{
    "04dc8272468e903ebae88b5145747003": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_reset(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\twant *Object\n\t}{\n\t\t{\n\t\t\tname: \"reset object\",\n\t\t\twant: &Object{\n\t\t\t\tkvs:           []kv{},\n\t\t\t\tkeysUnescaped: false,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\to := &Object{\n\t\t\t\tkvs:           []kv{{k: \"key1\", v: &Value{}}, {k: \"key2\", v: &Value{}}},\n\t\t\t\tkeysUnescaped: true,\n\t\t\t}\n\t\t\to.reset()\n\t\t\tif !compareFastjsonObject(o, tt.want) {\n\t\t\t\tt.Errorf(\"Object.reset() = %v, want %v\", o, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareFastjsonObject(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i := range o1.kvs {\n\t\tif o1.kvs[i].k != o2.kvs[i].k || o1.kvs[i].v != o2.kvs[i].v {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn o1.keysUnescaped == o2.keysUnescaped\n}",
    "030050b2471e57cd0d6c0d511578aae8": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWS(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"Empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"No leading whitespace\",\n\t\t\tinput:    \"hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Leading whitespace\",\n\t\t\tinput:    \"   hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Leading tab and space\",\n\t\t\tinput:    \"\\t  hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Leading newline\",\n\t\t\tinput:    \"\\nhello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Leading multiple whitespaces\",\n\t\t\tinput:    \"   \\t\\n   hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := skipWS(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"skipWS(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "04d6e97909589953719868a25b6e57cd": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple key\",\n\t\t\tinput:    `\"key\":`,\n\t\t\texpected: \"key\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"key with escape sequence\",\n\t\t\tinput:    `\"key\\\\\\\":`,\n\t\t\texpected: `key\\`,\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"key without closing quote\",\n\t\t\tinput:    `key:`,\n\t\t\texpected: \"key\",\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tkey, _, err := parseRawKey(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawKey() error = %v, wantErr %v\", err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif key != tc.expected {\n\t\t\t\tt.Errorf(\"parseRawKey() = %v, want %v\", key, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "04d0d806717ea36eb17f2b72144f32a0": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetBool(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\tkeys     []string\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname:     \"Existing bool value\",\n\t\t\tvalue:    &Value{t: TypeTrue},\n\t\t\tkeys:     []string{},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Non-existing keys path\",\n\t\t\tvalue:    &Value{t: TypeObject},\n\t\t\tkeys:     []string{\"foo\", \"bar\"},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid value type\",\n\t\t\tvalue:    &Value{t: TypeNumber},\n\t\t\tkeys:     []string{},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Array index in keys\",\n\t\t\tvalue:    &Value{a: []*Value{&Value{t: TypeTrue}}},\n\t\t\tkeys:     []string{\"0\"},\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := tc.value.GetBool(tc.keys...)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"GetBool(%v) = %v, expected %v\", tc.keys, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0144670a849d18faf8a4f3ce07fa7a09": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestObjectVisit(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected [][]byte\n\t}{\n\t\t{\n\t\t\tname:     \"empty object\",\n\t\t\tinput:    \"{}\",\n\t\t\texpected: [][]byte{},\n\t\t},\n\t\t{\n\t\t\tname:     \"object with single key-value pair\",\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: [][]byte{[]byte(\"key\")},\n\t\t},\n\t\t{\n\t\t\tname:     \"object with multiple key-value pairs\",\n\t\t\tinput:    `{\"key1\":\"value1\",\"key2\":\"value2\",\"key3\":\"value3\"}`,\n\t\t\texpected: [][]byte{[]byte(\"key1\"), []byte(\"key2\"), []byte(\"key3\")},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tv, err := Parse(tc.input)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t}\n\n\t\t\to, err := v.Object()\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t}\n\n\t\t\tvar keys [][]byte\n\t\t\to.Visit(func(key []byte, _ *Value) {\n\t\t\t\tkeys = append(keys, key)\n\t\t\t})\n\n\t\t\tif !reflect.DeepEqual(keys, tc.expected) {\n\t\t\t\tt.Errorf(\"expected keys %v, got %v\", tc.expected, keys)\n\t\t\t}\n\t\t})\n\t}\n}",
    "033e68fd7e13f2d9c2f9e28af7b159b4": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape sequences\",\n\t\t\tinput:    \"hello world\",\n\t\t\texpected: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Simple escape sequences\",\n\t\t\tinput:    \"hello\\\\\\\"world\\\\\\\\\",\n\t\t\texpected: \"hello\\\"world\\\\\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Unicode escape sequences\",\n\t\t\tinput:    \"hello\\\\u0041world\\\\u0042\",\n\t\t\texpected: \"helloAwordB\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Incomplete Unicode escape sequence\",\n\t\t\tinput:    \"hello\\\\u004\",\n\t\t\texpected: \"hello\\\\u004\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid Unicode escape sequence\",\n\t\t\tinput:    \"hello\\\\u123G\",\n\t\t\texpected: \"hello\\\\u123G\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Surrogate pairs\",\n\t\t\tinput:    \"hello\\\\uD83D\\\\uDE00world\",\n\t\t\texpected: \"helloüòÄworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Incomplete surrogate pair\",\n\t\t\tinput:    \"hello\\\\uD83D\",\n\t\t\texpected: \"hello\\\\uD83D\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid surrogate pair\",\n\t\t\tinput:    \"hello\\\\uD83D\\\\uZZZZ\",\n\t\t\texpected: \"hello\\\\uD83D\\\\uZZZZ\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "02a8269c4ee18a4fbb8c09411ab1841f": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Uint(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tv       *Value\n\t\twant    uint\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"valid uint\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42\",\n\t\t\t},\n\t\t\twant: 42,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid type\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"foo\",\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number doesn't fit uint\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"18446744073709551616\", // 2^64\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := tt.v.Uint()\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Value.Uint() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Value.Uint() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0579ad30148187ef9637d5bc4d216b67": "package fastjson\n\nimport (\n\t\"bytes\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestMarshalTo(t *testing.T) {\n\ttestCases := []struct {\n\t\tname   string\n\t\tinput  *Value\n\t\texpect []byte\n\t}{\n\t\t{\n\t\t\tname:   \"raw string\",\n\t\t\tinput:  &Value{t: typeRawString, s: \"hello\"},\n\t\t\texpect: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname:   \"object\",\n\t\t\tinput:  &Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}}, {k: \"key2\", v: &Value{t: TypeNumber, s: \"123\"}}}},\n\t\t\texpect: []byte(`{\"key1\":\"value1\",\"key2\":123}`),\n\t\t},\n\t\t{\n\t\t\tname:   \"array\",\n\t\t\tinput:  &Value{t: TypeArray, a: []*Value{{t: TypeString, s: \"str1\"}, {t: TypeNumber, s: \"123\"}, {t: TypeTrue}}},\n\t\t\texpect: []byte(`[\"str1\",123,true]`),\n\t\t},\n\t\t{\n\t\t\tname:   \"string\",\n\t\t\tinput:  &Value{t: TypeString, s: \"hello\\\"world\"},\n\t\t\texpect: []byte(`\"hello\\\"world\"`),\n\t\t},\n\t\t{\n\t\t\tname:   \"number\",\n\t\t\tinput:  &Value{t: TypeNumber, s: \"123.456\"},\n\t\t\texpect: []byte(\"123.456\"),\n\t\t},\n\t\t{\n\t\t\tname:   \"true\",\n\t\t\tinput:  &Value{t: TypeTrue},\n\t\t\texpect: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname:   \"false\",\n\t\t\tinput:  &Value{t: TypeFalse},\n\t\t\texpect: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname:   \"null\",\n\t\t\tinput:  &Value{t: TypeNull},\n\t\t\texpect: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname:   \"unknown type\",\n\t\t\tinput:  &Value{t: 99},\n\t\t\texpect: nil,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdst := make([]byte, 0, 100)\n\t\t\tgot := tc.input.MarshalTo(dst)\n\t\t\tif !bytes.Equal(got, tc.expect) {\n\t\t\t\tt.Errorf(\"MarshalTo(%+v) = %s, want %s\", tc.input, got, tc.expect)\n\t\t\t}\n\t\t})\n\t}\n}",
    "030088fada765edfb609350d13c2384f": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tinput   string\n\t\twantNum string\n\t\twantRem string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"valid number\",\n\t\t\tinput:   \"123.456e-7\",\n\t\t\twantNum: \"123.456e-7\",\n\t\t\twantRem: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with trailing characters\",\n\t\t\tinput:   \"123.456e-7abc\",\n\t\t\twantNum: \"123.456e-7\",\n\t\t\twantRem: \"abc\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading invalid character\",\n\t\t\tinput:   \"a123.456e-7\",\n\t\t\twantNum: \"\",\n\t\t\twantRem: \"a123.456e-7\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with invalid exponent\",\n\t\t\tinput:   \"123.456ex\",\n\t\t\twantNum: \"\",\n\t\t\twantRem: \"123.456ex\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"empty input\",\n\t\t\tinput:   \"\",\n\t\t\twantNum: \"\",\n\t\t\twantRem: \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"inf\",\n\t\t\tinput:   \"inf\",\n\t\t\twantNum: \"inf\",\n\t\t\twantRem: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"nan\",\n\t\t\tinput:   \"nan\",\n\t\t\twantNum: \"nan\",\n\t\t\twantRem: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNum, gotRem, gotErr := parseRawNumber(tt.input)\n\t\t\tif gotNum != tt.wantNum {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) gotNum = %q, want %q\", tt.input, gotNum, tt.wantNum)\n\t\t\t}\n\t\t\tif gotRem != tt.wantRem {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) gotRem = %q, want %q\", tt.input, gotRem, tt.wantRem)\n\t\t\t}\n\t\t\tif (gotErr != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %t\", tt.input, gotErr, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}",
    "033289b6ad4a2cc3c8f2036ab17e5a0b": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tinput   string\n\t\twantVal *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty array\",\n\t\t\tinput: \"[]\",\n\t\t\twantVal: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with values\",\n\t\t\tinput: \"[1, true, \\\"hello\\\"]\",\n\t\t\twantVal: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t\t{t: TypeString, s: \"hello\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with missing closing bracket\",\n\t\t\tinput: \"[1, true\",\n\t\t\twantVal: nil,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotVal, _, err := parseArray(tt.input, c, 0)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !testValueEqual(gotVal, tt.wantVal) {\n\t\t\t\tt.Errorf(\"parseArray() = %v, want %v\", gotVal, tt.wantVal)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc testValueEqual(a, b *Value) bool {\n\tif a == nil && b == nil {\n\t\treturn true\n\t}\n\tif a == nil || b == nil {\n\t\treturn false\n\t}\n\tif a.t != b.t {\n\t\treturn false\n\t}\n\tswitch a.t {\n\tcase TypeObject:\n\t\treturn true // not implemented\n\tcase TypeArray:\n\t\tif len(a.a) != len(b.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, v := range a.a {\n\t\t\tif !testValueEqual(v, b.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeString:\n\t\treturn a.s == b.s\n\tcase TypeNumber, TypeTrue, TypeFalse:\n\t\treturn a.s == b.s\n\tdefault:\n\t\treturn false\n\t}\n}",
    "00278ae3692fa09d9f958ad63beba116": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestExists(t *testing.T) {\n\tt.Run(\"Existing field\", func(t *testing.T) {\n\t\tv := &Value{\n\t\t\to: Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"field1\", v: &Value{s: \"value1\"}},\n\t\t\t\t\t{k: \"field2\", v: &Value{s: \"value2\"}},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\n\t\tif !v.Exists(\"field1\") {\n\t\t\tt.Errorf(\"Expect field1 to exist\")\n\t\t}\n\t})\n\n\tt.Run(\"Non-existing field\", func(t *testing.T) {\n\t\tv := &Value{\n\t\t\to: Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"field1\", v: &Value{s: \"value1\"}},\n\t\t\t\t\t{k: \"field2\", v: &Value{s: \"value2\"}},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\n\t\tif v.Exists(\"field3\") {\n\t\t\tt.Errorf(\"Expect field3 to not exist\")\n\t\t}\n\t})\n\n\tt.Run(\"Nested field\", func(t *testing.T) {\n\t\tv := &Value{\n\t\t\to: Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"field1\", v: &Value{\n\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t{k: \"subfield1\", v: &Value{s: \"value1\"}},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t}},\n\t\t\t\t\t{k: \"field2\", v: &Value{s: \"value2\"}},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\n\t\tif !v.Exists(\"field1\", \"subfield1\") {\n\t\t\tt.Errorf(\"Expect field1.subfield1 to exist\")\n\t\t}\n\t})\n\n\tt.Run(\"Nested field not found\", func(t *testing.T) {\n\t\tv := &Value{\n\t\t\to: Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"field1\", v: &Value{\n\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t{k: \"subfield1\", v: &Value{s: \"value1\"}},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t}},\n\t\t\t\t\t{k: \"field2\", v: &Value{s: \"value2\"}},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\n\t\tif v.Exists(\"field1\", \"subfield2\") {\n\t\t\tt.Errorf(\"Expect field1.subfield2 to not exist\")\n\t\t}\n\t})\n\n\tt.Run(\"Nil value\", func(t *testing.T) {\n\t\tvar v *Value\n\t\tif v.Exists(\"field\") {\n\t\t\tt.Errorf(\"Expect nil value to not exist\")\n\t\t}\n\t})\n}",
    "05f386d6426b2ba51ab1618802020780": "package fastjson\n\nimport (\n    \"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n    testCases := []struct {\n        name     string\n        input    string\n        expected string\n    }{\n        {\n            name:     \"No escape characters\",\n            input:    \"hello, world\",\n            expected: \"hello, world\",\n        },\n        {\n            name:     \"Simple escape characters\",\n            input:    \"hello, \\\\\\\"world\\\\\\\"\",\n            expected: `hello, \"world\"`,\n        },\n        {\n            name:     \"Unicode escape characters\",\n            input:    \"hello, \\\\u2603 world\",\n            expected: \"hello, ‚òÉ world\",\n        },\n        {\n            name:     \"Surrogate pair escape characters\",\n            input:    \"hello, \\\\uD835\\\\uDD60 world\",\n            expected: \"hello, ùí† world\",\n        },\n        {\n            name:     \"Invalid escape characters\",\n            input:    \"hello, \\\\x world\",\n            expected: \"hello, \\\\x world\",\n        },\n    }\n\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            result := unescapeStringBestEffort(tc.input)\n            if result != tc.expected {\n                t.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", tc.input, result, tc.expected)\n            }\n        })\n    }\n}",
    "07b09c2d02a2a43bf3bdfe6d215f6090": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestInt(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    *Value\n\t\texpected int\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"Valid integer\",\n\t\t\tinput:    &Value{s: \"42\", t: TypeNumber},\n\t\t\texpected: 42,\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Non-number type\",\n\t\t\tinput:    &Value{s: \"true\", t: TypeTrue},\n\t\t\texpected: 0,\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Number out of int range\",\n\t\t\tinput:    &Value{s: \"9223372036854775807\", t: TypeNumber},\n\t\t\texpected: 0,\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid number\",\n\t\t\tinput:    &Value{s: \"invalid\", t: TypeNumber},\n\t\t\texpected: 0,\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot, err := tc.input.Int()\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"Int() error = %v, wantErr %v\", err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tc.expected {\n\t\t\t\tt.Errorf(\"Int() = %v, want %v\", got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0939d19a198a44e82a69f74a6213352e": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: []string{\"hello\", \"\"},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello\\\"world\"`,\n\t\t\texpected: []string{\"hello\\\"world\", \"\"},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello\\\"world\\\"foo\"`,\n\t\t\texpected: []string{\"hello\\\"world\\\"foo\", \"\"},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with no closing quote\",\n\t\t\tinput:    `\"hello`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\terr:      fmt.Errorf(`missing closing '\"'`),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult, rest, err := parseRawString(tc.input)\n\t\t\tif err != nil && tc.err == nil {\n\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t}\n\t\t\tif err == nil && tc.err != nil {\n\t\t\t\tt.Errorf(\"expected error: %v\", tc.err)\n\t\t\t}\n\t\t\tif err != nil && tc.err != nil && err.Error() != tc.err.Error() {\n\t\t\t\tt.Errorf(\"error mismatch, expected: %v, got: %v\", tc.err, err)\n\t\t\t}\n\t\t\tif result != tc.expected[0] {\n\t\t\t\tt.Errorf(\"result mismatch, expected: %s, got: %s\", tc.expected[0], result)\n\t\t\t}\n\t\t\tif rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"rest mismatch, expected: %s, got: %s\", tc.expected[1], rest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "05d5d41f64663ccd061a86a2c50439e7": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantKey  string\n\t\twantRest string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"no closing quote\",\n\t\t\tinput:    `\"hello`,\n\t\t\twantErr:  true,\n\t\t\twantKey:  \"\",\n\t\t\twantRest: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"no escape\",\n\t\t\tinput:    `\"hello world\"`,\n\t\t\twantKey:  \"hello world\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"with escape\",\n\t\t\tinput:    `\"hello \\\"world\\\"\"`,\n\t\t\twantKey:  `hello \"world\"`,\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"with trailing\",\n\t\t\tinput:    `\"hello\"world`,\n\t\t\twantKey:  \"hello\",\n\t\t\twantRest: \"world\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"with escape and trailing\",\n\t\t\tinput:    `\"hello \\\"world\\\"\"other`,\n\t\t\twantKey:  `hello \"world\"`,\n\t\t\twantRest: \"other\",\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tkey, rest, err := parseRawString(tt.input)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif key != tt.wantKey {\n\t\t\t\tt.Errorf(\"parseRawString() key = %v, want %v\", key, tt.wantKey)\n\t\t\t}\n\t\t\tif rest != tt.wantRest {\n\t\t\t\tt.Errorf(\"parseRawString() rest = %v, want %v\", rest, tt.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0caf733fa5305edee132705c431f4cb5": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Uint(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tv       *Value\n\t\twant    uint\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"valid uint\",\n\t\t\tv:    &Value{s: \"42\", t: TypeNumber},\n\t\t\twant: 42,\n\t\t},\n\t\t{\n\t\t\tname:    \"non-number type\",\n\t\t\tv:       &Value{t: TypeString},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number\",\n\t\t\tv:       &Value{s: \"not a number\", t: TypeNumber},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"number out of uint range\",\n\t\t\tv:       &Value{s: \"18446744073709551616\", t: TypeNumber},\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := tt.v.Uint()\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Value.Uint() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Value.Uint() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0d8972029cfd570b7b6fadd35e2a9a42": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestType(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tv        *Value\n\t\texpected Type\n\t}{\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\texpected: TypeNull,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\texpected: TypeObject,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\texpected: TypeArray,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeString,\n\t\t\t},\n\t\t\texpected: TypeString,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\texpected: TypeNumber,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\texpected: TypeTrue,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\texpected: TypeFalse,\n\t\t},\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: &Value{\n\t\t\t\tt:       typeRawString,\n\t\t\t\ts:       \"hello\",\n\t\t\t},\n\t\t\texpected: TypeString,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tif got := tc.v.Type(); got != tc.expected {\n\t\t\t\tt.Errorf(\"Type() = %v, want %v\", got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "038822c39cb85eb822913d7b1c215e0d": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname       string\n\t\tinput      string\n\t\twantValue  *Value\n\t\twantTail   string\n\t\twantErr    error\n\t\tmaxDepth   int\n\t\twantErrMsg string\n\t}{\n\t\t{\n\t\t\tname:      \"empty input\",\n\t\t\tinput:     \"\",\n\t\t\twantValue: nil,\n\t\t\twantTail:  \"\",\n\t\t\twantErr:   fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:      \"depth exceeds maximum\",\n\t\t\tinput:     `{\"key\": 123}`,\n\t\t\tmaxDepth:  1,\n\t\t\twantValue: nil,\n\t\t\twantTail:  `{\"key\": 123}`,\n\t\t\twantErr:   fmt.Errorf(\"too big depth for the nested JSON; it exceeds 1\"),\n\t\t},\n\t\t{\n\t\t\tname:       \"valid object\",\n\t\t\tinput:      `{\"key\": 123}`,\n\t\t\tmaxDepth:   10,\n\t\t\twantValue:  &Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: &Value{t: TypeNumber, s: \"123\"}}}}},\n\t\t\twantTail:   \"\",\n\t\t\twantErr:    nil,\n\t\t},\n\t\t{\n\t\t\tname:       \"valid array\",\n\t\t\tinput:      `[1, 2, 3]`,\n\t\t\tmaxDepth:   10,\n\t\t\twantValue:  &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}, &Value{t: TypeNumber, s: \"2\"}, &Value{t: TypeNumber, s: \"3\"}}},\n\t\t\twantTail:   \"\",\n\t\t\twantErr:    nil,\n\t\t},\n\t\t{\n\t\t\tname:       \"valid string\",\n\t\t\tinput:      `\"hello\"`,\n\t\t\tmaxDepth:   10,\n\t\t\twantValue:  &Value{t: typeRawString, s: \"hello\"},\n\t\t\twantTail:   \"\",\n\t\t\twantErr:    nil,\n\t\t},\n\t\t{\n\t\t\tname:       \"valid true\",\n\t\t\tinput:      \"true\",\n\t\t\tmaxDepth:   10,\n\t\t\twantValue:  valueTrue,\n\t\t\twantTail:   \"\",\n\t\t\twantErr:    nil,\n\t\t},\n\t\t{\n\t\t\tname:       \"valid false\",\n\t\t\tinput:      \"false\",\n\t\t\tmaxDepth:   10,\n\t\t\twantValue:  valueFalse,\n\t\t\twantTail:   \"\",\n\t\t\twantErr:    nil,\n\t\t},\n\t\t{\n\t\t\tname:       \"valid null\",\n\t\t\tinput:      \"null\",\n\t\t\tmaxDepth:   10,\n\t\t\twantValue:  valueNull,\n\t\t\twantTail:   \"\",\n\t\t\twantErr:    nil,\n\t\t},\n\t\t{\n\t\t\tname:       \"valid number\",\n\t\t\tinput:      \"123\",\n\t\t\tmaxDepth:   10,\n\t\t\twantValue:  &Value{t: TypeNumber, s: \"123\"},\n\t\t\twantTail:   \"\",\n\t\t\twantErr:    nil,\n\t\t},\n\t\t{\n\t\t\tname:       \"invalid value\",\n\t\t\tinput:      \"invalid\",\n\t\t\tmaxDepth:   10,\n\t\t\twantValue:  nil,\n\t\t\twantTail:   \"invalid\",\n\t\t\twantErr:    fmt.Errorf(\"unexpected value found: %q\", \"invalid\"),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tvalue, tail, err := parseValue(tc.input, c, tc.maxDepth)\n\t\t\tif tc.wantErr != nil {\n\t\t\t\tif err == nil || err.Error() != tc.wantErrMsg {\n\t\t\t\t\tt.Errorf(\"parseValue(%q, %d) = (%v, %q, %v), want (%v, %q, %v)\", tc.input, tc.maxDepth, value, tail, err, tc.wantValue, tc.wantTail, tc.wantErr)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif !equalValues(value, tc.wantValue) || tail != tc.wantTail || err != tc.wantErr {\n\t\t\t\t\tt.Errorf(\"parseValue(%q, %d) = (%v, %q, %v), want (%v, %q, %v)\", tc.input, tc.maxDepth, value, tail, err, tc.wantValue, tc.wantTail, tc.wantErr)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\to1, _ := v1.Object()\n\t\to2, _ := v2.Object()\n\t\tif len(o1.kvs) != len(o2.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, kv1 := range o1.kvs {\n\t\t\tkv2 := o2.kvs[i]\n\t\t\tif kv1.k != kv2.k || !equalValues(kv1.v, kv2.v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeArray:\n\t\ta1, _ := v1.Array()\n\t\ta2, _ := v2.Array()\n\t\tif len(a1) != len(a2) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, v1 := range a1 {\n\t\t\tif !equalValues(v1, a2[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeString, TypeNumber, TypeTrue, TypeFalse, typeRawString:\n\t\treturn v1.s == v2.s\n\tcase TypeNull:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}",
    "0cd53799171f8eab7a7786371d5f8f6a": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantNum  string\n\t\twantRest string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.456e+7\",\n\t\t\twantNum:  \"123.456e+7\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with trailing non-numeric characters\",\n\t\t\tinput:    \"123.456abc\",\n\t\t\twantNum:  \"123.456\",\n\t\t\twantRest: \"abc\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number\",\n\t\t\tinput:    \"abc123\",\n\t\t\twantNum:  \"\",\n\t\t\twantRest: \"abc123\",\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with 'inf' suffix\",\n\t\t\tinput:    \"inf\",\n\t\t\twantNum:  \"inf\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with 'nan' suffix\",\n\t\t\tinput:    \"nan\",\n\t\t\twantNum:  \"nan\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty input\",\n\t\t\tinput:    \"\",\n\t\t\twantNum:  \"\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif num != tc.wantNum {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) num = %q, want %q\", tc.input, num, tc.wantNum)\n\t\t\t}\n\n\t\t\tif rest != tc.wantRest {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) rest = %q, want %q\", tc.input, rest, tc.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0ac5d665a06f3aea0c44fc787c1e6312": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: `{}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"simple object\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":123}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with whitespace\",\n\t\t\tinput: `{  \"key1\"  :  \"value1\"  ,  \"key2\"  :  123  }`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":123`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing key\",\n\t\t\tinput: `{:123}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing colon\",\n\t\t\tinput: `{\"key1\" \"value1\"}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing comma\",\n\t\t\tinput: `{\"key1\":\"value1\" \"key2\":123}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tactual, _, err := parseObject(tt.input, c, 0)\n\t\t\tif (err != nil) != tt.err {\n\t\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", tt.input, err, tt.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(actual, tt.expected) {\n\t\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", tt.input, actual, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "09ab002c025559c976b4c2b3658e55f7": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\thasError bool\n\t}{\n\t\t{\n\t\t\tname:     \"Valid JSON\",\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 42}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{s: \"value1\", t: TypeString}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{s: \"42\", t: TypeNumber}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\thasError: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid JSON\",\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 42,}`,\n\t\t\texpected: nil,\n\t\t\thasError: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Empty Input\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\thasError: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tp := &Parser{}\n\t\t\tresult, err := p.Parse(tc.input)\n\t\t\tif (err != nil) != tc.hasError {\n\t\t\t\tt.Errorf(\"Parse(%q) error = %v, expected error: %v\", tc.input, err, tc.hasError)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !valuesEqual(result, tc.expected) {\n\t\t\t\tt.Errorf(\"Parse(%q) = %v, expected %v\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc valuesEqual(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\to1, _ := v1.Object()\n\t\to2, _ := v2.Object()\n\t\tif len(o1.kvs) != len(o2.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, kv1 := range o1.kvs {\n\t\t\tkv2 := o2.kvs[i]\n\t\t\tif kv1.k != kv2.k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !valuesEqual(kv1.v, kv2.v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeArray:\n\t\ta1, _ := v1.Array()\n\t\ta2, _ := v2.Array()\n\t\tif len(a1) != len(a2) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, v := range a1 {\n\t\t\tif !valuesEqual(v, a2[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeString:\n\t\ts1, _ := v1.StringBytes()\n\t\ts2, _ := v2.StringBytes()\n\t\treturn string(s1) == string(s2)\n\tcase TypeNumber:\n\t\tn1, _ := v1.Int64()\n\t\tn2, _ := v2.Int64()\n\t\treturn n1 == n2\n\tcase TypeTrue, TypeFalse:\n\t\tb1, _ := v1.Bool()\n\t\tb2, _ := v2.Bool()\n\t\treturn b1 == b2\n\tcase TypeNull:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}",
    "0b937229edec31861deb151c4b2bde02": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty array\",\n\t\t\tinput: \"[]\",\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with one element\",\n\t\t\tinput: \"[1]\",\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with multiple elements\",\n\t\t\tinput: \"[1, 2, 3]\",\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with trailing comma\",\n\t\t\tinput: \"[1, 2, 3,]\",\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with missing closing bracket\",\n\t\t\tinput: \"[1, 2, 3\",\n\t\t\terr:   true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tv, _, err := parseArray(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseArray(%q) error = %v, want error: %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif err == nil && !v.equal(tc.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", tc.input, v, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc (v *Value) equal(other *Value) bool {\n\tif v.t != other.t {\n\t\treturn false\n\t}\n\n\tswitch v.t {\n\tcase TypeArray:\n\t\tif len(v.a) != len(other.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, elem := range v.a {\n\t\t\tif !elem.equal(other.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\tcase TypeString:\n\t\treturn v.s == other.s\n\tcase TypeNumber:\n\t\treturn v.s == other.s\n\tcase TypeTrue, TypeFalse, TypeNull:\n\t\treturn true\n\tdefault:\n\t\tpanic(\"unsupported type\")\n\t}\n\n\treturn true\n}",
    "0a78ec200670858320d02e398f83adb6": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname    string\n\t\tinput   string\n\t\twantVal *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty input\",\n\t\t\tinput: \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"max depth exceeded\",\n\t\t\tinput: \"{}\", // depth will be 1\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"valid object\",\n\t\t\tinput: `{\"key\":\"value\"}`,\n\t\t\twantVal: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{s: \"value\", t: typeRawString}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"valid array\",\n\t\t\tinput: `[1,2,3]`,\n\t\t\twantVal: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"1\", t: TypeNumber},\n\t\t\t\t\t{s: \"2\", t: TypeNumber},\n\t\t\t\t\t{s: \"3\", t: TypeNumber},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"valid string\",\n\t\t\tinput: `\"hello\"`,\n\t\t\twantVal: &Value{\n\t\t\t\ts: \"hello\",\n\t\t\t\tt: typeRawString,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"valid true\",\n\t\t\tinput: \"true\",\n\t\t\twantVal: valueTrue,\n\t\t},\n\t\t{\n\t\t\tname:  \"valid false\",\n\t\t\tinput: \"false\",\n\t\t\twantVal: valueFalse,\n\t\t},\n\t\t{\n\t\t\tname:  \"valid null\",\n\t\t\tinput: \"null\",\n\t\t\twantVal: valueNull,\n\t\t},\n\t\t{\n\t\t\tname:  \"valid number\",\n\t\t\tinput: \"42\",\n\t\t\twantVal: &Value{\n\t\t\t\ts: \"42\",\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgotVal, _, err := parseValue(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !equalValues(gotVal, tc.wantVal) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", tc.input, gotVal, tc.wantVal)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(a, b *Value) bool {\n\tif a == nil && b == nil {\n\t\treturn true\n\t}\n\tif a == nil || b == nil {\n\t\treturn false\n\t}\n\tif a.t != b.t {\n\t\treturn false\n\t}\n\tswitch a.t {\n\tcase TypeObject:\n\t\taObj, _ := a.Object()\n\t\tbObj, _ := b.Object()\n\t\treturn equalObjects(aObj, bObj)\n\tcase TypeArray:\n\t\taArr, _ := a.Array()\n\t\tbArr, _ := b.Array()\n\t\tif len(aArr) != len(bArr) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range aArr {\n\t\t\tif !equalValues(aArr[i], bArr[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase typeRawString:\n\t\treturn a.s == b.s\n\tcase TypeNumber, TypeTrue, TypeFalse, TypeNull:\n\t\treturn a.s == b.s\n\tdefault:\n\t\tpanic(\"unknown type\")\n\t}\n}\n\nfunc equalObjects(a, b *Object) bool {\n\tif a == nil && b == nil {\n\t\treturn true\n\t}\n\tif a == nil || b == nil {\n\t\treturn false\n\t}\n\tif len(a.kvs) != len(b.kvs) {\n\t\treturn false\n\t}\n\tfor i := range a.kvs {\n\t\tif a.kvs[i].k != b.kvs[i].k {\n\t\t\treturn false\n\t\t}\n\t\tif !equalValues(a.kvs[i].v, b.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "0e2fc36867a75303a40fd010715ca652": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\ttestCases := []struct {\n\t\tname      string\n\t\tinput     string\n\t\twantValue *Value\n\t\twantErr   bool\n\t}{\n\t\t{\n\t\t\tname:  \"valid JSON\",\n\t\t\tinput: `{\"key1\": \"value1\", \"key2\": 42}`,\n\t\t\twantValue: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{s: \"value1\", t: TypeString}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{s: \"42\", t: TypeNumber}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:      \"invalid JSON\",\n\t\t\tinput:     `{\"key1\": \"value1\", \"key2\"`,\n\t\t\twantValue: nil,\n\t\t\twantErr:   true,\n\t\t},\n\t\t{\n\t\t\tname:      \"empty input\",\n\t\t\tinput:     \"\",\n\t\t\twantValue: nil,\n\t\t\twantErr:   true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tp := &Parser{}\n\t\t\tgotValue, err := p.Parse(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"Parse(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !reflect.DeepEqual(gotValue, tc.wantValue) {\n\t\t\t\tt.Errorf(\"Parse(%q) = %v, want %v\", tc.input, gotValue, tc.wantValue)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0e9eb289cd868b9e3366eb39a10000e2": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"empty array\",\n\t\t\tinput:    \"[]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{}},\n\t\t},\n\t\t{\n\t\t\tname:     \"array with values\",\n\t\t\tinput:    \"[1, true, \\\"hello\\\"]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}, &Value{t: TypeTrue}, &Value{t: TypeString, s: \"hello\"}}},\n\t\t},\n\t\t{\n\t\t\tname:  \"missing closing bracket\",\n\t\t\tinput: \"[1, 2, 3\",\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"missing comma\",\n\t\t\tinput: \"[1 2]\",\n\t\t\terr:   true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tv, _, err := parseArray(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseArray(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !v.Equal(tc.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", tc.input, v, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0f26a105e8a6525daf65d26615bb027c": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tinput string\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"no escape characters\",\n\t\t\tinput: \"this is a test string\",\n\t\t\twant: \"this is a test string\",\n\t\t},\n\t\t{\n\t\t\tname: \"simple escape characters\",\n\t\t\tinput: \"this is a \\\"quoted\\\" string with a \\\\backslash\\\\\",\n\t\t\twant: `this is a \"quoted\" string with a \\backslash\\`,\n\t\t},\n\t\t{\n\t\t\tname: \"unicode escape characters\",\n\t\t\tinput: \"this string has a \\\\u2764 unicode character\",\n\t\t\twant: \"this string has a ‚ô• unicode character\",\n\t\t},\n\t\t{\n\t\t\tname: \"complex unicode escape characters\",\n\t\t\tinput: \"this string has a \\\\ud83d\\\\ude00 unicode character\",\n\t\t\twant: \"this string has a üòÄ unicode character\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid unicode escape characters\",\n\t\t\tinput: \"this string has an \\\\u123 invalid unicode character\",\n\t\t\twant: \"this string has an \\\\u123 invalid unicode character\",\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := unescapeStringBestEffort(test.input)\n\t\t\tif got != test.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", test.input, got, test.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0dd52c43968564e6763558b0b79bfa78": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tinput   string\n\t\twant    *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty string\",\n\t\t\tinput: \"\",\n\t\t\twant:  nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"too big depth\",\n\t\t\tinput: \"{\\\"key\\\":1}\",\n\t\t\twant:  nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"parse object\",\n\t\t\tinput: \"{\\\"key\\\":1}\",\n\t\t\twant: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"parse array\",\n\t\t\tinput: \"[1,2,3]\",\n\t\t\twant: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"parse string\",\n\t\t\tinput: `\"hello\"`,\n\t\t\twant: &Value{\n\t\t\t\ts: \"hello\",\n\t\t\t\tt: TypeString,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"parse true\",\n\t\t\tinput: \"true\",\n\t\t\twant: &Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"parse false\",\n\t\t\tinput: \"false\",\n\t\t\twant: &Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"parse null\",\n\t\t\tinput: \"null\",\n\t\t\twant: &Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"parse number\",\n\t\t\tinput: \"123\",\n\t\t\twant: &Value{\n\t\t\t\ts: \"123\",\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseValue(tt.input, c, 0)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0f616e71d39628a3904565c42de8b8bc": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCache_getValue(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tc    *cache\n\t\twant *Value\n\t}{\n\t\t{\n\t\t\tname: \"empty cache\",\n\t\t\tc:    &cache{},\n\t\t\twant: &Value{},\n\t\t},\n\t\t{\n\t\t\tname: \"cache with existing values\",\n\t\t\tc: &cache{\n\t\t\t\tvs: []Value{\n\t\t\t\t\t{},\n\t\t\t\t\t{},\n\t\t\t\t\t{},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: &Value{},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.c.getValue(); !compareValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"cache.getValue() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.o != v2.o || v1.s != v2.s || v1.t != v2.t {\n\t\treturn false\n\t}\n\tif len(v1.a) != len(v2.a) {\n\t\treturn false\n\t}\n\tfor i := range v1.a {\n\t\tif !compareValues(v1.a[i], v2.a[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "102240021d6c63d042cc29f0cf5c3c80": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_getKV(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\to    *Object\n\t\twant *kv\n\t}{\n\t\t{\n\t\t\tname: \"empty kvs\",\n\t\t\to:    &Object{},\n\t\t\twant: &kv{},\n\t\t},\n\t\t{\n\t\t\tname: \"kvs with capacity\",\n\t\t\to: &Object{\n\t\t\t\tkvs: make([]kv, 1, 2),\n\t\t\t},\n\t\t\twant: &kv{},\n\t\t},\n\t\t{\n\t\t\tname: \"kvs with length equal to capacity\",\n\t\t\to: &Object{\n\t\t\t\tkvs: make([]kv, 2, 2),\n\t\t\t},\n\t\t\twant: &kv{},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.o.getKV(); !(*got == *tt.want) {\n\t\t\t\tt.Errorf(\"Object.getKV() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0e137cd85ee0d22389c92c89df6ce95f": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: \"{}\",\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{},\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with one key-value pair\",\n\t\t\tinput: `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{t: TypeString, s: \"value\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with multiple key-value pairs\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":123,\"key3\":true}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t\t{k: \"key3\", v: &Value{t: TypeTrue}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\tinput: `{\"key1\":\"value1\",`,\n\t\t\texpected: nil,\n\t\t\terr:      nil, // The error will be returned by the parseObject function\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tresult, _, err := parseObject(tc.input, c, 0)\n\t\t\tif err != nil && tc.err == nil {\n\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err == nil && tc.err != nil {\n\t\t\t\tt.Errorf(\"expected error: %v\", tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !equal(result, tc.expected) {\n\t\t\t\tt.Errorf(\"expected %+v, got %+v\", tc.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equal(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn equalObject(v1.o, v2.o)\n\tcase TypeArray:\n\t\treturn equalArray(v1.a, v2.a)\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber, TypeTrue, TypeFalse:\n\t\treturn v1.s == v2.s\n\tcase TypeNull:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc equalObject(o1, o2 Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !equal(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc equalArray(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tif !equal(v1, a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "13ac2e84e94bb35e0a1906d0f00aa5aa": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tinput string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname: \"No escape characters\",\n\t\t\tinput: \"hello world\",\n\t\t\texpected: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"Single escape character\",\n\t\t\tinput: \"hello\\\\world\",\n\t\t\texpected: \"helloworld\",\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple escape characters\",\n\t\t\tinput: \"hello\\\\\\\"world\\\\\\\\\",\n\t\t\texpected: \"hello\\\"world\\\\\",\n\t\t},\n\t\t{\n\t\t\tname: \"Escape sequences\",\n\t\t\tinput: \"hello\\\\n\\\\t\\\\u0041world\",\n\t\t\texpected: \"hello\\n\\tAworld\",\n\t\t},\n\t\t{\n\t\t\tname: \"Invalid escape sequence\",\n\t\t\tinput: \"hello\\\\uabcd\\\\world\",\n\t\t\texpected: \"hello\\\\uabcd\\\\world\",\n\t\t},\n\t\t{\n\t\t\tname: \"Surrogate pairs\",\n\t\t\tinput: \"hello\\\\uD834\\\\uDD1Eworld\",\n\t\t\texpected: \"helloùÑûworld\",\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(test.input)\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", test.input, result, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "148ad80a180eea71a492d6b0b24097d2": "package fastjson\n\nimport (\n    \"reflect\"\n    \"testing\"\n)\n\nfunc TestValue_GetStringBytes(t *testing.T) {\n    tests := []struct {\n        name   string\n        v      *Value\n        keys   []string\n        want   []byte\n        wantNil bool\n    }{\n        {\n            name: \"string value\",\n            v: &Value{\n                s: \"hello\",\n                t: TypeString,\n            },\n            keys: []string{\"key\"},\n            want: []byte(\"hello\"),\n        },\n        {\n            name: \"non-string value\",\n            v: &Value{\n                i: 42,\n                t: TypeNumber,\n            },\n            keys: []string{\"key\"},\n            wantNil: true,\n        },\n        {\n            name: \"nil value\",\n            v:    nil,\n            keys: []string{\"key\"},\n            wantNil: true,\n        },\n    }\n\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            got := tt.v.GetStringBytes(tt.keys...)\n            if (got == nil) != tt.wantNil {\n                t.Errorf(\"Value.GetStringBytes() = %v, want %v\", got, tt.want)\n                return\n            }\n            if !tt.wantNil && !reflect.DeepEqual(got, tt.want) {\n                t.Errorf(\"Value.GetStringBytes() = %v, want %v\", got, tt.want)\n            }\n        })\n    }\n}",
    "127578a71a6a36cc5701f713d549647a": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"simple object\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: \"{}\",\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"missing closing brace\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:  \"missing key\",\n\t\t\tinput: `{\"key1\":\"value1\",:\"value2\"}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:  \"missing value separator\",\n\t\t\tinput: `{\"key1\":\"value1\" \"key2\":42}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:  \"missing value\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tv, _, err := parseObject(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(v, tc.expected) {\n\t\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", tc.input, v, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "10bbc6828a6fc03332fc16f5cfb25807": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"12.34\",\n\t\t\texpected: []string{\"12.34\", \"\"},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with exponent\",\n\t\t\tinput:    \"1.2e+3\",\n\t\t\texpected: []string{\"1.2e+3\", \"\"},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with negative exponent\",\n\t\t\tinput:    \"1.2e-3\",\n\t\t\texpected: []string{\"1.2e-3\", \"\"},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with leading and trailing whitespace\",\n\t\t\tinput:    \"  12.34  \",\n\t\t\texpected: []string{\"12.34\", \"  \"},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number with leading character\",\n\t\t\tinput:    \"a12.34\",\n\t\t\texpected: []string{\"\", \"a12.34\"},\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number with trailing character\",\n\t\t\tinput:    \"12.34a\",\n\t\t\texpected: []string{\"12.34\", \"a\"},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number with only special characters\",\n\t\t\tinput:    \"-+.\",\n\t\t\texpected: []string{\"\", \"-+.\"},\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid infinity\",\n\t\t\tinput:    \"inf\",\n\t\t\texpected: []string{\"inf\", \"\"},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid negative infinity\",\n\t\t\tinput:    \"-inf\",\n\t\t\texpected: []string{\"-inf\", \"\"},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid NaN\",\n\t\t\tinput:    \"nan\",\n\t\t\texpected: []string{\"nan\", \"\"},\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, remaining, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) expected error %t, got %v\", tc.input, tc.err, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.expected[0] || remaining != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = (%q, %q), want (%q, %q)\", tc.input, num, remaining, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "15857d05467c9fab2c5649930ceed954": "package fastjson\n\nimport \"testing\"\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"no whitespace\",\n\t\t\tinput:    \"hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading whitespace\",\n\t\t\tinput:    \"   hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"trailing whitespace\",\n\t\t\tinput:    \"hello   \",\n\t\t\texpected: \"hello   \",\n\t\t},\n\t\t{\n\t\t\tname:     \"mixed whitespace\",\n\t\t\tinput:    \"   hello\\t world\\r\\n\",\n\t\t\texpected: \"hello\\t world\\r\\n\",\n\t\t},\n\t\t{\n\t\t\tname:     \"all whitespace\",\n\t\t\tinput:    \"   \\t\\r\\n\",\n\t\t\texpected: \"\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := skipWSSlow(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"skipWSSlow(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "14c58917c9d82fa6db5387dd24350ac4": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts     string\n\t\tc     *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t// Add your test cases here\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:     \"\",\n\t\t\t\tc:     &cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"max depth exceeded\",\n\t\t\targs: args{\n\t\t\t\ts:     \"{}\", // any valid JSON string\n\t\t\t\tc:     &cache{},\n\t\t\t\tdepth: MaxDepth + 1,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"{}\", // the original input string\n\t\t\twantErr: true,\n\t\t},\n\t\t// Add more test cases as needed\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseValue() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "1490d6cb217dd451490dc28ee87e21f0": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantNum  string\n\t\twantRest string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.45e+6\",\n\t\t\twantNum:  \"123.45e+6\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with sign\",\n\t\t\tinput:    \"-0.123\",\n\t\t\twantNum:  \"-0.123\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with 'inf'\",\n\t\t\tinput:    \"inf\",\n\t\t\twantNum:  \"inf\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with 'nan'\",\n\t\t\tinput:    \"nan\",\n\t\t\twantNum:  \"nan\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number\",\n\t\t\tinput:    \"123a\",\n\t\t\twantNum:  \"\",\n\t\t\twantRest: \"123a\",\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty input\",\n\t\t\tinput:    \"\",\n\t\t\twantNum:  \"\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.wantNum {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) num = %q, want %q\", tc.input, num, tc.wantNum)\n\t\t\t}\n\t\t\tif rest != tc.wantRest {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) rest = %q, want %q\", tc.input, rest, tc.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "14fbe10b0680f4221116e7b1870b9a89": "package fastjson_test\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"empty array\",\n\t\t\tinput:    \"[]\",\n\t\t\texpected: \"[]\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with values\",\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: \"[1, 2, 3]\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with whitespace\",\n\t\t\tinput:    \"[ 1 , 2 , 3 ]\",\n\t\t\texpected: \"[1, 2, 3]\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with missing closing bracket\",\n\t\t\tinput:    \"[1, 2, 3\",\n\t\t\texpected: \"\",\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with missing comma\",\n\t\t\tinput:    \"[1 2, 3]\",\n\t\t\texpected: \"\",\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tv, _, err := parseArray(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseArray(%q) error = %v, wantErr %t\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err == nil && v.String() != tc.expected {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %s, want %s\", tc.input, v.String(), tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "15a1bd9c4cb7d2c8250487d176211055": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tinput string\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"no escape characters\",\n\t\t\tinput: \"hello, world\",\n\t\t\twant: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname: \"simple escape characters\",\n\t\t\tinput: \"hello\\\\\\\"world\\\\\\\\test\",\n\t\t\twant: \"hello\\\"world\\\\test\",\n\t\t},\n\t\t{\n\t\t\tname: \"unicode escape characters\",\n\t\t\tinput: \"hello\\\\u0020world\\\\u0021\",\n\t\t\twant: \"hello world!\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid unicode escape characters\",\n\t\t\tinput: \"hello\\\\u001world\\\\u0\",\n\t\t\twant: \"hello\\\\u001world\\\\u0\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape characters\",\n\t\t\tinput: \"hello\\\\\\\"\\\\\\\\world\\\\n\\\\t\",\n\t\t\twant: \"hello\\\"\\\\world\\n\\t\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := unescapeStringBestEffort(tt.input)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", tt.input, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "131c5e909188ccddbdbc641839726007": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype testCase struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}\n\n\ttestCases := []testCase{\n\t\t{\n\t\t\tname:     \"empty array\",\n\t\t\tinput:    \"[]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with one element\",\n\t\t\tinput:    \"[1]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with multiple elements\",\n\t\t\tinput:    \"[1,2,3]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}, &Value{t: TypeNumber, s: \"2\"}, &Value{t: TypeNumber, s: \"3\"}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with trailing comma\",\n\t\t\tinput:    \"[1,2,3,]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"unclosed array\",\n\t\t\tinput:    \"[1,2,3\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, _, err := parseArray(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseArray(%q) error = %v, wantErr %t\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !equalValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(a, b *Value) bool {\n\tif a == nil && b == nil {\n\t\treturn true\n\t}\n\tif a == nil || b == nil {\n\t\treturn false\n\t}\n\tif a.t != b.t {\n\t\treturn false\n\t}\n\tswitch a.t {\n\tcase TypeArray:\n\t\taa, _ := a.Array()\n\t\tab, _ := b.Array()\n\t\tif len(aa) != len(ab) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range aa {\n\t\t\tif !equalValues(aa[i], ab[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeObject:\n\t\tao, _ := a.Object()\n\t\tbo, _ := b.Object()\n\t\tif ao.Len() != bo.Len() {\n\t\t\treturn false\n\t\t}\n\t\tvar visited = make(map[string]bool)\n\t\tfor _, kv := range ao.kvs {\n\t\t\tbv := bo.Get(kv.k)\n\t\t\tif bv == nil || !equalValues(kv.v, bv) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tvisited[kv.k] = true\n\t\t}\n\t\tfor _, kv := range bo.kvs {\n\t\t\tif !visited[kv.k] {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeString, TypeNumber, TypeTrue, TypeFalse, TypeNull:\n\t\treturn a.s == b.s\n\tdefault:\n\t\tpanic(\"unknown type\")\n\t}\n}",
    "16723f2ffc32b29d413163cff8fbb420": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected1, expected2 string\n\t\texpectedErr error\n\t}{\n\t\t{\n\t\t\tname:      \"no closing quote\",\n\t\t\tinput:     `\"hello`,\n\t\t\texpected1: `\"hello`,\n\t\t\texpected2: \"\",\n\t\t\texpectedErr: fmt.Errorf(`missing closing '\"'`),\n\t\t},\n\t\t{\n\t\t\tname:      \"simple string\",\n\t\t\tinput:     `\"hello world\"`,\n\t\t\texpected1: `\"hello world\"`,\n\t\t\texpected2: \"\",\n\t\t\texpectedErr: nil,\n\t\t},\n\t\t{\n\t\t\tname:      \"string with escaped quote\",\n\t\t\tinput:     `\"hello \\\"world\\\"\"`,\n\t\t\texpected1: `\"hello \\\"world\\\"\"`,\n\t\t\texpected2: \"\",\n\t\t\texpectedErr: nil,\n\t\t},\n\t\t{\n\t\t\tname:      \"string with multiple escaped quotes\",\n\t\t\tinput:     `\"hello \\\"world\\\" \\\"foo\\\"\"`,\n\t\t\texpected1: `\"hello \\\"world\\\" \\\"foo\\\"\"`,\n\t\t\texpected2: \"\",\n\t\t\texpectedErr: nil,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual1, actual2, err := parseRawString(tc.input)\n\t\t\tif err != tc.expectedErr {\n\t\t\t\tt.Errorf(\"expected error %v, got %v\", tc.expectedErr, err)\n\t\t\t}\n\t\t\tif actual1 != tc.expected1 {\n\t\t\t\tt.Errorf(\"expected first output %q, got %q\", tc.expected1, actual1)\n\t\t\t}\n\t\t\tif actual2 != tc.expected2 {\n\t\t\t\tt.Errorf(\"expected second output %q, got %q\", tc.expected2, actual2)\n\t\t\t}\n\t\t})\n\t}\n}",
    "1b0cb5367fdb39bc465b2887e82894b3": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tt    Type\n\t\twant string\n\t}{\n\t\t{\"TypeObject\", TypeObject, \"\"},\n\t\t{\"TypeArray\", TypeArray, \"array\"},\n\t\t{\"TypeString\", TypeString, \"string\"},\n\t\t{\"TypeNumber\", TypeNumber, \"number\"},\n\t\t{\"TypeTrue\", TypeTrue, \"true\"},\n\t\t{\"TypeFalse\", TypeFalse, \"false\"},\n\t\t{\"TypeNull\", TypeNull, \"null\"},\n\t\t{\"Unknown\", Type(100), \"BUG: unknown Value type: 100\"},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.t.String(); got != tt.want {\n\t\t\t\tt.Errorf(\"Type.String() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "19b178d5d315f1ee4a910530c85798c5": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape sequence\",\n\t\t\tinput:    \"Hello, world!\",\n\t\t\texpected: \"Hello, world!\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Simple escape sequence\",\n\t\t\tinput:    \"Hello, \\\\\\\"world\\\\\\\"!\",\n\t\t\texpected: `Hello, \"world\"!`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Multiple escape sequences\",\n\t\t\tinput:    \"Hello, \\\\\\\"world\\\\\\\"! \\\\\\\\Backslash\\\\\\\\\",\n\t\t\texpected: `Hello, \"world\"! \\\\Backslash\\\\`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Unicode escape sequence\",\n\t\t\tinput:    \"Hello, \\\\u0041World!\",\n\t\t\texpected: \"Hello, AWorld!\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Surrogate pair escape sequence\",\n\t\t\tinput:    \"Hello, \\\\ud83d\\\\ude00World!\",\n\t\t\texpected: \"Hello, üòÄWorld!\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid escape sequence\",\n\t\t\tinput:    \"Hello, \\\\uWRONG!\",\n\t\t\texpected: \"Hello, \\\\uWRONG!\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "17b32a79b708d7306585f51b4a70cf38": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected struct {\n\t\t\tkey     string\n\t\t\tvalue   string\n\t\t\thasErro bool\n\t\t}\n\t}{\n\t\t{\n\t\t\tname:  \"simple string\",\n\t\t\tinput: `\"hello world\"`,\n\t\t\texpected: struct {\n\t\t\t\tkey     string\n\t\t\t\tvalue   string\n\t\t\t\thasErro bool\n\t\t\t}{\n\t\t\t\tkey:     \"hello world\",\n\t\t\t\tvalue:   \"\",\n\t\t\t\thasErro: false,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"string with escaped quote\",\n\t\t\tinput: `\"hello \\\"world\\\"\"`,\n\t\t\texpected: struct {\n\t\t\t\tkey     string\n\t\t\t\tvalue   string\n\t\t\t\thasErro bool\n\t\t\t}{\n\t\t\t\tkey:     `hello \"world\"`,\n\t\t\t\tvalue:   \"\",\n\t\t\t\thasErro: false,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"string missing closing quote\",\n\t\t\tinput: `\"hello world`,\n\t\t\texpected: struct {\n\t\t\t\tkey     string\n\t\t\t\tvalue   string\n\t\t\t\thasErro bool\n\t\t\t}{\n\t\t\t\tkey:     \"hello world\",\n\t\t\t\tvalue:   \"\",\n\t\t\t\thasErro: true,\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tkey, value, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.expected.hasErro {\n\t\t\t\tt.Errorf(\"expected error: %v, got: %v\", tc.expected.hasErro, err != nil)\n\t\t\t}\n\t\t\tif key != tc.expected.key {\n\t\t\t\tt.Errorf(\"expected key: %s, got: %s\", tc.expected.key, key)\n\t\t\t}\n\t\t\tif value != tc.expected.value {\n\t\t\t\tt.Errorf(\"expected value: %s, got: %s\", tc.expected.value, value)\n\t\t\t}\n\t\t})\n\t}\n}",
    "19b3a5701e18b77f98195cf754c31c57": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t\tleftover string\n\t\thasError bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: \"hello\",\n\t\t\tleftover: \"\",\n\t\t\thasError: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello\\\"world\"`,\n\t\t\texpected: `hello\"world`,\n\t\t\tleftover: \"\",\n\t\t\thasError: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with missing closing quote\",\n\t\t\tinput:    `\"hello`,\n\t\t\texpected: \"\",\n\t\t\tleftover: \"\",\n\t\t\thasError: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    `\"\"`,\n\t\t\texpected: \"\",\n\t\t\tleftover: \"\",\n\t\t\thasError: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello\\\"world\\\"there\"`,\n\t\t\texpected: `hello\"world\"there`,\n\t\t\tleftover: \"\",\n\t\t\thasError: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult, leftover, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.hasError {\n\t\t\t\tt.Errorf(\"unexpected error state: %v\", err)\n\t\t\t}\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"expected result %q, got %q\", tc.expected, result)\n\t\t\t}\n\t\t\tif leftover != tc.leftover {\n\t\t\t\tt.Errorf(\"expected leftover %q, got %q\", tc.leftover, leftover)\n\t\t\t}\n\t\t})\n\t}\n}",
    "1776fcb07dc4d492159b07148dfcd15c": "package fastjson\n\nimport (\n    \"reflect\"\n    \"testing\"\n)\n\nfunc TestGet(t *testing.T) {\n    testCases := []struct {\n        name     string\n        json     string\n        keys     []string\n        expected *Value\n    }{\n        {\n            name: \"Get from object\",\n            json: `{\"key1\": \"value1\", \"key2\": {\"subkey\": \"subvalue\"}}`,\n            keys: []string{\"key2\", \"subkey\"},\n            expected: &Value{\n                s: \"subvalue\",\n                t: TypeString,\n            },\n        },\n        {\n            name: \"Get from array\",\n            json: `[\"value1\", \"value2\", \"value3\"]`,\n            keys: []string{\"1\"},\n            expected: &Value{\n                s: \"value2\",\n                t: TypeString,\n            },\n        },\n        {\n            name: \"Non-existing key\",\n            json: `{\"key1\": \"value1\"}`,\n            keys: []string{\"key2\"},\n            expected: nil,\n        },\n    }\n\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            v, err := Parse(tc.json)\n            if err != nil {\n                t.Errorf(\"Parse() error: %v\", err)\n                return\n            }\n\n            got := v.Get(tc.keys...)\n            if !reflect.DeepEqual(got, tc.expected) {\n                t.Errorf(\"Get(%v) = %v, expected %v\", tc.keys, got, tc.expected)\n            }\n        })\n    }\n}",
    "1bca194f17562f1a6b2bfbc4f35dc226": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCache_GetValue(t *testing.T) {\n\tc := &cache{}\n\n\t// Test case 1: Adding a new value to the cache\n\tv1 := c.getValue()\n\tif v1 == nil {\n\t\tt.Errorf(\"expected a non-nil value, got nil\")\n\t}\n\n\t// Test case 2: Extending the cache length\n\tfor i := 0; i < cap(c.vs)-len(c.vs)+1; i++ {\n\t\tc.getValue()\n\t}\n\tif len(c.vs) != cap(c.vs) {\n\t\tt.Errorf(\"expected cache length to be equal to capacity, but got %d/%d\", len(c.vs), cap(c.vs))\n\t}\n\n\t// Test case 3: Adding a new value after capacity is reached\n\tv2 := c.getValue()\n\tif v2 == v1 {\n\t\tt.Errorf(\"expected a new value, but got the same pointer\")\n\t}\n\tif len(c.vs) != cap(c.vs) {\n\t\tt.Errorf(\"expected cache length to be equal to capacity, but got %d/%d\", len(c.vs), cap(c.vs))\n\t}\n}",
    "1c00ead46802235ac5eed2c1d0ca0b65": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestGetStringBytes(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tvalue *Value\n\t\tkeys  []string\n\t\twant  []byte\n\t}{\n\t\t{\n\t\t\tname: \"Existing string value\",\n\t\t\tvalue: &Value{\n\t\t\t\ts: \"hello\",\n\t\t\t\tt: TypeString,\n\t\t\t},\n\t\t\tkeys: []string{\"key\"},\n\t\t\twant: []byte(\"hello\"),\n\t\t},\n\t\t{\n\t\t\tname: \"Non-existing keys\",\n\t\t\tvalue: &Value{\n\t\t\t\ts: \"hello\",\n\t\t\t\tt: TypeString,\n\t\t\t},\n\t\t\tkeys: []string{\"non\", \"existing\", \"keys\"},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Invalid value type\",\n\t\t\tvalue: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{t: TypeObject}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\tkeys: []string{\"key\"},\n\t\t\twant: nil,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.value.GetStringBytes(tt.keys...)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"GetStringBytes(%v) = %v, want %v\", tt.keys, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "164ccc2a2be2f8e88436d7a4daedb07f": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:  \"empty string\",\n\t\t\tinput: \"\",\n\t\t\terr:   fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:  \"depth exceeded\",\n\t\t\tinput: \"{}\", // Simulate deep nesting by calling parseValue recursively\n\t\t\terr:   fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t},\n\t\t{\n\t\t\tname:     \"parse object\",\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: &Value{t: typeRawString, s: \"value\"}}}}},\n\t\t},\n\t\t{\n\t\t\tname:     \"parse array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}, &Value{t: TypeNumber, s: \"2\"}, &Value{t: TypeNumber, s: \"3\"}}},\n\t\t},\n\t\t{\n\t\t\tname:     \"parse string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{t: typeRawString, s: \"hello\"},\n\t\t},\n\t\t{\n\t\t\tname:     \"parse true\",\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t},\n\t\t{\n\t\t\tname:     \"parse false\",\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t},\n\t\t{\n\t\t\tname:     \"parse null\",\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t},\n\t\t{\n\t\t\tname:     \"parse number\",\n\t\t\tinput:    \"42\",\n\t\t\texpected: &Value{t: TypeNumber, s: \"42\"},\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, want %v\", tc.input, err, tc.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif tc.err != nil {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) error = nil, want %v\", tc.input, tc.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif !equal(got, tc.expected) {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", tc.input, got, tc.expected)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equal(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\to1, _ := v1.Object()\n\t\to2, _ := v2.Object()\n\t\treturn o1.Len() == o2.Len()\n\tcase TypeArray:\n\t\ta1, _ := v1.Array()\n\t\ta2, _ := v2.Array()\n\t\tif len(a1) != len(a2) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range a1 {\n\t\t\tif !equal(a1[i], a2[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase typeRawString, TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeTrue, TypeFalse, TypeNull:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}",
    "1aa906ed44c98caf0327578912d5774d": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"Hello, world!\",\n\t\t\texpected: \"Hello, world!\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape double quotes\",\n\t\t\tinput:    \"\\\"Hello, \\\\\\\"world\\\\\\\"!\\\"\",\n\t\t\texpected: \"\\\"Hello, \\\"world\\\"!\\\"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backslash\",\n\t\t\tinput:    \"Hello, \\\\\\\\world!\",\n\t\t\texpected: \"Hello, \\\\world!\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape slash\",\n\t\t\tinput:    \"Hello, \\\\/world!\",\n\t\t\texpected: \"Hello, /world!\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backspace\",\n\t\t\tinput:    \"Hello,\\\\bworld!\",\n\t\t\texpected: \"Hello,\\bworld!\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape form feed\",\n\t\t\tinput:    \"Hello,\\\\fworld!\",\n\t\t\texpected: \"Hello,\\fworld!\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape newline\",\n\t\t\tinput:    \"Hello,\\\\nworld!\",\n\t\t\texpected: \"Hello,\\nworld!\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape carriage return\",\n\t\t\tinput:    \"Hello,\\\\rworld!\",\n\t\t\texpected: \"Hello,\\rworld!\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape tab\",\n\t\t\tinput:    \"Hello,\\\\tworld!\",\n\t\t\texpected: \"Hello,\\tworld!\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Unicode\",\n\t\t\tinput:    \"Hello,\\\\u0041world!\",\n\t\t\texpected: \"Hello,Aworld!\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Surrogate Pair\",\n\t\t\tinput:    \"Hello,\\\\ud83d\\\\ude00world!\",\n\t\t\texpected: \"Hello,üòÄworld!\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid Escape Sequence\",\n\t\t\tinput:    \"Hello,\\\\xworld!\",\n\t\t\texpected: \"Hello,\\\\xworld!\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) returned %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "15d7ed731d71f30fb541c89324e4ba82": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname        string\n\t\tinput       string\n\t\texpectedV   *Value\n\t\texpectedTail string\n\t\texpectedErr  error\n\t}{\n\t\t{\n\t\t\tname:        \"empty input\",\n\t\t\tinput:       \"\",\n\t\t\texpectedV:   nil,\n\t\t\texpectedTail: \"\",\n\t\t\texpectedErr: fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:        \"max depth exceeded\",\n\t\t\tinput:       \"{}\", // Nested JSON can exceed max depth\n\t\t\texpectedV:   nil,\n\t\t\texpectedTail: \"{}\",\n\t\t\texpectedErr: fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t},\n\t\t{\n\t\t\tname:        \"parse object\",\n\t\t\tinput:       `{\"key\":\"value\"}`,\n\t\t\texpectedV:   &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{s: \"value\", t: typeRawString}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\texpectedTail: \"\",\n\t\t\texpectedErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:        \"parse array\",\n\t\t\tinput:       `[1,2,3]`,\n\t\t\texpectedV:   &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"1\", t: TypeNumber},\n\t\t\t\t\t{s: \"2\", t: TypeNumber},\n\t\t\t\t\t{s: \"3\", t: TypeNumber},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\texpectedTail: \"\",\n\t\t\texpectedErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:        \"parse string\",\n\t\t\tinput:       `\"hello\"`,\n\t\t\texpectedV:   &Value{\n\t\t\t\ts: \"hello\",\n\t\t\t\tt: typeRawString,\n\t\t\t},\n\t\t\texpectedTail: \"\",\n\t\t\texpectedErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:        \"parse true\",\n\t\t\tinput:       \"true\",\n\t\t\texpectedV:   valueTrue,\n\t\t\texpectedTail: \"\",\n\t\t\texpectedErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:        \"parse false\",\n\t\t\tinput:       \"false\",\n\t\t\texpectedV:   valueFalse,\n\t\t\texpectedTail: \"\",\n\t\t\texpectedErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:        \"parse null\",\n\t\t\tinput:       \"null\",\n\t\t\texpectedV:   valueNull,\n\t\t\texpectedTail: \"\",\n\t\t\texpectedErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:        \"parse number\",\n\t\t\tinput:       \"42\",\n\t\t\texpectedV:   &Value{\n\t\t\t\ts: \"42\",\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\texpectedTail: \"\",\n\t\t\texpectedErr:  nil,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tv, tail, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil && tc.expectedErr == nil {\n\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t} else if err == nil && tc.expectedErr != nil {\n\t\t\t\tt.Errorf(\"expected error %v, got nil\", tc.expectedErr)\n\t\t\t} else if err != nil && tc.expectedErr != nil && err.Error() != tc.expectedErr.Error() {\n\t\t\t\tt.Errorf(\"expected error %v, got %v\", tc.expectedErr, err)\n\t\t\t}\n\n\t\t\tif !equalValue(v, tc.expectedV) {\n\t\t\t\tt.Errorf(\"expected value %+v, got %+v\", tc.expectedV, v)\n\t\t\t}\n\n\t\t\tif tail != tc.expectedTail {\n\t\t\t\tt.Errorf(\"expected tail %q, got %q\", tc.expectedTail, tail)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValue(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn equalObject(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn equalArray(v1.a, v2.a)\n\tcase typeRawString, TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber, TypeTrue, TypeFalse, TypeNull:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc equalObject(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !equalValue(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc equalArray(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tv2 := a2[i]\n\t\tif !equalValue(v1, v2) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "19cc1c015d27484dc43e312ff7b721be": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"empty array\",\n\t\t\tinput:    \"[]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with one value\",\n\t\t\tinput:    \"[123]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"123\"}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with multiple values\",\n\t\t\tinput:    \"[123, \\\"hello\\\", true]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"123\"}, &Value{t: TypeString, s: \"hello\"}, &Value{t: TypeTrue}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with missing end bracket\",\n\t\t\tinput:    \"[123, \\\"hello\\\", true\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with missing comma\",\n\t\t\tinput:    \"[123 \\\"hello\\\"]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{vs: make([]Value, 0, 10)}\n\t\t\tactual, _, err := parseArray(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseArray(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !equalValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeNull, TypeTrue, TypeFalse:\n\t\treturn true\n\tcase TypeNumber, TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeObject:\n\t\treturn equalObjects(&v1.o, &v2.o)\n\tdefault:\n\t\tpanic(\"unexpected type\")\n\t}\n}\n\nfunc equalObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i := range o1.kvs {\n\t\tif o1.kvs[i].k != o2.kvs[i].k {\n\t\t\treturn false\n\t\t}\n\t\tif !equalValues(o1.kvs[i].v, o2.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "1ce43c5fa81158f58acaadeba7b8f216": "package fastjson_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/valyala/fastjson\"\n)\n\nfunc TestType_String(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tt    fastjson.Type\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"TypeObject\",\n\t\t\tt:    fastjson.TypeObject,\n\t\t\twant: \"object\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeArray\",\n\t\t\tt:    fastjson.TypeArray,\n\t\t\twant: \"array\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeString\",\n\t\t\tt:    fastjson.TypeString,\n\t\t\twant: \"string\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeNumber\",\n\t\t\tt:    fastjson.TypeNumber,\n\t\t\twant: \"number\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeTrue\",\n\t\t\tt:    fastjson.TypeTrue,\n\t\t\twant: \"true\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeFalse\",\n\t\t\tt:    fastjson.TypeFalse,\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeNull\",\n\t\t\tt:    fastjson.TypeNull,\n\t\t\twant: \"null\",\n\t\t},\n\t\t{\n\t\t\tname: \"Unknown\",\n\t\t\tt:    fastjson.Type(100),\n\t\t\twant: \"BUG: unknown Value type: 100\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.t.String(); got != tt.want {\n\t\t\t\tt.Errorf(\"Type.String() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "1ea4de15947de5848d3c8cf899c4801a": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestTypeString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\tt    Type\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"TypeObject\",\n\t\t\tt:    TypeObject,\n\t\t\twant: \"object\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeArray\",\n\t\t\tt:    TypeArray,\n\t\t\twant: \"array\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeString\",\n\t\t\tt:    TypeString,\n\t\t\twant: \"string\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeNumber\",\n\t\t\tt:    TypeNumber,\n\t\t\twant: \"number\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeTrue\",\n\t\t\tt:    TypeTrue,\n\t\t\twant: \"true\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeFalse\",\n\t\t\tt:    TypeFalse,\n\t\t\twant: \"false\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeNull\",\n\t\t\tt:    TypeNull,\n\t\t\twant: \"null\",\n\t\t},\n\t\t{\n\t\t\tname: \"Unknown Type\",\n\t\t\tt:    Type(100),\n\t\t\twant: \"BUG: unknown Value type: 100\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := tc.t.String()\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"Type.String() = %v, want %v\", got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "1dca8b16fd1f12843f54c38e028842d2": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetUint(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\tkeys     []string\n\t\texpected uint\n\t}{\n\t\t{\n\t\t\tname:     \"valid uint\",\n\t\t\tvalue:    &Value{s: \"42\", t: TypeNumber},\n\t\t\tkeys:     []string{},\n\t\t\texpected: 42,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid uint with keys\",\n\t\t\tvalue:    &Value{o: Object{kvs: []kv{{k: \"foo\", v: &Value{s: \"42\", t: TypeNumber}}}}, t: TypeObject},\n\t\t\tkeys:     []string{\"foo\"},\n\t\t\texpected: 42,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid value type\",\n\t\t\tvalue:    &Value{s: \"foo\", t: TypeString},\n\t\t\tkeys:     []string{},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"non-existing keys\",\n\t\t\tvalue:    &Value{o: Object{kvs: []kv{{k: \"foo\", v: &Value{s: \"42\", t: TypeNumber}}}}, t: TypeObject},\n\t\t\tkeys:     []string{\"bar\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"overflow uint\",\n\t\t\tvalue:    &Value{s: \"18446744073709551616\", t: TypeNumber},\n\t\t\tkeys:     []string{},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"nil value\",\n\t\t\tvalue:    nil,\n\t\t\tkeys:     []string{},\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := tc.value.GetUint(tc.keys...)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"expected %d, got %d\", tc.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "1d6102038107577e8f368fb5065b7559": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantNum  string\n\t\twantRest string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.45e+6\",\n\t\t\twantNum:  \"123.45e+6\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with leading sign\",\n\t\t\tinput:    \"-123.45e+6\",\n\t\t\twantNum:  \"-123.45e+6\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with trailing garbage\",\n\t\t\tinput:    \"123.45e+6abc\",\n\t\t\twantNum:  \"123.45e+6\",\n\t\t\twantRest: \"abc\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number\",\n\t\t\tinput:    \"abc\",\n\t\t\twantNum:  \"\",\n\t\t\twantRest: \"abc\",\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty input\",\n\t\t\tinput:    \"\",\n\t\t\twantNum:  \"\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.wantNum {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) num = %q, want %q\", tc.input, num, tc.wantNum)\n\t\t\t}\n\t\t\tif rest != tc.wantRest {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) rest = %q, want %q\", tc.input, rest, tc.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "1ef5dafc5651aab64d7c67dcd23d202e": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGet(t *testing.T) {\n\t// Test cases\n\ttestCases := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\tkeys     []string\n\t\texpected *Value\n\t}{\n\t\t{\n\t\t\tname: \"Existing keys path\",\n\t\t\tvalue: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{a: []*Value{\n\t\t\t\t\t\t\t{s: \"arr1\"}, {s: \"arr2\"},\n\t\t\t\t\t\t}}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"key1\", \"key2\", \"1\"},\n\t\t\texpected: &Value{s: \"arr2\"},\n\t\t},\n\t\t{\n\t\t\tname: \"Non-existing keys path\",\n\t\t\tvalue: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{s: \"value1\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"key1\", \"non-existing\", \"0\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Value is not an object or array\",\n\t\t\tvalue: &Value{\n\t\t\t\ts: \"string-value\",\n\t\t\t},\n\t\t\tkeys:     []string{\"0\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Nil value\",\n\t\t\tvalue:    nil,\n\t\t\tkeys:     []string{\"key1\"},\n\t\t\texpected: nil,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := tc.value.Get(tc.keys...)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"Get(%v) = %v, expected %v\", tc.keys, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "1c610a9276eeb78e756f2c509ddd525f": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Simple escape characters\",\n\t\t\tinput:    \"hello\\\\\\\"\\\\\\\\\\\\//\\\\b\\\\f\\\\n\\\\r\\\\tworld\",\n\t\t\texpected: `hello\"\\/\\b\\f\\n\\r\\tworld`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Unicode escape characters\",\n\t\t\tinput:    \"hello\\\\u0041\\\\u2233\\\\uD834\\\\uDD1E\\\\u0042world\",\n\t\t\texpected: \"helloA\\u2233\\U0001D11Eworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Incomplete Unicode escape characters\",\n\t\t\tinput:    \"hello\\\\u004A\\\\u12\",\n\t\t\texpected: \"hello\\\\u004A\\\\u12\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid Unicode escape characters\",\n\t\t\tinput:    \"hello\\\\u004x\\\\u1234world\",\n\t\t\texpected: \"hello\\\\u004x\\\\u1234world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Surrogate pair Unicode escape characters\",\n\t\t\tinput:    \"hello\\\\u2070\\\\uD834\\\\uDD1Eworld\",\n\t\t\texpected: \"hello\\u2070\\U0001D11Eworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Incomplete surrogate pair Unicode escape characters\",\n\t\t\tinput:    \"hello\\\\u2070\\\\uD834world\",\n\t\t\texpected: \"hello\\\\u2070\\\\uD834world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid surrogate pair Unicode escape characters\",\n\t\t\tinput:    \"hello\\\\u2070\\\\uD834\\\\u123Xworld\",\n\t\t\texpected: \"hello\\\\u2070\\\\uD834\\\\u123Xworld\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2013af45e79fe47fbf01b0eaa4ee45fa": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty array\",\n\t\t\tinput: \"[]\",\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with one element\",\n\t\t\tinput: \"[1]\",\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with multiple elements\",\n\t\t\tinput: \"[1,2,3]\",\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"missing closing bracket\",\n\t\t\tinput: \"[1,2,3\",\n\t\t\terr:   true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tactual, _, err := parseArray(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseArray(%q) error = %v, want error: %t\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !valuesEqual(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc valuesEqual(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !valuesEqual(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !valuesEqual(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeTrue:\n\t\treturn true\n\tcase TypeFalse:\n\t\treturn false\n\tcase TypeNull:\n\t\treturn true\n\t}\n\treturn true\n}",
    "21563450aa831ddb46cebdbf589fe705": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tt    Type\n\t\twant string\n\t}{\n\t\t{\"TypeObject\", TypeObject, \"object\"},\n\t\t{\"TypeArray\", TypeArray, \"array\"},\n\t\t{\"TypeString\", TypeString, \"string\"},\n\t\t{\"TypeNumber\", TypeNumber, \"number\"},\n\t\t{\"TypeTrue\", TypeTrue, \"true\"},\n\t\t{\"TypeFalse\", TypeFalse, \"false\"},\n\t\t{\"TypeNull\", TypeNull, \"null\"},\n\t\t{\"Unknown\", Type(100), \"BUG: unknown Value type: 100\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.t.String(); got != tt.want {\n\t\t\t\tt.Errorf(\"Type.String() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "20b5c1c1a4dfaafd124f9ff342248bef": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.45e+6\",\n\t\t\texpected: []string{\"123.45e+6\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with sign\",\n\t\t\tinput:    \"-0.1\",\n\t\t\texpected: []string{\"-0.1\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with exponent\",\n\t\t\tinput:    \"1e+10\",\n\t\t\texpected: []string{\"1e+10\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with exponent and sign\",\n\t\t\tinput:    \"-1.2e-3\",\n\t\t\texpected: []string{\"-1.2e-3\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number\",\n\t\t\tinput:    \"123.45.67\",\n\t\t\texpected: []string{\"\", \"123.45.67\"},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"infinity\",\n\t\t\tinput:    \"inf\",\n\t\t\texpected: []string{\"inf\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN\",\n\t\t\tinput:    \"nan\",\n\t\t\texpected: []string{\"nan\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnumber, remain, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif number != tc.expected[0] || remain != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = (%q, %q), want (%q, %q)\", tc.input, number, remain, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "20c410e6014f42776532d2abe3f935ad": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantKey  string\n\t\twantRest string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello\"world`,\n\t\t\twantKey:  \"hello\",\n\t\t\twantRest: \"world\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"he\\\"llo\"world`,\n\t\t\twantKey:  `he\"llo`,\n\t\t\twantRest: \"world\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"he\\\"\\\"llo\"world`,\n\t\t\twantKey:  `he\"\"llo`,\n\t\t\twantRest: \"world\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string without closing quote\",\n\t\t\tinput:    `\"hello`,\n\t\t\twantKey:  \"\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tkey, rest, err := parseRawString(tt.input)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif key != tt.wantKey {\n\t\t\t\tt.Errorf(\"parseRawString() key = %v, want %v\", key, tt.wantKey)\n\t\t\t}\n\t\t\tif rest != tt.wantRest {\n\t\t\t\tt.Errorf(\"parseRawString() rest = %v, want %v\", rest, tt.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "20bdc202f514624e2445ff26eb23a8bf": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestObject_unescapeKeys(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\to    *Object\n\t\twant *Object\n\t}{\n\t\t{\n\t\t\tname: \"no escape characters\",\n\t\t\to: &Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"key1\", v: &Value{}},\n\t\t\t\t\t{k: \"key2\", v: &Value{}},\n\t\t\t\t},\n\t\t\t\tkeysUnescaped: false,\n\t\t\t},\n\t\t\twant: &Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"key1\", v: &Value{}},\n\t\t\t\t\t{k: \"key2\", v: &Value{}},\n\t\t\t\t},\n\t\t\t\tkeysUnescaped: true,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"with escape characters\",\n\t\t\to: &Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"key\\\\\\\"1\", v: &Value{}},\n\t\t\t\t\t{k: \"key\\\\\\\"2\", v: &Value{}},\n\t\t\t\t},\n\t\t\t\tkeysUnescaped: false,\n\t\t\t},\n\t\t\twant: &Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: `key\"1`, v: &Value{}},\n\t\t\t\t\t{k: `key\"2`, v: &Value{}},\n\t\t\t\t},\n\t\t\t\tkeysUnescaped: true,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\ttt.o.unescapeKeys()\n\t\t\tif !reflect.DeepEqual(tt.o, tt.want) {\n\t\t\t\tt.Errorf(\"Object.unescapeKeys() = %v, want %v\", tt.o, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "20c0b47d55f6f1274b8c35f08b22d4a0": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantKey  string\n\t\twantRest string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\twantKey:  \"hello\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"he\\\"llo\"`,\n\t\t\twantKey:  `he\"llo`,\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing closing quote\",\n\t\t\tinput:    `\"hello`,\n\t\t\twantKey:  \"\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    `\"\"`,\n\t\t\twantKey:  \"\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with trailing content\",\n\t\t\tinput:    `\"hello\"world`,\n\t\t\twantKey:  \"hello\",\n\t\t\twantRest: \"world\",\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tkey, rest, err := parseRawString(tt.input)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif key != tt.wantKey {\n\t\t\t\tt.Errorf(\"parseRawString() key = %v, want %v\", key, tt.wantKey)\n\t\t\t}\n\t\t\tif rest != tt.wantRest {\n\t\t\t\tt.Errorf(\"parseRawString() rest = %v, want %v\", rest, tt.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "20f4fca86896e8b2a8b5f24aff6e129d": "package fastjson\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"abcd\",\n\t\t\texpected: \"abcd\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escaping double quotes\",\n\t\t\tinput:    \"\\\"hello\\\"\",\n\t\t\texpected: `\"hello\"`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escaping backslash\",\n\t\t\tinput:    \"\\\\\",\n\t\t\texpected: `\\`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escaping forward slash\",\n\t\t\tinput:    \"/\",\n\t\t\texpected: `/`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escaping backspace\",\n\t\t\tinput:    \"\\b\",\n\t\t\texpected: `\\b`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escaping form feed\",\n\t\t\tinput:    \"\\f\",\n\t\t\texpected: `\\f`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escaping newline\",\n\t\t\tinput:    \"\\n\",\n\t\t\texpected: `\\n`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escaping carriage return\",\n\t\t\tinput:    \"\\r\",\n\t\t\texpected: `\\r`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escaping tab\",\n\t\t\tinput:    \"\\t\",\n\t\t\texpected: `\\t`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escaping Unicode character\",\n\t\t\tinput:    \"\\\\u03c0\",\n\t\t\texpected: `œÄ`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escaping surrogate pair\",\n\t\t\tinput:    \"\\\\ud83d\\\\ude00\",\n\t\t\texpected: `üòÄ`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid escape sequence\",\n\t\t\tinput:    \"\\\\x\",\n\t\t\texpected: `\\x`,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tassert.Equal(t, tc.expected, result)\n\t\t})\n\t}\n}",
    "21c8b9ab6e61b74c9c277e147ee024f4": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty object\",\n\t\t\tinput:    \"{}\",\n\t\t\texpected: &Value{t: TypeObject, o: Object{}},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with one key-value pair\",\n\t\t\tinput: `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{t: TypeString, s: \"value\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with multiple key-value pairs\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42,\"key3\":true}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t\t{k: \"key3\", v: &Value{t: TypeTrue}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42`,\n\t\t\texpected: nil,\n\t\t\terr:      ErrMissingClosingBrace,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tv, _, err := parseObject(tc.input, c, 0)\n\t\t\tif err != tc.err {\n\t\t\t\tt.Errorf(\"expected error %v, got %v\", tc.err, err)\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(v, tc.expected) {\n\t\t\t\tt.Errorf(\"expected %+v, got %+v\", tc.expected, v)\n\t\t\t}\n\t\t})\n\t}\n}",
    "21fe26a1eb0ca3f4d414e14beec4b95b": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":\"value1\",\"key2\":42}`),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"item1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`[\"item1\",42,true]`),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello, world\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello, world\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42\",\n\t\t\t},\n\t\t\twant: []byte(\"42\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %s, want %s\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "24aa5034a511785e1541e0d1a6b12b78": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestUint(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tinput   *Value\n\t\twant    uint\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"Valid uint\",\n\t\t\tinput:   &Value{s: \"42\", t: TypeNumber},\n\t\t\twant:    42,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"Negative number\",\n\t\t\tinput:   &Value{s: \"-42\", t: TypeNumber},\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"Non-number type\",\n\t\t\tinput:   &Value{t: TypeString},\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"Number out of uint range\",\n\t\t\tinput:   &Value{s: \"18446744073709551615\", t: TypeNumber},\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := tt.input.Uint()\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Value.Uint() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Value.Uint() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "219d017f87ef89c0155d62b9adcf69a1": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"valid object\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"missing closing brace\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42`,\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"missing key\",\n\t\t\tinput: `{:42}`,\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"missing value\",\n\t\t\tinput: `{\"key1\":}`,\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"extra comma\",\n\t\t\tinput: `{\"key1\":\"value1\",}`,\n\t\t\terr:   true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tv, _, err := parseObject(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %t\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !valueEqual(v, tc.expected) {\n\t\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", tc.input, v, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc valueEqual(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn objectEqual(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !valueEqual(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeTrue, TypeFalse, TypeNull:\n\t\treturn true\n\tdefault:\n\t\tpanic(\"unknown type\")\n\t}\n}\n\nfunc objectEqual(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i := range o1.kvs {\n\t\tif o1.kvs[i].k != o2.kvs[i].k {\n\t\t\treturn false\n\t\t}\n\t\tif !valueEqual(o1.kvs[i].v, o2.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "2450389b1bc6ad67b7ef7b1235a62386": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantKey  string\n\t\twantRest string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\twantKey:  \"hello\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quotes\",\n\t\t\tinput:    `\"hello\\\"world\"`,\n\t\t\twantKey:  `hello\"world`,\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello\\\"world\\\"foo\"`,\n\t\t\twantKey:  `hello\"world\"foo`,\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with incomplete quote\",\n\t\t\tinput:    `\"hello`,\n\t\t\twantKey:  \"\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tkey, rest, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif key != tc.wantKey {\n\t\t\t\tt.Errorf(\"parseRawString(%q) key = %q, want %q\", tc.input, key, tc.wantKey)\n\t\t\t}\n\t\t\tif rest != tc.wantRest {\n\t\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, want %q\", tc.input, rest, tc.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2476caea5205f813f94d185bcf37165b": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetUint64(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tjson   string\n\t\tkeys   []string\n\t\texpect uint64\n\t}{\n\t\t{\n\t\t\tname:   \"existing key with valid uint64 value\",\n\t\t\tjson:   `{\"key\": 1234567890}`,\n\t\t\tkeys:   []string{\"key\"},\n\t\t\texpect: 1234567890,\n\t\t},\n\t\t{\n\t\t\tname:   \"non-existing key\",\n\t\t\tjson:   `{\"key1\": 1234567890}`,\n\t\t\tkeys:   []string{\"key2\"},\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"invalid value type\",\n\t\t\tjson:   `{\"key\": \"string\"}`,\n\t\t\tkeys:   []string{\"key\"},\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"nested object with valid uint64 value\",\n\t\t\tjson:   `{\"outer\":{\"key\": 1234567890}}`,\n\t\t\tkeys:   []string{\"outer\", \"key\"},\n\t\t\texpect: 1234567890,\n\t\t},\n\t\t{\n\t\t\tname:   \"array index in keys\",\n\t\t\tjson:   `{\"outer\":[{\"key\":1},{},{\"key\":2}]}`,\n\t\t\tkeys:   []string{\"outer\", \"2\", \"key\"},\n\t\t\texpect: 2,\n\t\t},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tv, err := ParseBytes([]byte(tc.json))\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"failed to parse JSON: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tgot := v.GetUint64(tc.keys...)\n\t\t\tif got != tc.expect {\n\t\t\t\tt.Errorf(\"GetUint64(%v) = %d, want %d\", tc.keys, got, tc.expect)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2100dd028b870c5605e39b71dc4b7a32": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      ErrEmptyInput,\n\t\t},\n\t\t{\n\t\t\tname:     \"too deep\",\n\t\t\tinput:    \"{}\", // Assuming MaxDepth is 1\n\t\t\texpected: nil,\n\t\t\terr:      ErrTooDeepJSON,\n\t\t},\n\t\t{\n\t\t\tname:     \"parse object\",\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{t: TypeObject, o: Object{kvs: []kv{{\"key\", &Value{t: TypeString, s: \"value\"}}}}},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"parse array\",\n\t\t\tinput:    `[\"value1\",\"value2\"]`,\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeString, s: \"value1\"}, &Value{t: TypeString, s: \"value2\"}}},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"parse string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{t: TypeString, s: \"hello\"},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"parse true\",\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"parse false\",\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"parse null\",\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"parse number\",\n\t\t\tinput:    \"42\",\n\t\t\texpected: &Value{t: TypeNumber, s: \"42\"},\n\t\t\terr:      nil,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != tc.err {\n\t\t\t\tt.Errorf(\"parseValue(%q) returned error %v, want %v\", tc.input, err, tc.err)\n\t\t\t}\n\t\t\tif !Equal(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseValue(%q) returned %v, want %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Equal(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn v1.o.Len() == v2.o.Len()\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, v := range v1.a {\n\t\t\tif !Equal(v, v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeString, TypeNumber, typeRawString:\n\t\treturn v1.s == v2.s\n\tcase TypeTrue, TypeFalse, TypeNull:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}",
    "24f6ab7fa227301c86006c63fd2bf228": "package fastjson\n\nimport (\n    \"testing\"\n)\n\nfunc TestGet(t *testing.T) {\n    // Test cases\n    testCases := []struct {\n        name   string\n        json   string\n        keys   []string\n        expect *Value\n    }{\n        {\n            name:   \"Simple object\",\n            json:   `{\"a\": 1, \"b\": 2}`,\n            keys:   []string{\"a\"},\n            expect: &Value{t: TypeNumber, s: \"1\"},\n        },\n        {\n            name:   \"Array index\",\n            json:   `[1, 2, 3]`,\n            keys:   []string{\"1\"},\n            expect: &Value{t: TypeNumber, s: \"2\"},\n        },\n        {\n            name:   \"Nested object\",\n            json:   `{\"a\": {\"b\": 1}}`,\n            keys:   []string{\"a\", \"b\"},\n            expect: &Value{t: TypeNumber, s: \"1\"},\n        },\n        {\n            name:   \"Non-existing key\",\n            json:   `{\"a\": 1}`,\n            keys:   []string{\"b\"},\n            expect: nil,\n        },\n        {\n            name:   \"Invalid array index\",\n            json:   `[1, 2, 3]`,\n            keys:   []string{\"3\"},\n            expect: nil,\n        },\n    }\n\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            v, _ := Parse(tc.json)\n            got := v.Get(tc.keys...)\n            if got != tc.expect {\n                t.Errorf(\"Get(%v) = %v, expect %v\", tc.keys, got, tc.expect)\n            }\n        })\n    }\n}",
    "2611c8b38fe13525416c8e88ca98ba23": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWS(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"Empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"String with no leading whitespace\",\n\t\t\tinput:    \"hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"String with leading whitespace\",\n\t\t\tinput:    \"  hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"String with mixed whitespace\",\n\t\t\tinput:    \" \\t\\n hello\\r\",\n\t\t\texpected: \"hello\\r\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := skipWS(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"skipWS(%q) = %q, want %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2571a7638b76ad2d74e4411f384573ac": "// fastjson_test.go\n\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"valid JSON\",\n\t\t\tinput: `{\"key\": \"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{s: \"value\", t: TypeString}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"invalid JSON\",\n\t\t\tinput: `{\"key\":`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:  \"extra trailing data\",\n\t\t\tinput: `{\"key\": \"value\"} extra`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tp := &Parser{}\n\t\t\tactual, err := p.Parse(tc.input)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !compare(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"expected %+v, got %+v\", tc.expected, actual)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compare(a, b *Value) bool {\n\tif a == nil && b == nil {\n\t\treturn true\n\t}\n\tif a == nil || b == nil {\n\t\treturn false\n\t}\n\tif a.t != b.t {\n\t\treturn false\n\t}\n\tswitch a.t {\n\tcase TypeObject:\n\t\treturn compareObject(&a.o, &b.o)\n\tcase TypeArray:\n\t\treturn compareArray(a.a, b.a)\n\tcase TypeString:\n\t\treturn a.s == b.s\n\tcase TypeNumber, TypeTrue, TypeFalse:\n\t\treturn a.s == b.s\n\tcase TypeNull:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc compareObject(a, b *Object) bool {\n\tif len(a.kvs) != len(b.kvs) {\n\t\treturn false\n\t}\n\tfor i := range a.kvs {\n\t\tif a.kvs[i].k != b.kvs[i].k {\n\t\t\treturn false\n\t\t}\n\t\tif !compare(a.kvs[i].v, b.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc compareArray(a, b []*Value) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif !compare(a[i], b[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "2442be74b57fe2079b5eff0a2bc0c33a": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"too deep\",\n\t\t\tinput:    \"{}\", // Assuming MaxDepth is 1\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t},\n\t\t{\n\t\t\tname:     \"parse object\",\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{s: \"value\", t: typeRawString}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"parse array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"1\", t: TypeNumber},\n\t\t\t\t\t{s: \"2\", t: TypeNumber},\n\t\t\t\t\t{s: \"3\", t: TypeNumber},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"parse string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{\n\t\t\t\ts: \"hello\",\n\t\t\t\tt: typeRawString,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"parse true\",\n\t\t\tinput:    `true`,\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"parse false\",\n\t\t\tinput:    `false`,\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"parse null\",\n\t\t\tinput:    `null`,\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"parse number\",\n\t\t\tinput:    `42`,\n\t\t\texpected: &Value{\n\t\t\t\ts: \"42\",\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tv, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) error: got %v, want %v\", tc.input, err, tc.err)\n\t\t\t\t}\n\t\t\t} else if tc.err != nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) error: got nil, want %v\", tc.input, tc.err)\n\t\t\t} else if !equalValue(v, tc.expected) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", tc.input, v, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// equalValue compares two Values for equality.\nfunc equalValue(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn equalObject(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn equalArray(v1.a, v2.a)\n\tcase TypeString, TypeNumber, typeRawString:\n\t\treturn v1.s == v2.s\n\tcase TypeTrue, TypeFalse, TypeNull:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\n// equalObject compares two Objects for equality.\nfunc equalObject(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !equalValue(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n// equalArray compares two Value slices for equality.\nfunc equalArray(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tif !equalValue(v1, a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "272c0c6a1e68be2b97a6035d445c2919": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"hello world\",\n\t\t\texpected: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Simple escape characters\",\n\t\t\tinput:    \"hello\\\\\\\"world\\\\\\\\\",\n\t\t\texpected: \"hello\\\"world\\\\\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Unicode escape characters\",\n\t\t\tinput:    \"hello\\\\u0040world\\\\u00A9\",\n\t\t\texpected: \"hello@world¬©\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Surrogate pairs\",\n\t\t\tinput:    \"hello\\\\uD83D\\\\uDE00world\",\n\t\t\texpected: \"helloüòÄworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid escape characters\",\n\t\t\tinput:    \"hello\\\\xworld\",\n\t\t\texpected: \"hello\\\\xworld\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "26212585ff2cf80f2aa004def4351ae6": "package fastjson_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/valyala/fastjson\"\n)\n\nfunc TestTypeString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    fastjson.Type\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"TypeObject\",\n\t\t\tinput:    fastjson.TypeObject,\n\t\t\texpected: \"object\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeArray\",\n\t\t\tinput:    fastjson.TypeArray,\n\t\t\texpected: \"array\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeString\",\n\t\t\tinput:    fastjson.TypeString,\n\t\t\texpected: \"string\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeNumber\",\n\t\t\tinput:    fastjson.TypeNumber,\n\t\t\texpected: \"number\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeTrue\",\n\t\t\tinput:    fastjson.TypeTrue,\n\t\t\texpected: \"true\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeFalse\",\n\t\t\tinput:    fastjson.TypeFalse,\n\t\t\texpected: \"false\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeNull\",\n\t\t\tinput:    fastjson.TypeNull,\n\t\t\texpected: \"null\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Unknown Type\",\n\t\t\tinput:    fastjson.Type(100),\n\t\t\texpected: \"BUG: unknown Value type: 100\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := tc.input.String()\n\t\t\tif got != tc.expected {\n\t\t\t\tt.Errorf(\"Type.String() = %q, want %q\", got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "25f24fcc36cc60aec68c7ede89d509c3": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.456e+78\",\n\t\t\texpected: []string{\"123.456e+78\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with trailing junk\",\n\t\t\tinput:    \"123.456abc\",\n\t\t\texpected: []string{\"123.456\", \"abc\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number\",\n\t\t\tinput:    \"abc\",\n\t\t\texpected: []string{\"\", \"abc\"},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with leading +/-\",\n\t\t\tinput:    \"+123.456\",\n\t\t\texpected: []string{\"+123.456\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"inf/nan\",\n\t\t\tinput:    \"inf\",\n\t\t\texpected: []string{\"inf\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"short inf/nan\",\n\t\t\tinput:    \"in\",\n\t\t\texpected: []string{\"\", \"in\"},\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tt.input)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tt.input, err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tt.expected[0] || rest != tt.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, %q, want %q, %q\", tt.input, num, rest, tt.expected[0], tt.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "240bda3681d592206cdcef8ff7978b96": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty object\",\n\t\t\tinput:    \"{}\",\n\t\t\texpected: &Value{t: TypeObject, o: Object{}},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with one key-value pair\",\n\t\t\tinput: `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{t: TypeString, s: \"value\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with multiple key-value pairs\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":123,\"key3\":true}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t\t{k: \"key3\", v: &Value{t: TypeTrue}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with nested object\",\n\t\t\tinput: `{\"key1\":{\"subkey\":\"subvalue\"}}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{k: \"subkey\", v: &Value{t: TypeString, s: \"subvalue\"}},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with nested array\",\n\t\t\tinput: `{\"key1\":[1,2,3]}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing key\",\n\t\t\tinput: `{:123}`,\n\t\t\terr:   fmt.Errorf(`cannot find opening '\"\" for object key`),\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing value\",\n\t\t\tinput: `{\"key\":}`,\n\t\t\terr:   fmt.Errorf(`missing ':' after object key`),\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing comma\",\n\t\t\tinput: `{\"key1\":\"value1\" \"key2\":123}`,\n\t\t\terr:   fmt.Errorf(`missing ',' after object value`),\n\t\t},\n\t\t{\n\t\t\tname:  \"object with unexpected end\",\n\t\t\tinput: `{\"key1\":\"value1\",`,\n\t\t\terr:   fmt.Errorf(`unexpected end of object`),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tv, _, err := parseObject(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil {\n\t\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t\t} else if err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"error mismatch: expected %v, got %v\", tc.err, err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif tc.err != nil {\n\t\t\t\tt.Errorf(\"expected error %v, got nil\", tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !compareValues(v, tc.expected) {\n\t\t\t\tt.Errorf(\"value mismatch: expected %v, got %v\", tc.expected, v)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\to1, err1 := v1.Object()\n\t\to2, err2 := v2.Object()\n\t\tif err1 != nil || err2 != nil {\n\t\t\treturn false\n\t\t}\n\t\tif len(o1.kvs) != len(o2.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, kv1 := range o1.kvs {\n\t\t\tkv2 := o2.kvs[i]\n\t\t\tif kv1.k != kv2.k || !compareValues(kv1.v, kv2.v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\tcase TypeArray:\n\t\ta1, err1 := v1.Array()\n\t\ta2, err2 := v2.Array()\n\t\tif err1 != nil || err2 != nil {\n\t\t\treturn false\n\t\t}\n\t\tif len(a1) != len(a2) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, v1 := range a1 {\n\t\t\tif !compareValues(v1, a2[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\tcase TypeString:\n\t\ts1, err1 := v1.StringBytes()\n\t\ts2, err2 := v2.StringBytes()\n\t\tif err1 != nil || err2 != nil {\n\t\t\treturn false\n\t\t}\n\t\tif string(s1) != string(s2) {\n\t\t\treturn false\n\t\t}\n\tcase TypeNumber, TypeTrue, TypeFalse:\n\t\treturn v1.s == v2.s\n\tcase TypeNull:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n\treturn true\n}",
    "24e116bdb8eb228efbb3cb4d39692562": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\tdepth    int\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\tdepth:    0,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"max depth exceeded\",\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\texpected: nil,\n\t\t\tdepth:    MaxDepth + 1,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t},\n\t\t{\n\t\t\tname:     \"parse object\",\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{\n\t\t\t\t\t\t\tt: typeRawString,\n\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\tdepth: 1,\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"parse array\",\n\t\t\tinput:    `[1, 2, 3]`,\n\t\t\texpected: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\tdepth: 1,\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"parse string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\tdepth: 1,\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"parse true\",\n\t\t\tinput:    `true`,\n\t\t\texpected: valueTrue,\n\t\t\tdepth:    1,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"parse false\",\n\t\t\tinput:    `false`,\n\t\t\texpected: valueFalse,\n\t\t\tdepth:    1,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"parse null\",\n\t\t\tinput:    `null`,\n\t\t\texpected: valueNull,\n\t\t\tdepth:    1,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"parse number\",\n\t\t\tinput:    `42`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42\",\n\t\t\t},\n\t\t\tdepth: 1,\n\t\t\terr:   nil,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tactual, _, err := parseValue(tc.input, c, tc.depth)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil {\n\t\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t\t} else if err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"error mismatch: expected %v, got %v\", tc.err, err)\n\t\t\t\t}\n\t\t\t} else if tc.err != nil {\n\t\t\t\tt.Errorf(\"expected error %v, got nil\", tc.err)\n\t\t\t}\n\n\t\t\tif !valuesEqual(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"unexpected result: expected %+v, got %+v\", tc.expected, actual)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc valuesEqual(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\to1, _ := v1.Object()\n\t\to2, _ := v2.Object()\n\t\treturn objectsEqual(o1, o2)\n\tcase TypeArray:\n\t\ta1, _ := v1.Array()\n\t\ta2, _ := v2.Array()\n\t\tif len(a1) != len(a2) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range a1 {\n\t\t\tif !valuesEqual(a1[i], a2[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase typeRawString, TypeNumber, TypeTrue, TypeFalse, TypeNull:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\tpanic(\"unexpected value type\")\n\t}\n}\n\nfunc objectsEqual(o1, o2 *Object) bool {\n\tif o1 == nil && o2 == nil {\n\t\treturn true\n\t}\n\tif o1 == nil || o2 == nil {\n\t\treturn false\n\t}\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i := range o1.kvs {\n\t\tif o1.kvs[i].k != o2.kvs[i].k {\n\t\t\treturn false\n\t\t}\n\t\tif !valuesEqual(o1.kvs[i].v, o2.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "27cd5aa55d8e553f006c9edbd010abf8": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestHasSpecialChars(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname:     \"Empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"String with no special characters\",\n\t\t\tinput:    \"abcdefghijklmnopqrstuvwxyz\",\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"String with double quote\",\n\t\t\tinput:    \"hello \\\"world\\\"\",\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"String with backslash\",\n\t\t\tinput:    \"hello\\\\world\",\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"String with control character\",\n\t\t\tinput:    \"hello\\nworld\",\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := hasSpecialChars(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"hasSpecialChars(%q) = %v, expected %v\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "264992c214c752cc47b58bbf20058423": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: \"{}\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with one key-value pair\",\n\t\t\tinput: `{\"key\":\"value\"}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with multiple key-value pairs\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":123,\"key3\":true}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\tinput: `{\"key\":\"value\"`,\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing key\",\n\t\t\tinput: `{:123}`,\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing value\",\n\t\t\tinput: `{\"key\":}`,\n\t\t\terr:   true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tactual, _, err := parseObject(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn compareObjects(&v1.o, &v2.o)\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeTrue, TypeFalse:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc compareObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "297a10288aca5d542180707ce840f7cb": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\targs string\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: \"\",\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with no leading whitespace\",\n\t\t\targs: \"hello\",\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with leading whitespace\",\n\t\t\targs: \"   hello\",\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with mixed whitespace\",\n\t\t\targs: \"   \\t\\n\\r hello   \\t\\n\\r\",\n\t\t\twant: \"hello   \\t\\n\\r\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with all whitespace\",\n\t\t\targs: \"   \\t\\n\\r \",\n\t\t\twant: \"\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.args); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2598149e38f0e0fe920438f700e84475": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\ts       string\n\t\tc       *cache\n\t\tdepth   int\n\t\twant    *Value\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\ts:     \"{}\",\n\t\t\tc:     &cache{},\n\t\t\tdepth: 0,\n\t\t\twant: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           []kv{},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with one key-value pair\",\n\t\t\ts:     `{\"key\":\"value\"}`,\n\t\t\tc:     &cache{},\n\t\t\tdepth: 0,\n\t\t\twant: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with multiple key-value pairs\",\n\t\t\ts:     `{\"key1\":\"value1\",\"key2\":123,\"key3\":true}`,\n\t\t\tc:     &cache{},\n\t\t\tdepth: 0,\n\t\t\twant: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\ts:     `{\"key1\":\"value1\",`,\n\t\t\tc:     &cache{},\n\t\t\tdepth: 0,\n\t\t\twant:  nil,\n\t\t\twantS:  `{\"key1\":\"value1\",`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, gotS, err := parseObject(tt.s, tt.c, tt.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !valuesEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseObject() gotS = %v, wantS %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc valuesEqual(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\to1, _ := v1.Object()\n\t\to2, _ := v2.Object()\n\t\treturn objectsEqual(o1, o2)\n\tcase TypeArray:\n\t\ta1, _ := v1.Array()\n\t\ta2, _ := v2.Array()\n\t\tif len(a1) != len(a2) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range a1 {\n\t\t\tif !valuesEqual(a1[i], a2[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeString:\n\t\ts1, _ := v1.StringBytes()\n\t\ts2, _ := v2.StringBytes()\n\t\treturn string(s1) == string(s2)\n\tcase TypeNumber, TypeTrue, TypeFalse:\n\t\treturn v1.s == v2.s\n\tcase TypeNull:\n\t\treturn true\n\tdefault:\n\t\tpanic(\"unknown type\")\n\t}\n}\n\nfunc objectsEqual(o1, o2 *Object) bool {\n\tif o1 == nil && o2 == nil {\n\t\treturn true\n\t}\n\tif o1 == nil || o2 == nil {\n\t\treturn false\n\t}\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i := range o1.kvs {\n\t\tif o1.kvs[i].k != o2.kvs[i].k {\n\t\t\treturn false\n\t\t}\n\t\tif !valuesEqual(o1.kvs[i].v, o2.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "297412639b832349e7f5ce6fcb4c4db4": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantHead string\n\t\twantTail string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"Simple string\",\n\t\t\tinput:    `\"hello, world\"`,\n\t\t\twantHead: \"hello, world\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"String with escaped quotes\",\n\t\t\tinput:    `\"hello, \\\"world\\\"\"`,\n\t\t\twantHead: `hello, \"world\"`,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"String without closing quote\",\n\t\t\tinput:    `\"hello, world`,\n\t\t\twantHead: \"\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Empty string\",\n\t\t\tinput:    `\"\"`,\n\t\t\twantHead: \"\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\thead, tail, err := parseRawString(tt.input)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif head != tt.wantHead {\n\t\t\t\tt.Errorf(\"parseRawString() head = %v, want %v\", head, tt.wantHead)\n\t\t\t}\n\t\t\tif tail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseRawString() tail = %v, want %v\", tail, tt.wantTail)\n\t\t\t}\n\t\t})\n\t}\n}",
    "26e7b14d9c8c2b77c7f3fa7a3edd517c": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\ts       string\n\t\twantV   *Value\n\t\twantTail string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:    \"empty string\",\n\t\t\ts:       \"\",\n\t\t\twantV:   nil,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:    \"max depth exceeded\",\n\t\t\ts:       \"{\\\"key\\\":{}}\", // 2 levels of nesting\n\t\t\twantV:   nil,\n\t\t\twantTail: \"{\\\"key\\\":{}}\",\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:    \"parse object\",\n\t\t\ts:       `{\"key\":\"value\"}`,\n\t\t\twantV:   &Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: &Value{t: typeRawString, s: \"value\"}}}}},\n\t\t\twantTail: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:    \"parse array\",\n\t\t\ts:       `[1,2,3]`,\n\t\t\twantV:   &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}, &Value{t: TypeNumber, s: \"2\"}, &Value{t: TypeNumber, s: \"3\"}}},\n\t\t\twantTail: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:    \"parse string\",\n\t\t\ts:       `\"hello\"`,\n\t\t\twantV:   &Value{t: typeRawString, s: \"hello\"},\n\t\t\twantTail: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:    \"parse true\",\n\t\t\ts:       `true`,\n\t\t\twantV:   valueTrue,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:    \"parse false\",\n\t\t\ts:       `false`,\n\t\t\twantV:   valueFalse,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:    \"parse null\",\n\t\t\ts:       `null`,\n\t\t\twantV:   valueNull,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:    \"parse number\",\n\t\t\ts:       `42`,\n\t\t\twantV:   &Value{t: TypeNumber, s: \"42\"},\n\t\t\twantTail: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, gotTail, err := parseValue(tt.s, c, 0)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !valuesEqual(got, tt.wantV) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.wantV)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseValue() gotTail = %q, want %q\", gotTail, tt.wantTail)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc valuesEqual(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn objectsEqual(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !valuesEqual(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase typeRawString, TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeTrue, TypeFalse, TypeNull:\n\t\treturn true\n\tdefault:\n\t\tpanic(\"unreachable\")\n\t}\n}\n\nfunc objectsEqual(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i := range o1.kvs {\n\t\tif o1.kvs[i].k != o2.kvs[i].k {\n\t\t\treturn false\n\t\t}\n\t\tif !valuesEqual(o1.kvs[i].v, o2.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "2cb611f73ab55538a6a679daf9e960b9": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"no escape sequence\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"simple escape sequence\",\n\t\t\tinput:    \"hello\\\\\\\"world\",\n\t\t\texpected: \"hello\\\"world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple escape sequences\",\n\t\t\tinput:    \"hello\\\\\\\"world\\\\\\\\foo\\\\n\",\n\t\t\texpected: \"hello\\\"world\\\\foo\\n\",\n\t\t},\n\t\t{\n\t\t\tname:     \"unicode escape sequence\",\n\t\t\tinput:    \"hello\\\\u0123world\",\n\t\t\texpected: \"hello\\u0123world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"surrogate pair escape sequence\",\n\t\t\tinput:    \"hello\\\\ud83d\\\\ude00world\",\n\t\t\texpected: \"helloüòÄworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid escape sequence\",\n\t\t\tinput:    \"hello\\\\uworld\",\n\t\t\texpected: \"hello\\\\uworld\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual := unescapeStringBestEffort(tc.input)\n\t\t\tif actual != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2ae0ecdcd56d387cccfbe4e2f5863e58": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"no escape characters\",\n\t\t\tinput:    \"hello world\",\n\t\t\texpected: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"basic escape characters\",\n\t\t\tinput:    \"hello\\\\n\\\\t\\\\\\\"\\\\\\\\world\",\n\t\t\texpected: \"hello\\n\\t\\\"\\\\world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"unicode escape characters\",\n\t\t\tinput:    \"hello\\\\u0123\\\\u4567world\",\n\t\t\texpected: \"hello\\u0123\\u4567world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"surrogate pair\",\n\t\t\tinput:    \"hello\\\\ud800\\\\udc00world\",\n\t\t\texpected: \"hello\\U00010000world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid escape sequence\",\n\t\t\tinput:    \"hello\\\\xyzworld\",\n\t\t\texpected: \"hello\\\\xyzworld\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"Expected: %q, Got: %q\", tc.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2ad93eb098464d4bf66381bf823da026": "package fastjson\n\nimport (\n    \"testing\"\n)\n\nfunc TestGet(t *testing.T) {\n    testCases := []struct {\n        name     string\n        json     string\n        keys     []string\n        expected *Value\n    }{\n        {\n            name: \"Get value from object\",\n            json: `{\"key1\": \"value1\", \"key2\": 123}`,\n            keys: []string{\"key1\"},\n            expected: &Value{\n                s: \"value1\",\n                t: TypeString,\n            },\n        },\n        {\n            name: \"Get value from nested object\",\n            json: `{\"key1\": {\"key2\": \"value2\"}}`,\n            keys: []string{\"key1\", \"key2\"},\n            expected: &Value{\n                s: \"value2\",\n                t: TypeString,\n            },\n        },\n        {\n            name: \"Get value from array\",\n            json: `[\"value1\", \"value2\"]`,\n            keys: []string{\"1\"},\n            expected: &Value{\n                s: \"value2\",\n                t: TypeString,\n            },\n        },\n        {\n            name: \"Get non-existing key\",\n            json: `{\"key1\": \"value1\"}`,\n            keys: []string{\"key2\"},\n            expected: nil,\n        },\n        {\n            name: \"Get non-existing array index\",\n            json: `[\"value1\", \"value2\"]`,\n            keys: []string{\"2\"},\n            expected: nil,\n        },\n    }\n\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            v, err := ParseBytes([]byte(tc.json))\n            if err != nil {\n                t.Errorf(\"unexpected error: %v\", err)\n                return\n            }\n\n            result := v.Get(tc.keys...)\n            if !compareValues(tc.expected, result) {\n                t.Errorf(\"expected %v, got %v\", tc.expected, result)\n            }\n        })\n    }\n}\n\nfunc compareValues(expected, actual *Value) bool {\n    if expected == nil && actual == nil {\n        return true\n    }\n    if expected == nil || actual == nil {\n        return false\n    }\n    if expected.t != actual.t {\n        return false\n    }\n    switch expected.t {\n    case TypeString:\n        return expected.s == actual.s\n    case TypeNumber:\n        // Compare numeric values\n        return true\n    case TypeObject:\n        // Compare object values\n        return true\n    case TypeArray:\n        // Compare array values\n        return true\n    case TypeTrue, TypeFalse, TypeNull:\n        return true\n    default:\n        return false\n    }\n}",
    "2ac68ec39b10b3df95bc31cb624004c3": "package fastjson_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/valyala/fastjson\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *fastjson.Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"empty array\",\n\t\t\tinput:    \"[]\",\n\t\t\texpected: &fastjson.Value{t: fastjson.TypeArray, a: []*fastjson.Value{}},\n\t\t},\n\t\t{\n\t\t\tname:     \"array with one element\",\n\t\t\tinput:    \"[1]\",\n\t\t\texpected: &fastjson.Value{t: fastjson.TypeArray, a: []*fastjson.Value{&fastjson.Value{t: fastjson.TypeNumber, s: \"1\"}}},\n\t\t},\n\t\t{\n\t\t\tname:     \"array with multiple elements\",\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: &fastjson.Value{t: fastjson.TypeArray, a: []*fastjson.Value{&fastjson.Value{t: fastjson.TypeNumber, s: \"1\"}, &fastjson.Value{t: fastjson.TypeNumber, s: \"2\"}, &fastjson.Value{t: fastjson.TypeNumber, s: \"3\"}}},\n\t\t},\n\t\t{\n\t\t\tname:  \"missing closing bracket\",\n\t\t\tinput: \"[1, 2, 3\",\n\t\t\terr:   true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &fastjson.cache{}\n\t\t\tv, _, err := fastjson.parseArray(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"expected error: %v, got: %v\", tc.err, err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif err == nil && !v.Equal(tc.expected) {\n\t\t\t\tt.Errorf(\"expected: %#v, got: %#v\", tc.expected, v)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc (v *fastjson.Value) Equal(other *fastjson.Value) bool {\n\tif v.t != other.t {\n\t\treturn false\n\t}\n\n\tswitch v.t {\n\tcase fastjson.TypeArray:\n\t\ta, _ := v.Array()\n\t\tb, _ := other.Array()\n\t\tif len(a) != len(b) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, vv := range a {\n\t\t\tif !vv.Equal(b[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase fastjson.TypeObject:\n\t\to, _ := v.Object()\n\t\tp, _ := other.Object()\n\t\treturn o.Len() == p.Len()\n\tcase fastjson.TypeString:\n\t\ts, _ := v.StringBytes()\n\t\tt, _ := other.StringBytes()\n\t\treturn string(s) == string(t)\n\tcase fastjson.TypeNumber:\n\t\treturn v.s == other.s\n\tcase fastjson.TypeTrue, fastjson.TypeFalse:\n\t\treturn true\n\tcase fastjson.TypeNull:\n\t\treturn true\n\tdefault:\n\t\tpanic(\"unknown type\")\n\t}\n}",
    "2806f695f214a4e8dff15db27c43a129": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      string\n\t}{\n\t\t{\n\t\t\tname:  \"Valid object\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":true,\"key3\":42}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tobj := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\"key1\", &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t\t{\"key2\", &Value{t: TypeTrue}},\n\t\t\t\t\t\t\t{\"key3\", &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn obj\n\t\t\t}(),\n\t\t\terr: \"\",\n\t\t},\n\t\t{\n\t\t\tname:  \"Missing closing brace\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":true,\"key3\":42`,\n\t\t\texpected: func() *Value {\n\t\t\t\tobj := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\"key1\", &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t\t{\"key2\", &Value{t: TypeTrue}},\n\t\t\t\t\t\t\t{\"key3\", &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn obj\n\t\t\t}(),\n\t\t\terr: \"missing '}'\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Empty input\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      \"missing '}'\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Closing brace without content\",\n\t\t\tinput:    \"}\",\n\t\t\texpected: &Value{t: TypeObject, o: Object{}},\n\t\t\terr:      \"\",\n\t\t},\n\t\t{\n\t\t\tname:  \"Missing key\",\n\t\t\tinput: `{:true}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tobj := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\"\", &Value{t: TypeTrue}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn obj\n\t\t\t}(),\n\t\t\terr: \"cannot find opening '\\\"' for object key\",\n\t\t},\n\t\t{\n\t\t\tname:  \"Missing colon\",\n\t\t\tinput: `{\"key1\" true}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tobj := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\"key1\", &Value{t: TypeTrue}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn obj\n\t\t\t}(),\n\t\t\terr: \"missing ':' after object key\",\n\t\t},\n\t\t{\n\t\t\tname:  \"Missing comma\",\n\t\t\tinput: `{\"key1\":true \"key2\":false}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tobj := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\"key1\", &Value{t: TypeTrue}},\n\t\t\t\t\t\t\t{\"key2\", &Value{t: TypeFalse}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn obj\n\t\t\t}(),\n\t\t\terr: \"missing ',' after object value\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{\n\t\t\t\tvs: make([]Value, 0, 64),\n\t\t\t}\n\t\t\tactual, _, err := parseObject(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == \"\" {\n\t\t\t\t\tt.Errorf(\"parseObject(%q) returned error: %v\", tc.input, err)\n\t\t\t\t} else if err.Error() != tc.err {\n\t\t\t\t\tt.Errorf(\"parseObject(%q) returned unexpected error: %v, expected: %s\", tc.input, err, tc.err)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif tc.err != \"\" {\n\t\t\t\t\tt.Errorf(\"parseObject(%q) did not return expected error: %s\", tc.input, tc.err)\n\t\t\t\t}\n\t\t\t\tif !actual.Equal(tc.expected) {\n\t\t\t\t\tt.Errorf(\"parseObject(%q) returned %v, expected %v\", tc.input, actual, tc.expected)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}",
    "2ceadea7d3d22fb61a883ee6a8978095": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.456e+78\",\n\t\t\texpected: []string{\"123.456e+78\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number with trailing characters\",\n\t\t\tinput:    \"123.456e+78abc\",\n\t\t\texpected: []string{\"123.456e+78\", \"abc\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number with leading non-digit\",\n\t\t\tinput:    \"a123.456e+78\",\n\t\t\texpected: []string{\"\", \"a123.456e+78\"},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty input\",\n\t\t\tinput:    \"\",\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"inf\",\n\t\t\tinput:    \"inf\",\n\t\t\texpected: []string{\"inf\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"nan\",\n\t\t\tinput:    \"nan\",\n\t\t\texpected: []string{\"nan\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, remaining, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.expected[0] {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) num = %q, expected %q\", tc.input, num, tc.expected[0])\n\t\t\t}\n\t\t\tif remaining != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) remaining = %q, expected %q\", tc.input, remaining, tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "2fa92d72de8793804a62897e8d2d73f2": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tt    Type\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"TypeObject\",\n\t\t\tt:    TypeObject,\n\t\t\twant: \"object\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeArray\",\n\t\t\tt:    TypeArray,\n\t\t\twant: \"array\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeString\",\n\t\t\tt:    TypeString,\n\t\t\twant: \"string\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeNumber\",\n\t\t\tt:    TypeNumber,\n\t\t\twant: \"number\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeTrue\",\n\t\t\tt:    TypeTrue,\n\t\t\twant: \"true\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeFalse\",\n\t\t\tt:    TypeFalse,\n\t\t\twant: \"false\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeNull\",\n\t\t\tt:    TypeNull,\n\t\t\twant: \"null\",\n\t\t},\n\t\t{\n\t\t\tname: \"Unknown Type\",\n\t\t\tt:    Type(8),\n\t\t\twant: \"BUG: unknown Value type: 8\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.t.String(); got != tt.want {\n\t\t\t\tt.Errorf(\"Type.String() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2df992bd75b18193a3fe156e4b85d482": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantNum  string\n\t\twantRest string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.456e+78\",\n\t\t\twantNum:  \"123.456e+78\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with trailing non-digit\",\n\t\t\tinput:    \"123.456a\",\n\t\t\twantNum:  \"123.456\",\n\t\t\twantRest: \"a\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty input\",\n\t\t\tinput:    \"\",\n\t\t\twantNum:  \"\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number prefix\",\n\t\t\tinput:    \"abc123\",\n\t\t\twantNum:  \"\",\n\t\t\twantRest: \"abc123\",\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"inf\",\n\t\t\tinput:    \"inf123\",\n\t\t\twantNum:  \"inf\",\n\t\t\twantRest: \"123\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"nan\",\n\t\t\tinput:    \"nan123\",\n\t\t\twantNum:  \"nan\",\n\t\t\twantRest: \"123\",\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.wantNum {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) num = %q, want %q\", tc.input, num, tc.wantNum)\n\t\t\t}\n\t\t\tif rest != tc.wantRest {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) rest = %q, want %q\", tc.input, rest, tc.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2cbc97769b8869a07f477d36c29e51d9": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"empty input\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"depth exceeds MaxDepth\",\n\t\t\tinput:    \"{}\", // Assuming MaxDepth is a constant defined in the source code\n\t\t\texpected: nil,\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid object\",\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: typeRawString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid boolean true\",\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid boolean false\",\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid null\",\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"42\",\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42\",\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, _, err := parseValue(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseValue() = %v, want %v\", actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(a, b *Value) bool {\n\tif a == nil && b == nil {\n\t\treturn true\n\t}\n\tif a == nil || b == nil {\n\t\treturn false\n\t}\n\tif a.t != b.t {\n\t\treturn false\n\t}\n\tswitch a.t {\n\tcase TypeNull, TypeTrue, TypeFalse:\n\t\treturn true\n\tcase TypeNumber, typeRawString:\n\t\treturn a.s == b.s\n\tcase TypeObject:\n\t\treturn compareObjects(&a.o, &b.o)\n\tcase TypeArray:\n\t\tif len(a.a) != len(b.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range a.a {\n\t\t\tif !compareValues(a.a[i], b.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc compareObjects(a, b *Object) bool {\n\tif len(a.kvs) != len(b.kvs) {\n\t\treturn false\n\t}\n\tfor i := range a.kvs {\n\t\tif a.kvs[i].k != b.kvs[i].k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(a.kvs[i].v, b.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "2f909e3670e0008a815b20c6f7e8a3a7": "package fastjson\n\nimport (\n    \"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n    testCases := []struct {\n        name     string\n        input    string\n        wantKey  string\n        wantRest string\n        wantErr  bool\n    }{\n        {\n            name:     \"simple string\",\n            input:    `\"hello\"`,\n            wantKey:  \"hello\",\n            wantRest: \"\",\n            wantErr:  false,\n        },\n        {\n            name:     \"string with escaped quote\",\n            input:    `\"hello\\\"world\"`,\n            wantKey:  `hello\"world`,\n            wantRest: \"\",\n            wantErr:  false,\n        },\n        {\n            name:     \"string with multiple escaped quotes\",\n            input:    `\"hello\\\"world\\\"foo\"`,\n            wantKey:  `hello\"world\"foo`,\n            wantRest: \"\",\n            wantErr:  false,\n        },\n        {\n            name:     \"string with missing closing quote\",\n            input:    `\"hello`,\n            wantKey:  \"\",\n            wantRest: \"\",\n            wantErr:  true,\n        },\n    }\n\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            key, rest, err := parseRawString(tc.input)\n            if (err != nil) != tc.wantErr {\n                t.Errorf(\"parseRawString(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n                return\n            }\n            if key != tc.wantKey {\n                t.Errorf(\"parseRawString(%q) key = %q, want %q\", tc.input, key, tc.wantKey)\n            }\n            if rest != tc.wantRest {\n                t.Errorf(\"parseRawString(%q) rest = %q, want %q\", tc.input, rest, tc.wantRest)\n            }\n        })\n    }\n}",
    "2e1e87a1802ab10a8d0fff9413ec247c": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"plain string\",\n\t\t\texpected: \"plain string\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape double quote\",\n\t\t\tinput:    \"\\\"escaped\\\"\",\n\t\t\texpected: \"\\\"escaped\\\"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backslash\",\n\t\t\tinput:    \"\\\\escaped\\\\\",\n\t\t\texpected: \"\\\\escaped\\\\\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape forward slash\",\n\t\t\tinput:    \"/escaped/\",\n\t\t\texpected: \"/escaped/\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backspace\",\n\t\t\tinput:    \"b\\bescaped\\b\",\n\t\t\texpected: \"b\\bescaped\\b\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape form feed\",\n\t\t\tinput:    \"f\\fescaped\\f\",\n\t\t\texpected: \"f\\fescaped\\f\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape newline\",\n\t\t\tinput:    \"n\\nescaped\\n\",\n\t\t\texpected: \"n\\nescaped\\n\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape carriage return\",\n\t\t\tinput:    \"r\\rescued\\r\",\n\t\t\texpected: \"r\\rescued\\r\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape tab\",\n\t\t\tinput:    \"t\\tescaped\\t\",\n\t\t\texpected: \"t\\tescaped\\t\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Unicode character\",\n\t\t\tinput:    \"\\\\u0123escaped\\\\u4567\",\n\t\t\texpected: \"escaped\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape invalid Unicode character\",\n\t\t\tinput:    \"\\\\u00escaped\\\\u0000\",\n\t\t\texpected: \"\\\\u00escaped\\\\u0000\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape surrogate pair\",\n\t\t\tinput:    \"\\\\ud800\\\\udc00escaped\\\\ud800\\\\udc01\",\n\t\t\texpected: \"êÄÄescapedêÄÅ\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape invalid surrogate pair\",\n\t\t\tinput:    \"\\\\ud800escaped\\\\udc00\",\n\t\t\texpected: \"\\\\ud800escaped\\\\udc00\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2d5f2487d64d711a19307d18f38dabf3": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tinput   string\n\t\twant1   string\n\t\twant2   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"valid number\",\n\t\t\tinput:   \"123.45e+6\",\n\t\t\twant1:   \"123.45e+6\",\n\t\t\twant2:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"valid number with sign\",\n\t\t\tinput:   \"-0.0\",\n\t\t\twant1:   \"-0.0\",\n\t\t\twant2:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"valid inf\",\n\t\t\tinput:   \"inf\",\n\t\t\twant1:   \"inf\",\n\t\t\twant2:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"valid nan\",\n\t\t\tinput:   \"nan\",\n\t\t\twant1:   \"nan\",\n\t\t\twant2:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid character\",\n\t\t\tinput:   \"123a\",\n\t\t\twant1:   \"\",\n\t\t\twant2:   \"123a\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"empty input\",\n\t\t\tinput:   \"\",\n\t\t\twant1:   \"\",\n\t\t\twant2:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot1, got2, err := parseRawNumber(tt.input)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawNumber() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t\tif got2 != tt.want2 {\n\t\t\t\tt.Errorf(\"parseRawNumber() got2 = %v, want %v\", got2, tt.want2)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2cc3b709604c5951ce3e82ebc9f8d8ad": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: \"{}\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"single key-value pair\",\n\t\t\tinput: `{\"key\":\"value\"}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"multiple key-value pairs\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":\"value2\"}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"missing closing brace\",\n\t\t\tinput: `{\"key\":\"value\"`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:  \"missing key\",\n\t\t\tinput: `{:true}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:  \"missing value\",\n\t\t\tinput: `{\"key\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{\n\t\t\t\tvs: make([]Value, 0, 8),\n\t\t\t}\n\t\t\tgot, _, err := parseObject(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !equalValues(got, tc.expected) {\n\t\t\t\tt.Errorf(\"parseObject() = %v, want %v\", got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn equalObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn equalArrays(v1.a, v2.a)\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber, TypeTrue, TypeFalse, TypeNull:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc equalObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !equalValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc equalArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tv2 := a2[i]\n\t\tif !equalValues(v1, v2) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "2fb0fc2eb32e058ac2dd842299b25569": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestGet(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\tkeys     []string\n\t\texpected *Value\n\t}{\n\t\t{\n\t\t\tname: \"Existing keys\",\n\t\t\tvalue: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{a: []*Value{&Value{s: \"value2\"}, &Value{s: \"value3\"}}}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"key1\", \"key2\", \"1\"},\n\t\t\texpected: &Value{s: \"value3\"},\n\t\t},\n\t\t{\n\t\t\tname:     \"Non-existing keys\",\n\t\t\tvalue:    &Value{o: Object{kvs: []kv{}}},\n\t\t\tkeys:     []string{\"non-existing\", \"key\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Nil value\",\n\t\t\tvalue:    nil,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Invalid type\",\n\t\t\tvalue: &Value{\n\t\t\t\ts: \"string value\",\n\t\t\t},\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: nil,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := tc.value.Get(tc.keys...)\n\t\t\tif !reflect.DeepEqual(result, tc.expected) {\n\t\t\t\tt.Errorf(\"Get(%v) = %v, want %v\", tc.keys, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2d6e38d353e304097ec83f3d45819f1d": "package fastjson\n\nimport (\n    \"fmt\"\n    \"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n    testCases := []struct {\n        name     string\n        input    string\n        expected *Value\n        err      error\n    }{\n        {\n            name:  \"empty object\",\n            input: `{}`,\n            expected: func() *Value {\n                v := &Value{\n                    t: TypeObject,\n                    o: Object{\n                        kvs:           []kv{},\n                        keysUnescaped: true,\n                    },\n                }\n                return v\n            }(),\n            err: nil,\n        },\n        {\n            name:  \"simple object\",\n            input: `{\"key1\":\"value1\",\"key2\":42}`,\n            expected: func() *Value {\n                v := &Value{\n                    t: TypeObject,\n                    o: Object{\n                        kvs: []kv{\n                            {k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n                            {k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n                        },\n                        keysUnescaped: true,\n                    },\n                }\n                return v\n            }(),\n            err: nil,\n        },\n        {\n            name:  \"object with nested object\",\n            input: `{\"key1\":{\"subkey1\":\"subvalue1\"},\"key2\":42}`,\n            expected: func() *Value {\n                v := &Value{\n                    t: TypeObject,\n                    o: Object{\n                        kvs: []kv{\n                            {k: \"key1\", v: &Value{\n                                t: TypeObject,\n                                o: Object{\n                                    kvs: []kv{\n                                        {k: \"subkey1\", v: &Value{t: TypeString, s: \"subvalue1\"}},\n                                    },\n                                    keysUnescaped: true,\n                                },\n                            }},\n                            {k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n                        },\n                        keysUnescaped: true,\n                    },\n                }\n                return v\n            }(),\n            err: nil,\n        },\n        {\n            name:  \"object with missing closing brace\",\n            input: `{\"key1\":\"value1\",\"key2\":42`,\n            expected: nil,\n            err:      fmt.Errorf(\"missing '}'\"),\n        },\n    }\n\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            c := &cache{}\n            actual, _, err := parseObject(tc.input, c, 0)\n            if err != nil {\n                if tc.err == nil {\n                    t.Errorf(\"unexpected error: %v\", err)\n                } else if err.Error() != tc.err.Error() {\n                    t.Errorf(\"unexpected error, expected: %v, got: %v\", tc.err, err)\n                }\n            } else {\n                if tc.err != nil {\n                    t.Errorf(\"expected error: %v, got nil\", tc.err)\n                }\n                if !objectEqual(actual, tc.expected) {\n                    t.Errorf(\"unexpected result, expected: %v, got: %v\", tc.expected, actual)\n                }\n            }\n        })\n    }\n}\n\nfunc objectEqual(v1, v2 *Value) bool {\n    if v1 == nil && v2 == nil {\n        return true\n    }\n    if v1 == nil || v2 == nil {\n        return false\n    }\n    if v1.t != v2.t {\n        return false\n    }\n    if v1.t == TypeObject {\n        if len(v1.o.kvs) != len(v2.o.kvs) {\n            return false\n        }\n        for i := range v1.o.kvs {\n            if v1.o.kvs[i].k != v2.o.kvs[i].k {\n                return false\n            }\n            if !objectEqual(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n                return false\n            }\n        }\n        return true\n    }\n    return v1.s == v2.s\n}",
    "2fe3ae84a715a014fd4df63781c671e4": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"empty input\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"depth exceeds MaxDepth\",\n\t\t\tinput:    \"{}\", // Recursive input\n\t\t\texpected: nil,\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid object\",\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{t: TypeObject},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{t: TypeArray},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{t: typeRawString, s: \"hello\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid true\",\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid false\",\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid null\",\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"42\",\n\t\t\texpected: &Value{t: TypeNumber, s: \"42\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid value\",\n\t\t\tinput:    \"invalid\",\n\t\t\texpected: nil,\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tv, _, err := parseValue(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif v == nil && tc.expected == nil {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif v == nil || tc.expected == nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, expected %v\", tc.input, v, tc.expected)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif v.t != tc.expected.t {\n\t\t\t\tt.Errorf(\"parseValue(%q) type = %v, expected %v\", tc.input, v.t, tc.expected.t)\n\t\t\t}\n\n\t\t\tif v.s != tc.expected.s {\n\t\t\t\tt.Errorf(\"parseValue(%q) value = %v, expected %v\", tc.input, v.s, tc.expected.s)\n\t\t\t}\n\t\t})\n\t}\n}",
    "303ad9d4dc410347d2cbd3bf7c648fec": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_getKV(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\to    *Object\n\t\twant *kv\n\t}{\n\t\t{\n\t\t\tname: \"empty kvs\",\n\t\t\to:    &Object{kvs: []kv{}},\n\t\t\twant: &kv{},\n\t\t},\n\t\t{\n\t\t\tname: \"non-empty kvs\",\n\t\t\to:    &Object{kvs: []kv{{k: \"key1\", v: &Value{}}, {k: \"key2\", v: &Value{}}}},\n\t\t\twant: &kv{k: \"key2\", v: &Value{}},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.o.getKV(); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Object.getKV() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "303b207c74ac5ea4ce5afbb436c3bd7f": "package fastjson_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/valyala/fastjson\"\n)\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tt    fastjson.Type\n\t\twant string\n\t}{\n\t\t{\"TypeObject\", fastjson.TypeObject, \"object\"},\n\t\t{\"TypeArray\", fastjson.TypeArray, \"array\"},\n\t\t{\"TypeString\", fastjson.TypeString, \"string\"},\n\t\t{\"TypeNumber\", fastjson.TypeNumber, \"number\"},\n\t\t{\"TypeTrue\", fastjson.TypeTrue, \"true\"},\n\t\t{\"TypeFalse\", fastjson.TypeFalse, \"false\"},\n\t\t{\"TypeNull\", fastjson.TypeNull, \"null\"},\n\t\t{\"unknown\", fastjson.Type(100), \"BUG: unknown Value type: 100\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.t.String(); got != tt.want {\n\t\t\t\tt.Errorf(\"Type.String() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2ff1850ae86de1ccc21484979242f638": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected struct {\n\t\t\tkey      string\n\t\t\tvalue    string\n\t\t\thasError bool\n\t\t}\n\t}{\n\t\t{\n\t\t\tname:  \"basic string\",\n\t\t\tinput: `\"hello, world\"`,\n\t\t\texpected: struct {\n\t\t\t\tkey      string\n\t\t\t\tvalue    string\n\t\t\t\thasError bool\n\t\t\t}{\n\t\t\t\tkey:      \"hello, world\",\n\t\t\t\tvalue:    \"\",\n\t\t\t\thasError: false,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"string with escaped quote\",\n\t\t\tinput: `\"hello, \\\"world\\\"\"`,\n\t\t\texpected: struct {\n\t\t\t\tkey      string\n\t\t\t\tvalue    string\n\t\t\t\thasError bool\n\t\t\t}{\n\t\t\t\tkey:      \"hello, \\\"world\\\"\",\n\t\t\t\tvalue:    \"\",\n\t\t\t\thasError: false,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"string with only quotes\",\n\t\t\tinput: `\"\"\"`,\n\t\t\texpected: struct {\n\t\t\t\tkey      string\n\t\t\t\tvalue    string\n\t\t\t\thasError bool\n\t\t\t}{\n\t\t\t\tkey:      \"\",\n\t\t\t\tvalue:    \"\",\n\t\t\t\thasError: true,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"string with no closing quote\",\n\t\t\tinput: `\"hello, world`,\n\t\t\texpected: struct {\n\t\t\t\tkey      string\n\t\t\t\tvalue    string\n\t\t\t\thasError bool\n\t\t\t}{\n\t\t\t\tkey:      \"\",\n\t\t\t\tvalue:    \"\",\n\t\t\t\thasError: true,\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tkey, value, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.expected.hasError {\n\t\t\t\tt.Errorf(\"unexpected error state, got: %v, want: %v\", err != nil, tc.expected.hasError)\n\t\t\t}\n\t\t\tif key != tc.expected.key {\n\t\t\t\tt.Errorf(\"unexpected key, got: %q, want: %q\", key, tc.expected.key)\n\t\t\t}\n\t\t\tif value != tc.expected.value {\n\t\t\t\tt.Errorf(\"unexpected value, got: %q, want: %q\", value, tc.expected.value)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2ff24b4095c848855256487499af5870": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestGet(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    *Value\n\t\tkeys     []string\n\t\texpected *Value\n\t}{\n\t\t{\n\t\t\tname: \"get from object\",\n\t\t\tinput: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: &Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"foo\", v: &Value{t: TypeString, s: \"bar\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"foo\"},\n\t\t\texpected: &Value{t: TypeString, s: \"bar\"},\n\t\t},\n\t\t{\n\t\t\tname: \"get from array\",\n\t\t\tinput: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"foo\"},\n\t\t\t\t\t{t: TypeString, s: \"bar\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"1\"},\n\t\t\texpected: &Value{t: TypeString, s: \"bar\"},\n\t\t},\n\t\t{\n\t\t\tname:     \"get from nil\",\n\t\t\tinput:    nil,\n\t\t\tkeys:     []string{\"foo\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"get non-existing key\",\n\t\t\tinput: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: &Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"foo\", v: &Value{t: TypeString, s: \"bar\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"baz\"},\n\t\t\texpected: nil,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := tc.input.Get(tc.keys...)\n\t\t\tif !reflect.DeepEqual(result, tc.expected) {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tc.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "30a6bbea29b047461f96d6422567f1ed": "package fastjson\n\nimport (\n    \"testing\"\n)\n\nfunc TestGetInt(t *testing.T) {\n    testCases := []struct {\n        name     string\n        input    *Value\n        keys     []string\n        expected int\n    }{\n        {\n            name:     \"valid int value\",\n            input:    &Value{s: \"42\", t: TypeNumber},\n            keys:     []string{},\n            expected: 42,\n        },\n        {\n            name:     \"non-existing keys path\",\n            input:    &Value{s: \"42\", t: TypeNumber},\n            keys:     []string{\"non\", \"existing\", \"keys\"},\n            expected: 0,\n        },\n        {\n            name:     \"invalid value type\",\n            input:    &Value{s: \"true\", t: TypeTrue},\n            keys:     []string{},\n            expected: 0,\n        },\n        {\n            name:     \"nil input\",\n            input:    nil,\n            keys:     []string{},\n            expected: 0,\n        },\n        {\n            name:     \"array index in keys\",\n            input:    &Value{a: []*Value{&Value{s: \"42\", t: TypeNumber}, &Value{s: \"24\", t: TypeNumber}}, t: TypeArray},\n            keys:     []string{\"1\"},\n            expected: 24,\n        },\n        {\n            name:     \"float64 value\",\n            input:    &Value{s: \"3.14\", t: TypeNumber},\n            keys:     []string{},\n            expected: 3,\n        },\n    }\n\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            result := tc.input.GetInt(tc.keys...)\n            if result != tc.expected {\n                t.Errorf(\"GetInt(%v) = %d, expected %d\", tc.keys, result, tc.expected)\n            }\n        })\n    }\n}",
    "3081f2b7867988b78d42025b66c8cccd": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantNum  string\n\t\twantRest string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.456e+7\",\n\t\t\twantNum:  \"123.456e+7\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with trailing non-digit\",\n\t\t\tinput:    \"123.456x\",\n\t\t\twantNum:  \"123.456\",\n\t\t\twantRest: \"x\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty input\",\n\t\t\tinput:    \"\",\n\t\t\twantNum:  \"\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid start\",\n\t\t\tinput:    \"xabc\",\n\t\t\twantNum:  \"\",\n\t\t\twantRest: \"xabc\",\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.wantNum {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) num = %q, want %q\", tc.input, num, tc.wantNum)\n\t\t\t}\n\t\t\tif rest != tc.wantRest {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) rest = %q, want %q\", tc.input, rest, tc.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "3054603d186f99fd6bc0c1c19a1e5682": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Simple escape characters\",\n\t\t\tinput:    \"hello\\\\\\\"world\\\\/\\\\b\\\\f\\\\n\\\\r\\\\t\",\n\t\t\texpected: \"hello\\\"world/\\b\\f\\n\\r\\t\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Unicode escape characters\",\n\t\t\tinput:    \"\\\\u0123\\\\u4567\",\n\t\t\texpected: \"\\u0123\\u4567\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Surrogate pair\",\n\t\t\tinput:    \"\\\\ud83d\\\\ude00\",\n\t\t\texpected: \"üòÄ\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid escape sequence\",\n\t\t\tinput:    \"\\\\u001\",\n\t\t\texpected: \"\\\\u001\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2e2c86f97ac7952a6d612a1dfbcc2116": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tinput   string\n\t\twantV   *Value\n\t\twantTail string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:    \"empty input\",\n\t\t\tinput:   \"\",\n\t\t\twantV:   nil,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:    \"max depth exceeded\",\n\t\t\tinput:   \"{}\", // Nesting level 1\n\t\t\twantV:   nil,\n\t\t\twantTail: \"{}\", // Original input\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:    \"parse object\",\n\t\t\tinput:   `{\"key\":\"value\"}`,\n\t\t\twantV:   &Value{o: Object{kvs: []kv{{k: \"key\", v: &Value{s: \"value\", t: typeRawString}}}}, t: TypeObject},\n\t\t\twantTail: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:    \"parse array\",\n\t\t\tinput:   `[1,2,3]`,\n\t\t\twantV:   &Value{a: []*Value{\n\t\t\t\t{s: \"1\", t: TypeNumber},\n\t\t\t\t{s: \"2\", t: TypeNumber},\n\t\t\t\t{s: \"3\", t: TypeNumber},\n\t\t\t}, t: TypeArray},\n\t\t\twantTail: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:    \"parse string\",\n\t\t\tinput:   `\"hello\"`,\n\t\t\twantV:   &Value{s: \"hello\", t: typeRawString},\n\t\t\twantTail: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:    \"parse true\",\n\t\t\tinput:   \"true\",\n\t\t\twantV:   valueTrue,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:    \"parse false\",\n\t\t\tinput:   \"false\",\n\t\t\twantV:   valueFalse,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:    \"parse null\",\n\t\t\tinput:   \"null\",\n\t\t\twantV:   valueNull,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:    \"parse number\",\n\t\t\tinput:   \"123\",\n\t\t\twantV:   &Value{s: \"123\", t: TypeNumber},\n\t\t\twantTail: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:    \"parse NaN\",\n\t\t\tinput:   \"NaN\",\n\t\t\twantV:   &Value{s: \"NaN\", t: TypeNumber},\n\t\t\twantTail: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:    \"unexpected value\",\n\t\t\tinput:   \"abc\",\n\t\t\twantV:   nil,\n\t\t\twantTail: \"abc\",\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotV, gotTail, err := parseValue(tt.input, c, 0)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !compareValues(gotV, tt.wantV) {\n\t\t\t\tt.Errorf(\"parseValue() gotV = %v, want %v\", gotV, tt.wantV)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseValue() gotTail = %v, want %v\", gotTail, tt.wantTail)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase typeRawString:\n\t\treturn v1.s == v2.s\n\tcase TypeObject:\n\t\treturn compareObjects(v1.o, v2.o)\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !compareValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeNumber, TypeTrue, TypeFalse:\n\t\treturn v1.s == v2.s\n\tcase TypeNull:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc compareObjects(o1, o2 Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i := range o1.kvs {\n\t\tif o1.kvs[i].k != o2.kvs[i].k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(o1.kvs[i].v, o2.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "2ff422ba8ebbc2fbda9512c1f666199b": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGet(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tvalue *Value\n\t\tkeys  []string\n\t\twant  *Value\n\t}{\n\t\t{\n\t\t\tname: \"get from object\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: &Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"name\", v: &Value{t: TypeString, s: \"John\"}},\n\t\t\t\t\t\t{k: \"age\", v: &Value{t: TypeNumber, s: \"30\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys: []string{\"name\"},\n\t\t\twant: &Value{t: TypeString, s: \"John\"},\n\t\t},\n\t\t{\n\t\t\tname: \"get from array\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"Alice\"},\n\t\t\t\t\t{t: TypeString, s: \"Bob\"},\n\t\t\t\t\t{t: TypeString, s: \"Charlie\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys: []string{\"1\"},\n\t\t\twant: &Value{t: TypeString, s: \"Bob\"},\n\t\t},\n\t\t{\n\t\t\tname: \"non-existing key\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: &Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"name\", v: &Value{t: TypeString, s: \"John\"}},\n\t\t\t\t\t\t{k: \"age\", v: &Value{t: TypeNumber, s: \"30\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys: []string{\"address\"},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"non-existing array index\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"Alice\"},\n\t\t\t\t\t{t: TypeString, s: \"Bob\"},\n\t\t\t\t\t{t: TypeString, s: \"Charlie\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys: []string{\"3\"},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid array index\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"Alice\"},\n\t\t\t\t\t{t: TypeString, s: \"Bob\"},\n\t\t\t\t\t{t: TypeString, s: \"Charlie\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys: []string{\"a\"},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"nil value\",\n\t\t\tvalue: nil,\n\t\t\tkeys: []string{\"name\"},\n\t\t\twant: nil,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.value.Get(tt.keys...)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Get() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "33bbc286c9451caee7ebaaf46dcc21c3": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestReset(t *testing.T) {\n\t// Create a new Object\n\to := &Object{\n\t\tkvs:           []kv{{\"key1\", &Value{}}, {\"key2\", &Value{}}},\n\t\tkeysUnescaped: true,\n\t}\n\n\t// Call the reset function\n\to.reset()\n\n\t// Verify that the kvs slice has been shortened by 1 and keysUnescaped is set to false\n\tif len(o.kvs) != 1 {\n\t\tt.Errorf(\"expected length of o.kvs to be 1, got %d\", len(o.kvs))\n\t}\n\tif o.keysUnescaped {\n\t\tt.Errorf(\"expected o.keysUnescaped to be false, got true\")\n\t}\n}",
    "31708e9592fc730726c6da06f0a4e763": "package fastjson\n\nimport (\n    \"testing\"\n)\n\nfunc TestGetObject(t *testing.T) {\n    // Test cases\n    testCases := []struct {\n        name     string\n        input    *Value\n        keys     []string\n        expected *Object\n    }{\n        {\n            name: \"Existing keys path\",\n            input: &Value{\n                o: Object{\n                    kvs: []kv{\n                        {k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n                        {k: \"key2\", v: &Value{t: TypeObject, o: Object{\n                            kvs: []kv{\n                                {k: \"subkey1\", v: &Value{t: TypeString, s: \"subvalue1\"}},\n                            },\n                        }}},\n                    },\n                },\n            },\n            keys:     []string{\"key2\"},\n            expected: &Object{\n                kvs: []kv{\n                    {k: \"subkey1\", v: &Value{t: TypeString, s: \"subvalue1\"}},\n                },\n            },\n        },\n        {\n            name: \"Non-existing keys path\",\n            input: &Value{\n                o: Object{\n                    kvs: []kv{\n                        {k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n                    },\n                },\n            },\n            keys:     []string{\"key2\", \"subkey\"},\n            expected: nil,\n        },\n        {\n            name: \"Invalid value type\",\n            input: &Value{\n                s: \"not an object\",\n                t: TypeString,\n            },\n            keys:     []string{\"key\"},\n            expected: nil,\n        },\n    }\n\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            result := tc.input.GetObject(tc.keys...)\n            if tc.expected != result {\n                t.Errorf(\"GetObject(%v) = %v, want %v\", tc.keys, result, tc.expected)\n            }\n        })\n    }\n}",
    "333e884dc25e2d7b7f3d4f1c2e529dc0": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: []string{\"hello\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello\\\"world\"`,\n\t\t\texpected: []string{\"hello\\\"world\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello\\\"world\\\"foo\"`,\n\t\t\texpected: []string{\"hello\\\"world\\\"foo\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string without closing quote\",\n\t\t\tinput:    `\"hello`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    `\"\"`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tstr, rest, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif str != tc.expected[0] || rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = %q, %q, want %q, %q\", tc.input, str, rest, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "34b7165e20b8f325f1cd12eb03dfd9f7": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestInt(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    *Value\n\t\texpected int\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid int\",\n\t\t\tinput:    &Value{s: \"42\", t: TypeNumber},\n\t\t\texpected: 42,\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"value is not a number\",\n\t\t\tinput:    &Value{s: \"foo\", t: TypeString},\n\t\t\texpected: 0,\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"number doesn't fit int\",\n\t\t\tinput:    &Value{s: \"9223372036854775807\", t: TypeNumber},\n\t\t\texpected: 0,\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number\",\n\t\t\tinput:    &Value{s: \"invalid\", t: TypeNumber},\n\t\t\texpected: 1,\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot, err := tc.input.Int()\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"Int() error = %v, wantErr %v\", err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tc.expected {\n\t\t\t\tt.Errorf(\"Int() got = %v, want %v\", got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "387bddf6b1481bddeded9525ddd43a5d": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"hello world\",\n\t\t\texpected: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Simple escape characters\",\n\t\t\tinput:    \"hello\\\\\\\"world\\\\\\\\\",\n\t\t\texpected: \"hello\\\"world\\\\\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Unicode escape characters\",\n\t\t\tinput:    \"hello\\\\u0123world\\\\u4567\",\n\t\t\texpected: \"hello\\u0123world\\u4567\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Surrogate pair escape characters\",\n\t\t\tinput:    \"hello\\\\ud834\\\\udd1e world\",\n\t\t\texpected: \"hello\\U0001d11e world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid escape characters\",\n\t\t\tinput:    \"hello\\\\xyzworld\",\n\t\t\texpected: \"hello\\\\xyzworld\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "3a0ad62efe4f25d6536920f0034c4190": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    string\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"no escape characters\",\n\t\t\ts:    \"hello world\",\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"simple escape characters\",\n\t\t\ts:    \"hello\\\\\\\"world\\\\\\\\\",\n\t\t\twant: \"hello\\\"world\\\\\",\n\t\t},\n\t\t{\n\t\t\tname: \"complex escape characters\",\n\t\t\ts:    \"hello\\\\u0000world\\\\u1234\\\\u{10FFFF}\",\n\t\t\twant: \"hello\\x00world\\u1234\\U0010FFFF\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape characters\",\n\t\t\ts:    \"hello\\\\uworld\\\\u123\",\n\t\t\twant: \"hello\\\\uworld\\\\u123\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.s); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", tt.s, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "36b8bc01cb6a97aac3ef6a838c4f1a2d": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape sequences\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Simple escape sequences\",\n\t\t\tinput:    \"hello\\\\\\\"world\\\\\\\\\",\n\t\t\texpected: \"hello\\\"world\\\\\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Complex escape sequences\",\n\t\t\tinput:    \"hello\\\\u0041\\\\u00E9world\\\\b\\\\f\\\\n\\\\r\\\\t\",\n\t\t\texpected: \"helloA√©world\\b\\f\\n\\r\\t\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Incomplete escape sequence\",\n\t\t\tinput:    \"hello\\\\u004\",\n\t\t\texpected: \"hello\\\\u004\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid escape sequence\",\n\t\t\tinput:    \"hello\\\\uXYZZ\",\n\t\t\texpected: \"hello\\\\uXYZZ\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Surrogate pair\",\n\t\t\tinput:    \"hello\\\\uD83D\\\\uDE00world\",\n\t\t\texpected: \"helloüòÄworld\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "39322df48baace138a017c3d3bc1d3b5": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestValue_GetArray(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tvalue  *Value\n\t\tkeys   []string\n\t\texpect []*Value\n\t}{\n\t\t{\n\t\t\tname: \"valid array\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:   []string{\"0\", \"1\", \"2\"},\n\t\t\texpect: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}},\n\t\t},\n\t\t{\n\t\t\tname: \"non-existing keys\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:   []string{\"0\", \"1\", \"3\"},\n\t\t\texpect: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, nil},\n\t\t},\n\t\t{\n\t\t\tname:   \"nil value\",\n\t\t\tvalue:  nil,\n\t\t\tkeys:   []string{\"0\", \"1\", \"2\"},\n\t\t\texpect: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"non-array value\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"foo\", v: &Value{t: TypeNumber, s: \"1\"}},\n\t\t\t\t\t\t{k: \"bar\", v: &Value{t: TypeNumber, s: \"2\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:   []string{\"0\", \"1\", \"2\"},\n\t\t\texpect: nil,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.value.GetArray(tt.keys...)\n\t\t\tif !reflect.DeepEqual(got, tt.expect) {\n\t\t\t\tt.Errorf(\"Value.GetArray() = %v, expect %v\", got, tt.expect)\n\t\t\t}\n\t\t})\n\t}\n}",
    "352054701a05c0ea76f056039ee028d9": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape double quotes\",\n\t\t\tinput:    \"\\\"hello, world\\\"\",\n\t\t\texpected: `\"hello, world\"`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backslash\",\n\t\t\tinput:    \"\\\\hello, world\\\\\",\n\t\t\texpected: `\\hello, world\\`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape forward slash\",\n\t\t\tinput:    \"/hello, world/\",\n\t\t\texpected: `/hello, world/`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backspace\",\n\t\t\tinput:    \"h\\bello, world\",\n\t\t\texpected: \"h\\bello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape form feed\",\n\t\t\tinput:    \"h\\fello, world\",\n\t\t\texpected: \"h\\fello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape newline\",\n\t\t\tinput:    \"h\\nello, world\",\n\t\t\texpected: \"h\\nello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape carriage return\",\n\t\t\tinput:    \"h\\rello, world\",\n\t\t\texpected: \"h\\rello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape tab\",\n\t\t\tinput:    \"h\\tello, world\",\n\t\t\texpected: \"h\\tello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape unicode\",\n\t\t\tinput:    \"\\\\u0061\\\\u0062\\\\u0063\",\n\t\t\texpected: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape unicode surrogate pair\",\n\t\t\tinput:    \"\\\\ud83d\\\\ude00\",\n\t\t\texpected: \"üòÄ\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid escape sequence\",\n\t\t\tinput:    \"\\\\x hello, world\",\n\t\t\texpected: \"\\\\x hello, world\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "3a398eada6bb87a5c52c84d718887602": "package fastjson_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/valyala/fastjson\"\n)\n\nfunc TestValue_Object(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tv       *fastjson.Value\n\t\twant    *fastjson.Object\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"valid JSON object\",\n\t\t\tv: &fastjson.Value{\n\t\t\t\tt: fastjson.TypeObject,\n\t\t\t\to: fastjson.Object{\n\t\t\t\t\tkvs: []fastjson.kv{\n\t\t\t\t\t\t{k: \"key1\", v: &fastjson.Value{t: fastjson.TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &fastjson.Value{t: fastjson.TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant:    &fastjson.Value{t: fastjson.TypeObject, o: fastjson.Object{kvs: []fastjson.kv{{k: \"key1\", v: &fastjson.Value{t: fastjson.TypeString, s: \"value1\"}}, {k: \"key2\", v: &fastjson.Value{t: fastjson.TypeNumber, s: \"42\"}}}}.o,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"non-object type\",\n\t\t\tv: &fastjson.Value{\n\t\t\t\tt: fastjson.TypeArray,\n\t\t\t\ta: []*fastjson.Value{\n\t\t\t\t\t{t: fastjson.TypeString, s: \"value1\"},\n\t\t\t\t\t{t: fastjson.TypeNumber, s: \"42\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := tt.v.Object()\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Value.Object() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.Object() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "3c43fd358c0d29f9399e5e3093638908": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWS(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"Empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"String with leading whitespace\",\n\t\t\tinput:    \"   hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"String with trailing whitespace\",\n\t\t\tinput:    \"hello   \",\n\t\t\texpected: \"hello   \",\n\t\t},\n\t\t{\n\t\t\tname:     \"String with leading and trailing whitespace\",\n\t\t\tinput:    \"   hello   \",\n\t\t\texpected: \"hello   \",\n\t\t},\n\t\t{\n\t\t\tname:     \"String with no whitespace\",\n\t\t\tinput:    \"hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := skipWS(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"skipWS(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "34e720be16f6ed3adf8118013d3b1dfe": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tinput   string\n\t\twant    *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:  \"simple object\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42}`,\n\t\t\twant: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: `{}`,\n\t\t\twant: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"missing closing brace\",\n\t\t\tinput:   `{\"key1\":\"value1\",\"key2\":42`,\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"missing colon\",\n\t\t\tinput:   `{\"key1\":\"value1\" \"key2\":42}`,\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"missing key\",\n\t\t\tinput:   `{:42}`,\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tgot, _, err := parseObject(tt.input, c, 0)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !EqualValue(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// EqualValue is a helper function to compare two Values for equality\nfunc EqualValue(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn EqualObject(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn EqualArray(v1.a, v2.a)\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber, TypeTrue, TypeFalse:\n\t\treturn v1.s == v2.s\n\tcase TypeNull:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc EqualObject(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !EqualValue(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc EqualArray(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tif !EqualValue(v1, a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "3b184aa717383a10e0642287c3ad0201": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty array\",\n\t\t\tinput:    \"[]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{}},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with values\",\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}, &Value{t: TypeNumber, s: \"2\"}, &Value{t: TypeNumber, s: \"3\"}}},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with trailing comma\",\n\t\t\tinput:    \"[1, 2, 3,]\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"missing ',' after array value\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"array with missing end bracket\",\n\t\t\tinput:    \"[1, 2, 3\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"missing ']'\"),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tv, _, err := parseArray(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err == nil && tc.err != nil {\n\t\t\t\tt.Errorf(\"expected error: %v\", tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif v.t != tc.expected.t {\n\t\t\t\tt.Errorf(\"unexpected type: got %s, want %s\", v.t.String(), tc.expected.t.String())\n\t\t\t}\n\t\t\tif len(v.a) != len(tc.expected.a) {\n\t\t\t\tt.Errorf(\"unexpected array length: got %d, want %d\", len(v.a), len(tc.expected.a))\n\t\t\t}\n\t\t\tfor i, e := range tc.expected.a {\n\t\t\t\tif v.a[i].t != e.t {\n\t\t\t\t\tt.Errorf(\"unexpected element type at index %d: got %s, want %s\", i, v.a[i].t.String(), e.t.String())\n\t\t\t\t}\n\t\t\t\tif v.a[i].s != e.s {\n\t\t\t\t\tt.Errorf(\"unexpected element value at index %d: got %s, want %s\", i, v.a[i].s, e.s)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}",
    "3aaf7a1aae8189f0ac66ba79a7f3d3ae": "package fastjson_test\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n\n\t\"github.com/valyala/fastjson\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttestCases := []struct {\n\t\tname   string\n\t\tvalue  *fastjson.Value\n\t\texpect []byte\n\t}{\n\t\t{\n\t\t\tname:   \"raw string\",\n\t\t\tvalue:  &fastjson.Value{t: typeRawString, s: \"hello\"},\n\t\t\texpect: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tvalue: &fastjson.Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: fastjson.Object{\n\t\t\t\t\tkvs: []fastjson.kv{\n\t\t\t\t\t\t{k: \"key1\", v: &fastjson.Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &fastjson.Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpect: []byte(`{\"key1\":\"value1\",\"key2\":42}`),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tvalue: &fastjson.Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*fastjson.Value{\n\t\t\t\t\t{t: TypeString, s: \"item1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t\t{t: TypeFalse},\n\t\t\t\t\t{t: TypeNull},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpect: []byte(`[\"item1\",42,true,false,null]`),\n\t\t},\n\t\t{\n\t\t\tname:   \"string\",\n\t\t\tvalue:  &fastjson.Value{t: TypeString, s: \"hello\"},\n\t\t\texpect: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname:   \"number\",\n\t\t\tvalue:  &fastjson.Value{t: TypeNumber, s: \"42\"},\n\t\t\texpect: []byte(\"42\"),\n\t\t},\n\t\t{\n\t\t\tname:   \"true\",\n\t\t\tvalue:  &fastjson.Value{t: TypeTrue},\n\t\t\texpect: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname:   \"false\",\n\t\t\tvalue:  &fastjson.Value{t: TypeFalse},\n\t\t\texpect: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname:   \"null\",\n\t\t\tvalue:  &fastjson.Value{t: TypeNull},\n\t\t\texpect: []byte(\"null\"),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdst := make([]byte, 0, 32)\n\t\t\tresult := tc.value.MarshalTo(dst)\n\t\t\tif !bytes.Equal(result, tc.expect) {\n\t\t\t\tt.Errorf(\"expected %q, got %q\", tc.expect, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "3d6e3f3ce2b90894ed5585626a6d5265": "package fastjson\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n)\n\nfunc TestEscapeString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []byte\n\t}{\n\t\t{\n\t\t\tname:     \"No special characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: []byte(`\"hello, world\"`),\n\t\t},\n\t\t{\n\t\t\tname:     \"Contains special characters\",\n\t\t\tinput:    \"hello, \\\"world\\\"\",\n\t\t\texpected: []byte(`\"hello, \\\"world\\\"\"`),\n\t\t},\n\t\t{\n\t\t\tname:     \"Empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: []byte(`\"\"`),\n\t\t},\n\t\t{\n\t\t\tname:     \"String with backslash\",\n\t\t\tinput:    \"hello\\\\world\",\n\t\t\texpected: []byte(`\"hello\\\\world\"`),\n\t\t},\n\t\t{\n\t\t\tname:     \"String with newline\",\n\t\t\tinput:    \"hello\\nworld\",\n\t\t\texpected: []byte(`\"hello\\nworld\"`),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdst := make([]byte, 0, len(tc.input)+2)\n\t\t\tresult := escapeString(dst, tc.input)\n\t\t\tif !bytes.Equal(result, tc.expected) {\n\t\t\t\tt.Errorf(\"escapeString(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "3c5d58b5438759a28be54d5c21c2f82c": "package fastjson_test\n\nimport (\n    \"testing\"\n\n    \"github.com/valyala/fastjson\"\n)\n\nfunc TestValue_Array(t *testing.T) {\n    tests := []struct {\n        name    string\n        v       *fastjson.Value\n        want    []*fastjson.Value\n        wantErr bool\n    }{\n        {\n            name: \"valid array\",\n            v: func() *fastjson.Value {\n                p := &fastjson.Parser{}\n                v, _ := p.Parse(`[1, 2, 3]`)\n                return v\n            }(),\n            want: []*fastjson.Value{\n                {t: fastjson.TypeNumber, s: \"1\"},\n                {t: fastjson.TypeNumber, s: \"2\"},\n                {t: fastjson.TypeNumber, s: \"3\"},\n            },\n            wantErr: false,\n        },\n        {\n            name: \"non-array value\",\n            v: func() *fastjson.Value {\n                p := &fastjson.Parser{}\n                v, _ := p.Parse(`\"hello\"`)\n                return v\n            }(),\n            want:    nil,\n            wantErr: true,\n        },\n    }\n\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            got, err := tt.v.Array()\n            if (err != nil) != tt.wantErr {\n                t.Errorf(\"Value.Array() error = %v, wantErr %v\", err, tt.wantErr)\n                return\n            }\n            if len(got) != len(tt.want) {\n                t.Errorf(\"Value.Array() = %v, want %v\", got, tt.want)\n                return\n            }\n            for i := range got {\n                if got[i].t != tt.want[i].t || got[i].s != tt.want[i].s {\n                    t.Errorf(\"Value.Array() = %v, want %v\", got, tt.want)\n                    return\n                }\n            }\n        })\n    }\n}",
    "3d1a0785dcf3d2378895c989662c217c": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetInt(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tjson     string\n\t\tkeys     []string\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"Existing integer value\",\n\t\t\tjson:     `{\"key\": 42}`,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: 42,\n\t\t},\n\t\t{\n\t\t\tname:     \"Non-existing key\",\n\t\t\tjson:     `{\"key1\": 42}`,\n\t\t\tkeys:     []string{\"key2\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid value type\",\n\t\t\tjson:     `{\"key\": \"value\"}`,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Nested object with array index\",\n\t\t\tjson:     `{\"key\": {\"subkey\": [1, 2, 3]}}`,\n\t\t\tkeys:     []string{\"key\", \"subkey\", \"1\"},\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"Nested array with array index\",\n\t\t\tjson:     `{\"key\": [{\"subkey\": 1}, {\"subkey\": 2}, {\"subkey\": 3}]}`,\n\t\t\tkeys:     []string{\"key\", \"1\", \"subkey\"},\n\t\t\texpected: 2,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tv, _ := ParseBytes([]byte(tc.json))\n\t\t\tactual := v.GetInt(tc.keys...)\n\t\t\tif actual != tc.expected {\n\t\t\t\tt.Errorf(\"GetInt(%v) = %d, want %d\", tc.keys, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "3f31a54f585efbbec2a16c87a8cbe8e0": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty array\",\n\t\t\tinput:    \"[]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{}},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with values\",\n\t\t\tinput:    \"[1, true, \\\"hello\\\"]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}, &Value{t: TypeTrue}, &Value{t: TypeString, s: \"hello\"}}},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"unterminated array\",\n\t\t\tinput:    \"[1, 2, 3\",\n\t\t\texpected: nil,\n\t\t\terr:      ErrMissingArrayEnd,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing comma\",\n\t\t\tinput:    \"[1 2]\",\n\t\t\texpected: nil,\n\t\t\terr:      ErrMissingComma,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tgot, _, err := parseArray(tc.input, c, 0)\n\t\t\tif !reflect.DeepEqual(got, tc.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", tc.input, got, tc.expected)\n\t\t\t}\n\t\t\tif err != tc.err {\n\t\t\t\tt.Errorf(\"parseArray(%q) error = %v, want %v\", tc.input, err, tc.err)\n\t\t\t}\n\t\t})\n\t}\n}",
    "3f7572e75236edb893fcc23f31599964": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\targs string\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"no escape characters\",\n\t\t\targs: \"hello world\",\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"simple escape characters\",\n\t\t\targs: \"hello\\\\\\\"world\\\\\\\\\",\n\t\t\twant: \"hello\\\"world\\\\\",\n\t\t},\n\t\t{\n\t\t\tname: \"complex escape characters\",\n\t\t\targs: \"hello\\\\n\\\\t\\\\u0001world\",\n\t\t\twant: \"hello\\n\\t\\u0001world\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid unicode escape\",\n\t\t\targs: \"hello\\\\u123world\",\n\t\t\twant: \"hello\\\\u123world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete unicode escape\",\n\t\t\targs: \"hello\\\\u1234world\",\n\t\t\twant: \"hello\\\\u1234world\",\n\t\t},\n\t\t{\n\t\t\tname: \"surrogate pair\",\n\t\t\targs: \"hello\\\\ud83d\\\\ude00world\",\n\t\t\twant: \"helloüòÄworld\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid surrogate pair\",\n\t\t\targs: \"hello\\\\ud83d\\\\world\",\n\t\t\twant: \"hello\\\\ud83d\\\\world\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "3f357661c008ff56cdc0f9cfad225fac": "package fastjson_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/valyala/fastjson\"\n)\n\nfunc TestBool(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    *fastjson.Value\n\t\texpected bool\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"true\",\n\t\t\tinput:    &fastjson.Value{t: fastjson.TypeTrue},\n\t\t\texpected: true,\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"false\",\n\t\t\tinput:    &fastjson.Value{t: fastjson.TypeFalse},\n\t\t\texpected: false,\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid type\",\n\t\t\tinput:    &fastjson.Value{t: fastjson.TypeNumber},\n\t\t\texpected: false,\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot, err := tc.input.Bool()\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"Bool() error = %v, wantErr %v\", err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tc.expected {\n\t\t\t\tt.Errorf(\"Bool() got = %v, want %v\", got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "3c85e974218694a7de9cb13fa4be2f63": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tinput   string\n\t\twantVal *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty string\",\n\t\t\tinput: \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"depth exceeds MaxDepth\",\n\t\t\tinput: \"{\\\"key\\\": {\\\"nested\\\": {}}}\", // depth of 3 exceeds MaxDepth of 2\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"valid object\",\n\t\t\tinput: \"{\\\"key\\\":\\\"value\\\"}\",\n\t\t\twantVal: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{\n\t\t\t\t\t\t\tt: typeRawString,\n\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"valid array\",\n\t\t\tinput: \"[1,2,3]\",\n\t\t\twantVal: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"valid string\",\n\t\t\tinput: `\"hello\"`,\n\t\t\twantVal: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"valid true\",\n\t\t\tinput: \"true\",\n\t\t\twantVal: valueTrue,\n\t\t},\n\t\t{\n\t\t\tname:  \"valid false\",\n\t\t\tinput: \"false\",\n\t\t\twantVal: valueFalse,\n\t\t},\n\t\t{\n\t\t\tname:  \"valid null\",\n\t\t\tinput: \"null\",\n\t\t\twantVal: valueNull,\n\t\t},\n\t\t{\n\t\t\tname:  \"valid number\",\n\t\t\tinput: \"42\",\n\t\t\twantVal: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42\",\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tgot, _, err := parseValue(tt.input, c, 0)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, wantErr %v\", tt.input, err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr && !valuesEqual(got, tt.wantVal) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", tt.input, got, tt.wantVal)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc valuesEqual(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeNull, TypeTrue, TypeFalse:\n\t\treturn true\n\tcase TypeNumber, typeRawString:\n\t\treturn v1.s == v2.s\n\tcase TypeObject:\n\t\treturn objectEqual(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, v := range v1.a {\n\t\t\tif !valuesEqual(v, v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\tpanic(fmt.Sprintf(\"unknown type: %d\", v1.t))\n\t}\n}\n\nfunc objectEqual(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !valuesEqual(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "3d2d4a89f500c5677c5352bea33edf13": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"valid object\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{s: \"value1\", t: TypeString}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{s: \"42\", t: TypeNumber}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42`,\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing key\",\n\t\t\tinput: `{:42}`,\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing value\",\n\t\t\tinput: `{\"key1\":}`,\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: `{}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, _, err := parseObject(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err == nil && !equalValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil || v2 == nil {\n\t\treturn v1 == v2\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn equalObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn equalArrays(v1.a, v2.a)\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber, TypeTrue, TypeFalse:\n\t\treturn v1.s == v2.s\n\tcase TypeNull:\n\t\treturn true\n\tdefault:\n\t\tpanic(\"unknown type\")\n\t}\n}\n\nfunc equalObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !equalValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc equalArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tif !equalValues(v1, a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "3d8f6ad0ab0bfb926e53c4a95ced9ccd": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tinput   string\n\t\twantVal *Value\n\t\twantRem string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty array\",\n\t\t\tinput: \"[]\",\n\t\t\twantVal: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\twantRem: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with single value\",\n\t\t\tinput: \"[123]\",\n\t\t\twantVal: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantRem: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with multiple values\",\n\t\t\tinput: \"[123, true, \\\"hello\\\"]\",\n\t\t\twantVal: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"hello\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantRem: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with trailing comma\",\n\t\t\tinput: \"[123, true,]\",\n\t\t\twantVal: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantRem: \"]\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with missing closing bracket\",\n\t\t\tinput: \"[123, true\",\n\t\t\twantVal: nil,\n\t\t\twantRem: \"[123, true\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotVal, gotRem, gotErr := parseArray(tt.input, c, 0)\n\t\t\tif (gotErr != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", gotErr, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(gotVal, tt.wantVal) {\n\t\t\t\tt.Errorf(\"parseArray() gotVal = %v, want %v\", gotVal, tt.wantVal)\n\t\t\t}\n\t\t\tif gotRem != tt.wantRem {\n\t\t\t\tt.Errorf(\"parseArray() gotRem = %v, want %v\", gotRem, tt.wantRem)\n\t\t\t}\n\t\t})\n\t}\n}",
    "418c69497f59b9f493827f62e95a9c11": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetBool(t *testing.T) {\n\t// Test cases\n\ttestCases := []struct {\n\t\tname     string\n\t\tjson     string\n\t\tkeys     []string\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname:     \"Existing boolean value\",\n\t\t\tjson:     `{\"key\": true}`,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Non-existing key\",\n\t\t\tjson:     `{\"key\": true}`,\n\t\t\tkeys:     []string{\"non-existing\"},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid value type\",\n\t\t\tjson:     `{\"key\": 42}`,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Array index key\",\n\t\t\tjson:     `{\"key\": [true, false]}`,\n\t\t\tkeys:     []string{\"key\", \"1\"},\n\t\t\texpected: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tv, err := Parse(tc.json)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Parse() error: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tresult := v.GetBool(tc.keys...)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"GetBool() = %v, expected %v\", result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "41702ffcac5eb63c344593da8804a2ae": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantKey  string\n\t\twantRest string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"no quotes\",\n\t\t\tinput:    \"foo bar\",\n\t\t\twantKey:  \"foo bar\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"simple quote\",\n\t\t\tinput:    `\"foo\"bar`,\n\t\t\twantKey:  \"foo\",\n\t\t\twantRest: \"bar\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"escaped quote\",\n\t\t\tinput:    `\"foo\\\"bar\"baz`,\n\t\t\twantKey:  `foo\"bar`,\n\t\t\twantRest: \"baz\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing end quote\",\n\t\t\tinput:    `\"foo`,\n\t\t\twantKey:  \"\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tkey, rest, err := parseRawString(tt.input)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif key != tt.wantKey {\n\t\t\t\tt.Errorf(\"parseRawString() key = %v, want %v\", key, tt.wantKey)\n\t\t\t}\n\t\t\tif rest != tt.wantRest {\n\t\t\t\tt.Errorf(\"parseRawString() rest = %v, want %v\", rest, tt.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "40bce8756653a7f7b2a826f9d1e70a02": "package fastjson\n\nimport (\n    \"reflect\"\n    \"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n    testCases := []struct {\n        name     string\n        input    string\n        expected *Value\n        err      bool\n    }{\n        {\n            name:     \"valid object\",\n            input:    `{\"key1\":\"value1\",\"key2\":42}`,\n            expected: &Value{t: TypeObject, o: Object{kvs: []kv{{\"key1\", &Value{t: TypeString, s: \"value1\"}}, {\"key2\", &Value{t: TypeNumber, s: \"42\"}}}}},\n            err:      false,\n        },\n        {\n            name:     \"missing closing brace\",\n            input:    `{\"key1\":\"value1\",\"key2\":42`,\n            expected: nil,\n            err:      true,\n        },\n        {\n            name:     \"missing key\",\n            input:    `{:\"value1\",\"key2\":42}`,\n            expected: nil,\n            err:      true,\n        },\n        {\n            name:     \"missing colon\",\n            input:    `{\"key1\"\"value1\",\"key2\":42}`,\n            expected: nil,\n            err:      true,\n        },\n        {\n            name:     \"missing comma\",\n            input:    `{\"key1\":\"value1\" \"key2\":42}`,\n            expected: nil,\n            err:      true,\n        },\n    }\n\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            c := &cache{}\n            got, _, err := parseObject(tc.input, c, 0)\n            if (err != nil) != tc.err {\n                t.Errorf(\"parseObject(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n                return\n            }\n\n            if !reflect.DeepEqual(got, tc.expected) {\n                t.Errorf(\"parseObject(%q) = %v, want %v\", tc.input, got, tc.expected)\n            }\n        })\n    }\n}",
    "40a195db240c45247c569f188288dc15": "package fastjson_test\n\nimport (\n    \"fmt\"\n    \"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n    testCases := []struct {\n        name     string\n        input    string\n        wantKey  string\n        wantVal  string\n        wantErr  bool\n        errMsg   string\n    }{\n        {\n            name:     \"basic\",\n            input:    `\"key\":\"value\"`,\n            wantKey:  \"key\",\n            wantVal:  \"value\",\n            wantErr:  false,\n            errMsg:   \"\",\n        },\n        {\n            name:     \"escaped quotes\",\n            input:    `\"key\\\":value\"`,\n            wantKey:  `key\"`,\n            wantVal:  \"value\",\n            wantErr:  false,\n            errMsg:   \"\",\n        },\n        {\n            name:     \"missing closing quotes\",\n            input:    `\"key:\"value\"`,\n            wantKey:  \"\",\n            wantVal:  \"\",\n            wantErr:  true,\n            errMsg:   \"missing closing '\\\"'\",\n        },\n        {\n            name:     \"empty string\",\n            input:    `\"\"`,\n            wantKey:  \"\",\n            wantVal:  \"\",\n            wantErr:  false,\n            errMsg:   \"\",\n        },\n    }\n\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            key, val, err := parseRawString(tc.input)\n            if tc.wantErr {\n                if err == nil {\n                    t.Errorf(\"expected error: %s\", tc.errMsg)\n                } else if err.Error() != tc.errMsg {\n                    t.Errorf(\"unexpected error: got %v, want %s\", err, tc.errMsg)\n                }\n            } else {\n                if err != nil {\n                    t.Errorf(\"unexpected error: %v\", err)\n                }\n                if key != tc.wantKey {\n                    t.Errorf(\"unexpected key: got %q, want %q\", key, tc.wantKey)\n                }\n                if val != tc.wantVal {\n                    t.Errorf(\"unexpected value: got %q, want %q\", val, tc.wantVal)\n                }\n            }\n        })\n    }\n}",
    "41eed9330e6f62c05d39e701011084a6": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantNum  string\n\t\twantRest string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.456e+78\",\n\t\t\twantNum:  \"123.456e+78\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with sign\",\n\t\t\tinput:    \"-0.1\",\n\t\t\twantNum:  \"-0.1\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with exponent\",\n\t\t\tinput:    \"1e-10\",\n\t\t\twantNum:  \"1e-10\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid character\",\n\t\t\tinput:    \"123.4$56\",\n\t\t\twantNum:  \"123.4\",\n\t\t\twantRest: \"$56\",\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty input\",\n\t\t\tinput:    \"\",\n\t\t\twantNum:  \"\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"inf\",\n\t\t\tinput:    \"inf\",\n\t\t\twantNum:  \"inf\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"nan\",\n\t\t\tinput:    \"nan\",\n\t\t\twantNum:  \"nan\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.wantNum {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) num = %q, want %q\", tc.input, num, tc.wantNum)\n\t\t\t}\n\t\t\tif rest != tc.wantRest {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) rest = %q, want %q\", tc.input, rest, tc.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "42a4581e9bcb47c9cae323e224321838": "package fastjson\n\nimport (\n\t\"bytes\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttestCases := []struct {\n\t\tname   string\n\t\tvalue  *Value\n\t\texpect []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello, world\",\n\t\t\t},\n\t\t\texpect: []byte(`\"hello, world\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpect: []byte(`{\"key1\":\"value1\",\"key2\":42}`),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"hello\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t\t{t: TypeTrue, s: \"\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpect: []byte(`[\"hello\",42,true]`),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello, world\",\n\t\t\t},\n\t\t\texpect: []byte(`\"hello, world\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42\",\n\t\t\t},\n\t\t\texpect: []byte(\"42\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\texpect: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\texpect: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: TypeNull,\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\texpect: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"unknown type\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: 999,\n\t\t\t},\n\t\t\texpect: nil,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdst := make([]byte, 0, 64)\n\t\t\tresult := tc.value.MarshalTo(dst)\n\t\t\tif !bytes.Equal(result, tc.expect) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %q, want %q\", result, tc.expect)\n\t\t\t}\n\t\t})\n\t}\n}",
    "45e9f90038c7ac1a7282335fc1180fe8": "// fastjson_test.go\n\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_getKV(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\to    *Object\n\t\twant *kv\n\t}{\n\t\t{\n\t\t\tname: \"with available capacity\",\n\t\t\to: &Object{\n\t\t\t\tkvs: make([]kv, 4, 5),\n\t\t\t},\n\t\t\twant: &kv{},\n\t\t},\n\t\t{\n\t\t\tname: \"without available capacity\",\n\t\t\to: &Object{\n\t\t\t\tkvs: make([]kv, 5, 5),\n\t\t\t},\n\t\t\twant: &kv{},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.o.getKV(); got != tt.want {\n\t\t\t\tt.Errorf(\"Object.getKV() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "438cdd38c430e24205d861b12ce862a1": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected1, expected2 string\n\t\texpectedErr bool\n\t}{\n\t\t{\n\t\t\tname:  \"basic\",\n\t\t\tinput: `\"hello, world\"`,\n\t\t\texpected1: \"hello, world\",\n\t\t\texpected2: \"\",\n\t\t\texpectedErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"empty string\",\n\t\t\tinput: `\"\"`,\n\t\t\texpected1: \"\",\n\t\t\texpected2: \"\",\n\t\t\texpectedErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"missing closing quote\",\n\t\t\tinput: `\"hello, world`,\n\t\t\texpected1: \"\",\n\t\t\texpected2: \"\",\n\t\t\texpectedErr: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"escaped quote\",\n\t\t\tinput: `\"hello, \\\"world\\\"\"`,\n\t\t\texpected1: \"hello, \\\"world\\\"\",\n\t\t\texpected2: \"\",\n\t\t\texpectedErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"multiple escaped quotes\",\n\t\t\tinput: `\"hello, \\\\\\\"world\\\\\\\"\"`,\n\t\t\texpected1: \"hello, \\\\\\\"world\\\\\\\"\",\n\t\t\texpected2: \"\",\n\t\t\texpectedErr: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual1, actual2, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.expectedErr {\n\t\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expectedErr %v\", tc.input, err, tc.expectedErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif actual1 != tc.expected1 {\n\t\t\t\tt.Errorf(\"parseRawString(%q) first return value = %q, expected %q\", tc.input, actual1, tc.expected1)\n\t\t\t}\n\t\t\tif actual2 != tc.expected2 {\n\t\t\t\tt.Errorf(\"parseRawString(%q) second return value = %q, expected %q\", tc.input, actual2, tc.expected2)\n\t\t\t}\n\t\t})\n\t}\n}",
    "43f05169bea4b18464c3beff0572b019": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantStr  string\n\t\twantRest string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\twantStr:  \"hello\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello\\\"world\"`,\n\t\t\twantStr:  `hello\"world`,\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello\\\"world\\\"foo\"`,\n\t\t\twantStr:  `hello\"world\"foo`,\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with unmatched quote\",\n\t\t\tinput:    `\"hello`,\n\t\t\twantStr:  \"\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tstr, rest, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif str != tc.wantStr {\n\t\t\t\tt.Errorf(\"parseRawString(%q) str = %q, want %q\", tc.input, str, tc.wantStr)\n\t\t\t}\n\t\t\tif rest != tc.wantRest {\n\t\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, want %q\", tc.input, rest, tc.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "4317dd94c9c81cdfc7394fab018fe2c2": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantNum  string\n\t\twantRest string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid positive integer\",\n\t\t\tinput:    \"123abc\",\n\t\t\twantNum:  \"123\",\n\t\t\twantRest: \"abc\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid negative integer\",\n\t\t\tinput:    \"-456def\",\n\t\t\twantNum:  \"-456\",\n\t\t\twantRest: \"def\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid positive float\",\n\t\t\tinput:    \"3.14ghij\",\n\t\t\twantNum:  \"3.14\",\n\t\t\twantRest: \"ghij\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid negative float\",\n\t\t\tinput:    \"-2.71828klm\",\n\t\t\twantNum:  \"-2.71828\",\n\t\t\twantRest: \"klm\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid input\",\n\t\t\tinput:    \"abc\",\n\t\t\twantNum:  \"\",\n\t\t\twantRest: \"abc\",\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"input starts with special characters\",\n\t\t\tinput:    \"+3.14nop\",\n\t\t\twantNum:  \"+3.14\",\n\t\t\twantRest: \"nop\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"input starts with 'inf'\",\n\t\t\tinput:    \"infqrs\",\n\t\t\twantNum:  \"inf\",\n\t\t\twantRest: \"qrs\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"input starts with 'nan'\",\n\t\t\tinput:    \"nantuv\",\n\t\t\twantNum:  \"nan\",\n\t\t\twantRest: \"tuv\",\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.wantNum {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) num = %q, want %q\", tc.input, num, tc.wantNum)\n\t\t\t}\n\t\t\tif rest != tc.wantRest {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) rest = %q, want %q\", tc.input, rest, tc.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "46016ef0a20258ffb65f7446c875b298": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid JSON\",\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\texpected: &Value{o: Object{kvs: []kv{{\"key\", &Value{s: \"value\", t: TypeString}}}}, t: TypeObject},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid JSON\",\n\t\t\tinput:    `{\"key\": \"value`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty input\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"whitespace only\",\n\t\t\tinput:    \"   \",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tp := &Parser{}\n\t\t\tactual, err := p.Parse(tc.input)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tc.expected, actual)\n\t\t\t}\n\t\t})\n\t}\n}",
    "474587a46759d9c9af305ffe6abc10cf": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestObject_unescapeKeys(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\to    *Object\n\t\twant *Object\n\t}{\n\t\t{\n\t\t\tname: \"keys are already unescaped\",\n\t\t\to: &Object{\n\t\t\t\tkvs:           []kv{{k: \"key1\", v: &Value{}}, {k: \"key2\", v: &Value{}}},\n\t\t\t\tkeysUnescaped: true,\n\t\t\t},\n\t\t\twant: &Object{\n\t\t\t\tkvs:           []kv{{k: \"key1\", v: &Value{}}, {k: \"key2\", v: &Value{}}},\n\t\t\t\tkeysUnescaped: true,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"keys need to be unescaped\",\n\t\t\to: &Object{\n\t\t\t\tkvs:           []kv{{k: `\"key1\"`, v: &Value{}}, {k: `\"key2\"`, v: &Value{}}},\n\t\t\t\tkeysUnescaped: false,\n\t\t\t},\n\t\t\twant: &Object{\n\t\t\t\tkvs:           []kv{{k: \"key1\", v: &Value{}}, {k: \"key2\", v: &Value{}}},\n\t\t\t\tkeysUnescaped: true,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\ttt.o.unescapeKeys()\n\t\t\tif !reflect.DeepEqual(tt.o, tt.want) {\n\t\t\t\tt.Errorf(\"Object.unescapeKeys() = %v, want %v\", tt.o, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "47b28de27696c7d835e66559172d7cdc": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttestCases := []struct {\n\t\tname   string\n\t\tvalue  *Value\n\t\texpect []byte\n\t}{\n\t\t{\n\t\t\tname:   \"raw string\",\n\t\t\tvalue:  &Value{t: typeRawString, s: \"hello\"},\n\t\t\texpect: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname:   \"object\",\n\t\t\tvalue:  &Value{t: TypeObject, o: &Object{kvs: []kv{{k: \"key\", v: &Value{t: TypeString, s: \"value\"}}}}},\n\t\t\texpect: []byte(`{\"key\":\"value\"}`),\n\t\t},\n\t\t{\n\t\t\tname:   \"array\",\n\t\t\tvalue:  &Value{t: TypeArray, a: []*Value{&Value{t: TypeString, s: \"one\"}, &Value{t: TypeString, s: \"two\"}}},\n\t\t\texpect: []byte(`[\"one\",\"two\"]`),\n\t\t},\n\t\t{\n\t\t\tname:   \"string\",\n\t\t\tvalue:  &Value{t: TypeString, s: \"hello\"},\n\t\t\texpect: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname:   \"number\",\n\t\t\tvalue:  &Value{t: TypeNumber, s: \"42\"},\n\t\t\texpect: []byte(\"42\"),\n\t\t},\n\t\t{\n\t\t\tname:   \"true\",\n\t\t\tvalue:  &Value{t: TypeTrue},\n\t\t\texpect: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname:   \"false\",\n\t\t\tvalue:  &Value{t: TypeFalse},\n\t\t\texpect: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname:   \"null\",\n\t\t\tvalue:  &Value{t: TypeNull},\n\t\t\texpect: []byte(\"null\"),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdst := make([]byte, 0, 64)\n\t\t\tgot := tc.value.MarshalTo(dst)\n\t\t\tif !reflect.DeepEqual(got, tc.expect) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %s, expect %s\", got, tc.expect)\n\t\t\t}\n\t\t})\n\t}\n}",
    "48320e961bd2d8c9a3735fa076ff65ef": "package fastjson\n\nimport (\n    \"testing\"\n)\n\nfunc TestTypeString(t *testing.T) {\n    tests := []struct {\n        name string\n        t    Type\n        want string\n    }{\n        {\"TypeObject\", TypeObject, \"object\"},\n        {\"TypeArray\", TypeArray, \"array\"},\n        {\"TypeString\", TypeString, \"string\"},\n        {\"TypeNumber\", TypeNumber, \"number\"},\n        {\"TypeTrue\", TypeTrue, \"true\"},\n        {\"TypeFalse\", TypeFalse, \"false\"},\n        {\"TypeNull\", TypeNull, \"null\"},\n    }\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            if got := tt.t.String(); got != tt.want {\n                t.Errorf(\"Type.String() = %v, want %v\", got, tt.want)\n            }\n        })\n    }\n}",
    "4778417afe75368a35b2b6f4f35fc985": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty array\",\n\t\t\tinput: \"[]\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with one value\",\n\t\t\tinput: \"[1]\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with multiple values\",\n\t\t\tinput: \"[1,2,3]\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with trailing comma\",\n\t\t\tinput: \"[1,2,3,]\",\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with missing ending bracket\",\n\t\t\tinput: \"[1,2,3\",\n\t\t\terr:   true,\n\t\t},\n\t}\n\n\tc := &cache{\n\t\tvs: make([]Value, 0, 16),\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult, _, err := parseArray(tc.input, c, 0)\n\t\t\tif tc.err && err == nil {\n\t\t\t\tt.Errorf(\"expected error, but got none\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tc.err && err != nil {\n\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tc.err {\n\t\t\t\tif result.t != tc.expected.t {\n\t\t\t\t\tt.Errorf(\"unexpected type, got %v, want %v\", result.t, tc.expected.t)\n\t\t\t\t}\n\t\t\t\tif len(result.a) != len(tc.expected.a) {\n\t\t\t\t\tt.Errorf(\"unexpected array length, got %d, want %d\", len(result.a), len(tc.expected.a))\n\t\t\t\t}\n\t\t\t\tfor i := range result.a {\n\t\t\t\t\tif result.a[i].s != tc.expected.a[i].s {\n\t\t\t\t\t\tt.Errorf(\"unexpected array element at index %d, got %v, want %v\", i, result.a[i].s, tc.expected.a[i].s)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}",
    "482458ac461af40cdb53b92e922369b7": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t\trest     string\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"basic string\",\n\t\t\tinput:    `\"hello world\"`,\n\t\t\texpected: \"hello world\",\n\t\t\trest:     \"\",\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello \\\"world\\\"\"`,\n\t\t\texpected: `hello \"world\"`,\n\t\t\trest:     \"\",\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello \\\"world\\\" \\\"foo\\\"\"`,\n\t\t\texpected: `hello \"world\" \"foo\"`,\n\t\t\trest:     \"\",\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing closing quote\",\n\t\t\tinput:    `\"hello world`,\n\t\t\texpected: \"\",\n\t\t\trest:     \"\",\n\t\t\terr:      fmt.Errorf(`missing closing '\"'`),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult, rest, err := parseRawString(tc.input)\n\t\t\tif err != tc.err {\n\t\t\t\tt.Errorf(\"expected error %v, got %v\", tc.err, err)\n\t\t\t}\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"expected result %s, got %s\", tc.expected, result)\n\t\t\t}\n\t\t\tif rest != tc.rest {\n\t\t\t\tt.Errorf(\"expected rest %s, got %s\", tc.rest, rest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "446abaebeeef376ebc93226303f531ed": "package fastjson\n\nimport (\n    \"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n    testCases := []struct {\n        name     string\n        input    string\n        expected *Value\n        err      error\n    }{\n        {\n            name:  \"Valid JSON object\",\n            input: `{\"key1\":\"value1\",\"key2\":42}`,\n            expected: func() *Value {\n                v := &Value{\n                    t: TypeObject,\n                    o: Object{\n                        kvs: []kv{\n                            {k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n                            {k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n                        },\n                    },\n                }\n                return v\n            }(),\n            err: nil,\n        },\n        {\n            name:  \"Missing closing brace\",\n            input: `{\"key1\":\"value1\",\"key2\":42`,\n            expected: nil,\n            err:      fmt.Errorf(\"missing '}'\"),\n        },\n        {\n            name:  \"Missing object key\",\n            input: `{:42}`,\n            expected: nil,\n            err:      fmt.Errorf(`cannot find opening '\"\" for object key`),\n        },\n    }\n\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            c := &cache{}\n            actual, _, err := parseObject(tc.input, c, 0)\n            if err != nil {\n                if tc.err == nil || err.Error() != tc.err.Error() {\n                    t.Errorf(\"parseObject(%q) error = %v, expected %v\", tc.input, err, tc.err)\n                }\n            } else {\n                if !objectsEqual(actual, tc.expected) {\n                    t.Errorf(\"parseObject(%q) = %+v, expected %+v\", tc.input, actual, tc.expected)\n                }\n            }\n        })\n    }\n}\n\nfunc objectsEqual(a, b *Value) bool {\n    if a == nil && b == nil {\n        return true\n    }\n    if a == nil || b == nil {\n        return false\n    }\n    if a.t != b.t {\n        return false\n    }\n    switch a.t {\n    case TypeObject:\n        if len(a.o.kvs) != len(b.o.kvs) {\n            return false\n        }\n        for i, kv := range a.o.kvs {\n            if kv.k != b.o.kvs[i].k || !objectsEqual(kv.v, b.o.kvs[i].v) {\n                return false\n            }\n        }\n    case TypeArray:\n        if len(a.a) != len(b.a) {\n            return false\n        }\n        for i, v := range a.a {\n            if !objectsEqual(v, b.a[i]) {\n                return false\n            }\n        }\n    case TypeString:\n        return a.s == b.s\n    case TypeNumber:\n        return a.s == b.s\n    case TypeTrue, TypeFalse, TypeNull:\n        return true\n    default:\n        panic(\"unknown type\")\n    }\n    return true\n}",
    "48d318ea87ed8fe26689b887bc8fd3c8": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\targs string\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: \"\",\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"string without leading whitespace\",\n\t\t\targs: \"hello\",\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with leading whitespace\",\n\t\t\targs: \"  hello world\",\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with leading and trailing whitespace\",\n\t\t\targs: \"    hello world    \",\n\t\t\twant: \"hello world    \",\n\t\t},\n\t\t{\n\t\t\tname: \"string with all whitespace characters\",\n\t\t\targs: \"\\t\\n \\r\",\n\t\t\twant: \"\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.args); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow(%q) = %q, want %q\", tt.args, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "4b129ab98d5c4c731411a79d4a5f508e": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"Empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"String without leading whitespace\",\n\t\t\tinput:    \"hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"String with leading whitespace\",\n\t\t\tinput:    \"   hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"String with mixed whitespace\",\n\t\t\tinput:    \"   \\t\\n\\rhello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"String with only whitespace\",\n\t\t\tinput:    \"   \\t\\n\\r\",\n\t\t\texpected: \"\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := skipWSSlow(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"skipWSSlow(%q) = %q, want %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "47a7a73c5d932bf8413c1aa7692b5419": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname    string\n\t\tinput   string\n\t\twantVal *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty string\",\n\t\t\tinput: \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"depth exceeded\",\n\t\t\tinput: \"{}\", // Assuming MaxDepth is 1\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"parse object\",\n\t\t\tinput: `{\"key\":\"value\"}`,\n\t\t\twantVal: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{s: \"value\", t: typeRawString}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"parse array\",\n\t\t\tinput: `[1,true,null]`,\n\t\t\twantVal: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"1\", t: TypeNumber},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t\t{t: TypeNull},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"parse string\",\n\t\t\tinput: `\"hello\"`,\n\t\t\twantVal: &Value{\n\t\t\t\ts: \"hello\",\n\t\t\t\tt: typeRawString,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"parse true\",\n\t\t\tinput: \"true\",\n\t\t\twantVal: valueTrue,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"parse false\",\n\t\t\tinput: \"false\",\n\t\t\twantVal: valueFalse,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"parse null\",\n\t\t\tinput: \"null\",\n\t\t\twantVal: valueNull,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"parse number\",\n\t\t\tinput: \"42\",\n\t\t\twantVal: &Value{\n\t\t\t\ts: \"42\",\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"parse NaN\",\n\t\t\tinput: \"NaN\",\n\t\t\twantVal: &Value{\n\t\t\t\ts: \"NaN\",\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tval, _, err := parseValue(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !valuesEqual(val, tc.wantVal) {\n\t\t\t\tt.Errorf(\"parseValue() = %v, want %v\", val, tc.wantVal)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc valuesEqual(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\n\tswitch v1.t {\n\tcase TypeObject:\n\t\to1, _ := v1.Object()\n\t\to2, _ := v2.Object()\n\t\tif len(o1.kvs) != len(o2.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, kv1 := range o1.kvs {\n\t\t\tkv2 := o2.kvs[i]\n\t\t\tif kv1.k != kv2.k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !valuesEqual(kv1.v, kv2.v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\tcase TypeArray:\n\t\ta1, _ := v1.Array()\n\t\ta2, _ := v2.Array()\n\t\tif len(a1) != len(a2) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, v1 := range a1 {\n\t\t\tif !valuesEqual(v1, a2[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\tcase typeRawString, TypeNumber, TypeTrue, TypeFalse, TypeNull:\n\t\treturn v1.s == v2.s\n\t}\n\n\treturn true\n}",
    "4b87cd4d52570dab9666b264f36b07db": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestTypeString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\ttyp      Type\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"TypeObject\",\n\t\t\ttyp:      TypeObject,\n\t\t\texpected: \"object\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeArray\",\n\t\t\ttyp:      TypeArray,\n\t\t\texpected: \"array\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeString\",\n\t\t\ttyp:      TypeString,\n\t\t\texpected: \"string\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeNumber\",\n\t\t\ttyp:      TypeNumber,\n\t\t\texpected: \"number\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeTrue\",\n\t\t\ttyp:      TypeTrue,\n\t\t\texpected: \"true\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeFalse\",\n\t\t\ttyp:      TypeFalse,\n\t\t\texpected: \"false\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeNull\",\n\t\t\ttyp:      TypeNull,\n\t\t\texpected: \"null\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Unknown Type\",\n\t\t\ttyp:      Type(100),\n\t\t\texpected: \"BUG: unknown Value type: 100\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := tc.typ.String()\n\t\t\tif got != tc.expected {\n\t\t\t\tt.Errorf(\"Type.String() = %q, want %q\", got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "4bfd353ce394104c3e5e7330f2d8c37e": "package fastjson\n\nimport (\n    \"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n    testCases := []struct {\n        name     string\n        input    string\n        expected string\n        err      bool\n    }{\n        {\n            name:     \"simple string\",\n            input:    `\"hello\"`,\n            expected: \"hello\",\n            err:      false,\n        },\n        {\n            name:     \"string with escaped quotes\",\n            input:    `\"hello \\\"world\\\"\"`,\n            expected: `hello \"world\"`,\n            err:      false,\n        },\n        {\n            name:     \"string with multiple escaped quotes\",\n            input:    `\"hello \\\"world\\\" \\\"foo\\\"\"`,\n            expected: `hello \"world\" \"foo\"`,\n            err:      false,\n        },\n        {\n            name:     \"string without closing quote\",\n            input:    `\"hello`,\n            expected: \"\",\n            err:      true,\n        },\n    }\n\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            s, rest, err := parseRawString(tc.input)\n            if (err != nil) != tc.err {\n                t.Errorf(\"expected error %t, got %v\", tc.err, err)\n                return\n            }\n            if s != tc.expected {\n                t.Errorf(\"expected %q, got %q\", tc.expected, s)\n            }\n            if rest != \"\" {\n                t.Errorf(\"expected empty rest, got %q\", rest)\n            }\n        })\n    }\n}",
    "4cdd623a302712e4419ad2c3a2c97876": "package fastjson\n\nimport (\n    \"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n    testCases := []struct {\n        name     string\n        input    string\n        expected []string\n        err      bool\n    }{\n        {\n            name:     \"simple string\",\n            input:    `\"hello world\"`,\n            expected: []string{\"hello world\", \"\"},\n            err:      false,\n        },\n        {\n            name:     \"string with escaped quotes\",\n            input:    `\"hello \\\"world\\\"\"`,\n            expected: []string{\"hello \\\"world\\\"\", \"\"},\n            err:      false,\n        },\n        {\n            name:     \"string with multiple escaped quotes\",\n            input:    `\"hello \\\"world\\\" \\\"test\\\"\"`,\n            expected: []string{\"hello \\\"world\\\" \\\"test\\\"\", \"\"},\n            err:      false,\n        },\n        {\n            name:     \"string with no closing quote\",\n            input:    `\"hello world`,\n            expected: []string{\"\", \"\"},\n            err:      true,\n        },\n    }\n\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            result, _, err := parseRawString(tc.input)\n            if (err != nil) != tc.err {\n                t.Errorf(\"expected error: %v, got: %v\", tc.err, err)\n            }\n\n            if result != tc.expected[0] {\n                t.Errorf(\"expected result: %s, got: %s\", tc.expected[0], result)\n            }\n        })\n    }\n}",
    "48615e4e0f80b59be18ffb71c44492a6": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"max depth exceeded\",\n\t\t\tinput:    \"{}\", // Assuming MaxDepth is set to 1\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t},\n\t\t{\n\t\t\tname:     \"valid object\",\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t\tt: typeRawString,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{\n\t\t\t\ts: \"hello\",\n\t\t\t\tt: typeRawString,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid true\",\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid false\",\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid null\",\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"42\",\n\t\t\texpected: &Value{\n\t\t\t\ts: \"42\",\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tv, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) returned error %v, expected %v\", tc.input, err, tc.err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif tc.err != nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) did not return expected error %v\", tc.input, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !reflect.DeepEqual(v, tc.expected) {\n\t\t\t\tt.Errorf(\"parseValue(%q) returned %v, expected %v\", tc.input, v, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "487b4d87b952e68219b21d44a1371cea": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty array\",\n\t\t\tinput:    \"[]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{}},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with values\",\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}, &Value{t: TypeNumber, s: \"2\"}, &Value{t: TypeNumber, s: \"3\"}}},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with whitespace\",\n\t\t\tinput:    \"[ 1, 2, 3 ]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}, &Value{t: TypeNumber, s: \"2\"}, &Value{t: TypeNumber, s: \"3\"}}},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing closing bracket\",\n\t\t\tinput:    \"[1, 2, 3\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"missing ']'\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"missing comma\",\n\t\t\tinput:    \"[1 2, 3]\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"missing ',' after array value\"),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tactual, _, err := parseArray(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil {\n\t\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t\t} else if err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"error mismatch: expected %v, got %v\", tc.err, err)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif tc.err != nil {\n\t\t\t\t\tt.Errorf(\"expected error %v, but got none\", tc.err)\n\t\t\t\t} else if !valuesEqual(actual, tc.expected) {\n\t\t\t\t\tt.Errorf(\"result mismatch: expected %v, got %v\", tc.expected, actual)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc valuesEqual(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, v := range v1.a {\n\t\t\tif !valuesEqual(v, v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\treturn true\n\t}\n}",
    "4fc89e3a630b8e550765596372d584cd": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"hello world\",\n\t\t\texpected: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Simple escape characters\",\n\t\t\tinput:    \"hello\\\\\\\"world\\\\\\\\\",\n\t\t\texpected: \"hello\\\"world\\\\\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Unicode escape characters\",\n\t\t\tinput:    \"hello\\\\u0061world\",\n\t\t\texpected: \"helloaworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Surrogate pair escape characters\",\n\t\t\tinput:    \"hello\\\\ud83d\\\\ude00world\",\n\t\t\texpected: \"helloüòÄworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid escape characters\",\n\t\t\tinput:    \"hello\\\\xworld\",\n\t\t\texpected: \"hello\\\\xworld\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "48c9e62e37da97e070e59a6c5e30e526": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: \"{}\",\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with one key-value pair\",\n\t\t\tinput: `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with multiple key-value pairs\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":true,\"key3\":42}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"42\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\tinput: `{\"key1\":\"value1\",`,\n\t\t\texpected: nil,\n\t\t\terr:      ErrMissingClosingBrace,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing colon\",\n\t\t\tinput: `{\"key1\" \"value1\"}`,\n\t\t\texpected: nil,\n\t\t\terr:      ErrMissingColon,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with invalid key\",\n\t\t\tinput: `{123:\"value1\"}`,\n\t\t\texpected: nil,\n\t\t\terr:      ErrInvalidKey,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{\n\t\t\t\tvs: make([]Value, 0, 10),\n\t\t\t}\n\t\t\tvalue, _, err := parseObject(tc.input, c, 0)\n\t\t\tif err != nil && tc.err == nil {\n\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err == nil && tc.err != nil {\n\t\t\t\tt.Errorf(\"expected error: %v, got nil\", tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err != nil && tc.err != nil && err.Error() != tc.err.Error() {\n\t\t\t\tt.Errorf(\"expected error: %v, got: %v\", tc.err, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !equalValues(value, tc.expected) {\n\t\t\t\tt.Errorf(\"expected: %v, got: %v\", tc.expected, value)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn equalObjects(v1.o, v2.o)\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeTrue, TypeFalse, TypeNull:\n\t\treturn true\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, v := range v1.a {\n\t\t\tif !equalValues(v, v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc equalObjects(o1, o2 Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv := range o1.kvs {\n\t\tif kv.k != o2.kvs[i].k {\n\t\t\treturn false\n\t\t}\n\t\tif !equalValues(kv.v, o2.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "507ed88071a072bb161e39e02811a740": "package fastjson\n\nimport \"testing\"\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"no leading whitespace\",\n\t\t\tinput:    \"hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading space\",\n\t\t\tinput:    \" hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading newline\",\n\t\t\tinput:    \"\\nhello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading tab\",\n\t\t\tinput:    \"\\thello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading carriage return\",\n\t\t\tinput:    \"\\rhello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple leading whitespaces\",\n\t\t\tinput:    \"   \\t\\r\\nhello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"whitespace only\",\n\t\t\tinput:    \"   \\t\\r\\n\",\n\t\t\texpected: \"\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := skipWSSlow(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"skipWSSlow(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "4d0122a553f10d32bc49513bf0d9a989": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape sequences\",\n\t\t\tinput:    \"This is a simple string.\",\n\t\t\texpected: \"This is a simple string.\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape double quote\",\n\t\t\tinput:    \"This has a \\\"quoted\\\" word.\",\n\t\t\texpected: \"This has a \\\"quoted\\\" word.\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backslash\",\n\t\t\tinput:    \"This has a \\\\ backslash.\",\n\t\t\texpected: \"This has a \\\\ backslash.\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape forward slash\",\n\t\t\tinput:    \"This has a / forward slash.\",\n\t\t\texpected: \"This has a / forward slash.\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backspace\",\n\t\t\tinput:    \"This has a \\b backspace.\",\n\t\t\texpected: \"This has a \\b backspace.\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape form feed\",\n\t\t\tinput:    \"This has a \\f form feed.\",\n\t\t\texpected: \"This has a \\f form feed.\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape newline\",\n\t\t\tinput:    \"This has a \\n newline.\",\n\t\t\texpected: \"This has a \\n newline.\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape carriage return\",\n\t\t\tinput:    \"This has a \\r carriage return.\",\n\t\t\texpected: \"This has a \\r carriage return.\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape tab\",\n\t\t\tinput:    \"This has a \\t tab.\",\n\t\t\texpected: \"This has a \\t tab.\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Unicode\",\n\t\t\tinput:    \"This has a \\\\u0041 Unicode character.\",\n\t\t\texpected: \"This has a A Unicode character.\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Surrogate Pair\",\n\t\t\tinput:    \"This has a \\\\ud83d\\\\ude00 emoji.\",\n\t\t\texpected: \"This has a üòÄ emoji.\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid Escape Sequence\",\n\t\t\tinput:    \"This has a \\\\x invalid escape sequence.\",\n\t\t\texpected: \"This has a \\\\x invalid escape sequence.\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "49c1fd950447c90d34f273d87ba7c002": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\tvalid    bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: \"{}\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs:           []kv{},\n\t\t\t\t\t\tkeysUnescaped: true,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\tvalid: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with one key-value pair\",\n\t\t\tinput: `{\"key\":\"value\"}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{k: \"key\", v: &Value{t: TypeString, s: \"value\"}},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tkeysUnescaped: true,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\tvalid: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with multiple key-value pairs\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42,\"key3\":true}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t\t\t{k: \"key3\", v: &Value{t: TypeTrue}},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tkeysUnescaped: true,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\tvalid: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\tinput: `{\"key\":\"value\"`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{k: \"key\", v: &Value{t: TypeString, s: \"value\"}},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tkeysUnescaped: true,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\tvalid: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tv, _, err := parseObject(tc.input, c, 0)\n\t\t\tif tc.valid && err != nil {\n\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tc.valid && err == nil {\n\t\t\t\tt.Errorf(\"expected error, got nil\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tc.valid {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !compareValues(t, tc.expected, v) {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tc.expected, v)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(t *testing.T, expected, actual *Value) bool {\n\tif expected.t != actual.t {\n\t\tt.Errorf(\"expected type %v, got %v\", expected.t, actual.t)\n\t\treturn false\n\t}\n\tswitch expected.t {\n\tcase TypeObject:\n\t\tif len(expected.o.kvs) != len(actual.o.kvs) {\n\t\t\tt.Errorf(\"expected %d keys, got %d\", len(expected.o.kvs), len(actual.o.kvs))\n\t\t\treturn false\n\t\t}\n\t\tfor i, kv := range expected.o.kvs {\n\t\t\tif kv.k != actual.o.kvs[i].k {\n\t\t\t\tt.Errorf(\"expected key %q, got %q\", kv.k, actual.o.kvs[i].k)\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !compareValues(t, kv.v, actual.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\tcase TypeString:\n\t\tif expected.s != actual.s {\n\t\t\tt.Errorf(\"expected string %q, got %q\", expected.s, actual.s)\n\t\t\treturn false\n\t\t}\n\tcase TypeNumber:\n\t\tif expected.s != actual.s {\n\t\t\tt.Errorf(\"expected number %q, got %q\", expected.s, actual.s)\n\t\t\treturn false\n\t\t}\n\tcase TypeTrue:\n\t\t// Nothing to compare\n\tcase TypeFalse:\n\t\t// Nothing to compare\n\tdefault:\n\t\tt.Errorf(\"unexpected type %v\", expected.t)\n\t\treturn false\n\t}\n\treturn true\n}",
    "4f4491cb7c5cc7f58615a05c592dd536": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"object\",\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: &Value{t: typeRawString, s: \"value\"}}}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t}},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{t: typeRawString, s: \"hello\"},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"true\",\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"false\",\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"null\",\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number\",\n\t\t\tinput:    \"42\",\n\t\t\texpected: &Value{t: TypeNumber, s: \"42\"},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid input\",\n\t\t\tinput:    \"invalid\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"depth exceeded\",\n\t\t\tinput:    strings.Repeat(\"{\", MaxDepth+1) + \"}\" + strings.Repeat(\"}\", MaxDepth+1),\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tv, _, err := parseValue(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(v, tc.expected) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", tc.input, v, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "51eb580ec9a46535500e7d56e243aafa": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"no escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"escaped characters\",\n\t\t\tinput:    \"hello\\\\n\\\\u0020world\",\n\t\t\texpected: \"hello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid escape sequence\",\n\t\t\tinput:    \"hello\\\\xworld\",\n\t\t\texpected: \"hello\\\\xworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"surrogate pairs\",\n\t\t\tinput:    \"hello\\\\ud83d\\\\ude00world\",\n\t\t\texpected: \"helloüòÄworld\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "526d23c85d09e89c801d9123b00e9a9b": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Basic escape characters\",\n\t\t\tinput:    \"hello\\\\\\\"world\\\\\\\\\",\n\t\t\texpected: \"hello\\\"world\\\\\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Unicode escape characters\",\n\t\t\tinput:    \"hello\\\\u0041world\\\\u002f\",\n\t\t\texpected: \"helloAworld/\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Surrogate pair escape characters\",\n\t\t\tinput:    \"hello\\\\ud83d\\\\ude00world\",\n\t\t\texpected: \"helloüòÄworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid escape characters\",\n\t\t\tinput:    \"hello\\\\xabworld\",\n\t\t\texpected: \"hello\\\\xabworld\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "503f3922e45e669920f6725150e5602b": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tinput   string\n\t\twant    *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:  \"valid JSON\",\n\t\t\tinput: `{\"name\":\"John\",\"age\":30}`,\n\t\t\twant: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"name\", v: &Value{s: \"John\", t: TypeString}},\n\t\t\t\t\t\t{k: \"age\", v: &Value{s: \"30\", t: TypeNumber}},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: true,\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid JSON\",\n\t\t\tinput:   `{\"name\":\"John\"age\":30}`,\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"unexpected tail\",\n\t\t\tinput:   `{\"name\":\"John\"} extra`,\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tp := &Parser{}\n\t\t\tgot, err := p.Parse(tt.input)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Parse() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"Parse() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn equalObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn equalArrays(v1.a, v2.a)\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeTrue, TypeFalse, TypeNull:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc equalObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !equalValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn o1.keysUnescaped == o2.keysUnescaped\n}\n\nfunc equalArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i := range a1 {\n\t\tif !equalValues(a1[i], a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "51623eafceb80d06c6bf0fcefe4a047b": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"empty array\",\n\t\t\tinput:    \"[]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{}},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with one value\",\n\t\t\tinput:    \"[1]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}}},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with multiple values\",\n\t\t\tinput:    \"[1,2,3]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}, &Value{t: TypeNumber, s: \"2\"}, &Value{t: TypeNumber, s: \"3\"}}},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with trailing comma\",\n\t\t\tinput:    \"[1,2,3,]\",\n\t\t\texpected: nil,\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with missing closing bracket\",\n\t\t\tinput:    \"[1,2,3\",\n\t\t\texpected: nil,\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tactual, _, err := parseArray(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseArray() = %v, want %v\", actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(a, b *Value) bool {\n\tif a == nil && b == nil {\n\t\treturn true\n\t}\n\tif a == nil || b == nil {\n\t\treturn false\n\t}\n\tif a.t != b.t {\n\t\treturn false\n\t}\n\tswitch a.t {\n\tcase TypeArray:\n\t\tif len(a.a) != len(b.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range a.a {\n\t\t\tif !compareValues(a.a[i], b.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\tcase TypeString:\n\t\tif a.s != b.s {\n\t\t\treturn false\n\t\t}\n\tcase TypeNumber:\n\t\tif a.s != b.s {\n\t\t\treturn false\n\t\t}\n\tcase TypeObject:\n\t\tif !a.o.equalsObject(&b.o) {\n\t\t\treturn false\n\t\t}\n\tcase TypeTrue, TypeFalse, TypeNull:\n\t\t// No additional checks needed\n\tdefault:\n\t\tpanic(\"unknown type\")\n\t}\n\treturn true\n}\n\nfunc (o *Object) equalsObject(b *Object) bool {\n\tif len(o.kvs) != len(b.kvs) {\n\t\treturn false\n\t}\n\tfor i := range o.kvs {\n\t\tif o.kvs[i].k != b.kvs[i].k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(o.kvs[i].v, b.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "52f0859c0121dc670dfa3c6394572777": "package fastjson_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/valyala/fastjson\"\n)\n\nfunc TestTypeString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    fastjson.Type\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"TypeObject\",\n\t\t\tinput:    fastjson.TypeObject,\n\t\t\texpected: \"object\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeArray\",\n\t\t\tinput:    fastjson.TypeArray,\n\t\t\texpected: \"array\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeString\",\n\t\t\tinput:    fastjson.TypeString,\n\t\t\texpected: \"string\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeNumber\",\n\t\t\tinput:    fastjson.TypeNumber,\n\t\t\texpected: \"number\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeTrue\",\n\t\t\tinput:    fastjson.TypeTrue,\n\t\t\texpected: \"true\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeFalse\",\n\t\t\tinput:    fastjson.TypeFalse,\n\t\t\texpected: \"false\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeNull\",\n\t\t\tinput:    fastjson.TypeNull,\n\t\t\texpected: \"null\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Unknown\",\n\t\t\tinput:    fastjson.Type(100),\n\t\t\texpected: \"BUG: unknown Value type: 100\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := tc.input.String()\n\t\t\tif got != tc.expected {\n\t\t\t\tt.Errorf(\"String() = %q, want %q\", got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "52b69c67d9b989e8d08cb882093db87e": "package fastjson\n\nimport (\n    \"testing\"\n)\n\nfunc TestGet(t *testing.T) {\n    tests := []struct {\n        name   string\n        input  *Value\n        keys   []string\n        expect *Value\n    }{\n        {\n            name:   \"Get from object\",\n            input:  &Value{t: TypeObject, o: &Object{kvs: []kv{{\"key1\", &Value{t: TypeString, s: \"value1\"}}, {\"key2\", &Value{t: TypeNumber, s: \"42\"}}}}},\n            keys:   []string{\"key1\"},\n            expect: &Value{t: TypeString, s: \"value1\"},\n        },\n        {\n            name:   \"Get from array\",\n            input:  &Value{t: TypeArray, a: []*Value{&Value{t: TypeString, s: \"item1\"}, &Value{t: TypeNumber, s: \"42\"}}},\n            keys:   []string{\"1\"},\n            expect: &Value{t: TypeNumber, s: \"42\"},\n        },\n        {\n            name:   \"Get non-existing key\",\n            input:  &Value{t: TypeObject, o: &Object{kvs: []kv{{\"key1\", &Value{t: TypeString, s: \"value1\"}}, {\"key2\", &Value{t: TypeNumber, s: \"42\"}}}}},\n            keys:   []string{\"key3\"},\n            expect: nil,\n        },\n        {\n            name:   \"Get from nested object\",\n            input:  &Value{t: TypeObject, o: &Object{kvs: []kv{{\"key1\", &Value{t: TypeObject, o: &Object{kvs: []kv{{\"subkey\", &Value{t: TypeString, s: \"subvalue\"}}}}}}}}},\n            keys:   []string{\"key1\", \"subkey\"},\n            expect: &Value{t: TypeString, s: \"subvalue\"},\n        },\n        {\n            name:   \"Get from nested array\",\n            input:  &Value{t: TypeObject, o: &Object{kvs: []kv{{\"key1\", &Value{t: TypeArray, a: []*Value{&Value{t: TypeString, s: \"item1\"}, &Value{t: TypeNumber, s: \"42\"}}}}}}},\n            keys:   []string{\"key1\", \"1\"},\n            expect: &Value{t: TypeNumber, s: \"42\"},\n        },\n    }\n\n    for _, test := range tests {\n        t.Run(test.name, func(t *testing.T) {\n            got := test.input.Get(test.keys...)\n            if got != test.expect {\n                t.Errorf(\"Get(%v) = %v, want %v\", test.keys, got, test.expect)\n            }\n        })\n    }\n}",
    "528a2d825a6aee6a7ac7a372fbecd8b5": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello, world\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello, world\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":\"value1\",\"key2\":42}`),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"one\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`[\"one\",42,true]`),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello, \\\"world\\\"\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello, \\\"world\\\"\"\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42.5\",\n\t\t\t},\n\t\t\twant: []byte(\"42.5\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := make([]byte, 0, 64)\n\t\t\tgot := tt.v.MarshalTo(dst)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", string(got), string(tt.want))\n\t\t\t}\n\t\t})\n\t}\n}",
    "53998db868a67109c659274b129aa427": "package fastjson\n\nimport (\n    \"reflect\"\n    \"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n    testCases := []struct {\n        name     string\n        input    string\n        expected *Value\n        wantErr  bool\n    }{\n        {\n            name:    \"empty array\",\n            input:   \"[]\",\n            expected: &Value{\n                t: TypeArray,\n                a: []*Value{},\n            },\n            wantErr: false,\n        },\n        {\n            name:    \"array with one value\",\n            input:   \"[1]\",\n            expected: &Value{\n                t: TypeArray,\n                a: []*Value{\n                    {\n                        t: TypeNumber,\n                        s: \"1\",\n                    },\n                },\n            },\n            wantErr: false,\n        },\n        {\n            name:    \"array with multiple values\",\n            input:   \"[1, 2, 3]\",\n            expected: &Value{\n                t: TypeArray,\n                a: []*Value{\n                    {\n                        t: TypeNumber,\n                        s: \"1\",\n                    },\n                    {\n                        t: TypeNumber,\n                        s: \"2\",\n                    },\n                    {\n                        t: TypeNumber,\n                        s: \"3\",\n                    },\n                },\n            },\n            wantErr: false,\n        },\n        {\n            name:    \"array with whitespace\",\n            input:   \"[ 1, 2 , 3 ]\",\n            expected: &Value{\n                t: TypeArray,\n                a: []*Value{\n                    {\n                        t: TypeNumber,\n                        s: \"1\",\n                    },\n                    {\n                        t: TypeNumber,\n                        s: \"2\",\n                    },\n                    {\n                        t: TypeNumber,\n                        s: \"3\",\n                    },\n                },\n            },\n            wantErr: false,\n        },\n        {\n            name:    \"incomplete array\",\n            input:   \"[1, 2,\",\n            expected: nil,\n            wantErr: true,\n        },\n    }\n\n    c := &cache{}\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            got, _, err := parseArray(tc.input, c, 0)\n            if (err != nil) != tc.wantErr {\n                t.Errorf(\"parseArray(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n                return\n            }\n            if !reflect.DeepEqual(got, tc.expected) {\n                t.Errorf(\"parseArray(%q) = %v, expected %v\", tc.input, got, tc.expected)\n            }\n        })\n    }\n}",
    "51deb49920dfc6e510077a17df92cc0a": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty input\",\n\t\t\tinput: \"\",\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"too deep\",\n\t\t\tinput: \"{}\", // Assuming MaxDepth is 1\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:     \"parse object\",\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{o: Object{kvs: []kv{{k: \"key\", v: &Value{s: \"value\", t: typeRawString}}}}, t: TypeObject},\n\t\t},\n\t\t{\n\t\t\tname:     \"parse array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{a: []*Value{&Value{s: \"1\", t: TypeNumber}, &Value{s: \"2\", t: TypeNumber}, &Value{s: \"3\", t: TypeNumber}}, t: TypeArray},\n\t\t},\n\t\t{\n\t\t\tname:     \"parse string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{s: \"hello\", t: typeRawString},\n\t\t},\n\t\t{\n\t\t\tname:     \"parse true\",\n\t\t\tinput:    `true`,\n\t\t\texpected: valueTrue,\n\t\t},\n\t\t{\n\t\t\tname:     \"parse false\",\n\t\t\tinput:    `false`,\n\t\t\texpected: valueFalse,\n\t\t},\n\t\t{\n\t\t\tname:     \"parse null\",\n\t\t\tinput:    `null`,\n\t\t\texpected: valueNull,\n\t\t},\n\t\t{\n\t\t\tname:     \"parse number\",\n\t\t\tinput:    `42`,\n\t\t\texpected: &Value{s: \"42\", t: TypeNumber},\n\t\t},\n\t\t{\n\t\t\tname:     \"parse NaN\",\n\t\t\tinput:    `NaN`,\n\t\t\texpected: &Value{s: \"NaN\", t: TypeNumber},\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, _, err := parseValue(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, want error: %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn compareObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn compareArrays(v1.a, v2.a)\n\tcase typeRawString, TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber, TypeTrue, TypeFalse, TypeNull:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc compareObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc compareArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tif !compareValues(v1, a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "54d21dbd2f396078b3efb6b6942aa1c4": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected1, expected2 string\n\t\texpectedErr bool\n\t}{\n\t\t{\n\t\t\tname:        \"No closing quote\",\n\t\t\tinput:       `hello`,\n\t\t\texpectedErr: true,\n\t\t},\n\t\t{\n\t\t\tname:        \"Unclosed quote\",\n\t\t\tinput:       `\"hello`,\n\t\t\texpectedErr: true,\n\t\t},\n\t\t{\n\t\t\tname:        \"Simple string\",\n\t\t\tinput:       `\"hello world\"`,\n\t\t\texpected1:   `hello world`,\n\t\t\texpected2:   ``,\n\t\t},\n\t\t{\n\t\t\tname:        \"String with escaped quote\",\n\t\t\tinput:       `\"hello \\\"world\\\"\"`,\n\t\t\texpected1:   `hello \"world\"`,\n\t\t\texpected2:   ``,\n\t\t},\n\t\t{\n\t\t\tname:        \"String with multiple escaped quotes\",\n\t\t\tinput:       `\"hello \\\"world\\\" \\\"foo\\\"\"`,\n\t\t\texpected1:   `hello \"world\" \"foo\"`,\n\t\t\texpected2:   ``,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual1, actual2, err := parseRawString(tc.input)\n\t\t\tif tc.expectedErr {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"Expected error, but got none\")\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif actual1 != tc.expected1 {\n\t\t\t\tt.Errorf(\"Expected first result to be %q, but got %q\", tc.expected1, actual1)\n\t\t\t}\n\n\t\t\tif actual2 != tc.expected2 {\n\t\t\t\tt.Errorf(\"Expected second result to be %q, but got %q\", tc.expected2, actual2)\n\t\t\t}\n\t\t})\n\t}\n}",
    "5247ae134bd05d190a83b85d60a407ce": "package fastjson_test\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tinput   string\n\t\twantVal *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty input\",\n\t\t\tinput: \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"depth exceeds max\",\n\t\t\tinput: \"{}\", // Nest max depth + 1\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"invalid object\",\n\t\t\tinput: \"{\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"invalid array\",\n\t\t\tinput: \"[\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"invalid string\",\n\t\t\tinput: `\"`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"invalid true\",\n\t\t\tinput: \"tru\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"invalid false\",\n\t\t\tinput: \"fals\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"invalid null\",\n\t\t\tinput: \"nul\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"invalid number\",\n\t\t\tinput: \"1.2.3\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"valid object\",\n\t\t\tinput: `{\"key\":\"value\"}`,\n\t\t\twantVal: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{s: \"value\", t: typeRawString}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"valid array\",\n\t\t\tinput: `[1,2,3]`,\n\t\t\twantVal: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"1\", t: TypeNumber},\n\t\t\t\t\t{s: \"2\", t: TypeNumber},\n\t\t\t\t\t{s: \"3\", t: TypeNumber},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"valid string\",\n\t\t\tinput: `\"hello\"`,\n\t\t\twantVal: &Value{\n\t\t\t\ts: \"hello\",\n\t\t\t\tt: typeRawString,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"valid true\",\n\t\t\tinput: \"true\",\n\t\t\twantVal: valueTrue,\n\t\t},\n\t\t{\n\t\t\tname:  \"valid false\",\n\t\t\tinput: \"false\",\n\t\t\twantVal: valueFalse,\n\t\t},\n\t\t{\n\t\t\tname:  \"valid null\",\n\t\t\tinput: \"null\",\n\t\t\twantVal: valueNull,\n\t\t},\n\t\t{\n\t\t\tname:  \"valid number\",\n\t\t\tinput: \"42\",\n\t\t\twantVal: &Value{\n\t\t\t\ts: \"42\",\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotVal, _, err := parseValue(tt.input, c, 0)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, wantErr %v\", tt.input, err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr && !equalValues(gotVal, tt.wantVal) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", tt.input, gotVal, tt.wantVal)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\to1, _ := v1.Object()\n\t\to2, _ := v2.Object()\n\t\treturn equalObjects(o1, o2)\n\tcase TypeArray:\n\t\ta1, _ := v1.Array()\n\t\ta2, _ := v2.Array()\n\t\tif len(a1) != len(a2) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range a1 {\n\t\t\tif !equalValues(a1[i], a2[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase typeRawString, TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber, TypeTrue, TypeFalse:\n\t\treturn v1.s == v2.s\n\tcase TypeNull:\n\t\treturn true\n\tdefault:\n\t\tpanic(fmt.Errorf(\"unknown type: %d\", v1.t))\n\t}\n}\n\nfunc equalObjects(o1, o2 *Object) bool {\n\tif o1 == nil && o2 == nil {\n\t\treturn true\n\t}\n\tif o1 == nil || o2 == nil {\n\t\treturn false\n\t}\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i := range o1.kvs {\n\t\tif o1.kvs[i].k != o2.kvs[i].k {\n\t\t\treturn false\n\t\t}\n\t\tif !equalValues(o1.kvs[i].v, o2.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "52d2cdb7fd59ff3333585b77492b3dac": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:    \"empty input\",\n\t\t\tinput:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"single key-value pair\",\n\t\t\tinput: `{\"key\":\"value\"}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"multiple key-value pairs\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42,\"key3\":true}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\ts: \"42\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"nested object\",\n\t\t\tinput: `{\"key1\":{\"key2\":\"value2\"}}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\twantErr: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := &cache{\n\t\t\t\tvs: make([]Value, 0, 10),\n\t\t\t}\n\t\t\tgot, _, err := parseObject(tt.input, c, 0)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !compareValues(got, tt.expected) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn compareObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn compareArrays(v1.a, v2.a)\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber, TypeTrue, TypeFalse:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\treturn true\n\t}\n}\n\nfunc compareObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc compareArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tv2 := a2[i]\n\t\tif !compareValues(v1, v2) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "569ceb1896d923fc26f5c3de368f3449": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\targ  string\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targ:  \"\",\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no whitespace\",\n\t\t\targ:  \"hello\",\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace\",\n\t\t\targ:  \"   hello\",\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"mixed whitespace\",\n\t\t\targ:  \"   \\t\\n\\r hello\",\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"all whitespace\",\n\t\t\targ:  \"   \\t\\n\\r \",\n\t\t\twant: \"\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.arg); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow(%q) = %q, want %q\", tt.arg, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "55c709ffad8143534ddeaf41a1e7bd19": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.456\",\n\t\t\texpected: []string{\"123.456\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with scientific notation\",\n\t\t\tinput:    \"1.2e+3\",\n\t\t\texpected: []string{\"1.2e+3\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with leading sign\",\n\t\t\tinput:    \"-123\",\n\t\t\texpected: []string{\"-123\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number\",\n\t\t\tinput:    \"abc\",\n\t\t\texpected: []string{\"\", \"abc\"},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with inf\",\n\t\t\tinput:    \"inf\",\n\t\t\texpected: []string{\"inf\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with nan\",\n\t\t\tinput:    \"nan\",\n\t\t\texpected: []string{\"nan\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.expected[0] || rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, %q, want %q, %q\", tc.input, num, rest, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "53b23725d802bd896fea42c9c410de4c": "package fastjson\n\nimport (\n    \"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n    tests := []struct {\n        name    string\n        input   string\n        wantVal *Value\n        wantTail string\n        wantErr  bool\n    }{\n        {\n            name:  \"empty input\",\n            input: \"\",\n            wantErr: true,\n        },\n        {\n            name:  \"too big depth\",\n            input: \"{\\\"key\\\":\\\"value\\\"}\",\n            wantErr: true,\n        },\n        {\n            name:  \"valid object\",\n            input: \"{\\\"key\\\":\\\"value\\\"}\",\n            wantVal: &Value{\n                o: Object{\n                    kvs: []kv{\n                        {k: \"key\", v: &Value{s: \"value\", t: typeRawString}},\n                    },\n                },\n                t: TypeObject,\n            },\n            wantTail: \"\",\n        },\n        {\n            name:  \"valid array\",\n            input: \"[1,2,3]\",\n            wantVal: &Value{\n                a: []*Value{\n                    {s: \"1\", t: TypeNumber},\n                    {s: \"2\", t: TypeNumber},\n                    {s: \"3\", t: TypeNumber},\n                },\n                t: TypeArray,\n            },\n            wantTail: \"\",\n        },\n        {\n            name:  \"valid string\",\n            input: \"\\\"hello\\\"\",\n            wantVal: &Value{\n                s: \"hello\",\n                t: typeRawString,\n            },\n            wantTail: \"\",\n        },\n        {\n            name:  \"valid true\",\n            input: \"true\",\n            wantVal: valueTrue,\n            wantTail: \"\",\n        },\n        {\n            name:  \"valid false\",\n            input: \"false\",\n            wantVal: valueFalse,\n            wantTail: \"\",\n        },\n        {\n            name:  \"valid null\",\n            input: \"null\",\n            wantVal: valueNull,\n            wantTail: \"\",\n        },\n        {\n            name:  \"valid number\",\n            input: \"123.45\",\n            wantVal: &Value{\n                s: \"123.45\",\n                t: TypeNumber,\n            },\n            wantTail: \"\",\n        },\n    }\n\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            c := &cache{}\n            gotVal, gotTail, err := parseValue(tt.input, c, 0)\n            if (err != nil) != tt.wantErr {\n                t.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n                return\n            }\n            if !equalValues(gotVal, tt.wantVal) {\n                t.Errorf(\"parseValue() gotVal = %v, want %v\", gotVal, tt.wantVal)\n            }\n            if gotTail != tt.wantTail {\n                t.Errorf(\"parseValue() gotTail = %q, want %q\", gotTail, tt.wantTail)\n            }\n        })\n    }\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n    if v1 == nil && v2 == nil {\n        return true\n    }\n    if v1 == nil || v2 == nil {\n        return false\n    }\n    if v1.t != v2.t {\n        return false\n    }\n    switch v1.t {\n    case TypeObject:\n        o1, _ := v1.Object()\n        o2, _ := v2.Object()\n        if len(o1.kvs) != len(o2.kvs) {\n            return false\n        }\n        for i := range o1.kvs {\n            if o1.kvs[i].k != o2.kvs[i].k {\n                return false\n            }\n            if !equalValues(o1.kvs[i].v, o2.kvs[i].v) {\n                return false\n            }\n        }\n    case TypeArray:\n        a1, _ := v1.Array()\n        a2, _ := v2.Array()\n        if len(a1) != len(a2) {\n            return false\n        }\n        for i := range a1 {\n            if !equalValues(a1[i], a2[i]) {\n                return false\n            }\n        }\n    case typeRawString, TypeString, TypeNumber:\n        return v1.s == v2.s\n    case TypeTrue, TypeFalse, TypeNull:\n        return true\n    }\n    return true\n}",
    "567dc1a07a611eae451a61af6d9ce469": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetValue(t *testing.T) {\n\tc := &cache{\n\t\tvs: make([]Value, 0, 10),\n\t}\n\n\t// Test when capacity is greater than length\n\tv1 := c.getValue()\n\tif len(c.vs) != 1 {\n\t\tt.Errorf(\"expected length of vs to be 1, got %d\", len(c.vs))\n\t}\n\tif v1 != &c.vs[0] {\n\t\tt.Errorf(\"expected v1 to be the last element in vs, got %p\", v1)\n\t}\n\n\t// Test when capacity is equal to length\n\tfor i := 0; i < cap(c.vs); i++ {\n\t\tc.getValue()\n\t}\n\tif len(c.vs) != cap(c.vs) {\n\t\tt.Errorf(\"expected length of vs to be equal to capacity, got length %d, capacity %d\", len(c.vs), cap(c.vs))\n\t}\n\tv2 := c.getValue()\n\tif len(c.vs) != cap(c.vs) {\n\t\tt.Errorf(\"expected length of vs to be equal to capacity, got length %d, capacity %d\", len(c.vs), cap(c.vs))\n\t}\n\tif v2 != &c.vs[len(c.vs)-1] {\n\t\tt.Errorf(\"expected v2 to be the last element in vs, got %p\", v2)\n\t}\n}",
    "55ae7eb91da475c49df165ec95632208": "package fastjson\n\nimport (\n\t\"bytes\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":\"value1\",\"key2\":42}`),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"elem1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`[\"elem1\",42,true]`),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42\",\n\t\t\t},\n\t\t\twant: []byte(\"42\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"unknown type\",\n\t\t\tv: &Value{\n\t\t\t\tt: 999,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := make([]byte, 0, len(tt.want))\n\t\t\tdst := tt.v.MarshalTo(got)\n\t\t\tif !reflect.DeepEqual(dst, tt.want) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %s, want %s\", dst, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "56d6cf5f0d301863de996118db5b3f31": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype testCase struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected1, expected2 string\n\t\texpectedErr bool\n\t}\n\n\ttestCases := []testCase{\n\t\t{\n\t\t\tname:        \"Simple string\",\n\t\t\tinput:        `\"hello world\"`,\n\t\t\texpected1:    \"hello world\",\n\t\t\texpected2:    \"\",\n\t\t\texpectedErr: false,\n\t\t},\n\t\t{\n\t\t\tname:        \"String with escaped quotes\",\n\t\t\tinput:        `\"hello \\\"world\\\"\"`,\n\t\t\texpected1:    `hello \"world\"`,\n\t\t\texpected2:    \"\",\n\t\t\texpectedErr: false,\n\t\t},\n\t\t{\n\t\t\tname:        \"Missing closing quote\",\n\t\t\tinput:        `\"hello world`,\n\t\t\texpected1:    \"\",\n\t\t\texpected2:    \"\",\n\t\t\texpectedErr: true,\n\t\t},\n\t\t{\n\t\t\tname:        \"Empty string\",\n\t\t\tinput:        `\"\"`,\n\t\t\texpected1:    \"\",\n\t\t\texpected2:    \"\",\n\t\t\texpectedErr: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult1, result2, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.expectedErr {\n\t\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expectedErr %v\", tc.input, err, tc.expectedErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif result1 != tc.expected1 {\n\t\t\t\tt.Errorf(\"parseRawString(%q) result1 = %q, expected %q\", tc.input, result1, tc.expected1)\n\t\t\t}\n\t\t\tif result2 != tc.expected2 {\n\t\t\t\tt.Errorf(\"parseRawString(%q) result2 = %q, expected %q\", tc.input, result2, tc.expected2)\n\t\t\t}\n\t\t})\n\t}\n}",
    "569adecc916ae3f07b25462da44a89f4": "package fastjson\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"testing\"\n)\n\nfunc TestMarshalTo(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"Raw string\",\n\t\t\tv: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello, world\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello, world\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"Object\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":\"value1\",\"key2\":42}`),\n\t\t},\n\t\t{\n\t\t\tname: \"Array\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"str1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t\t{t: TypeFalse},\n\t\t\t\t\t{t: TypeNull},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`[\"str1\",42,true,false,null]`),\n\t\t},\n\t\t{\n\t\t\tname: \"String\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello, world\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello, world\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"Number\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42\",\n\t\t\t},\n\t\t\twant: []byte(\"42\"),\n\t\t},\n\t\t{\n\t\t\tname: \"True\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"False\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"Null\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdst := make([]byte, 0, 64)\n\t\t\tgot := tc.v.MarshalTo(dst)\n\t\t\tif !bytes.Equal(got, tc.want) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %q, want %q\", got, tc.want)\n\t\t\t}\n\n\t\t\t// Compare with the standard library JSON marshaler\n\t\t\tvar buf bytes.Buffer\n\t\t\tif err := json.NewEncoder(&buf).Encode(tc.v); err != nil {\n\t\t\t\tt.Errorf(\"json.NewEncoder().Encode() failed: %v\", err)\n\t\t\t}\n\t\t\tif !bytes.Equal(got, buf.Bytes()) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %q, standard library JSON = %q\", got, buf.Bytes())\n\t\t\t}\n\t\t})\n\t}\n}",
    "55ab33cd70885a9d7bec39d7c6952a4f": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"object\",\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: &Value{t: typeRawString, s: \"value\"}}}}},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}, &Value{t: TypeNumber, s: \"2\"}, &Value{t: TypeNumber, s: \"3\"}}},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{t: typeRawString, s: \"hello\"},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"true\",\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"false\",\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"null\",\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"number\",\n\t\t\tinput:    \"42\",\n\t\t\texpected: &Value{t: TypeNumber, s: \"42\"},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"max depth exceeded\",\n\t\t\tinput:    \"{}\", // Assuming MaxDepth is 1\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tv, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, expected %v\", tc.input, err, tc.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else if tc.err != nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = nil, expected %v\", tc.input, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !equalValue(v, tc.expected) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, expected %v\", tc.input, v, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValue(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn equalObject(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn equalArray(v1.a, v2.a)\n\tcase typeRawString, TypeNumber, TypeTrue, TypeFalse:\n\t\treturn v1.s == v2.s\n\tcase TypeNull:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc equalObject(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !equalValue(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc equalArray(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tif !equalValue(v1, a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "5839b963b0f00d47ba1ea71416983cae": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tinput   string\n\t\twant    *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:  \"valid JSON\",\n\t\t\tinput: `{\"key1\": \"value1\", \"key2\": 123}`,\n\t\t\twant: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid JSON\",\n\t\t\tinput:   `{\"key1\": \"value1\", \"key2\":`,\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"empty input\",\n\t\t\tinput:   \"\",\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tp := &Parser{}\n\t\t\tgot, err := p.Parse(tt.input)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Parse() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !cmpValue(got, tt.want) {\n\t\t\t\tt.Errorf(\"Parse() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc cmpValue(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeNull, TypeTrue, TypeFalse:\n\t\treturn true\n\tcase TypeNumber, TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeObject:\n\t\treturn cmpObject(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, v := range v1.a {\n\t\t\tif !cmpValue(v, v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc cmpObject(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !cmpValue(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "58c7405e774342bc9822664969457783": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantKey  string\n\t\twantRest string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\twantKey:  \"hello\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello\\\"world\"`,\n\t\t\twantKey:  `hello\"world`,\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello\\\"world\\\"foo\"`,\n\t\t\twantKey:  `hello\"world\"foo`,\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with unbalanced quote\",\n\t\t\tinput:    `\"hello`,\n\t\t\twantKey:  \"\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tkey, rest, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif key != tc.wantKey {\n\t\t\t\tt.Errorf(\"parseRawString(%q) key = %q, want %q\", tc.input, key, tc.wantKey)\n\t\t\t}\n\t\t\tif rest != tc.wantRest {\n\t\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, want %q\", tc.input, rest, tc.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "59947fc5320ff2dac77bc86ecff32065": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello world\"`,\n\t\t\texpected: \"hello world\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello \\\"world\\\"\"`,\n\t\t\texpected: `hello \"world\"`,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello \\\"world\\\" \\\"again\\\"\"`,\n\t\t\texpected: `hello \"world\" \"again\"`,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string without closing quote\",\n\t\t\tinput:    `\"hello world`,\n\t\t\texpected: \"\",\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult, _, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t}\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"expected %q, got %q\", tc.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "5babdb3951265dc321e891198b96edd4": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestHasSpecialChars(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname:     \"Empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"String with no special characters\",\n\t\t\tinput:    \"abcdefghijklmnopqrstuvwxyz\",\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"String with double quote\",\n\t\t\tinput:    \"hello \\\"world\\\"\",\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"String with backslash\",\n\t\t\tinput:    \"hello\\\\world\",\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"String with control character\",\n\t\t\tinput:    \"hello\\nworld\",\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := hasSpecialChars(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"hasSpecialChars(%q) = %t, expected %t\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "5918e72973e48fabd54b0b57cef2017c": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"no escape characters\",\n\t\t\tinput:    \"hello world\",\n\t\t\texpected: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"simple escape characters\",\n\t\t\tinput:    \"hello\\\\\\\"world\\\\\\\\\",\n\t\t\texpected: \"hello\\\"world\\\\\",\n\t\t},\n\t\t{\n\t\t\tname:     \"complex escape characters\",\n\t\t\tinput:    \"hello\\\\u0020world\\\\u000a\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u002f\",\n\t\t\texpected: \"hello world\\n\\b\\f\\n\\r\\t/\",\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid unicode escape\",\n\t\t\tinput:    \"hello\\\\u0020world\\\\u001\",\n\t\t\texpected: \"hello \\\\u0020world\\\\u001\",\n\t\t},\n\t\t{\n\t\t\tname:     \"incomplete surrogate pair\",\n\t\t\tinput:    \"hello\\\\u0020world\\\\u0021\\\\uD800\",\n\t\t\texpected: \"hello \\\\u0020world\\\\u0021\\\\uD800\",\n\t\t},\n\t\t{\n\t\t\tname:     \"valid surrogate pair\",\n\t\t\tinput:    \"hello\\\\u0020world\\\\u0021\\\\uD800\\\\uDC00\",\n\t\t\texpected: \"hello \\\\u0020world\\\\u0021\\U00010000\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "5871d8de5bda10f9c2f0957142902f82": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:  \"empty input\",\n\t\t\tinput: \"\",\n\t\t\terr:   fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:  \"too big depth\",\n\t\t\tinput: \"{}\", // Assuming MaxDepth = 1\n\t\t\terr:   fmt.Errorf(\"too big depth for the nested JSON; it exceeds 1\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"valid object\",\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: &Value{t: typeRawString, s: \"value\"}}}}},\n\t\t},\n\t\t{\n\t\t\tname:     \"valid array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}, &Value{t: TypeNumber, s: \"2\"}, &Value{t: TypeNumber, s: \"3\"}}},\n\t\t},\n\t\t{\n\t\t\tname:     \"valid string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{t: typeRawString, s: \"hello\"},\n\t\t},\n\t\t{\n\t\t\tname:     \"valid true\",\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid false\",\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid null\",\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"42\",\n\t\t\texpected: &Value{t: TypeNumber, s: \"42\"},\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, expected %v\", tc.input, err, tc.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else if tc.err != nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = nil, expected %v\", tc.input, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif tc.expected != nil && !tc.expected.Equal(got) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, expected %v\", tc.input, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "58c88278ce1d66a2a2e9a8ffad165b22": "package fastjson\n\nimport (\n    \"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n    testCases := []struct {\n        name     string\n        input    string\n        expected *Value\n        err      bool\n    }{\n        {\n            name:  \"valid object\",\n            input: `{\"key1\":\"value1\",\"key2\":true}`,\n            expected: func() *Value {\n                v := &Value{\n                    t: TypeObject,\n                    o: Object{\n                        kvs: []kv{\n                            {k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n                            {k: \"key2\", v: &Value{t: TypeTrue}},\n                        },\n                    },\n                }\n                return v\n            }(),\n            err: false,\n        },\n        {\n            name:  \"missing closing brace\",\n            input: `{\"key1\":\"value1\",\"key2\":true`,\n            err:   true,\n        },\n        {\n            name:  \"missing object key\",\n            input: `{:true}`,\n            err:   true,\n        },\n        {\n            name:  \"invalid value type\",\n            input: `{\"key1\":123.4}`,\n            err:   true,\n        },\n    }\n\n    c := &cache{}\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            v, _, err := parseObject(tc.input, c, 0)\n            if (err != nil) != tc.err {\n                t.Errorf(\"parseObject(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n                return\n            }\n            if err == nil && !v.Equal(tc.expected) {\n                t.Errorf(\"parseObject(%q) = %v, want %v\", tc.input, v, tc.expected)\n            }\n        })\n    }\n}",
    "5d423fabd7fd94b752240bfb62492b92": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestGetArray(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tjson   string\n\t\tkeys   []string\n\t\texpect []*Value\n\t}{\n\t\t{\n\t\t\tname: \"valid array\",\n\t\t\tjson: `{\"key1\": [1, 2, 3]}`,\n\t\t\tkeys: []string{\"key1\"},\n\t\t\texpect: []*Value{\n\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"non-existing key\",\n\t\t\tjson: `{\"key1\": [1, 2, 3]}`,\n\t\t\tkeys: []string{\"key2\"},\n\t\t\texpect: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid value type\",\n\t\t\tjson: `{\"key1\": \"value\"}`,\n\t\t\tkeys: []string{\"key1\"},\n\t\t\texpect: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"array index key\",\n\t\t\tjson: `{\"key1\": [1, 2, 3]}`,\n\t\t\tkeys: []string{\"key1\", \"1\"},\n\t\t\texpect: []*Value{{t: TypeNumber, s: \"2\"}},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tv, err := Parse(test.json)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgot := v.GetArray(test.keys...)\n\t\t\tif !reflect.DeepEqual(got, test.expect) {\n\t\t\t\tt.Errorf(\"GetArray(%v) = %v, want %v\", test.keys, got, test.expect)\n\t\t\t}\n\t\t})\n\t}\n}",
    "59b8e71ef0b4aca2099db261e7678633": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:  \"Valid object\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tc := &cache{}\n\t\t\t\tv, _, _ := parseObject(`{\"key1\":\"value1\",\"key2\":42}`, c, 0)\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"Missing closing brace\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42`,\n\t\t\texpected: func() *Value {\n\t\t\t\tc := &cache{}\n\t\t\t\tv, _, err := parseObject(`{\"key1\":\"value1\",\"key2\":42`, c, 0)\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"Empty input\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t\t{\n\t\t\tname:  \"Nested object\",\n\t\t\tinput: `{\"key1\":{\"subkey\":\"subvalue\"},\"key2\":42}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tc := &cache{}\n\t\t\t\tv, _, _ := parseObject(`{\"key1\":{\"subkey\":\"subvalue\"},\"key2\":42}`, c, 0)\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: nil,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tv, _, err := parseObject(tt.input, c, 0)\n\t\t\tif err != nil && tt.err == nil {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, expected no error\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err == nil && tt.err != nil {\n\t\t\t\tt.Errorf(\"parseObject() error = nil, expected error %v\", tt.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err != nil && tt.err != nil && err.Error() != tt.err.Error() {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, expected error %v\", err, tt.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !v.Equal(tt.expected) {\n\t\t\t\tt.Errorf(\"parseObject() = %v, expected %v\", v, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "5d9ba318f485a038f98ce79add0f925e": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantNum  string\n\t\twantRest string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.456e+7foo\",\n\t\t\twantNum:  \"123.456e+7\",\n\t\t\twantRest: \"foo\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with leading minus\",\n\t\t\tinput:    \"-123.456e+7foo\",\n\t\t\twantNum:  \"-123.456e+7\",\n\t\t\twantRest: \"foo\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with leading plus\",\n\t\t\tinput:    \"+123.456e+7foo\",\n\t\t\twantNum:  \"+123.456e+7\",\n\t\t\twantRest: \"foo\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number\",\n\t\t\tinput:    \"foo123.456e+7\",\n\t\t\twantNum:  \"\",\n\t\t\twantRest: \"foo123.456e+7\",\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"inf\",\n\t\t\tinput:    \"infbar\",\n\t\t\twantNum:  \"inf\",\n\t\t\twantRest: \"bar\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"nan\",\n\t\t\tinput:    \"nanbar\",\n\t\t\twantNum:  \"nan\",\n\t\t\twantRest: \"bar\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty input\",\n\t\t\tinput:    \"\",\n\t\t\twantNum:  \"\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNum, gotRest, err := parseRawNumber(tt.input)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNum != tt.wantNum {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNum = %v, want %v\", gotNum, tt.wantNum)\n\t\t\t}\n\t\t\tif gotRest != tt.wantRest {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotRest = %v, want %v\", gotRest, tt.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "5f00dfe65b2cd06b1edd54aff1a38985": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestType_String(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tt        Type\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"TypeObject\",\n\t\t\tt:        TypeObject,\n\t\t\texpected: \"object\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeArray\",\n\t\t\tt:        TypeArray,\n\t\t\texpected: \"array\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeString\",\n\t\t\tt:        TypeString,\n\t\t\texpected: \"string\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeNumber\",\n\t\t\tt:        TypeNumber,\n\t\t\texpected: \"number\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeTrue\",\n\t\t\tt:        TypeTrue,\n\t\t\texpected: \"true\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeFalse\",\n\t\t\tt:        TypeFalse,\n\t\t\texpected: \"false\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeNull\",\n\t\t\tt:        TypeNull,\n\t\t\texpected: \"null\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Unknown Type\",\n\t\t\tt:        Type(100),\n\t\t\texpected: \"BUG: unknown Value type: 100\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := tc.t.String()\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"expected %s, got %s\", tc.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "5f2d638daec8a7a43d52ea4a7cee1688": "package fastjson\n\nimport (\n    \"testing\"\n)\n\nfunc TestValueType(t *testing.T) {\n    testCases := []struct {\n        name     string\n        value    *Value\n        expected Type\n    }{\n        {\n            name:     \"Null\",\n            value:    &Value{t: TypeNull},\n            expected: TypeNull,\n        },\n        {\n            name:     \"Object\",\n            value:    &Value{t: TypeObject},\n            expected: TypeObject,\n        },\n        {\n            name:     \"Array\",\n            value:    &Value{t: TypeArray},\n            expected: TypeArray,\n        },\n        {\n            name:     \"String\",\n            value:    &Value{t: TypeString},\n            expected: TypeString,\n        },\n        {\n            name:     \"Number\",\n            value:    &Value{t: TypeNumber},\n            expected: TypeNumber,\n        },\n        {\n            name:     \"True\",\n            value:    &Value{t: TypeTrue},\n            expected: TypeTrue,\n        },\n        {\n            name:     \"False\",\n            value:    &Value{t: TypeFalse},\n            expected: TypeFalse,\n        },\n        {\n            name:     \"RawString\",\n            value:    &Value{t: typeRawString},\n            expected: typeRawString,\n        },\n    }\n\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            if got := tc.value.Type(); got != tc.expected {\n                t.Errorf(\"Value.Type() = %v, expected %v\", got, tc.expected)\n            }\n        })\n    }\n}",
    "5da18abcb95e96380f9c8fd275d622fd": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"no escape sequence\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"simple escape sequence\",\n\t\t\tinput:    \"hello\\\\\\\"world\",\n\t\t\texpected: \"hello\\\"world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple escape sequences\",\n\t\t\tinput:    \"hello\\\\\\\"world\\\\n\\\\t\",\n\t\t\texpected: \"hello\\\"world\\n\\t\",\n\t\t},\n\t\t{\n\t\t\tname:     \"unicode escape sequence\",\n\t\t\tinput:    \"hello\\\\u0061world\",\n\t\t\texpected: \"helloaworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"surrogate pair unicode escape sequence\",\n\t\t\tinput:    \"hello\\\\ud83d\\\\ude00world\",\n\t\t\texpected: \"helloüòÄworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid unicode escape sequence\",\n\t\t\tinput:    \"hello\\\\u123world\",\n\t\t\texpected: \"hello\\\\u123world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"unknown escape sequence\",\n\t\t\tinput:    \"hello\\\\xworld\",\n\t\t\texpected: \"hello\\\\xworld\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "5ec1cf68f235fec45dbd1b9bba550fd2": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape sequence\",\n\t\t\tinput:    \"hello world\",\n\t\t\texpected: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Simple escape sequence\",\n\t\t\tinput:    \"hello\\\\nworld\",\n\t\t\texpected: \"hello\\nworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Multiple escape sequences\",\n\t\t\tinput:    \"hello\\\\n\\\\r\\\\t\\\\u0020world\",\n\t\t\texpected: \"hello\\n\\r\\t world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Incomplete escape sequence\",\n\t\t\tinput:    \"hello\\\\u001\",\n\t\t\texpected: \"hello\\\\u001\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid escape sequence\",\n\t\t\tinput:    \"hello\\\\xyzworld\",\n\t\t\texpected: \"hello\\\\xyzworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Surrogate pair\",\n\t\t\tinput:    \"hello\\\\uD83D\\\\uDE00world\",\n\t\t\texpected: \"helloüòÄworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Incomplete surrogate pair\",\n\t\t\tinput:    \"hello\\\\uD83D\",\n\t\t\texpected: \"hello\\\\uD83D\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "5f7e1b408299a5feceba48dcfcc3c3e6": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: []string{\"hello\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"he\\\"llo\"`,\n\t\t\texpected: []string{\"he\\\"llo\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"he\\\\\\\"llo\"`,\n\t\t\texpected: []string{\"he\\\\\\\"llo\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with missing closing quote\",\n\t\t\tinput:    `\"hello`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    `\"\"`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, rest, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif actual != tc.expected[0] || rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = %q, %q, want %q, %q\", tc.input, actual, rest, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "5cd64ad2aa4560244f16feafbdcdc631": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype testCase struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}\n\n\ttestCases := []testCase{\n\t\t{\n\t\t\tname:     \"Empty object\",\n\t\t\tinput:    \"{}\",\n\t\t\texpected: &Value{t: TypeObject, o: Object{}},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"Object with one key-value pair\",\n\t\t\tinput: `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{t: TypeString, s: \"value\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"Object with multiple key-value pairs\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42,\"key3\":true}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t\t{k: \"key3\", v: &Value{t: TypeTrue}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"Object with missing closing brace\",\n\t\t\tinput: `{\"key\":\"value\"`,\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t\t{\n\t\t\tname:  \"Object with missing key\",\n\t\t\tinput: `{:42}`,\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(`cannot find opening '\"\" for object key`),\n\t\t},\n\t\t{\n\t\t\tname:  \"Object with missing colon\",\n\t\t\tinput: `{\"key\" 42}`,\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t\t{\n\t\t\tname:  \"Object with missing comma\",\n\t\t\tinput: `{\"key1\":\"value1\" \"key2\":42}`,\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseObject(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseObject(%q) error = %v, expected %v\", tc.input, err, tc.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else if tc.err != nil {\n\t\t\t\tt.Errorf(\"parseObject(%q) error = nil, expected %v\", tc.input, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !equalValues(got, tc.expected) {\n\t\t\t\tt.Errorf(\"parseObject(%q) = %v, expected %v\", tc.input, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn equalObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn equalArrays(v1.a, v2.a)\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\treturn v1.s == v2.s\n\t}\n}\n\nfunc equalObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i := range o1.kvs {\n\t\tif o1.kvs[i].k != o2.kvs[i].k {\n\t\t\treturn false\n\t\t}\n\t\tif !equalValues(o1.kvs[i].v, o2.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc equalArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i := range a1 {\n\t\tif !equalValues(a1[i], a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "638aa3553dd719f069b9f6dffc648994": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObjectReset(t *testing.T) {\n\tobj := &Object{\n\t\tkvs: []kv{\n\t\t\t{k: \"key1\", v: &Value{s: \"value1\"}},\n\t\t\t{k: \"key2\", v: &Value{s: \"value2\"}},\n\t\t},\n\t\tkeysUnescaped: true,\n\t}\n\n\tobj.reset()\n\n\tif len(obj.kvs) != 0 {\n\t\tt.Errorf(\"Expected kvs to be empty, got %d\", len(obj.kvs))\n\t}\n\n\tif obj.keysUnescaped {\n\t\tt.Error(\"Expected keysUnescaped to be false\")\n\t}\n}",
    "5d50de60db0396b2d0bd0253f72fb162": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tinput   string\n\t\twantVal *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"empty string\",\n\t\t\tinput:   \"\",\n\t\t\twantVal: nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"too big depth\",\n\t\t\tinput:   \"{}\", // Simulating too big depth by not providing any content\n\t\t\twantVal: nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"valid object\",\n\t\t\tinput:   `{\"key\":\"value\"}`,\n\t\t\twantVal: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t\tt: typeRawString,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"valid array\",\n\t\t\tinput:   `[\"item1\",\"item2\"]`,\n\t\t\twantVal: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\ts: \"item1\",\n\t\t\t\t\t\tt: typeRawString,\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\ts: \"item2\",\n\t\t\t\t\t\tt: typeRawString,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"valid string\",\n\t\t\tinput:   `\"hello\"`,\n\t\t\twantVal: &Value{\n\t\t\t\ts: \"hello\",\n\t\t\t\tt: typeRawString,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"valid true\",\n\t\t\tinput:   \"true\",\n\t\t\twantVal: valueTrue,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"valid false\",\n\t\t\tinput:   \"false\",\n\t\t\twantVal: valueFalse,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"valid null\",\n\t\t\tinput:   \"null\",\n\t\t\twantVal: valueNull,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"valid number\",\n\t\t\tinput:   \"42\",\n\t\t\twantVal: &Value{\n\t\t\t\ts: \"42\",\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotVal, _, err := parseValue(tt.input, c, 0)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !compareValues(gotVal, tt.wantVal) {\n\t\t\t\tt.Errorf(\"parseValue() = %v, want %v\", gotVal, tt.wantVal)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase typeRawString:\n\t\treturn v1.s == v2.s\n\tcase TypeObject:\n\t\treturn compareObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn compareArrays(v1.a, v2.a)\n\tcase TypeNumber, TypeTrue, TypeFalse, TypeNull:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc compareObjects(o1, o2 *Object) bool {\n\tif o1 == nil && o2 == nil {\n\t\treturn true\n\t}\n\tif o1 == nil || o2 == nil {\n\t\treturn false\n\t}\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i := range o1.kvs {\n\t\tif o1.kvs[i].k != o2.kvs[i].k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(o1.kvs[i].v, o2.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc compareArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i := range a1 {\n\t\tif !compareValues(a1[i], a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "61c8116723a685d16e3b316f3a1002d9": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape sequence\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Simple escape sequence\",\n\t\t\tinput:    \"hello\\\\nworld\",\n\t\t\texpected: \"hello\\nworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Unicode escape sequence\",\n\t\t\tinput:    \"hello\\\\u0123world\",\n\t\t\texpected: \"hello\\u0123world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Surrogate pair escape sequence\",\n\t\t\tinput:    \"hello\\\\ud83d\\\\ude00world\",\n\t\t\texpected: \"helloüòÄworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid escape sequence\",\n\t\t\tinput:    \"hello\\\\xyzworld\",\n\t\t\texpected: \"hello\\\\xyzworld\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif !reflect.DeepEqual(result, tc.expected) {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "60373dd5eb43b7806c0c2d73a68b5a1f": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts      string\n\t\tc      *cache\n\t\tdepth  int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:      \"\",\n\t\t\t\tc:      &cache{},\n\t\t\t\tdepth:  0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"depth exceeded\",\n\t\t\targs: args{\n\t\t\t\ts:      \"{}\", // Arbitrary JSON value\n\t\t\t\tc:      &cache{},\n\t\t\t\tdepth:  MaxDepth + 1,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"parse object\",\n\t\t\targs: args{\n\t\t\t\ts:      `{\"key\":\"value\"}`,\n\t\t\t\tc:      &cache{},\n\t\t\t\tdepth:  0,\n\t\t\t},\n\t\t\twant: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t\tt: typeRawString,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"parse array\",\n\t\t\targs: args{\n\t\t\t\ts:      `[1,2,3]`,\n\t\t\t\tc:      &cache{},\n\t\t\t\tdepth:  0,\n\t\t\t},\n\t\t\twant: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"parse string\",\n\t\t\targs: args{\n\t\t\t\ts:      `\"hello\"`,\n\t\t\t\tc:      &cache{},\n\t\t\t\tdepth:  0,\n\t\t\t},\n\t\t\twant: &Value{\n\t\t\t\ts: \"hello\",\n\t\t\t\tt: typeRawString,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"parse true\",\n\t\t\targs: args{\n\t\t\t\ts:      \"true\",\n\t\t\t\tc:      &cache{},\n\t\t\t\tdepth:  0,\n\t\t\t},\n\t\t\twant:    valueTrue,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"parse false\",\n\t\t\targs: args{\n\t\t\t\ts:      \"false\",\n\t\t\t\tc:      &cache{},\n\t\t\t\tdepth:  0,\n\t\t\t},\n\t\t\twant:    valueFalse,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"parse null\",\n\t\t\targs: args{\n\t\t\t\ts:      \"null\",\n\t\t\t\tc:      &cache{},\n\t\t\t\tdepth:  0,\n\t\t\t},\n\t\t\twant:    valueNull,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"parse number\",\n\t\t\targs: args{\n\t\t\t\ts:      \"42\",\n\t\t\t\tc:      &cache{},\n\t\t\t\tdepth:  0,\n\t\t\t},\n\t\t\twant: &Value{\n\t\t\t\ts: \"42\",\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !got.Equal(tt.want) {\n\t\t\t\tt.Errorf(\"parseValue() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "63cc792ba38391a1dc1494e0e4f7ffab": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts      string\n\t\tc      *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t// Add your test cases here\n\t\t{\n\t\t\tname: \"Test Case 1\",\n\t\t\targs: args{\n\t\t\t\ts:      `{\"key1\":\"value1\",\"key2\":123,\"key3\":true}`,\n\t\t\t\tc:      &cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{s: \"value1\", t: TypeString}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t\t{k: \"key3\", v: &Value{t: TypeTrue}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t// Add more test cases as needed\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "61b554d4a71f6eec4c4a774e11524106": "package fastjson\n\nimport (\n    \"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n    tests := []struct {\n        name     string\n        input    string\n        expected *Value\n        err      error\n    }{\n        {\n            name:  \"valid object\",\n            input: `{\"key1\":\"value1\",\"key2\":123}`,\n            expected: &Value{\n                t: TypeObject,\n                o: Object{\n                    kvs: []kv{\n                        {k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n                        {k: \"key2\", v: &Value{t: TypeNumber, s: \"123\"}},\n                    },\n                },\n            },\n            err: nil,\n        },\n        {\n            name:  \"object with missing closing brace\",\n            input: `{\"key1\":\"value1\",\"key2\":123`,\n            expected: nil,\n            err:      fmt.Errorf(\"missing '}'\"),\n        },\n        {\n            name:  \"object with missing colon\",\n            input: `{\"key1\":\"value1\" \"key2\":123}`,\n            expected: nil,\n            err:      fmt.Errorf(\"missing ':' after object key\"),\n        },\n        {\n            name:  \"object with missing comma\",\n            input: `{\"key1\":\"value1\" \"key2\":123}`,\n            expected: nil,\n            err:      fmt.Errorf(\"missing ',' after object value\"),\n        },\n    }\n\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            c := &cache{}\n            result, _, err := parseObject(tt.input, c, 0)\n            if err != nil {\n                if tt.err == nil || err.Error() != tt.err.Error() {\n                    t.Errorf(\"parseObject(%q) error = %v, expected %v\", tt.input, err, tt.err)\n                    return\n                }\n            } else {\n                if !compareValues(result, tt.expected) {\n                    t.Errorf(\"parseObject(%q) = %v, expected %v\", tt.input, result, tt.expected)\n                }\n            }\n        })\n    }\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n    if v1 == nil && v2 == nil {\n        return true\n    }\n    if v1 == nil || v2 == nil {\n        return false\n    }\n    if v1.t != v2.t {\n        return false\n    }\n    switch v1.t {\n    case TypeObject:\n        return compareObjects(&v1.o, &v2.o)\n    case TypeArray:\n        return compareArrays(v1.a, v2.a)\n    case TypeString:\n        return v1.s == v2.s\n    case TypeNumber, TypeTrue, TypeFalse:\n        return v1.s == v2.s\n    default:\n        return true\n    }\n}\n\nfunc compareObjects(o1, o2 *Object) bool {\n    if len(o1.kvs) != len(o2.kvs) {\n        return false\n    }\n    for i := range o1.kvs {\n        if o1.kvs[i].k != o2.kvs[i].k {\n            return false\n        }\n        if !compareValues(o1.kvs[i].v, o2.kvs[i].v) {\n            return false\n        }\n    }\n    return true\n}\n\nfunc compareArrays(a1, a2 []*Value) bool {\n    if len(a1) != len(a2) {\n        return false\n    }\n    for i := range a1 {\n        if !compareValues(a1[i], a2[i]) {\n            return false\n        }\n    }\n    return true\n}",
    "6430a06526b6fe0eb984404080988e8a": "package fastjson\n\nimport (\n    \"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n    testCases := []struct {\n        name     string\n        input    string\n        expected [3]string\n    }{\n        {\n            name:     \"Simple string\",\n            input:    `\"hello\"`,\n            expected: [3]string{\"hello\", \"\", \"\"},\n        },\n        {\n            name:     \"String with escaped quotes\",\n            input:    `\"he\\\"llo\"`,\n            expected: [3]string{\"he\\\"llo\", \"\", \"\"},\n        },\n        {\n            name:     \"String with missing closing quote\",\n            input:    `\"hello`,\n            expected: [3]string{\"\", \"\", \"missing closing '\\\"'\"},\n        },\n        {\n            name:     \"String with whitespace\",\n            input:    `\" hello \"`,\n            expected: [3]string{\" hello \", \"\", \"\"},\n        },\n    }\n\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            res, remainder, err := parseRawString(tc.input)\n            if res != tc.expected[0] || remainder != tc.expected[1] || (err != nil && err.Error() != tc.expected[2]) {\n                t.Errorf(\"parseRawString(%q) = %q, %q, %v; expected %q, %q, %v\",\n                    tc.input, res, remainder, err, tc.expected[0], tc.expected[1], tc.expected[2])\n            }\n        })\n    }\n}",
    "63402e102f86c86928aec807fb0479ab": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tinput   string\n\t\twantNum string\n\t\twantRem string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"valid number\",\n\t\t\tinput:   \"123.456e+7\",\n\t\t\twantNum: \"123.456e+7\",\n\t\t\twantRem: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with sign\",\n\t\t\tinput:   \"-0.0001\",\n\t\t\twantNum: \"-0.0001\",\n\t\t\twantRem: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with special chars\",\n\t\t\tinput:   \"123.45abc\",\n\t\t\twantNum: \"123.45\",\n\t\t\twantRem: \"abc\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with 'inf'\",\n\t\t\tinput:   \"+inf\",\n\t\t\twantNum: \"+inf\",\n\t\t\twantRem: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with 'nan'\",\n\t\t\tinput:   \"-NaN\",\n\t\t\twantNum: \"-NaN\",\n\t\t\twantRem: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number start\",\n\t\t\tinput:   \"a123.45\",\n\t\t\twantNum: \"\",\n\t\t\twantRem: \"a123.45\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"empty input\",\n\t\t\tinput:   \"\",\n\t\t\twantNum: \"\",\n\t\t\twantRem: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNum, gotRem, gotErr := parseRawNumber(tt.input)\n\t\t\tif gotNum != tt.wantNum {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) gotNum = %q, want %q\", tt.input, gotNum, tt.wantNum)\n\t\t\t}\n\t\t\tif gotRem != tt.wantRem {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) gotRem = %q, want %q\", tt.input, gotRem, tt.wantRem)\n\t\t\t}\n\t\t\tif (gotErr != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) gotErr = %v, wantErr %t\", tt.input, gotErr, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}",
    "621369ec062ba27fe0667dfb122818cd": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetObject(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tinput  string\n\t\tkeys   []string\n\t\texpect *Object\n\t}{\n\t\t{\n\t\t\tname:  \"existing keys path\",\n\t\t\tinput: `{\"a\":{\"b\":1}}`,\n\t\t\tkeys:  []string{\"a\", \"b\"},\n\t\t\texpect: &Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"b\", v: &Value{t: TypeNumber, s: \"1\"}},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:   \"non-existing keys path\",\n\t\t\tinput:  `{\"a\":{\"b\":1}}`,\n\t\t\tkeys:   []string{\"x\", \"y\"},\n\t\t\texpect: nil,\n\t\t},\n\t\t{\n\t\t\tname:   \"invalid value type\",\n\t\t\tinput:  `{\"a\":1}`,\n\t\t\tkeys:   []string{\"a\", \"b\"},\n\t\t\texpect: nil,\n\t\t},\n\t\t{\n\t\t\tname:   \"nil input\",\n\t\t\tinput:  \"\",\n\t\t\tkeys:   []string{\"a\", \"b\"},\n\t\t\texpect: nil,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tv, err := Parse(test.input)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t\t\t}\n\t\t\tactual := v.GetObject(test.keys...)\n\t\t\tif !objectsEqual(actual, test.expect) {\n\t\t\t\tt.Errorf(\"GetObject(%v) = %v, want %v\", test.keys, actual, test.expect)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc objectsEqual(o1, o2 *Object) bool {\n\tif o1 == nil && o2 == nil {\n\t\treturn true\n\t}\n\tif o1 == nil || o2 == nil {\n\t\treturn false\n\t}\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !valuesEqual(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc valuesEqual(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn objectsEqual(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, v := range v1.a {\n\t\t\tif !valuesEqual(v, v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber, TypeTrue, TypeFalse:\n\t\treturn v1.s == v2.s\n\tcase TypeNull:\n\t\treturn true\n\tdefault:\n\t\tpanic(\"unreachable\")\n\t}\n}",
    "63d456ce66116ca7c6f98bdfaf7cb763": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantNum  string\n\t\twantRest string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"12345.67e+89\",\n\t\t\twantNum:  \"12345.67e+89\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with sign\",\n\t\t\tinput:    \"-0.123\",\n\t\t\twantNum:  \"-0.123\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"inf\",\n\t\t\tinput:    \"inf\",\n\t\t\twantNum:  \"inf\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"nan\",\n\t\t\tinput:    \"nan\",\n\t\t\twantNum:  \"nan\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid character\",\n\t\t\tinput:    \"12a\",\n\t\t\twantNum:  \"\",\n\t\t\twantRest: \"12a\",\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty input\",\n\t\t\tinput:    \"\",\n\t\t\twantNum:  \"\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.wantNum {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) num = %q, want %q\", tc.input, num, tc.wantNum)\n\t\t\t}\n\t\t\tif rest != tc.wantRest {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) rest = %q, want %q\", tc.input, rest, tc.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "65d4ee93a3ee3af7d8087f02220faf12": "package fastjson\n\nimport (\n    \"testing\"\n)\n\nfunc TestObject_getKV(t *testing.T) {\n    type fields struct {\n        kvs           []kv\n        keysUnescaped bool\n    }\n    tests := []struct {\n        name   string\n        fields fields\n        want   *kv\n    }{\n        {\n            name: \"when kvs capacity is greater than length\",\n            fields: fields{\n                kvs:           make([]kv, 10, 20),\n                keysUnescaped: false,\n            },\n            want: &kv{},\n        },\n        {\n            name: \"when kvs capacity is equal to length\",\n            fields: fields{\n                kvs:           make([]kv, 10, 10),\n                keysUnescaped: true,\n            },\n            want: &kv{},\n        },\n    }\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            o := &Object{\n                kvs:           tt.fields.kvs,\n                keysUnescaped: tt.fields.keysUnescaped,\n            }\n            if got := o.getKV(); !(&kv{} == got) {\n                t.Errorf(\"Object.getKV() = %v, want %v\", got, tt.want)\n            }\n        })\n    }\n}",
    "645caff14b02a94bc8655b0b42b8bae0": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantKey  string\n\t\twantRest string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\twantKey:  \"hello\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"he\\\"llo\"`,\n\t\t\twantKey:  `he\"llo`,\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"he\\\"\\\"llo\"`,\n\t\t\twantKey:  `he\"\"llo`,\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with trailing whitespace\",\n\t\t\tinput:    `\"hello \"`,\n\t\t\twantKey:  \"hello\",\n\t\t\twantRest: \" \",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing closing quote\",\n\t\t\tinput:    `\"hello`,\n\t\t\twantKey:  \"\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tkey, rest, err := parseRawString(tt.input)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString(%q) error = %v, wantErr %v\", tt.input, err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif key != tt.wantKey {\n\t\t\t\tt.Errorf(\"parseRawString(%q) key = %q, want %q\", tt.input, key, tt.wantKey)\n\t\t\t}\n\t\t\tif rest != tt.wantRest {\n\t\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, want %q\", tt.input, rest, tt.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "649e83338fd51e1621a05feef82da083": "package fastjson\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"this is a simple string\",\n\t\t\texpected: \"this is a simple string\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape double quote\",\n\t\t\tinput:    \"\\\"hello\\\"\",\n\t\t\texpected: \"\\\"hello\\\"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backslash\",\n\t\t\tinput:    \"\\\\hello\\\\\",\n\t\t\texpected: \"\\\\hello\\\\\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape forward slash\",\n\t\t\tinput:    \"/hello/\",\n\t\t\texpected: \"/hello/\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backspace\",\n\t\t\tinput:    \"hello\\bworld\",\n\t\t\texpected: \"hello\\bworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape formfeed\",\n\t\t\tinput:    \"hello\\fworld\",\n\t\t\texpected: \"hello\\fworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape newline\",\n\t\t\tinput:    \"hello\\nworld\",\n\t\t\texpected: \"hello\\nworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape carriage return\",\n\t\t\tinput:    \"hello\\rworld\",\n\t\t\texpected: \"hello\\rworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape tab\",\n\t\t\tinput:    \"hello\\tworld\",\n\t\t\texpected: \"hello\\tworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape unicode\",\n\t\t\tinput:    \"hello\\\\u0041world\",\n\t\t\texpected: \"helloAworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape surrogate pair\",\n\t\t\tinput:    \"hello\\\\ud83d\\\\ude00world\",\n\t\t\texpected: \"helloüòÄworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid escape sequence\",\n\t\t\tinput:    \"hello\\\\xworld\",\n\t\t\texpected: \"hello\\\\xworld\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tassert.Equal(t, tc.expected, result)\n\t\t})\n\t}\n}",
    "61fabe52f811641e8d99fbb89579e7fe": "package fastjson\n\nimport (\n    \"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n    testCases := []struct {\n        name     string\n        input    string\n        expected *Value\n        errMsg   string\n    }{\n        {\n            name:     \"empty input\",\n            input:    \"\",\n            expected: nil,\n            errMsg:   \"cannot parse empty string\",\n        },\n        {\n            name:     \"max depth exceeded\",\n            input:    \"{}\", // Assume MaxDepth is 1 for this test case\n            expected: nil,\n            errMsg:   \"too big depth for the nested JSON; it exceeds 1\",\n        },\n        {\n            name:     \"parse object\",\n            input:    `{\"key\":\"value\"}`,\n            expected: &Value{\n                o: Object{\n                    kvs: []kv{\n                        {\n                            k: \"key\",\n                            v: &Value{\n                                s: \"value\",\n                                t: typeRawString,\n                            },\n                        },\n                    },\n                },\n                t: TypeObject,\n            },\n            errMsg: \"\",\n        },\n        {\n            name:     \"parse array\",\n            input:    `[1,2,3]`,\n            expected: &Value{\n                a: []*Value{\n                    {\n                        s: \"1\",\n                        t: TypeNumber,\n                    },\n                    {\n                        s: \"2\",\n                        t: TypeNumber,\n                    },\n                    {\n                        s: \"3\",\n                        t: TypeNumber,\n                    },\n                },\n                t: TypeArray,\n            },\n            errMsg: \"\",\n        },\n        {\n            name:     \"parse string\",\n            input:    `\"hello\"`,\n            expected: &Value{\n                s: \"hello\",\n                t: typeRawString,\n            },\n            errMsg: \"\",\n        },\n        {\n            name:     \"parse true\",\n            input:    \"true\",\n            expected: valueTrue,\n            errMsg:   \"\",\n        },\n        {\n            name:     \"parse false\",\n            input:    \"false\",\n            expected: valueFalse,\n            errMsg:   \"\",\n        },\n        {\n            name:     \"parse null\",\n            input:    \"null\",\n            expected: valueNull,\n            errMsg:   \"\",\n        },\n        {\n            name:     \"parse number\",\n            input:    \"42\",\n            expected: &Value{\n                s: \"42\",\n                t: TypeNumber,\n            },\n            errMsg: \"\",\n        },\n    }\n\n    c := &cache{}\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            actual, _, err := parseValue(tc.input, c, 0)\n            if tc.errMsg != \"\" {\n                if err == nil || err.Error() != tc.errMsg {\n                    t.Errorf(\"expected error: %s, got: %v\", tc.errMsg, err)\n                }\n            } else {\n                if err != nil {\n                    t.Errorf(\"unexpected error: %v\", err)\n                }\n                if !valueEqual(actual, tc.expected) {\n                    t.Errorf(\"expected: %#v, got: %#v\", tc.expected, actual)\n                }\n            }\n        })\n    }\n}\n\nfunc valueEqual(v1, v2 *Value) bool {\n    if v1 == nil && v2 == nil {\n        return true\n    }\n    if v1 == nil || v2 == nil {\n        return false\n    }\n    if v1.t != v2.t {\n        return false\n    }\n    switch v1.t {\n    case TypeObject:\n        return objectEqual(&v1.o, &v2.o)\n    case TypeArray:\n        return arrayEqual(v1.a, v2.a)\n    case typeRawString, TypeString, TypeNumber:\n        return v1.s == v2.s\n    case TypeTrue, TypeFalse, TypeNull:\n        return true\n    default:\n        return false\n    }\n}\n\nfunc objectEqual(o1, o2 *Object) bool {\n    if len(o1.kvs) != len(o2.kvs) {\n        return false\n    }\n    for i, kv1 := range o1.kvs {\n        kv2 := o2.kvs[i]\n        if kv1.k != kv2.k {\n            return false\n        }\n        if !valueEqual(kv1.v, kv2.v) {\n            return false\n        }\n    }\n    return true\n}\n\nfunc arrayEqual(a1, a2 []*Value) bool {\n    if len(a1) != len(a2) {\n        return false\n    }\n    for i, v1 := range a1 {\n        if !valueEqual(v1, a2[i]) {\n            return false\n        }\n    }\n    return true\n}",
    "65fc2fe3ed6e0aadf459c8a6722c7911": "package fastjson\n\nimport (\n    \"reflect\"\n    \"testing\"\n)\n\nfunc TestCache_getValue(t *testing.T) {\n    c := &cache{\n        vs: []Value{\n            {t: TypeObject},\n            {t: TypeString, s: \"value1\"},\n            {t: TypeNumber, s: \"42\"},\n        },\n    }\n\n    v := c.getValue()\n    if v.t != TypeString || v.s != \"value1\" {\n        t.Errorf(\"unexpected value: %v\", v)\n    }\n\n    if len(c.vs) != 3 {\n        t.Errorf(\"unexpected length of c.vs: %d\", len(c.vs))\n    }\n\n    if cap(c.vs) != 3 {\n        t.Errorf(\"unexpected capacity of c.vs: %d\", cap(c.vs))\n    }\n\n    // Test the case where the slice capacity is exceeded\n    for i := 0; i < 10; i++ {\n        c.getValue()\n    }\n\n    if len(c.vs) != 12 {\n        t.Errorf(\"unexpected length of c.vs: %d\", len(c.vs))\n    }\n\n    if cap(c.vs) != 12 {\n        t.Errorf(\"unexpected capacity of c.vs: %d\", cap(c.vs))\n    }\n\n    // Validate the returned value\n    v = c.getValue()\n    if v.t != TypeString || v.s != \"value1\" {\n        t.Errorf(\"unexpected value: %v\", v)\n    }\n}",
    "6731289aaef77b8400d83d46dbc76417": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestHasSpecialChars(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname:     \"Valid string\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"String with double quote\",\n\t\t\tinput:    \"hello, \\\"world\\\"\",\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"String with backslash\",\n\t\t\tinput:    \"hello, world\\\\\",\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"String with control character\",\n\t\t\tinput:    \"hello\\x01, world\",\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := hasSpecialChars(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"hasSpecialChars(%q) = %v, want %v\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "668a856045bb7eb8bad1930a3275cef9": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Single escape character\",\n\t\t\tinput:    \"hello\\\\world\",\n\t\t\texpected: \"hello\\\\world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Multiple escape characters\",\n\t\t\tinput:    \"hello\\\\\\\"world\\\\/\\\\b\\\\f\\\\n\\\\r\\\\t\",\n\t\t\texpected: \"hello\\\"world/\\b\\f\\n\\r\\t\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Unicode escape character\",\n\t\t\tinput:    \"hello\\\\u00A0world\",\n\t\t\texpected: \"hello\\u00A0world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid Unicode escape character\",\n\t\t\tinput:    \"hello\\\\u123world\",\n\t\t\texpected: \"hello\\\\u123world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Surrogate pair\",\n\t\t\tinput:    \"hello\\\\uD83D\\\\uDE00world\",\n\t\t\texpected: \"helloüòÄworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid surrogate pair\",\n\t\t\tinput:    \"hello\\\\uD83D\\\\uDEworld\",\n\t\t\texpected: \"hello\\\\uD83D\\\\uDEworld\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "6804e2a188450095521d19251089a3cd": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"no escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"simple escape characters\",\n\t\t\tinput:    \"hello\\\\\\\"world\\\\\\\\\",\n\t\t\texpected: \"hello\\\"world\\\\\",\n\t\t},\n\t\t{\n\t\t\tname:     \"unicode escape characters\",\n\t\t\tinput:    \"hello\\\\u0123world\\\\u4567\",\n\t\t\texpected: \"hello\\u0123world\\u4567\",\n\t\t},\n\t\t{\n\t\t\tname:     \"surrogate pairs\",\n\t\t\tinput:    \"hello\\\\ud83d\\\\ude00world\",\n\t\t\texpected: \"helloüòÄworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid escape characters\",\n\t\t\tinput:    \"hello\\\\xyzworld\",\n\t\t\texpected: \"hello\\\\xyzworld\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "682443aef2bd906bc6223297b5892cb3": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tinput string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname: \"No escape characters\",\n\t\t\tinput: \"hello world\",\n\t\t\texpected: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"Simple escape characters\",\n\t\t\tinput: \"hello\\\\\\\"world\\\\\\\\\",\n\t\t\texpected: \"hello\\\"world\\\\\",\n\t\t},\n\t\t{\n\t\t\tname: \"Escape Unicode characters\",\n\t\t\tinput: \"hello\\\\u0123world\",\n\t\t\texpected: \"hello\\u0123world\",\n\t\t},\n\t\t{\n\t\t\tname: \"Escape surrogate pairs\",\n\t\t\tinput: \"hello\\\\ud83d\\\\ude00world\",\n\t\t\texpected: \"helloüòÄworld\",\n\t\t},\n\t\t{\n\t\t\tname: \"Invalid escape sequence\",\n\t\t\tinput: \"hello\\\\xworld\",\n\t\t\texpected: \"hello\\\\xworld\",\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(test.input)\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", test.input, result, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "687b07e488e0a192515ad3f89d12c2ca": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"no escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"basic escape characters\",\n\t\t\tinput:    \"hello, \\\\\\\"world\\\\\\\"\",\n\t\t\texpected: \"hello, \\\"world\\\"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"complex escape characters\",\n\t\t\tinput:    \"hello, \\\\u0041\\\\u0042\\\\u0043\",\n\t\t\texpected: \"hello, ABC\",\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid escape characters\",\n\t\t\tinput:    \"hello, \\\\x\",\n\t\t\texpected: \"hello, \\\\x\",\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple escape characters\",\n\t\t\tinput:    \"hello, \\\\\\\"world\\\\\\\" \\\\u0041\\\\u0042\\\\u0043\",\n\t\t\texpected: \"hello, \\\"world\\\" ABC\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "6548e1529105cef09542af737bec500c": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"too deep\",\n\t\t\tinput:    \"{}\", // Assuming MaxDepth is set to 1\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t},\n\t\t{\n\t\t\tname:     \"valid object\",\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{t: TypeObject, o: Object{kvs: []kv{{\"key\", &Value{t: typeRawString, s: \"value\"}}}}},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}, &Value{t: TypeNumber, s: \"2\"}, &Value{t: TypeNumber, s: \"3\"}}},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{t: typeRawString, s: \"hello\"},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid true\",\n\t\t\tinput:    `true`,\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid false\",\n\t\t\tinput:    `false`,\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid null\",\n\t\t\tinput:    `null`,\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    `42`,\n\t\t\texpected: &Value{t: TypeNumber, s: \"42\"},\n\t\t\terr:      nil,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) returned unexpected error: %v\", tc.input, err)\n\t\t\t\t} else if err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) returned error %v, expected %v\", tc.input, err, tc.err)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif tc.err != nil {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) returned %v, expected error: %v\", tc.input, actual, tc.err)\n\t\t\t\t} else if !valuesEqual(actual, tc.expected) {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) returned %v, expected %v\", tc.input, actual, tc.expected)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc valuesEqual(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn objectsEqual(v1.o, v2.o)\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !valuesEqual(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase typeRawString, TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeTrue, TypeFalse, TypeNull:\n\t\treturn true\n\tdefault:\n\t\tpanic(fmt.Sprintf(\"unknown type: %d\", v1.t))\n\t}\n}\n\nfunc objectsEqual(o1, o2 Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i := range o1.kvs {\n\t\tif o1.kvs[i].k != o2.kvs[i].k {\n\t\t\treturn false\n\t\t}\n\t\tif !valuesEqual(o1.kvs[i].v, o2.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "68808cd021a8ac028c0531f9704bfc29": "package fastjson\n\nimport (\n    \"testing\"\n)\n\nfunc TestObject_getKV(t *testing.T) {\n    tests := []struct {\n        name string\n        o    *Object\n        want *kv\n    }{\n        {\n            name: \"empty kvs\",\n            o:    &Object{kvs: []kv{}},\n            want: &kv{k: \"\", v: nil},\n        },\n        {\n            name: \"kvs with capacity\",\n            o: &Object{\n                kvs: make([]kv, 0, 2),\n            },\n            want: &kv{k: \"\", v: nil},\n        },\n        {\n            name: \"kvs with length\",\n            o: &Object{\n                kvs: make([]kv, 1, 2),\n            },\n            want: &kv{k: \"\", v: nil},\n        },\n    }\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            if got := tt.o.getKV(); !sameKV(got, tt.want) {\n                t.Errorf(\"Object.getKV() = %v, want %v\", got, tt.want)\n            }\n        })\n    }\n}\n\nfunc sameKV(a, b *kv) bool {\n    if a == nil || b == nil {\n        return a == b\n    }\n    return a.k == b.k && a.v == b.v\n}",
    "667c7903ac2f443de1f8b57d78b53346": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\t// Test cases\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty input\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"exceed max depth\",\n\t\t\tinput:    \"{}\", // Nested JSON\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t},\n\t\t{\n\t\t\tname:     \"parse object\",\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{t: typeRawString, s: \"value\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"parse array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"parse string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{t: typeRawString, s: \"hello\"},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"parse true\",\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"parse false\",\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"parse null\",\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"parse number\",\n\t\t\tinput:    \"42\",\n\t\t\texpected: &Value{t: TypeNumber, s: \"42\"},\n\t\t\terr:      nil,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tv, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, expected %v\", tc.input, err, tc.err)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif !tc.expected.Equal(v) {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) returned %v, expected %v\", tc.input, v, tc.expected)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}",
    "691a36d7ea06c6aa770c81bab56634b6": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"Hello, world!\",\n\t\t\texpected: \"Hello, world!\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Simple escape characters\",\n\t\t\tinput:    \"Hello, \\\\\\\"world\\\\\\\"!\",\n\t\t\texpected: \"Hello, \\\"world\\\"!\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Complex escape characters\",\n\t\t\tinput:    \"Hello, \\\\\\\"world\\\\\\\"\\\\\\\\\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0123\\\\u3456\",\n\t\t\texpected: \"Hello, \\\"world\\\"\\\\b\\f\\n\\r\\t\\u0123\\u3456\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Incomplete escape characters\",\n\t\t\tinput:    \"Hello, \\\\\\\"world\\\\\\\"\\\\u012\",\n\t\t\texpected: \"Hello, \\\"world\\\"\\\\u012\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid escape characters\",\n\t\t\tinput:    \"Hello, \\\\\\\"world\\\\\\\"\\\\x\",\n\t\t\texpected: \"Hello, \\\"world\\\"\\\\x\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Surrogate pairs\",\n\t\t\tinput:    \"Hello, \\\\uD834\\\\uDD1E\",\n\t\t\texpected: \"Hello, ùîû\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Incomplete surrogate pairs\",\n\t\t\tinput:    \"Hello, \\\\uD834\",\n\t\t\texpected: \"Hello, \\\\uD834\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "69e14af1a1cf177e765068338ea97f04": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestBool(t *testing.T) {\n\tcases := []struct {\n\t\tname     string\n\t\tv        *Value\n\t\texpected bool\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\texpected: true,\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\texpected: false,\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname: \"non-bool\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeString,\n\t\t\t},\n\t\t\texpected: false,\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tb, err := tc.v.Bool()\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"Bool() error = %v, wantErr %v\", err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif b != tc.expected {\n\t\t\t\tt.Errorf(\"Bool() = %v, want %v\", b, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "67b025a3b6f0c6ae2fda197859e96ab1": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantVal  *Value\n\t\twantTail string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"empty input\",\n\t\t\tinput:    \"\",\n\t\t\twantVal:  nil,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"max depth exceeded\",\n\t\t\tinput:    \"{\\\"key\\\":{\\\"key\\\":{\\\"key\\\":{\\\"key\\\":\\\"value\\\"}}}}\",\n\t\t\twantVal:  nil,\n\t\t\twantTail: \"{\\\"key\\\":{\\\"key\\\":{\\\"key\\\":{\\\"key\\\":\\\"value\\\"}}}}\",\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"parse object\",\n\t\t\tinput:    `{\"key\":\"value\",\"array\":[1,2,3]}`,\n\t\t\twantVal:  &Value{t: TypeObject},\n\t\t\twantTail: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"parse array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\twantVal:  &Value{t: TypeArray},\n\t\t\twantTail: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"parse string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\twantVal:  &Value{t: typeRawString, s: \"hello\"},\n\t\t\twantTail: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"parse true\",\n\t\t\tinput:    `true`,\n\t\t\twantVal:  valueTrue,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"parse false\",\n\t\t\tinput:    `false`,\n\t\t\twantVal:  valueFalse,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"parse null\",\n\t\t\tinput:    `null`,\n\t\t\twantVal:  valueNull,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"parse number\",\n\t\t\tinput:    `42`,\n\t\t\twantVal:  &Value{t: TypeNumber, s: \"42\"},\n\t\t\twantTail: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotVal, gotTail, gotErr := parseValue(tt.input, c, 0)\n\t\t\tif (gotErr != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", gotErr, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !compareValues(gotVal, tt.wantVal) {\n\t\t\t\tt.Errorf(\"parseValue() gotVal = %v, want %v\", gotVal, tt.wantVal)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseValue() gotTail = %v, want %v\", gotTail, tt.wantTail)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(got, want *Value) bool {\n\tif got == nil || want == nil {\n\t\treturn got == want\n\t}\n\tif got.t != want.t {\n\t\treturn false\n\t}\n\tswitch got.t {\n\tcase TypeObject:\n\t\treturn true // can't compare objects\n\tcase TypeArray:\n\t\tif len(got.a) != len(want.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range got.a {\n\t\t\tif !compareValues(got.a[i], want.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase typeRawString, TypeNumber:\n\t\treturn got.s == want.s\n\tcase TypeTrue, TypeFalse, TypeNull:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}",
    "6aca4cb03aca002182ddf53b78161961": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestHasSpecialChars(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"string with double quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with backslash\",\n\t\t\targs: args{\n\t\t\t\ts: `hello\\\\world`,\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with control character\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello\\nworld\",\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with no special characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello world\",\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := hasSpecialChars(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"hasSpecialChars(%q) = %v, want %v\", tt.args.s, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "68fecac4233379e0ee0add4e25802abc": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:  \"Empty array\",\n\t\t\tinput: \"[]\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"Array with single value\",\n\t\t\tinput: \"[1]\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"Array with multiple values\",\n\t\t\tinput: \"[1, 2, 3]\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"Array with missing closing bracket\",\n\t\t\tinput: \"[1, 2, 3\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"missing ']'\"),\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, _, err := parseArray(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseArray(%q) returned error %v, expected %v\", tc.input, err, tc.err)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\t\tt.Errorf(\"parseArray(%q) returned %v, expected %v\", tc.input, actual, tc.expected)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn false // not implemented\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !compareValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeTrue, TypeFalse, TypeNull:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}",
    "6978245fc46d5f25aaf2c8cac4473f73": "package fastjson\n\nimport (\n    \"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n    testCases := []struct {\n        name     string\n        input    string\n        expected string\n        wantErr  bool\n    }{\n        {\n            name:     \"valid number\",\n            input:    \"12.34\",\n            expected: \"12.34\",\n            wantErr:  false,\n        },\n        {\n            name:     \"number with exponent\",\n            input:    \"1.2e3\",\n            expected: \"1.2e3\",\n            wantErr:  false,\n        },\n        {\n            name:     \"number with leading zero\",\n            input:    \"012.34\",\n            expected: \"012.34\",\n            wantErr:  false,\n        },\n        {\n            name:     \"number with sign\",\n            input:    \"-12.34\",\n            expected: \"-12.34\",\n            wantErr:  false,\n        },\n        {\n            name:     \"number with leading/trailing whitespace\",\n            input:    \"   12.34   \",\n            expected: \"12.34\",\n            wantErr:  false,\n        },\n        {\n            name:     \"invalid number with non-digit character\",\n            input:    \"12.3a4\",\n            expected: \"\",\n            wantErr:  true,\n        },\n        {\n            name:     \"invalid number with too short 'inf/nan'\",\n            input:    \"in\",\n            expected: \"\",\n            wantErr:  true,\n        },\n        {\n            name:     \"valid 'inf'\",\n            input:    \"inf\",\n            expected: \"inf\",\n            wantErr:  false,\n        },\n        {\n            name:     \"valid 'nan'\",\n            input:    \"nan\",\n            expected: \"nan\",\n            wantErr:  false,\n        },\n    }\n\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            result, _, err := parseRawNumber(tc.input)\n            if (err != nil) != tc.wantErr {\n                t.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n                return\n            }\n            if result != tc.expected {\n                t.Errorf(\"parseRawNumber(%q) = %q, want %q\", tc.input, result, tc.expected)\n            }\n        })\n    }\n}",
    "6d3a5822e00fab03ff2f1d46789bc3de": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantKey  string\n\t\twantRest string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\twantKey:  \"hello\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello \\\"world\\\"\"`,\n\t\t\twantKey:  `hello \"world\"`,\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing closing quote\",\n\t\t\tinput:    `\"hello`,\n\t\t\twantKey:  \"\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    `\"\"`,\n\t\t\twantKey:  \"\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with trailing content\",\n\t\t\tinput:    `\"hello\" world`,\n\t\t\twantKey:  \"hello\",\n\t\t\twantRest: \" world\",\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tkey, rest, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif key != tc.wantKey {\n\t\t\t\tt.Errorf(\"parseRawString(%q) key = %q, want %q\", tc.input, key, tc.wantKey)\n\t\t\t}\n\t\t\tif rest != tc.wantRest {\n\t\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, want %q\", tc.input, rest, tc.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "6b82b35fcceba03b7e2a861d1ca8a1bc": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"too deep JSON\",\n\t\t\tinput:    \"{\\\"a\\\":{\\\"b\\\":{\\\"c\\\":{}}}}\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t},\n\t\t{\n\t\t\tname:     \"valid object\",\n\t\t\tinput:    `{\"a\":1,\"b\":true,\"c\":\"str\"}`,\n\t\t\texpected: &Value{t: TypeObject},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{t: TypeArray},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{t: typeRawString, s: \"hello\"},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid true\",\n\t\t\tinput:    `true`,\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid false\",\n\t\t\tinput:    `false`,\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid null\",\n\t\t\tinput:    `null`,\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    `123.456`,\n\t\t\texpected: &Value{t: TypeNumber, s: \"123.456\"},\n\t\t\terr:      nil,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, expected %v\", tc.input, err, tc.err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif tc.err != nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = nil, expected %v\", tc.input, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif tc.expected.t != actual.t {\n\t\t\t\tt.Errorf(\"parseValue(%q) type = %v, expected %v\", tc.input, actual.t, tc.expected.t)\n\t\t\t}\n\n\t\t\tif tc.expected.s != actual.s {\n\t\t\t\tt.Errorf(\"parseValue(%q) value = %v, expected %v\", tc.input, actual.s, tc.expected.s)\n\t\t\t}\n\t\t})\n\t}\n}",
    "6d42cc491bb7931af5168fb29d450757": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantNum  string\n\t\twantRest string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.45e+6\",\n\t\t\twantNum:  \"123.45e+6\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with leading whitespace\",\n\t\t\tinput:    \"  123.45\",\n\t\t\twantNum:  \"123.45\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with trailing whitespace\",\n\t\t\tinput:    \"123.45  \",\n\t\t\twantNum:  \"123.45\",\n\t\t\twantRest: \"  \",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number\",\n\t\t\tinput:    \"abc\",\n\t\t\twantNum:  \"\",\n\t\t\twantRest: \"abc\",\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with special values\",\n\t\t\tinput:    \"inf\",\n\t\t\twantNum:  \"inf\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with special values (nan)\",\n\t\t\tinput:    \"nan\",\n\t\t\twantNum:  \"nan\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNum, gotRest, err := parseRawNumber(tt.input)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNum != tt.wantNum {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNum = %v, want %v\", gotNum, tt.wantNum)\n\t\t\t}\n\t\t\tif gotRest != tt.wantRest {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotRest = %v, want %v\", gotRest, tt.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "6d5a8b1708e96dcfd891f4e6f778b2eb": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.456e+78\",\n\t\t\texpected: []string{\"123.456e+78\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with negative sign\",\n\t\t\tinput:    \"-123.456e-78\",\n\t\t\texpected: []string{\"-123.456e-78\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with plus sign\",\n\t\t\tinput:    \"+123.456e+78\",\n\t\t\texpected: []string{\"+123.456e+78\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with inf\",\n\t\t\tinput:    \"inf\",\n\t\t\texpected: []string{\"\", \"inf\"},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with nan\",\n\t\t\tinput:    \"nan\",\n\t\t\texpected: []string{\"\", \"nan\"},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with non-numeric character\",\n\t\t\tinput:    \"123abc\",\n\t\t\texpected: []string{\"123\", \"abc\"},\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.expected[0] || rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = (%q, %q), expected (%q, %q)\", tc.input, num, rest, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "6b4af14a43e831b21c655ba7bacce0d5": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttype fields struct {\n\t\to Object\n\t\ta []*Value\n\t\ts string\n\t\tt Type\n\t}\n\ttype args struct {\n\t\tdst []byte\n\t}\n\ttests := []struct {\n\t\tname   string\n\t\tfields fields\n\t\targs   args\n\t\twant   []byte\n\t}{\n\t\t{\n\t\t\tname: \"Marshal raw string\",\n\t\t\tfields: fields{\n\t\t\t\ts: \"hello\",\n\t\t\t\tt: typeRawString,\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tdst: make([]byte, 0, 10),\n\t\t\t},\n\t\t\twant: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal object\",\n\t\t\tfields: fields{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{s: \"value1\", t: TypeString}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{s: \"value2\", t: TypeString}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tdst: make([]byte, 0, 50),\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":\"value1\",\"key2\":\"value2\"}`),\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal array\",\n\t\t\tfields: fields{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"value1\", t: TypeString},\n\t\t\t\t\t{s: \"value2\", t: TypeString},\n\t\t\t\t\t{s: \"value3\", t: TypeString},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tdst: make([]byte, 0, 50),\n\t\t\t},\n\t\t\twant: []byte(`[\"value1\",\"value2\",\"value3\"]`),\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal string\",\n\t\t\tfields: fields{\n\t\t\t\ts: \"hello\",\n\t\t\t\tt: TypeString,\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tdst: make([]byte, 0, 10),\n\t\t\t},\n\t\t\twant: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal number\",\n\t\t\tfields: fields{\n\t\t\t\ts: \"42\",\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tdst: make([]byte, 0, 5),\n\t\t\t},\n\t\t\twant: []byte(\"42\"),\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal true\",\n\t\t\tfields: fields{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tdst: make([]byte, 0, 5),\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal false\",\n\t\t\tfields: fields{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tdst: make([]byte, 0, 6),\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal null\",\n\t\t\tfields: fields{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tdst: make([]byte, 0, 4),\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv := &Value{\n\t\t\t\to: tt.fields.o,\n\t\t\t\ta: tt.fields.a,\n\t\t\t\ts: tt.fields.s,\n\t\t\t\tt: tt.fields.t,\n\t\t\t}\n\t\t\tif got := v.MarshalTo(tt.args.dst); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "6e33d0d62a23a8721caad8b3e9af809d": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\targs string\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: \"\",\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no leading whitespace\",\n\t\t\targs: \"hello\",\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading space\",\n\t\t\targs: \" hello\",\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading newline\",\n\t\t\targs: \"\\nhello\",\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading tab\",\n\t\t\targs: \"\\thello\",\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading carriage return\",\n\t\t\targs: \"\\rhello\",\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"all whitespace\",\n\t\t\targs: \"   \\n\\t\\r\",\n\t\t\twant: \"\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.args); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "6da65682ce259312ae9b4cdb1e73416a": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\thasError bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.456e+7\",\n\t\t\texpected: []string{\"123.456e+7\", \"\"},\n\t\t\thasError: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with leading zeros\",\n\t\t\tinput:    \"00123.456\",\n\t\t\texpected: []string{\"00123.456\", \"\"},\n\t\t\thasError: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with sign\",\n\t\t\tinput:    \"-123.456\",\n\t\t\texpected: []string{\"-123.456\", \"\"},\n\t\t\thasError: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with invalid character\",\n\t\t\tinput:    \"123.456a\",\n\t\t\texpected: []string{\"\", \"a\"},\n\t\t\thasError: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\thasError: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with leading non-digit\",\n\t\t\tinput:    \"a123.456\",\n\t\t\texpected: []string{\"\", \"a123.456\"},\n\t\t\thasError: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with leading plus sign\",\n\t\t\tinput:    \"+123.456\",\n\t\t\texpected: []string{\"+123.456\", \"\"},\n\t\t\thasError: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with 'inf'\",\n\t\t\tinput:    \"inf\",\n\t\t\texpected: []string{\"inf\", \"\"},\n\t\t\thasError: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with 'nan'\",\n\t\t\tinput:    \"nan\",\n\t\t\texpected: []string{\"nan\", \"\"},\n\t\t\thasError: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.hasError {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, expected error: %t\", tc.input, err, tc.hasError)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif num != tc.expected[0] || rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, %q; expected %q, %q\", tc.input, num, rest, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "6df0d4e5d8c2ff606085628a104b67b6": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"Valid number\",\n\t\t\tinput:    \"123.45e+6\",\n\t\t\texpected: []string{\"123.45e+6\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Number with leading sign\",\n\t\t\tinput:    \"-123.45\",\n\t\t\texpected: []string{\"-123.45\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Number with trailing non-digit\",\n\t\t\tinput:    \"123.45a\",\n\t\t\texpected: []string{\"123.45\", \"a\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid number\",\n\t\t\tinput:    \"123.45.6\",\n\t\t\texpected: []string{\"\", \"123.45.6\"},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Infinity and NaN\",\n\t\t\tinput:    \"inf\",\n\t\t\texpected: []string{\"inf\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Infinity and NaN with trailing characters\",\n\t\t\tinput:    \"infabc\",\n\t\t\texpected: []string{\"inf\", \"abc\"},\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif num != tc.expected[0] || rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, %q; expected %q, %q\", tc.input, num, rest, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "6e8502e4888bb33c5d31d62ffdb69b41": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"Hello, world!\",\n\t\t\texpected: \"Hello, world!\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Single escape character\",\n\t\t\tinput:    \"Hello, \\\\world!\",\n\t\t\texpected: \"Hello, world!\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Multiple escape characters\",\n\t\t\tinput:    \"Hello, \\\\w\\\\o\\\\r\\\\l\\\\d!\",\n\t\t\texpected: \"Hello, world!\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escaped special characters\",\n\t\t\tinput:    \"Hello, \\\\\\\"\\\\\\\\\\\\n\\\\r\\\\t\\\\f\\\\b\\\\u0123\\\\u00A9world!\",\n\t\t\texpected: \"Hello, \\\"\\\\'\\n\\r\\t\\f\\b\\u0123¬©world!\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Incomplete escape sequence\",\n\t\t\tinput:    \"Hello, \\\\u1234world!\",\n\t\t\texpected: \"Hello, \\\\u1234world!\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid escape sequence\",\n\t\t\tinput:    \"Hello, \\\\xworld!\",\n\t\t\texpected: \"Hello, \\\\xworld!\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Surrogate pair escape sequence\",\n\t\t\tinput:    \"Hello, \\\\uD83D\\\\uDE00world!\",\n\t\t\texpected: \"Hello, üòÄworld!\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Incomplete surrogate pair escape sequence\",\n\t\t\tinput:    \"Hello, \\\\uD83Dworld!\",\n\t\t\texpected: \"Hello, \\\\uD83Dworld!\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "6f19aa110e6aa422ecee615bd3adb1ca": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"no escape characters\",\n\t\t\tinput:    \"hello world\",\n\t\t\texpected: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"simple escape characters\",\n\t\t\tinput:    \"hello\\\\n\\\\t\\\\\\\"world\",\n\t\t\texpected: \"hello\\n\\t\\\"world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"unicode escape characters\",\n\t\t\tinput:    \"hello\\\\u0041\\\\u0052\\\\u0043\\\\u0048world\",\n\t\t\texpected: \"helloARCHworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"surrogate pair escape characters\",\n\t\t\tinput:    \"hello\\\\ud83d\\\\ude00world\",\n\t\t\texpected: \"helloüòÄworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid unicode escape characters\",\n\t\t\tinput:    \"hello\\\\u123world\",\n\t\t\texpected: \"hello\\\\u123world\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "6f51b309595c1399dbabe55956e4e70a": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected1, expected2 string\n\t\texpectedErr error\n\t}{\n\t\t{\n\t\t\tname:       \"Simple string\",\n\t\t\tinput:      `\"hello, world\"`,\n\t\t\texpected1:  \"hello, world\",\n\t\t\texpected2:  \"\",\n\t\t\texpectedErr: nil,\n\t\t},\n\t\t{\n\t\t\tname:       \"String with escaped quotes\",\n\t\t\tinput:      `\"hello, \\\"world\\\"\"`,\n\t\t\texpected1:  \"hello, \\\"world\\\"\",\n\t\t\texpected2:  \"\",\n\t\t\texpectedErr: nil,\n\t\t},\n\t\t{\n\t\t\tname:       \"String without closing quote\",\n\t\t\tinput:      `\"hello, world`,\n\t\t\texpected1:  \"\",\n\t\t\texpected2:  \"\",\n\t\t\texpectedErr: ErrMissingClosingQuote,\n\t\t},\n\t\t{\n\t\t\tname:       \"Empty string\",\n\t\t\tinput:      `\"\"`,\n\t\t\texpected1:  \"\",\n\t\t\texpected2:  \"\",\n\t\t\texpectedErr: nil,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual1, actual2, err := parseRawString(tc.input)\n\t\t\tif err != tc.expectedErr {\n\t\t\t\tt.Errorf(\"expected error %v, got %v\", tc.expectedErr, err)\n\t\t\t}\n\t\t\tif actual1 != tc.expected1 {\n\t\t\t\tt.Errorf(\"expected first result %q, got %q\", tc.expected1, actual1)\n\t\t\t}\n\t\t\tif actual2 != tc.expected2 {\n\t\t\t\tt.Errorf(\"expected second result %q, got %q\", tc.expected2, actual2)\n\t\t\t}\n\t\t})\n\t}\n}",
    "706865992798e2e97cf456a24af456c3": "package fastjson\n\nimport (\n    \"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n    testCases := []struct {\n        name     string\n        input    string\n        expected string\n    }{\n        {\n            name:     \"No escape sequences\",\n            input:    \"hello, world\",\n            expected: \"hello, world\",\n        },\n        {\n            name:     \"Simple escape sequences\",\n            input:    \"hello\\\\\\\" \\\\/ \\\\b \\\\f \\\\n \\\\r \\\\t\",\n            expected: \"hello\\\" / \\b \\f \\n \\r \\t\",\n        },\n        {\n            name:     \"Unicode escape sequences\",\n            input:    \"\\\\u0041\\\\u0042\\\\u0043\",\n            expected: \"ABC\",\n        },\n        {\n            name:     \"Surrogate pair\",\n            input:    \"\\\\ud83d\\\\ude00\",\n            expected: \"üòÄ\",\n        },\n        {\n            name:     \"Invalid escape sequence\",\n            input:    \"\\\\u123\",\n            expected: \"\\\\u123\",\n        },\n    }\n\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            result := unescapeStringBestEffort(tc.input)\n            if result != tc.expected {\n                t.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", tc.input, result, tc.expected)\n            }\n        })\n    }\n}",
    "6fab218b3923aaaeb15f025f2a5a7e40": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantKey  string\n\t\twantData string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello, world\"`,\n\t\t\twantKey:  \"hello, world\",\n\t\t\twantData: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello, \\\"world\\\"\"`,\n\t\t\twantKey:  `hello, \"world\"`,\n\t\t\twantData: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with no closing quote\",\n\t\t\tinput:    `\"hello, world`,\n\t\t\twantKey:  \"\",\n\t\t\twantData: \"\",\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    `\"\"`,\n\t\t\twantKey:  \"\",\n\t\t\twantData: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tkey, data, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif key != tc.wantKey {\n\t\t\t\tt.Errorf(\"parseRawString(%q) key = %q, want %q\", tc.input, key, tc.wantKey)\n\t\t\t}\n\t\t\tif data != tc.wantData {\n\t\t\t\tt.Errorf(\"parseRawString(%q) data = %q, want %q\", tc.input, data, tc.wantData)\n\t\t\t}\n\t\t})\n\t}\n}",
    "706e5a0147669f36804cbc0a3f095f5e": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tin   string\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"no escape characters\",\n\t\t\tin:   \"hello world\",\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"single escape character\",\n\t\t\tin:   \"hello\\\\world\",\n\t\t\twant: \"helloworld\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape characters\",\n\t\t\tin:   \"hello\\\\\\\"world\\\\\\\\\",\n\t\t\twant: \"hello\\\"world\\\\\",\n\t\t},\n\t\t{\n\t\t\tname: \"unicode escape character\",\n\t\t\tin:   \"hello\\\\u0123world\",\n\t\t\twant: \"hello\\u0123world\",\n\t\t},\n\t\t{\n\t\t\tname: \"surrogate pair escape character\",\n\t\t\tin:   \"hello\\\\ud83d\\\\ude00world\",\n\t\t\twant: \"helloüòÄworld\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape character\",\n\t\t\tin:   \"hello\\\\xworld\",\n\t\t\twant: \"hello\\\\xworld\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := unescapeStringBestEffort(tt.in)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", tt.in, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "6f44ad38d1750d682e4dc5ccc8c22331": "package fastjson\n\nimport (\n    \"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n    testCases := []struct {\n        name     string\n        input    string\n        expected *Value\n        err      bool\n    }{\n        {\n            name:  \"valid object\",\n            input: `{\"key1\":\"value1\",\"key2\":123}`,\n            expected: func() *Value {\n                o := &Value{\n                    t: TypeObject,\n                    o: Object{\n                        kvs: []kv{\n                            {k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n                            {k: \"key2\", v: &Value{t: TypeNumber, s: \"123\"}},\n                        },\n                    },\n                }\n                return o\n            }(),\n            err: false,\n        },\n        {\n            name:  \"empty object\",\n            input: \"{}\",\n            expected: func() *Value {\n                o := &Value{\n                    t: TypeObject,\n                    o: Object{},\n                }\n                return o\n            }(),\n            err: false,\n        },\n        {\n            name:  \"missing closing brace\",\n            input: `{\"key1\":\"value1\",\"key2\":123`,\n            expected: nil,\n            err:      true,\n        },\n        {\n            name:  \"missing colon\",\n            input: `{\"key1\":\"value1\",\"key2\" 123}`,\n            expected: nil,\n            err:      true,\n        },\n        {\n            name:  \"missing comma\",\n            input: `{\"key1\":\"value1\" \"key2\":123}`,\n            expected: nil,\n            err:      true,\n        },\n    }\n\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            c := &cache{}\n            actual, _, err := parseObject(tc.input, c, 0)\n            if (err != nil) != tc.err {\n                t.Errorf(\"parseObject(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n                return\n            }\n\n            if !equalValues(actual, tc.expected) {\n                t.Errorf(\"parseObject(%q) = %v, want %v\", tc.input, actual, tc.expected)\n            }\n        })\n    }\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n    if v1 == nil || v2 == nil {\n        return v1 == v2\n    }\n\n    if v1.t != v2.t {\n        return false\n    }\n\n    switch v1.t {\n    case TypeObject:\n        return equalObjects(&v1.o, &v2.o)\n    case TypeArray:\n        return equalArrays(v1.a, v2.a)\n    case TypeString:\n        return v1.s == v2.s\n    case TypeNumber, TypeTrue, TypeFalse:\n        return v1.s == v2.s\n    default:\n        return true\n    }\n}\n\nfunc equalObjects(o1, o2 *Object) bool {\n    if len(o1.kvs) != len(o2.kvs) {\n        return false\n    }\n\n    for i := range o1.kvs {\n        if o1.kvs[i].k != o2.kvs[i].k {\n            return false\n        }\n        if !equalValues(o1.kvs[i].v, o2.kvs[i].v) {\n            return false\n        }\n    }\n\n    return true\n}\n\nfunc equalArrays(a1, a2 []*Value) bool {\n    if len(a1) != len(a2) {\n        return false\n    }\n\n    for i := range a1 {\n        if !equalValues(a1[i], a2[i]) {\n            return false\n        }\n    }\n\n    return true\n}",
    "6db00f06325b618d849dc56822ae75ec": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\tdepth    int\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\tdepth:    0,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"too big depth\",\n\t\t\tinput:    \"{}\", // Any valid JSON input would work\n\t\t\texpected: nil,\n\t\t\tdepth:    MaxDepth + 1,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t},\n\t\t{\n\t\t\tname:     \"valid object\",\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\texpected: &Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: &Value{t: typeRawString, s: \"value\"}}}}},\n\t\t\tdepth:    0,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid array\",\n\t\t\tinput:    `[\"item1\", \"item2\"]`,\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{{t: typeRawString, s: \"item1\"}, {t: typeRawString, s: \"item2\"}}},\n\t\t\tdepth:    0,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{t: typeRawString, s: \"hello\"},\n\t\t\tdepth:    0,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid true\",\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\tdepth:    0,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid false\",\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\tdepth:    0,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid null\",\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\tdepth:    0,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.45\",\n\t\t\texpected: &Value{t: TypeNumber, s: \"123.45\"},\n\t\t\tdepth:    0,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid value\",\n\t\t\tinput:    \"invalid\",\n\t\t\texpected: nil,\n\t\t\tdepth:    0,\n\t\t\terr:      fmt.Errorf(\"unexpected value found: %q\", \"invalid\"),\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tv, _, err := parseValue(tc.input, c, tc.depth)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil {\n\t\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t\t} else if err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"error mismatch: got %v, want %v\", err, tc.err)\n\t\t\t\t}\n\t\t\t} else if tc.err != nil {\n\t\t\t\tt.Errorf(\"expected error: %v, got nil\", tc.err)\n\t\t\t} else if !equalValues(v, tc.expected) {\n\t\t\t\tt.Errorf(\"value mismatch: got %+v, want %+v\", v, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn equalObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase typeRawString, TypeNumber, TypeTrue, TypeFalse:\n\t\treturn v1.s == v2.s\n\tcase TypeNull:\n\t\treturn true\n\tdefault:\n\t\tpanic(fmt.Errorf(\"unknown type: %d\", v1.t))\n\t}\n}\n\nfunc equalObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i := range o1.kvs {\n\t\tif o1.kvs[i].k != o2.kvs[i].k {\n\t\t\treturn false\n\t\t}\n\t\tif !equalValues(o1.kvs[i].v, o2.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "71635dd415056a10080843df1cfc642f": "package fastjson\n\nimport (\n    \"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n    tests := []struct {\n        name string\n        input string\n        want string\n    }{\n        {\n            name: \"empty string\",\n            input: \"\",\n            want: \"\",\n        },\n        {\n            name: \"no whitespace\",\n            input: \"abc\",\n            want: \"abc\",\n        },\n        {\n            name: \"leading whitespace\",\n            input: \"   abc\",\n            want: \"abc\",\n        },\n        {\n            name: \"leading and trailing whitespace\",\n            input: \"   abc   \",\n            want: \"abc   \",\n        },\n        {\n            name: \"all whitespace\",\n            input: \"   \\t\\n\\r\",\n            want: \"\",\n        },\n    }\n\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            if got := skipWSSlow(tt.input); got != tt.want {\n                t.Errorf(\"skipWSSlow(%q) = %q, want %q\", tt.input, got, tt.want)\n            }\n        })\n    }\n}",
    "7058efd0c56b597cc2d9223ff1700ad9": "package fastjson\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n)\n\nfunc TestVisit(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\tjson string\n\t\twant [][]byte\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\tjson: \"{}\",\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"single key-value pair\",\n\t\t\tjson: `{\"key\":\"value\"}`,\n\t\t\twant: [][]byte{[]byte(\"key\"), []byte(\"value\")},\n\t\t},\n\t\t{\n\t\t\tname: \"multiple key-value pairs\",\n\t\t\tjson: `{\"key1\":\"value1\",\"key2\":true,\"key3\":123}`,\n\t\t\twant: [][]byte{[]byte(\"key1\"), []byte(\"value1\"), []byte(\"key2\"), []byte(\"true\"), []byte(\"key3\"), []byte(\"123\")},\n\t\t},\n\t\t{\n\t\t\tname: \"nested object\",\n\t\t\tjson: `{\"key1\":{\"subkey1\":\"subvalue1\",\"subkey2\":false},\"key2\":null}`,\n\t\t\twant: [][]byte{[]byte(\"key1\"), []byte(\"subkey1\"), []byte(\"subvalue1\"), []byte(\"subkey2\"), []byte(\"false\"), []byte(\"key2\"), []byte(\"null\")},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tvar keys, values [][]byte\n\t\t\tv, err := ParseBytes([]byte(tc.json))\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"ParseBytes(%q) failed: %v\", tc.json, err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\to := v.Object()\n\t\t\to.Visit(func(key []byte, value *Value) {\n\t\t\t\tkeys = append(keys, key)\n\t\t\t\tvalues = append(values, value.StringBytes())\n\t\t\t})\n\n\t\t\tif len(keys) != len(tc.want) {\n\t\t\t\tt.Errorf(\"Visit returned %d keys, want %d\", len(keys), len(tc.want))\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tfor i, want := range tc.want {\n\t\t\t\tif !bytes.Equal(keys[i], want) {\n\t\t\t\t\tt.Errorf(\"Visit returned key %q, want %q\", keys[i], want)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}",
    "70a38a44496c23ee87fb465becf29b01": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tv      *Value\n\t\twantDst []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello, world!\",\n\t\t\t},\n\t\t\twantDst: []byte(`\"hello, world!\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantDst: []byte(`{\"key1\":\"value1\",\"key2\":42}`),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"hello\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t\t{t: TypeFalse},\n\t\t\t\t\t{t: TypeNull},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantDst: []byte(`[\"hello\",42,true,false,null]`),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello, world!\",\n\t\t\t},\n\t\t\twantDst: []byte(`\"hello, world!\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42\",\n\t\t\t},\n\t\t\twantDst: []byte(\"42\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twantDst: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twantDst: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twantDst: []byte(\"null\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotDst := tt.v.MarshalTo(nil)\n\t\t\tif !reflect.DeepEqual(gotDst, tt.wantDst) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", gotDst, tt.wantDst)\n\t\t\t}\n\t\t})\n\t}\n}",
    "7230092514433d8801df7477caa09618": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantKey  string\n\t\twantRest string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple key\",\n\t\t\tinput:    `\"key\":value`,\n\t\t\twantKey:  \"key\",\n\t\t\twantRest: \":value\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"key with escape sequence\",\n\t\t\tinput:    `\"key\\\"with\\\"escape\":value`,\n\t\t\twantKey:  \"key\\\"with\\\"escape\",\n\t\t\twantRest: \":value\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing closing quote\",\n\t\t\tinput:    `\"key without closing quote`,\n\t\t\twantKey:  `\"key without closing quote`,\n\t\t\twantRest: \"\",\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty input\",\n\t\t\tinput:    ``,\n\t\t\twantKey:  ``,\n\t\t\twantRest: ``,\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tkey, rest, err := parseRawKey(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawKey(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif key != tc.wantKey {\n\t\t\t\tt.Errorf(\"parseRawKey(%q) key = %q, want %q\", tc.input, key, tc.wantKey)\n\t\t\t}\n\t\t\tif rest != tc.wantRest {\n\t\t\t\tt.Errorf(\"parseRawKey(%q) rest = %q, want %q\", tc.input, rest, tc.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "6fd24ebeaee11084b0c385bb63aecac6": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"empty array\",\n\t\t\tinput:    \"[]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with single value\",\n\t\t\tinput:    \"[123]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"123\"}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with multiple values\",\n\t\t\tinput:    \"[123, \\\"foo\\\", true]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"123\"}, &Value{t: TypeString, s: \"foo\"}, &Value{t: TypeTrue}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:  \"missing closing bracket\",\n\t\t\tinput: \"[123, \\\"foo\\\", true\",\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"missing comma\",\n\t\t\tinput: \"[123 \\\"foo\\\", true]\",\n\t\t\terr:   true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{vs: make([]Value, 0, 100)}\n\t\t\tgot, _, err := parseArray(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseArray(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !equalValues(got, tc.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", tc.input, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeNull, TypeTrue, TypeFalse:\n\t\treturn true\n\tcase TypeNumber, TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeObject:\n\t\treturn equalObjects(v1.o, v2.o)\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\tpanic(\"unreachable\")\n\t}\n}\n\nfunc equalObjects(o1, o2 Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i := range o1.kvs {\n\t\tif o1.kvs[i].k != o2.kvs[i].k || !equalValues(o1.kvs[i].v, o2.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "73e81573c1097aa5d3bc8873077efe2d": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    string\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"no escape characters\",\n\t\t\ts:    \"hello world\",\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"simple escape characters\",\n\t\t\ts:    \"hello\\\\\\\"world\\\\\\\\\",\n\t\t\twant: \"hello\\\"world\\\\\",\n\t\t},\n\t\t{\n\t\t\tname: \"complex escape characters\",\n\t\t\ts:    \"hello\\\\u0123\\\\u4567\\\\u89ab\\\\ucdef\\\\U00012345world\",\n\t\t\twant: \"hello\\u0123\\u4567\\u89ab\\ucdef\\U00012345world\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape characters\",\n\t\t\ts:    \"hello\\\\x12world\",\n\t\t\twant: \"hello\\\\x12world\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", tt.s, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "74d7cae76125b8d48ca978cf0f627552": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\targs string\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: \"\",\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no leading/trailing whitespace\",\n\t\t\targs: \"hello\",\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace\",\n\t\t\targs: \" hello\",\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailing whitespace\",\n\t\t\targs: \"hello \",\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading and trailing whitespace\",\n\t\t\targs: \" hello \",\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"mixed whitespace\",\n\t\t\targs: \"  \\t\\n\\r hello \\t\\n\\r\",\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"all whitespace\",\n\t\t\targs: \"   \\t\\n\\r\",\n\t\t\twant: \"\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.args); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow(%q) = %q, want %q\", tt.args, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "7401629604b0f70bcbc19d96baaedff5": "package fastjson\n\nimport (\n    \"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n    testCases := []struct {\n        name     string\n        input    string\n        expected string\n    }{\n        {\n            name:     \"No escape characters\",\n            input:    \"hello, world\",\n            expected: \"hello, world\",\n        },\n        {\n            name:     \"Escaped characters\",\n            input:    \"hello\\\\\\\"world\\\\\\\\\",\n            expected: \"hello\\\"world\\\\\",\n        },\n        {\n            name:     \"Partial escape sequence\",\n            input:    \"hello\\\\u123world\",\n            expected: \"hello\\\\u123world\",\n        },\n        {\n            name:     \"Valid escape sequence\",\n            input:    \"hello\\\\u0064world\",\n            expected: \"hellodworld\",\n        },\n        {\n            name:     \"Surrogate pair\",\n            input:    \"hello\\\\ud83d\\\\ude00world\",\n            expected: \"helloüòÄworld\",\n        },\n        {\n            name:     \"Invalid surrogate pair\",\n            input:    \"hello\\\\ud83dworld\",\n            expected: \"hello\\\\ud83dworld\",\n        },\n    }\n\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            result := unescapeStringBestEffort(tc.input)\n            if result != tc.expected {\n                t.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n            }\n        })\n    }\n}",
    "73637f7e1e8efbc7668ced1b35bb1c13": "package fastjson\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: &Value{\n\t\t\t\ts: \"hello\",\n\t\t\t\tt: typeRawString,\n\t\t\t},\n\t\t\twant: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{s: \"value1\", t: TypeString}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{s: \"value2\", t: TypeString}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":\"value1\",\"key2\":\"value2\"}`),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"value1\", t: TypeString},\n\t\t\t\t\t{s: \"value2\", t: TypeString},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\twant: []byte(`[\"value1\",\"value2\"]`),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: &Value{\n\t\t\t\ts: \"hello\",\n\t\t\t\tt: TypeString,\n\t\t\t},\n\t\t\twant: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: &Value{\n\t\t\t\ts: \"42\",\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\twant: []byte(\"42\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := make([]byte, 0, 64)\n\t\t\tgot := tt.v.MarshalTo(dst)\n\t\t\tif !bytes.Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %q, want %q\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "728d133d01cc468ecfd0317cc4c69179": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"valid JSON\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{s: \"value1\", t: TypeString}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{s: \"42\", t: TypeNumber}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"invalid JSON\",\n\t\t\tinput: `{\"key1\":\"value1\"`,\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty input\",\n\t\t\tinput:    \"\",\n\t\t\texpected: &Value{},\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tp := &Parser{}\n\t\t\tv, err := p.Parse(tc.input)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif err == nil && !v.Equal(tc.expected) {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tc.expected, v)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc (v *Value) Equal(other *Value) bool {\n\tif v.t != other.t {\n\t\treturn false\n\t}\n\n\tswitch v.t {\n\tcase TypeObject:\n\t\treturn v.o.Equal(&other.o)\n\tcase TypeArray:\n\t\tif len(v.a) != len(other.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, vv := range v.a {\n\t\t\tif !vv.Equal(other.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeString:\n\t\treturn v.s == other.s\n\tcase TypeNumber:\n\t\treturn v.s == other.s\n\tcase TypeTrue, TypeFalse, TypeNull:\n\t\treturn true\n\tdefault:\n\t\tpanic(\"unsupported type\")\n\t}\n}\n\nfunc (o *Object) Equal(other *Object) bool {\n\tif len(o.kvs) != len(other.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv := range o.kvs {\n\t\tif kv.k != other.kvs[i].k || !kv.v.Equal(other.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "724994c4227fea1f6874c6180fbf74e8": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"simple object\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{s: \"value1\", t: TypeString}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{s: \"42\", t: TypeNumber}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with whitespace\",\n\t\t\tinput: `{ \"key1\" : \"value1\", \"key2\" : 42 }`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{s: \"value1\", t: TypeString}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{s: \"42\", t: TypeNumber}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing key\",\n\t\t\tinput: `{\"key1\":\"value1\",:\"value2\"}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing value\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: `{}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tactual, _, err := parseObject(test.input, c, 0)\n\t\t\tif (err != nil) != test.err {\n\t\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %t\", test.input, err, test.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !objectEqual(actual, test.expected) {\n\t\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", test.input, actual, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc objectEqual(a, b *Value) bool {\n\tif a == nil && b == nil {\n\t\treturn true\n\t}\n\tif a == nil || b == nil {\n\t\treturn false\n\t}\n\tif a.t != b.t {\n\t\treturn false\n\t}\n\tif a.t != TypeObject {\n\t\treturn false\n\t}\n\tif len(a.o.kvs) != len(b.o.kvs) {\n\t\treturn false\n\t}\n\tfor i, kva := range a.o.kvs {\n\t\tkvb := b.o.kvs[i]\n\t\tif kva.k != kvb.k {\n\t\t\treturn false\n\t\t}\n\t\tif !valueEqual(kva.v, kvb.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc valueEqual(a, b *Value) bool {\n\tif a == nil && b == nil {\n\t\treturn true\n\t}\n\tif a == nil || b == nil {\n\t\treturn false\n\t}\n\tif a.t != b.t {\n\t\treturn false\n\t}\n\tswitch a.t {\n\tcase TypeObject:\n\t\treturn objectEqual(a, b)\n\tcase TypeArray:\n\t\tif len(a.a) != len(b.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, va := range a.a {\n\t\t\tif !valueEqual(va, b.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeString:\n\t\treturn a.s == b.s\n\tcase TypeNumber:\n\t\treturn a.s == b.s\n\tcase TypeTrue, TypeFalse, TypeNull:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}",
    "75777daeca0c7bd8df52b21d1b780eff": "package fastjson\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n)\n\nfunc TestMarshalTo(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\texpected []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello, world\",\n\t\t\t},\n\t\t\texpected: []byte(`\"hello, world\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: []byte(`{\"key1\":\"value1\",\"key2\":42}`),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"item1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: []byte(`[\"item1\",42,true]`),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello, world\",\n\t\t\t},\n\t\t\texpected: []byte(`\"hello, world\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42\",\n\t\t\t},\n\t\t\texpected: []byte(\"42\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"true\",\n\t\t\tvalue:    &Value{t: TypeTrue},\n\t\t\texpected: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"false\",\n\t\t\tvalue:    &Value{t: TypeFalse},\n\t\t\texpected: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"null\",\n\t\t\tvalue:    &Value{t: TypeNull},\n\t\t\texpected: []byte(\"null\"),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdst := make([]byte, 0, len(tc.expected))\n\t\t\tresult := tc.value.MarshalTo(dst)\n\t\t\tif !bytes.Equal(result, tc.expected) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %q, expected %q\", result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "76c88dee15d18184fd5aae3fde728d6e": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantKey  string\n\t\twantVal  string\n\t\twantErr  bool\n\t\twantErrMsg string\n\t}{\n\t\t{\n\t\t\tname:    \"simple string\",\n\t\t\tinput:   `\"hello\"`,\n\t\t\twantKey: \"hello\",\n\t\t\twantVal: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"string with escaped quote\",\n\t\t\tinput:   `\"hello\\\"world\"`,\n\t\t\twantKey: `hello\"world`,\n\t\t\twantVal: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with missing closing quote\",\n\t\t\tinput:    `\"hello`,\n\t\t\twantKey:  \"\",\n\t\t\twantVal:  \"\",\n\t\t\twantErr:  true,\n\t\t\twantErrMsg: `missing closing '\"'`,\n\t\t},\n\t\t{\n\t\t\tname:    \"empty string\",\n\t\t\tinput:   `\"\"`,\n\t\t\twantKey: \"\",\n\t\t\twantVal: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tkey, val, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err != nil && err.Error() != tc.wantErrMsg {\n\t\t\t\tt.Errorf(\"parseRawString(%q) error message = %v, want %v\", tc.input, err.Error(), tc.wantErrMsg)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif key != tc.wantKey {\n\t\t\t\tt.Errorf(\"parseRawString(%q) key = %v, want %v\", tc.input, key, tc.wantKey)\n\t\t\t}\n\t\t\tif val != tc.wantVal {\n\t\t\t\tt.Errorf(\"parseRawString(%q) value = %v, want %v\", tc.input, val, tc.wantVal)\n\t\t\t}\n\t\t})\n\t}\n}",
    "7687ecf07cfcfde6c5776872c4fb9d33": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantVal  *Value\n\t\twantTail string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:    \"empty string\",\n\t\t\tinput:   \"\",\n\t\t\twantVal: nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"too big depth\",\n\t\t\tinput:   \"{}\", // Assuming MaxDepth is 1\n\t\t\twantVal: nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"valid object\",\n\t\t\tinput:   `{\"key\":\"value\"}`,\n\t\t\twantVal: &Value{t: TypeObject, o: Object{kvs: []kv{{\"key\", &Value{t: typeRawString, s: \"value\"}}}}},\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"valid array\",\n\t\t\tinput:   `[1,2,3]`,\n\t\t\twantVal: &Value{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t}},\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"valid string\",\n\t\t\tinput:   `\"hello\"`,\n\t\t\twantVal: &Value{t: typeRawString, s: \"hello\"},\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"valid true\",\n\t\t\tinput:   `true`,\n\t\t\twantVal: valueTrue,\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"valid false\",\n\t\t\tinput:   `false`,\n\t\t\twantVal: valueFalse,\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"valid null\",\n\t\t\tinput:   `null`,\n\t\t\twantVal: valueNull,\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"valid number\",\n\t\t\tinput:   `42`,\n\t\t\twantVal: &Value{t: TypeNumber, s: \"42\"},\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotVal, gotTail, err := parseValue(tt.input, c, 0)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(gotVal, tt.wantVal) {\n\t\t\t\tt.Errorf(\"parseValue() gotVal = %v, want %v\", gotVal, tt.wantVal)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseValue() gotTail = %v, want %v\", gotTail, tt.wantTail)\n\t\t\t}\n\t\t})\n\t}\n}",
    "753a7a1e99cdb1733921791f2452aeb5": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty array\",\n\t\t\tinput: \"[]\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{}\n\t\t\t\tv.t = TypeArray\n\t\t\t\tv.a = []*Value{}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with one element\",\n\t\t\tinput: \"[1]\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{}\n\t\t\t\tv.t = TypeArray\n\t\t\t\tv.a = []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with multiple elements\",\n\t\t\tinput: \"[1,2,3]\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{}\n\t\t\t\tv.t = TypeArray\n\t\t\t\tv.a = []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with whitespace\",\n\t\t\tinput: \"[ 1 , 2 , 3 ]\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{}\n\t\t\t\tv.t = TypeArray\n\t\t\t\tv.a = []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"missing closing bracket\",\n\t\t\tinput: \"[1,2,3\",\n\t\t\terr:   true,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseArray(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseArray(%q) returned error %v, expected error: %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !equalValues(got, tc.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) returned %v, expected %v\", tc.input, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn true // TODO: implement object comparison\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeTrue, TypeFalse, TypeNull:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}",
    "77bce0e6590e4b18937b930f84c13ca1": "package fastjson\n\nimport (\n    \"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n    testCases := []struct {\n        name     string\n        input    string\n        expected []string\n        err      bool\n    }{\n        {\n            name:     \"simple string\",\n            input:    `\"hello\"`,\n            expected: []string{\"hello\", \"\"},\n            err:      false,\n        },\n        {\n            name:     \"string with escaped quote\",\n            input:    `\"hello\\\"world\"`,\n            expected: []string{\"hello\\\"world\", \"\"},\n            err:      false,\n        },\n        {\n            name:     \"string with multiple escaped quotes\",\n            input:    `\"hello\\\"world\\\"foo\"`,\n            expected: []string{\"hello\\\"world\\\"foo\", \"\"},\n            err:      false,\n        },\n        {\n            name:     \"missing closing quote\",\n            input:    `\"hello`,\n            expected: []string{},\n            err:      true,\n        },\n    }\n\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            str, rest, err := parseRawString(tc.input)\n            if (err != nil) != tc.err {\n                t.Errorf(\"parseRawString(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n                return\n            }\n            if str != tc.expected[0] || rest != tc.expected[1] {\n                t.Errorf(\"parseRawString(%q) = %q, %q, want %q, %q\", tc.input, str, rest, tc.expected[0], tc.expected[1])\n            }\n        })\n    }\n}",
    "73e9cfe5e08926c7976321a2a9cd9a45": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"max depth exceeded\",\n\t\t\tinput:    \"{}\", // Assuming MaxDepth is set to 1\n\t\t\texpected: nil,\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid object\",\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{t: TypeObject, o: Object{kvs: []kv{{\"key\", &Value{t: typeRawString, s: \"value\"}}}}},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}, &Value{t: TypeNumber, s: \"2\"}, &Value{t: TypeNumber, s: \"3\"}}},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{t: typeRawString, s: \"hello\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid true\",\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid false\",\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid null\",\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"42\",\n\t\t\texpected: &Value{t: TypeNumber, s: \"42\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid value\",\n\t\t\tinput:    \"invalid\",\n\t\t\texpected: nil,\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseValue(tt.input, c, 0)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !equalValue(got, tt.expected) {\n\t\t\t\tt.Errorf(\"parseValue() = %v, want %v\", got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValue(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\to1, _ := v1.Object()\n\t\to2, _ := v2.Object()\n\t\tif len(o1.kvs) != len(o2.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, kv1 := range o1.kvs {\n\t\t\tkv2 := o2.kvs[i]\n\t\t\tif kv1.k != kv2.k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValue(kv1.v, kv2.v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\tcase TypeArray:\n\t\ta1, _ := v1.Array()\n\t\ta2, _ := v2.Array()\n\t\tif len(a1) != len(a2) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, v1 := range a1 {\n\t\t\tif !equalValue(v1, a2[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\tcase typeRawString, TypeNumber, TypeTrue, TypeFalse, TypeNull:\n\t\treturn v1.s == v2.s\n\t}\n\treturn true\n}",
    "782108c696836cbdae2916bc481df792": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"empty array\",\n\t\t\tinput:    \"[]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{}},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with values\",\n\t\t\tinput:    \"[1, true, \\\"hello\\\"]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t{t: TypeTrue},\n\t\t\t\t{t: TypeString, s: \"hello\"},\n\t\t\t}},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"missing closing bracket\",\n\t\t\tinput:   \"[1, 2, 3\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"missing comma after value\",\n\t\t\tinput:   \"[1 2]\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseArray(test.input, c, 0)\n\t\t\tif (err != nil) != test.wantErr {\n\t\t\t\tt.Errorf(\"parseArray(%q) error = %v, wantErr %v\", test.input, err, test.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, test.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", test.input, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "798be09ae942c932c643af314a791107": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"hello world\",\n\t\t\texpected: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Simple escape characters\",\n\t\t\tinput:    \"Hello \\\\\\\"world\\\\\\\"\",\n\t\t\texpected: `Hello \"world\"`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Complex escape characters\",\n\t\t\tinput:    \"Hello \\\\u00A9 world \\\\u0009 \\\\r\\\\n\",\n\t\t\texpected: \"Hello ¬© world \\t \\r\\n\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Incomplete escape sequence\",\n\t\t\tinput:    \"Hello \\\\u123 world\",\n\t\t\texpected: \"Hello \\\\u123 world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Surrogate pair\",\n\t\t\tinput:    \"Hello \\\\uD83D\\\\uDE00 world\",\n\t\t\texpected: \"Hello üòÄ world\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "786947ac52c4718b1416b399695b5978": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tinput   string\n\t\twant    *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty array\",\n\t\t\tinput: \"[]\",\n\t\t\twant: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with values\",\n\t\t\tinput: `[1, \"foo\", true]`,\n\t\t\twant: func() *Value {\n\t\t\t\tv1 := &Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"1\",\n\t\t\t\t}\n\t\t\t\tv2 := &Value{\n\t\t\t\t\tt: TypeString,\n\t\t\t\t\ts: \"foo\",\n\t\t\t\t}\n\t\t\t\tv3 := &Value{\n\t\t\t\t\tt: TypeTrue,\n\t\t\t\t}\n\t\t\t\treturn &Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{v1, v2, v3},\n\t\t\t\t}\n\t\t\t}(),\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with missing closing bracket\",\n\t\t\tinput: \"[1, 2, 3\",\n\t\t\twant:  nil,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tgot, _, err := parseArray(tt.input, c, 0)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr && !got.Equal(tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "76f5fd995e906a4073d48604a7268b3e": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tinput   string\n\t\twantVal *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty string\",\n\t\t\tinput: \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"max depth exceeded\",\n\t\t\tinput: \"{}\", // Simulate max depth by nesting heavily\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"valid object\",\n\t\t\tinput: `{\"key\":\"value\"}`,\n\t\t\twantVal: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: typeRawString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"valid array\",\n\t\t\tinput: `[1,2,3]`,\n\t\t\twantVal: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"valid string\",\n\t\t\tinput: `\"hello\"`,\n\t\t\twantVal: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"valid true\",\n\t\t\tinput: \"true\",\n\t\t\twantVal: valueTrue,\n\t\t},\n\t\t{\n\t\t\tname:  \"valid false\",\n\t\t\tinput: \"false\",\n\t\t\twantVal: valueFalse,\n\t\t},\n\t\t{\n\t\t\tname:  \"valid null\",\n\t\t\tinput: \"null\",\n\t\t\twantVal: valueNull,\n\t\t},\n\t\t{\n\t\t\tname:  \"valid number\",\n\t\t\tinput: \"42\",\n\t\t\twantVal: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42\",\n\t\t\t},\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotVal, _, err := parseValue(tt.input, c, 0)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !equalValues(gotVal, tt.wantVal) {\n\t\t\t\tt.Errorf(\"parseValue() = %v, want %v\", gotVal, tt.wantVal)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn equalObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn equalArrays(v1.a, v2.a)\n\tcase typeRawString, TypeNumber, TypeTrue, TypeFalse:\n\t\treturn v1.s == v2.s\n\tcase TypeNull:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc equalObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !equalValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc equalArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tif !equalValues(v1, a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "7b0eb03b9c3c5c2a59058e32333f3f39": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"Valid key without escape sequences\",\n\t\t\tinput:    `\"key\":`,\n\t\t\texpected: []string{\"key\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Key with escape sequence\",\n\t\t\tinput:    `\"key\\n\":`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Missing closing quote\",\n\t\t\tinput:    `\"key`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tkey, rest, err := parseRawKey(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawKey() error = %v, wantErr %v\", err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif key != tc.expected[0] || rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawKey() got (%v, %v), want (%v, %v)\", key, rest, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "7ae139e99d6004412db527f5cec86730": "package fastjson_test\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantKey  string\n\t\twantRest string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple key\",\n\t\t\tinput:    `\"key\":value`,\n\t\t\twantKey:  \"key\",\n\t\t\twantRest: \":value\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"key with escape sequence\",\n\t\t\tinput:    `\"ke\\\"y\":value`,\n\t\t\twantKey:  \"\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing closing quote\",\n\t\t\tinput:    `\"key:value`,\n\t\t\twantKey:  \"\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    `\"\"`,\n\t\t\twantKey:  \"\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tkey, rest, err := parseRawKey(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawKey(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif key != tc.wantKey {\n\t\t\t\tt.Errorf(\"parseRawKey(%q) key = %q, want %q\", tc.input, key, tc.wantKey)\n\t\t\t}\n\t\t\tif rest != tc.wantRest {\n\t\t\t\tt.Errorf(\"parseRawKey(%q) rest = %q, want %q\", tc.input, rest, tc.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc parseRawKey(s string) (string, string, error) {\n\t// Implementation omitted\n\tpanic(fmt.Errorf(\"not implemented\"))\n}",
    "7be990ce79cb1a8b124a128d9ab3387a": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantText string\n\t\twantRest string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello world\"`,\n\t\t\twantText: \"hello world\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quotes\",\n\t\t\tinput:    `\"hello \\\"world\\\"\"`,\n\t\t\twantText: `hello \"world\"`,\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with missing closing quote\",\n\t\t\tinput:    `\"hello world`,\n\t\t\twantText: \"\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    `\"\"`,\n\t\t\twantText: \"\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\ttext, rest, err := parseRawString(tt.input)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif text != tt.wantText {\n\t\t\t\tt.Errorf(\"parseRawString() text = %v, want %v\", text, tt.wantText)\n\t\t\t}\n\t\t\tif rest != tt.wantRest {\n\t\t\t\tt.Errorf(\"parseRawString() rest = %v, want %v\", rest, tt.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "79d8078e796dcbcc4dd823f358ec52aa": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty array\",\n\t\t\tinput: \"[]\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{t: TypeArray}\n\t\t\t\tv.a = make([]*Value, 1)\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"single value array\",\n\t\t\tinput: \"[1]\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{t: TypeArray}\n\t\t\t\tv.a = make([]*Value, 1)\n\t\t\t\tv.a[0] = &Value{t: TypeNumber, s: \"1\"}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"multiple value array\",\n\t\t\tinput: \"[1,2,3]\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{t: TypeArray}\n\t\t\t\tv.a = make([]*Value, 3)\n\t\t\t\tv.a[0] = &Value{t: TypeNumber, s: \"1\"}\n\t\t\t\tv.a[1] = &Value{t: TypeNumber, s: \"2\"}\n\t\t\t\tv.a[2] = &Value{t: TypeNumber, s: \"3\"}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with missing closing bracket\",\n\t\t\tinput: \"[1,2,3\",\n\t\t\terr:   true,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, _, err := parseArray(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseArray(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !compareValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeTrue, TypeFalse, TypeNull:\n\t\treturn true\n\tcase TypeObject:\n\t\treturn compareObjects(v1.o, v2.o)\n\tdefault:\n\t\tpanic(\"unknown type\")\n\t}\n\treturn true\n}\n\nfunc compareObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i := range o1.kvs {\n\t\tif o1.kvs[i].k != o2.kvs[i].k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(o1.kvs[i].v, o2.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "7dad3b1c46ec53aac2f667a5953c1862": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"Hello, world!\",\n\t\t\texpected: \"Hello, world!\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Basic escape characters\",\n\t\t\tinput:    \"Hello, \\\\\\\"world\\\\\\\"!\",\n\t\t\texpected: \"Hello, \\\"world\\\"!\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Unicode escape characters\",\n\t\t\tinput:    \"Hello, \\\\u2764 \\\\uD83D\\\\uDE0A!\",\n\t\t\texpected: \"Hello, ‚ù§ üòä!\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Incomplete Unicode escape character\",\n\t\t\tinput:    \"Hello, \\\\u123!\",\n\t\t\texpected: \"Hello, \\\\u123!\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Unknown escape character\",\n\t\t\tinput:    \"Hello, \\\\x!\",\n\t\t\texpected: \"Hello, \\\\x!\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "7ca549d288828fbe5328bbd86e0db62a": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantKey  string\n\t\twantRest string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"no quotes\",\n\t\t\tinput:    \"abcd\",\n\t\t\twantKey:  \"abcd\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\twantKey:  \"hello\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"he\\\"llo\"`,\n\t\t\twantKey:  `he\"llo`,\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing closing quote\",\n\t\t\tinput:    `\"hello`,\n\t\t\twantKey:  \"\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    `\"\"`,\n\t\t\twantKey:  \"\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tkey, rest, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif key != tc.wantKey {\n\t\t\t\tt.Errorf(\"parseRawString(%q) key = %q, want %q\", tc.input, key, tc.wantKey)\n\t\t\t}\n\t\t\tif rest != tc.wantRest {\n\t\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, want %q\", tc.input, rest, tc.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "7dcd4b2020590e522e3b8a940cc501f3": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"Empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"String without leading whitespace\",\n\t\t\tinput:    \"hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"String with leading whitespace\",\n\t\t\tinput:    \"  hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"String with leading and trailing whitespace\",\n\t\t\tinput:    \"  hello   \",\n\t\t\texpected: \"hello   \",\n\t\t},\n\t\t{\n\t\t\tname:     \"String with only whitespace\",\n\t\t\tinput:    \"   \",\n\t\t\texpected: \"\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual := skipWSSlow(tc.input)\n\t\t\tif actual != tc.expected {\n\t\t\t\tt.Errorf(\"skipWSSlow(%q) = %q, want %q\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "7db1f88e3c96395375451e83de16c5b6": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t\trest     string\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.456e+7\",\n\t\t\texpected: \"123.456e+7\",\n\t\t\trest:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with trailing characters\",\n\t\t\tinput:    \"123abc\",\n\t\t\texpected: \"123\",\n\t\t\trest:     \"abc\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number\",\n\t\t\tinput:    \"abc\",\n\t\t\texpected: \"\",\n\t\t\trest:     \"abc\",\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with inf/nan\",\n\t\t\tinput:    \"+inf\",\n\t\t\texpected: \"+inf\",\n\t\t\trest:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, expected error: %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.expected {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) number = %q, expected %q\", tc.input, num, tc.expected)\n\t\t\t}\n\t\t\tif rest != tc.rest {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) rest = %q, expected %q\", tc.input, rest, tc.rest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "7e8e562ef2d27c182d546cf4c9a07086": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestGetArray(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tv      *Value\n\t\tkeys   []string\n\t\texpect []*Value\n\t}{\n\t\t{\n\t\t\tname: \"Existing key path\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"foo\", t: TypeString},\n\t\t\t\t\t{s: \"bar\", t: TypeString},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:   []string{\"0\", \"1\"},\n\t\t\texpect: []*Value{{s: \"foo\", t: TypeString}, {s: \"bar\", t: TypeString}},\n\t\t},\n\t\t{\n\t\t\tname: \"Non-existing key path\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"foo\", v: &Value{s: \"bar\", t: TypeString}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:   []string{\"nonexistent\"},\n\t\t\texpect: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Invalid value type\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"foo\",\n\t\t\t},\n\t\t\tkeys:   []string{\"0\"},\n\t\t\texpect: nil,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.GetArray(tt.keys...)\n\t\t\tif !reflect.DeepEqual(got, tt.expect) {\n\t\t\t\tt.Errorf(\"GetArray(%v) = %v, want %v\", tt.keys, got, tt.expect)\n\t\t\t}\n\t\t})\n\t}\n}",
    "7a92821e0adc82cb85ceea8247358d8a": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tinput   string\n\t\twant    *Value\n\t\twantRem string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: \"{}\",\n\t\t\twant: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantRem: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"simple object\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":123}`,\n\t\t\twant: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantRem: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with nested value\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":{\"nestedKey\":\"nestedValue\"}}`,\n\t\t\twant: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{\n\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t{k: \"nestedKey\", v: &Value{t: TypeString, s: \"nestedValue\"}},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantRem: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with trailing comma\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":123,}`,\n\t\t\twant: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantRem: \",\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing key\",\n\t\t\tinput: `{:123}`,\n\t\t\twant:  nil,\n\t\t\twantRem: \":123}\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tgot, rem, err := parseObject(tt.input, c, 0)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got == nil || tt.want == nil {\n\t\t\t\tif got != tt.want {\n\t\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t\t}\n\t\t\t} else if !got.Equal(tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif rem != tt.wantRem {\n\t\t\t\tt.Errorf(\"parseObject() rem = %q, want %q\", rem, tt.wantRem)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc (v *Value) Equal(other *Value) bool {\n\tif v.t != other.t {\n\t\treturn false\n\t}\n\tswitch v.t {\n\tcase TypeObject:\n\t\treturn v.o.Equal(&other.o)\n\tcase TypeArray:\n\t\treturn v.ArrayEqual(other.a)\n\tcase TypeString:\n\t\treturn v.s == other.s\n\tcase TypeNumber:\n\t\treturn v.s == other.s\n\tcase TypeTrue, TypeFalse, TypeNull:\n\t\treturn true\n\tdefault:\n\t\tpanic(\"unreachable\")\n\t}\n}\n\nfunc (o *Object) Equal(other *Object) bool {\n\tif len(o.kvs) != len(other.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv := range o.kvs {\n\t\tif kv.k != other.kvs[i].k || !kv.v.Equal(other.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn o.keysUnescaped == other.keysUnescaped\n}\n\nfunc (v *Value) ArrayEqual(other []*Value) bool {\n\tif len(v.a) != len(other) {\n\t\treturn false\n\t}\n\tfor i, elem := range v.a {\n\t\tif !elem.Equal(other[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "7f4ba0b171c71cd762dba9c2e617f4ff": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetUint(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tjson     string\n\t\tkeys     []string\n\t\texpected uint\n\t}{\n\t\t{\n\t\t\tname:     \"valid uint\",\n\t\t\tjson:     `{\"num\": 42}`,\n\t\t\tkeys:     []string{\"num\"},\n\t\t\texpected: 42,\n\t\t},\n\t\t{\n\t\t\tname:     \"non-existing key\",\n\t\t\tjson:     `{\"num\": 42}`,\n\t\t\tkeys:     []string{\"invalid\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid value type\",\n\t\t\tjson:     `{\"num\": \"42\"}`,\n\t\t\tkeys:     []string{\"num\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"array index\",\n\t\t\tjson:     `[1, 2, 3]`,\n\t\t\tkeys:     []string{\"1\"},\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"array index out of range\",\n\t\t\tjson:     `[1, 2, 3]`,\n\t\t\tkeys:     []string{\"3\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"array index with float\",\n\t\t\tjson:     `[1, 2, 3]`,\n\t\t\tkeys:     []string{\"1.0\"},\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"nested object\",\n\t\t\tjson:     `{\"obj\": {\"num\": 42}}`,\n\t\t\tkeys:     []string{\"obj\", \"num\"},\n\t\t\texpected: 42,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tv, err := ParseBytes([]byte(tc.json))\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"failed to parse JSON: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tactual := v.GetUint(tc.keys...)\n\t\t\tif actual != tc.expected {\n\t\t\t\tt.Errorf(\"expected %d, got %d\", tc.expected, actual)\n\t\t\t}\n\t\t})\n\t}\n}",
    "7c09caf0ea87aa843bac1becd45191fc": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tinput   string\n\t\twantVal *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty string\",\n\t\t\tinput: \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"depth exceeds MaxDepth\",\n\t\t\tinput: \"{\\\"key\\\":{\\\"key2\\\":{}}}\", // Nested JSON exceeding MaxDepth\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"valid object\",\n\t\t\tinput: `{\"key\":\"value\"}`,\n\t\t\twantVal: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: typeRawString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"valid array\",\n\t\t\tinput: `[1,2,3]`,\n\t\t\twantVal: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"valid string\",\n\t\t\tinput: `\"hello\"`,\n\t\t\twantVal: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"valid true\",\n\t\t\tinput: \"true\",\n\t\t\twantVal: valueTrue,\n\t\t},\n\t\t{\n\t\t\tname:  \"valid false\",\n\t\t\tinput: \"false\",\n\t\t\twantVal: valueFalse,\n\t\t},\n\t\t{\n\t\t\tname:  \"valid null\",\n\t\t\tinput: \"null\",\n\t\t\twantVal: valueNull,\n\t\t},\n\t\t{\n\t\t\tname:  \"valid number\",\n\t\t\tinput: \"123.456\",\n\t\t\twantVal: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseValue(tt.input, &cache{}, 0)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !compareValues(got, tt.wantVal) {\n\t\t\t\tt.Errorf(\"parseValue() = %v, want %v\", got, tt.wantVal)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(a, b *Value) bool {\n\tif a == nil && b == nil {\n\t\treturn true\n\t}\n\tif a == nil || b == nil {\n\t\treturn false\n\t}\n\tif a.t != b.t {\n\t\treturn false\n\t}\n\tswitch a.t {\n\tcase typeRawString:\n\t\treturn a.s == b.s\n\tcase TypeNumber:\n\t\treturn a.s == b.s\n\tcase TypeObject:\n\t\treturn compareObjects(&a.o, &b.o)\n\tcase TypeArray:\n\t\treturn compareArrays(a.a, b.a)\n\tcase TypeTrue, TypeFalse, TypeNull:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc compareObjects(a, b *Object) bool {\n\tif len(a.kvs) != len(b.kvs) {\n\t\treturn false\n\t}\n\tfor i, akv := range a.kvs {\n\t\tbkv := b.kvs[i]\n\t\tif akv.k != bkv.k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(akv.v, bkv.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc compareArrays(a, b []*Value) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i, av := range a {\n\t\tif !compareValues(av, b[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "7dd7034a21a9529c961f608a308225ae": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"valid object\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42`,\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing key\",\n\t\t\tinput: `{:42}`,\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing value\",\n\t\t\tinput: `{\"key1\":}`,\n\t\t\terr:   true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tv, _, err := parseObject(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif tc.expected != nil && !v.Equal(tc.expected) {\n\t\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", tc.input, v, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc (v *Value) Equal(other *Value) bool {\n\tif v.t != other.t {\n\t\treturn false\n\t}\n\n\tswitch v.t {\n\tcase TypeObject:\n\t\treturn v.o.Equal(&other.o)\n\tcase TypeArray:\n\t\tif len(v.a) != len(other.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, vv := range v.a {\n\t\t\tif !vv.Equal(other.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeString:\n\t\treturn v.s == other.s\n\tcase TypeNumber:\n\t\treturn v.s == other.s\n\tcase TypeTrue, TypeFalse, TypeNull:\n\t\treturn true\n\tdefault:\n\t\tpanic(\"unreachable\")\n\t}\n}\n\nfunc (o *Object) Equal(other *Object) bool {\n\tif len(o.kvs) != len(other.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv := range o.kvs {\n\t\tif kv.k != other.kvs[i].k {\n\t\t\treturn false\n\t\t}\n\t\tif !kv.v.Equal(other.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "8177a350d4c4cce2597cc004623711f5": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"no escaped quotes\",\n\t\t\tinput:    `\"hello, world\"`,\n\t\t\texpected: []string{\"hello, world\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"with escaped quotes\",\n\t\t\tinput:    `\"hello, \\\"world\\\"\"`,\n\t\t\texpected: []string{\"hello, \\\"world\\\"\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing closing quote\",\n\t\t\tinput:    `\"hello, world`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    `\"\"`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\ts, r, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif s != tc.expected[0] || r != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawString() = (%q, %q), expected (%q, %q)\", s, r, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "80eb4c1412d255ee46292aae604c32df": "package fastjson_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/valyala/fastjson\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantNum  string\n\t\twantRest string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.456e+78\",\n\t\t\twantNum:  \"123.456e+78\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with trailing non-digit\",\n\t\t\tinput:    \"123.456x\",\n\t\t\twantNum:  \"123.456\",\n\t\t\twantRest: \"x\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with leading non-digit\",\n\t\t\tinput:    \"xfoo123.456\",\n\t\t\twantNum:  \"\",\n\t\t\twantRest: \"xfoo123.456\",\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty input\",\n\t\t\tinput:    \"\",\n\t\t\twantNum:  \"\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"inf\",\n\t\t\tinput:    \"inf123\",\n\t\t\twantNum:  \"inf\",\n\t\t\twantRest: \"123\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"nan\",\n\t\t\tinput:    \"nan123\",\n\t\t\twantNum:  \"nan\",\n\t\t\twantRest: \"123\",\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := fastjson.ParseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"ParseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.wantNum {\n\t\t\t\tt.Errorf(\"ParseRawNumber(%q) num = %q, want %q\", tc.input, num, tc.wantNum)\n\t\t\t}\n\t\t\tif rest != tc.wantRest {\n\t\t\t\tt.Errorf(\"ParseRawNumber(%q) rest = %q, want %q\", tc.input, rest, tc.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "8357f5d24e1cdb9aefc22a135c1b9466": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape sequences\",\n\t\t\tinput:    \"Hello, world!\",\n\t\t\texpected: \"Hello, world!\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Basic escape sequences\",\n\t\t\tinput:    \"Hello, \\\\\\\"world\\\\\\\"!\",\n\t\t\texpected: \"Hello, \\\"world\\\"!\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Unicode escape sequences\",\n\t\t\tinput:    \"Hello, \\\\u0123world\\\\u4567!\",\n\t\t\texpected: \"Hello, \\u0123world\\u4567!\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid Unicode escape sequence\",\n\t\t\tinput:    \"Hello, \\\\uABCDworld!\",\n\t\t\texpected: \"Hello, \\\\uABCDworld!\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Surrogate pair\",\n\t\t\tinput:    \"Hello, \\\\ud83d\\\\ude00world!\",\n\t\t\texpected: \"Hello, üòÄworld!\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid surrogate pair\",\n\t\t\tinput:    \"Hello, \\\\ud83d\\\\uworld!\",\n\t\t\texpected: \"Hello, \\\\ud83d\\\\uworld!\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "813b6cc65bfab253187227574002ee26": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestGet(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    *Value\n\t\tkeys     []string\n\t\texpected *Value\n\t}{\n\t\t{\n\t\t\tname: \"Existing key in object\",\n\t\t\tinput: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: &Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"key2\"},\n\t\t\texpected: &Value{t: TypeNumber, s: \"42\"},\n\t\t},\n\t\t{\n\t\t\tname: \"Non-existing key in object\",\n\t\t\tinput: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: &Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"key3\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Existing index in array\",\n\t\t\tinput: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"value1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"1\"},\n\t\t\texpected: &Value{t: TypeNumber, s: \"42\"},\n\t\t},\n\t\t{\n\t\t\tname: \"Non-existing index in array\",\n\t\t\tinput: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"value1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"2\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Invalid type\",\n\t\t\tinput: &Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"value\",\n\t\t\t},\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: nil,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := tc.input.Get(tc.keys...)\n\t\t\tif !reflect.DeepEqual(got, tc.expected) {\n\t\t\t\tt.Errorf(\"Get(%v) = %v, expected %v\", tc.keys, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "829f3bee55cc6c18e8df104328bf5e2b": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantKey  string\n\t\twantRest string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\twantKey:  \"hello\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello\\\"world\"`,\n\t\t\twantKey:  `hello\"world`,\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello\\\"world\\\"foo\"`,\n\t\t\twantKey:  `hello\"world\"foo`,\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with no closing quote\",\n\t\t\tinput:    `\"hello`,\n\t\t\twantKey:  \"\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tkey, rest, err := parseRawString(tt.input)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString(%q) error = %v, wantErr %v\", tt.input, err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif key != tt.wantKey {\n\t\t\t\tt.Errorf(\"parseRawString(%q) key = %q, want %q\", tt.input, key, tt.wantKey)\n\t\t\t}\n\t\t\tif rest != tt.wantRest {\n\t\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, want %q\", tt.input, rest, tt.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "807d013abe86474680c99a8397c44ef9": "package fastjson\n\nimport (\n    \"testing\"\n)\n\nfunc TestGet(t *testing.T) {\n    tests := []struct {\n        name string\n        v    *Value\n        keys []string\n        want *Value\n    }{\n        {\n            name: \"get from object\",\n            v: &Value{\n                t: TypeObject,\n                o: &Object{\n                    kvs: []kv{\n                        {k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n                        {k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n                    },\n                },\n            },\n            keys: []string{\"key1\"},\n            want: &Value{t: TypeString, s: \"value1\"},\n        },\n        {\n            name: \"get from array\",\n            v: &Value{\n                t: TypeArray,\n                a: []*Value{\n                    {t: TypeString, s: \"value1\"},\n                    {t: TypeNumber, s: \"42\"},\n                },\n            },\n            keys: []string{\"1\"},\n            want: &Value{t: TypeNumber, s: \"42\"},\n        },\n        {\n            name: \"non-existing key\",\n            v: &Value{\n                t: TypeObject,\n                o: &Object{\n                    kvs: []kv{\n                        {k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n                    },\n                },\n            },\n            keys: []string{\"key2\"},\n            want: nil,\n        },\n    }\n\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            if got := tt.v.Get(tt.keys...); !compareValues(got, tt.want) {\n                t.Errorf(\"Get() = %v, want %v\", got, tt.want)\n            }\n        })\n    }\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n    if v1 == nil && v2 == nil {\n        return true\n    }\n    if v1 == nil || v2 == nil {\n        return false\n    }\n    if v1.t != v2.t {\n        return false\n    }\n    switch v1.t {\n    case TypeObject:\n        return compareObjects(v1.o, v2.o)\n    case TypeArray:\n        return compareArrays(v1.a, v2.a)\n    case TypeString:\n        return v1.s == v2.s\n    case TypeNumber:\n        return v1.s == v2.s\n    case TypeTrue, TypeFalse, TypeNull:\n        return true\n    default:\n        return false\n    }\n}\n\nfunc compareObjects(o1, o2 *Object) bool {\n    if len(o1.kvs) != len(o2.kvs) {\n        return false\n    }\n    for i, kv1 := range o1.kvs {\n        kv2 := o2.kvs[i]\n        if kv1.k != kv2.k {\n            return false\n        }\n        if !compareValues(kv1.v, kv2.v) {\n            return false\n        }\n    }\n    return true\n}\n\nfunc compareArrays(a1, a2 []*Value) bool {\n    if len(a1) != len(a2) {\n        return false\n    }\n    for i, v1 := range a1 {\n        if !compareValues(v1, a2[i]) {\n            return false\n        }\n    }\n    return true\n}",
    "7f60f1b39103ded7daa1b75a4ee76a2d": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype testCase struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}\n\n\ttestCases := []testCase{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"object\",\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: &Value{t: typeRawString, s: \"value\"}}}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t}},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{t: typeRawString, s: \"hello\"},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"true\",\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"false\",\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"null\",\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number\",\n\t\t\tinput:    \"123\",\n\t\t\texpected: &Value{t: TypeNumber, s: \"123\"},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"too deep\",\n\t\t\tinput:    \"{}\", // Depth exceeds MaxDepth\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tv, _, err := parseValue(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, expected error: %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !equalValues(v, tc.expected) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, expected %v\", tc.input, v, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\to1, _ := v1.Object()\n\t\to2, _ := v2.Object()\n\t\tif len(o1.kvs) != len(o2.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, kv1 := range o1.kvs {\n\t\t\tkv2 := o2.kvs[i]\n\t\t\tif kv1.k != kv2.k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(kv1.v, kv2.v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeArray:\n\t\ta1, _ := v1.Array()\n\t\ta2, _ := v2.Array()\n\t\tif len(a1) != len(a2) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, v1 := range a1 {\n\t\t\tif !equalValues(v1, a2[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase typeRawString, TypeNumber, TypeTrue, TypeFalse, TypeNull:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\tpanic(\"unexpected type\")\n\t}\n}",
    "846b5a8936b60cdcefab9152a8a78e08": "package fastjson\n\nimport (\n    \"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n    testCases := []struct {\n        name     string\n        input    string\n        expected1, expected2 string\n        expectedErr bool\n    }{\n        {\n            name:  \"valid number\",\n            input: \"123.45e6\",\n            expected1: \"123.45e6\",\n            expected2: \"\",\n            expectedErr: false,\n        },\n        {\n            name:  \"valid number with negative exponent\",\n            input: \"12.34e-5\",\n            expected1: \"12.34e-5\",\n            expected2: \"\",\n            expectedErr: false,\n        },\n        {\n            name:  \"valid integer\",\n            input: \"12345\",\n            expected1: \"12345\",\n            expected2: \"\",\n            expectedErr: false,\n        },\n        {\n            name:  \"valid negative number\",\n            input: \"-12.34\",\n            expected1: \"-12.34\",\n            expected2: \"\",\n            expectedErr: false,\n        },\n        {\n            name:  \"invalid number with non-digit character\",\n            input: \"12a.34\",\n            expected1: \"\",\n            expected2: \"a.34\",\n            expectedErr: true,\n        },\n        {\n            name:  \"invalid number starting with non-digit character\",\n            input: \"a123.45\",\n            expected1: \"\",\n            expected2: \"a123.45\",\n            expectedErr: true,\n        },\n        {\n            name:  \"invalid number with 'inf' suffix\",\n            input: \"12.34inf\",\n            expected1: \"12.34\",\n            expected2: \"inf\",\n            expectedErr: false,\n        },\n        {\n            name:  \"invalid number with 'nan' suffix\",\n            input: \"12.34nan\",\n            expected1: \"12.34\",\n            expected2: \"nan\",\n            expectedErr: false,\n        },\n    }\n\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            num, rest, err := parseRawNumber(tc.input)\n            if (err != nil) != tc.expectedErr {\n                t.Errorf(\"parseRawNumber(%q) error = %v, expectedErr = %v\", tc.input, err, tc.expectedErr)\n                return\n            }\n            if num != tc.expected1 {\n                t.Errorf(\"parseRawNumber(%q) num = %q, expected = %q\", tc.input, num, tc.expected1)\n            }\n            if rest != tc.expected2 {\n                t.Errorf(\"parseRawNumber(%q) rest = %q, expected = %q\", tc.input, rest, tc.expected2)\n            }\n        })\n    }\n}",
    "85860e752a54f3e60b619400d8ea0e22": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantNum  string\n\t\twantRest string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid_integer\",\n\t\t\tinput:    \"123\",\n\t\t\twantNum:  \"123\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid_float\",\n\t\t\tinput:    \"3.14\",\n\t\t\twantNum:  \"3.14\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid_exponential\",\n\t\t\tinput:    \"1.23e4\",\n\t\t\twantNum:  \"1.23e4\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid_start\",\n\t\t\tinput:    \"abc123\",\n\t\t\twantNum:  \"\",\n\t\t\twantRest: \"abc123\",\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid_end\",\n\t\t\tinput:    \"123abc\",\n\t\t\twantNum:  \"123\",\n\t\t\twantRest: \"abc\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"inf\",\n\t\t\tinput:    \"inf\",\n\t\t\twantNum:  \"inf\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"nan\",\n\t\t\tinput:    \"nan\",\n\t\t\twantNum:  \"nan\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.wantNum {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) num = %q, want %q\", tc.input, num, tc.wantNum)\n\t\t\t}\n\t\t\tif rest != tc.wantRest {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) rest = %q, want %q\", tc.input, rest, tc.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "867153df9b6a69ea618b77a3fc27945c": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantNum  string\n\t\twantRest string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid_number\",\n\t\t\tinput:    \"123.45e+6\",\n\t\t\twantNum:  \"123.45e+6\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number_with_inf\",\n\t\t\tinput:    \"inf\",\n\t\t\twantNum:  \"inf\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number_with_nan\",\n\t\t\tinput:    \"nan\",\n\t\t\twantNum:  \"nan\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number_with_invalid_char\",\n\t\t\tinput:    \"-123a\",\n\t\t\twantNum:  \"\",\n\t\t\twantRest: \"-123a\",\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty_string\",\n\t\t\tinput:    \"\",\n\t\t\twantNum:  \"\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.wantNum {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) num = %q, want %q\", tc.input, num, tc.wantNum)\n\t\t\t}\n\t\t\tif rest != tc.wantRest {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) rest = %q, want %q\", tc.input, rest, tc.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "871e93cc734c52c098de30486d1c84ef": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetFloat64(t *testing.T) {\n\ttestCases := []struct {\n\t\tname   string\n\t\tvalue  *Value\n\t\tkeys   []string\n\t\texpect float64\n\t}{\n\t\t{\n\t\t\tname:   \"Valid float64 value\",\n\t\t\tvalue:  &Value{s: \"3.14\", t: TypeNumber},\n\t\t\tkeys:   []string{},\n\t\t\texpect: 3.14,\n\t\t},\n\t\t{\n\t\t\tname:   \"Non-existing keys\",\n\t\t\tvalue:  &Value{s: \"3.14\", t: TypeNumber},\n\t\t\tkeys:   []string{\"foo\", \"bar\"},\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"Invalid value type\",\n\t\t\tvalue:  &Value{s: \"true\", t: TypeTrue},\n\t\t\tkeys:   []string{},\n\t\t\texpect: 0,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := tc.value.GetFloat64(tc.keys...)\n\t\t\tif result != tc.expect {\n\t\t\t\tt.Errorf(\"GetFloat64(%v) = %f, want %f\", tc.keys, result, tc.expect)\n\t\t\t}\n\t\t})\n\t}\n}",
    "880ea0b271ad5f9e12e05cf9dcf137a3": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"no escape sequences\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"simple escape sequences\",\n\t\t\tinput:    \"hello\\\\\\\"\\\\\\\\\\\\n\\\\t\\\\r\\\\b\\\\fworld\",\n\t\t\texpected: \"hello\\\"\\\\\\n\\t\\r\\b\\fworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"unicode escape sequences\",\n\t\t\tinput:    \"hello\\\\u0041\\\\u0042\\\\u0043world\",\n\t\t\texpected: \"helloABCworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"surrogate pair escape sequences\",\n\t\t\tinput:    \"hello\\\\ud83d\\\\ude00world\",\n\t\t\texpected: \"helloüòÄworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid escape sequences\",\n\t\t\tinput:    \"hello\\\\u123world\",\n\t\t\texpected: \"hello\\\\u123world\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "88b3d88545e7b71fef3f2ddd387f7e6d": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"basic string\",\n\t\t\tinput:    `\"hello world\"`,\n\t\t\texpected: []string{\"hello world\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quotes\",\n\t\t\tinput:    `\"hello \\\"world\\\"\"`,\n\t\t\texpected: []string{\"hello \\\"world\\\"\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello \\\"world\\\" \\\"foo\\\"\"`,\n\t\t\texpected: []string{\"hello \\\"world\\\" \\\"foo\\\"\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with unbalanced quotes\",\n\t\t\tinput:    `\"hello world`,\n\t\t\texpected: []string{}, // empty strings\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    `\"\"`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\ts1, s2, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif s1 != tc.expected[0] {\n\t\t\t\tt.Errorf(\"parseRawString() s1 = %v, want %v\", s1, tc.expected[0])\n\t\t\t}\n\n\t\t\tif s2 != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawString() s2 = %v, want %v\", s2, tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "8717eb40e7c5b1502a86c46aec6f0a2f": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\targs string\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"no escaped characters\",\n\t\t\targs: \"hello, world\",\n\t\t\twant: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped double quote\",\n\t\t\targs: \"\\\"hello, world\\\"\",\n\t\t\twant: `\"hello, world\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslash\",\n\t\t\targs: \"hello, \\\\world\",\n\t\t\twant: \"hello, \\\\world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped slash\",\n\t\t\targs: \"hello, \\\\/world\",\n\t\t\twant: \"hello, /world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: \"hello, \\bworld\",\n\t\t\twant: \"hello, \\bworld\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: \"hello, \\fworld\",\n\t\t\twant: \"hello, \\fworld\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: \"hello,\\nworld\",\n\t\t\twant: \"hello,\\nworld\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: \"hello,\\rworld\",\n\t\t\twant: \"hello,\\rworld\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: \"hello,\\tworld\",\n\t\t\twant: \"hello,\\tworld\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: \"hello, \\\\u1234world\",\n\t\t\twant: \"hello, \\u1234world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: \"hello, \\\\ud834\\\\udd1e\",\n\t\t\twant: \"hello, üéû\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: \"hello, \\\\xworld\",\n\t\t\twant: \"hello, \\\\xworld\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", tt.args, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "88bc848125f2ad9eae9f374f797cdd6d": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape sequences\",\n\t\t\tinput:    \"Hello, world!\",\n\t\t\texpected: \"Hello, world!\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Basic escape sequences\",\n\t\t\tinput:    \"Hello, \\\\\\\"world\\\\\\\"!\",\n\t\t\texpected: \"Hello, \\\"world\\\"!\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Unicode escape sequence\",\n\t\t\tinput:    \"Hello, \\\\u0041\\\\u0042\\\\u0043!\",\n\t\t\texpected: \"Hello, ABC!\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Surrogate pair escape sequence\",\n\t\t\tinput:    \"Hello, \\\\uD83D\\\\uDE00!\",\n\t\t\texpected: \"Hello, üòÄ!\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid escape sequence\",\n\t\t\tinput:    \"Hello, \\\\u0G41!\",\n\t\t\texpected: \"Hello, \\\\u0G41!\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Incomplete escape sequence\",\n\t\t\tinput:    \"Hello, \\\\u0\",\n\t\t\texpected: \"Hello, \\\\u0\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "8a92d6cf40fb9967c46b22a97cd7d74c": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"Empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"String without whitespace\",\n\t\t\tinput:    \"hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"String with leading whitespace\",\n\t\t\tinput:    \"   hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"String with trailing whitespace\",\n\t\t\tinput:    \"hello   \",\n\t\t\texpected: \"hello   \",\n\t\t},\n\t\t{\n\t\t\tname:     \"String with leading and trailing whitespace\",\n\t\t\tinput:    \"   hello   \",\n\t\t\texpected: \"hello   \",\n\t\t},\n\t\t{\n\t\t\tname:     \"String with mixed whitespace\",\n\t\t\tinput:    \"   \\t\\n\\r hello \\t\\n\\r\",\n\t\t\texpected: \"hello \\t\\n\\r\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := skipWSSlow(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"skipWSSlow(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "8a73b2899763b71a1e7be8fdde02f4a4": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"Valid number\",\n\t\t\tinput:    \"12345.67\",\n\t\t\texpected: []string{\"12345.67\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Number with exponent\",\n\t\t\tinput:    \"1.23e4\",\n\t\t\texpected: []string{\"1.23e4\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Negative number\",\n\t\t\tinput:    \"-3.14\",\n\t\t\texpected: []string{\"-3.14\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Infinity\",\n\t\t\tinput:    \"inf\",\n\t\t\texpected: []string{\"\", \"inf\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN\",\n\t\t\tinput:    \"nan\",\n\t\t\texpected: []string{\"\", \"nan\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid character\",\n\t\t\tinput:    \"12a\",\n\t\t\texpected: []string{\"\", \"12a\"},\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.expected[0] {\n\t\t\t\tt.Errorf(\"parseRawNumber() num = %v, expected %v\", num, tc.expected[0])\n\t\t\t}\n\t\t\tif rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawNumber() rest = %v, expected %v\", rest, tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "8bd5ac54a8d97cb3498cac05c38ebb21": "package fastjson\n\nimport (\n    \"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n    testCases := []struct {\n        name     string\n        input    string\n        number   string\n        rest     string\n        hasError bool\n    }{\n        {\n            name:     \"valid number\",\n            input:    \"123.456e+78abc\",\n            number:   \"123.456e+78\",\n            rest:     \"abc\",\n            hasError: false,\n        },\n        {\n            name:     \"number with leading sign\",\n            input:    \"-123.456abc\",\n            number:   \"-123.456\",\n            rest:     \"abc\",\n            hasError: false,\n        },\n        {\n            name:     \"number with leading sign and exponent\",\n            input:    \"+123.456e-78abc\",\n            number:   \"+123.456e-78\",\n            rest:     \"abc\",\n            hasError: false,\n        },\n        {\n            name:     \"number with invalid character\",\n            input:    \"123.456$abc\",\n            number:   \"\",\n            rest:     \"123.456$abc\",\n            hasError: true,\n        },\n        {\n            name:     \"empty input\",\n            input:    \"\",\n            number:   \"\",\n            rest:     \"\",\n            hasError: false,\n        },\n        {\n            name:     \"inf\",\n            input:    \"infabc\",\n            number:   \"inf\",\n            rest:     \"abc\",\n            hasError: false,\n        },\n        {\n            name:     \"nan\",\n            input:    \"nanabc\",\n            number:   \"nan\",\n            rest:     \"abc\",\n            hasError: false,\n        },\n    }\n\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            number, rest, err := parseRawNumber(tc.input)\n            if (err != nil) != tc.hasError {\n                t.Errorf(\"unexpected error state, expected error: %t, got error: %v\", tc.hasError, err)\n            }\n            if number != tc.number {\n                t.Errorf(\"unexpected number, expected: %q, got: %q\", tc.number, number)\n            }\n            if rest != tc.rest {\n                t.Errorf(\"unexpected rest, expected: %q, got: %q\", tc.rest, rest)\n            }\n        })\n    }\n}",
    "8cebbaf56eed54ae7ac1f41dc7bca55a": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"Simple string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: []string{\"hello\", \"\"},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"String with escaped quote\",\n\t\t\tinput:    `\"he\\\"llo\"`,\n\t\t\texpected: []string{\"he\\\"llo\", \"\"},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"String with multiple escaped quotes\",\n\t\t\tinput:    `\"he\\\"ll\\\"o\"`,\n\t\t\texpected: []string{\"he\\\"ll\\\"o\", \"\"},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Unclosed string\",\n\t\t\tinput:    `\"hello`,\n\t\t\texpected: []string{},\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Empty string\",\n\t\t\tinput:    `\"\"`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult1, result2, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expected error: %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif result1 != tc.expected[0] || result2 != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = (%q, %q), expected (%q, %q)\", tc.input, result1, result2, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "8f3577abc1e9b4953cc10e31b104475d": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\targs string\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: \"\",\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no leading whitespace\",\n\t\t\targs: \"hello\",\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace\",\n\t\t\targs: \"   hello\",\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace and newline\",\n\t\t\targs: \"\\n   hello\",\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace and tab\",\n\t\t\targs: \"\\t   hello\",\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace and carriage return\",\n\t\t\targs: \"\\r   hello\",\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"all whitespace\",\n\t\t\targs: \"   \\n\\t\\r\",\n\t\t\twant: \"\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.args); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "88843da73a4c0686070c97ea98d37280": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"empty array\",\n\t\t\tinput:    `[]`,\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{}},\n\t\t},\n\t\t{\n\t\t\tname:     \"simple array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}, &Value{t: TypeNumber, s: \"2\"}, &Value{t: TypeNumber, s: \"3\"}}},\n\t\t},\n\t\t{\n\t\t\tname:     \"array with whitespace\",\n\t\t\tinput:    `[ 1 , 2 , 3 ]`,\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}, &Value{t: TypeNumber, s: \"2\"}, &Value{t: TypeNumber, s: \"3\"}}},\n\t\t},\n\t\t{\n\t\t\tname:     \"array with nested objects\",\n\t\t\tinput:    `[{\"a\":1},{\"b\":2}]`,\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeObject, o: Object{kvs: []kv{{k: \"a\", v: &Value{t: TypeNumber, s: \"1\"}}}}}, &Value{t: TypeObject, o: Object{kvs: []kv{{k: \"b\", v: &Value{t: TypeNumber, s: \"2\"}}}}}}},\n\t\t},\n\t\t{\n\t\t\tname:  \"missing closing bracket\",\n\t\t\tinput: `[1,2,3`,\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"missing comma after value\",\n\t\t\tinput: `[1 2]`,\n\t\t\terr:   true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tgot, _, err := parseArray(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseArray(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !equalValues(got, tc.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", tc.input, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn equalObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn equalArrays(v1.a, v2.a)\n\tcase TypeString, TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeTrue, TypeFalse, TypeNull:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc equalObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !equalValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc equalArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tif !equalValues(v1, a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "90accc99b0223bbeeeeba3f4b5a0306c": "package fastjson_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/valyala/fastjson\"\n)\n\nfunc TestObjectReset(t *testing.T) {\n\t// Create a new Object\n\tobj := &fastjson.Object{\n\t\tkvs:           []fastjson.kv{\n\t\t\t{\n\t\t\t\tk: \"key1\",\n\t\t\t\tv: &fastjson.Value{},\n\t\t\t},\n\t\t\t{\n\t\t\t\tk: \"key2\",\n\t\t\t\tv: &fastjson.Value{},\n\t\t\t},\n\t\t},\n\t\tkeysUnescaped: true,\n\t}\n\n\t// Reset the Object\n\tobj.reset()\n\n\t// Verify the Object has been reset correctly\n\tif len(obj.kvs) != 1 {\n\t\tt.Errorf(\"expected len(obj.kvs) = 1, got %d\", len(obj.kvs))\n\t}\n\tif obj.keysUnescaped != false {\n\t\tt.Errorf(\"expected obj.keysUnescaped = false, got %t\", obj.keysUnescaped)\n\t}\n}",
    "8e7a2d1d824892a379375c34369f029f": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"simple object\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":true}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{t: TypeObject}\n\t\t\t\tv.o.kvs = []kv{\n\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeTrue}},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with whitespace\",\n\t\t\tinput: `{ \"key1\" : \"value1\" , \"key2\" : true }`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{t: TypeObject}\n\t\t\t\tv.o.kvs = []kv{\n\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeTrue}},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":true`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing key\",\n\t\t\tinput: `{\"key1\":\"value1\",:\"value2\"}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing value\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tv, _, err := parseObject(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"expected error: %v, got: %v\", tc.err, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif tc.expected != nil && !v.Equal(tc.expected) {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tc.expected, v)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc (v *Value) Equal(other *Value) bool {\n\tif v.t != other.t {\n\t\treturn false\n\t}\n\tswitch v.t {\n\tcase TypeObject:\n\t\treturn v.o.Equal(&other.o)\n\tcase TypeArray:\n\t\tif len(v.a) != len(other.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, vv := range v.a {\n\t\t\tif !vv.Equal(other.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeString:\n\t\treturn v.s == other.s\n\tcase TypeNumber:\n\t\treturn v.s == other.s\n\tcase TypeTrue:\n\t\treturn true\n\tcase TypeFalse:\n\t\treturn false\n\tcase TypeNull:\n\t\treturn true\n\tdefault:\n\t\tpanic(\"unknown type\")\n\t}\n}\n\nfunc (o *Object) Equal(other *Object) bool {\n\tif len(o.kvs) != len(other.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv := range o.kvs {\n\t\tif kv.k != other.kvs[i].k {\n\t\t\treturn false\n\t\t}\n\t\tif !kv.v.Equal(other.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "9077a4076d664e3c106ffc6a35892930": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected1, expected2 string\n\t\texpectedErr bool\n\t}{\n\t\t{\n\t\t\tname:  \"valid number\",\n\t\t\tinput: \"123.45e+6\",\n\t\t\texpected1: \"123.45e+6\",\n\t\t\texpected2: \"\",\n\t\t\texpectedErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"number with trailing non-numeric characters\",\n\t\t\tinput: \"123.45abc\",\n\t\t\texpected1: \"123.45\",\n\t\t\texpected2: \"abc\",\n\t\t\texpectedErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"number with leading non-numeric characters\",\n\t\t\tinput: \"abc123.45\",\n\t\t\texpected1: \"\",\n\t\t\texpected2: \"abc123.45\",\n\t\t\texpectedErr: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"empty string\",\n\t\t\tinput: \"\",\n\t\t\texpected1: \"\",\n\t\t\texpected2: \"\",\n\t\t\texpectedErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"inf\",\n\t\t\tinput: \"inf\",\n\t\t\texpected1: \"inf\",\n\t\t\texpected2: \"\",\n\t\t\texpectedErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"nan\",\n\t\t\tinput: \"nan\",\n\t\t\texpected1: \"nan\",\n\t\t\texpected2: \"\",\n\t\t\texpectedErr: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.expectedErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) expected error %v, got %v\", tc.input, tc.expectedErr, err)\n\t\t\t}\n\t\t\tif num != tc.expected1 {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) expected num %q, got %q\", tc.input, tc.expected1, num)\n\t\t\t}\n\t\t\tif rest != tc.expected2 {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) expected rest %q, got %q\", tc.input, tc.expected2, rest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "8f686768662947d3b2eeeb2bfd5865e5": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape double quote\",\n\t\t\tinput:    \"hello, \\\"world\\\"\",\n\t\t\texpected: \"hello, \\\"world\\\"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backslash\",\n\t\t\tinput:    \"hello, \\\\world\\\\\",\n\t\t\texpected: \"hello, \\\\world\\\\\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape forward slash\",\n\t\t\tinput:    \"hello, /world/\",\n\t\t\texpected: \"hello, /world/\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backspace\",\n\t\t\tinput:    \"hello, \\bworld\\b\",\n\t\t\texpected: \"hello, \\bworld\\b\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape form feed\",\n\t\t\tinput:    \"hello, \\fworld\\f\",\n\t\t\texpected: \"hello, \\fworld\\f\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape newline\",\n\t\t\tinput:    \"hello,\\nworld\\n\",\n\t\t\texpected: \"hello,\\nworld\\n\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape carriage return\",\n\t\t\tinput:    \"hello,\\rworld\\r\",\n\t\t\texpected: \"hello,\\rworld\\r\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape tab\",\n\t\t\tinput:    \"hello,\\tworld\\t\",\n\t\t\texpected: \"hello,\\tworld\\t\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Unicode character\",\n\t\t\tinput:    \"hello, \\u2603 world\",\n\t\t\texpected: \"hello, ‚òÉ world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape surrogate pair\",\n\t\t\tinput:    \"hello, \\uD83D\\uDE00 world\",\n\t\t\texpected: \"hello, üòÄ world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid escape sequence\",\n\t\t\tinput:    \"hello, \\\\x world\",\n\t\t\texpected: \"hello, \\\\x world\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "927442f535b7e4a37d3a499635756263": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"Empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"No leading whitespace\",\n\t\t\tinput:    \"hello world\",\n\t\t\texpected: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Leading space\",\n\t\t\tinput:    \" hello world\",\n\t\t\texpected: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Leading tab\",\n\t\t\tinput:    \"\\thello world\",\n\t\t\texpected: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Leading newline\",\n\t\t\tinput:    \"\\nhello world\",\n\t\t\texpected: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Leading carriage return\",\n\t\t\tinput:    \"\\rhello world\",\n\t\t\texpected: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Multiple leading whitespace\",\n\t\t\tinput:    \"   \\t\\n\\rhello world\",\n\t\t\texpected: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Whitespace only\",\n\t\t\tinput:    \"   \\t\\n\\r\",\n\t\t\texpected: \"\",\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tresult := skipWSSlow(test.input)\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"skipWSSlow(%q) = %q, expected %q\", test.input, result, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "944cf59ea2ceb697831d45af4347d2e0": "package fastjson\n\nimport (\n    \"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n    testCases := []struct {\n        name     string\n        input    string\n        wantKey  string\n        wantRest string\n        wantErr  bool\n    }{\n        {\n            name:     \"simple string\",\n            input:    `\"hello\"`,\n            wantKey:  \"hello\",\n            wantRest: \"\",\n            wantErr:  false,\n        },\n        {\n            name:     \"string with escaped quote\",\n            input:    `\"he\\\"llo\"`,\n            wantKey:  `he\"llo`,\n            wantRest: \"\",\n            wantErr:  false,\n        },\n        {\n            name:     \"missing closing quote\",\n            input:    `\"hello`,\n            wantKey:  \"\",\n            wantRest: \"\",\n            wantErr:  true,\n        },\n        {\n            name:     \"empty string\",\n            input:    `\"\"`,\n            wantKey:  \"\",\n            wantRest: \"\",\n            wantErr:  false,\n        },\n    }\n\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            key, rest, err := parseRawString(tc.input)\n            if (err != nil) != tc.wantErr {\n                t.Errorf(\"parseRawString(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n                return\n            }\n            if key != tc.wantKey {\n                t.Errorf(\"parseRawString(%q) key = %q, want %q\", tc.input, key, tc.wantKey)\n            }\n            if rest != tc.wantRest {\n                t.Errorf(\"parseRawString(%q) rest = %q, want %q\", tc.input, rest, tc.wantRest)\n            }\n        })\n    }\n}",
    "931de4c9bc95fb1424329131cacd818c": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"hello world\",\n\t\t\texpected: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape double quotes\",\n\t\t\tinput:    \"\\\"hello\\\" world\",\n\t\t\texpected: `\"hello\" world`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backslash\",\n\t\t\tinput:    \"hello\\\\ world\",\n\t\t\texpected: `hello\\ world`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape forward slash\",\n\t\t\tinput:    \"hello/ world\",\n\t\t\texpected: `hello/ world`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backspace\",\n\t\t\tinput:    \"hello\\b world\",\n\t\t\texpected: \"hello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape form feed\",\n\t\t\tinput:    \"hello\\f world\",\n\t\t\texpected: \"hello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape newline\",\n\t\t\tinput:    \"hello\\n world\",\n\t\t\texpected: \"hello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape carriage return\",\n\t\t\tinput:    \"hello\\r world\",\n\t\t\texpected: \"hello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape tab\",\n\t\t\tinput:    \"hello\\t world\",\n\t\t\texpected: \"hello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape unicode\",\n\t\t\tinput:    \"hello\\\\u1234 world\",\n\t\t\texpected: \"hello\\u1234 world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape surrogate pair\",\n\t\t\tinput:    \"hello\\\\u1234\\\\u5678 world\",\n\t\t\texpected: \"hello\\U00012345 world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid escape sequence\",\n\t\t\tinput:    \"hello\\\\x world\",\n\t\t\texpected: \"hello\\\\x world\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "8eae25ac5e53288751b9137800585cf9": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tinput   string\n\t\twantVal *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty string\",\n\t\t\tinput: \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object\",\n\t\t\tinput: `{\"key\":\"value\"}`,\n\t\t\twantVal: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{s: \"value\", t: typeRawString}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"array\",\n\t\t\tinput: `[1,true,null]`,\n\t\t\twantVal: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"1\", t: TypeNumber},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t\t{t: TypeNull},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"string\",\n\t\t\tinput: `\"hello\"`,\n\t\t\twantVal: &Value{\n\t\t\t\ts: \"hello\",\n\t\t\t\tt: typeRawString,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"true\",\n\t\t\tinput: \"true\",\n\t\t\twantVal: valueTrue,\n\t\t},\n\t\t{\n\t\t\tname:  \"false\",\n\t\t\tinput: \"false\",\n\t\t\twantVal: valueFalse,\n\t\t},\n\t\t{\n\t\t\tname:  \"null\",\n\t\t\tinput: \"null\",\n\t\t\twantVal: valueNull,\n\t\t},\n\t\t{\n\t\t\tname:  \"number\",\n\t\t\tinput: \"42\",\n\t\t\twantVal: &Value{\n\t\t\t\ts: \"42\",\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"too deep\",\n\t\t\tinput: \"{}\", // depth limit not exceeded in this test\n\t\t\twantErr: true,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotVal, _, gotErr := parseValue(tt.input, c, 0)\n\t\t\tif (gotErr != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, wantErr %v\", tt.input, gotErr, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr && !valsEqual(gotVal, tt.wantVal) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", tt.input, gotVal, tt.wantVal)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc valsEqual(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\to1, _ := v1.Object()\n\t\to2, _ := v2.Object()\n\t\tif len(o1.kvs) != len(o2.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, kv1 := range o1.kvs {\n\t\t\tkv2 := o2.kvs[i]\n\t\t\tif kv1.k != kv2.k || !valsEqual(kv1.v, kv2.v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeArray:\n\t\ta1, _ := v1.Array()\n\t\ta2, _ := v2.Array()\n\t\tif len(a1) != len(a2) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, v := range a1 {\n\t\t\tif !valsEqual(v, a2[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase typeRawString, TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber, TypeTrue, TypeFalse, TypeNull:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\tpanic(\"unknown Type\")\n\t}\n}",
    "973c84c52e171785247ca35616aa1d1f": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWS(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"string with no whitespace\",\n\t\t\tinput:    \"abc\",\n\t\t\texpected: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname:     \"string with leading whitespace\",\n\t\t\tinput:    \"   abc\",\n\t\t\texpected: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname:     \"string with trailing whitespace\",\n\t\t\tinput:    \"abc   \",\n\t\t\texpected: \"abc   \",\n\t\t},\n\t\t{\n\t\t\tname:     \"string with leading and trailing whitespace\",\n\t\t\tinput:    \"   abc   \",\n\t\t\texpected: \"abc   \",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := skipWS(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"skipWS(%q) = %q, want %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "95389a6837d9eb3a84111077fcf4a879": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantNum  string\n\t\twantRest string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.45e+67\",\n\t\t\twantNum:  \"123.45e+67\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with trailing characters\",\n\t\t\tinput:    \"123.45e+67abc\",\n\t\t\twantNum:  \"123.45e+67\",\n\t\t\twantRest: \"abc\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty input\",\n\t\t\tinput:    \"\",\n\t\t\twantNum:  \"\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid character\",\n\t\t\tinput:    \"123a\",\n\t\t\twantNum:  \"\",\n\t\t\twantRest: \"123a\",\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN\",\n\t\t\tinput:    \"NAN\",\n\t\t\twantNum:  \"NAN\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid NaN\",\n\t\t\tinput:    \"NA\",\n\t\t\twantNum:  \"\",\n\t\t\twantRest: \"NA\",\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif tc.wantErr {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"parseRawNumber(%q) expected error, got nil\", tc.input)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"parseRawNumber(%q) unexpected error: %v\", tc.input, err)\n\t\t\t\t}\n\t\t\t\tif num != tc.wantNum {\n\t\t\t\t\tt.Errorf(\"parseRawNumber(%q) got num=%q, want %q\", tc.input, num, tc.wantNum)\n\t\t\t\t}\n\t\t\t\tif rest != tc.wantRest {\n\t\t\t\t\tt.Errorf(\"parseRawNumber(%q) got rest=%q, want %q\", tc.input, rest, tc.wantRest)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}",
    "98c795bf1798c0c906aef3710ac7839f": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestHasSpecialChars(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    string\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\ts:    \"\",\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with backslash\",\n\t\t\ts:    \"hello\\\\world\",\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with control character\",\n\t\t\ts:    \"hello\\nworld\",\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with no special characters\",\n\t\t\ts:    \"helloworld\",\n\t\t\twant: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := hasSpecialChars(tt.s); got != tt.want {\n\t\t\t\tt.Errorf(\"hasSpecialChars(%q) = %v, want %v\", tt.s, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "988e774d0c9bbf8ebec69401aa6197ef": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape sequences\",\n\t\t\tinput:    \"hello world\",\n\t\t\texpected: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Simple escape sequences\",\n\t\t\tinput:    `hello\\\"world\\/\\b\\f\\n\\r\\t`,\n\t\t\texpected: `hello\"world/\\b\\f\\n\\r\\t`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Unicode escape sequences\",\n\t\t\tinput:    `hello\\u0041\\u00dc\\u0161\\u00f6\\u0173world`,\n\t\t\texpected: `helloA??≈°??world`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Surrogate pair escape sequences\",\n\t\t\tinput:    `hello\\ud83d\\ude00world`,\n\t\t\texpected: `hello????world`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid escape sequences\",\n\t\t\tinput:    `hello\\u123\\u12world`,\n\t\t\texpected: `hello\\u123\\u12world`,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"Expected '%s', got '%s'\", tc.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "962a6598fdf73728f2ed67799af5edd1": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid JSON\",\n\t\t\tinput:    `{\"key\":\"value\",\"num\":42,\"bool\":true}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{s: \"value\", t: TypeString}},\n\t\t\t\t\t\t{k: \"num\", v: &Value{s: \"42\", t: TypeNumber}},\n\t\t\t\t\t\t{k: \"bool\", v: &Value{s: \"true\", t: TypeTrue}},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: true,\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid JSON\",\n\t\t\tinput:    `{\"key\":\"value\"`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"unexpected tail\",\n\t\t\tinput:    `{\"key\":\"value\"} extra`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tp := &Parser{}\n\t\t\tactual, err := p.Parse(tc.input)\n\t\t\tif err != nil && !tc.err {\n\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t}\n\t\t\tif err == nil && tc.err {\n\t\t\t\tt.Errorf(\"expected error, but got none\")\n\t\t\t}\n\t\t\tif !equalValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"unexpected result:\\ngot: %+v\\nwant: %+v\", actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\to1, _ := v1.Object()\n\t\to2, _ := v2.Object()\n\t\tif len(o1.kvs) != len(o2.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range o1.kvs {\n\t\t\tif o1.kvs[i].k != o2.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(o1.kvs[i].v, o2.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeArray:\n\t\ta1, _ := v1.Array()\n\t\ta2, _ := v2.Array()\n\t\tif len(a1) != len(a2) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range a1 {\n\t\t\tif !equalValues(a1[i], a2[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeString:\n\t\ts1, _ := v1.StringBytes()\n\t\ts2, _ := v2.StringBytes()\n\t\treturn string(s1) == string(s2)\n\tcase TypeNumber, TypeTrue, TypeFalse:\n\t\treturn v1.s == v2.s\n\tcase TypeNull:\n\t\treturn true\n\tdefault:\n\t\tpanic(\"unknown type\")\n\t}\n}",
    "97f2c7add671ebe3902cf2bb0b7a7f33": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:  \"valid object\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":123}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":123`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"empty input\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"closing brace with no object\",\n\t\t\tinput:    \"}\",\n\t\t\texpected: &Value{t: TypeObject, o: Object{}},\n\t\t\terr:      nil,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tactual, _, err := parseObject(tc.input, c, 0)\n\t\t\tif !reflect.DeepEqual(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tc.expected, actual)\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(err, tc.err) {\n\t\t\t\tt.Errorf(\"expected error %v, got %v\", tc.err, err)\n\t\t\t}\n\t\t})\n\t}\n}",
    "9c63bb399dab302f6903eab6bf141443": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCache_GetValue(t *testing.T) {\n\tc := &cache{\n\t\tvs: make([]Value, 0, 1),\n\t}\n\n\t// Test when the capacity is greater than the length\n\tv := c.getValue()\n\tif v == nil {\n\t\tt.Errorf(\"expected a non-nil Value, got nil\")\n\t}\n\tif len(c.vs) != 1 {\n\t\tt.Errorf(\"expected length of vs to be 1, got %d\", len(c.vs))\n\t}\n\tif cap(c.vs) != 1 {\n\t\tt.Errorf(\"expected capacity of vs to be 1, got %d\", cap(c.vs))\n\t}\n\n\t// Test when the capacity is equal to the length\n\tc.vs = c.vs[:cap(c.vs)]\n\tv = c.getValue()\n\tif v == nil {\n\t\tt.Errorf(\"expected a non-nil Value, got nil\")\n\t}\n\tif len(c.vs) != 1 {\n\t\tt.Errorf(\"expected length of vs to be 1, got %d\", len(c.vs))\n\t}\n\tif cap(c.vs) != 1 {\n\t\tt.Errorf(\"expected capacity of vs to be 1, got %d\", cap(c.vs))\n\t}\n}",
    "9914998199e4809edead0dd3661441c4": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype testCase struct {\n\t\tname     string\n\t\tinput    string\n\t\twantKey  string\n\t\twantRest string\n\t\twantErr  bool\n\t}\n\n\ttestCases := []testCase{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello\"world`,\n\t\t\twantKey:  \"hello\",\n\t\t\twantRest: \"world\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello\\\"world\"`,\n\t\t\twantKey:  `hello\"world`,\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello\\\"world\\\"foo\"`,\n\t\t\twantKey:  `hello\"world\"foo`,\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with no closing quote\",\n\t\t\tinput:    `\"hello`,\n\t\t\twantKey:  \"\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tkey, rest, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif key != tc.wantKey {\n\t\t\t\tt.Errorf(\"parseRawString(%q) key = %q, want %q\", tc.input, key, tc.wantKey)\n\t\t\t}\n\t\t\tif rest != tc.wantRest {\n\t\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, want %q\", tc.input, rest, tc.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "9d722c9775b36fd5ffebc9644db7afd5": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t\tremaindr string\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid key without escape\",\n\t\t\tinput:    `\"foo\"bar`,\n\t\t\texpected: `foo`,\n\t\t\tremaindr: `bar`,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid key with escape\",\n\t\t\tinput:    `\"foo\\\"bar\"baz`,\n\t\t\texpected: `foo\"bar`,\n\t\t\tremaindr: `baz`,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing closing quote\",\n\t\t\tinput:    `\"foo`,\n\t\t\texpected: ``,\n\t\t\tremaindr: ``,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tkey, remainder, err := parseRawKey(tc.input)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"expected error: %v, got: %v\", tc.err, err)\n\t\t\t}\n\t\t\tif key != tc.expected {\n\t\t\t\tt.Errorf(\"expected key: %s, got: %s\", tc.expected, key)\n\t\t\t}\n\t\t\tif remainder != tc.remaindr {\n\t\t\t\tt.Errorf(\"expected remainder: %s, got: %s\", tc.remaindr, remainder)\n\t\t\t}\n\t\t})\n\t}\n}",
    "9b380eec8fa2e09aba0eeacd0f8da3ef": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape sequences\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Simple escape sequences\",\n\t\t\tinput:    \"hello\\\\\\\"\\\\\\\\\\\\r\\\\n\\\\tworld\",\n\t\t\texpected: \"hello\\\"\\\\r\\n\\tworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Unicode escape sequences\",\n\t\t\tinput:    \"hello\\\\u0041\\\\u00DF\\\\u20ACworld\",\n\t\t\texpected: \"helloA\\u00DF√¢‚Äö¬¨world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Surrogate pair escape sequences\",\n\t\t\tinput:    \"hello\\\\uD834\\\\uDD1Eworld\",\n\t\t\texpected: \"helloœÄ¬´world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid escape sequences\",\n\t\t\tinput:    \"hello\\\\u123world\\\\u12\",\n\t\t\texpected: \"hello\\\\u123world\\\\u12\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "9d1c733b765c6e5bb2e318b7bf7b1f1d": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetFloat64(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    *Value\n\t\tkeys     []string\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname: \"Existing Float64 value\",\n\t\t\tinput: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"3.14\",\n\t\t\t},\n\t\t\tkeys:     []string{},\n\t\t\texpected: 3.14,\n\t\t},\n\t\t{\n\t\t\tname: \"Non-existing keys path\",\n\t\t\tinput: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"foo\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"3.14\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"bar\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Invalid value type\",\n\t\t\tinput: &Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\tkeys:     []string{},\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := tc.input.GetFloat64(tc.keys...)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"GetFloat64(%v) = %v, want %v\", tc.keys, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "9a400049bc667439078b6f295edaa514": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tinput   string\n\t\twantVal *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty array\",\n\t\t\tinput: \"[]\",\n\t\t\twantVal: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with values\",\n\t\t\tinput: \"[1, true, \\\"hello\\\"]\",\n\t\t\twantVal: func() *Value {\n\t\t\t\tv1 := &Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"1\",\n\t\t\t\t}\n\t\t\t\tv2 := &Value{\n\t\t\t\t\tt: TypeTrue,\n\t\t\t\t}\n\t\t\t\tv3 := &Value{\n\t\t\t\t\tt: TypeString,\n\t\t\t\t\ts: \"hello\",\n\t\t\t\t}\n\t\t\t\treturn &Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{v1, v2, v3},\n\t\t\t\t}\n\t\t\t}(),\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with missing closing bracket\",\n\t\t\tinput: \"[1, true, \\\"hello\\\"\",\n\t\t\twantVal: nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with missing comma\",\n\t\t\tinput: \"[1 true, \\\"hello\\\"]\",\n\t\t\twantVal: nil,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tgotVal, _, err := parseArray(tt.input, c, 0)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !reflect.DeepEqual(gotVal, tt.wantVal) {\n\t\t\t\tt.Errorf(\"parseArray() gotVal = %v, want %v\", gotVal, tt.wantVal)\n\t\t\t}\n\t\t})\n\t}\n}",
    "9e07e1684a9175571829fc4b6c2848ae": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestValueGet(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tv      *Value\n\t\tkeys   []string\n\t\texpect *Value\n\t}{\n\t\t{\n\t\t\tname: \"get from object\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: &Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:   []string{\"key1\"},\n\t\t\texpect: &Value{t: TypeString, s: \"value1\"},\n\t\t},\n\t\t{\n\t\t\tname: \"get from array\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"value1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:   []string{\"1\"},\n\t\t\texpect: &Value{t: TypeNumber, s: \"42\"},\n\t\t},\n\t\t{\n\t\t\tname: \"non-existing key\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: &Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:   []string{\"key2\"},\n\t\t\texpect: nil,\n\t\t},\n\t\t{\n\t\t\tname:   \"nil input\",\n\t\t\tv:      nil,\n\t\t\tkeys:   []string{\"key\"},\n\t\t\texpect: nil,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.Get(tt.keys...)\n\t\t\tif !reflect.DeepEqual(got, tt.expect) {\n\t\t\t\tt.Errorf(\"Get(%v) = %v, want %v\", tt.keys, got, tt.expect)\n\t\t\t}\n\t\t})\n\t}\n}",
    "9e0ed56369c9670fc81d5c33642bb3d0": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWS(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    string\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\ts:    \"\",\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no whitespace\",\n\t\t\ts:    \"hello\",\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace\",\n\t\t\ts:    \"   hello\",\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailing whitespace\",\n\t\t\ts:    \"hello   \",\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading and trailing whitespace\",\n\t\t\ts:    \"   hello   \",\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"all whitespace\",\n\t\t\ts:    \"   \",\n\t\t\twant: \"\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWS(tt.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWS(%q) = %q, want %q\", tt.s, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "9e524aa14aefac4ab3ed67beab293c90": "package fastjson\n\nimport (\n    \"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n    testCases := []struct {\n        name     string\n        input    string\n        expected string\n    }{\n        {\n            name:     \"empty string\",\n            input:    \"\",\n            expected: \"\",\n        },\n        {\n            name:     \"no leading/trailing whitespace\",\n            input:    \"hello world\",\n            expected: \"hello world\",\n        },\n        {\n            name:     \"leading whitespace\",\n            input:    \"  hello world\",\n            expected: \"hello world\",\n        },\n        {\n            name:     \"trailing whitespace\",\n            input:    \"hello world  \",\n            expected: \"hello world\",\n        },\n        {\n            name:     \"leading and trailing whitespace\",\n            input:    \"  hello world  \",\n            expected: \"hello world\",\n        },\n        {\n            name:     \"mixed whitespace\",\n            input:    \"  \\t hello \\n world \\r \",\n            expected: \"hello \\n world\",\n        },\n    }\n\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            result := skipWSSlow(tc.input)\n            if result != tc.expected {\n                t.Errorf(\"skipWSSlow(%q) = %q, expected %q\", tc.input, result, tc.expected)\n            }\n        })\n    }\n}",
    "99f957235d301b83e920e28e6e699f3b": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty array\",\n\t\t\tinput: \"[]\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with one element\",\n\t\t\tinput: \"[1]\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with multiple elements\",\n\t\t\tinput: \"[1,2,3]\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with missing closing bracket\",\n\t\t\tinput: \"[1,2,\",\n\t\t\texpected: nil,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{\n\t\t\t\tvs: make([]Value, 0, 8),\n\t\t\t}\n\t\t\tactual, _, err := parseArray(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !equalValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseArray() = %v, want %v\", actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeNull, TypeTrue, TypeFalse:\n\t\treturn true\n\tcase TypeNumber, TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeObject:\n\t\treturn equalObjects(v1.o, v2.o)\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc equalObjects(o1, o2 Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i := range o1.kvs {\n\t\tif o1.kvs[i].k != o2.kvs[i].k {\n\t\t\treturn false\n\t\t}\n\t\tif !equalValues(o1.kvs[i].v, o2.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "9ded4cbbfb091b99193517a3125351b6": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tinput string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname: \"No escape characters\",\n\t\t\tinput: \"hello world\",\n\t\t\texpected: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"Escaping double quotes\",\n\t\t\tinput: \"\\\"hello\\\" world\",\n\t\t\texpected: `\"hello\" world`,\n\t\t},\n\t\t{\n\t\t\tname: \"Escaping backslash\",\n\t\t\tinput: \"hello\\\\world\",\n\t\t\texpected: `hello\\world`,\n\t\t},\n\t\t{\n\t\t\tname: \"Escaping forward slash\",\n\t\t\tinput: \"hello/world\",\n\t\t\texpected: `hello/world`,\n\t\t},\n\t\t{\n\t\t\tname: \"Escaping backspace\",\n\t\t\tinput: \"hello\\bworld\",\n\t\t\texpected: `hello\\bworld`,\n\t\t},\n\t\t{\n\t\t\tname: \"Escaping form feed\",\n\t\t\tinput: \"hello\\fworld\",\n\t\t\texpected: `hello\\fworld`,\n\t\t},\n\t\t{\n\t\t\tname: \"Escaping newline\",\n\t\t\tinput: \"hello\\nworld\",\n\t\t\texpected: `hello\\nworld`,\n\t\t},\n\t\t{\n\t\t\tname: \"Escaping carriage return\",\n\t\t\tinput: \"hello\\rworld\",\n\t\t\texpected: `hello\\rworld`,\n\t\t},\n\t\t{\n\t\t\tname: \"Escaping tab\",\n\t\t\tinput: \"hello\\tworld\",\n\t\t\texpected: `hello\\tworld`,\n\t\t},\n\t\t{\n\t\t\tname: \"Escaping Unicode character\",\n\t\t\tinput: \"hello\\u0123world\",\n\t\t\texpected: `hello\\u0123world`,\n\t\t},\n\t\t{\n\t\t\tname: \"Escaping surrogate pair\",\n\t\t\tinput: \"hello\\uD834\\uDD1Eworld\",\n\t\t\texpected: `hello\\uD834\\uDD1Eworld`,\n\t\t},\n\t\t{\n\t\t\tname: \"Mixed escape sequences\",\n\t\t\tinput: \"\\\"hello\\\\world\\\\/\\b\\f\\n\\r\\t\\u0123\\\"\",\n\t\t\texpected: `\"hello\\world\\/\\b\\f\\n\\r\\t\\u0123\"`,\n\t\t},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "9f91440c10436878372c66e4c407c431": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestEscapeString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []byte\n\t}{\n\t\t{\n\t\t\tname:     \"No special characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: []byte(`\"hello, world\"`),\n\t\t},\n\t\t{\n\t\t\tname:     \"Has special characters\",\n\t\t\tinput:    \"hello, \\\"world\\\"\",\n\t\t\texpected: []byte(`\"hello, \\\"world\\\"\"`),\n\t\t},\n\t\t{\n\t\t\tname:     \"Empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: []byte(`\"\"`),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdst := make([]byte, 0, len(tc.input)+2)\n\t\t\tresult := escapeString(dst, tc.input)\n\t\t\tif !reflect.DeepEqual(result, tc.expected) {\n\t\t\t\tt.Errorf(\"escapeString(%q) = %q, want %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "9fedd9038220768c2bac39e510f99dc1": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetValue(t *testing.T) {\n\tc := &cache{\n\t\tvs: make([]Value, 0, 1),\n\t}\n\n\tv := c.getValue()\n\tif v == nil {\n\t\tt.Errorf(\"getValue() returned nil, expected a non-nil Value\")\n\t}\n\n\tif len(c.vs) != 1 {\n\t\tt.Errorf(\"Expected 1 value in the cache, got %d\", len(c.vs))\n\t}\n\n\tif &c.vs[0] != v {\n\t\tt.Errorf(\"getValue() returned a different Value than the one in the cache\")\n\t}\n\n\t// Test that the cache grows when necessary\n\tfor i := 0; i < 10; i++ {\n\t\tv = c.getValue()\n\t}\n\n\tif len(c.vs) != 11 {\n\t\tt.Errorf(\"Expected 11 values in the cache, got %d\", len(c.vs))\n\t}\n}",
    "9ecd12b15090c9fb41c1b44b254548bd": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantKey  string\n\t\twantRest string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello world\"`,\n\t\t\twantKey:  \"hello world\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello \\\"world\\\"\"`,\n\t\t\twantKey:  `hello \"world\"`,\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing closing quote\",\n\t\t\tinput:    `\"hello world`,\n\t\t\twantKey:  \"\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with trailing content\",\n\t\t\tinput:    `\"hello world\" 123`,\n\t\t\twantKey:  \"hello world\",\n\t\t\twantRest: \" 123\",\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tkey, rest, err := parseRawString(tt.input)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString(%q) error = %v, wantErr %v\", tt.input, err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif key != tt.wantKey {\n\t\t\t\tt.Errorf(\"parseRawString(%q) key = %q, want %q\", tt.input, key, tt.wantKey)\n\t\t\t}\n\t\t\tif rest != tt.wantRest {\n\t\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, want %q\", tt.input, rest, tt.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a0be294fe6b017709180cd40c5a0fee5": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetFloat64(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tjson   string\n\t\tkeys   []string\n\t\texpect float64\n\t}{\n\t\t{\n\t\t\tname:   \"existing float value\",\n\t\t\tjson:   `{\"key\": 3.14}`,\n\t\t\tkeys:   []string{\"key\"},\n\t\t\texpect: 3.14,\n\t\t},\n\t\t{\n\t\t\tname:   \"non-existing key\",\n\t\t\tjson:   `{\"key\": 3.14}`,\n\t\t\tkeys:   []string{\"non-existing\"},\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"invalid value type\",\n\t\t\tjson:   `{\"key\": \"string\"}`,\n\t\t\tkeys:   []string{\"key\"},\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"array index\",\n\t\t\tjson:   `[1.23, 4.56]`,\n\t\t\tkeys:   []string{\"1\"},\n\t\t\texpect: 4.56,\n\t\t},\n\t\t{\n\t\t\tname:   \"nested object\",\n\t\t\tjson:   `{\"outer\": {\"inner\": 2.71}}`,\n\t\t\tkeys:   []string{\"outer\", \"inner\"},\n\t\t\texpect: 2.71,\n\t\t},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tv, err := ParseBytes([]byte(tc.json))\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t\t\t}\n\n\t\t\tgot := v.GetFloat64(tc.keys...)\n\t\t\tif got != tc.expect {\n\t\t\t\tt.Errorf(\"unexpected result, got: %f, want: %f\", got, tc.expect)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a0373d3677e79e645b6cf3ae1430e524": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttestCases := []struct {\n\t\tname       string\n\t\tinput      string\n\t\twantValue  *Value\n\t\twantRemainder string\n\t\twantErr    bool\n\t}{\n\t\t{\n\t\t\tname:       \"empty array\",\n\t\t\tinput:      \"[]\",\n\t\t\twantValue:  &Value{t: TypeArray, a: []*Value{}},\n\t\t\twantRemainder: \"\",\n\t\t\twantErr:    false,\n\t\t},\n\t\t{\n\t\t\tname:       \"array with one value\",\n\t\t\tinput:      \"[1]\",\n\t\t\twantValue:  &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}}},\n\t\t\twantRemainder: \"\",\n\t\t\twantErr:    false,\n\t\t},\n\t\t{\n\t\t\tname:       \"array with multiple values\",\n\t\t\tinput:      \"[1,2,3]\",\n\t\t\twantValue:  &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}, &Value{t: TypeNumber, s: \"2\"}, &Value{t: TypeNumber, s: \"3\"}}},\n\t\t\twantRemainder: \"\",\n\t\t\twantErr:    false,\n\t\t},\n\t\t{\n\t\t\tname:       \"array with trailing comma\",\n\t\t\tinput:      \"[1,2,3,]\",\n\t\t\twantValue:  &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}, &Value{t: TypeNumber, s: \"2\"}, &Value{t: TypeNumber, s: \"3\"}}},\n\t\t\twantRemainder: \",\",\n\t\t\twantErr:    false,\n\t\t},\n\t\t{\n\t\t\tname:       \"array with missing closing bracket\",\n\t\t\tinput:      \"[1,2,3\",\n\t\t\twantValue:  nil,\n\t\t\twantRemainder: \"[1,2,3\",\n\t\t\twantErr:    true,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgotValue, gotRemainder, gotErr := parseArray(tc.input, c, 0)\n\t\t\tif (gotErr != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseArray(%q) error = %v, wantErr %v\", tc.input, gotErr, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(gotValue, tc.wantValue) {\n\t\t\t\tt.Errorf(\"parseArray(%q) gotValue = %v, want %v\", tc.input, gotValue, tc.wantValue)\n\t\t\t}\n\t\t\tif gotRemainder != tc.wantRemainder {\n\t\t\t\tt.Errorf(\"parseArray(%q) gotRemainder = %q, want %q\", tc.input, gotRemainder, tc.wantRemainder)\n\t\t\t}\n\t\t})\n\t}\n}",
    "9f53176c39cd51e97ea861dcb0f5391f": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tinput   string\n\t\twantVal *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty string\",\n\t\t\tinput: \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"too big depth\",\n\t\t\tinput: \"{\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object parsing error\",\n\t\t\tinput: \"{]\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array parsing error\",\n\t\t\tinput: \"[}\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"string parsing error\",\n\t\t\tinput: `\"unterminated`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"true value\",\n\t\t\tinput: \"true\",\n\t\t\twantVal: valueTrue,\n\t\t},\n\t\t{\n\t\t\tname:  \"false value\",\n\t\t\tinput: \"false\",\n\t\t\twantVal: valueFalse,\n\t\t},\n\t\t{\n\t\t\tname:  \"null value\",\n\t\t\tinput: \"null\",\n\t\t\twantVal: valueNull,\n\t\t},\n\t\t{\n\t\t\tname:  \"NaN value\",\n\t\t\tinput: \"NaN\",\n\t\t\twantVal: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"number parsing error\",\n\t\t\tinput: \"1.2.3\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"number parsing success\",\n\t\t\tinput: \"42\",\n\t\t\twantVal: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42\",\n\t\t\t},\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotVal, _, err := parseValue(tt.input, c, 0)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, wantErr %v\", tt.input, err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr && !tt.wantVal.Equal(gotVal) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", tt.input, gotVal, tt.wantVal)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc (v *Value) Equal(other *Value) bool {\n\tif v == nil || other == nil {\n\t\treturn v == other\n\t}\n\tif v.t != other.t {\n\t\treturn false\n\t}\n\tswitch v.t {\n\tcase TypeNull, TypeTrue, TypeFalse:\n\t\treturn true\n\tcase TypeNumber, typeRawString:\n\t\treturn v.s == other.s\n\tcase TypeObject:\n\t\treturn v.o.Equal(&other.o)\n\tcase TypeArray:\n\t\tif len(v.a) != len(other.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v.a {\n\t\t\tif !v.a[i].Equal(other.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\tpanic(\"BUG: unknown type\")\n\t}\n}\n\nfunc (o *Object) Equal(other *Object) bool {\n\tif len(o.kvs) != len(other.kvs) {\n\t\treturn false\n\t}\n\tfor i := range o.kvs {\n\t\tif o.kvs[i].k != other.kvs[i].k {\n\t\t\treturn false\n\t\t}\n\t\tif !o.kvs[i].v.Equal(other.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "a182a5363911766a168f3e7aaec2dfd7": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestMarshalTo(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\texpected []byte\n\t}{\n\t\t{\n\t\t\tname: \"Raw String\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello, world\",\n\t\t\t},\n\t\t\texpected: []byte(`\"hello, world\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"Object\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: &Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"name\", v: &Value{t: TypeString, s: \"John Doe\"}},\n\t\t\t\t\t\t{k: \"age\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: []byte(`{\"name\":\"John Doe\",\"age\":\"42\"}`),\n\t\t},\n\t\t{\n\t\t\tname: \"Array\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"apple\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: []byte(`[\"apple\",\"42\",true]`),\n\t\t},\n\t\t{\n\t\t\tname: \"String\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello, world\",\n\t\t\t},\n\t\t\texpected: []byte(`\"hello, world\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"Number\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42\",\n\t\t\t},\n\t\t\texpected: []byte(\"42\"),\n\t\t},\n\t\t{\n\t\t\tname: \"True\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\texpected: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"False\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\texpected: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"Null\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\texpected: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"Invalid Type\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: 999,\n\t\t\t},\n\t\t\texpected: nil,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdst := make([]byte, 0, 64)\n\t\t\tresult := tc.value.MarshalTo(dst)\n\t\t\tif !reflect.DeepEqual(result, tc.expected) {\n\t\t\t\tt.Errorf(\"MarshalTo(%+v) = %s, expected %s\", tc.value, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a1999ce8c66e2667b511eb94b5a41394": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantNum  string\n\t\twantRest string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.456e+78\",\n\t\t\twantNum:  \"123.456e+78\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with negative sign\",\n\t\t\tinput:    \"-123.456\",\n\t\t\twantNum:  \"-123.456\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with positive sign\",\n\t\t\tinput:    \"+123.456\",\n\t\t\twantNum:  \"+123.456\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"inf\",\n\t\t\tinput:    \"inf\",\n\t\t\twantNum:  \"inf\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN\",\n\t\t\tinput:    \"NaN\",\n\t\t\twantNum:  \"NaN\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid character\",\n\t\t\tinput:    \"123.4$56\",\n\t\t\twantNum:  \"\",\n\t\t\twantRest: \"123.4$56\",\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\twantNum:  \"\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.wantNum {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) num = %q, want %q\", tc.input, num, tc.wantNum)\n\t\t\t}\n\t\t\tif rest != tc.wantRest {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) rest = %q, want %q\", tc.input, rest, tc.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a2f4f8f4570d0c7dbc3af7e259d2ec73": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"no escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"simple escape characters\",\n\t\t\tinput:    \"hello\\\\\\\"world\\\\\\\\\",\n\t\t\texpected: \"hello\\\"world\\\\\",\n\t\t},\n\t\t{\n\t\t\tname:     \"unicode escape characters\",\n\t\t\tinput:    \"hello\\\\u0041world\",\n\t\t\texpected: \"helloAworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"surrogate pair escape characters\",\n\t\t\tinput:    \"hello\\\\ud83d\\\\ude00world\",\n\t\t\texpected: \"helloüòÄworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"unknown escape characters\",\n\t\t\tinput:    \"hello\\\\xworld\",\n\t\t\texpected: \"hello\\\\xworld\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a1df8c3e567b7b354393345c6fe5b1af": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGet(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tjson     string\n\t\tkeys     []string\n\t\texpected *Value\n\t}{\n\t\t{\n\t\t\tname:     \"Existing key in object\",\n\t\t\tjson:     `{\"key1\": \"value1\", \"key2\": 123}`,\n\t\t\tkeys:     []string{\"key1\"},\n\t\t\texpected: &Value{s: \"value1\", t: TypeString},\n\t\t},\n\t\t{\n\t\t\tname:     \"Non-existing key in object\",\n\t\t\tjson:     `{\"key1\": \"value1\", \"key2\": 123}`,\n\t\t\tkeys:     []string{\"key3\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Existing index in array\",\n\t\t\tjson:     `[\"item1\", \"item2\", \"item3\"]`,\n\t\t\tkeys:     []string{\"1\"},\n\t\t\texpected: &Value{s: \"item2\", t: TypeString},\n\t\t},\n\t\t{\n\t\t\tname:     \"Non-existing index in array\",\n\t\t\tjson:     `[\"item1\", \"item2\", \"item3\"]`,\n\t\t\tkeys:     []string{\"3\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Nested object and array\",\n\t\t\tjson:     `{\"key1\": [{\"subkey1\": \"subvalue1\"}, {\"subkey2\": 456}]}`,\n\t\t\tkeys:     []string{\"key1\", \"1\", \"subkey2\"},\n\t\t\texpected: &Value{v: 456, t: TypeNumber},\n\t\t},\n\t\t{\n\t\t\tname:     \"Nil Value\",\n\t\t\tjson:     `null`,\n\t\t\tkeys:     []string{\"key1\"},\n\t\t\texpected: nil,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tv, _ := Parse(tc.json)\n\t\t\tresult := v.Get(tc.keys...)\n\t\t\tif !compareValues(result, tc.expected) {\n\t\t\t\tt.Errorf(\"Get(%v) = %v, want %v\", tc.keys, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber:\n\t\treturn v1.v == v2.v\n\tcase TypeTrue, TypeFalse:\n\t\treturn v1.v == v2.v\n\tcase TypeObject:\n\t\treturn v1.o.Len() == v2.o.Len()\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, item1 := range v1.a {\n\t\t\tif !compareValues(item1, v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\treturn true\n\t}\n}",
    "a25d25f02f8b86580274389aa74aef8f": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:  \"empty input\",\n\t\t\tinput: \"\",\n\t\t\terr:   fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:  \"max depth exceeded\",\n\t\t\tinput: \"{}\", // Assume MaxDepth is 1\n\t\t\terr:   fmt.Errorf(\"too big depth for the nested JSON; it exceeds 1\"),\n\t\t},\n\t\t{\n\t\t\tname:  \"valid object\",\n\t\t\tinput: `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{s: \"value\", t: typeRawString}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"valid array\",\n\t\t\tinput: `[1,2,3]`,\n\t\t\texpected: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"1\", t: TypeNumber},\n\t\t\t\t\t{s: \"2\", t: TypeNumber},\n\t\t\t\t\t{s: \"3\", t: TypeNumber},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"valid string\",\n\t\t\tinput: `\"hello\"`,\n\t\t\texpected: &Value{\n\t\t\t\ts: \"hello\",\n\t\t\t\tt: typeRawString,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"valid true\",\n\t\t\tinput: \"true\",\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"valid false\",\n\t\t\tinput: \"false\",\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"valid null\",\n\t\t\tinput: \"null\",\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"valid number\",\n\t\t\tinput: \"42\",\n\t\t\texpected: &Value{\n\t\t\t\ts: \"42\",\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv, _, err := parseValue(tt.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tt.err == nil || err.Error() != tt.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif tt.expected == nil {\n\t\t\t\t\tt.Errorf(\"parseValue() = %v, want nil\", v)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif !v.Equal(tt.expected) {\n\t\t\t\t\tt.Errorf(\"parseValue() = %v, want %v\", v, tt.expected)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}",
    "a26ff4e2909ed2e5edc90ee00447e0ab": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello, world\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello, world\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":\"value1\",\"key2\":42}`),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"str1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t\t{t: TypeFalse},\n\t\t\t\t\t{t: TypeNull},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`[\"str1\",42,true,false,null]`),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello, world\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello, world\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42\",\n\t\t\t},\n\t\t\twant: []byte(\"42\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"unknown type\",\n\t\t\tv: &Value{\n\t\t\t\tt: 100,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a2c3d304cfd86c61fd58859dae8a49a4": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"no escape characters\",\n\t\t\tinput:    \"hello world\",\n\t\t\texpected: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"escape double quote\",\n\t\t\tinput:    \"\\\"hello\\\" world\",\n\t\t\texpected: `\"hello\" world`,\n\t\t},\n\t\t{\n\t\t\tname:     \"escape backslash\",\n\t\t\tinput:    \"hello\\\\world\",\n\t\t\texpected: `hello\\world`,\n\t\t},\n\t\t{\n\t\t\tname:     \"escape forward slash\",\n\t\t\tinput:    \"hello/world\",\n\t\t\texpected: `hello/world`,\n\t\t},\n\t\t{\n\t\t\tname:     \"escape backspace\",\n\t\t\tinput:    \"hello\\bworld\",\n\t\t\texpected: `hello\\bworld`,\n\t\t},\n\t\t{\n\t\t\tname:     \"escape form feed\",\n\t\t\tinput:    \"hello\\fworld\",\n\t\t\texpected: `hello\\fworld`,\n\t\t},\n\t\t{\n\t\t\tname:     \"escape newline\",\n\t\t\tinput:    \"hello\\nworld\",\n\t\t\texpected: `hello\\nworld`,\n\t\t},\n\t\t{\n\t\t\tname:     \"escape carriage return\",\n\t\t\tinput:    \"hello\\rworld\",\n\t\t\texpected: `hello\\rworld`,\n\t\t},\n\t\t{\n\t\t\tname:     \"escape tab\",\n\t\t\tinput:    \"hello\\tworld\",\n\t\t\texpected: `hello\\tworld`,\n\t\t},\n\t\t{\n\t\t\tname:     \"escape unicode\",\n\t\t\tinput:    \"hello\\u0123world\",\n\t\t\texpected: \"hello\\u0123world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"escape invalid unicode\",\n\t\t\tinput:    \"hello\\u0123\",\n\t\t\texpected: `hello\\u0123`,\n\t\t},\n\t\t{\n\t\t\tname:     \"escape surrogate pair\",\n\t\t\tinput:    \"hello\\uD800\\uDC00world\",\n\t\t\texpected: \"hello\\U00010000world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"escape invalid surrogate pair\",\n\t\t\tinput:    \"hello\\uD800world\",\n\t\t\texpected: `hello\\uD800world`,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a31ab6e2a85edb4433203a49ee3c665e": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"hello world\",\n\t\t\texpected: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape double quotes\",\n\t\t\tinput:    \"\\\"hello\\\" world\",\n\t\t\texpected: `\"hello\" world`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backslash\",\n\t\t\tinput:    `hello\\\\world`,\n\t\t\texpected: `hello\\\\world`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape forward slash\",\n\t\t\tinput:    `hello\\/world`,\n\t\t\texpected: `hello/world`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backspace\",\n\t\t\tinput:    `hello\\bworld`,\n\t\t\texpected: \"hello\\bworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape form feed\",\n\t\t\tinput:    `hello\\fworld`,\n\t\t\texpected: \"hello\\fworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape newline\",\n\t\t\tinput:    `hello\\nworld`,\n\t\t\texpected: \"hello\\nworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape carriage return\",\n\t\t\tinput:    `hello\\rworld`,\n\t\t\texpected: \"hello\\rworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape tab\",\n\t\t\tinput:    `hello\\tworld`,\n\t\t\texpected: \"hello\\tworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Unicode\",\n\t\t\tinput:    `hello\\u0041world`,\n\t\t\texpected: \"helloAworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Surrogate Pair\",\n\t\t\tinput:    `hello\\uD83D\\uDE00world`,\n\t\t\texpected: \"helloüòÄworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid Unicode Escape\",\n\t\t\tinput:    `hello\\u00world`,\n\t\t\texpected: `hello\\u00world`,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a235cfa8a800f97d978cf0010f204605": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty input\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"too big depth\",\n\t\t\tinput:    \"{}\", // Assuming MaxDepth is 10\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds 10\"),\n\t\t},\n\t\t{\n\t\t\tname:  \"valid object\",\n\t\t\tinput: `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{s: \"value\", t: typeRawString}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"valid array\",\n\t\t\tinput: `[1,2,3]`,\n\t\t\texpected: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"1\", t: TypeNumber},\n\t\t\t\t\t{s: \"2\", t: TypeNumber},\n\t\t\t\t\t{s: \"3\", t: TypeNumber},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"valid string\",\n\t\t\tinput: `\"hello\"`,\n\t\t\texpected: &Value{\n\t\t\t\ts: \"hello\",\n\t\t\t\tt: typeRawString,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid value\",\n\t\t\tinput:    \"invalid\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"unexpected value found: \\\"invalid\\\"\"),\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tv, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, expected %v\", tc.input, err, tc.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else if tc.err != nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = nil, expected %v\", tc.input, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !equalValues(v, tc.expected) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, expected %v\", tc.input, v, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn equalObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase typeRawString, TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber, TypeTrue, TypeFalse:\n\t\treturn v1.s == v2.s\n\tcase TypeNull:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc equalObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i := range o1.kvs {\n\t\tif o1.kvs[i].k != o2.kvs[i].k {\n\t\t\treturn false\n\t\t}\n\t\tif !equalValues(o1.kvs[i].v, o2.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "a26b80d5cf03fc8984eb5057109c119c": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tinput   string\n\t\twantVal *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"empty input\",\n\t\t\tinput:   \"\",\n\t\t\twantVal: nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"depth exceeds max\",\n\t\t\tinput:   \"{}\", // Simulate deep nested JSON\n\t\t\twantVal: nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"parse object\",\n\t\t\tinput:   `{\"key\":\"value\"}`,\n\t\t\twantVal: &Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: &Value{t: typeRawString, s: \"value\"}}}}},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"parse array\",\n\t\t\tinput:   `[1,2,3]`,\n\t\t\twantVal: &Value{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t}},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"parse string\",\n\t\t\tinput:   `\"hello\"`,\n\t\t\twantVal: &Value{t: typeRawString, s: \"hello\"},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"parse true\",\n\t\t\tinput:   \"true\",\n\t\t\twantVal: valueTrue,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"parse false\",\n\t\t\tinput:   \"false\",\n\t\t\twantVal: valueFalse,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"parse null\",\n\t\t\tinput:   \"null\",\n\t\t\twantVal: valueNull,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"parse number\",\n\t\t\tinput:   \"42\",\n\t\t\twantVal: &Value{t: TypeNumber, s: \"42\"},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"parse NaN\",\n\t\t\tinput:   \"NaN\",\n\t\t\twantVal: &Value{t: TypeNumber, s: \"NaN\"},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"unexpected value\",\n\t\t\tinput:   \"unexpected\",\n\t\t\twantVal: nil,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tgotVal, _, err := parseValue(tt.input, c, 0)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !compareValues(gotVal, tt.wantVal) {\n\t\t\t\tt.Errorf(\"parseValue() = %v, want %v\", gotVal, tt.wantVal)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\to1, _ := v1.Object()\n\t\to2, _ := v2.Object()\n\t\treturn compareObjects(o1, o2)\n\tcase TypeArray:\n\t\ta1, _ := v1.Array()\n\t\ta2, _ := v2.Array()\n\t\tif len(a1) != len(a2) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range a1 {\n\t\t\tif !compareValues(a1[i], a2[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeString, TypeNumber, TypeTrue, TypeFalse, TypeNull, typeRawString:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc compareObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i := range o1.kvs {\n\t\tif o1.kvs[i].k != o2.kvs[i].k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(o1.kvs[i].v, o2.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "a3df68aeb767bb59890390b17452dac4": "package fastjson\n\nimport (\n    \"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n    testCases := []struct {\n        name     string\n        input    string\n        expected *Value\n        err      error\n    }{\n        {\n            name:     \"valid object\",\n            input:    `{\"key1\":\"value1\",\"key2\":true,\"key3\":42}`,\n            expected: &Value{t: TypeObject, o: Object{kvs: []kv{\n                {k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n                {k: \"key2\", v: &Value{t: TypeTrue}},\n                {k: \"key3\", v: &Value{t: TypeNumber, s: \"42\"}},\n            }}},\n        {\n            name:  \"missing closing brace\",\n            input: `{\"key1\":\"value1\",\"key2\":true,\"key3\":42`,\n            err:   fmt.Errorf(\"missing '}'\"),\n        },\n        {\n            name:  \"missing colon\",\n            input: `{\"key1\":\"value1\",\"key2\" true,\"key3\":42}`,\n            err:   fmt.Errorf(\"missing ':' after object key\"),\n        },\n        {\n            name:  \"missing object key\",\n            input: `{:true,\"key3\":42}`,\n            err:   fmt.Errorf(`cannot find opening '\"\" for object key`),\n        },\n    }\n\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            c := &cache{}\n            v, _, err := parseObject(tc.input, c, 0)\n            if err != nil {\n                if tc.err == nil || err.Error() != tc.err.Error() {\n                    t.Errorf(\"unexpected error: %v, expected: %v\", err, tc.err)\n                }\n                return\n            }\n            if tc.err != nil {\n                t.Errorf(\"expected error: %v, got nil\", tc.err)\n                return\n            }\n            if !v.Equal(tc.expected) {\n                t.Errorf(\"unexpected result:\\n got: %+v\\nwant: %+v\", v, tc.expected)\n            }\n        })\n    }\n}",
    "a3e48b7e8794256346743472b05097d3": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"hello world\",\n\t\t\texpected: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape double quotes\",\n\t\t\tinput:    \"\\\"hello\\\" world\",\n\t\t\texpected: `\"hello\" world`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backslash\",\n\t\t\tinput:    \"hello\\\\ world\",\n\t\t\texpected: `hello\\\\ world`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape forward slash\",\n\t\t\tinput:    \"hello/ world\",\n\t\t\texpected: `hello/ world`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backspace\",\n\t\t\tinput:    \"hello\\b world\",\n\t\t\texpected: `hello\\b world`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape form feed\",\n\t\t\tinput:    \"hello\\f world\",\n\t\t\texpected: `hello\\f world`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape newline\",\n\t\t\tinput:    \"hello\\n world\",\n\t\t\texpected: `hello\\n world`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape carriage return\",\n\t\t\tinput:    \"hello\\r world\",\n\t\t\texpected: `hello\\r world`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape tab\",\n\t\t\tinput:    \"hello\\t world\",\n\t\t\texpected: `hello\\t world`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape unknown character\",\n\t\t\tinput:    \"hello\\\\x world\",\n\t\t\texpected: `hello\\\\x world`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape invalid Unicode sequence\",\n\t\t\tinput:    \"hello\\\\u123 world\",\n\t\t\texpected: `hello\\\\u123 world`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape surrogate pair\",\n\t\t\tinput:    \"hello\\\\ud83d\\\\ude00 world\",\n\t\t\texpected: `hello\\ud83d\\ude00 world`,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual := unescapeStringBestEffort(tc.input)\n\t\t\tif actual != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a4fba82f647f277618decc132ad6bbbd": "package fastjson\n\nimport (\n    \"reflect\"\n    \"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n    testCases := []struct {\n        name     string\n        input    string\n        expected string\n    }{\n        {\n            name:     \"No escape characters\",\n            input:    \"hello world\",\n            expected: \"hello world\",\n        },\n        {\n            name:     \"Escaped characters\",\n            input:    \"hello\\\\n\\\\t\\\\\\\"world\",\n            expected: \"hello\\n\\t\\\"world\",\n        },\n        {\n            name:     \"Incomplete escape sequence\",\n            input:    \"hello\\\\uworld\",\n            expected: \"hello\\\\uworld\",\n        },\n        {\n            name:     \"Surrogate pair\",\n            input:    \"hello\\\\ud83d\\\\ude00world\",\n            expected: \"helloüòÄworld\",\n        },\n        {\n            name:     \"Unknown escape sequence\",\n            input:    \"hello\\\\xworld\",\n            expected: \"hello\\\\xworld\",\n        },\n    }\n\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            result := unescapeStringBestEffort(tc.input)\n            if !reflect.DeepEqual(result, tc.expected) {\n                t.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n            }\n        })\n    }\n}",
    "a5e01f7b9aa5ec2f7147d5827f47b853": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestTypeString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    Type\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"TypeObject\",\n\t\t\tinput:    TypeObject,\n\t\t\texpected: \"object\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeArray\",\n\t\t\tinput:    TypeArray,\n\t\t\texpected: \"array\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeString\",\n\t\t\tinput:    TypeString,\n\t\t\texpected: \"string\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeNumber\",\n\t\t\tinput:    TypeNumber,\n\t\t\texpected: \"number\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeTrue\",\n\t\t\tinput:    TypeTrue,\n\t\t\texpected: \"true\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeFalse\",\n\t\t\tinput:    TypeFalse,\n\t\t\texpected: \"false\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeNull\",\n\t\t\tinput:    TypeNull,\n\t\t\texpected: \"null\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Unknown Type\",\n\t\t\tinput:    Type(100),\n\t\t\texpected: \"BUG: unknown Value type: 100\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := tc.input.String()\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"expected %q, got %q\", tc.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a33528d332979ee2e87754f0c86d20ab": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty array\",\n\t\t\tinput:    \"[]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{}},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with one value\",\n\t\t\tinput:    \"[42]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"42\"}}},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with multiple values\",\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}, &Value{t: TypeNumber, s: \"2\"}, &Value{t: TypeNumber, s: \"3\"}}},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with missing closing bracket\",\n\t\t\tinput:    \"[1, 2, 3\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"missing ']'\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"array with missing comma\",\n\t\t\tinput:    \"[1 2]\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"missing ',' after array value\"),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{vs: make([]Value, 0, 16)}\n\t\t\tactual, _, err := parseArray(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil {\n\t\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t\t} else if err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"expected error %q, got %q\", tc.err, err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif tc.err != nil {\n\t\t\t\tt.Errorf(\"expected error %q, got nil\", tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !valuesEqual(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"expected %+v, got %+v\", tc.expected, actual)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc valuesEqual(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeNull, TypeTrue, TypeFalse:\n\t\treturn true\n\tcase TypeNumber, TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, v := range v1.a {\n\t\t\tif !valuesEqual(v, v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeObject:\n\t\treturn v1.o.Len() == v2.o.Len() && v1.o.keysUnescaped == v2.o.keysUnescaped\n\tdefault:\n\t\tpanic(fmt.Errorf(\"unknown Type: %d\", v1.t))\n\t}\n}",
    "a5b8556bdc21d1ed32652816cb936193": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv:    &Value{t: TypeNull},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv:    &Value{t: TypeTrue},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv:    &Value{t: TypeFalse},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv:    &Value{t: TypeString, s: \"hello\"},\n\t\t\twant: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv:    &Value{t: TypeNumber, s: \"42\"},\n\t\t\twant: []byte(\"42\"),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: &Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":\"value1\",\"key2\":42}`),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"value1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t\t{t: TypeFalse},\n\t\t\t\t\t{t: TypeNull},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`[\"value1\",42,true,false,null]`),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := make([]byte, 0, 64)\n\t\t\tgot := tt.v.MarshalTo(dst)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %q, want %q\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a811fb62916e790dd566077bd6a35109": "package fastjson\n\nimport (\n    \"testing\"\n)\n\nfunc TestTypeString(t *testing.T) {\n    testCases := []struct {\n        name  string\n        input Type\n        want  string\n    }{\n        {\"TypeObject\", TypeObject, \"object\"},\n        {\"TypeArray\", TypeArray, \"array\"},\n        {\"TypeString\", TypeString, \"string\"},\n        {\"TypeNumber\", TypeNumber, \"number\"},\n        {\"TypeTrue\", TypeTrue, \"true\"},\n        {\"TypeFalse\", TypeFalse, \"false\"},\n        {\"TypeNull\", TypeNull, \"\"},\n    }\n\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            got := tc.input.String()\n            if got != tc.want {\n                t.Errorf(\"Type.String() = %v, want %v\", got, tc.want)\n            }\n        })\n    }\n}",
    "a9e232b93b484e6e3469207334efc237": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCache_getValue(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tc    *cache\n\t\twant *Value\n\t}{\n\t\t{\n\t\t\tname: \"empty cache\",\n\t\t\tc:    &cache{},\n\t\t\twant: &Value{},\n\t\t},\n\t\t{\n\t\t\tname: \"cache with one value\",\n\t\t\tc: &cache{\n\t\t\t\tvs: []Value{\n\t\t\t\t\t{s: \"hello\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: &Value{s: \"hello\"},\n\t\t},\n\t\t{\n\t\t\tname: \"cache with multiple values\",\n\t\t\tc: &cache{\n\t\t\t\tvs: []Value{\n\t\t\t\t\t{s: \"hello\"}, {s: \"world\"}, {s: \"foo\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: &Value{s: \"foo\"},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.c.getValue()\n\t\t\tif got.s != tt.want.s {\n\t\t\t\tt.Errorf(\"cache.getValue() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a68b8acf83004d4b6f250b3f0d6d4899": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: \"{}\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"simple object\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":123}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"missing closing brace\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":123`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:  \"missing object key\",\n\t\t\tinput: `{:123}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:  \"invalid object value\",\n\t\t\tinput: `{\"key1\":\"value1\",key2:123}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tgot, _, err := parseObject(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseObject(%q) error = %v, expected error: %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif err == nil && !got.Equal(tc.expected) {\n\t\t\t\tt.Errorf(\"parseObject(%q) = %v, expected %v\", tc.input, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a70e42d00ffb9791be3db5ccdfec5efc": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestMarshalTo(t *testing.T) {\n\ttestCases := []struct {\n\t\tname   string\n\t\tv      *Value\n\t\texpect []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: &Value{\n\t\t\t\ts: \"hello\",\n\t\t\t\tt: typeRawString,\n\t\t\t},\n\t\t\texpect: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{s: \"value1\", t: TypeString}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{s: \"value2\", t: TypeString}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\texpect: []byte(`{\"key1\":\"value1\",\"key2\":\"value2\"}`),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"elem1\", t: TypeString},\n\t\t\t\t\t{s: \"elem2\", t: TypeString},\n\t\t\t\t\t{s: \"elem3\", t: TypeString},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\texpect: []byte(`[\"elem1\",\"elem2\",\"elem3\"]`),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: &Value{\n\t\t\t\ts: \"hello world\",\n\t\t\t\tt: TypeString,\n\t\t\t},\n\t\t\texpect: []byte(`\"hello world\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: &Value{\n\t\t\t\ts: \"42\",\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\texpect: []byte(\"42\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\texpect: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\texpect: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\texpect: []byte(\"null\"),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdst := make([]byte, 0, 100)\n\t\t\tresult := tc.v.MarshalTo(dst)\n\t\t\tif !reflect.DeepEqual(result, tc.expect) {\n\t\t\t\tt.Errorf(\"MarshalTo(%+v) = %s, expect %s\", tc.v, result, tc.expect)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a5e6d71fa8c194773dae5aec918f7650": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid object\",\n\t\t\tinput:    `{\"key1\":\"value1\",\"key2\":42}`,\n\t\t\texpected: &Value{t: TypeObject, o: Object{kvs: []kv{{\"key1\", &Value{t: TypeString, s: \"value1\"}}, {\"key2\", &Value{t: TypeNumber, s: \"42\"}}}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty object\",\n\t\t\tinput:    \"{}\",\n\t\t\texpected: &Value{t: TypeObject, o: Object{kvs: nil}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:  \"missing closing brace\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42`,\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"missing key quote\",\n\t\t\tinput: `{key1:\"value1\",\"key2\":42}`,\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"missing colon\",\n\t\t\tinput: `{\"key1\" \"value1\",\"key2\":42}`,\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"missing comma\",\n\t\t\tinput: `{\"key1\":\"value1\" \"key2\":42}`,\n\t\t\terr:   true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tv, _, err := parseObject(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(v, tc.expected) {\n\t\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", tc.input, v, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "aa6b9126a55855fa7d61ff927be5d07b": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestObjectUnescapeKeys(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tobject   *Object\n\t\texpected *Object\n\t}{\n\t\t{\n\t\t\tname: \"keys already unescaped\",\n\t\t\tobject: &Object{\n\t\t\t\tkvs:           []kv{{k: \"key1\", v: &Value{}}, {k: \"key2\", v: &Value{}}},\n\t\t\t\tkeysUnescaped: true,\n\t\t\t},\n\t\t\texpected: &Object{\n\t\t\t\tkvs:           []kv{{k: \"key1\", v: &Value{}}, {k: \"key2\", v: &Value{}}},\n\t\t\t\tkeysUnescaped: true,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"keys need to be unescaped\",\n\t\t\tobject: &Object{\n\t\t\t\tkvs:           []kv{{k: `k\\\"ey1`, v: &Value{}}, {k: `k\\\"ey2`, v: &Value{}}},\n\t\t\t\tkeysUnescaped: false,\n\t\t\t},\n\t\t\texpected: &Object{\n\t\t\t\tkvs:           []kv{{k: `key1`, v: &Value{}}, {k: `key2`, v: &Value{}}},\n\t\t\t\tkeysUnescaped: true,\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\ttc.object.unescapeKeys()\n\t\t\tif !reflect.DeepEqual(tc.object, tc.expected) {\n\t\t\t\tt.Errorf(\"unescapeKeys() = %v, want %v\", tc.object, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "abaa0a9b4a1101f0ffe6fbdd0d47f13e": "package fastjson\n\nimport (\n    \"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n    tests := []struct {\n        name string\n        input string\n        want string\n    }{\n        {\n            name: \"empty string\",\n            input: \"\",\n            want: \"\",\n        },\n        {\n            name: \"no whitespace\",\n            input: \"hello\",\n            want: \"hello\",\n        },\n        {\n            name: \"leading whitespace\",\n            input: \"   hello\",\n            want: \"hello\",\n        },\n        {\n            name: \"trailing whitespace\",\n            input: \"hello   \",\n            want: \"hello   \",\n        },\n        {\n            name: \"leading and trailing whitespace\",\n            input: \"   hello   \",\n            want: \"hello   \",\n        },\n        {\n            name: \"mixed whitespace\",\n            input: \"\\t \\r\\nhello\\t \\n\",\n            want: \"hello\\t \\n\",\n        },\n    }\n\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            got := skipWSSlow(tt.input)\n            if got != tt.want {\n                t.Errorf(\"skipWSSlow(%q) = %q, want %q\", tt.input, got, tt.want)\n            }\n        })\n    }\n}",
    "ab7254c63d697a2098f1843de7716d02": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetFloat64(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tjson     string\n\t\tkeys     []string\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"Existing float64 value\",\n\t\t\tjson:     `{\"key1\": 3.14}`,\n\t\t\tkeys:     []string{\"key1\"},\n\t\t\texpected: 3.14,\n\t\t},\n\t\t{\n\t\t\tname:     \"Non-existing key\",\n\t\t\tjson:     `{\"key1\": 3.14}`,\n\t\t\tkeys:     []string{\"key2\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid value type\",\n\t\t\tjson:     `{\"key1\": \"foo\"}`,\n\t\t\tkeys:     []string{\"key1\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Array index access\",\n\t\t\tjson:     `{\"key1\": [1.23, 4.56]}`,\n\t\t\tkeys:     []string{\"key1\", \"1.0\"},\n\t\t\texpected: 4.56,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tv, err := Parse(tc.json)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"Failed to parse JSON: %v\", err)\n\t\t\t}\n\n\t\t\tresult := v.GetFloat64(tc.keys...)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"GetFloat64(%v) = %f, want %f\", tc.keys, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "aadbb8a32afe4362ea210a5afd1631b3": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueGet(t *testing.T) {\n\t// Test cases\n\ttestCases := []struct {\n\t\tname     string\n\t\tv        *Value\n\t\tkeys     []string\n\t\texpected *Value\n\t}{\n\t\t{\n\t\t\tname:     \"Existing keys\",\n\t\t\tv:        &Value{t: TypeObject, o: &Object{kvs: []kv{{\"key1\", &Value{t: TypeNumber, s: \"42\"}}, {\"key2\", &Value{t: TypeString, s: \"value2\"}}}},\n\t\t\tkeys:     []string{\"key1\", \"key2\"},\n\t\t\texpected: &Value{t: TypeString, s: \"value2\"},\n\t\t},\n\t\t{\n\t\t\tname:     \"Non-existing key\",\n\t\t\tv:        &Value{t: TypeObject, o: &Object{kvs: []kv{{\"key1\", &Value{t: TypeNumber, s: \"42\"}}, {\"key2\", &Value{t: TypeString, s: \"value2\"}}}},\n\t\t\tkeys:     []string{\"key3\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Array index\",\n\t\t\tv:        &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}, &Value{t: TypeString, s: \"two\"}}},\n\t\t\tkeys:     []string{\"1\"},\n\t\t\texpected: &Value{t: TypeString, s: \"two\"},\n\t\t},\n\t\t{\n\t\t\tname:     \"Array index out of range\",\n\t\t\tv:        &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}, &Value{t: TypeString, s: \"two\"}}},\n\t\t\tkeys:     []string{\"2\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Nil value\",\n\t\t\tv:        nil,\n\t\t\tkeys:     []string{\"key1\"},\n\t\t\texpected: nil,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := tc.v.Get(tc.keys...)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"Get(%v) = %v, expected %v\", tc.keys, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "ac3e7c0295a352264e9924a302df5bfd": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string // expected key, rest\n\t}{\n\t\t{\n\t\t\tname:     \"basic key\",\n\t\t\tinput:    `\"key\":value`,\n\t\t\texpected: []string{\"key\", `:value`},\n\t\t},\n\t\t{\n\t\t\tname:     \"key with escape\",\n\t\t\tinput:    `\"key\\\"with\\\"escape\":value`,\n\t\t\texpected: []string{`key\"with\"escape`, `:value`},\n\t\t},\n\t\t{\n\t\t\tname:     \"missing closing quote\",\n\t\t\tinput:    `\"key without closing quote`,\n\t\t\texpected: []string{`\"key without closing quote`, \"\"},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tkey, rest, err := parseRawKey(tc.input)\n\t\t\tif err != nil {\n\t\t\t\tif len(tc.expected) == 2 && tc.expected[1] == \"\" {\n\t\t\t\t\t// Expected error for missing closing quote\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t}\n\n\t\t\tif key != tc.expected[0] {\n\t\t\t\tt.Errorf(\"expected key %q, got %q\", tc.expected[0], key)\n\t\t\t}\n\n\t\t\tif rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"expected rest %q, got %q\", tc.expected[1], rest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "adf277bf36616eaa81aa73858644bb63": "package fastjson_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/valyala/fastjson\"\n)\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tt    fastjson.Type\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"TypeObject\",\n\t\t\tt:    fastjson.TypeObject,\n\t\t\twant: \"object\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeArray\",\n\t\t\tt:    fastjson.TypeArray,\n\t\t\twant: \"array\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeString\",\n\t\t\tt:    fastjson.TypeString,\n\t\t\twant: \"string\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeNumber\",\n\t\t\tt:    fastjson.TypeNumber,\n\t\t\twant: \"number\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeTrue\",\n\t\t\tt:    fastjson.TypeTrue,\n\t\t\twant: \"true\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeFalse\",\n\t\t\tt:    fastjson.TypeFalse,\n\t\t\twant: \"false\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeNull\",\n\t\t\tt:    fastjson.TypeNull,\n\t\t\twant: \"null\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.t.String(); got != tt.want {\n\t\t\t\tt.Errorf(\"Type.String() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "ac7b78a14ebcaa3e2da32258ce951a82": "package fastjson\n\nimport (\n    \"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n    testCases := []struct {\n        name     string\n        input    string\n        expected string\n        remain   string\n        err      bool\n    }{\n        {\n            name:     \"Valid integer\",\n            input:    \"123\",\n            expected: \"123\",\n            remain:   \"\",\n            err:      false,\n        },\n        {\n            name:     \"Valid float\",\n            input:    \"3.14\",\n            expected: \"3.14\",\n            remain:   \"\",\n            err:      false,\n        },\n        {\n            name:     \"Valid negative number\",\n            input:    \"-42\",\n            expected: \"-42\",\n            remain:   \"\",\n            err:      false,\n        },\n        {\n            name:     \"Valid number with exponent\",\n            input:    \"1.2e+3\",\n            expected: \"1.2e+3\",\n            remain:   \"\",\n            err:      false,\n        },\n        {\n            name:     \"Invalid number with non-digit character\",\n            input:    \"123a\",\n            expected: \"\",\n            remain:   \"a\",\n            err:      true,\n        },\n        {\n            name:     \"Empty input\",\n            input:    \"\",\n            expected: \"\",\n            remain:   \"\",\n            err:      false,\n        },\n    }\n\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            actual, remain, err := parseRawNumber(tc.input)\n            if tc.err && err == nil {\n                t.Errorf(\"Expected error, but got none\")\n                return\n            }\n            if !tc.err && err != nil {\n                t.Errorf(\"Unexpected error: %v\", err)\n                return\n            }\n            if actual != tc.expected {\n                t.Errorf(\"Expected %q, got %q\", tc.expected, actual)\n            }\n            if remain != tc.remain {\n                t.Errorf(\"Expected remaining %q, got %q\", tc.remain, remain)\n            }\n        })\n    }\n}",
    "ae4d8039b488babc11d0ff7d99cdce09": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_getKV(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\to    *Object\n\t\twant *kv\n\t}{\n\t\t{\n\t\t\tname: \"empty kvs\",\n\t\t\to:    &Object{},\n\t\t\twant: &kv{},\n\t\t},\n\t\t{\n\t\t\tname: \"kvs with capacity\",\n\t\t\to: &Object{\n\t\t\t\tkvs: make([]kv, 1, 2),\n\t\t\t},\n\t\t\twant: &kv{},\n\t\t},\n\t\t{\n\t\t\tname: \"kvs with more elements\",\n\t\t\to: &Object{\n\t\t\t\tkvs: make([]kv, 2, 2),\n\t\t\t},\n\t\t\twant: &kv{},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.o.getKV(); !compareKVs(got, tt.want) {\n\t\t\t\tt.Errorf(\"Object.getKV() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareKVs(a, b *kv) bool {\n\tif a == nil && b == nil {\n\t\treturn true\n\t}\n\tif a == nil || b == nil {\n\t\treturn false\n\t}\n\treturn a.k == b.k && a.v == b.v\n}",
    "abc7cd4d914a92eeb50b3ac0d0168973": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantNum  string\n\t\twantRest string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid positive integer\",\n\t\t\tinput:    \"123456\",\n\t\t\twantNum:  \"123456\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid negative integer\",\n\t\t\tinput:    \"-123456\",\n\t\t\twantNum:  \"-123456\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid float\",\n\t\t\tinput:    \"3.14\",\n\t\t\twantNum:  \"3.14\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid scientific notation\",\n\t\t\tinput:    \"1.23e4\",\n\t\t\twantNum:  \"1.23e4\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid character\",\n\t\t\tinput:    \"123a\",\n\t\t\twantNum:  \"\",\n\t\t\twantRest: \"123a\",\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"leading invalid character\",\n\t\t\tinput:    \"a123\",\n\t\t\twantNum:  \"\",\n\t\t\twantRest: \"a123\",\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"leading inf\",\n\t\t\tinput:    \"inf123\",\n\t\t\twantNum:  \"inf\",\n\t\t\twantRest: \"123\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"leading nan\",\n\t\t\tinput:    \"nan123\",\n\t\t\twantNum:  \"nan\",\n\t\t\twantRest: \"123\",\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.wantNum {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) num = %q, want %q\", tc.input, num, tc.wantNum)\n\t\t\t}\n\t\t\tif rest != tc.wantRest {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) rest = %q, want %q\", tc.input, rest, tc.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "ae9123f503428ba5692e3ea27ac17461": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantKey  string\n\t\twantRest string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello\"world`,\n\t\t\twantKey:  `\"hello\"`,\n\t\t\twantRest: `world`,\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hel\\\"lo\"world`,\n\t\t\twantKey:  `\"hel\\\"lo\"`,\n\t\t\twantRest: `world`,\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hel\\\"l\\\"o\"world`,\n\t\t\twantKey:  `\"hel\\\"l\\\"o\"`,\n\t\t\twantRest: `world`,\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing closing quote\",\n\t\t\tinput:    `\"hello`,\n\t\t\twantKey:  \"\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tkey, rest, err := parseRawString(tt.input)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif key != tt.wantKey {\n\t\t\t\tt.Errorf(\"parseRawString() key = %q, want %q\", key, tt.wantKey)\n\t\t\t}\n\t\t\tif rest != tt.wantRest {\n\t\t\t\tt.Errorf(\"parseRawString() rest = %q, want %q\", rest, tt.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "ae0b572cc88c22817952f3cafbbcef57": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname    string\n\t\tinput   string\n\t\twantVal *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty input\",\n\t\t\tinput: \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"depth too big\",\n\t\t\tinput: \"{}\", // Depth is 1 here\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"parse object\",\n\t\t\tinput: `{\"key\":\"value\"}`,\n\t\t\twantVal: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{s: \"value\", t: typeRawString}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"parse array\",\n\t\t\tinput: `[1,2,3]`,\n\t\t\twantVal: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"1\", t: TypeNumber},\n\t\t\t\t\t{s: \"2\", t: TypeNumber},\n\t\t\t\t\t{s: \"3\", t: TypeNumber},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"parse string\",\n\t\t\tinput: `\"hello\"`,\n\t\t\twantVal: &Value{\n\t\t\t\ts: \"hello\",\n\t\t\t\tt: typeRawString,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"parse true\",\n\t\t\tinput: \"true\",\n\t\t\twantVal: valueTrue,\n\t\t},\n\t\t{\n\t\t\tname:  \"parse false\",\n\t\t\tinput: \"false\",\n\t\t\twantVal: valueFalse,\n\t\t},\n\t\t{\n\t\t\tname:  \"parse null\",\n\t\t\tinput: \"null\",\n\t\t\twantVal: valueNull,\n\t\t},\n\t\t{\n\t\t\tname:  \"parse number\",\n\t\t\tinput: \"42\",\n\t\t\twantVal: &Value{\n\t\t\t\ts: \"42\",\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tgotVal, _, err := parseValue(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tc.wantErr && !tc.wantVal.Equal(gotVal) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", tc.input, gotVal, tc.wantVal)\n\t\t\t}\n\t\t})\n\t}\n}",
    "af10a7f04b7057fbe477a26022125bc6": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"Simple string\",\n\t\t\tinput:    `\"hello world\"`,\n\t\t\texpected: []string{\"hello world\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"String with escaped quote\",\n\t\t\tinput:    `\"hello \\\"world\\\"\"`,\n\t\t\texpected: []string{\"hello \\\"world\\\"\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"String with multiple escaped quotes\",\n\t\t\tinput:    `\"hello \\\"world\\\" \\\"foo\\\"\"`,\n\t\t\texpected: []string{\"hello \\\"world\\\" \\\"foo\\\"\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"String with no closing quote\",\n\t\t\tinput:    `\"hello world`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult1, result2, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif result1 != tc.expected[0] {\n\t\t\t\tt.Errorf(\"parseRawString() result1 = %v, expected %v\", result1, tc.expected[0])\n\t\t\t}\n\t\t\tif result2 != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawString() result2 = %v, expected %v\", result2, tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "ae9693e983789f3217631b97120308a1": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantNum  string\n\t\twantRest string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.45e+67\",\n\t\t\twantNum:  \"123.45e+67\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with sign\",\n\t\t\tinput:    \"-123.45e+67\",\n\t\t\twantNum:  \"-123.45e+67\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with 'inf'\",\n\t\t\tinput:    \"inf\",\n\t\t\twantNum:  \"inf\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with 'nan'\",\n\t\t\tinput:    \"nan\",\n\t\t\twantNum:  \"nan\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number\",\n\t\t\tinput:    \"abc\",\n\t\t\twantNum:  \"\",\n\t\t\twantRest: \"abc\",\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tt.input)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tt.input, err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tt.wantNum {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) num = %q, want %q\", tt.input, num, tt.wantNum)\n\t\t\t}\n\t\t\tif rest != tt.wantRest {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) rest = %q, want %q\", tt.input, rest, tt.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "afef6c05b46268a259be59a5a9fca661": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: &Value{\n\t\t\t\ts: \"hello\",\n\t\t\t\tt: typeRawString,\n\t\t\t},\n\t\t\twant: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{s: \"value1\", t: TypeString}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{s: \"value2\", t: TypeString}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":\"value1\",\"key2\":\"value2\"}`),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"value1\", t: TypeString},\n\t\t\t\t\t{s: \"value2\", t: TypeString},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\twant: []byte(`[\"value1\",\"value2\"]`),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: &Value{\n\t\t\t\ts: \"hello\",\n\t\t\t\tt: TypeString,\n\t\t\t},\n\t\t\twant: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: &Value{\n\t\t\t\ts: \"42\",\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\twant: []byte(\"42\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %q, want %q\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b0b5fd686ad16fef8e8d59f74a9f67c4": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetFunction(t *testing.T) {\n\t// Test cases for the Get function\n\ttestCases := []struct {\n\t\tname     string\n\t\tjson     string\n\t\tkeys     []string\n\t\texpected *Value\n\t}{\n\t\t{\n\t\t\tname: \"Get from object\",\n\t\t\tjson: `{\"a\":1,\"b\":2,\"c\":{\"d\":3}}`,\n\t\t\tkeys: []string{\"c\", \"d\"},\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"3\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"Get from array\",\n\t\t\tjson: `[1,2,{\"a\":3}]`,\n\t\t\tkeys: []string{\"2\", \"a\"},\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"3\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"Get non-existing key\",\n\t\t\tjson: `{\"a\":1,\"b\":2}`,\n\t\t\tkeys: []string{\"c\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Get from invalid type\",\n\t\t\tjson: `1`,\n\t\t\tkeys: []string{\"a\"},\n\t\t\texpected: nil,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tv, err := Parse(tc.json)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tresult := v.Get(tc.keys...)\n\t\t\tif !compareValues(result, tc.expected) {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tc.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(a, b *Value) bool {\n\tif a == nil && b == nil {\n\t\treturn true\n\t}\n\tif a == nil || b == nil {\n\t\treturn false\n\t}\n\treturn a.t == b.t && a.s == b.s\n}",
    "b19489aa7c40cead98db30a214543112": "package fastjson\n\nimport (\n    \"reflect\"\n    \"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n    testCases := []struct {\n        name     string\n        input    string\n        wantNum  string\n        wantRest string\n        wantErr  bool\n    }{\n        {\n            name:     \"valid number\",\n            input:    \"123.45e+6\",\n            wantNum:  \"123.45e+6\",\n            wantRest: \"\",\n            wantErr:  false,\n        },\n        {\n            name:     \"number with trailing characters\",\n            input:    \"123.45e+6abc\",\n            wantNum:  \"123.45e+6\",\n            wantRest: \"abc\",\n            wantErr:  false,\n        },\n        {\n            name:     \"invalid number\",\n            input:    \"abc\",\n            wantNum:  \"\",\n            wantRest: \"abc\",\n            wantErr:  true,\n        },\n        {\n            name:     \"empty string\",\n            input:    \"\",\n            wantNum:  \"\",\n            wantRest: \"\",\n            wantErr:  true,\n        },\n        {\n            name:     \"leading sign only\",\n            input:    \"-\",\n            wantNum:  \"\",\n            wantRest: \"-\",\n            wantErr:  true,\n        },\n        {\n            name:     \"inf and nan\",\n            input:    \"inf123\",\n            wantNum:  \"inf\",\n            wantRest: \"123\",\n            wantErr:  false,\n        },\n    }\n\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            gotNum, gotRest, gotErr := parseRawNumber(tc.input)\n            if gotNum != tc.wantNum {\n                t.Errorf(\"parseRawNumber(%q) gotNum = %q, want %q\", tc.input, gotNum, tc.wantNum)\n            }\n            if gotRest != tc.wantRest {\n                t.Errorf(\"parseRawNumber(%q) gotRest = %q, want %q\", tc.input, gotRest, tc.wantRest)\n            }\n            if (gotErr != nil) != tc.wantErr {\n                t.Errorf(\"parseRawNumber(%q) gotErr = %v, wantErr = %t\", tc.input, gotErr, tc.wantErr)\n            }\n        })\n    }\n}",
    "b04b74319d940f0635ec6c3ab0c4f8db": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tinput   string\n\t\twant    []*Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty array\",\n\t\t\tinput: \"[]\",\n\t\t\twant:  []*Value{},\n\t\t},\n\t\t{\n\t\t\tname:  \"array with values\",\n\t\t\tinput: \"[1, 2, 3]\",\n\t\t\twant: []*Value{\n\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:    \"missing closing bracket\",\n\t\t\tinput:   \"[1, 2, 3\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"missing comma\",\n\t\t\tinput:   \"[1 2]\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with null values\",\n\t\t\tinput: \"[null, null, null]\",\n\t\t\twant: []*Value{\n\t\t\t\t{t: TypeNull},\n\t\t\t\t{t: TypeNull},\n\t\t\t\t{t: TypeNull},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"array with mixed types\",\n\t\t\tinput: \"[1, true, null, \"abc\"]\",\n\t\t\twant: []*Value{\n\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t{t: TypeTrue},\n\t\t\t\t{t: TypeNull},\n\t\t\t\t{t: TypeString, s: \"abc\"},\n\t\t\t},\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseArray(tt.input, c, 0)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif len(got.a) != len(tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got.a, tt.want)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tfor i := range got.a {\n\t\t\t\tif got.a[i].t != tt.want[i].t || got.a[i].s != tt.want[i].s {\n\t\t\t\t\tt.Errorf(\"parseArray() got[%d] = %v, want %v\", i, got.a[i], tt.want[i])\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}",
    "abf55f53ceb89bc55eca47b43f24c5c4": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty object\",\n\t\t\tinput:    \"{}\",\n\t\t\texpected: &Value{t: TypeObject, o: Object{}},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with one key-value pair\",\n\t\t\tinput: `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{t: TypeString, s: \"value\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with multiple key-value pairs\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":123,\"key3\":true}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t\t{k: \"key3\", v: &Value{t: TypeTrue}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with nested object\",\n\t\t\tinput: `{\"key1\":{\"subkey\":\"subvalue\"},\"key2\":123}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{\n\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t{k: \"subkey\", v: &Value{t: TypeString, s: \"subvalue\"}},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with nested array\",\n\t\t\tinput: `{\"key1\":[1,2,3],\"key2\":true}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{\n\t\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeTrue}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with invalid key\",\n\t\t\tinput: `{key:\"value\"}`,\n\t\t\terr:   fmt.Errorf(`cannot find opening '\"\" for object key`),\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing colon\",\n\t\t\tinput: `{\"key\" \"value\"}`,\n\t\t\terr:   fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing comma\",\n\t\t\tinput: `{\"key1\":\"value1\" \"key2\":123}`,\n\t\t\terr:   fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\t\t{\n\t\t\tname:  \"object with unexpected end\",\n\t\t\tinput: `{\"key1\":\"value1\",`,\n\t\t\terr:   fmt.Errorf(\"unexpected end of object\"),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tactual, _, err := parseObject(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil {\n\t\t\t\t\tt.Errorf(\"parseObject(%q) returned error: %v\", tc.input, err)\n\t\t\t\t} else if err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseObject(%q) returned error %v, expected %v\", tc.input, err, tc.err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif tc.err != nil {\n\t\t\t\tt.Errorf(\"parseObject(%q) did not return expected error: %v\", tc.input, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseObject(%q) returned %v, expected %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn compareObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn compareArrays(v1.a, v2.a)\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber, TypeTrue, TypeFalse:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\treturn true\n\t}\n}\n\nfunc compareObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc compareArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tif !compareValues(v1, a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "b514df76d6af14fc4f444c942cde5ac8": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"Empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"No whitespace\",\n\t\t\tinput:    \"abcd\",\n\t\t\texpected: \"abcd\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Leading whitespace\",\n\t\t\tinput:    \"   abcd\",\n\t\t\texpected: \"abcd\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Trailing whitespace\",\n\t\t\tinput:    \"abcd   \",\n\t\t\texpected: \"abcd\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Whitespace in the middle\",\n\t\t\tinput:    \"ab  cd\",\n\t\t\texpected: \"cd\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Only whitespace\",\n\t\t\tinput:    \"   \",\n\t\t\texpected: \"\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := skipWSSlow(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"skipWSSlow(%q) = %q, want %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b2cf84a6aeb0b423ad46a2a92b4babdf": "package fastjson\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    *Value\n\t\texpected []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tinput: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\texpected: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tinput: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: []byte(`{\"key1\":\"value1\",\"key2\":42}`),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tinput: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"item1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: []byte(`[\"item1\",42,true]`),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tinput: &Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\texpected: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tinput: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42\",\n\t\t\t},\n\t\t\texpected: []byte(\"42\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"true\",\n\t\t\tinput:    &Value{t: TypeTrue},\n\t\t\texpected: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"false\",\n\t\t\tinput:    &Value{t: TypeFalse},\n\t\t\texpected: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"null\",\n\t\t\tinput:    &Value{t: TypeNull},\n\t\t\texpected: []byte(\"null\"),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdst := make([]byte, 0, 100)\n\t\t\tresult := tc.input.MarshalTo(dst)\n\t\t\tif !bytes.Equal(result, tc.expected) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %q, expected %q\", result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b450486b468a9852733fdb3976569a3c": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetFloat64(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\tkeys     []string\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"valid float64\",\n\t\t\tvalue:    &Value{s: \"3.14\", t: TypeNumber},\n\t\t\tkeys:     []string{},\n\t\t\texpected: 3.14,\n\t\t},\n\t\t{\n\t\t\tname:     \"non-existing keys\",\n\t\t\tvalue:    &Value{s: \"3.14\", t: TypeNumber},\n\t\t\tkeys:     []string{\"non\", \"existing\", \"keys\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid value type\",\n\t\t\tvalue:    &Value{s: \"true\", t: TypeTrue},\n\t\t\tkeys:     []string{},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"nil value\",\n\t\t\tvalue:    nil,\n\t\t\tkeys:     []string{},\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := tt.value.GetFloat64(tt.keys...)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"GetFloat64(%v) = %v, expected %v\", tt.keys, result, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b274ce25e34f5619bedd4d1f51c52eb9": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty array\",\n\t\t\tinput:    \"[]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{}},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with one element\",\n\t\t\tinput: \"[42]\",\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with multiple elements\",\n\t\t\tinput: \"[1, true, null]\",\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t\t{t: TypeNull},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with nested array\",\n\t\t\tinput: \"[[1, 2], [3, 4]]\",\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t\t\t\t{t: TypeNumber, s: \"4\"},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with trailing comma\",\n\t\t\tinput: \"[1, 2,]\",\n\t\t\terr:    ErrMissingComma,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with missing comma\",\n\t\t\tinput: \"[1 2]\",\n\t\t\terr:    ErrMissingComma,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tv, _, err := parseArray(tc.input, c, 0)\n\t\t\tif err != tc.err {\n\t\t\t\tt.Errorf(\"expected error %v, got %v\", tc.err, err)\n\t\t\t}\n\t\t\tif !valuesEqual(v, tc.expected) {\n\t\t\t\tt.Errorf(\"expected %#v, got %#v\", tc.expected, v)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc valuesEqual(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeNull, TypeTrue, TypeFalse:\n\t\treturn true\n\tcase TypeNumber, TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !valuesEqual(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeObject:\n\t\treturn v1.o.Len() == v2.o.Len() && v1.o.keysUnescaped == v2.o.keysUnescaped\n\tdefault:\n\t\tpanic(\"unknown type\")\n\t}\n}",
    "b23f165790dec92592a71e74e8fd8fd3": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype testCase struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}\n\n\ttestCases := []testCase{\n\t\t{\n\t\t\tname:     \"empty array\",\n\t\t\tinput:    \"[]\",\n\t\t\texpected: &Value{t: TypeArray},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with one element\",\n\t\t\tinput:    \"[1]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}}},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with multiple elements\",\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}, &Value{t: TypeNumber, s: \"2\"}, &Value{t: TypeNumber, s: \"3\"}}},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with trailing comma\",\n\t\t\tinput:    \"[1, 2, 3,]\",\n\t\t\texpected: nil,\n\t\t\terr:      errMissingArrayValue,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with missing closing bracket\",\n\t\t\tinput:    \"[1, 2, 3\",\n\t\t\texpected: nil,\n\t\t\terr:      errMissingArrayClosingBracket,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tactual, _, err := parseArray(tc.input, c, 0)\n\t\t\tif err != tc.err {\n\t\t\t\tt.Errorf(\"Expected error %v, got %v\", tc.err, err)\n\t\t\t}\n\t\t\tif !equalValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", tc.expected, actual)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeNull, TypeTrue, TypeFalse:\n\t\treturn true\n\tcase TypeNumber, TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeObject:\n\t\treturn equalObjects(&v1.o, &v2.o)\n\tdefault:\n\t\tpanic(\"unsupported type\")\n\t}\n}\n\nfunc equalObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i := range o1.kvs {\n\t\tif o1.kvs[i].k != o2.kvs[i].k {\n\t\t\treturn false\n\t\t}\n\t\tif !equalValues(o1.kvs[i].v, o2.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "b2c1c16f19f788e01adcb94f55cad0b0": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"empty object\",\n\t\t\tinput:    `{}`,\n\t\t\texpected: &Value{t: TypeObject, o: Object{}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"object with one key-value pair\",\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{t: TypeObject, o: Object{kvs: []kv{{\"key\", &Value{t: TypeString, s: \"value\"}}}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"object with multiple key-value pairs\",\n\t\t\tinput:    `{\"key1\":\"value1\",\"key2\":42,\"key3\":true}`,\n\t\t\texpected: &Value{t: TypeObject, o: Object{kvs: []kv{{\"key1\", &Value{t: TypeString, s: \"value1\"}}, {\"key2\", &Value{t: TypeNumber, s: \"42\"}}, {\"key3\", &Value{t: TypeTrue}}}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:  \"missing closing brace\",\n\t\t\tinput: `{\"key\":\"value\"`,\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"missing colon\",\n\t\t\tinput: `{\"key\" \"value\"}`,\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"missing key\",\n\t\t\tinput: `{:42}`,\n\t\t\terr:   true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{vs: make([]Value, 0, 16)}\n\t\t\tgot, _, err := parseObject(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !objectsEqual(got, tc.expected) {\n\t\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", tc.input, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc objectsEqual(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\to1, _ := v1.Object()\n\t\to2, _ := v2.Object()\n\t\tif len(o1.kvs) != len(o2.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, kv1 := range o1.kvs {\n\t\t\tkv2 := o2.kvs[i]\n\t\t\tif kv1.k != kv2.k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !objectsEqual(kv1.v, kv2.v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeTrue, TypeFalse, TypeNull:\n\t\treturn true\n\tcase TypeArray:\n\t\ta1, _ := v1.Array()\n\t\ta2, _ := v2.Array()\n\t\tif len(a1) != len(a2) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, v := range a1 {\n\t\t\tif !objectsEqual(v, a2[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\tpanic(\"unknown type\")\n\t}\n}",
    "b677050dbcec629c8d29f82e2c3f2fd6": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestType(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant Type\n\t}{\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv:    &Value{t: TypeNull},\n\t\t\twant: TypeNull,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv:    &Value{t: TypeObject},\n\t\t\twant: TypeObject,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv:    &Value{t: TypeArray},\n\t\t\twant: TypeArray,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv:    &Value{t: TypeString},\n\t\t\twant: TypeString,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv:    &Value{t: TypeNumber},\n\t\t\twant: TypeNumber,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv:    &Value{t: TypeTrue},\n\t\t\twant: TypeTrue,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv:    &Value{t: TypeFalse},\n\t\t\twant: TypeFalse,\n\t\t},\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv:    &Value{t: typeRawString, s: `\"hello\"`, s: \"hello\"},\n\t\t\twant: typeRawString,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := tc.v.Type()\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"Type() = %v, want %v\", got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b649516c92ed84646401f9a0c8be1b42": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGet(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tvalue *Value\n\t\tkeys  []string\n\t\twant  *Value\n\t}{\n\t\t{\n\t\t\tname:  \"nil input\",\n\t\t\tvalue: nil,\n\t\t\tkeys:  []string{\"key1\"},\n\t\t\twant:  nil,\n\t\t},\n\t\t{\n\t\t\tname: \"object path\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: &Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys: []string{\"key1\"},\n\t\t\twant: &Value{t: TypeString, s: \"value1\"},\n\t\t},\n\t\t{\n\t\t\tname: \"array path\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"value1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys: []string{\"1\"},\n\t\t\twant: &Value{t: TypeNumber, s: \"42\"},\n\t\t},\n\t\t{\n\t\t\tname: \"non-existing path\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: &Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys: []string{\"key2\"},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"mixed path\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: &Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeArray, a: []*Value{\n\t\t\t\t\t\t\t{t: TypeString, s: \"value1\"},\n\t\t\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t\t\t}}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys: []string{\"key1\", \"1\"},\n\t\t\twant: &Value{t: TypeNumber, s: \"42\"},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.value.Get(tt.keys...); got != tt.want {\n\t\t\t\tt.Errorf(\"Get() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b77435e569aff9b55cf6558a968f476c": "package fastjson\n\nimport (\n    \"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n    testCases := []struct {\n        name     string\n        input    string\n        expected1, expected2 string\n        expectErr bool\n    }{\n        {\n            name:     \"simple string\",\n            input:    `\"hello\"`,\n            expected1: \"hello\",\n            expected2: \"\",\n            expectErr: false,\n        },\n        {\n            name:     \"string with escaped quotes\",\n            input:    `\"hello\\\"world\"`,\n            expected1: \"hello\\\"world\",\n            expected2: \"\",\n            expectErr: false,\n        },\n        {\n            name:     \"string with unbalanced quotes\",\n            input:    `\"hello`,\n            expected1: \"\",\n            expected2: \"\",\n            expectErr: true,\n        },\n        {\n            name:     \"empty string\",\n            input:    `\"\"`,\n            expected1: \"\",\n            expected2: \"\",\n            expectErr: false,\n        },\n    }\n\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            res1, res2, err := parseRawString(tc.input)\n            if (err != nil) != tc.expectErr {\n                t.Errorf(\"parseRawString(%q) error = %v, expectErr %v\", tc.input, err, tc.expectErr)\n                return\n            }\n            if res1 != tc.expected1 {\n                t.Errorf(\"parseRawString(%q) result1 = %q, want %q\", tc.input, res1, tc.expected1)\n            }\n            if res2 != tc.expected2 {\n                t.Errorf(\"parseRawString(%q) result2 = %q, want %q\", tc.input, res2, tc.expected2)\n            }\n        })\n    }\n}",
    "b702b7f64b16cbf5e64694750a7a6b86": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantKey  string\n\t\twantRest string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple key\",\n\t\t\tinput:    `\"key\":`,\n\t\t\twantKey:  \"key\",\n\t\t\twantRest: \":\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"key with escape sequence\",\n\t\t\tinput:    `\"key\\\"with\\\\escape\":`,\n\t\t\twantKey:  `key\"with\\escape`,\n\t\t\twantRest: \":\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing closing quote\",\n\t\t\tinput:    `\"key`,\n\t\t\twantKey:  \"key\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotKey, gotRest, err := parseRawKey(tt.input)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawKey() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotKey != tt.wantKey {\n\t\t\t\tt.Errorf(\"parseRawKey() gotKey = %v, want %v\", gotKey, tt.wantKey)\n\t\t\t}\n\t\t\tif gotRest != tt.wantRest {\n\t\t\t\tt.Errorf(\"parseRawKey() gotRest = %v, want %v\", gotRest, tt.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b986d4c589f56a16c52eb378505a2e52": "package fastjson\n\nimport (\n    \"testing\"\n)\n\nfunc TestType_String(t *testing.T) {\n    tests := []struct {\n        name string\n        t    Type\n        want string\n    }{\n        {\"TypeObject\", TypeObject, \"object\"},\n        {\"TypeArray\", TypeArray, \"array\"},\n        {\"TypeString\", TypeString, \"string\"},\n        {\"TypeNumber\", TypeNumber, \"number\"},\n        {\"TypeTrue\", TypeTrue, \"true\"},\n        {\"TypeFalse\", TypeFalse, \"false\"},\n        {\"TypeNull\", TypeNull, \"null\"},\n        {\"Unknown Type\", Type(10), \"BUG: unknown Value type: 10\"},\n    }\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            if got := tt.t.String(); got != tt.want {\n                t.Errorf(\"Type.String() = %v, want %v\", got, tt.want)\n            }\n        })\n    }\n}",
    "b820683300c14c36357582b48bac4df3": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected1, expected2 string\n\t\texpectedError error\n\t}{\n\t\t{\n\t\t\tname:            \"Simple string\",\n\t\t\tinput:           `\"hello\"`,\n\t\t\texpected1:       \"hello\",\n\t\t\texpected2:       \"\",\n\t\t\texpectedError:   nil,\n\t\t},\n\t\t{\n\t\t\tname:            \"String with escaped quotes\",\n\t\t\tinput:           `\"hello \\\"world\\\"\"`,\n\t\t\texpected1:       `hello \"world\"`,\n\t\t\texpected2:       \"\",\n\t\t\texpectedError:   nil,\n\t\t},\n\t\t{\n\t\t\tname:            \"Missing closing quote\",\n\t\t\tinput:           `\"hello`,\n\t\t\texpected1:       \"\",\n\t\t\texpected2:       \"\",\n\t\t\texpectedError:   fmt.Errorf(`missing closing '\"'`),\n\t\t},\n\t\t{\n\t\t\tname:            \"Empty string\",\n\t\t\tinput:           `\"\"`,\n\t\t\texpected1:       \"\",\n\t\t\texpected2:       \"\",\n\t\t\texpectedError:   nil,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual1, actual2, err := parseRawString(tc.input)\n\t\t\tif err != tc.expectedError {\n\t\t\t\tt.Errorf(\"Expected error %v, got %v\", tc.expectedError, err)\n\t\t\t}\n\t\t\tif actual1 != tc.expected1 {\n\t\t\t\tt.Errorf(\"Expected first result %q, got %q\", tc.expected1, actual1)\n\t\t\t}\n\t\t\tif actual2 != tc.expected2 {\n\t\t\t\tt.Errorf(\"Expected second result %q, got %q\", tc.expected2, actual2)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b7a19dad9f8dc44de63625c70135f9cb": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.456e+78\",\n\t\t\texpected: []string{\"123.456e+78\", \"\"},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with leading/trailing spaces\",\n\t\t\tinput:    \"  123.456e+78  \",\n\t\t\texpected: []string{\"123.456e+78\", \"  \"},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number with non-digit character\",\n\t\t\tinput:    \"123.4x56\",\n\t\t\texpected: []string{\"\", \"123.4x56\"},\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number with leading non-digit character\",\n\t\t\tinput:    \"x123.456\",\n\t\t\texpected: []string{\"\", \"x123.456\"},\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number with only non-digit characters\",\n\t\t\tinput:    \"abc\",\n\t\t\texpected: []string{\"\", \"abc\"},\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with 'inf'\",\n\t\t\tinput:    \"  +inf  \",\n\t\t\texpected: []string{\"+inf\", \"  \"},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with 'nan'\",\n\t\t\tinput:    \"  -nan  \",\n\t\t\texpected: []string{\"-nan\", \"  \"},\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif err != nil && !tc.err {\n\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t}\n\t\t\tif err == nil && tc.err {\n\t\t\t\tt.Errorf(\"expected error, but got none\")\n\t\t\t}\n\t\t\tif num != tc.expected[0] {\n\t\t\t\tt.Errorf(\"expected number: %q, got: %q\", tc.expected[0], num)\n\t\t\t}\n\t\t\tif rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"expected rest: %q, got: %q\", tc.expected[1], rest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b94c8a675ca01c0e5705f4898a327a1f": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"empty array\",\n\t\t\tinput:    \"[]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with values\",\n\t\t\tinput: `[1, \"hello\", true]`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeString, s: \"hello\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with missing comma\",\n\t\t\tinput: `[1 \"hello\", true]`,\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with unexpected end\",\n\t\t\tinput: `[1, \"hello\"`,\n\t\t\terr:   true,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tv, _, err := parseArray(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseArray(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !v.Equal(tc.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", tc.input, v, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b9027e608afcd64bdeefc42196d68462": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestMarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: `\"hello, world\"`,\n\t\t\t},\n\t\t\twant: []byte(`\"hello, world\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":\"value1\",\"key2\":42}`),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"hello\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`[\"hello\",42,true]`),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello, world\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello, world\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42\",\n\t\t\t},\n\t\t\twant: []byte(\"42\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %s, want %s\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b5ba9e305ed271a13086bb75c92eeb74": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\texpectedErr error\n\t}{\n\t\t{\n\t\t\tname:     \"empty input\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\texpectedErr: fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"object\",\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t\tt: typeRawString,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\texpectedErr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\texpectedErr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{\n\t\t\t\ts: \"hello\",\n\t\t\t\tt: typeRawString,\n\t\t\t},\n\t\t\texpectedErr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"true\",\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\texpectedErr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"false\",\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\texpectedErr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"null\",\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\texpectedErr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"number\",\n\t\t\tinput:    \"42\",\n\t\t\texpected: &Value{\n\t\t\t\ts: \"42\",\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\texpectedErr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid value\",\n\t\t\tinput:    \"invalid\",\n\t\t\texpected: nil,\n\t\t\texpectedErr: fmt.Errorf(\"unexpected value found: \\\"invalid\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"too big depth\",\n\t\t\tinput:    \"{}\", // nested up to MaxDepth\n\t\t\texpected: nil,\n\t\t\texpectedErr: fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tv, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.expectedErr == nil || err.Error() != tc.expectedErr.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, expectedErr = %v\", tc.input, err, tc.expectedErr)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else if tc.expectedErr != nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = nil, expectedErr = %v\", tc.input, tc.expectedErr)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !compareValues(v, tc.expected) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, expected %v\", tc.input, v, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn compareObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn compareArrays(v1.a, v2.a)\n\tcase typeRawString, TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber, TypeTrue, TypeFalse, TypeNull:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc compareObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc compareArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tif !compareValues(v1, a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "bae59786f5c861d477ca897b14a101e7": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestMarshalTo(t *testing.T) {\n\ttestCases := []struct {\n\t\tname   string\n\t\tvalue  *Value\n\t\texpect []byte\n\t}{\n\t\t{\n\t\t\tname:   \"raw string\",\n\t\t\tvalue:  &Value{t: typeRawString, s: \"hello\"},\n\t\t\texpect: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname:   \"object\",\n\t\t\tvalue:  &Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: &Value{t: TypeString, s: \"value\"}}}}},\n\t\t\texpect: []byte(`{\"key\":\"value\"}`),\n\t\t},\n\t\t{\n\t\t\tname:   \"array\",\n\t\t\tvalue:  &Value{t: TypeArray, a: []*Value{{t: TypeString, s: \"one\"}, {t: TypeString, s: \"two\"}}},\n\t\t\texpect: []byte(`[\"one\",\"two\"]`),\n\t\t},\n\t\t{\n\t\t\tname:   \"string\",\n\t\t\tvalue:  &Value{t: TypeString, s: \"hello\"},\n\t\t\texpect: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname:   \"number\",\n\t\t\tvalue:  &Value{t: TypeNumber, s: \"42\"},\n\t\t\texpect: []byte(\"42\"),\n\t\t},\n\t\t{\n\t\t\tname:   \"true\",\n\t\t\tvalue:  &Value{t: TypeTrue},\n\t\t\texpect: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname:   \"false\",\n\t\t\tvalue:  &Value{t: TypeFalse},\n\t\t\texpect: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname:   \"null\",\n\t\t\tvalue:  &Value{t: TypeNull},\n\t\t\texpect: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname:   \"unknown type\",\n\t\t\tvalue:  &Value{t: 999},\n\t\t\texpect: nil,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdst := make([]byte, 0, 64)\n\t\t\tresult := tc.value.MarshalTo(dst)\n\t\t\tif !reflect.DeepEqual(result, tc.expect) {\n\t\t\t\tt.Errorf(\"expected %q, got %q\", tc.expect, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "bbd4aacd501b5510c301e28e2c99a7a2": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestGetStringBytes(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tvalue *Value\n\t\tkeys  []string\n\t\twant  []byte\n\t}{\n\t\t{\n\t\t\tname: \"string value\",\n\t\t\tvalue: &Value{\n\t\t\t\ts: \"hello, world\",\n\t\t\t\tt: TypeString,\n\t\t\t},\n\t\t\tkeys: []string{\"key\"},\n\t\t\twant: []byte(\"hello, world\"),\n\t\t},\n\t\t{\n\t\t\tname: \"non-string value\",\n\t\t\tvalue: &Value{\n\t\t\t\ti: 42,\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\tkeys: []string{\"key\"},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"non-existing keys\",\n\t\t\tvalue: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{s: \"value1\", t: TypeString}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{s: \"value2\", t: TypeString}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\tkeys: []string{\"non-existing-key\"},\n\t\t\twant: nil,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.value.GetStringBytes(tt.keys...)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"GetStringBytes() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "bba33bd45299023ca8b7a83a78d12329": "package fastjson\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty array\",\n\t\t\tinput:    \"[]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{}},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"single element array\",\n\t\t\tinput:    \"[42]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"42\"}}},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"multi-element array\",\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}, &Value{t: TypeNumber, s: \"2\"}, &Value{t: TypeNumber, s: \"3\"}}},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with whitespace\",\n\t\t\tinput:    \"[ 1,  2 , 3 ]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}, &Value{t: TypeNumber, s: \"2\"}, &Value{t: TypeNumber, s: \"3\"}}},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with missing closing bracket\",\n\t\t\tinput:    \"[1, 2, 3\",\n\t\t\texpected: nil,\n\t\t\terr:      assert.AnError,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tv, _, err := parseArray(tc.input, c, 0)\n\t\t\tif tc.err != nil {\n\t\t\t\tassert.Error(t, err)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t\tassert.Equal(t, tc.expected, v)\n\t\t\t}\n\t\t})\n\t}\n}",
    "bae6aaeb6d2dde466a9d225e8b25689e": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\texpected []byte\n\t}{\n\t\t{\n\t\t\tname: \"Raw String\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello, world\",\n\t\t\t},\n\t\t\texpected: []byte(`\"hello, world\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"Object\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: []byte(`{\"key1\":\"value1\",\"key2\":42}`),\n\t\t},\n\t\t{\n\t\t\tname: \"Array\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"one\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t\t{t: TypeFalse},\n\t\t\t\t\t{t: TypeNull},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: []byte(`[\"one\",2,true,false,null]`),\n\t\t},\n\t\t{\n\t\t\tname: \"String\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello, world\",\n\t\t\t},\n\t\t\texpected: []byte(`\"hello, world\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"Number\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42\",\n\t\t\t},\n\t\t\texpected: []byte(\"42\"),\n\t\t},\n\t\t{\n\t\t\tname: \"True\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\texpected: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"False\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\texpected: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"Null\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\texpected: []byte(\"null\"),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdst := make([]byte, 0, len(tc.expected))\n\t\t\tresult := tc.value.MarshalTo(dst)\n\t\t\tif !reflect.DeepEqual(result, tc.expected) {\n\t\t\t\tt.Errorf(\"MarshalTo(%v) = %s, expected %s\", tc.value, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "be3fef38b753fb00b2dd27df1c22fb9f": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tt    Type\n\t\twant string\n\t}{\n\t\t{\"TypeObject\", TypeObject, \"object\"},\n\t\t{\"TypeArray\", TypeArray, \"array\"},\n\t\t{\"TypeString\", TypeString, \"string\"},\n\t\t{\"TypeNumber\", TypeNumber, \"number\"},\n\t\t{\"TypeTrue\", TypeTrue, \"true\"},\n\t\t{\"TypeFalse\", TypeFalse, \"false\"},\n\t\t{\"TypeNull\", TypeNull, \"null\"},\n\t\t{\"Unknown\", Type(100), \"BUG: unknown Value type: 100\"},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.t.String(); got != tt.want {\n\t\t\t\tt.Errorf(\"Type.String() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "bd43f4fafcaeeba798c3f402040ffc31": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"no escape characters\",\n\t\t\tinput:    \"hello world\",\n\t\t\texpected: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"escaped characters\",\n\t\t\tinput:    \"hello\\\\n\\\\t\\\\u0020world\",\n\t\t\texpected: \"hello\\n\\t world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid escape character\",\n\t\t\tinput:    \"hello\\\\xworld\",\n\t\t\texpected: \"hello\\\\xworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"incomplete escape sequence\",\n\t\t\tinput:    \"hello\\\\u001\",\n\t\t\texpected: \"hello\\\\u001\",\n\t\t},\n\t\t{\n\t\t\tname:     \"surrogate pair\",\n\t\t\tinput:    \"hello\\\\uD83D\\\\uDE00world\",\n\t\t\texpected: \"helloüòÄworld\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "bc32bb4bd7cd7c280d27c80f1da62f5b": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantNum  string\n\t\twantRest string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.456e+78\",\n\t\t\twantNum:  \"123.456e+78\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with trailing characters\",\n\t\t\tinput:    \"123.456abc\",\n\t\t\twantNum:  \"123.456\",\n\t\t\twantRest: \"abc\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number\",\n\t\t\tinput:    \"abc123\",\n\t\t\twantNum:  \"\",\n\t\t\twantRest: \"abc123\",\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with inf/nan\",\n\t\t\tinput:    \"+inf\",\n\t\t\twantNum:  \"+inf\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with inf/nan\",\n\t\t\tinput:    \"-nan\",\n\t\t\twantNum:  \"-nan\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.wantNum {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) num = %q, want %q\", tc.input, num, tc.wantNum)\n\t\t\t}\n\t\t\tif rest != tc.wantRest {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) rest = %q, want %q\", tc.input, rest, tc.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "bfd9bf47990529b6e2f1fe69b5593909": "package fastjson\n\nimport \"testing\"\n\nfunc TestHasSpecialChars(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname:     \"Empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"String with no special characters\",\n\t\t\tinput:    \"hello world\",\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"String with double quote\",\n\t\t\tinput:    \"hello \\\"world\\\"\",\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"String with backslash\",\n\t\t\tinput:    \"hello\\\\world\",\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"String with control character\",\n\t\t\tinput:    \"hello\\nworld\",\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := hasSpecialChars(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"hasSpecialChars(%q) = %v, expected %v\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "bbe3e673670e6d1a8100b95f3f3b6604": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: \"{}\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs:           []kv{},\n\t\t\t\t\t\tkeysUnescaped: true,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with one key-value pair\",\n\t\t\tinput: `{\"key\":\"value\"}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tkeysUnescaped: true,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with multiple key-value pairs\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42,\"key3\":true}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\ts: \"42\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tkeysUnescaped: true,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with trailing comma\",\n\t\t\tinput: `{\"key1\":\"value1\",}`,\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing key\",\n\t\t\tinput: `{:42}`,\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing value\",\n\t\t\tinput: `{\"key\":}`,\n\t\t\terr:   true,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseObject(tt.input, c, 0)\n\t\t\tif (err != nil) != tt.err {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.err && !got.Equal(tt.expected) {\n\t\t\t\tt.Errorf(\"parseObject() = %v, want %v\", got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "bd08cdc2e23161062627047e003b8850": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\targs string\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"No escape characters\",\n\t\t\targs: \"hello, world\",\n\t\t\twant: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname: \"Escaped double quote\",\n\t\t\targs: \"\\\"hello, world\\\"\",\n\t\t\twant: \"\\\"hello, world\\\"\",\n\t\t},\n\t\t{\n\t\t\tname: \"Escaped backslash\",\n\t\t\targs: \"hello\\\\, world\",\n\t\t\twant: \"hello\\\\, world\",\n\t\t},\n\t\t{\n\t\t\tname: \"Escaped forward slash\",\n\t\t\targs: \"hello\\\\/world\",\n\t\t\twant: \"hello/world\",\n\t\t},\n\t\t{\n\t\t\tname: \"Escaped backspace\",\n\t\t\targs: \"hello\\bworld\",\n\t\t\twant: \"hello\\bworld\",\n\t\t},\n\t\t{\n\t\t\tname: \"Escaped form feed\",\n\t\t\targs: \"hello\\fworld\",\n\t\t\twant: \"hello\\fworld\",\n\t\t},\n\t\t{\n\t\t\tname: \"Escaped newline\",\n\t\t\targs: \"hello\\nworld\",\n\t\t\twant: \"hello\\nworld\",\n\t\t},\n\t\t{\n\t\t\tname: \"Escaped carriage return\",\n\t\t\targs: \"hello\\rworld\",\n\t\t\twant: \"hello\\rworld\",\n\t\t},\n\t\t{\n\t\t\tname: \"Escaped tab\",\n\t\t\targs: \"hello\\tworld\",\n\t\t\twant: \"hello\\tworld\",\n\t\t},\n\t\t{\n\t\t\tname: \"Escaped Unicode character\",\n\t\t\targs: \"hello\\\\u0123world\",\n\t\t\twant: \"hello\\u0123world\",\n\t\t},\n\t\t{\n\t\t\tname: \"Escaped surrogate pair\",\n\t\t\targs: \"hello\\\\ud83d\\\\ude00world\",\n\t\t\twant: \"helloüòÄworld\",\n\t\t},\n\t\t{\n\t\t\tname: \"Invalid escape sequence\",\n\t\t\targs: \"hello\\\\xworld\",\n\t\t\twant: \"hello\\\\xworld\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", tt.args, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c139b8b840fd95c233cf58a5b0b8e307": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: []string{\"hello\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello\\\"world\"`,\n\t\t\texpected: []string{\"hello\\\"world\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello\\\"world\\\"foo\"`,\n\t\t\texpected: []string{\"hello\\\"world\\\"foo\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with unmatched quote\",\n\t\t\tinput:    `\"hello`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, _, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif actual != tc.expected[0] {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = %v, expected %v\", tc.input, actual, tc.expected[0])\n\t\t\t}\n\t\t})\n\t}\n}",
    "c0874c7164c921c92d5c73b5e96f2adc": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantNum  string\n\t\twantRest string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.45e+6abc\",\n\t\t\twantNum:  \"123.45e+6\",\n\t\t\twantRest: \"abc\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with leading sign\",\n\t\t\tinput:    \"-123.45e+6abc\",\n\t\t\twantNum:  \"-123.45e+6\",\n\t\t\twantRest: \"abc\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"inf\",\n\t\t\tinput:    \"infabc\",\n\t\t\twantNum:  \"inf\",\n\t\t\twantRest: \"abc\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"nan\",\n\t\t\tinput:    \"nanabc\",\n\t\t\twantNum:  \"nan\",\n\t\t\twantRest: \"abc\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid character\",\n\t\t\tinput:    \"12a3.45e+6abc\",\n\t\t\twantNum:  \"\",\n\t\t\twantRest: \"12a3.45e+6abc\",\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty input\",\n\t\t\tinput:    \"\",\n\t\t\twantNum:  \"\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.wantNum {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) num = %q, want %q\", tc.input, num, tc.wantNum)\n\t\t\t}\n\t\t\tif rest != tc.wantRest {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) rest = %q, want %q\", tc.input, rest, tc.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c3af1e47e08002ea2a66ba4555dc8b2c": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestGetStringBytes(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tinput *Value\n\t\tkeys  []string\n\t\twant  []byte\n\t}{\n\t\t{\n\t\t\tname: \"existing key\",\n\t\t\tinput: &Value{\n\t\t\t\ts: \"foo\",\n\t\t\t},\n\t\t\tkeys: []string{\"\"},\n\t\t\twant: []byte(\"foo\"),\n\t\t},\n\t\t{\n\t\t\tname: \"non-existing key\",\n\t\t\tinput: &Value{\n\t\t\t\ts: \"foo\",\n\t\t\t},\n\t\t\tkeys: []string{\"bar\"},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid value type\",\n\t\t\tinput: &Value{\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\tkeys: []string{\"0\"},\n\t\t\twant: nil,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.input.GetStringBytes(tt.keys...)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"GetStringBytes(%v) = %v, want %v\", tt.keys, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "bc5d285469a1c0d8fc4ef44b5183d6ea": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:  \"empty array\",\n\t\t\tinput: \"[]\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with one element\",\n\t\t\tinput: \"[1]\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv1 := &Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"1\",\n\t\t\t\t}\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{v1},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with multiple elements\",\n\t\t\tinput: \"[1,2,3]\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv1 := &Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"1\",\n\t\t\t\t}\n\t\t\t\tv2 := &Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"2\",\n\t\t\t\t}\n\t\t\t\tv3 := &Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"3\",\n\t\t\t\t}\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{v1, v2, v3},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with missing end bracket\",\n\t\t\tinput: \"[1,2,3\",\n\t\t\texpected: nil,\n\t\t\terr:      errMissingEndBracket,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tcache := &cache{}\n\t\t\tactual, _, err := parseArray(tc.input, cache, 0)\n\t\t\tif err != tc.err {\n\t\t\t\tt.Errorf(\"expected error %v, got %v\", tc.err, err)\n\t\t\t}\n\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tc.expected, actual)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn compareObjects(v1.o, v2.o)\n\tcase TypeArray:\n\t\treturn compareArrays(v1.a, v2.a)\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber, TypeTrue, TypeFalse:\n\t\treturn v1.s == v2.s\n\tcase TypeNull:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc compareArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i := range a1 {\n\t\tif !compareValues(a1[i], a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc compareObjects(o1, o2 Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i := range o1.kvs {\n\t\tif o1.kvs[i].k != o2.kvs[i].k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(o1.kvs[i].v, o2.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "c3d3743fdc801655ec63135d7bb59672": "package fastjson_test\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetValue(t *testing.T) {\n\t// Create a new cache\n\tc := &cache{\n\t\tvs: make([]Value, 0, 10),\n\t}\n\n\t// Call the getValue() function\n\tvalue := c.getValue()\n\n\t// Verify that the returned value is not nil\n\tif value == nil {\n\t\tt.Errorf(\"getValue() returned a nil value\")\n\t}\n\n\t// Verify that the length of the slice has increased by 1\n\tif len(c.vs) != 1 {\n\t\tt.Errorf(\"Expected length of c.vs to be 1, got %d\", len(c.vs))\n\t}\n}",
    "bfff9a81256b0c60aeeaa312fc7ea322": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"empty array\",\n\t\t\tinput:    \"[]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{}},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with one element\",\n\t\t\tinput:    \"[1]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}}},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with multiple elements\",\n\t\t\tinput:    \"[1,2,3]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}, &Value{t: TypeNumber, s: \"2\"}, &Value{t: TypeNumber, s: \"3\"}}},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with invalid element\",\n\t\t\tinput:    \"[1,2,]\",\n\t\t\texpected: nil,\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tgot, _, err := parseArray(tt.input, c, 0)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !equalValues(got, tt.expected) {\n\t\t\t\tt.Errorf(\"parseArray() = %v, want %v\", got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn equalObjects(v1.o, v2.o)\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeTrue, TypeFalse, TypeNull:\n\t\treturn true\n\tdefault:\n\t\tpanic(\"unreachable\")\n\t}\n}\n\nfunc equalObjects(o1, o2 *Object) bool {\n\tif o1 == nil && o2 == nil {\n\t\treturn true\n\t}\n\tif o1 == nil || o2 == nil {\n\t\treturn false\n\t}\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i := range o1.kvs {\n\t\tif o1.kvs[i].k != o2.kvs[i].k {\n\t\t\treturn false\n\t\t}\n\t\tif !equalValues(o1.kvs[i].v, o2.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "c32a429bd8165819c0e2efc39c6b825a": "package fastjson\n\nimport (\n    \"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n    tests := []struct {\n        name     string\n        input    string\n        wantKey  string\n        wantRest string\n        wantErr  bool\n    }{\n        {\n            name:     \"basic\",\n            input:    `\"hello\"world`,\n            wantKey:  `\"hello\"`,\n            wantRest: `world`,\n            wantErr:  false,\n        },\n        {\n            name:     \"escaped quote\",\n            input:    `\"he\\\"llo\"world`,\n            wantKey:  `\"he\\\"llo\"`,\n            wantRest: `world`,\n            wantErr:  false,\n        },\n        {\n            name:     \"missing closing quote\",\n            input:    `\"hello`,\n            wantKey:  \"\",\n            wantRest: \"\",\n            wantErr:  true,\n        },\n        {\n            name:     \"empty input\",\n            input:    ``,\n            wantKey:  \"\",\n            wantRest: \"\",\n            wantErr:  true,\n        },\n    }\n\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            gotKey, gotRest, err := parseRawString(tt.input)\n            if (err != nil) != tt.wantErr {\n                t.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n                return\n            }\n            if gotKey != tt.wantKey {\n                t.Errorf(\"parseRawString() gotKey = %v, want %v\", gotKey, tt.wantKey)\n            }\n            if gotRest != tt.wantRest {\n                t.Errorf(\"parseRawString() gotRest = %v, want %v\", gotRest, tt.wantRest)\n            }\n        })\n    }\n}",
    "c2da5751cd2c5398838167b28b6919cf": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    *Value\n\t\texpected []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tinput: &Value{\n\t\t\t\ts: \"hello, world\",\n\t\t\t\tt: typeRawString,\n\t\t\t},\n\t\t\texpected: []byte(`\"hello, world\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tinput: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{s: \"value1\", t: TypeString}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{s: \"value2\", t: TypeString}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\texpected: []byte(`{\"key1\":\"value1\",\"key2\":\"value2\"}`),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tinput: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"value1\", t: TypeString},\n\t\t\t\t\t{s: \"value2\", t: TypeString},\n\t\t\t\t\t{s: \"value3\", t: TypeString},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\texpected: []byte(`[\"value1\",\"value2\",\"value3\"]`),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tinput: &Value{\n\t\t\t\ts: \"hello, world\",\n\t\t\t\tt: TypeString,\n\t\t\t},\n\t\t\texpected: []byte(`\"hello, world\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tinput: &Value{\n\t\t\t\ts: \"42\",\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\texpected: []byte(\"42\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tinput: &Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\texpected: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tinput: &Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\texpected: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tinput: &Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\texpected: []byte(\"null\"),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdst := make([]byte, 0, 128)\n\t\t\tresult := tc.input.MarshalTo(dst)\n\t\t\tif !reflect.DeepEqual(result, tc.expected) {\n\t\t\t\tt.Errorf(\"MarshalTo(%#v) = %s, want %s\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c3ca300ea3ef3c2d58924dcfd3e7b4d8": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape sequence\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Single escape sequence\",\n\t\t\tinput:    \"hello\\\\nworld\",\n\t\t\texpected: \"hello\\nworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Multiple escape sequences\",\n\t\t\tinput:    \"hello\\\\n\\\\\\\"\\\\tworld\",\n\t\t\texpected: \"hello\\n\\\"\\tworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid escape sequence\",\n\t\t\tinput:    \"hello\\\\xworld\",\n\t\t\texpected: \"hello\\\\xworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Surrogate pair\",\n\t\t\tinput:    \"hello\\\\ud83d\\\\ude00world\",\n\t\t\texpected: \"helloüòÄworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Incomplete surrogate pair\",\n\t\t\tinput:    \"hello\\\\ud83dworld\",\n\t\t\texpected: \"hello\\\\ud83dworld\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c41fada46f28a36a945f14b1dabf43f8": "package fastjson\n\nimport \"testing\"\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"no whitespace\",\n\t\t\tinput:    \"hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading whitespace\",\n\t\t\tinput:    \"   hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"trailing whitespace\",\n\t\t\tinput:    \"hello   \",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading and trailing whitespace\",\n\t\t\tinput:    \"   hello   \",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"mixed whitespace\",\n\t\t\tinput:    \"\\t \\n hello \\r\\n\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"all whitespace\",\n\t\t\tinput:    \"   \\t\\n\\r\\n   \",\n\t\t\texpected: \"\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := skipWSSlow(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"skipWSSlow(%q) = %q, want %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c4ca0fa3d11b72162681fabfbab58d61": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetValue(t *testing.T) {\n\tc := &cache{}\n\n\t// Test when the capacity of c.vs is greater than the length\n\tc.vs = make([]Value, 0, 10)\n\tv := c.getValue()\n\tif len(c.vs) != 1 {\n\t\tt.Errorf(\"expected len(c.vs) to be 1, got %d\", len(c.vs))\n\t}\n\tif v != &c.vs[0] {\n\t\tt.Errorf(\"expected v to be &c.vs[0], got %p\", v)\n\t}\n\n\t// Test when the capacity of c.vs is equal to the length\n\tc.vs = make([]Value, 10)\n\tv = c.getValue()\n\tif len(c.vs) != 11 {\n\t\tt.Errorf(\"expected len(c.vs) to be 11, got %d\", len(c.vs))\n\t}\n\tif v != &c.vs[10] {\n\t\tt.Errorf(\"expected v to be &c.vs[10], got %p\", v)\n\t}\n}",
    "c3f9de78bc4ab5f2c224c68fe6a512d2": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetObject(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tfields *Value\n\t\targs   []string\n\t\twant   *Object\n\t}{\n\t\t{\n\t\t\tname: \"Existing keys path\",\n\t\t\tfields: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{s: \"value2\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\targs: []string{\"key1\", \"key2\"},\n\t\t\twant: &Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"key1\", v: &Value{s: \"value1\"}},\n\t\t\t\t\t{k: \"key2\", v: &Value{s: \"value2\"}},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"Non-existing keys path\",\n\t\t\tfields: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{s: \"value2\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\targs: []string{\"key1\", \"key3\"},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Invalid value type\",\n\t\t\tfields: &Value{\n\t\t\t\ts: \"invalid\",\n\t\t\t},\n\t\t\targs: []string{\"key1\"},\n\t\t\twant: nil,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv := tt.fields\n\t\t\tif got := v.GetObject(tt.args...); got != tt.want {\n\t\t\t\tt.Errorf(\"Value.GetObject() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c5cdd5f26f85c8b4f71fd4ad327b5a2e": "// fastjson_test.go\n\npackage fastjson\n\nimport (\n    \"testing\"\n)\n\nfunc TestObjectReset(t *testing.T) {\n    // Arrange\n    obj := &Object{\n        kvs:           []kv{{k: \"key1\", v: &Value{}}, {k: \"key2\", v: &Value{}}},\n        keysUnescaped: true,\n    }\n\n    // Act\n    obj.reset()\n\n    // Assert\n    if len(obj.kvs) != 0 {\n        t.Errorf(\"expected kvs to be empty, got %d\", len(obj.kvs))\n    }\n\n    if obj.keysUnescaped {\n        t.Errorf(\"expected keysUnescaped to be false, got true\")\n    }\n}",
    "c55ae409893aa760b6837960ae6d3139": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"no escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"simple escape characters\",\n\t\t\tinput:    \"hello\\\\\\\"world\\\\\\\\\",\n\t\t\texpected: \"hello\\\"world\\\\\",\n\t\t},\n\t\t{\n\t\t\tname:     \"unicode escape characters\",\n\t\t\tinput:    \"hello\\\\u0041world\\\\u0042\",\n\t\t\texpected: \"helloAwordB\",\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid unicode escape characters\",\n\t\t\tinput:    \"hello\\\\u004x\",\n\t\t\texpected: \"hello\\\\u004x\",\n\t\t},\n\t\t{\n\t\t\tname:     \"surrogate pair unicode escape characters\",\n\t\t\tinput:    \"hello\\\\uD835\\\\uDD42world\",\n\t\t\texpected: \"helloùïÇworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid surrogate pair unicode escape characters\",\n\t\t\tinput:    \"hello\\\\uD835world\",\n\t\t\texpected: \"hello\\\\uD835world\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual := unescapeStringBestEffort(tc.input)\n\t\t\tif actual != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c5cb7d728cb8fdc34f85c406b961cc9e": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escaping\",\n\t\t\tinput:    \"This is a string with no escaping\",\n\t\t\texpected: \"This is a string with no escaping\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Basic escaping\",\n\t\t\tinput:    \"This is a string with \\\"quotes\\\" and \\\\backslashes\\\\\",\n\t\t\texpected: \"This is a string with \\\"quotes\\\" and \\\\backslashes\\\\\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Unicode escaping\",\n\t\t\tinput:    \"This string has \\\\u0061 a \\\\u0062 b \\\\u0063 c characters\",\n\t\t\texpected: \"This string has a b c characters\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Surrogate pairs\",\n\t\t\tinput:    \"This string has \\\\ud83d\\\\ude00 a smiley face \\\\ud83d\\\\ude01\",\n\t\t\texpected: \"This string has \\U0001f600 a smiley face \\U0001f601\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid escape sequence\",\n\t\t\tinput:    \"This string has an \\\\x invalid escape sequence\",\n\t\t\texpected: \"This string has an \\\\x invalid escape sequence\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := unescapeStringBestEffort(tc.input)\n\t\t\tif got != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", tc.input, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c5586c4ceae5d3f167bcc3ee23c33dbe": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantNum  string\n\t\twantRest string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid integer\",\n\t\t\tinput:    \"123\",\n\t\t\twantNum:  \"123\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid float\",\n\t\t\tinput:    \"3.14\",\n\t\t\twantNum:  \"3.14\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid negative number\",\n\t\t\tinput:    \"-42\",\n\t\t\twantNum:  \"-42\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid number with exponent\",\n\t\t\tinput:    \"1e+6\",\n\t\t\twantNum:  \"1e+6\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number (starts with non-digit)\",\n\t\t\tinput:    \"a123\",\n\t\t\twantNum:  \"\",\n\t\t\twantRest: \"a123\",\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number (contains invalid char)\",\n\t\t\tinput:    \"12$3\",\n\t\t\twantNum:  \"12\",\n\t\t\twantRest: \"$3\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number (only special chars)\",\n\t\t\tinput:    \"-.+e\",\n\t\t\twantNum:  \"\",\n\t\t\twantRest: \"-.+e\",\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number (only inf/nan)\",\n\t\t\tinput:    \"inf\",\n\t\t\twantNum:  \"inf\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNum, gotRest, err := parseRawNumber(tt.input)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tt.input, err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNum != tt.wantNum {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) gotNum = %v, want %v\", tt.input, gotNum, tt.wantNum)\n\t\t\t}\n\t\t\tif gotRest != tt.wantRest {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) gotRest = %v, want %v\", tt.input, gotRest, tt.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c764ce35ca14ae6a72207278122d0d5b": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":\"value1\",\"key2\":42}`),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"a\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t\t{t: TypeFalse},\n\t\t\t\t\t{t: TypeNull},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`[\"a\",42,true,false,null]`),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42\",\n\t\t\t},\n\t\t\twant: []byte(\"42\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"unknown type\",\n\t\t\tv: &Value{\n\t\t\t\tt: 100,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %s, want %s\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c862c57bfd6664eb3772ddfd9cc5ec8c": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No Escape Sequence\",\n\t\t\tinput:    \"hello, world!\",\n\t\t\texpected: \"hello, world!\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Simple Escape Sequence\",\n\t\t\tinput:    \"hello\\\\nworld\",\n\t\t\texpected: \"hello\\nworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Multiple Escape Sequences\",\n\t\t\tinput:    \"hello\\\\nworld\\\\ttest\",\n\t\t\texpected: \"hello\\nworld\\ttest\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Incomplete Escape Sequence\",\n\t\t\tinput:    \"hello\\\\u123world\",\n\t\t\texpected: \"hello\\\\u123world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Surrogate Pair Escape Sequence\",\n\t\t\tinput:    \"hello\\\\uD83D\\\\uDE00world\",\n\t\t\texpected: \"helloüòÄworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid Escape Sequence\",\n\t\t\tinput:    \"hello\\\\xyzworld\",\n\t\t\texpected: \"hello\\\\xyzworld\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c7df6ab3486acf816f4a9b764f6a03d8": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: []string{\"hello\", \"\"},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello\\\"world\"`,\n\t\t\texpected: []string{\"hello\\\"world\", \"\"},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello\\\"world\\\"foo\"`,\n\t\t\texpected: []string{\"hello\\\"world\\\"foo\", \"\"},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with non-escaped quote\",\n\t\t\tinput:    `\"hello\"world\"`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    `\"\"`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult1, result2, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"expected error: %v, got: %v\", tc.err, err)\n\t\t\t}\n\n\t\t\tif result1 != tc.expected[0] || result2 != tc.expected[1] {\n\t\t\t\tt.Errorf(\"expected result: %v, got: %v, %v\", tc.expected, result1, result2)\n\t\t\t}\n\t\t})\n\t}\n}",
    "cac4f04680835dd843013cfc1b730880": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestEscapeString(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\ts   string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"no special characters\",\n\t\t\targs: args{\n\t\t\t\tdst: nil,\n\t\t\t\ts:   \"hello\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"has special characters\",\n\t\t\targs: args{\n\t\t\t\tdst: nil,\n\t\t\t\ts:   \"hello\\nworld\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello\\nworld\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\tdst: nil,\n\t\t\t\ts:   \"\",\n\t\t\t},\n\t\t\twant: []byte(`\"\"`),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := escapeString(tt.args.dst, tt.args.s); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"escapeString() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c9f4acd3cb04b2ed994e2e7099cc5b41": "package fastjson_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/valyala/fastjson\"\n)\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tt    fastjson.Type\n\t\twant string\n\t}{\n\t\t{\"TypeObject\", fastjson.TypeObject, \"object\"},\n\t\t{\"TypeArray\", fastjson.TypeArray, \"array\"},\n\t\t{\"TypeString\", fastjson.TypeString, \"string\"},\n\t\t{\"TypeNumber\", fastjson.TypeNumber, \"number\"},\n\t\t{\"TypeTrue\", fastjson.TypeTrue, \"true\"},\n\t\t{\"TypeFalse\", fastjson.TypeFalse, \"false\"},\n\t\t{\"TypeNull\", fastjson.TypeNull, \"null\"},\n\t\t{\"Unknown\", fastjson.Type(100), \"BUG: unknown Value type: 100\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.t.String(); got != tt.want {\n\t\t\t\tt.Errorf(\"Type.String() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c89109383f77829fd96d34eb2ecc83ef": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello, world\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello, world\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":\"value1\",\"key2\":42}`),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"str1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`[\"str1\",42,true]`),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello, world\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello, world\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42\",\n\t\t\t},\n\t\t\twant: []byte(\"42\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %q, want %q\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "cb85710523cfb04cdcdf04451f7449d2": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: \"hello\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"he\\\"llo\"`,\n\t\t\texpected: `he\"llo`,\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"he\\\\\\\"llo\"`,\n\t\t\texpected: `he\\\"llo`,\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with no closing quote\",\n\t\t\tinput:    `\"hello`,\n\t\t\texpected: \"\",\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult, _, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"parseRawString() = %v, want %v\", result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c8009aa53c1b79da028713d43677a10e": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"empty array\",\n\t\t\tinput:    \"[]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with values\",\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}, &Value{t: TypeNumber, s: \"2\"}, &Value{t: TypeNumber, s: \"3\"}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with whitespace\",\n\t\t\tinput:    \"[ 1,  2, 3 ]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}, &Value{t: TypeNumber, s: \"2\"}, &Value{t: TypeNumber, s: \"3\"}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with missing closing bracket\",\n\t\t\tinput:    \"[1, 2, 3\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with missing comma\",\n\t\t\tinput:    \"[1 2, 3]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tgot, _, err := parseArray(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseArray(%q) error = %v, want error %t\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !compareValues(got, tc.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", tc.input, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeArray:\n\t\ta1, _ := v1.Array()\n\t\ta2, _ := v2.Array()\n\t\tif len(a1) != len(a2) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range a1 {\n\t\t\tif !compareValues(a1[i], a2[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeObject:\n\t\to1, _ := v1.Object()\n\t\to2, _ := v2.Object()\n\t\tif o1.Len() != o2.Len() {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range o1.kvs {\n\t\t\tif o1.kvs[i].k != o2.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !compareValues(o1.kvs[i].v, o2.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\treturn v1.s == v2.s\n\t}\n}",
    "c6faba2bbfc994b9485296bddc91361b": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: \"{}\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with one key-value pair\",\n\t\t\tinput: `{\"key\":\"value\"}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with multiple key-value pairs\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":123,\"key3\":true}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\tinput: `{\"key1\":\"value1\",`,\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing key\",\n\t\t\tinput: `{:123}`,\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing value\",\n\t\t\tinput: `{\"key\":}`,\n\t\t\terr:   true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tv, _, err := parseObject(tt.input, c, 0)\n\t\t\tif (err != nil) != tt.err {\n\t\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", tt.input, err, tt.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !compareValues(t, v, tt.expected) {\n\t\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", tt.input, v, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(t *testing.T, got, want *Value) bool {\n\tif got.t != want.t {\n\t\treturn false\n\t}\n\tswitch got.t {\n\tcase TypeObject:\n\t\treturn compareObjects(t, &got.o, &want.o)\n\tcase TypeArray:\n\t\treturn compareArrays(t, got.a, want.a)\n\tcase TypeString:\n\t\treturn got.s == want.s\n\tcase TypeNumber, TypeTrue, TypeFalse:\n\t\treturn got.s == want.s\n\tcase TypeNull:\n\t\treturn true\n\tdefault:\n\t\tt.Errorf(\"unknown value type: %v\", got.t)\n\t\treturn false\n\t}\n}\n\nfunc compareObjects(t *testing.T, got, want *Object) bool {\n\tif len(got.kvs) != len(want.kvs) {\n\t\treturn false\n\t}\n\tfor i, gotKV := range got.kvs {\n\t\twantKV := want.kvs[i]\n\t\tif gotKV.k != wantKV.k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(t, gotKV.v, wantKV.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc compareArrays(t *testing.T, got, want []*Value) bool {\n\tif len(got) != len(want) {\n\t\treturn false\n\t}\n\tfor i, gotV := range got {\n\t\twantV := want[i]\n\t\tif !compareValues(t, gotV, wantV) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "cb8b337a5da945f53db16b6db1e7cef5": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantKey  string\n\t\twantRest string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid key without escape\",\n\t\t\tinput:    `\"key1\":\"value1\"`,\n\t\t\twantKey:  \"key1\",\n\t\t\twantRest: `:\"value1\"`,\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid key with escape\",\n\t\t\tinput:    `\"ke\\\"y1\":\"value1\"`,\n\t\t\twantKey:  `ke\"y1`,\n\t\t\twantRest: `:\"value1\"`,\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing closing quote\",\n\t\t\tinput:    `\"key1:value1`,\n\t\t\twantKey:  \"\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgotKey, gotRest, err := parseRawKey(test.input)\n\t\t\tif (err != nil) != test.wantErr {\n\t\t\t\tt.Errorf(\"parseRawKey(%q) error = %v, wantErr %v\", test.input, err, test.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotKey != test.wantKey {\n\t\t\t\tt.Errorf(\"parseRawKey(%q) gotKey = %v, want %v\", test.input, gotKey, test.wantKey)\n\t\t\t}\n\t\t\tif gotRest != test.wantRest {\n\t\t\t\tt.Errorf(\"parseRawKey(%q) gotRest = %v, want %v\", test.input, gotRest, test.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "cd09872ff98ed51df9fc60253203ac1c": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantKey  string\n\t\twantRest string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\twantKey:  \"hello\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello\\\"world\"`,\n\t\t\twantKey:  `hello\"world`,\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing closing quote\",\n\t\t\tinput:    `\"hello`,\n\t\t\twantKey:  \"\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    `\"\"`,\n\t\t\twantKey:  \"\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tkey, rest, err := parseRawString(tt.input)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString(%q) error = %v, wantErr %v\", tt.input, err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif key != tt.wantKey {\n\t\t\t\tt.Errorf(\"parseRawString(%q) key = %q, want %q\", tt.input, key, tt.wantKey)\n\t\t\t}\n\t\t\tif rest != tt.wantRest {\n\t\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, want %q\", tt.input, rest, tt.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "cd6cb6e8218d1f8c8539694471a3eebe": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tinput string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname: \"No escape characters\",\n\t\t\tinput: \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname: \"Simple escape characters\",\n\t\t\tinput: \"hello\\\\\\\"world\\\\\\\\\",\n\t\t\texpected: \"hello\\\"world\\\\\",\n\t\t},\n\t\t{\n\t\t\tname: \"Escaped Unicode characters\",\n\t\t\tinput: \"hello\\\\u0123world\\\\u4567\",\n\t\t\texpected: \"hello\\u0123world\\u4567\",\n\t\t},\n\t\t{\n\t\t\tname: \"Escaped surrogate pair\",\n\t\t\tinput: \"hello\\\\uD834\\\\uDD1Eworld\",\n\t\t\texpected: \"hello\\U0001D11Eworld\",\n\t\t},\n\t\t{\n\t\t\tname: \"Invalid escape sequence\",\n\t\t\tinput: \"hello\\\\xyzworld\",\n\t\t\texpected: \"hello\\\\xyzworld\",\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(test.input)\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", test.input, result, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "cc2ca3ffb95a189c0927b89f2ea28794": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantKey  string\n\t\twantRest string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"key\":\"value\"`,\n\t\t\twantKey:  \"key\",\n\t\t\twantRest: \"value\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"key\\\"with\\\"escape\":\"value\"`,\n\t\t\twantKey:  `key\"with\"escape`,\n\t\t\twantRest: \"value\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing closing quote\",\n\t\t\tinput:    `\"key\":value`,\n\t\t\twantKey:  \"\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    `\"\"`,\n\t\t\twantKey:  \"\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tkey, rest, err := parseRawString(tt.input)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString(%q) error = %v, wantErr %v\", tt.input, err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif key != tt.wantKey {\n\t\t\t\tt.Errorf(\"parseRawString(%q) key = %v, want %v\", tt.input, key, tt.wantKey)\n\t\t\t}\n\t\t\tif rest != tt.wantRest {\n\t\t\t\tt.Errorf(\"parseRawString(%q) rest = %v, want %v\", tt.input, rest, tt.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "cc89c1bed9800d39da5e4dc1a0fd47ba": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.456e+78\",\n\t\t\texpected: []string{\"123.456e+78\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number with non-digit character\",\n\t\t\tinput:    \"123.45x\",\n\t\t\texpected: []string{\"\", \"123.45x\"},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number starting with non-digit character\",\n\t\t\tinput:    \"x123.45\",\n\t\t\texpected: []string{\"\", \"x123.45\"},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"inf\",\n\t\t\tinput:    \"inf\",\n\t\t\texpected: []string{\"inf\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"nan\",\n\t\t\tinput:    \"nan\",\n\t\t\texpected: []string{\"nan\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif num != tc.expected[0] {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) number = %q, expected %q\", tc.input, num, tc.expected[0])\n\t\t\t}\n\n\t\t\tif rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) rest = %q, expected %q\", tc.input, rest, tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "cd096a26bec96244813fa324ca0118d3": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tinput   string\n\t\twantVal *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"empty string\",\n\t\t\tinput:   \"\",\n\t\t\twantVal: nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"object\",\n\t\t\tinput:   `{\"key\":\"value\"}`,\n\t\t\twantVal: &Value{t: TypeObject},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"array\",\n\t\t\tinput:   `[1,2,3]`,\n\t\t\twantVal: &Value{t: TypeArray},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"string\",\n\t\t\tinput:   `\"hello\"`,\n\t\t\twantVal: &Value{t: typeRawString, s: \"hello\"},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"true\",\n\t\t\tinput:   \"true\",\n\t\t\twantVal: valueTrue,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"false\",\n\t\t\tinput:   \"false\",\n\t\t\twantVal: valueFalse,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"null\",\n\t\t\tinput:   \"null\",\n\t\t\twantVal: valueNull,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number\",\n\t\t\tinput:   \"123.45\",\n\t\t\twantVal: &Value{t: TypeNumber, s: \"123.45\"},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid value\",\n\t\t\tinput:   \"invalid\",\n\t\t\twantVal: nil,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotVal, _, err := parseValue(tt.input, c, 0)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (gotVal == nil && tt.wantVal != nil) || (gotVal != nil && tt.wantVal == nil) || (gotVal.t != tt.wantVal.t) {\n\t\t\t\tt.Errorf(\"parseValue() = %v, want %v\", gotVal, tt.wantVal)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c80f450b5ed4b0fa2ce024b7f69bb8fc": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: \"{}\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs:           []kv{},\n\t\t\t\t\t\tkeysUnescaped: true,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"simple object\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tkeysUnescaped: true,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with nested object\",\n\t\t\tinput: `{\"key1\":{\"subkey1\":\"subvalue1\"},\"key2\":42}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{k: \"key1\", v: &Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{k: \"subkey1\", v: &Value{t: TypeString, s: \"subvalue1\"}},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: true,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tkeysUnescaped: true,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with nested array\",\n\t\t\tinput: `{\"key1\":[1,2,3],\"key2\":42}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{k: \"key1\", v: &Value{\n\t\t\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tkeysUnescaped: true,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42`,\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing colon\",\n\t\t\tinput: `{\"key1\"\",\"key2\":42}`,\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, _, err := parseObject(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseObject(%q) = _, _, %v, want _, _, %v\", tc.input, err, tc.err)\n\t\t\t\t}\n\t\t\t} else if tc.err != nil {\n\t\t\t\tt.Errorf(\"parseObject(%q) = %v, _, nil, want _, _, %v\", tc.input, actual, tc.err)\n\t\t\t} else if !objectEqual(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseObject(%q) = %v, _, nil, want %v, _, nil\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc objectEqual(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.t == TypeObject {\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !objectEqual(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\tif v1.t == TypeArray {\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !objectEqual(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\treturn v1.s == v2.s\n}",
    "ce19768ad4ca3977d0976120357c68d6": "package fastjson\n\nimport \"testing\"\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\targs string\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: \"\",\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"string without whitespace\",\n\t\t\targs: \"hello\",\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with leading whitespace\",\n\t\t\targs: \"   hello\",\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with trailing whitespace\",\n\t\t\targs: \"hello   \",\n\t\t\twant: \"hello   \",\n\t\t},\n\t\t{\n\t\t\tname: \"string with leading and trailing whitespace\",\n\t\t\targs: \"   hello   \",\n\t\t\twant: \"hello   \",\n\t\t},\n\t\t{\n\t\t\tname: \"string with mixed whitespace\",\n\t\t\targs: \" \\t\\nhello\\r\\n \",\n\t\t\twant: \"hello\\r\\n \",\n\t\t},\n\t\t{\n\t\t\tname: \"string with only whitespace\",\n\t\t\targs: \" \\t\\n\\r\",\n\t\t\twant: \"\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.args); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "cee6ab93546cb62c80fb31265cc0b0c3": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantNum  string\n\t\twantRest string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.45e+6\",\n\t\t\twantNum:  \"123.45e+6\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with trailing characters\",\n\t\t\tinput:    \"123.45abc\",\n\t\t\twantNum:  \"123.45\",\n\t\t\twantRest: \"abc\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number\",\n\t\t\tinput:    \"abc123\",\n\t\t\twantNum:  \"\",\n\t\t\twantRest: \"abc123\",\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"inf\",\n\t\t\tinput:    \"inf\",\n\t\t\twantNum:  \"inf\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"nan\",\n\t\t\tinput:    \"nan\",\n\t\t\twantNum:  \"nan\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.wantNum {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) num = %q, want %q\", tc.input, num, tc.wantNum)\n\t\t\t}\n\t\t\tif rest != tc.wantRest {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) rest = %q, want %q\", tc.input, rest, tc.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "cf569eccca807a583e3e1abb4542ed42": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: []string{\"hello\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"he\\\"llo\"`,\n\t\t\texpected: []string{\"he\\\"llo\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"he\\\\\\\"llo\"`,\n\t\t\texpected: []string{\"he\\\\\\\"llo\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with no closing quote\",\n\t\t\tinput:    `\"hello`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot, gotRest, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tc.expected[0] {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, expected %v\", got, tc.expected[0])\n\t\t\t}\n\t\t\tif gotRest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawString() gotRest = %v, expected %v\", gotRest, tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "cbef8bb22fee92b10afa87f54f0a53b0": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty input\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"too deep JSON\",\n\t\t\tinput:    \"{\\\"a\\\":{\\\"b\\\":{\\\"c\\\":{\\\"d\\\":{}}}}\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t},\n\t\t{\n\t\t\tname:     \"valid object\",\n\t\t\tinput:    `{\"a\":1,\"b\":true,\"c\":\"hello\"}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"a\", v: &Value{t: TypeNumber, s: \"1\"}},\n\t\t\t\t\t\t{k: \"b\", v: valueTrue},\n\t\t\t\t\t\t{k: \"c\", v: &Value{t: TypeString, s: \"hello\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid true\",\n\t\t\tinput:    `true`,\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid false\",\n\t\t\tinput:    `false`,\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid null\",\n\t\t\tinput:    `null`,\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    `42`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42\",\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tv, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t\t}\n\t\t\t} else if tc.err != nil {\n\t\t\t\tt.Errorf(\"expected error: %v\", tc.err)\n\t\t\t} else if !valuesEqual(v, tc.expected) {\n\t\t\t\tt.Errorf(\"unexpected value: got %v, want %v\", v, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc valuesEqual(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn objectsEqual(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn arraysEqual(v1.a, v2.a)\n\tcase TypeString, TypeNumber, typeRawString:\n\t\treturn v1.s == v2.s\n\tcase TypeTrue, TypeFalse, TypeNull:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc objectsEqual(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !valuesEqual(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc arraysEqual(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tv2 := a2[i]\n\t\tif !valuesEqual(v1, v2) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "d17936696f61395fe3f9b52667ef3ece": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"Empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"No leading whitespace\",\n\t\t\tinput:    \"hello world\",\n\t\t\texpected: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Leading whitespace\",\n\t\t\tinput:    \"   hello world\",\n\t\t\texpected: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Leading and trailing whitespace\",\n\t\t\tinput:    \"   hello world   \",\n\t\t\texpected: \"hello world   \",\n\t\t},\n\t\t{\n\t\t\tname:     \"All whitespace\",\n\t\t\tinput:    \"   \\t\\n\\r\",\n\t\t\texpected: \"\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := skipWSSlow(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"skipWSSlow(%q) = %q; expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "cfc916037e0bc9ef8c3ad68cd5ccc315": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGet(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tinput *Value\n\t\tkeys  []string\n\t\twant  *Value\n\t}{\n\t\t{\n\t\t\tname: \"Get from object\",\n\t\t\tinput: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys: []string{\"key1\"},\n\t\t\twant: &Value{t: TypeString, s: \"value1\"},\n\t\t},\n\t\t{\n\t\t\tname: \"Get from array\",\n\t\t\tinput: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"value1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys: []string{\"1\"},\n\t\t\twant: &Value{t: TypeNumber, s: \"42\"},\n\t\t},\n\t\t{\n\t\t\tname:  \"Get from nil\",\n\t\t\tinput: nil,\n\t\t\tkeys:  []string{\"key\"},\n\t\t\twant:  nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Get non-existing key\",\n\t\t\tinput: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys: []string{\"key2\"},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Get from invalid type\",\n\t\t\tinput: &Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"value\",\n\t\t\t},\n\t\t\tkeys: []string{\"key\"},\n\t\t\twant: nil,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.input.Get(tt.keys...)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Get(%v) = %v, want %v\", tt.keys, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "d08a0b4bda078a33a560fef033579209": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Simple escape characters\",\n\t\t\tinput:    \"hello, \\\\\\\"world\\\\\\\"\",\n\t\t\texpected: \"hello, \\\"world\\\"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Complex escape characters\",\n\t\t\tinput:    \"hello, \\\\u0041\\\\u0042\\\\u0043\\\\u0044\",\n\t\t\texpected: \"hello, ABCD\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Incomplete escape characters\",\n\t\t\tinput:    \"hello, \\\\u004\",\n\t\t\texpected: \"hello, \\\\u004\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid escape characters\",\n\t\t\tinput:    \"hello, \\\\x\",\n\t\t\texpected: \"hello, \\\\x\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Surrogate pair escape characters\",\n\t\t\tinput:    \"hello, \\\\uD834\\\\uDD1E\",\n\t\t\texpected: \"hello, ùÑû\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Incomplete surrogate pair escape characters\",\n\t\t\tinput:    \"hello, \\\\uD834\",\n\t\t\texpected: \"hello, \\\\uD834\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "d19552cb4a85b8bdc7ee59d416f1defb": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: &Value{\n\t\t\t\ts: \"hello\",\n\t\t\t\tt: typeRawString,\n\t\t\t},\n\t\t\twant: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{s: \"value1\", t: TypeString}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{s: \"value2\", t: TypeString}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":\"value1\",\"key2\":\"value2\"}`),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"value1\", t: TypeString},\n\t\t\t\t\t{s: \"value2\", t: TypeString},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\twant: []byte(`[\"value1\",\"value2\"]`),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: &Value{\n\t\t\t\ts: \"hello\\\"world\",\n\t\t\t\tt: TypeString,\n\t\t\t},\n\t\t\twant: []byte(`\"hello\\\"world\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: &Value{\n\t\t\t\ts: \"42\",\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\twant: []byte(\"42\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "ce393aeae9568082d69d7a6c00ded17e": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"too deep depth\",\n\t\t\tinput:    \"{}\", // nested depth exceeds MaxDepth\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t},\n\t\t{\n\t\t\tname:     \"valid object\",\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: &Value{t: typeRawString, s: \"value\"}}}}},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid array\",\n\t\t\tinput:    `[\"value1\",\"value2\"]`,\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{{t: typeRawString, s: \"value1\"}, {t: typeRawString, s: \"value2\"}}},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{t: typeRawString, s: \"hello\"},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid true\",\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid false\",\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid null\",\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.45\",\n\t\t\texpected: &Value{t: TypeNumber, s: \"123.45\"},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid value\",\n\t\t\tinput:    \"invalid\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"unexpected value found: %q\", \"invalid\"),\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseValue(tc.input, c, 0)\n\t\t\tif (err != nil && tc.err == nil) || (err == nil && tc.err != nil) || (err != nil && tc.err != nil && err.Error() != tc.err.Error()) {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, expected %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !valueEqual(got, tc.expected) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, expected %v\", tc.input, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc valueEqual(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase typeRawString:\n\t\treturn v1.s == v2.s\n\tcase TypeObject:\n\t\treturn objectEqual(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !valueEqual(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeNumber, TypeTrue, TypeFalse, TypeNull:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\tpanic(\"BUG: unknown type\")\n\t}\n}\n\nfunc objectEqual(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i := range o1.kvs {\n\t\tif o1.kvs[i].k != o2.kvs[i].k {\n\t\t\treturn false\n\t\t}\n\t\tif !valueEqual(o1.kvs[i].v, o2.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "d37f73f2514549345a227ae9b96d41ee": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantKey  string\n\t\twantRest string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple key\",\n\t\t\tinput:    `\"key\":`,\n\t\t\twantKey:  \"key\",\n\t\t\twantRest: `:`,\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"key with escape sequence\",\n\t\t\tinput:    `\"key\\\":\":`,\n\t\t\twantKey:  `key\"`,\n\t\t\twantRest: `:`,\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing closing quote\",\n\t\t\tinput:    `\"key`,\n\t\t\twantKey:  `\"key`,\n\t\t\twantRest: ``,\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tkey, rest, err := parseRawKey(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawKey(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif key != tc.wantKey {\n\t\t\t\tt.Errorf(\"parseRawKey(%q) key = %q, want %q\", tc.input, key, tc.wantKey)\n\t\t\t}\n\t\t\tif rest != tc.wantRest {\n\t\t\t\tt.Errorf(\"parseRawKey(%q) rest = %q, want %q\", tc.input, rest, tc.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "d022cd027712a505cb7c482afa838bb6": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"empty input\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"depth exceeds max\",\n\t\t\tinput:    `{\"a\":{\"b\":{\"c\":{\"d\":{}}}}}`,\n\t\t\texpected: nil,\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"parse object\",\n\t\t\tinput:    `{\"a\":1,\"b\":true,\"c\":\"hello\"}`,\n\t\t\texpected: &Value{t: TypeObject},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"parse array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{t: TypeArray},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"parse string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{t: typeRawString, s: \"hello\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"parse true\",\n\t\t\tinput:    `true`,\n\t\t\texpected: valueTrue,\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"parse false\",\n\t\t\tinput:    `false`,\n\t\t\texpected: valueFalse,\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"parse null\",\n\t\t\tinput:    `null`,\n\t\t\texpected: valueNull,\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"parse number\",\n\t\t\tinput:    `123.45`,\n\t\t\texpected: &Value{t: TypeNumber, s: \"123.45\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"parse NaN\",\n\t\t\tinput:    `NaN`,\n\t\t\texpected: &Value{t: TypeNumber, s: \"NaN\"},\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseValue(tt.input, c, 0)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !equalsValue(got, tt.expected) {\n\t\t\t\tt.Errorf(\"parseValue() = %v, want %v\", got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalsValue(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase typeRawString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeTrue:\n\t\treturn true\n\tcase TypeFalse:\n\t\treturn true\n\tcase TypeNull:\n\t\treturn true\n\tcase TypeObject:\n\t\t// TODO: implement object comparison\n\t\treturn true\n\tcase TypeArray:\n\t\t// TODO: implement array comparison\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}",
    "d384e78a0455b8094e0cc981c2bfffd0": "package fastjson\n\nimport (\n    \"testing\"\n)\n\nfunc TestUnescapeKeys(t *testing.T) {\n    tests := []struct {\n        name string\n        obj  *Object\n        want *Object\n    }{\n        {\n            name: \"unescaped keys\",\n            obj: &Object{\n                kvs: []kv{\n                    {k: \"key1\", v: &Value{}},\n                    {k: \"key2\", v: &Value{}},\n                    {k: \"key\\u00a0\", v: &Value{}},\n                },\n                keysUnescaped: false,\n            },\n            want: &Object{\n                kvs: []kv{\n                    {k: \"key1\", v: &Value{}},\n                    {k: \"key2\", v: &Value{}},\n                    {k: \"key \", v: &Value{}},\n                },\n                keysUnescaped: true,\n            },\n        },\n        {\n            name: \"already unescaped keys\",\n            obj: &Object{\n                kvs: []kv{\n                    {k: \"key1\", v: &Value{}},\n                    {k: \"key2\", v: &Value{}},\n                    {k: \"key \", v: &Value{}},\n                },\n                keysUnescaped: true,\n            },\n            want: &Object{\n                kvs: []kv{\n                    {k: \"key1\", v: &Value{}},\n                    {k: \"key2\", v: &Value{}},\n                    {k: \"key \", v: &Value{}},\n                },\n                keysUnescaped: true,\n            },\n        },\n    }\n\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            tt.obj.unescapeKeys()\n            if !objectsEqual(tt.obj, tt.want) {\n                t.Errorf(\"unescapeKeys() = %v, want %v\", tt.obj, tt.want)\n            }\n        })\n    }\n}\n\nfunc objectsEqual(o1, o2 *Object) bool {\n    if len(o1.kvs) != len(o2.kvs) {\n        return false\n    }\n\n    for i := range o1.kvs {\n        if o1.kvs[i].k != o2.kvs[i].k {\n            return false\n        }\n        if o1.kvs[i].v != o2.kvs[i].v {\n            return false\n        }\n    }\n\n    return o1.keysUnescaped == o2.keysUnescaped\n}",
    "d4b604f7b013fd7cbb085e5d0f4c170d": "package fastjson\n\nimport (\n    \"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n    tests := []struct {\n        name     string\n        input    string\n        expected []string\n        wantErr  bool\n    }{\n        {\n            name:     \"valid number\",\n            input:    \"123.456\",\n            expected: []string{\"123.456\", \"\"},\n            wantErr:  false,\n        },\n        {\n            name:     \"number with exponent\",\n            input:    \"1.2e+3\",\n            expected: []string{\"1.2e+3\", \"\"},\n            wantErr:  false,\n        },\n        {\n            name:     \"invalid number\",\n            input:    \"abc\",\n            expected: []string{\"\", \"abc\"},\n            wantErr:  true,\n        },\n        {\n            name:     \"number with leading zeros\",\n            input:    \"00123.456\",\n            expected: []string{\"00123.456\", \"\"},\n            wantErr:  false,\n        },\n        {\n            name:     \"infinity\",\n            input:    \"inf\",\n            expected: []string{\"inf\", \"\"},\n            wantErr:  false,\n        },\n        {\n            name:     \"NaN\",\n            input:    \"nan\",\n            expected: []string{\"nan\", \"\"},\n            wantErr:  false,\n        },\n    }\n\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            got, remainder, err := parseRawNumber(tt.input)\n            if (err != nil) != tt.wantErr {\n                t.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n                return\n            }\n            if got != tt.expected[0] || remainder != tt.expected[1] {\n                t.Errorf(\"parseRawNumber() got = %v, %v, want %v, %v\", got, remainder, tt.expected[0], tt.expected[1])\n            }\n        })\n    }\n}",
    "d2756c18d2278ae148d9b3426eb9553b": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:  \"valid object\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing closing brace\",\n\t\t\tinput:    `{\"key1\":\"value1\",\"key2\":42`,\n\t\t\texpected: nil,\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing key\",\n\t\t\tinput:    `{:42}`,\n\t\t\texpected: nil,\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing value\",\n\t\t\tinput:    `{\"key1\":}`,\n\t\t\texpected: nil,\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tactual, _, err := parseObject(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !equalValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseObject() = %v, want %v\", actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeNull:\n\t\treturn true\n\tcase TypeObject:\n\t\treturn equalObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn equalArrays(v1.a, v2.a)\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber, TypeTrue, TypeFalse:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc equalObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !equalValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc equalArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tif !equalValues(v1, a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "d1c42aa0ff9a668dfcf23c9f797c946e": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid object\",\n\t\t\tinput:    `{\"key1\":\"value1\",\"key2\":123}`,\n\t\t\texpected: &Value{t: TypeObject, o: Object{kvs: []kv{{\"key1\", &Value{t: TypeString, s: \"value1\"}}, {\"key2\", &Value{t: TypeNumber, s: \"123\"}}}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty object\",\n\t\t\tinput:    `{}`,\n\t\t\texpected: &Value{t: TypeObject, o: Object{kvs: []kv{}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing closing brace\",\n\t\t\tinput:    `{\"key1\":\"value1\",\"key2\":123`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing key\",\n\t\t\tinput:    `{:123}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing colon\",\n\t\t\tinput:    `{\"key1\" \"value1\"}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing comma\",\n\t\t\tinput:    `{\"key1\":\"value1\" \"key2\":123}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tv, _, err := parseObject(tt.input, c, 0)\n\t\t\tif (err != nil) != tt.err {\n\t\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", tt.input, err, tt.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !Equal(v, tt.expected) {\n\t\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", tt.input, v, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// Equal compares two Value pointers for equality.\nfunc Equal(v1, v2 *Value) bool {\n\tif v1 == nil || v2 == nil {\n\t\treturn v1 == v2\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn equalObject(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn equalArray(v1.a, v2.a)\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber, TypeTrue, TypeFalse, TypeNull:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc equalObject(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !Equal(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc equalArray(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tif !Equal(v1, a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "d6b58a3300f6f0aa3be4fdc50d3224d9": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestStringBytes(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tv       *Value\n\t\twant    []byte\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"valid string\",\n\t\t\tv: &Value{\n\t\t\t\ts: \"hello, world\",\n\t\t\t\tt: TypeString,\n\t\t\t},\n\t\t\twant:    []byte(\"hello, world\"),\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"non-string type\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := tt.v.StringBytes()\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Value.StringBytes() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.StringBytes() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "d82823f69afa030b585520cf90bdf567": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestType_String(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    Type\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"TypeObject\",\n\t\t\tinput:    TypeObject,\n\t\t\texpected: \"object\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeArray\",\n\t\t\tinput:    TypeArray,\n\t\t\texpected: \"array\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeString\",\n\t\t\tinput:    TypeString,\n\t\t\texpected: \"string\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeNumber\",\n\t\t\tinput:    TypeNumber,\n\t\t\texpected: \"number\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeTrue\",\n\t\t\tinput:    TypeTrue,\n\t\t\texpected: \"true\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeFalse\",\n\t\t\tinput:    TypeFalse,\n\t\t\texpected: \"false\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeNull\",\n\t\t\tinput:    TypeNull,\n\t\t\texpected: \"null\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Default\",\n\t\t\tinput:    Type(100),\n\t\t\texpected: \"\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := tc.input.String()\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"expected %q, got %q\", tc.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "d4399876666ac672c67f3ad25ddf2cf4": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty input\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"too deep nested JSON\",\n\t\t\tinput:    \"{\\\"key\\\":{\\\"key\\\":{\\\"key\\\":{\\\"key\\\":{}}}}}\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t},\n\t\t{\n\t\t\tname:     \"valid object\",\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{t: TypeObject, o: Object{kvs: []kv{{\"key\", &Value{t: typeRawString, s: \"value\"}}}}},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid array\",\n\t\t\tinput:    `[\"value1\",\"value2\"]`,\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: typeRawString, s: \"value1\"}, &Value{t: typeRawString, s: \"value2\"}}},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid string\",\n\t\t\tinput:    `\"value\"`,\n\t\t\texpected: &Value{t: typeRawString, s: \"value\"},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid true\",\n\t\t\tinput:    `true`,\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid false\",\n\t\t\tinput:    `false`,\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid null\",\n\t\t\tinput:    `null`,\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    `42`,\n\t\t\texpected: &Value{t: TypeNumber, s: \"42\"},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid value\",\n\t\t\tinput:    `invalid`,\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"unexpected value found: %q\", \"invalid\"),\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tv, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) returned error %v, expected %v\", tc.input, err, tc.err)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif tc.expected == nil || !v.Equal(tc.expected) {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) returned %v, expected %v\", tc.input, v, tc.expected)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}",
    "db61f8c8bafafa3f785b8278370ea805": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"Simple string\",\n\t\t\tinput:    `\"hello world\"`,\n\t\t\texpected: []string{\"hello world\", \"\"},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"String with escaped quotes\",\n\t\t\tinput:    `\"hello \\\"world\\\"\"`,\n\t\t\texpected: []string{\"hello \\\"world\\\"\", \"\"},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"String with unmatched quotes\",\n\t\t\tinput:    `\"hello world`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Empty string\",\n\t\t\tinput:    `\"\"`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult, rest, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseRawString(%q) returned error %v, expected error: %t\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif result != tc.expected[0] {\n\t\t\t\tt.Errorf(\"parseRawString(%q) returned %q, expected %q\", tc.input, result, tc.expected[0])\n\t\t\t}\n\n\t\t\tif rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawString(%q) returned rest %q, expected %q\", tc.input, rest, tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "dc8ba8ea3d6e15a7873c4367652b2c60": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    string\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"Empty string\",\n\t\t\ts:    \"\",\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"String without leading whitespace\",\n\t\t\ts:    \"hello\",\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"String with leading whitespace\",\n\t\t\ts:    \"   hello\",\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"String with mixed whitespace\",\n\t\t\ts:    \"   \\t\\nhello\\r\\n\",\n\t\t\twant: \"hello\\r\\n\",\n\t\t},\n\t\t{\n\t\t\tname: \"String with only whitespace\",\n\t\t\ts:    \"   \\t\\n\\r\",\n\t\t\twant: \"\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow(%q) = %q, want %q\", tt.s, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "d5afcbd21334131754f319a21296c8e1": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tinput   string\n\t\twant    *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty array\",\n\t\t\tinput: \"[]\",\n\t\t\twant: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"single element array\",\n\t\t\tinput: \"[1]\",\n\t\t\twant: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"multi-element array\",\n\t\t\tinput: \"[1,2,3]\",\n\t\t\twant: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with whitespace\",\n\t\t\tinput: \"[ 1 , 2 , 3 ]\",\n\t\t\twant: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"incomplete array\",\n\t\t\tinput: \"[1,\",\n\t\t\twant:  nil,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tgot, _, err := parseArray(tt.input, c, 0)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeArray:\n\t\ta1, _ := v1.Array()\n\t\ta2, _ := v2.Array()\n\t\tif len(a1) != len(a2) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range a1 {\n\t\t\tif !equalValues(a1[i], a2[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\tcase TypeObject:\n\t\to1, _ := v1.Object()\n\t\to2, _ := v2.Object()\n\t\tif o1.Len() != o2.Len() {\n\t\t\treturn false\n\t\t}\n\t\tfor _, kv1 := range o1.kvs {\n\t\t\tkv2 := o2.Get(kv1.k)\n\t\t\tif kv2 == nil || !equalValues(kv1.v, kv2) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\tcase TypeString:\n\t\ts1, _ := v1.StringBytes()\n\t\ts2, _ := v2.StringBytes()\n\t\treturn string(s1) == string(s2)\n\tcase TypeNumber, TypeTrue, TypeFalse:\n\t\treturn v1.s == v2.s\n\tcase TypeNull:\n\t\treturn true\n\t}\n\treturn true\n}",
    "de1d09d9d4effb17d78a1263560aee71": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"Empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"No leading whitespace\",\n\t\t\tinput:    \"hello world\",\n\t\t\texpected: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Leading whitespace\",\n\t\t\tinput:    \"  hello world\",\n\t\t\texpected: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Leading tabs and newlines\",\n\t\t\tinput:    \"\\t\\n  hello world\",\n\t\t\texpected: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"All whitespace\",\n\t\t\tinput:    \"   \\t\\n\",\n\t\t\texpected: \"\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := skipWSSlow(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"skipWSSlow(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "df4c44fc41f3659b59dbb32405ad0613": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetBool(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    *Value\n\t\tkeys     []string\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname:     \"True value\",\n\t\t\tinput:    &Value{t: TypeTrue},\n\t\t\tkeys:     []string{\"key1\", \"key2\"},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"False value\",\n\t\t\tinput:    &Value{t: TypeFalse},\n\t\t\tkeys:     []string{\"key1\", \"key2\"},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Non-existing keys\",\n\t\t\tinput:    &Value{t: TypeNull},\n\t\t\tkeys:     []string{\"key1\", \"key2\"},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid value type\",\n\t\t\tinput:    &Value{t: TypeString, s: \"some string\"},\n\t\t\tkeys:     []string{\"key1\", \"key2\"},\n\t\t\texpected: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := tc.input.GetBool(tc.keys...)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"GetBool(%v) = %v, expected %v\", tc.keys, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "dca2d006634fa60407c962b9f0af8fda": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"valid object\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{s: \"value1\", t: TypeString}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{s: \"42\", t: TypeNumber}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: \"{}\",\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"missing closing brace\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:  \"missing key\",\n\t\t\tinput: `{:42}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:  \"missing value\",\n\t\t\tinput: `{\"key1\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:  \"missing comma\",\n\t\t\tinput: `{\"key1\":\"value1\" \"key2\":42}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tv, _, err := parseObject(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"expected error: %v, got: %v\", tc.err, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(v, tc.expected) {\n\t\t\t\tt.Errorf(\"expected:\\n%+v\\ngot:\\n%+v\", tc.expected, v)\n\t\t\t}\n\t\t})\n\t}\n}",
    "dd219a2aa44bcb66c6744f5b2ba36ce9": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"no escape sequence\",\n\t\t\tinput:    \"hello, world!\",\n\t\t\texpected: \"hello, world!\",\n\t\t},\n\t\t{\n\t\t\tname:     \"simple escape sequence\",\n\t\t\tinput:    \"hello\\\\nworld\",\n\t\t\texpected: \"hello\\nworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple escape sequences\",\n\t\t\tinput:    \"hello\\\\n\\\\tworld\\\\\\\"\",\n\t\t\texpected: \"hello\\n\\tworld\\\"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid escape sequence\",\n\t\t\tinput:    \"hello\\\\xworld\",\n\t\t\texpected: \"hello\\\\xworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"surrogate pair\",\n\t\t\tinput:    \"hello\\\\uD83D\\\\uDE00world\",\n\t\t\texpected: \"helloüòÄworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"incomplete surrogate pair\",\n\t\t\tinput:    \"hello\\\\uD83Dworld\",\n\t\t\texpected: \"hello\\\\uD83Dworld\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e08540605cae6ed9a666d3cee7b412f7": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Simple escape characters\",\n\t\t\tinput:    \"hello\\\\\\\"world\\\\\\\\\",\n\t\t\texpected: \"hello\\\"world\\\\\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Unicode escape characters\",\n\t\t\tinput:    \"hello\\\\u0123world\\\\u4567\",\n\t\t\texpected: \"hello\\u0123world\\u4567\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Surrogate pair escape characters\",\n\t\t\tinput:    \"hello\\\\u0123\\\\u4567world\",\n\t\t\texpected: \"hello\\U00024567world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid escape characters\",\n\t\t\tinput:    \"hello\\\\uworld\\\\u12\",\n\t\t\texpected: \"hello\\\\uworld\\\\u12\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "dc8534c514a95ac790249388b3fb0c86": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantNum  string\n\t\twantRest string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid_integer\",\n\t\t\tinput:    \"123\",\n\t\t\twantNum:  \"123\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid_float\",\n\t\t\tinput:    \"3.14\",\n\t\t\twantNum:  \"3.14\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid_exponent\",\n\t\t\tinput:    \"1.23e4\",\n\t\t\twantNum:  \"1.23e4\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid_negative\",\n\t\t\tinput:    \"-42\",\n\t\t\twantNum:  \"-42\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid_leading_char\",\n\t\t\tinput:    \"a123\",\n\t\t\twantNum:  \"\",\n\t\t\twantRest: \"a123\",\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid_middle_char\",\n\t\t\tinput:    \"12a3\",\n\t\t\twantNum:  \"12\",\n\t\t\twantRest: \"a3\",\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid_inf\",\n\t\t\tinput:    \"inf\",\n\t\t\twantNum:  \"inf\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid_nan\",\n\t\t\tinput:    \"nan\",\n\t\t\twantNum:  \"nan\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.wantNum {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) num = %q, want %q\", tc.input, num, tc.wantNum)\n\t\t\t}\n\t\t\tif rest != tc.wantRest {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) rest = %q, want %q\", tc.input, rest, tc.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e0c44423b42e12e4986c689637048fc2": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tinput string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname: \"No escape sequences\",\n\t\t\tinput: \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname: \"Simple escape sequences\",\n\t\t\tinput: \"hello\\\\\\\"\\\\\\\\\\\\n\\\\r\\\\t\\\\b\\\\fworld\",\n\t\t\texpected: \"hello\\\"\\\\\\n\\r\\t\\b\\fworld\",\n\t\t},\n\t\t{\n\t\t\tname: \"Unicode escape sequences\",\n\t\t\tinput: \"hello\\\\u0041\\\\u00ffworld\",\n\t\t\texpected: \"helloA\\u00ffworld\",\n\t\t},\n\t\t{\n\t\t\tname: \"Surrogate pairs\",\n\t\t\tinput: \"hello\\\\ud83d\\\\ude00world\",\n\t\t\texpected: \"helloüòÄworld\",\n\t\t},\n\t\t{\n\t\t\tname: \"Invalid escape sequences\",\n\t\t\tinput: \"hello\\\\u123world\",\n\t\t\texpected: \"hello\\\\u123world\",\n\t\t},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "dde25cf643e56e97e53ca4ead8c2e7f0": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantNum  string\n\t\twantRest string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.45e+6\",\n\t\t\twantNum:  \"123.45e+6\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with sign\",\n\t\t\tinput:    \"-123.45e-6\",\n\t\t\twantNum:  \"-123.45e-6\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with trailing non-numeric\",\n\t\t\tinput:    \"123.45x\",\n\t\t\twantNum:  \"123.45\",\n\t\t\twantRest: \"x\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number\",\n\t\t\tinput:    \"abc\",\n\t\t\twantNum:  \"\",\n\t\t\twantRest: \"abc\",\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"inf\",\n\t\t\tinput:    \"inf\",\n\t\t\twantNum:  \"inf\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"nan\",\n\t\t\tinput:    \"nan\",\n\t\t\twantNum:  \"nan\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.wantNum {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) num = %q, want %q\", tc.input, num, tc.wantNum)\n\t\t\t}\n\t\t\tif rest != tc.wantRest {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) rest = %q, want %q\", tc.input, rest, tc.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e21671345d404e178d58a9be757c585b": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tinput   string\n\t\twantVal *Value\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty array\",\n\t\t\tinput: \"[]\",\n\t\t\twantVal: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with values\",\n\t\t\tinput: \"[1, true, \\\"foo\\\", null]\",\n\t\t\twantVal: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t\t{t: TypeString, s: \"foo\"},\n\t\t\t\t\t{t: TypeNull},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with missing closing bracket\",\n\t\t\tinput: \"[1, 2, 3\",\n\t\t\twantVal: nil,\n\t\t\twantS:   \"[1, 2, 3\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with missing comma\",\n\t\t\tinput: \"[1 2]\",\n\t\t\twantVal: nil,\n\t\t\twantS:   \"[1 2]\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotVal, gotS, err := parseArray(tt.input, c, 0)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(gotVal, tt.wantVal) {\n\t\t\t\tt.Errorf(\"parseArray() gotVal = %v, want %v\", gotVal, tt.wantVal)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseArray() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e23f2363915a7f8671a8500fbf19be5d": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":\"value1\",\"key2\":42}`),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"hello\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t\t{t: TypeFalse},\n\t\t\t\t\t{t: TypeNull},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`[\"hello\",42,true,false,null]`),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello \\\"world\\\"\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello \\\"world\\\"\"\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42\",\n\t\t\t},\n\t\t\twant: []byte(\"42\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := make([]byte, 0, 64)\n\t\t\tgot := tt.v.MarshalTo(dst)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %q, want %q\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e29ea33cab5b9f9fb4523fdea62a7bfd": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantNum  string\n\t\twantRest string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.456e+7\",\n\t\t\twantNum:  \"123.456e+7\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with negative exponent\",\n\t\t\tinput:    \"-0.00012e-3\",\n\t\t\twantNum:  \"-0.00012e-3\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with sign\",\n\t\t\tinput:    \"+123.45\",\n\t\t\twantNum:  \"+123.45\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with leading zeros\",\n\t\t\tinput:    \"0000123.45\",\n\t\t\twantNum:  \"0000123.45\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number (starts with non-digit)\",\n\t\t\tinput:    \"a123.45\",\n\t\t\twantNum:  \"\",\n\t\t\twantRest: \"a123.45\",\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number (inf)\",\n\t\t\tinput:    \"inf\",\n\t\t\twantNum:  \"inf\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number (nan)\",\n\t\t\tinput:    \"nan\",\n\t\t\twantNum:  \"nan\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNum, gotRest, err := parseRawNumber(tt.input)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tt.input, err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNum != tt.wantNum {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) gotNum = %v, want %v\", tt.input, gotNum, tt.wantNum)\n\t\t\t}\n\t\t\tif gotRest != tt.wantRest {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) gotRest = %v, want %v\", tt.input, gotRest, tt.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e3f590dbf2ba58be97e9c05ed05fbb1a": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestTypeString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tt        Type\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"TypeObject\",\n\t\t\tt:        TypeObject,\n\t\t\texpected: \"object\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeArray\",\n\t\t\tt:        TypeArray,\n\t\t\texpected: \"array\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeString\",\n\t\t\tt:        TypeString,\n\t\t\texpected: \"string\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeNumber\",\n\t\t\tt:        TypeNumber,\n\t\t\texpected: \"number\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeTrue\",\n\t\t\tt:        TypeTrue,\n\t\t\texpected: \"\", // TypeTrue should not return a string\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeFalse\",\n\t\t\tt:        TypeFalse,\n\t\t\texpected: \"false\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeNull\",\n\t\t\tt:        TypeNull,\n\t\t\texpected: \"null\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Unknown Type\",\n\t\t\tt:        Type(8), // Unknown type\n\t\t\texpected: \"\", // Should panic\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := tc.t.String()\n\t\t\tif got != tc.expected {\n\t\t\t\tt.Errorf(\"String() = %q, want %q\", got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e3eb0620aefa4f7a91429e17a5df1d87": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype testCase struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}\n\n\ttestCases := []testCase{\n\t\t{\n\t\t\tname:     \"no escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"simple escape characters\",\n\t\t\tinput:    \"hello\\\\\\\"\\\\\\\\\\\\n\\\\/\\\\b\\\\f\\\\r\\\\t\\\\u0123world\",\n\t\t\texpected: \"hello\\\"\\\\\\\\n/\\b\\f\\r\\t\\u0123world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"unicode surrogate pair\",\n\t\t\tinput:    \"hello\\\\uD83D\\\\uDE00world\",\n\t\t\texpected: \"helloüòÄworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid unicode escape\",\n\t\t\tinput:    \"hello\\\\uD83Dworld\",\n\t\t\texpected: \"hello\\\\uD83Dworld\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e367c07855bfa56e25589782286ec8b7": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype testCase struct {\n\t\tname     string\n\t\tinput    string\n\t\twantKey  string\n\t\twantRest string\n\t\twantErr  bool\n\t}\n\n\ttestCases := []testCase{\n\t\t{\n\t\t\tname:     \"Simple string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\twantKey:  \"hello\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"String with escaped quotes\",\n\t\t\tinput:    `\"hello\\\"world\"`,\n\t\t\twantKey:  `hello\"world`,\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"String with multiple escaped quotes\",\n\t\t\tinput:    `\"hello\\\"world\\\"foo\"`,\n\t\t\twantKey:  `hello\"world\"foo`,\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Missing closing quote\",\n\t\t\tinput:    `\"hello`,\n\t\t\twantKey:  \"\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Empty string\",\n\t\t\tinput:    `\"\"`,\n\t\t\twantKey:  \"\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tkey, rest, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif key != tc.wantKey {\n\t\t\t\tt.Errorf(\"parseRawString(%q) key = %q, want %q\", tc.input, key, tc.wantKey)\n\t\t\t}\n\t\t\tif rest != tc.wantRest {\n\t\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, want %q\", tc.input, rest, tc.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e32f3799b5fb1bcda0719fd195661530": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape sequences\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape double quotes\",\n\t\t\tinput:    \"\\\"hello, world\\\"\",\n\t\t\texpected: `\"hello, world\"`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backslash\",\n\t\t\tinput:    \"\\\\hello, world\\\\\",\n\t\t\texpected: `\\hello, world\\`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape forward slash\",\n\t\t\tinput:    \"/<hello, world>/\",\n\t\t\texpected: \"/<hello, world>/\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backspace\",\n\t\t\tinput:    \"h\\bello, world\",\n\t\t\texpected: \"h\\bello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape form feed\",\n\t\t\tinput:    \"h\\fello, world\",\n\t\t\texpected: \"h\\fello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape newline\",\n\t\t\tinput:    \"h\\nello, world\",\n\t\t\texpected: \"h\\nello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape carriage return\",\n\t\t\tinput:    \"h\\rello, world\",\n\t\t\texpected: \"h\\rello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape tab\",\n\t\t\tinput:    \"h\\tello, world\",\n\t\t\texpected: \"h\\tello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Unicode character\",\n\t\t\tinput:    \"\\\\u00a9hello, world\",\n\t\t\texpected: \"¬©hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape invalid Unicode character\",\n\t\t\tinput:    \"\\\\u00hello, world\",\n\t\t\texpected: \"\\\\u00hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape surrogate pair\",\n\t\t\tinput:    \"\\\\ud83d\\\\ude00hello, world\",\n\t\t\texpected: \"üòÄhello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape invalid surrogate pair\",\n\t\t\tinput:    \"\\\\ud83d\\\\hello, world\",\n\t\t\texpected: \"\\\\ud83d\\\\hello, world\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e5485be886fbf998b404fd9392355eb6": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetFloat64(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    *Value\n\t\tkeys     []string\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"Existing float64 value\",\n\t\t\tinput:    &Value{s: \"3.14\"},\n\t\t\tkeys:     []string{},\n\t\t\texpected: 3.14,\n\t\t},\n\t\t{\n\t\t\tname:     \"Non-existing keys path\",\n\t\t\tinput:    &Value{s: \"3.14\"},\n\t\t\tkeys:     []string{\"non\", \"existing\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid value type\",\n\t\t\tinput:    &Value{s: \"string\"},\n\t\t\tkeys:     []string{},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Array index in keys\",\n\t\t\tinput:    &Value{a: []*Value{&Value{s: \"3.14\"}}},\n\t\t\tkeys:     []string{\"0\"},\n\t\t\texpected: 3.14,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := tc.input.GetFloat64(tc.keys...)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"GetFloat64(%v) = %f, expected %f\", tc.keys, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e310404b1d11354d4286fbf82a7a9788": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: \"{}\",\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           []kv{},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with one key-value pair\",\n\t\t\tinput: `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with multiple key-value pairs\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":123,\"key3\":true}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\tinput: `{\"key\":\"value\"`,\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing colon\",\n\t\t\tinput: `{\"key\" \"value\"}`,\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing comma\",\n\t\t\tinput: `{\"key1\":\"value1\" \"key2\":123}`,\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tv, _, err := parseObject(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseObject(%q) error = %v, expected %v\", tc.input, err, tc.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif tc.err != nil {\n\t\t\t\t\tt.Errorf(\"parseObject(%q) error = nil, expected %v\", tc.input, tc.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif !reflect.DeepEqual(v, tc.expected) {\n\t\t\t\t\tt.Errorf(\"parseObject(%q) = %v, expected %v\", tc.input, v, tc.expected)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}",
    "e51e94608dd11bf35b4e80233aad4416": "package fastjson\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tv        *Value\n\t\texpected []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello, world\",\n\t\t\t},\n\t\t\texpected: []byte(`\"hello, world\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: []byte(`{\"key1\":\"value1\",\"key2\":42}`),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"item1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t\t{t: TypeTrue, s: \"true\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: []byte(`[\"item1\",42,true]`),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello, world\",\n\t\t\t},\n\t\t\texpected: []byte(`\"hello, world\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42\",\n\t\t\t},\n\t\t\texpected: []byte(\"42\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\texpected: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\texpected: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\texpected: []byte(\"null\"),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdst := make([]byte, 0, 64)\n\t\t\tgot := tc.v.MarshalTo(dst)\n\t\t\tif !bytes.Equal(got, tc.expected) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %q, expected %q\", got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e2f1c5765c1a8aba24c0ebf5d434d945": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty object\",\n\t\t\tinput:    \"{}\",\n\t\t\texpected: &Value{t: TypeObject, o: Object{}},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with one key-value pair\",\n\t\t\tinput: `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{t: TypeString, s: \"value\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with multiple key-value pairs\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":123,\"key3\":true}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t\t{k: \"key3\", v: &Value{t: TypeTrue}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with nested object\",\n\t\t\tinput: `{\"key1\":{\"subkey\":\"subvalue\"},\"key2\":123}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{\n\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t{k: \"subkey\", v: &Value{t: TypeString, s: \"subvalue\"}},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with nested array\",\n\t\t\tinput: `{\"key1\":[1,2,3],\"key2\":true}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{\n\t\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeTrue}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\tinput: `{\"key1\":\"value\"`,\n\t\t\texpected: nil,\n\t\t\terr:      ErrUnexpectedEnd,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing colon\",\n\t\t\tinput: `{\"key1\" \"value\"}`,\n\t\t\texpected: nil,\n\t\t\terr:      ErrMissingColon,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing comma\",\n\t\t\tinput: `{\"key1\":\"value\" \"key2\":\"value2\"}`,\n\t\t\texpected: nil,\n\t\t\terr:      ErrMissingComma,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv, _, err := parseObject(tt.input, c, 0)\n\t\t\tif err != tt.err {\n\t\t\t\tt.Errorf(\"parseObject(%q) error = %v, expected %v\", tt.input, err, tt.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(v, tt.expected) {\n\t\t\t\tt.Errorf(\"parseObject(%q) = %v, expected %v\", tt.input, v, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e3b625c10b9083a177ee75bf2554ab5a": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"empty array\",\n\t\t\tinput:    \"[]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with values\",\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}, &Value{t: TypeNumber, s: \"2\"}, &Value{t: TypeNumber, s: \"3\"}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with trailing comma\",\n\t\t\tinput:    \"[1, 2, 3,]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with missing close bracket\",\n\t\t\tinput:    \"[1, 2, 3\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tv, _, err := parseArray(tc.input, c, 0)\n\t\t\tif tc.err {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"expected error, but got none\")\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !v.Equal(tc.expected) {\n\t\t\t\tt.Errorf(\"expected %v, but got %v\", tc.expected, v)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc (v *Value) Equal(other *Value) bool {\n\tif v.t != other.t {\n\t\treturn false\n\t}\n\n\tswitch v.t {\n\tcase TypeArray:\n\t\ta1, _ := v.Array()\n\t\ta2, _ := other.Array()\n\t\tif len(a1) != len(a2) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range a1 {\n\t\t\tif !a1[i].Equal(a2[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeObject:\n\t\to1, _ := v.Object()\n\t\to2, _ := other.Object()\n\t\tif o1.Len() != o2.Len() {\n\t\t\treturn false\n\t\t}\n\t\tfor _, kv1 := range o1.kvs {\n\t\t\tkv2 := o2.Get(kv1.k)\n\t\t\tif kv2 == nil || !kv1.v.Equal(kv2) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeString:\n\t\ts1, _ := v.StringBytes()\n\t\ts2, _ := other.StringBytes()\n\t\treturn string(s1) == string(s2)\n\tcase TypeNumber:\n\t\tn1, _ := v.Float64()\n\t\tn2, _ := other.Float64()\n\t\treturn n1 == n2\n\tcase TypeTrue, TypeFalse:\n\t\tb1, _ := v.Bool()\n\t\tb2, _ := other.Bool()\n\t\treturn b1 == b2\n\tcase TypeNull:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}",
    "e59539ec2cf73eea40662f8b045e72c5": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestObject_Visit(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\to    *Object\n\t\twant []kv\n\t}{\n\t\t{\n\t\t\tname: \"nil object\",\n\t\t\to:    nil,\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\to:    &Object{},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"object with keys\",\n\t\t\to: &Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{\"key1\", &Value{s: \"value1\"}},\n\t\t\t\t\t{\"key2\", &Value{s: \"value2\"}},\n\t\t\t\t\t{\"key3\", &Value{s: \"value3\"}},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []kv{\n\t\t\t\t{\"key1\", &Value{s: \"value1\"}},\n\t\t\t\t{\"key2\", &Value{s: \"value2\"}},\n\t\t\t\t{\"key3\", &Value{s: \"value3\"}},\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tvar kvs []kv\n\t\t\ttt.o.Visit(func(key []byte, v *Value) {\n\t\t\t\tkvs = append(kvs, kv{s2b(key), v})\n\t\t\t})\n\n\t\t\tif !reflect.DeepEqual(kvs, tt.want) {\n\t\t\t\tt.Errorf(\"Object.Visit() = %v, want %v\", kvs, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc s2b(s string) []byte {\n\treturn []byte(s)\n}",
    "e5859f88ecff2e15e312b6c54fde32c3": "package fastjson\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tv        *Value\n\t\texpected []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello, world\",\n\t\t\t},\n\t\t\texpected: []byte(`\"hello, world\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: []byte(`{\"key1\":\"value1\",\"key2\":42}`),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"elem1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: []byte(`[\"elem1\",42,true]`),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello, world\",\n\t\t\t},\n\t\t\texpected: []byte(`\"hello, world\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42\",\n\t\t\t},\n\t\t\texpected: []byte(\"42\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\texpected: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\texpected: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\texpected: []byte(\"null\"),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdst := make([]byte, 0, 64)\n\t\t\tactual := tc.v.MarshalTo(dst)\n\t\t\tif !bytes.Equal(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %q, expected %q\", actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e6cb490bb2c0d83ed347c3d9f08ba14a": "package fastjson\n\nimport \"testing\"\n\nfunc TestSkipWS(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"empty input\",\n\t\t\tinput:    \"\",\n\t\t\texpected: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"input with leading whitespace\",\n\t\t\tinput:    \"   hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"input with trailing whitespace\",\n\t\t\tinput:    \"hello   \",\n\t\t\texpected: \"hello   \",\n\t\t},\n\t\t{\n\t\t\tname:     \"input with leading and trailing whitespace\",\n\t\t\tinput:    \"   hello   \",\n\t\t\texpected: \"hello   \",\n\t\t},\n\t\t{\n\t\t\tname:     \"input with no whitespace\",\n\t\t\tinput:    \"hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tresult := skipWS(test.input)\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"skipWS(%q) = %q, expected %q\", test.input, result, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e68dfded8d2b26a44da71ff5e78c83dd": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.456e+78\",\n\t\t\texpected: []string{\"123.456e+78\", \"\"},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with leading sign\",\n\t\t\tinput:    \"-0.1\",\n\t\t\texpected: []string{\"-0.1\", \"\"},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with leading zeros\",\n\t\t\tinput:    \"0.0001\",\n\t\t\texpected: []string{\"0.0001\", \"\"},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with exponent\",\n\t\t\tinput:    \"1e-6\",\n\t\t\texpected: []string{\"1e-6\", \"\"},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with exponent and sign\",\n\t\t\tinput:    \"-1e+6\",\n\t\t\texpected: []string{\"-1e+6\", \"\"},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number with trailing characters\",\n\t\t\tinput:    \"123.456abc\",\n\t\t\texpected: []string{\"123.456\", \"abc\"},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number with single character\",\n\t\t\tinput:    \"a\",\n\t\t\texpected: []string{\"\", \"a\"},\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number with two characters\",\n\t\t\tinput:    \"-a\",\n\t\t\texpected: []string{\"\", \"-a\"},\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number with inf\",\n\t\t\tinput:    \"inf\",\n\t\t\texpected: []string{\"inf\", \"\"},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number with nan\",\n\t\t\tinput:    \"nan\",\n\t\t\texpected: []string{\"nan\", \"\"},\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif tc.err && err == nil {\n\t\t\t\tt.Errorf(\"expected error, but got none\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tc.err && err != nil {\n\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.expected[0] {\n\t\t\t\tt.Errorf(\"unexpected number: got %q, want %q\", num, tc.expected[0])\n\t\t\t}\n\t\t\tif rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"unexpected rest: got %q, want %q\", rest, tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "e7400b10fb6d7115b93dba7c2dfd9129": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"no escape sequences\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"simple escape sequences\",\n\t\t\tinput:    \"hello\\\\n\\\\t\\\\r\\\\\\\"\\\\\\\\world\",\n\t\t\texpected: \"hello\\n\\t\\r\\\"\\\\world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"unicode escape sequences\",\n\t\t\tinput:    \"hello\\\\u0041\\\\u0042\\\\u0043world\",\n\t\t\texpected: \"helloABCworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"surrogate pair escape sequences\",\n\t\t\tinput:    \"hello\\\\ud83d\\\\ude00world\",\n\t\t\texpected: \"helloüòÄworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid escape sequences\",\n\t\t\tinput:    \"hello\\\\uworld\\\\n\\\\xhello\",\n\t\t\texpected: \"hello\\\\uworld\\n\\\\xhello\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e783a3e5d0076d408007be0cbdc07566": "// fastjson_test.go\n\npackage fastjson\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestObjectReset(t *testing.T) {\n\t// Create a new Object\n\tobj := &Object{\n\t\tkvs:           []kv{{k: \"key1\", v: &Value{s: \"value1\"}}, {k: \"key2\", v: &Value{s: \"value2\"}}},\n\t\tkeysUnescaped: true,\n\t}\n\n\t// Call the reset method\n\tobj.reset()\n\n\t// Verify that the kvs slice has been reset to an empty slice\n\tassert.Equal(t, 0, len(obj.kvs))\n\n\t// Verify that the keysUnescaped flag has been reset to false\n\tassert.False(t, obj.keysUnescaped)\n}",
    "e6b2976f720156be6211fd77b2f75c07": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello, world\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello, world\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":\"value1\",\"key2\":42}`),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"str1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"123\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`[\"str1\",123,true]`),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello, world\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello, world\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42\",\n\t\t\t},\n\t\t\twant: []byte(\"42\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"unknown type\",\n\t\t\tv: &Value{\n\t\t\t\tt: 100,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e7490200a8c15ff50bab2c7d5fde9cac": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected struct {\n\t\t\tkey  string\n\t\t\trest string\n\t\t\terr  error\n\t\t}\n\t}{\n\t\t{\n\t\t\tname:  \"simple string\",\n\t\t\tinput: `\"hello\"world`,\n\t\t\texpected: struct {\n\t\t\t\tkey  string\n\t\t\t\trest string\n\t\t\t\terr  error\n\t\t\t}{\n\t\t\t\tkey:  \"hello\",\n\t\t\t\trest: \"world\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"string with escaped quote\",\n\t\t\tinput: `\"he\\\"llo\"world`,\n\t\t\texpected: struct {\n\t\t\t\tkey  string\n\t\t\t\trest string\n\t\t\t\terr  error\n\t\t\t}{\n\t\t\t\tkey:  `he\"llo`,\n\t\t\t\trest: \"world\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"string with missing closing quote\",\n\t\t\tinput: `\"hello`,\n\t\t\texpected: struct {\n\t\t\t\tkey  string\n\t\t\t\trest string\n\t\t\t\terr  error\n\t\t\t}{\n\t\t\t\tkey:  \"hello\",\n\t\t\t\trest: \"\",\n\t\t\t\terr:  ErrMissingClosingQuote,\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tkey, rest, err := parseRawString(tc.input)\n\t\t\tif err != tc.expected.err {\n\t\t\t\tt.Errorf(\"expected error %v, got %v\", tc.expected.err, err)\n\t\t\t}\n\t\t\tif key != tc.expected.key {\n\t\t\t\tt.Errorf(\"expected key %q, got %q\", tc.expected.key, key)\n\t\t\t}\n\t\t\tif rest != tc.expected.rest {\n\t\t\t\tt.Errorf(\"expected rest %q, got %q\", tc.expected.rest, rest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "eb0bed6b248796ac2aa5e59b1e4f4066": "package fastjson\n\nimport (\n    \"testing\"\n)\n\nfunc TestTypeString(t *testing.T) {\n    testCases := []struct {\n        name string\n        typ  Type\n        want string\n    }{\n        {\n            name: \"TypeObject\",\n            typ:  TypeObject,\n            want: \"object\",\n        },\n        {\n            name: \"TypeArray\",\n            typ:  TypeArray,\n            want: \"array\",\n        },\n        {\n            name: \"TypeString\",\n            typ:  TypeString,\n            want: \"string\",\n        },\n        {\n            name: \"TypeNumber\",\n            typ:  TypeNumber,\n            want: \"number\",\n        },\n        {\n            name: \"TypeTrue\",\n            typ:  TypeTrue,\n            want: \"true\",\n        },\n        {\n            name: \"TypeFalse\",\n            typ:  TypeFalse,\n            want: \"false\",\n        },\n        {\n            name: \"TypeNull\",\n            typ:  TypeNull,\n            want: \"null\",\n        },\n        {\n            name: \"Unknown Type\",\n            typ:  Type(7),\n            want: \"BUG: unknown Value type: 7\",\n        },\n    }\n\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            got := tc.typ.String()\n            if got != tc.want {\n                t.Errorf(\"Type.String() = %q, want %q\", got, tc.want)\n            }\n        })\n    }\n}",
    "e74702fd6fc7d1ac731ed0c5591cd278": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: \"{}\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{t: TypeObject}\n\t\t\t\tv.o.reset()\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"simple object\",\n\t\t\tinput: `{\"key\":\"value\"}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{t: TypeObject}\n\t\t\t\tv.o.reset()\n\t\t\t\tkv := v.o.getKV()\n\t\t\t\tkv.k = \"key\"\n\t\t\t\tkv.v = &Value{t: TypeString, s: \"value\"}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with nested object\",\n\t\t\tinput: `{\"key\":{\"nested_key\":\"nested_value\"}}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{t: TypeObject}\n\t\t\t\tv.o.reset()\n\t\t\t\tkv := v.o.getKV()\n\t\t\t\tkv.k = \"key\"\n\t\t\t\tnestedV := &Value{t: TypeObject}\n\t\t\t\tnestedKV := nestedV.o.getKV()\n\t\t\t\tnestedKV.k = \"nested_key\"\n\t\t\t\tnestedKV.v = &Value{t: TypeString, s: \"nested_value\"}\n\t\t\t\tkv.v = nestedV\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\tinput: `{\"key\":\"value\"`,\n\t\t\texpected: nil,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseObject(test.input, c, 0)\n\t\t\tif (err != nil) != test.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, test.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !objectsEqual(got, test.expected) {\n\t\t\t\tt.Errorf(\"parseObject() = %v, want %v\", got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc objectsEqual(a, b *Value) bool {\n\tif a == nil && b == nil {\n\t\treturn true\n\t}\n\tif a == nil || b == nil {\n\t\treturn false\n\t}\n\tif a.t != b.t {\n\t\treturn false\n\t}\n\tswitch a.t {\n\tcase TypeObject:\n\t\treturn objectsEqual(a.Get(\"key\"), b.Get(\"key\"))\n\tcase TypeString:\n\t\treturn a.s == b.s\n\tdefault:\n\t\treturn true\n\t}\n}",
    "e897c35ec322a812216cfd3f5ff03ffd": "package fastjson\n\nimport \"testing\"\n\nfunc TestGetInt(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    *Value\n\t\tkeys     []string\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"valid int value\",\n\t\t\tinput:    &Value{s: \"42\", t: TypeNumber},\n\t\t\tkeys:     []string{},\n\t\t\texpected: 42,\n\t\t},\n\t\t{\n\t\t\tname:     \"non-existing key path\",\n\t\t\tinput:    &Value{s: \"42\", t: TypeNumber},\n\t\t\tkeys:     []string{\"foo\", \"bar\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid value type\",\n\t\t\tinput:    &Value{s: \"foo\", t: TypeString},\n\t\t\tkeys:     []string{},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"int value out of range\",\n\t\t\tinput:    &Value{s: \"9223372036854775807\", t: TypeNumber},\n\t\t\tkeys:     []string{},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"array index in keys\",\n\t\t\tinput:    &Value{a: []*Value{&Value{s: \"42\", t: TypeNumber}}},\n\t\t\tkeys:     []string{\"0\"},\n\t\t\texpected: 42,\n\t\t},\n\t\t{\n\t\t\tname:     \"decimal array index in keys\",\n\t\t\tinput:    &Value{a: []*Value{&Value{s: \"42\", t: TypeNumber}, &Value{s: \"84\", t: TypeNumber}}},\n\t\t\tkeys:     []string{\"1.0\"},\n\t\t\texpected: 84,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual := tc.input.GetInt(tc.keys...)\n\t\t\tif actual != tc.expected {\n\t\t\t\tt.Errorf(\"GetInt(%v) = %d, expected %d\", tc.keys, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "ea1af124e3f14fce95ff74dac77cb87e": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetKV(t *testing.T) {\n\to := &Object{}\n\tkv := o.getKV()\n\tif kv == nil {\n\t\tt.Errorf(\"getKV() returned nil\")\n\t}\n\tif len(o.kvs) != 1 {\n\t\tt.Errorf(\"expected len(o.kvs) to be 1, got %d\", len(o.kvs))\n\t}\n\tif &o.kvs[0] != kv {\n\t\tt.Errorf(\"getKV() returned a different kv pointer\")\n\t}\n\n\t// Test that the kv slice is expanded when it's full\n\tfor i := 0; i < cap(o.kvs)-len(o.kvs)+1; i++ {\n\t\to.getKV()\n\t}\n\tif len(o.kvs) != cap(o.kvs) {\n\t\tt.Errorf(\"expected len(o.kvs) to be equal to cap(o.kvs), got %d != %d\", len(o.kvs), cap(o.kvs))\n\t}\n\tkv = o.getKV()\n\tif &o.kvs[len(o.kvs)-1] != kv {\n\t\tt.Errorf(\"getKV() returned a different kv pointer\")\n\t}\n}",
    "eb071f816583aa7cfc1e96a4582d81f2": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantNum  string\n\t\twantRest string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.45e+67\",\n\t\t\twantNum:  \"123.45e+67\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with trailing characters\",\n\t\t\tinput:    \"123.45e+67abc\",\n\t\t\twantNum:  \"123.45e+67\",\n\t\t\twantRest: \"abc\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number (starts with non-digit)\",\n\t\t\tinput:    \"a123.45e+67\",\n\t\t\twantNum:  \"\",\n\t\t\twantRest: \"a123.45e+67\",\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number (invalid exponent)\",\n\t\t\tinput:    \"123.45e+\",\n\t\t\twantNum:  \"\",\n\t\t\twantRest: \"123.45e+\",\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number (empty input)\",\n\t\t\tinput:    \"\",\n\t\t\twantNum:  \"\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid infinity\",\n\t\t\tinput:    \"inf\",\n\t\t\twantNum:  \"inf\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid negative infinity\",\n\t\t\tinput:    \"-inf\",\n\t\t\twantNum:  \"-inf\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid NaN\",\n\t\t\tinput:    \"nan\",\n\t\t\twantNum:  \"nan\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNum, gotRest, err := parseRawNumber(tt.input)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tt.input, err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNum != tt.wantNum {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) gotNum = %v, want %v\", tt.input, gotNum, tt.wantNum)\n\t\t\t}\n\t\t\tif gotRest != tt.wantRest {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) gotRest = %v, want %v\", tt.input, gotRest, tt.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e83bb0b3a53e8c49660f6e11d35138f1": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:  \"valid object\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42,\"key3\":true}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tobj := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t\t\t{k: \"key3\", v: &Value{t: TypeTrue}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn obj\n\t\t\t}(),\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42,`,\n\t\t\texpected: func() *Value {\n\t\t\t\tobj := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn obj\n\t\t\t}(),\n\t\t\terr: errMissingClosingBrace,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing colon\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\" 42}`,\n\t\t\texpected: nil,\n\t\t\terr:     errMissingColon,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing quotes around key\",\n\t\t\tinput: `{key1:\"value1\",\"key2\":42}`,\n\t\t\texpected: nil,\n\t\t\terr:     errMissingOpeningQuote,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tv, _, err := parseObject(tc.input, c, 0)\n\t\t\tif err != tc.err {\n\t\t\t\tt.Errorf(\"expected error %v, got %v\", tc.err, err)\n\t\t\t}\n\t\t\tif !compareValues(t, v, tc.expected) {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tc.expected, v)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(t *testing.T, actual, expected *Value) bool {\n\tif actual == nil && expected == nil {\n\t\treturn true\n\t}\n\tif actual == nil || expected == nil {\n\t\treturn false\n\t}\n\tif actual.t != expected.t {\n\t\treturn false\n\t}\n\tswitch actual.t {\n\tcase TypeObject:\n\t\tif len(actual.o.kvs) != len(expected.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, kv := range actual.o.kvs {\n\t\t\tif kv.k != expected.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !compareValues(t, kv.v, expected.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\tcase TypeArray:\n\t\tif len(actual.a) != len(expected.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, v := range actual.a {\n\t\t\tif !compareValues(t, v, expected.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\tcase TypeString:\n\t\treturn actual.s == expected.s\n\tcase TypeNumber, TypeTrue, TypeFalse:\n\t\treturn actual.s == expected.s\n\tdefault:\n\t\tt.Errorf(\"unsupported type: %v\", actual.t)\n\t\treturn false\n\t}\n\treturn true\n}",
    "eb885289b7d2fd99a584dd8528e7a597": "package fastjson_test\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected struct {\n\t\t\tkey   string\n\t\t\tvalue string\n\t\t\terr   error\n\t\t}\n\t}{\n\t\t{\n\t\t\tname:  \"simple string\",\n\t\t\tinput: `\"hello\"`,\n\t\t\texpected: struct {\n\t\t\t\tkey   string\n\t\t\t\tvalue string\n\t\t\t\terr   error\n\t\t\t}{\n\t\t\t\tkey:   `\"hello\"`,\n\t\t\t\tvalue: \"\",\n\t\t\t\terr:   nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"string with escaped quote\",\n\t\t\tinput: `\"hello\\\"world\"`,\n\t\t\texpected: struct {\n\t\t\t\tkey   string\n\t\t\t\tvalue string\n\t\t\t\terr   error\n\t\t\t}{\n\t\t\t\tkey:   `\"hello\\\"world\"`,\n\t\t\t\tvalue: \"\",\n\t\t\t\terr:   nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"missing closing quote\",\n\t\t\tinput: `\"hello`,\n\t\t\texpected: struct {\n\t\t\t\tkey   string\n\t\t\t\tvalue string\n\t\t\t\terr   error\n\t\t\t}{\n\t\t\t\tkey:   \"\",\n\t\t\t\tvalue: \"\",\n\t\t\t\terr:   errMissingClosingQuote,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"empty string\",\n\t\t\tinput: `\"\"`,\n\t\t\texpected: struct {\n\t\t\t\tkey   string\n\t\t\t\tvalue string\n\t\t\t\terr   error\n\t\t\t}{\n\t\t\t\tkey:   `\"\"`,\n\t\t\t\tvalue: \"\",\n\t\t\t\terr:   nil,\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tkey, value, err := parseRawString(tc.input)\n\t\t\tif err != tc.expected.err {\n\t\t\t\tt.Errorf(\"expected error %v, got %v\", tc.expected.err, err)\n\t\t\t}\n\t\t\tif key != tc.expected.key {\n\t\t\t\tt.Errorf(\"expected key %q, got %q\", tc.expected.key, key)\n\t\t\t}\n\t\t\tif value != tc.expected.value {\n\t\t\t\tt.Errorf(\"expected value %q, got %q\", tc.expected.value, value)\n\t\t\t}\n\t\t})\n\t}\n}",
    "ebf2cbcce69e6375a3f5bae521ef8b70": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t\trest     string\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.456e+78\",\n\t\t\texpected: \"123.456e+78\",\n\t\t\trest:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid character\",\n\t\t\tinput:    \"123.456a\",\n\t\t\texpected: \"\",\n\t\t\trest:     \"123.456a\",\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"leading plus sign\",\n\t\t\tinput:    \"+123.456\",\n\t\t\texpected: \"+123.456\",\n\t\t\trest:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"leading minus sign\",\n\t\t\tinput:    \"-123.456\",\n\t\t\texpected: \"-123.456\",\n\t\t\trest:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"inf\",\n\t\t\tinput:    \"inf\",\n\t\t\texpected: \"inf\",\n\t\t\trest:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"nan\",\n\t\t\tinput:    \"nan\",\n\t\t\texpected: \"nan\",\n\t\t\trest:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, expected error: %t\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.expected {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, expected %q\", tc.input, num, tc.expected)\n\t\t\t}\n\t\t\tif rest != tc.rest {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) rest = %q, expected %q\", tc.input, rest, tc.rest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "eb2f7a09786ed520e3c0026730fb8e56": "package fastjson\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n)\n\nfunc TestMarshalTo(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: &Value{\n\t\t\t\ts: `\"hello, world\"`,\n\t\t\t\tt: typeRawString,\n\t\t\t},\n\t\t\twant: []byte(`\"hello, world\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{s: \"value1\", t: TypeString}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{s: \"value2\", t: TypeString}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":\"value1\",\"key2\":\"value2\"}`),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"item1\", t: TypeString},\n\t\t\t\t\t{s: \"item2\", t: TypeString},\n\t\t\t\t\t{s: \"item3\", t: TypeString},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\twant: []byte(`[\"item1\",\"item2\",\"item3\"]`),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: &Value{\n\t\t\t\ts: \"hello, world\",\n\t\t\t\tt: TypeString,\n\t\t\t},\n\t\t\twant: []byte(`\"hello, world\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: &Value{\n\t\t\t\ts: \"42\",\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\twant: []byte(\"42\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdst := make([]byte, 0, len(tc.want))\n\t\t\tgot := tc.v.MarshalTo(dst)\n\t\t\tif !bytes.Equal(got, tc.want) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %q, want %q\", got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "ec026c231b0d836d21a262081a7a59a0": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    *Value\n\t\tkeys     []string\n\t\texpected *Object\n\t}{\n\t\t{\n\t\t\tname: \"Valid object\",\n\t\t\tinput: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"key1\", \"key2\"},\n\t\t\texpected: &Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"Non-existing key\",\n\t\t\tinput: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"key3\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Invalid type\",\n\t\t\tinput: &Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"invalid\",\n\t\t\t},\n\t\t\tkeys:     []string{\"key1\"},\n\t\t\texpected: nil,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := tc.input.GetObject(tc.keys...)\n\t\t\tif tc.expected != got {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tc.expected, got)\n\t\t\t}\n\t\t})\n\t}\n}",
    "ed2bbe5d8b0addacee0007eb6c33fdd0": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestTypeString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tt        Type\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"TypeObject\",\n\t\t\tt:        TypeObject,\n\t\t\texpected: \"object\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeArray\",\n\t\t\tt:        TypeArray,\n\t\t\texpected: \"array\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeString\",\n\t\t\tt:        TypeString,\n\t\t\texpected: \"string\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeNumber\",\n\t\t\tt:        TypeNumber,\n\t\t\texpected: \"number\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeTrue\",\n\t\t\tt:        TypeTrue,\n\t\t\texpected: \"true\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeFalse\",\n\t\t\tt:        TypeFalse,\n\t\t\texpected: \"false\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeNull\",\n\t\t\tt:        TypeNull,\n\t\t\texpected: \"null\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Unknown\",\n\t\t\tt:        8, // A value outside the defined constants\n\t\t\texpected: \"BUG: unknown Value type: 8\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := tc.t.String()\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unexpected result: got %q, want %q\", result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "ecb9681ec50f26f5fdb26414aabd3121": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"no escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"simple escape characters\",\n\t\t\tinput:    \"hello\\\\\\\"world\\\\n\\\\r\\\\t\\\\b\\\\f\",\n\t\t\texpected: \"hello\\\"world\\n\\r\\t\\b\\f\",\n\t\t},\n\t\t{\n\t\t\tname:     \"unicode escape characters\",\n\t\t\tinput:    \"hello\\\\u0123world\\\\u4567\",\n\t\t\texpected: \"hello\\u0123world\\u4567\",\n\t\t},\n\t\t{\n\t\t\tname:     \"surrogate pair\",\n\t\t\tinput:    \"hello\\\\ud800\\\\udc00world\",\n\t\t\texpected: \"hello\\U00010000world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid unicode escape\",\n\t\t\tinput:    \"hello\\\\uXYZZworld\",\n\t\t\texpected: \"hello\\\\uXYZZworld\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "ed7f1f9db9ebf8c730e6dec6ab9e2901": "package fastjson\n\nimport (\n    \"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n    tests := []struct {\n        name    string\n        input   string\n        wantErr bool\n    }{\n        {\n            name:    \"valid JSON\",\n            input:   `{\"key\":\"value\"}`,\n            wantErr: false,\n        },\n        {\n            name:    \"invalid JSON\",\n            input:   `{\"key\":}`,\n            wantErr: true,\n        },\n        {\n            name:    \"empty input\",\n            input:   \"\",\n            wantErr: true,\n        },\n    }\n\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            p := &Parser{}\n            _, err := p.Parse(tt.input)\n            if (err != nil) != tt.wantErr {\n                t.Errorf(\"Parse() error = %v, wantErr %v\", err, tt.wantErr)\n                return\n            }\n        })\n    }\n}",
    "ed60335579948b7d973b557c9487f30f": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Uint64(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tv       *Value\n\t\twant    uint64\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"valid number\",\n\t\t\tv:    &Value{s: \"42\", t: TypeNumber},\n\t\t\twant: 42,\n\t\t},\n\t\t{\n\t\t\tname:    \"non-number type\",\n\t\t\tv:       &Value{s: \"true\", t: TypeTrue},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number\",\n\t\t\tv:       &Value{s: \"invalid\", t: TypeNumber},\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := tt.v.Uint64()\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Value.Uint64() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Value.Uint64() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "ebf877e63e90ebbf0504c5ddb8afea58": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty input\",\n\t\t\tinput:    \"\",\n\t\t\texpected: \"\",\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"depth exceeds MaxDepth\",\n\t\t\tinput:    \"{}\", // Simulate deep nesting by calling parseValue recursively\n\t\t\texpected: \"\",\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t},\n\t\t{\n\t\t\tname:     \"valid object\",\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: `{\"key\":\"value\"}`,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid array\",\n\t\t\tinput:    `[\"value1\",\"value2\"]`,\n\t\t\texpected: `[\"value1\",\"value2\"]`,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid string\",\n\t\t\tinput:    `\"hello, world!\"`,\n\t\t\texpected: `\"hello, world!\"`,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid true\",\n\t\t\tinput:    \"true\",\n\t\t\texpected: \"true\",\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid false\",\n\t\t\tinput:    \"false\",\n\t\t\texpected: \"false\",\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid null\",\n\t\t\tinput:    \"null\",\n\t\t\texpected: \"null\",\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"42\",\n\t\t\texpected: \"42\",\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid value\",\n\t\t\tinput:    \"invalid\",\n\t\t\texpected: \"\",\n\t\t\terr:      fmt.Errorf(\"unexpected value found: %q\", \"invalid\"),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tv, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, expected %v\", tc.input, err, tc.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif tc.err != nil {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) error = nil, expected %v\", tc.input, tc.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif v.String() != tc.expected {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) = %v, expected %v\", tc.input, v.String(), tc.expected)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}",
    "e7853b1995be2a7e0f2c932045cca477": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname       string\n\t\tinput      string\n\t\twantValue  *Value\n\t\twantTail   string\n\t\twantErrMsg string\n\t}{\n\t\t{\n\t\t\tname:       \"empty input\",\n\t\t\tinput:      \"\",\n\t\t\twantValue:  nil,\n\t\t\twantTail:   \"\",\n\t\t\twantErrMsg: \"cannot parse empty string\",\n\t\t},\n\t\t{\n\t\t\tname:       \"too big depth\",\n\t\t\tinput:      \"{}\", // Assuming MaxDepth is 1 for this test case\n\t\t\twantValue:  nil,\n\t\t\twantTail:   \"{\",\n\t\t\twantErrMsg: \"too big depth for the nested JSON; it exceeds 1\",\n\t\t},\n\t\t{\n\t\t\tname:       \"valid object\",\n\t\t\tinput:      `{\"key\":\"value\"}`,\n\t\t\twantValue:  &Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: &Value{t: typeRawString, s: \"value\"}}}}},\n\t\t\twantTail:   \"\",\n\t\t\twantErrMsg: \"\",\n\t\t},\n\t\t{\n\t\t\tname:       \"valid array\",\n\t\t\tinput:      `[1,2,3]`,\n\t\t\twantValue:  &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}, &Value{t: TypeNumber, s: \"2\"}, &Value{t: TypeNumber, s: \"3\"}}},\n\t\t\twantTail:   \"\",\n\t\t\twantErrMsg: \"\",\n\t\t},\n\t\t{\n\t\t\tname:       \"valid string\",\n\t\t\tinput:      `\"hello\"`,\n\t\t\twantValue:  &Value{t: typeRawString, s: \"hello\"},\n\t\t\twantTail:   \"\",\n\t\t\twantErrMsg: \"\",\n\t\t},\n\t\t{\n\t\t\tname:       \"valid true\",\n\t\t\tinput:      \"true\",\n\t\t\twantValue:  valueTrue,\n\t\t\twantTail:   \"\",\n\t\t\twantErrMsg: \"\",\n\t\t},\n\t\t{\n\t\t\tname:       \"valid false\",\n\t\t\tinput:      \"false\",\n\t\t\twantValue:  valueFalse,\n\t\t\twantTail:   \"\",\n\t\t\twantErrMsg: \"\",\n\t\t},\n\t\t{\n\t\t\tname:       \"valid null\",\n\t\t\tinput:      \"null\",\n\t\t\twantValue:  valueNull,\n\t\t\twantTail:   \"\",\n\t\t\twantErrMsg: \"\",\n\t\t},\n\t\t{\n\t\t\tname:       \"valid number\",\n\t\t\tinput:      \"123\",\n\t\t\twantValue:  &Value{t: TypeNumber, s: \"123\"},\n\t\t\twantTail:   \"\",\n\t\t\twantErrMsg: \"\",\n\t\t},\n\t\t{\n\t\t\tname:       \"invalid value\",\n\t\t\tinput:      \"invalid\",\n\t\t\twantValue:  nil,\n\t\t\twantTail:   \"invalid\",\n\t\t\twantErrMsg: \"unexpected value found: \\\"invalid\\\"\",\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgotValue, gotTail, gotErr := parseValue(tc.input, c, 0)\n\t\t\tif gotErr != nil {\n\t\t\t\tif tc.wantErrMsg == \"\" {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) returned unexpected error: %v\", tc.input, gotErr)\n\t\t\t\t} else if gotErr.Error() != tc.wantErrMsg {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) returned unexpected error: got %v, want %s\", tc.input, gotErr, tc.wantErrMsg)\n\t\t\t\t}\n\t\t\t} else if tc.wantErrMsg != \"\" {\n\t\t\t\tt.Errorf(\"parseValue(%q) did not return expected error: %s\", tc.input, tc.wantErrMsg)\n\t\t\t}\n\n\t\t\tif !equalValues(gotValue, tc.wantValue) {\n\t\t\t\tt.Errorf(\"parseValue(%q) returned unexpected value: got %+v, want %+v\", tc.input, gotValue, tc.wantValue)\n\t\t\t}\n\n\t\t\tif gotTail != tc.wantTail {\n\t\t\t\tt.Errorf(\"parseValue(%q) returned unexpected tail: got %q, want %q\", tc.input, gotTail, tc.wantTail)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase typeRawString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeObject:\n\t\treturn equalObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn equalArrays(v1.a, v2.a)\n\tcase TypeTrue, TypeFalse, TypeNull:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc equalObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !equalValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc equalArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tif !equalValues(v1, a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "f05845715af1ed66ea29327c8a4a23ec": "package fastjson\n\nimport (\n    \"testing\"\n)\n\nfunc TestGetValue(t *testing.T) {\n    c := &cache{\n        vs: []Value{\n            {}, // This will be overwritten\n        },\n    }\n\n    v := c.getValue()\n    if v == nil {\n        t.Errorf(\"getValue() returned nil\")\n    }\n\n    if len(c.vs) != 2 {\n        t.Errorf(\"expected len(c.vs) = 2, got %d\", len(c.vs))\n    }\n\n    if &c.vs[1] != v {\n        t.Errorf(\"returned pointer doesn't match the cache value\")\n    }\n}",
    "efa4903c7248777618b60131d2acc577": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"Hello, world!\",\n\t\t\texpected: \"Hello, world!\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Simple escape characters\",\n\t\t\tinput:    \"Hello, \\\\\\\"world\\\\\\\"!\",\n\t\t\texpected: \"Hello, \\\"world\\\"!\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Unicode escape characters\",\n\t\t\tinput:    \"Hello, \\\\u00A9 world!\",\n\t\t\texpected: \"Hello, ¬© world!\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Surrogate pair escape characters\",\n\t\t\tinput:    \"Hello, \\\\uD83D\\\\uDE00 world!\",\n\t\t\texpected: \"Hello, üòÄ world!\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid escape characters\",\n\t\t\tinput:    \"Hello, \\\\x world!\",\n\t\t\texpected: \"Hello, \\\\x world!\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "ee281fd673e0e5921d985e16d66274ec": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"hello world\",\n\t\t\texpected: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Simple escape characters\",\n\t\t\tinput:    \"hello\\\\\\\"world\\\\\\\\\",\n\t\t\texpected: \"hello\\\"world\\\\\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Complex escape characters\",\n\t\t\tinput:    \"hello\\\\u0001\\\\u0002\\\\b\\\\f\\\\n\\\\r\\\\tworld\",\n\t\t\texpected: \"hello\\u0001\\u0002\\b\\f\\n\\r\\tworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Surrogate pair\",\n\t\t\tinput:    \"hello\\\\ud83d\\\\ude01world\",\n\t\t\texpected: \"helloüòÅworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid escape sequence\",\n\t\t\tinput:    \"hello\\\\uworld\",\n\t\t\texpected: \"hello\\\\uworld\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "edc73e729f5fb16c77ddb02f2d62c7f4": "package fastjson\n\nimport (\n    \"bytes\"\n    \"reflect\"\n    \"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n    tests := []struct {\n        name string\n        v    *Value\n        want []byte\n    }{\n        {\n            name: \"raw string\",\n            v: &Value{\n                t: typeRawString,\n                s: \"hello\",\n            },\n            want: []byte(`\"hello\"`),\n        },\n        {\n            name: \"object\",\n            v: &Value{\n                t: TypeObject,\n                o: Object{\n                    kvs: []kv{\n                        {k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n                        {k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n                    },\n                },\n            },\n            want: []byte(`{\"key1\":\"value1\",\"key2\":42}`),\n        },\n        {\n            name: \"array\",\n            v: &Value{\n                t: TypeArray,\n                a: []*Value{\n                    {t: TypeString, s: \"str1\"},\n                    {t: TypeNumber, s: \"42\"},\n                    {t: TypeTrue},\n                    {t: TypeFalse},\n                    {t: TypeNull},\n                },\n            },\n            want: []byte(`[\"str1\",42,true,false,null]`),\n        },\n        {\n            name: \"string\",\n            v: &Value{\n                t: TypeString,\n                s: \"hello\\\"world\",\n            },\n            want: []byte(`\"hello\\\"world\"`),\n        },\n        {\n            name: \"number\",\n            v: &Value{\n                t: TypeNumber,\n                s: \"42.5\",\n            },\n            want: []byte(\"42.5\"),\n        },\n        {\n            name: \"true\",\n            v: &Value{\n                t: TypeTrue,\n            },\n            want: []byte(\"true\"),\n        },\n        {\n            name: \"false\",\n            v: &Value{\n                t: TypeFalse,\n            },\n            want: []byte(\"false\"),\n        },\n        {\n            name: \"null\",\n            v: &Value{\n                t: TypeNull,\n            },\n            want: []byte(\"null\"),\n        },\n    }\n\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            dst := make([]byte, 0, 100)\n            got := tt.v.MarshalTo(dst)\n            if !reflect.DeepEqual(got, tt.want) {\n                t.Errorf(\"Value.MarshalTo() = %s, want %s\", got, tt.want)\n            }\n        })\n    }\n}",
    "f23543cc8a2f20450756636e16c7ac84": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetKV(t *testing.T) {\n\t// Test when there is enough capacity in the kvs slice\n\to := &Object{\n\t\tkvs: make([]kv, 2, 4),\n\t}\n\tkv := o.getKV()\n\tif len(o.kvs) != 3 {\n\t\tt.Errorf(\"expected length of kvs to be 3, got %d\", len(o.kvs))\n\t}\n\tif kv != &o.kvs[2] {\n\t\tt.Errorf(\"expected kv to be the last element in the kvs slice\")\n\t}\n\n\t// Test when there is not enough capacity in the kvs slice\n\to = &Object{\n\t\tkvs: make([]kv, 4, 4),\n\t}\n\tkv = o.getKV()\n\tif len(o.kvs) != 5 {\n\t\tt.Errorf(\"expected length of kvs to be 5, got %d\", len(o.kvs))\n\t}\n\tif kv != &o.kvs[4] {\n\t\tt.Errorf(\"expected kv to be the last element in the kvs slice\")\n\t}\n}",
    "f131920ae34d0848f01ae4cda57a1695": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_getKV(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\to    *Object\n\t\twant *kv\n\t}{\n\t\t{\n\t\t\tname: \"KVs slice has available capacity\",\n\t\t\to: &Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"key1\", v: &Value{}},\n\t\t\t\t\t{k: \"key2\", v: &Value{}},\n\t\t\t\t\t{k: \"key3\", v: &Value{}},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: &kv{k: \"\", v: nil},\n\t\t},\n\t\t{\n\t\t\tname: \"KVs slice has no available capacity\",\n\t\t\to: &Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"key1\", v: &Value{}},\n\t\t\t\t\t{k: \"key2\", v: &Value{}},\n\t\t\t\t\t{k: \"key3\", v: &Value{}},\n\t\t\t\t\t{k: \"key4\", v: &Value{}},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: &kv{k: \"\", v: nil},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.o.getKV(); !equalKV(got, tt.want) {\n\t\t\t\tt.Errorf(\"Object.getKV() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalKV(a, b *kv) bool {\n\tif a == nil && b == nil {\n\t\treturn true\n\t}\n\tif a == nil || b == nil {\n\t\treturn false\n\t}\n\treturn a.k == b.k && a.v == b.v\n}",
    "f090bde8d09c3c16eb0203495d317a50": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype testCase struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}\n\n\ttestCases := []testCase{\n\t\t{\n\t\t\tname:  \"valid object\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: `{}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"missing closing brace\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42`,\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"missing key\",\n\t\t\tinput: `{:42}`,\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"invalid value\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":true}`,\n\t\t\terr:   true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tv, _, err := parseObject(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"expected error: %t, got error: %v\", tc.err, err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif err == nil && !v.Equal(tc.expected) {\n\t\t\t\tt.Errorf(\"expected result: %v, got: %v\", tc.expected, v)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f43be1abf4b1b32657a9009cca3aa5f7": "package fastjson\n\nimport (\n    \"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n    testCases := []struct {\n        name     string\n        input    string\n        expected []string\n        wantErr  bool\n    }{\n        {\n            name:     \"simple string\",\n            input:    `\"hello world\"`,\n            expected: []string{\"hello world\", \"\"},\n            wantErr:  false,\n        },\n        {\n            name:     \"string with escaped quote\",\n            input:    `\"hello \\\"world\\\"\"`,\n            expected: []string{\"hello \\\"world\\\"\", \"\"},\n            wantErr:  false,\n        },\n        {\n            name:     \"string with multiple escaped quotes\",\n            input:    `\"hello \\\"world\\\" \\\"foo\\\"\"`,\n            expected: []string{\"hello \\\"world\\\" \\\"foo\\\"\", \"\"},\n            wantErr:  false,\n        },\n        {\n            name:     \"string with no closing quote\",\n            input:    `\"hello world`,\n            expected: []string{\"\", \"\"},\n            wantErr:  true,\n        },\n    }\n\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            got1, got2, err := parseRawString(tc.input)\n            if (err != nil) != tc.wantErr {\n                t.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tc.wantErr)\n                return\n            }\n            if got1 != tc.expected[0] {\n                t.Errorf(\"parseRawString() got1 = %v, expected %v\", got1, tc.expected[0])\n            }\n            if got2 != tc.expected[1] {\n                t.Errorf(\"parseRawString() got2 = %v, expected %v\", got2, tc.expected[1])\n            }\n        })\n    }\n}",
    "f42b808694ac056f3434ca48d3a97f42": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tinput   string\n\t\twantObj *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: `{}`,\n\t\t\twantObj: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: nil,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with one key-value pair\",\n\t\t\tinput: `{\"key1\":\"value1\"}`,\n\t\t\twantObj: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with multiple key-value pairs\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42,\"key3\":true}`,\n\t\t\twantObj: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t\t{k: \"key3\", v: &Value{t: TypeTrue}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\tinput: `{\"key1\":\"value1\",`,\n\t\t\twantObj: nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing colon\",\n\t\t\tinput: `{\"key1\" \"value1\"}`,\n\t\t\twantObj: nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing key\",\n\t\t\tinput: `{:42}`,\n\t\t\twantObj: nil,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tgotObj, _, err := parseObject(tt.input, c, 0)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(gotObj, tt.wantObj) {\n\t\t\t\tt.Errorf(\"parseObject() gotObj = %v, want %v\", gotObj, tt.wantObj)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f4bcb92947eb553e92ce8b89aba331e3": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"no escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"simple escape characters\",\n\t\t\tinput:    \"hello\\\\\\\"\\\\\\\\\\\\n\\\\tworld\",\n\t\t\texpected: \"hello\\\"\\\\\\n\\tworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"unicode escape characters\",\n\t\t\tinput:    \"hello\\\\u0041\\\\u0042\\\\u0043world\",\n\t\t\texpected: \"helloABCworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"surrogate pairs\",\n\t\t\tinput:    \"hello\\\\ud83d\\\\ude00world\",\n\t\t\texpected: \"helloüòÄworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid escape characters\",\n\t\t\tinput:    \"hello\\\\x00world\",\n\t\t\texpected: \"hello\\\\x00world\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f0667afc84cf5da4eedaac8df46a195b": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tinput   string\n\t\twant    *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: \"{}\",\n\t\t\twant: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with one key-value pair\",\n\t\t\tinput: `{\"key\":\"value\"}`,\n\t\t\twant: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with multiple key-value pairs\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42,\"key3\":true}`,\n\t\t\twant: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"42\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\tinput: `{\"key\":\"value\"`,\n\t\t\twant:  nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing colon\",\n\t\t\tinput: `{\"key\" \"value\"}`,\n\t\t\twant:  nil,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tgot, _, err := parseObject(tt.input, c, 0)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !valueEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc valueEqual(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn objectEqual(v1.o, v2.o)\n\tcase TypeArray:\n\t\treturn arrayEqual(v1.a, v2.a)\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber, TypeTrue, TypeFalse:\n\t\treturn v1.s == v2.s\n\tcase TypeNull:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc objectEqual(o1, o2 Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !valueEqual(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc arrayEqual(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tv2 := a2[i]\n\t\tif !valueEqual(v1, v2) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "f507afd9a2e710907103163f30938768": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape sequence\",\n\t\t\tinput:    \"Hello, world!\",\n\t\t\texpected: \"Hello, world!\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Simple escape sequence\",\n\t\t\tinput:    \"Hello\\\\\\\"world\\\\\\\\\",\n\t\t\texpected: \"Hello\\\"world\\\\\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Complex escape sequence\",\n\t\t\tinput:    \"Hello\\\\u0041\\\\u00C4\\\\u00df\\\\u0020world!\",\n\t\t\texpected: \"HelloA√Ñ√ü world!\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Incomplete escape sequence\",\n\t\t\tinput:    \"Hello\\\\u004\",\n\t\t\texpected: \"Hello\\\\u004\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid escape sequence\",\n\t\t\tinput:    \"Hello\\\\uXYZ world!\",\n\t\t\texpected: \"Hello\\\\uXYZ world!\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Surrogate pair\",\n\t\t\tinput:    \"Hello\\\\uD800\\\\uDC00 world!\",\n\t\t\texpected: \"Hello\\U00010000 world!\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Incomplete surrogate pair\",\n\t\t\tinput:    \"Hello\\\\uD800 world!\",\n\t\t\texpected: \"Hello\\\\uD800 world!\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f1d4a580fbdf8c143281df8713dc7b06": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tinput   string\n\t\twantV   *Value\n\t\twantTail string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:    \"empty input\",\n\t\t\tinput:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"max depth exceeded\",\n\t\t\tinput:   \"{}\", // Depth of 1, max depth is 100\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"parse object\",\n\t\t\tinput:   `{\"key\":\"value\"}`,\n\t\t\twantV:   &Value{o: Object{kvs: []kv{{k: \"key\", v: &Value{s: \"value\", t: typeRawString}}}}, t: TypeObject},\n\t\t\twantTail: \"\",\n\t\t},\n\t\t{\n\t\t\tname:    \"parse array\",\n\t\t\tinput:   `[1,2,3]`,\n\t\t\twantV:   &Value{a: []*Value{&Value{s: \"1\", t: TypeNumber}, &Value{s: \"2\", t: TypeNumber}, &Value{s: \"3\", t: TypeNumber}}, t: TypeArray},\n\t\t\twantTail: \"\",\n\t\t},\n\t\t{\n\t\t\tname:    \"parse string\",\n\t\t\tinput:   `\"hello\"`,\n\t\t\twantV:   &Value{s: \"hello\", t: typeRawString},\n\t\t\twantTail: \"\",\n\t\t},\n\t\t{\n\t\t\tname:    \"parse true\",\n\t\t\tinput:   `true`,\n\t\t\twantV:   valueTrue,\n\t\t\twantTail: \"\",\n\t\t},\n\t\t{\n\t\t\tname:    \"parse false\",\n\t\t\tinput:   `false`,\n\t\t\twantV:   valueFalse,\n\t\t\twantTail: \"\",\n\t\t},\n\t\t{\n\t\t\tname:    \"parse null\",\n\t\t\tinput:   `null`,\n\t\t\twantV:   valueNull,\n\t\t\twantTail: \"\",\n\t\t},\n\t\t{\n\t\t\tname:    \"parse number\",\n\t\t\tinput:   `42`,\n\t\t\twantV:   &Value{s: \"42\", t: TypeNumber},\n\t\t\twantTail: \"\",\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotV, gotTail, gotErr := parseValue(tt.input, c, 0)\n\t\t\tif (gotErr != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", gotErr, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !equalValue(gotV, tt.wantV) {\n\t\t\t\tt.Errorf(\"parseValue() gotV = %v, want %v\", gotV, tt.wantV)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseValue() gotTail = %v, want %v\", gotTail, tt.wantTail)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValue(v1, v2 *Value) bool {\n\tif v1 == nil || v2 == nil {\n\t\treturn v1 == v2\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn equalObject(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn equalArray(v1.a, v2.a)\n\tcase typeRawString, TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber, TypeTrue, TypeFalse, TypeNull:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc equalObject(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !equalValue(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc equalArray(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tif !equalValue(v1, a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "f59ee05c8531a20d9be7e8f6127935d7": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"this is a test string\",\n\t\t\texpected: \"this is a test string\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape double quote\",\n\t\t\tinput:    \"\\\"hello\\\"\",\n\t\t\texpected: \"\\\"hello\\\"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backslash\",\n\t\t\tinput:    \"\\\\\",\n\t\t\texpected: \"\\\\\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape forward slash\",\n\t\t\tinput:    \"/\",\n\t\t\texpected: \"/\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backspace\",\n\t\t\tinput:    \"\\b\",\n\t\t\texpected: \"\\b\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape form feed\",\n\t\t\tinput:    \"\\f\",\n\t\t\texpected: \"\\f\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape newline\",\n\t\t\tinput:    \"\\n\",\n\t\t\texpected: \"\\n\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape carriage return\",\n\t\t\tinput:    \"\\r\",\n\t\t\texpected: \"\\r\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape tab\",\n\t\t\tinput:    \"\\t\",\n\t\t\texpected: \"\\t\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Unicode character\",\n\t\t\tinput:    \"\\\\u0041\",\n\t\t\texpected: \"A\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape surrogate pair\",\n\t\t\tinput:    \"\\\\ud83d\\\\ude00\",\n\t\t\texpected: \"üòÄ\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid escape sequence\",\n\t\t\tinput:    \"\\\\x\",\n\t\t\texpected: \"\\\\x\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f52a9ba437685c8435afc8b5272bb656": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetInt(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    *Value\n\t\tkeys     []string\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname: \"Existing integer key\",\n\t\t\tinput: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42\",\n\t\t\t},\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: 42,\n\t\t},\n\t\t{\n\t\t\tname: \"Non-existing key\",\n\t\t\tinput: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"key2\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Invalid value type\",\n\t\t\tinput: &Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"non-numeric\",\n\t\t\t},\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Array index access\",\n\t\t\tinput: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"10\"},\n\t\t\t\t\t{t: TypeNumber, s: \"20\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"1\"},\n\t\t\texpected: 20,\n\t\t},\n\t\t{\n\t\t\tname: \"Array index out of range\",\n\t\t\tinput: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"10\"},\n\t\t\t\t\t{t: TypeNumber, s: \"20\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"2\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Floating-point number\",\n\t\t\tinput: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"3.14\",\n\t\t\t},\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"Integer overflow\",\n\t\t\tinput: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"9223372036854775807\",\n\t\t\t},\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := tc.input.GetInt(tc.keys...)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"GetInt(%v) = %d, expected %d\", tc.keys, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f4ec22d1a5a18bc89b39a41074f20a98": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantNum  string\n\t\twantRest string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.456e-78\",\n\t\t\twantNum:  \"123.456e-78\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with special characters\",\n\t\t\tinput:    \"123.456x\",\n\t\t\twantNum:  \"123.456\",\n\t\t\twantRest: \"x\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty input\",\n\t\t\tinput:    \"\",\n\t\t\twantNum:  \"\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number\",\n\t\t\tinput:    \"abc\",\n\t\t\twantNum:  \"\",\n\t\t\twantRest: \"abc\",\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with leading zeros\",\n\t\t\tinput:    \"0123.45\",\n\t\t\twantNum:  \"0123.45\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with leading sign\",\n\t\t\tinput:    \"-123.45\",\n\t\t\twantNum:  \"-123.45\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with leading sign and zeros\",\n\t\t\tinput:    \"-0123.45\",\n\t\t\twantNum:  \"-0123.45\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with 'inf' suffix\",\n\t\t\tinput:    \"inf\",\n\t\t\twantNum:  \"inf\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with 'nan' suffix\",\n\t\t\tinput:    \"nan\",\n\t\t\twantNum:  \"nan\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.wantNum {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) num = %q, want %q\", tc.input, num, tc.wantNum)\n\t\t\t}\n\t\t\tif rest != tc.wantRest {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) rest = %q, want %q\", tc.input, rest, tc.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f1fe434c7c5c4eee4f1b5f499d63ef52": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"object\",\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: typeRawString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"array\",\n\t\t\tinput:    `[\"item1\",\"item2\"]`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: typeRawString,\n\t\t\t\t\t\ts: \"item1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: typeRawString,\n\t\t\t\t\t\ts: \"item2\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"true\",\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"false\",\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"null\",\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"number\",\n\t\t\tinput:    \"42\",\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42\",\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"too deep\",\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tv, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, expected %v\", tc.input, err, tc.err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif tc.err != nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = nil, expected %v\", tc.input, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !valueEqual(v, tc.expected) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, expected %v\", tc.input, v, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc valueEqual(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\to1, _ := v1.Object()\n\t\to2, _ := v2.Object()\n\t\treturn objectEqual(o1, o2)\n\tcase TypeArray:\n\t\ta1, _ := v1.Array()\n\t\ta2, _ := v2.Array()\n\t\tif len(a1) != len(a2) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range a1 {\n\t\t\tif !valueEqual(a1[i], a2[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase typeRawString, TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeTrue, TypeFalse, TypeNull:\n\t\treturn true\n\tdefault:\n\t\tpanic(\"unreachable\")\n\t}\n}\n\nfunc objectEqual(o1, o2 *Object) bool {\n\tif o1 == nil && o2 == nil {\n\t\treturn true\n\t}\n\tif o1 == nil || o2 == nil {\n\t\treturn false\n\t}\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i := range o1.kvs {\n\t\tif o1.kvs[i].k != o2.kvs[i].k {\n\t\t\treturn false\n\t\t}\n\t\tif !valueEqual(o1.kvs[i].v, o2.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "f5e0639406a7ac149ef59ce46b9fd877": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_getKV(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\to    *Object\n\t\twant *kv\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\to:    &Object{},\n\t\t\twant: &kv{},\n\t\t},\n\t\t{\n\t\t\tname: \"object with existing kvs\",\n\t\t\to: &Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"key1\", v: &Value{}},\n\t\t\t\t\t{k: \"key2\", v: &Value{}},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: &kv{},\n\t\t},\n\t\t{\n\t\t\tname: \"object with capacity greater than length\",\n\t\t\to: &Object{\n\t\t\t\tkvs: make([]kv, 2, 3),\n\t\t\t},\n\t\t\twant: &kv{},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.o.getKV(); !equalKV(got, tt.want) {\n\t\t\t\tt.Errorf(\"Object.getKV() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalKV(a, b *kv) bool {\n\tif a == nil && b == nil {\n\t\treturn true\n\t}\n\tif a == nil || b == nil {\n\t\treturn false\n\t}\n\treturn a.k == b.k && a.v == b.v\n}",
    "f61bfa80baef78dd9ee3035bba841ed5": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"no leading whitespace\",\n\t\t\tinput:    \"abc\",\n\t\t\texpected: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading space\",\n\t\t\tinput:    \" abc\",\n\t\t\texpected: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading tab\",\n\t\t\tinput:    \"\\tabc\",\n\t\t\texpected: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading newline\",\n\t\t\tinput:    \"\\nabc\",\n\t\t\texpected: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading carriage return\",\n\t\t\tinput:    \"\\rabc\",\n\t\t\texpected: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple leading whitespace\",\n\t\t\tinput:    \"   \\t\\n\\r abc\",\n\t\t\texpected: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname:     \"all whitespace\",\n\t\t\tinput:    \"   \\t\\n\\r \",\n\t\t\texpected: \"\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := skipWSSlow(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"skipWSSlow(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f583068e21b7ee06f424a489cd2eb93d": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"valid object\",\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{o: Object{kvs: []kv{{k: \"key\", v: &Value{s: \"value\", t: TypeString}}}}, t: TypeObject},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{a: []*Value{&Value{s: \"1\", t: TypeNumber}, &Value{s: \"2\", t: TypeNumber}, &Value{s: \"3\", t: TypeNumber}}, t: TypeArray},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{s: \"hello\", t: TypeString},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid true\",\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid false\",\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid null\",\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"42\",\n\t\t\texpected: &Value{s: \"42\", t: TypeNumber},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"too deep\",\n\t\t\tinput:    `{\"key\":{\"key2\":{\"key3\":1}}}`,\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tv, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) returned error %v, want %v\", tc.input, err, tc.err)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif !reflect.DeepEqual(v, tc.expected) {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) returned %v, want %v\", tc.input, v, tc.expected)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}",
    "f6f799d652f95548df1454b0da524481": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: []string{\"hello\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quotes\",\n\t\t\tinput:    `\"hello\\\"world\"`,\n\t\t\texpected: []string{\"hello\\\"world\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello\\\"world\\\"foo\"`,\n\t\t\texpected: []string{\"hello\\\"world\\\"foo\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string without closing quote\",\n\t\t\tinput:    `\"hello`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    `\"\"`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult1, result2, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif result1 != tc.expected[0] || result2 != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = (%q, %q), want (%q, %q)\", tc.input, result1, result2, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "f625b903fe1f87df3db897c6edb4f6ae": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: &Value{\n\t\t\t\ts: \"hello\",\n\t\t\t\tt: typeRawString,\n\t\t\t},\n\t\t\twant: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{s: \"value1\", t: TypeString}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{s: \"value2\", t: TypeString}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":\"value1\",\"key2\":\"value2\"}`),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"value1\", t: TypeString},\n\t\t\t\t\t{s: \"value2\", t: TypeString},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\twant: []byte(`[\"value1\",\"value2\"]`),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: &Value{\n\t\t\t\ts: \"hello\",\n\t\t\t\tt: TypeString,\n\t\t\t},\n\t\t\twant: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: &Value{\n\t\t\t\ts: \"42\",\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\twant: []byte(\"42\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := make([]byte, 0, 64)\n\t\t\tgot := tt.v.MarshalTo(dst)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %s, want %s\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f95819b73bedc0740878a7252e4ef62b": "package fastjson_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/valyala/fastjson\"\n)\n\nfunc TestTypeString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tt        fastjson.Type\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"TypeObject\",\n\t\t\tt:        fastjson.TypeObject,\n\t\t\texpected: \"object\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeArray\",\n\t\t\tt:        fastjson.TypeArray,\n\t\t\texpected: \"array\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeString\",\n\t\t\tt:        fastjson.TypeString,\n\t\t\texpected: \"string\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeNumber\",\n\t\t\tt:        fastjson.TypeNumber,\n\t\t\texpected: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeTrue\",\n\t\t\tt:        fastjson.TypeTrue,\n\t\t\texpected: \"true\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeFalse\",\n\t\t\tt:        fastjson.TypeFalse,\n\t\t\texpected: \"false\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeNull\",\n\t\t\tt:        fastjson.TypeNull,\n\t\t\texpected: \"null\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Unknown\",\n\t\t\tt:        fastjson.Type(100),\n\t\t\texpected: \"BUG: unknown Value type: 100\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := tc.t.String()\n\t\t\tif got != tc.expected {\n\t\t\t\tt.Errorf(\"got %q, want %q\", got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f7c57cc5d4987c63433126e4c45ef159": "package fastjson\n\nimport \"testing\"\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\targs string\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: \"\",\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"string without leading whitespace\",\n\t\t\targs: \"hello\",\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with leading whitespace\",\n\t\t\targs: \" \\t\\n\\rhello\",\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with leading and trailing whitespace\",\n\t\t\targs: \" \\t\\n\\rhello\\t\\n\\r \",\n\t\t\twant: \"hello\\t\\n\\r \",\n\t\t},\n\t\t{\n\t\t\tname: \"string with only whitespace\",\n\t\t\targs: \" \\t\\n\\r \",\n\t\t\twant: \"\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.args); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow(%q) = %q, want %q\", tt.args, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f8928951972e02af89edabbec7377750": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestInt(t *testing.T) {\n\ttestCases := []struct {\n\t\tname      string\n\t\tinput     *Value\n\t\texpected  int\n\t\texpectErr bool\n\t}{\n\t\t{\n\t\t\tname:      \"valid number\",\n\t\t\tinput:     &Value{s: \"42\", t: TypeNumber},\n\t\t\texpected:  42,\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tname:      \"non-number type\",\n\t\t\tinput:     &Value{t: TypeString},\n\t\t\texpected:  0,\n\t\t\texpectErr: true,\n\t\t},\n\t\t{\n\t\t\tname:      \"number out of range\",\n\t\t\tinput:     &Value{s: \"9223372036854775808\", t: TypeNumber},\n\t\t\texpected:  0,\n\t\t\texpectErr: true,\n\t\t},\n\t\t{\n\t\t\tname:      \"invalid number format\",\n\t\t\tinput:     &Value{s: \"42.5\", t: TypeNumber},\n\t\t\texpected:  0,\n\t\t\texpectErr: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, err := tc.input.Int()\n\t\t\tif (err != nil) != tc.expectErr {\n\t\t\t\tt.Errorf(\"Int() error = %v, expectErr %v\", err, tc.expectErr)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif actual != tc.expected {\n\t\t\t\tt.Errorf(\"Int() = %v, want %v\", actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f8da9bdf20008c2b106a9e69d349e4ba": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantKey  string\n\t\twantRest string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"key\":\"value\"`,\n\t\t\twantKey:  \"key\",\n\t\t\twantRest: \"value\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"key\\\":value\"`,\n\t\t\twantKey:  `key\\\"`,\n\t\t\twantRest: \"value\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing closing quote\",\n\t\t\tinput:    `\"key\"`,\n\t\t\twantKey:  \"\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    `\"\"`,\n\t\t\twantKey:  \"\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotKey, gotRest, err := parseRawString(tt.input)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotKey != tt.wantKey {\n\t\t\t\tt.Errorf(\"parseRawString() gotKey = %v, want %v\", gotKey, tt.wantKey)\n\t\t\t}\n\t\t\tif gotRest != tt.wantRest {\n\t\t\t\tt.Errorf(\"parseRawString() gotRest = %v, want %v\", gotRest, tt.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f7174365718278f6c246af3c02df800c": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParser_Parse(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\ts       string\n\t\twant    *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"valid JSON\",\n\t\t\ts:    `{\"name\":\"John\",\"age\":30,\"city\":\"New York\"}`,\n\t\t\twant: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"name\", v: &Value{t: TypeString, s: \"John\"}},\n\t\t\t\t\t\t{k: \"age\", v: &Value{t: TypeNumber, s: \"30\"}},\n\t\t\t\t\t\t{k: \"city\", v: &Value{t: TypeString, s: \"New York\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid JSON\",\n\t\t\ts:       `{\"name\":\"John\",age:30,\"city\":\"New York\"}`,\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tp := &Parser{}\n\t\t\tgot, err := p.Parse(tt.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Parser.Parse() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"Parser.Parse() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn equalObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn equalArrays(v1.a, v2.a)\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber, TypeTrue, TypeFalse, TypeNull:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc equalObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !equalValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc equalArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tif !equalValues(v1, a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "f981bfe9171513de09c0681357443d27": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected struct {\n\t\t\tkey    string\n\t\t\tvalue  string\n\t\t\thasErr bool\n\t\t}\n\t}{\n\t\t{\n\t\t\tname:  \"simple string\",\n\t\t\tinput: `\"hello, world\"`,\n\t\t\texpected: struct {\n\t\t\t\tkey    string\n\t\t\t\tvalue  string\n\t\t\t\thasErr bool\n\t\t\t}{\n\t\t\t\tkey:    \"hello, world\",\n\t\t\t\tvalue:  \"\",\n\t\t\t\thasErr: false,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"string with escaped quote\",\n\t\t\tinput: `\"hello, \\\"world\\\"\"`,\n\t\t\texpected: struct {\n\t\t\t\tkey    string\n\t\t\t\tvalue  string\n\t\t\t\thasErr bool\n\t\t\t}{\n\t\t\t\tkey:    \"hello, \\\"world\\\"\",\n\t\t\t\tvalue:  \"\",\n\t\t\t\thasErr: false,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"missing closing quote\",\n\t\t\tinput: `\"hello, world`,\n\t\t\texpected: struct {\n\t\t\t\tkey    string\n\t\t\t\tvalue  string\n\t\t\t\thasErr bool\n\t\t\t}{\n\t\t\t\tkey:    \"\",\n\t\t\t\tvalue:  \"\",\n\t\t\t\thasErr: true,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"empty string\",\n\t\t\tinput: `\"\"`,\n\t\t\texpected: struct {\n\t\t\t\tkey    string\n\t\t\t\tvalue  string\n\t\t\t\thasErr bool\n\t\t\t}{\n\t\t\t\tkey:    \"\",\n\t\t\t\tvalue:  \"\",\n\t\t\t\thasErr: false,\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tkey, value, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.expected.hasErr {\n\t\t\t\tt.Errorf(\"Expected error: %v, got: %v\", tc.expected.hasErr, err != nil)\n\t\t\t}\n\t\t\tif key != tc.expected.key {\n\t\t\t\tt.Errorf(\"Expected key: %q, got: %q\", tc.expected.key, key)\n\t\t\t}\n\t\t\tif value != tc.expected.value {\n\t\t\t\tt.Errorf(\"Expected value: %q, got: %q\", tc.expected.value, value)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f9747230c68e23c0a3a3fc2165b2b8a6": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestMarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: &Value{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t\tt: typeRawString,\n\t\t\t},\n\t\t\twant: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{s: \"value1\", t: TypeString}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{s: \"value2\", t: TypeString}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":\"value1\",\"key2\":\"value2\"}`),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"value1\", t: TypeString},\n\t\t\t\t\t{s: \"value2\", t: TypeString},\n\t\t\t\t\t{s: \"value3\", t: TypeString},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\twant: []byte(`[\"value1\",\"value2\",\"value3\"]`),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: &Value{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t\tt: TypeString,\n\t\t\t},\n\t\t\twant: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: &Value{\n\t\t\t\ts: \"123\",\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\twant: []byte(\"123\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %q, want %q\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "fb729c9e664590824f43d00dd4575e18": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantStr  string\n\t\twantRest string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello world\"`,\n\t\t\twantStr:  \"hello world\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quotes\",\n\t\t\tinput:    `\"hello \\\"world\\\"\"`,\n\t\t\twantStr:  `hello \"world\"`,\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with trailing characters\",\n\t\t\tinput:    `\"hello world\" trailing`,\n\t\t\twantStr:  \"hello world\",\n\t\t\twantRest: \" trailing\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing closing quote\",\n\t\t\tinput:    `\"hello world`,\n\t\t\twantStr:  \"\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    `\"\"`,\n\t\t\twantStr:  \"\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotStr, gotRest, err := parseRawString(tt.input)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotStr != tt.wantStr {\n\t\t\t\tt.Errorf(\"parseRawString() gotStr = %v, want %v\", gotStr, tt.wantStr)\n\t\t\t}\n\t\t\tif gotRest != tt.wantRest {\n\t\t\t\tt.Errorf(\"parseRawString() gotRest = %v, want %v\", gotRest, tt.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "fa43a2f1438e1f409b9dcf9d2fc25dc6": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: \"{}\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs:           []kv{},\n\t\t\t\t\t\tkeysUnescaped: true,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with one key-value pair\",\n\t\t\tinput: `{\"key\":\"value\"}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tkeysUnescaped: true,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with multiple key-value pairs\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42,\"key3\":true}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\ts: \"42\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tkeysUnescaped: true,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\tinput: `{\"key\":\"value\"`,\n\t\t\texpected: nil,\n\t\t\terr:    fmt.Errorf(\"missing '}'\"\t),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tactual, _, err := parseObject(tc.input, c, 0)\n\t\t\tif !reflect.DeepEqual(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"Expected: %v, Actual: %v\", tc.expected, actual)\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(err, tc.err) {\n\t\t\t\tt.Errorf(\"Expected error: %v, Actual error: %v\", tc.err, err)\n\t\t\t}\n\t\t})\n\t}\n}",
    "fad2cd55a1437b3ce0da7feb21a2c28c": "package fastjson_test\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n\n\t\"github.com/valyala/fastjson\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tv        *fastjson.Value\n\t\texpected []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: &fastjson.Value{\n\t\t\t\tt: fastjson.typeRawString,\n\t\t\t\ts: \"hello, world\",\n\t\t\t},\n\t\t\texpected: []byte(`\"hello, world\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: &fastjson.Value{\n\t\t\t\tt: fastjson.TypeObject,\n\t\t\t\to: &fastjson.Object{\n\t\t\t\t\tkvs: []fastjson.kv{\n\t\t\t\t\t\t{k: \"key1\", v: &fastjson.Value{t: fastjson.TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &fastjson.Value{t: fastjson.TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: []byte(`{\"key1\":\"value1\",\"key2\":42}`),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: &fastjson.Value{\n\t\t\t\tt: fastjson.TypeArray,\n\t\t\t\ta: []*fastjson.Value{\n\t\t\t\t\t{t: fastjson.TypeString, s: \"hello\"},\n\t\t\t\t\t{t: fastjson.TypeNumber, s: \"42\"},\n\t\t\t\t\t{t: fastjson.TypeTrue},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: []byte(`[\"hello\",42,true]`),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: &fastjson.Value{\n\t\t\t\tt: fastjson.TypeString,\n\t\t\t\ts: \"hello, world\",\n\t\t\t},\n\t\t\texpected: []byte(`\"hello, world\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: &fastjson.Value{\n\t\t\t\tt: fastjson.TypeNumber,\n\t\t\t\ts: \"42\",\n\t\t\t},\n\t\t\texpected: []byte(\"42\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: &fastjson.Value{\n\t\t\t\tt: fastjson.TypeTrue,\n\t\t\t},\n\t\t\texpected: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: &fastjson.Value{\n\t\t\t\tt: fastjson.TypeFalse,\n\t\t\t},\n\t\t\texpected: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: &fastjson.Value{\n\t\t\t\tt: fastjson.TypeNull,\n\t\t\t},\n\t\t\texpected: []byte(\"null\"),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdst := make([]byte, 0, 64)\n\t\t\tactual := tc.v.MarshalTo(dst)\n\t\t\tif !bytes.Equal(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"MarshalTo(%#v) = %q, expected %q\", tc.v, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "fafe949e40ef0e679a1dce9f0ab14244": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tinput   string\n\t\twant    *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: `{}`,\n\t\t\twant: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           []kv{},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with one key-value pair\",\n\t\t\tinput: `{\"key\":\"value\"}`,\n\t\t\twant: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with multiple key-value pairs\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42,\"key3\":true}`,\n\t\t\twant: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\ts: \"42\",\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\ts: \"true\",\n\t\t\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"missing closing brace\",\n\t\t\tinput:   `{\"key1\":\"value1\",\"key2\":42`,\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"missing colon after key\",\n\t\t\tinput:   `{\"key1\"value1\",\"key2\":42}`,\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tgot, _, err := parseObject(tt.input, c, 0)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr && !got.Equals(tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "fce70cc9e40ba2c400ed89f3e0ba423b": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetInt(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tvalue  *Value\n\t\tkeys   []string\n\t\texpect int\n\t}{\n\t\t{\n\t\t\tname:   \"existing int value\",\n\t\t\tvalue:  &Value{s: \"123\", t: TypeNumber},\n\t\t\tkeys:   []string{},\n\t\t\texpect: 123,\n\t\t},\n\t\t{\n\t\t\tname:   \"non-existing key path\",\n\t\t\tvalue:  &Value{s: \"123\", t: TypeNumber},\n\t\t\tkeys:   []string{\"foo\", \"bar\"},\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"invalid value type\",\n\t\t\tvalue:  &Value{s: \"abc\", t: TypeString},\n\t\t\tkeys:   []string{},\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"float value\",\n\t\t\tvalue:  &Value{s: \"3.14\", t: TypeNumber},\n\t\t\tkeys:   []string{},\n\t\t\texpect: 3,\n\t\t},\n\t\t{\n\t\t\tname:   \"array index\",\n\t\t\tvalue:  &Value{a: []*Value{&Value{s: \"10\", t: TypeNumber}}, t: TypeArray},\n\t\t\tkeys:   []string{\"0\"},\n\t\t\texpect: 10,\n\t\t},\n\t\t{\n\t\t\tname:   \"array index with float\",\n\t\t\tvalue:  &Value{a: []*Value{&Value{s: \"3.14\", t: TypeNumber}}, t: TypeArray},\n\t\t\tkeys:   []string{\"0\"},\n\t\t\texpect: 3,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := test.value.GetInt(test.keys...)\n\t\t\tif got != test.expect {\n\t\t\t\tt.Errorf(\"GetInt(%v) = %d, want %d\", test.keys, got, test.expect)\n\t\t\t}\n\t\t})\n\t}\n}",
    "fa1f625cfa6f647e389ef8b2e4a2b0f7": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: \"{}\",\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           []kv{},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with one key-value pair\",\n\t\t\tinput: `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{t: TypeString, s: \"value\"}},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with multiple key-value pairs\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42,\"key3\":true}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t\t{k: \"key3\", v: &Value{t: TypeTrue}},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\tinput: `{\"key\":\"value\"`,\n\t\t\texpected: nil,\n\t\t\terr:      ErrMissingClosingBrace,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing colon\",\n\t\t\tinput: `{\"key\" \"value\"}`,\n\t\t\texpected: nil,\n\t\t\terr:      ErrMissingColon,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing comma\",\n\t\t\tinput: `{\"key\":\"value\" \"key2\":\"value2\"}`,\n\t\t\texpected: nil,\n\t\t\terr:      ErrMissingComma,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tactual, _, err := parseObject(tc.input, c, 0)\n\t\t\tif err != tc.err {\n\t\t\t\tt.Errorf(\"expected error %v, got %v\", tc.err, err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !equalValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"expected %+v, got %+v\", tc.expected, actual)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn equalObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn equalArrays(v1.a, v2.a)\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber, TypeTrue, TypeFalse, TypeNull:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc equalObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !equalValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc equalArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tif !equalValues(v1, a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "fb7e9ab90d925bed85b64d15b8032d26": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"empty array\",\n\t\t\tinput:    \"[]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with one value\",\n\t\t\tinput:    \"[1]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with multiple values\",\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}, &Value{t: TypeNumber, s: \"2\"}, &Value{t: TypeNumber, s: \"3\"}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with missing closing bracket\",\n\t\t\tinput:    \"[1, 2, 3\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with unexpected end\",\n\t\t\tinput:    \"[1, 2,\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tactual, _, err := parseArray(tc.input, c, 0)\n\t\t\tif tc.err {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"expected error, but got none\")\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tc.expected, actual)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(a, b *Value) bool {\n\tif a == nil || b == nil {\n\t\treturn a == b\n\t}\n\n\tif a.t != b.t {\n\t\treturn false\n\t}\n\n\tswitch a.t {\n\tcase TypeArray:\n\t\tif len(a.a) != len(b.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, v := range a.a {\n\t\t\tif !compareValues(v, b.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\tcase TypeString:\n\t\treturn a.s == b.s\n\tcase TypeNumber:\n\t\treturn a.s == b.s\n\tcase TypeTrue, TypeFalse, TypeNull:\n\t\treturn true\n\tdefault:\n\t\tpanic(\"unsupported type\")\n\t}\n\n\treturn true\n}",
    "ff75975ea5cedab01a573834e62bf964": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t\tremaining string\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.456e+7\",\n\t\t\texpected: \"123.456e+7\",\n\t\t\tremaining: \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with leading zeros\",\n\t\t\tinput:    \"0123.456\",\n\t\t\texpected: \"0123.456\",\n\t\t\tremaining: \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with sign\",\n\t\t\tinput:    \"-123.456\",\n\t\t\texpected: \"-123.456\",\n\t\t\tremaining: \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with exponent\",\n\t\t\tinput:    \"1.2e-3\",\n\t\t\texpected: \"1.2e-3\",\n\t\t\tremaining: \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid input\",\n\t\t\tinput:    \"abc123\",\n\t\t\texpected: \"\",\n\t\t\tremaining: \"abc123\",\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult, remaining, err := parseRawNumber(tc.input)\n\t\t\tif err != nil && !tc.err {\n\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t}\n\t\t\tif err == nil && tc.err {\n\t\t\t\tt.Errorf(\"expected error, but got none\")\n\t\t\t}\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"expected result %q, got %q\", tc.expected, result)\n\t\t\t}\n\t\t\tif remaining != tc.remaining {\n\t\t\t\tt.Errorf(\"expected remaining %q, got %q\", tc.remaining, remaining)\n\t\t\t}\n\t\t})\n\t}\n}",
    "ff2e64941735c4b5b5fb0f73d2564232": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetUint(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tjson  string\n\t\tkeys  []string\n\t\twant  uint\n\t\twantE bool\n\t}{\n\t\t{\n\t\t\tname: \"valid uint\",\n\t\t\tjson: `{\"key\": 42}`,\n\t\t\tkeys: []string{\"key\"},\n\t\t\twant: 42,\n\t\t},\n\t\t{\n\t\t\tname: \"non-existing key\",\n\t\t\tjson: `{\"key\": 42}`,\n\t\t\tkeys: []string{\"non-existing\"},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid value type\",\n\t\t\tjson: `{\"key\": true}`,\n\t\t\tkeys: []string{\"key\"},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"value out of range for uint\",\n\t\t\tjson: `{\"key\": 18446744073709551616}`,\n\t\t\tkeys: []string{\"key\"},\n\t\t\twant: 0,\n\t\t\twantE: true,\n\t\t},\n\t\t{\n\t\t\tname: \"nested object\",\n\t\t\tjson: `{\"key\": {\"subkey\": 42}}`,\n\t\t\tkeys: []string{\"key\", \"subkey\"},\n\t\t\twant: 42,\n\t\t},\n\t\t{\n\t\t\tname: \"array index access\",\n\t\t\tjson: `{\"key\": [10, 20, 30]}`,\n\t\t\tkeys: []string{\"key\", \"1\"},\n\t\t\twant: 20,\n\t\t},\n\t\t{\n\t\t\tname: \"array index out of range\",\n\t\t\tjson: `{\"key\": [10, 20, 30]}`,\n\t\t\tkeys: []string{\"key\", \"3\"},\n\t\t\twant: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv, err := ParseBytes([]byte(tt.json))\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"ParseBytes(%q) failed: %v\", tt.json, err)\n\t\t\t}\n\n\t\t\tgot := v.GetUint(tt.keys...)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"v.GetUint(%v) = %d, want %d\", tt.keys, got, tt.want)\n\t\t\t}\n\n\t\t\tif (got == 0 && tt.want != 0) && !tt.wantE {\n\t\t\t\tt.Errorf(\"v.GetUint(%v) = 0, want %d\", tt.keys, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "feacaa5e88202caacf33cb33a02608a6": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tinput   string\n\t\twantVal *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"empty string\",\n\t\t\tinput:   \"\",\n\t\t\twantVal: nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"too deep JSON\",\n\t\t\tinput:   \"{\\\"a\\\":{\\\"b\\\":{\\\"c\\\":{\\\"d\\\":{}}}}}\",\n\t\t\twantVal: nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"valid object\",\n\t\t\tinput:   `{\"key\":\"value\"}`,\n\t\t\twantVal: &Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: &Value{t: typeRawString, s: \"value\"}}}}},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"valid array\",\n\t\t\tinput:   `[\"value1\",\"value2\"]`,\n\t\t\twantVal: &Value{t: TypeArray, a: []*Value{&Value{t: typeRawString, s: \"value1\"}, &Value{t: typeRawString, s: \"value2\"}}},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"valid string\",\n\t\t\tinput:   `\"hello\"`,\n\t\t\twantVal: &Value{t: typeRawString, s: \"hello\"},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"valid true\",\n\t\t\tinput:   \"true\",\n\t\t\twantVal: valueTrue,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"valid false\",\n\t\t\tinput:   \"false\",\n\t\t\twantVal: valueFalse,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"valid null\",\n\t\t\tinput:   \"null\",\n\t\t\twantVal: valueNull,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"valid number\",\n\t\t\tinput:   \"42\",\n\t\t\twantVal: &Value{t: TypeNumber, s: \"42\"},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid value\",\n\t\t\tinput:   \"invalid\",\n\t\t\twantVal: nil,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotVal, _, gotErr := parseValue(tt.input, c, 0)\n\t\t\tif (gotErr != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", gotErr, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !valuesEqual(gotVal, tt.wantVal) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", gotVal, tt.wantVal)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc valuesEqual(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\to1, _ := v1.Object()\n\t\to2, _ := v2.Object()\n\t\treturn objectsEqual(o1, o2)\n\tcase TypeArray:\n\t\ta1, _ := v1.Array()\n\t\ta2, _ := v2.Array()\n\t\tif len(a1) != len(a2) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range a1 {\n\t\t\tif !valuesEqual(a1[i], a2[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase typeRawString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber, TypeTrue, TypeFalse, TypeNull:\n\t\treturn true\n\tdefault:\n\t\tpanic(\"unsupported type\")\n\t}\n}\n\nfunc objectsEqual(o1, o2 *Object) bool {\n\tif o1 == nil && o2 == nil {\n\t\treturn true\n\t}\n\tif o1 == nil || o2 == nil {\n\t\treturn false\n\t}\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i := range o1.kvs {\n\t\tif o1.kvs[i].k != o2.kvs[i].k {\n\t\t\treturn false\n\t\t}\n\t\tif !valuesEqual(o1.kvs[i].v, o2.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "ff29818ed9c5eb2e04b751c3ad5a474c": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"depth exceeds MaxDepth\",\n\t\t\tinput:    \"{}\", // Assuming MaxDepth is 1\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t},\n\t\t{\n\t\t\tname:     \"valid object\",\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t\tt: typeRawString,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{\n\t\t\t\ts: \"hello\",\n\t\t\t\tt: typeRawString,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid true\",\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid false\",\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid null\",\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"42\",\n\t\t\texpected: &Value{\n\t\t\t\ts: \"42\",\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid value\",\n\t\t\tinput:    \"invalid\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"unexpected value found: %q\", \"invalid\"),\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tv, _, err := parseValue(tc.input, c, 0)\n\t\t\tif tc.err != nil {\n\t\t\t\tif err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) returned error %v, want %v\", tc.input, err, tc.err)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) returned error %v, want nil\", tc.input, err)\n\t\t\t\t}\n\t\t\t\tif !equalValue(v, tc.expected) {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) returned %+v, want %+v\", tc.input, v, tc.expected)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValue(a, b *Value) bool {\n\tif a == nil && b == nil {\n\t\treturn true\n\t}\n\tif a == nil || b == nil {\n\t\treturn false\n\t}\n\tif a.t != b.t {\n\t\treturn false\n\t}\n\tswitch a.t {\n\tcase TypeObject:\n\t\taObj, _ := a.Object()\n\t\tbObj, _ := b.Object()\n\t\treturn equalObject(aObj, bObj)\n\tcase TypeArray:\n\t\taArr, _ := a.Array()\n\t\tbArr, _ := b.Array()\n\t\tif len(aArr) != len(bArr) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range aArr {\n\t\t\tif !equalValue(aArr[i], bArr[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase typeRawString, TypeString:\n\t\treturn a.s == b.s\n\tcase TypeNumber, TypeTrue, TypeFalse, TypeNull:\n\t\treturn a.s == b.s\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc equalObject(a, b *Object) bool {\n\tif a == nil && b == nil {\n\t\treturn true\n\t}\n\tif a == nil || b == nil {\n\t\treturn false\n\t}\n\tif len(a.kvs) != len(b.kvs) {\n\t\treturn false\n\t}\n\tfor i := range a.kvs {\n\t\tif a.kvs[i].k != b.kvs[i].k {\n\t\t\treturn false\n\t\t}\n\t\tif !equalValue(a.kvs[i].v, b.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}"
}