{
    "04dc8272468e903ebae88b5145747003": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObjectReset(t *testing.T) {\n\to := &Object{\n\t\tkvs:           []kv{{k: \"key1\", v: &Value{s: \"value1\"}}, {k: \"key2\", v: &Value{s: \"value2\"}}},\n\t\tkeysUnescaped: true,\n\t}\n\n\to.reset()\n\n\tif len(o.kvs) != 0 {\n\t\tt.Errorf(\"expected o.kvs to be empty, got %v\", o.kvs)\n\t}\n\n\tif o.keysUnescaped {\n\t\tt.Errorf(\"expected o.keysUnescaped to be false, got true\")\n\t}\n}",
    "02a8269c4ee18a4fbb8c09411ab1841f": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUint(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    *Value\n\t\texpected uint\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid uint\",\n\t\t\tinput:    &Value{s: \"42\", t: TypeNumber},\n\t\t\texpected: 42,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"value is not a number\",\n\t\t\tinput:    &Value{s: \"foo\", t: TypeString},\n\t\t\texpected: 0,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"number doesn't fit uint\",\n\t\t\tinput:    &Value{s: \"18446744073709551616\", t: TypeNumber},\n\t\t\texpected: 0,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, err := tc.input.Uint()\n\t\t\tif tc.err {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"expected error, got nil\")\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t\t}\n\t\t\t\tif actual != tc.expected {\n\t\t\t\t\tt.Errorf(\"expected %d, got %d\", tc.expected, actual)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}",
    "030050b2471e57cd0d6c0d511578aae8": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWS(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"no whitespace\",\n\t\t\tinput:    \"hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading whitespace\",\n\t\t\tinput:    \"   hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"trailing whitespace\",\n\t\t\tinput:    \"hello   \",\n\t\t\texpected: \"hello   \",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading and trailing whitespace\",\n\t\t\tinput:    \"   hello   \",\n\t\t\texpected: \"hello   \",\n\t\t},\n\t\t{\n\t\t\tname:     \"all whitespace\",\n\t\t\tinput:    \"   \\t\\n\\r \",\n\t\t\texpected: \"\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := skipWS(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"skipWS(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "033e68fd7e13f2d9c2f9e28af7b159b4": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"no escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"simple escape characters\",\n\t\t\tinput:    \"hello\\\\\\\"world\\\\\\\\\",\n\t\t\texpected: \"hello\\\"world\\\\\",\n\t\t},\n\t\t{\n\t\t\tname:     \"complex escape characters\",\n\t\t\tinput:    \"hello\\\\u0041\\\\u0042\\\\u0043world\",\n\t\t\texpected: \"helloABCworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid escape characters\",\n\t\t\tinput:    \"hello\\\\u0041\\\\u004\",\n\t\t\texpected: \"hello\\\\u0041\\\\u004\",\n\t\t},\n\t\t{\n\t\t\tname:     \"surrogate pairs\",\n\t\t\tinput:    \"hello\\\\ud83d\\\\ude00world\",\n\t\t\texpected: \"helloðŸ˜€world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid surrogate pairs\",\n\t\t\tinput:    \"hello\\\\ud83d\\\\ude\",\n\t\t\texpected: \"hello\\\\ud83d\\\\ude\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "04d6e97909589953719868a25b6e57cd": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantKey  string\n\t\twantRest string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple key\",\n\t\t\tinput:    `\"key\":value`,\n\t\t\twantKey:  \"key\",\n\t\t\twantRest: \":value\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"key with escape sequence\",\n\t\t\tinput:    `\"key\\\"with\\\"escape\":value`,\n\t\t\twantKey:  `key\"with\"escape`,\n\t\t\twantRest: \":value\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing closing quote\",\n\t\t\tinput:    `\"key:value`,\n\t\t\twantKey:  \"\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tkey, rest, err := parseRawKey(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawKey(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif key != tc.wantKey {\n\t\t\t\tt.Errorf(\"parseRawKey(%q) key = %q, want %q\", tc.input, key, tc.wantKey)\n\t\t\t}\n\t\t\tif rest != tc.wantRest {\n\t\t\t\tt.Errorf(\"parseRawKey(%q) rest = %q, want %q\", tc.input, rest, tc.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "04d0d806717ea36eb17f2b72144f32a0": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetBool(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    *Value\n\t\tkeys     []string\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname: \"Existing key with bool value\",\n\t\t\tinput: &Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Existing key with non-bool value\",\n\t\t\tinput: &Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Non-existing key\",\n\t\t\tinput: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeTrue}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"key2\"},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Nested key\",\n\t\t\tinput: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{\n\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeTrue}},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"key1\", \"key2\"},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Array index key\",\n\t\t\tinput: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t\t{t: TypeFalse},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"1\"},\n\t\t\texpected: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := tc.input.GetBool(tc.keys...)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"GetBool(%v) = %v, expected %v\", tc.keys, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "00278ae3692fa09d9f958ad63beba116": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestExists(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\tkeys     []string\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname: \"Existing field\",\n\t\t\tvalue: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"foo\", v: &Value{s: \"bar\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"foo\"},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Non-existing field\",\n\t\t\tvalue: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"foo\", v: &Value{s: \"bar\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"baz\"},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Nested field exists\",\n\t\t\tvalue: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"foo\", v: &Value{\n\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t{k: \"bar\", v: &Value{s: \"baz\"}},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"foo\", \"bar\"},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Nested field does not exist\",\n\t\t\tvalue: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"foo\", v: &Value{\n\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t{k: \"bar\", v: &Value{s: \"baz\"}},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"foo\", \"baz\"},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Array index\",\n\t\t\tvalue: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"foo\"},\n\t\t\t\t\t{s: \"bar\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"1\"},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Array index out of bounds\",\n\t\t\tvalue: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"foo\"},\n\t\t\t\t\t{s: \"bar\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"2\"},\n\t\t\texpected: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tif got := tc.value.Exists(tc.keys...); got != tc.expected {\n\t\t\t\tt.Errorf(\"Exists(%v) = %v, want %v\", tc.keys, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "030088fada765edfb609350d13c2384f": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantNum  string\n\t\twantRest string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.456e+7\",\n\t\t\twantNum:  \"123.456e+7\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with trailing characters\",\n\t\t\tinput:    \"123.456e+7abc\",\n\t\t\twantNum:  \"123.456e+7\",\n\t\t\twantRest: \"abc\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number\",\n\t\t\tinput:    \"abc\",\n\t\t\twantNum:  \"\",\n\t\t\twantRest: \"abc\",\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty input\",\n\t\t\tinput:    \"\",\n\t\t\twantNum:  \"\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"inf\",\n\t\t\tinput:    \"inf\",\n\t\t\twantNum:  \"inf\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"nan\",\n\t\t\tinput:    \"nan\",\n\t\t\twantNum:  \"nan\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.wantNum {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) num = %q, want %q\", tc.input, num, tc.wantNum)\n\t\t\t}\n\t\t\tif rest != tc.wantRest {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) rest = %q, want %q\", tc.input, rest, tc.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0579ad30148187ef9637d5bc4d216b67": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":\"value1\",\"key2\":42}`),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"hello\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`[\"hello\",42,true]`),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42\",\n\t\t\t},\n\t\t\twant: []byte(\"42\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %q, want %q\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0144670a849d18faf8a4f3ce07fa7a09": "package fastjson\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n)\n\nfunc TestVisit(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\tjson string\n\t\twant [][]byte\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\tjson: \"{}\",\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"single key-value pair\",\n\t\t\tjson: `{\"key\":\"value\"}`,\n\t\t\twant: [][]byte{[]byte(\"key\"), []byte(\"value\")},\n\t\t},\n\t\t{\n\t\t\tname: \"multiple key-value pairs\",\n\t\t\tjson: `{\"key1\":\"value1\",\"key2\":\"value2\",\"key3\":\"value3\"}`,\n\t\t\twant: [][]byte{[]byte(\"key1\"), []byte(\"value1\"), []byte(\"key2\"), []byte(\"value2\"), []byte(\"key3\"), []byte(\"value3\")},\n\t\t},\n\t\t{\n\t\t\tname: \"nested object\",\n\t\t\tjson: `{\"key1\":{\"key2\":\"value2\"},\"key3\":\"value3\"}`,\n\t\t\twant: [][]byte{[]byte(\"key1\"), []byte(\"key2\"), []byte(\"value2\"), []byte(\"key3\"), []byte(\"value3\")},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tvar got [][]byte\n\t\t\tv, err := Parse(tc.json)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Parse(%q) failed: %v\", tc.json, err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\to, err := v.Object()\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"v.Object() failed: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\to.Visit(func(key []byte, value *Value) {\n\t\t\t\tgot = append(got, key)\n\t\t\t\tvar buf bytes.Buffer\n\t\t\t\tif _, err := value.MarshalTo(&buf); err != nil {\n\t\t\t\t\tt.Errorf(\"value.MarshalTo() failed: %v\", err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tgot = append(got, buf.Bytes())\n\t\t\t})\n\n\t\t\tif !bytes.Equal(flattenSlice(tc.want), flattenSlice(got)) {\n\t\t\t\tt.Errorf(\"Visit() = %v, want %v\", got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc flattenSlice(s [][]byte) []byte {\n\tvar buf bytes.Buffer\n\tfor _, b := range s {\n\t\tbuf.Write(b)\n\t\tbuf.WriteByte(0)\n\t}\n\treturn buf.Bytes()\n}",
    "033289b6ad4a2cc3c8f2036ab17e5a0b": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty array\",\n\t\t\tinput: \"[]\",\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with values\",\n\t\t\tinput: \"[1, true, null, \\\"hello\\\"]\",\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t\t{t: TypeNull},\n\t\t\t\t\t{t: TypeString, s: \"hello\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with missing comma\",\n\t\t\tinput: \"[1 2]\",\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with missing closing bracket\",\n\t\t\tinput: \"[1, 2\",\n\t\t\terr:   true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tv, _, err := parseArray(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseArray(%q) error = %v, want error: %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !v.Equal(tc.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", tc.input, v, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc (v *Value) Equal(other *Value) bool {\n\tif v.t != other.t {\n\t\treturn false\n\t}\n\tswitch v.t {\n\tcase TypeNull, TypeTrue, TypeFalse:\n\t\treturn true\n\tcase TypeNumber, TypeString:\n\t\treturn v.s == other.s\n\tcase TypeArray:\n\t\tif len(v.a) != len(other.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, vv := range v.a {\n\t\t\tif !vv.Equal(other.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeObject:\n\t\treturn v.o.Equal(&other.o)\n\tdefault:\n\t\tpanic(\"unknown type\")\n\t}\n}\n\nfunc (o *Object) Equal(other *Object) bool {\n\tif len(o.kvs) != len(other.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv := range o.kvs {\n\t\tif kv.k != other.kvs[i].k {\n\t\t\treturn false\n\t\t}\n\t\tif !kv.v.Equal(other.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "05d5d41f64663ccd061a86a2c50439e7": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: []string{\"hello\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello\\\"world\"`,\n\t\t\texpected: []string{\"hello\\\"world\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello\\\"world\\\"foo\"`,\n\t\t\texpected: []string{\"hello\\\"world\\\"foo\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with no closing quote\",\n\t\t\tinput:    `\"hello`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    `\"\"`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult, rest, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif result != tc.expected[0] || rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = %q, %q, want %q, %q\", tc.input, result, rest, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "07b09c2d02a2a43bf3bdfe6d215f6090": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestInt(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    *Value\n\t\texpected int\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    &Value{s: \"42\", t: TypeNumber},\n\t\t\texpected: 42,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"non-number type\",\n\t\t\tinput:    &Value{s: \"true\", t: TypeTrue},\n\t\t\texpected: 0,\n\t\t\terr:      fmt.Errorf(\"value doesn't contain number; it contains true\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"number out of int range\",\n\t\t\tinput:    &Value{s: \"9223372036854775807\", t: TypeNumber},\n\t\t\texpected: 0,\n\t\t\terr:      fmt.Errorf(\"number \\\"9223372036854775807\\\" doesn't fit int\"),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, err := tc.input.Int()\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t\t}\n\t\t\t} else if actual != tc.expected {\n\t\t\t\tt.Errorf(\"expected %d, got %d\", tc.expected, actual)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0939d19a198a44e82a69f74a6213352e": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: []string{\"hello\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello\\\"world\"`,\n\t\t\texpected: []string{\"hello\\\"world\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello\\\"world\\\"foo\"`,\n\t\t\texpected: []string{\"hello\\\"world\\\"foo\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with no closing quote\",\n\t\t\tinput:    `\"hello`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot, got2, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tc.expected[0] {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, expected %v\", got, tc.expected[0])\n\t\t\t}\n\t\t\tif got2 != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawString() got2 = %v, expected %v\", got2, tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "038822c39cb85eb822913d7b1c215e0d": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"too big depth\",\n\t\t\tinput:    \"{}\", // Assuming MaxDepth is 1\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds 1\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"valid object\",\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{\n\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\tt: typeRawString,\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"1\", t: TypeNumber},\n\t\t\t\t\t{s: \"2\", t: TypeNumber},\n\t\t\t\t\t{s: \"3\", t: TypeNumber},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{\n\t\t\t\ts: \"hello\",\n\t\t\t\tt: typeRawString,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid true\",\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid false\",\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid null\",\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"42\",\n\t\t\texpected: &Value{\n\t\t\t\ts: \"42\",\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tactual, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, expected %v\", tc.input, err, tc.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else if tc.err != nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = nil, expected %v\", tc.input, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, expected %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\to1, _ := v1.Object()\n\t\to2, _ := v2.Object()\n\t\treturn compareObjects(o1, o2)\n\tcase TypeArray:\n\t\ta1, _ := v1.Array()\n\t\ta2, _ := v2.Array()\n\t\tif len(a1) != len(a2) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range a1 {\n\t\t\tif !compareValues(a1[i], a2[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase typeRawString, TypeNumber, TypeTrue, TypeFalse, TypeNull:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc compareObjects(o1, o2 *Object) bool {\n\tif o1 == nil && o2 == nil {\n\t\treturn true\n\t}\n\tif o1 == nil || o2 == nil {\n\t\treturn false\n\t}\n\tif o1.Len() != o2.Len() {\n\t\treturn false\n\t}\n\tfor i := range o1.kvs {\n\t\tif o1.kvs[i].k != o2.kvs[i].k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(o1.kvs[i].v, o2.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "05f386d6426b2ba51ab1618802020780": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape double quote\",\n\t\t\tinput:    \"hello, \\\"world\\\"\",\n\t\t\texpected: \"hello, \\\"world\\\"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backslash\",\n\t\t\tinput:    \"hello, \\\\world\\\\\",\n\t\t\texpected: \"hello, \\\\world\\\\\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape forward slash\",\n\t\t\tinput:    \"hello, /world/\",\n\t\t\texpected: \"hello, /world/\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backspace\",\n\t\t\tinput:    \"hello, \\bworld\\b\",\n\t\t\texpected: \"hello, \\bworld\\b\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape form feed\",\n\t\t\tinput:    \"hello, \\fworld\\f\",\n\t\t\texpected: \"hello, \\fworld\\f\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape newline\",\n\t\t\tinput:    \"hello,\\nworld\\n\",\n\t\t\texpected: \"hello,\\nworld\\n\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape carriage return\",\n\t\t\tinput:    \"hello,\\rworld\\r\",\n\t\t\texpected: \"hello,\\rworld\\r\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape tab\",\n\t\t\tinput:    \"hello,\\tworld\\t\",\n\t\t\texpected: \"hello,\\tworld\\t\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Unicode\",\n\t\t\tinput:    \"hello, \\\\u0041world\\\\u0042\",\n\t\t\texpected: \"hello, Aworld\\u0042\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Unicode surrogate pair\",\n\t\t\tinput:    \"hello, \\\\u0041\\\\u0042world\\\\u0043\\\\u0044\",\n\t\t\texpected: \"hello, \\u0041\\u0042world\\u0043\\u0044\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid escape sequence\",\n\t\t\tinput:    \"hello, \\\\xworld\\\\x\",\n\t\t\texpected: \"hello, \\\\xworld\\\\x\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0caf733fa5305edee132705c431f4cb5": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestUint(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    *Value\n\t\texpected uint\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"valid uint\",\n\t\t\tinput:    &Value{s: \"42\", t: TypeNumber},\n\t\t\texpected: 42,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"value not a number\",\n\t\t\tinput:    &Value{s: \"foo\", t: TypeString},\n\t\t\texpected: 0,\n\t\t\terr:      fmt.Errorf(\"value doesn't contain number; it contains string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"number too large for uint\",\n\t\t\tinput:    &Value{s: \"18446744073709551616\", t: TypeNumber},\n\t\t\texpected: 0,\n\t\t\terr:      fmt.Errorf(\"number \\\"18446744073709551616\\\" doesn't fit uint\"),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, err := tc.input.Uint()\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t\t}\n\t\t\t} else if tc.err != nil {\n\t\t\t\tt.Errorf(\"expected error: %v\", tc.err)\n\t\t\t} else if actual != tc.expected {\n\t\t\t\tt.Errorf(\"expected %d, got %d\", tc.expected, actual)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0d8972029cfd570b7b6fadd35e2a9a42": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestType(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant Type\n\t}{\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: TypeNull,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\twant: TypeObject,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\twant: TypeArray,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t},\n\t\t\twant: TypeString,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\twant: TypeNumber,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: TypeTrue,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: TypeFalse,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := tc.v.Type()\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"Type() = %v, want %v\", got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0cd53799171f8eab7a7786371d5f8f6a": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.456e+78\",\n\t\t\texpected: []string{\"123.456e+78\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with leading zeros\",\n\t\t\tinput:    \"0123.456\",\n\t\t\texpected: []string{\"0123.456\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with sign\",\n\t\t\tinput:    \"-123.456\",\n\t\t\texpected: []string{\"-123.456\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with inf\",\n\t\t\tinput:    \"inf\",\n\t\t\texpected: []string{\"inf\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with nan\",\n\t\t\tinput:    \"nan\",\n\t\t\texpected: []string{\"nan\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number\",\n\t\t\tinput:    \"123.456a\",\n\t\t\texpected: []string{\"\", \"123.456a\"},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.expected[0] || rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = (%q, %q), want (%q, %q)\", tc.input, num, rest, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "09ab002c025559c976b4c2b3658e55f7": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tinput   string\n\t\twant    *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:  \"valid JSON\",\n\t\t\tinput: `{\"key1\": \"value1\", \"key2\": 42}`,\n\t\t\twant: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{s: \"value1\", t: TypeString}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{s: \"42\", t: TypeNumber}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid JSON\",\n\t\t\tinput:   `{\"key1\": \"value1\", \"key2\"`,\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"empty input\",\n\t\t\tinput:   \"\",\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tp := &Parser{}\n\t\t\tgot, err := p.Parse(tt.input)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Parse() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !compareValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"Parse() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\to1, _ := v1.Object()\n\t\to2, _ := v2.Object()\n\t\tif len(o1.kvs) != len(o2.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, kv1 := range o1.kvs {\n\t\t\tkv2 := o2.kvs[i]\n\t\t\tif kv1.k != kv2.k || !compareValues(kv1.v, kv2.v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\tcase TypeArray:\n\t\ta1, _ := v1.Array()\n\t\ta2, _ := v2.Array()\n\t\tif len(a1) != len(a2) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, v1 := range a1 {\n\t\t\tif !compareValues(v1, a2[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\tcase TypeString:\n\t\ts1, _ := v1.StringBytes()\n\t\ts2, _ := v2.StringBytes()\n\t\treturn string(s1) == string(s2)\n\tcase TypeNumber:\n\t\tn1, _ := v1.Float64()\n\t\tn2, _ := v2.Float64()\n\t\treturn n1 == n2\n\tcase TypeTrue, TypeFalse:\n\t\tb1, _ := v1.Bool()\n\t\tb2, _ := v2.Bool()\n\t\treturn b1 == b2\n\tcase TypeNull:\n\t\treturn true\n\t}\n\treturn false\n}",
    "0f616e71d39628a3904565c42de8b8bc": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCache_getValue(t *testing.T) {\n\tc := &cache{\n\t\tvs: make([]Value, 0, 10),\n\t}\n\n\t// Test when the capacity of the slice is greater than the length\n\tv1 := c.getValue()\n\tif v1 == nil {\n\t\tt.Errorf(\"getValue() returned nil\")\n\t}\n\tif len(c.vs) != 1 {\n\t\tt.Errorf(\"expected length of vs to be 1, got %d\", len(c.vs))\n\t}\n\n\t// Test when the capacity of the slice is equal to the length\n\tfor i := 0; i < 10; i++ {\n\t\tc.getValue()\n\t}\n\tif len(c.vs) != 11 {\n\t\tt.Errorf(\"expected length of vs to be 11, got %d\", len(c.vs))\n\t}\n}",
    "0f26a105e8a6525daf65d26615bb027c": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"no escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"simple escape characters\",\n\t\t\tinput:    \"hello\\\\\\\"world\\\\\\\\\",\n\t\t\texpected: \"hello\\\"world\\\\\",\n\t\t},\n\t\t{\n\t\t\tname:     \"complex escape characters\",\n\t\t\tinput:    \"hello\\\\u0000world\\\\u1234\\\\u{10000}\",\n\t\t\texpected: \"hello\\x00world\\u1234\\U00010000\",\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid escape characters\",\n\t\t\tinput:    \"hello\\\\u000world\\\\u123\",\n\t\t\texpected: \"hello\\\\u000world\\\\u123\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0b937229edec31861deb151c4b2bde02": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty array\",\n\t\t\tinput: \"[]\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with one value\",\n\t\t\tinput: \"[1]\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with multiple values\",\n\t\t\tinput: \"[1,2,3]\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with trailing comma\",\n\t\t\tinput: \"[1,2,3,]\",\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with missing closing bracket\",\n\t\t\tinput: \"[1,2,3\",\n\t\t\terr:   true,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, _, err := parseArray(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseArray(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !equalValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeTrue, TypeFalse, TypeNull:\n\t\treturn true\n\tdefault:\n\t\tpanic(\"unknown type\")\n\t}\n\treturn true\n}",
    "0e137cd85ee0d22389c92c89df6ce95f": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: \"{}\",\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           []kv{},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with one key-value pair\",\n\t\t\tinput: `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with multiple key-value pairs\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":123,\"key3\":true}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":123`,\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing colon\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\"}`,\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing value\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":}`,\n\t\t\terr:   true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tv, _, err := parseObject(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !v.Equal(tc.expected) {\n\t\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", tc.input, v, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0ac5d665a06f3aea0c44fc787c1e6312": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: \"{}\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with one key-value pair\",\n\t\t\tinput: `{\"key\":\"value\"}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with multiple key-value pairs\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":123,\"key3\":true}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\tinput: `{\"key1\":\"value1\",`,\n\t\t\texpected: nil,\n\t\t\terr:     true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing colon\",\n\t\t\tinput: `{\"key1\" \"value1\"}`,\n\t\t\texpected: nil,\n\t\t\terr:     true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing comma\",\n\t\t\tinput: `{\"key1\":\"value1\" \"key2\":\"value2\"}`,\n\t\t\texpected: nil,\n\t\t\terr:     true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tactual, _, err := parseObject(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn compareObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn compareArrays(v1.a, v2.a)\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber, TypeTrue, TypeFalse:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\treturn true\n\t}\n}\n\nfunc compareObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc compareArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tif !compareValues(v1, a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "0a78ec200670858320d02e398f83adb6": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"too big depth\",\n\t\t\tinput:    \"{}\", // Assuming MaxDepth is 1\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds 1\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"valid object\",\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t\tt: typeRawString,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{\n\t\t\t\ts: \"hello\",\n\t\t\t\tt: typeRawString,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid true\",\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid false\",\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid null\",\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"42\",\n\t\t\texpected: &Value{\n\t\t\t\ts: \"42\",\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, expected %v\", tc.input, err, tc.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else if tc.err != nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = nil, expected %v\", tc.input, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, expected %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn compareObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn compareArrays(v1.a, v2.a)\n\tcase typeRawString, TypeNumber, TypeTrue, TypeFalse, TypeNull:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc compareObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc compareArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tif !compareValues(v1, a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "102240021d6c63d042cc29f0cf5c3c80": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_getKV(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\to    *Object\n\t\twant *kv\n\t}{\n\t\t{\n\t\t\tname: \"empty kvs\",\n\t\t\to:    &Object{kvs: []kv{}},\n\t\t\twant: &kv{},\n\t\t},\n\t\t{\n\t\t\tname: \"kvs with capacity\",\n\t\t\to:    &Object{kvs: make([]kv, 1, 2)},\n\t\t\twant: &o.kvs[1],\n\t\t},\n\t\t{\n\t\t\tname: \"kvs without capacity\",\n\t\t\to:    &Object{kvs: []kv{{}, {}}},\n\t\t\twant: &o.kvs[2],\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.o.getKV(); got != tt.want {\n\t\t\t\tt.Errorf(\"Object.getKV() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0e2fc36867a75303a40fd010715ca652": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"valid JSON\",\n\t\t\tinput: `{\"key1\": \"value1\", \"key2\": 42}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{s: \"value1\", t: TypeString}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{s: \"42\", t: TypeNumber}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"invalid JSON\",\n\t\t\tinput: `{\"key1\": \"value1\", \"key2\":`,\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty input\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tp := &Parser{}\n\t\t\tactual, err := p.Parse(tc.input)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"Parse(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !equalValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"Parse(%q) = %v, want %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn equalObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn equalArrays(v1.a, v2.a)\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber, TypeTrue, TypeFalse:\n\t\treturn v1.s == v2.s\n\tcase TypeNull:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc equalObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !equalValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc equalArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tif !equalValues(v1, a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "0e9eb289cd868b9e3366eb39a10000e2": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"empty array\",\n\t\t\tinput:    \"[]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with one value\",\n\t\t\tinput:    \"[1]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with multiple values\",\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}, &Value{t: TypeNumber, s: \"2\"}, &Value{t: TypeNumber, s: \"3\"}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with missing closing bracket\",\n\t\t\tinput:    \"[1, 2, 3\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with missing comma\",\n\t\t\tinput:    \"[1 2]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tactual, _, err := parseArray(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseArray(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeArray:\n\t\ta1, _ := v1.Array()\n\t\ta2, _ := v2.Array()\n\t\tif len(a1) != len(a2) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range a1 {\n\t\t\tif !compareValues(a1[i], a2[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeObject:\n\t\to1, _ := v1.Object()\n\t\to2, _ := v2.Object()\n\t\tif o1.Len() != o2.Len() {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range o1.kvs {\n\t\t\tif o1.kvs[i].k != o2.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !compareValues(o1.kvs[i].v, o2.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeString, TypeNumber, TypeTrue, TypeFalse:\n\t\treturn v1.s == v2.s\n\tcase TypeNull:\n\t\treturn true\n\tdefault:\n\t\tpanic(\"unknown type\")\n\t}\n}",
    "10bbc6828a6fc03332fc16f5cfb25807": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t\trest     string\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.456e+7\",\n\t\t\texpected: \"123.456e+7\",\n\t\t\trest:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with leading sign\",\n\t\t\tinput:    \"-123.456e+7\",\n\t\t\texpected: \"-123.456e+7\",\n\t\t\trest:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with trailing non-digit\",\n\t\t\tinput:    \"123.456e+7x\",\n\t\t\texpected: \"123.456e+7\",\n\t\t\trest:     \"x\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number\",\n\t\t\tinput:    \"abc\",\n\t\t\texpected: \"\",\n\t\t\trest:     \"abc\",\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"inf\",\n\t\t\tinput:    \"inf\",\n\t\t\texpected: \"inf\",\n\t\t\trest:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"nan\",\n\t\t\tinput:    \"nan\",\n\t\t\texpected: \"nan\",\n\t\t\trest:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, want error %t\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.expected {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, want %q\", tc.input, num, tc.expected)\n\t\t\t}\n\t\t\tif rest != tc.rest {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) rest = %q, want %q\", tc.input, rest, tc.rest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0dd52c43968564e6763558b0b79bfa78": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty input\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"too deep nested JSON\",\n\t\t\tinput:    \"{\\\"key\\\":{\\\"key2\\\":{\\\"key3\\\":{}}}}\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t},\n\t\t{\n\t\t\tname:     \"valid object\",\n\t\t\tinput:    `{\"key\":\"value\",\"key2\":123}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{t: TypeString, s: \"value\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid true\",\n\t\t\tinput:    `true`,\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid false\",\n\t\t\tinput:    `false`,\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid null\",\n\t\t\tinput:    `null`,\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    `123`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tv, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, expected %v\", tc.input, err, tc.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else if tc.err != nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = nil, expected %v\", tc.input, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !compareValues(v, tc.expected) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, expected %v\", tc.input, v, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn compareObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn compareArrays(v1.a, v2.a)\n\tcase TypeString, TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeTrue, TypeFalse, TypeNull:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc compareObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc compareArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tif !compareValues(v1, a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "15857d05467c9fab2c5649930ceed954": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"no whitespace\",\n\t\t\tinput:    \"hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading whitespace\",\n\t\t\tinput:    \"   hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"trailing whitespace\",\n\t\t\tinput:    \"hello   \",\n\t\t\texpected: \"hello   \",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading and trailing whitespace\",\n\t\t\tinput:    \"   hello   \",\n\t\t\texpected: \"hello   \",\n\t\t},\n\t\t{\n\t\t\tname:     \"mixed whitespace\",\n\t\t\tinput:    \"   \\t\\r\\n hello \\t\\r\\n\",\n\t\t\texpected: \"hello \\t\\r\\n\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := skipWSSlow(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"skipWSSlow(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "1490d6cb217dd451490dc28ee87e21f0": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.456e+78\",\n\t\t\texpected: []string{\"123.456e+78\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with trailing characters\",\n\t\t\tinput:    \"123.456abc\",\n\t\t\texpected: []string{\"123.456\", \"abc\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number\",\n\t\t\tinput:    \"abc123\",\n\t\t\texpected: []string{\"\", \"abc123\"},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"inf\",\n\t\t\tinput:    \"inf\",\n\t\t\texpected: []string{\"inf\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"nan\",\n\t\t\tinput:    \"nan\",\n\t\t\texpected: []string{\"nan\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.expected[0] || rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = (%q, %q), expected (%q, %q)\", tc.input, num, rest, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "13ac2e84e94bb35e0a1906d0f00aa5aa": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape double quote\",\n\t\t\tinput:    \"\\\"hello, world\\\"\",\n\t\t\texpected: `\"hello, world\"`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backslash\",\n\t\t\tinput:    \"\\\\hello, world\\\\\",\n\t\t\texpected: `\\hello, world\\`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape forward slash\",\n\t\t\tinput:    \"/hello, world/\",\n\t\t\texpected: `/hello, world/`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backspace\",\n\t\t\tinput:    \"h\\bello, world\",\n\t\t\texpected: \"h\\bello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape form feed\",\n\t\t\tinput:    \"h\\fello, world\",\n\t\t\texpected: \"h\\fello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape newline\",\n\t\t\tinput:    \"h\\nello, world\",\n\t\t\texpected: \"h\\nello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape carriage return\",\n\t\t\tinput:    \"h\\rello, world\",\n\t\t\texpected: \"h\\rello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape tab\",\n\t\t\tinput:    \"h\\tello, world\",\n\t\t\texpected: \"h\\tello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Unicode character\",\n\t\t\tinput:    \"\\\\u00A9hello, world\",\n\t\t\texpected: \"Â©hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape invalid Unicode character\",\n\t\t\tinput:    \"\\\\u00Xhello, world\",\n\t\t\texpected: \"\\\\u00Xhello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape surrogate pair\",\n\t\t\tinput:    \"\\\\uD83D\\\\uDE00hello, world\",\n\t\t\texpected: \"ðŸ˜€hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape invalid surrogate pair\",\n\t\t\tinput:    \"\\\\uD83D\\\\uXXXXhello, world\",\n\t\t\texpected: \"\\\\uD83D\\\\uXXXXhello, world\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "131c5e909188ccddbdbc641839726007": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"empty array\",\n\t\t\tinput:    \"[]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with one value\",\n\t\t\tinput:    \"[1]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with multiple values\",\n\t\t\tinput:    \"[1,2,3]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}, &Value{t: TypeNumber, s: \"2\"}, &Value{t: TypeNumber, s: \"3\"}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with missing closing bracket\",\n\t\t\tinput:    \"[1,2,3\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with missing comma\",\n\t\t\tinput:    \"[1 2]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tactual, _, err := parseArray(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseArray(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !compareValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\t}\n\treturn true\n}",
    "148ad80a180eea71a492d6b0b24097d2": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestGetStringBytes(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tvalue *Value\n\t\tkeys  []string\n\t\twant  []byte\n\t}{\n\t\t{\n\t\t\tname: \"valid string\",\n\t\t\tvalue: &Value{\n\t\t\t\ts: \"hello, world\",\n\t\t\t\tt: TypeString,\n\t\t\t},\n\t\t\tkeys: []string{},\n\t\t\twant: []byte(\"hello, world\"),\n\t\t},\n\t\t{\n\t\t\tname:  \"nil value\",\n\t\t\tvalue: nil,\n\t\t\tkeys:  []string{},\n\t\t\twant:  nil,\n\t\t},\n\t\t{\n\t\t\tname: \"non-string value\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\tkeys: []string{},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"non-existing key\",\n\t\t\tvalue: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"foo\", v: &Value{s: \"bar\", t: TypeString}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys: []string{\"baz\"},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"nested object\",\n\t\t\tvalue: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"foo\", v: &Value{\n\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t{k: \"bar\", v: &Value{s: \"baz\", t: TypeString}},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys: []string{\"foo\", \"bar\"},\n\t\t\twant: []byte(\"baz\"),\n\t\t},\n\t\t{\n\t\t\tname: \"array index\",\n\t\t\tvalue: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"foo\", t: TypeString},\n\t\t\t\t\t{s: \"bar\", t: TypeString},\n\t\t\t\t\t{s: \"baz\", t: TypeString},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys: []string{\"1\"},\n\t\t\twant: []byte(\"bar\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.value.GetStringBytes(tt.keys...)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"GetStringBytes(%v) = %v, want %v\", tt.keys, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "14fbe10b0680f4221116e7b1870b9a89": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty array\",\n\t\t\tinput: \"[]\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with one value\",\n\t\t\tinput: \"[1]\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with multiple values\",\n\t\t\tinput: \"[1,2,3]\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with trailing comma\",\n\t\t\tinput: \"[1,2,3,]\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with missing closing bracket\",\n\t\t\tinput: \"[1,2,3\",\n\t\t\texpected: nil,\n\t\t\terr:    true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tactual, _, err := parseArray(tc.input, c, 0)\n\t\t\tif tc.err && err == nil {\n\t\t\t\tt.Errorf(\"expected error, but got none\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tc.err && err != nil {\n\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tc.err && !actual.Equal(tc.expected) {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tc.expected, actual)\n\t\t\t}\n\t\t})\n\t}\n}",
    "14c58917c9d82fa6db5387dd24350ac4": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty input\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"too deep nested JSON\",\n\t\t\tinput:    \"{\\\"key\\\":{\\\"key2\\\":{\\\"key3\\\":{}}}}\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t},\n\t\t{\n\t\t\tname:     \"valid object\",\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: &Value{t: typeRawString, s: \"value\"}}}}},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t}},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{t: typeRawString, s: \"hello\"},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid true\",\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid false\",\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid null\",\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"42\",\n\t\t\texpected: &Value{t: TypeNumber, s: \"42\"},\n\t\t\terr:      nil,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tv, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif tc.err != nil {\n\t\t\t\t\tt.Errorf(\"expected error: %v\", tc.err)\n\t\t\t\t}\n\t\t\t\tif !v.Equal(tc.expected) {\n\t\t\t\t\tt.Errorf(\"unexpected value: got %v, want %v\", v, tc.expected)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}",
    "127578a71a6a36cc5701f713d549647a": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: \"{}\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs:           []kv{},\n\t\t\t\t\t\tkeysUnescaped: true,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"simple object\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tkeysUnescaped: true,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with whitespace\",\n\t\t\tinput: `{ \"key1\" : \"value1\" , \"key2\" : 42 }`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tkeysUnescaped: true,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing colon\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\"}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing comma\",\n\t\t\tinput: `{\"key1\":\"value1\" \"key2\":42}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{\n\t\t\t\tvs: make([]Value, 0, 8),\n\t\t\t}\n\t\t\tactual, _, err := parseObject(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !equalValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn equalObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn equalArrays(v1.a, v2.a)\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeTrue, TypeFalse, TypeNull:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc equalObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !equalValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc equalArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tif !equalValues(v1, a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "15a1bd9c4cb7d2c8250487d176211055": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape double quote\",\n\t\t\tinput:    \"\\\"hello, world\\\"\",\n\t\t\texpected: `\"hello, world\"`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backslash\",\n\t\t\tinput:    \"\\\\hello, world\\\\\",\n\t\t\texpected: `\\hello, world\\`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape forward slash\",\n\t\t\tinput:    \"/hello, world/\",\n\t\t\texpected: `/hello, world/`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backspace\",\n\t\t\tinput:    \"h\\bello, world\",\n\t\t\texpected: \"h\\bello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape form feed\",\n\t\t\tinput:    \"h\\fello, world\",\n\t\t\texpected: \"h\\fello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape newline\",\n\t\t\tinput:    \"h\\nello, world\",\n\t\t\texpected: \"h\\nello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape carriage return\",\n\t\t\tinput:    \"h\\rello, world\",\n\t\t\texpected: \"h\\rello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape tab\",\n\t\t\tinput:    \"h\\tello, world\",\n\t\t\texpected: \"h\\tello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Unicode character\",\n\t\t\tinput:    \"\\\\u00a9 hello, world\",\n\t\t\texpected: \"Â© hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape surrogate pair\",\n\t\t\tinput:    \"\\\\ud83d\\\\ude00 hello, world\",\n\t\t\texpected: \"ðŸ˜€ hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid escape sequence\",\n\t\t\tinput:    \"\\\\x hello, world\",\n\t\t\texpected: \"\\\\x hello, world\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "16723f2ffc32b29d413163cff8fbb420": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: []string{\"hello\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello\\\"world\"`,\n\t\t\texpected: []string{\"hello\\\"world\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello\\\"world\\\"foo\"`,\n\t\t\texpected: []string{\"hello\\\"world\\\"foo\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with no closing quote\",\n\t\t\tinput:    `\"hello`,\n\t\t\texpected: []string{},\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot, rest, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tc.expected[0] || rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = %q, %q, want %q, %q\", tc.input, got, rest, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "1776fcb07dc4d492159b07148dfcd15c": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGet(t *testing.T) {\n\t// Test cases\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    *Value\n\t\tkeys     []string\n\t\texpected *Value\n\t}{\n\t\t{\n\t\t\tname: \"Get from object\",\n\t\t\tinput: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: &Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"key1\"},\n\t\t\texpected: &Value{t: TypeString, s: \"value1\"},\n\t\t},\n\t\t{\n\t\t\tname: \"Get from array\",\n\t\t\tinput: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"value1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"1\"},\n\t\t\texpected: &Value{t: TypeNumber, s: \"42\"},\n\t\t},\n\t\t{\n\t\t\tname:     \"Get from nil\",\n\t\t\tinput:    nil,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Get non-existing key\",\n\t\t\tinput: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: &Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"key2\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Get non-existing array index\",\n\t\t\tinput: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"value1\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"1\"},\n\t\t\texpected: nil,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := tc.input.Get(tc.keys...)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"Get(%v) = %v, expected %v\", tc.keys, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "17b32a79b708d7306585f51b4a70cf38": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: []string{\"hello\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello\\\"world\"`,\n\t\t\texpected: []string{\"hello\\\"world\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello\\\"world\\\"foo\"`,\n\t\t\texpected: []string{\"hello\\\"world\\\"foo\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with no closing quote\",\n\t\t\tinput:    `\"hello`,\n\t\t\texpected: []string{},\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult, rest, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif result != tc.expected[0] {\n\t\t\t\tt.Errorf(\"parseRawString() result = %v, expected %v\", result, tc.expected[0])\n\t\t\t}\n\t\t\tif rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawString() rest = %v, expected %v\", rest, tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "19b3a5701e18b77f98195cf754c31c57": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello world\"`,\n\t\t\texpected: []string{\"hello world\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello \\\"world\\\"\"`,\n\t\t\texpected: []string{\"hello \\\"world\\\"\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello \\\"world\\\" \\\"foo\\\"\"`,\n\t\t\texpected: []string{\"hello \\\"world\\\" \\\"foo\\\"\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with no closing quote\",\n\t\t\tinput:    `\"hello world`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    `\"\"`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult, rest, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif result != tc.expected[0] || rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = %q, %q, want %q, %q\", tc.input, result, rest, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "1b0cb5367fdb39bc465b2887e82894b3": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestTypeString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    Type\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"TypeObject\",\n\t\t\tinput:    TypeObject,\n\t\t\texpected: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeArray\",\n\t\t\tinput:    TypeArray,\n\t\t\texpected: \"array\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeString\",\n\t\t\tinput:    TypeString,\n\t\t\texpected: \"string\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeNumber\",\n\t\t\tinput:    TypeNumber,\n\t\t\texpected: \"number\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeTrue\",\n\t\t\tinput:    TypeTrue,\n\t\t\texpected: \"true\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeFalse\",\n\t\t\tinput:    TypeFalse,\n\t\t\texpected: \"false\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeNull\",\n\t\t\tinput:    TypeNull,\n\t\t\texpected: \"null\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Unknown Type\",\n\t\t\tinput:    Type(100),\n\t\t\texpected: \"BUG: unknown Value type: 100\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := tc.input.String()\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"expected %q, got %q\", tc.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "19b178d5d315f1ee4a910530c85798c5": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape double quote\",\n\t\t\tinput:    \"\\\"hello, world\\\"\",\n\t\t\texpected: `\"hello, world\"`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backslash\",\n\t\t\tinput:    \"\\\\hello, world\\\\\",\n\t\t\texpected: `\\hello, world\\`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape forward slash\",\n\t\t\tinput:    \"/hello, world/\",\n\t\t\texpected: `/hello, world/`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backspace\",\n\t\t\tinput:    \"h\\bello, world\",\n\t\t\texpected: \"h\\bello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape form feed\",\n\t\t\tinput:    \"h\\fello, world\",\n\t\t\texpected: \"h\\fello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape newline\",\n\t\t\tinput:    \"h\\nello, world\",\n\t\t\texpected: \"h\\nello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape carriage return\",\n\t\t\tinput:    \"h\\rello, world\",\n\t\t\texpected: \"h\\rello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape tab\",\n\t\t\tinput:    \"h\\tello, world\",\n\t\t\texpected: \"h\\tello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Unicode\",\n\t\t\tinput:    \"\\\\u0041\\\\u0042\\\\u0043\",\n\t\t\texpected: \"ABC\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Surrogate Pair\",\n\t\t\tinput:    \"\\\\ud83d\\\\ude00\",\n\t\t\texpected: \"ðŸ˜€\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid Escape Sequence\",\n\t\t\tinput:    \"\\\\uABCD\",\n\t\t\texpected: \"\\\\uABCD\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "1bca194f17562f1a6b2bfbc4f35dc226": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetValue(t *testing.T) {\n\tc := &cache{\n\t\tvs: make([]Value, 0, 2),\n\t}\n\n\t// Test when the capacity of the slice is greater than the length\n\tv1 := c.getValue()\n\tif len(c.vs) != 1 {\n\t\tt.Errorf(\"expected length of c.vs to be 1, got %d\", len(c.vs))\n\t}\n\tif v1 != &c.vs[0] {\n\t\tt.Errorf(\"expected v1 to be the same as c.vs[0], got %p and %p\", v1, &c.vs[0])\n\t}\n\n\t// Test when the capacity of the slice is equal to the length\n\tv2 := c.getValue()\n\tif len(c.vs) != 2 {\n\t\tt.Errorf(\"expected length of c.vs to be 2, got %d\", len(c.vs))\n\t}\n\tif v2 != &c.vs[1] {\n\t\tt.Errorf(\"expected v2 to be the same as c.vs[1], got %p and %p\", v2, &c.vs[1])\n\t}\n}",
    "1c00ead46802235ac5eed2c1d0ca0b65": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestGetStringBytes(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tinput *Value\n\t\tkeys  []string\n\t\twant  []byte\n\t}{\n\t\t{\n\t\t\tname: \"existing key path\",\n\t\t\tinput: &Value{\n\t\t\t\ts: \"hello\",\n\t\t\t\tt: TypeString,\n\t\t\t},\n\t\t\tkeys: []string{\"\"},\n\t\t\twant: []byte(\"hello\"),\n\t\t},\n\t\t{\n\t\t\tname: \"non-existing key path\",\n\t\t\tinput: &Value{\n\t\t\t\ts: \"hello\",\n\t\t\t\tt: TypeString,\n\t\t\t},\n\t\t\tkeys: []string{\"foo\"},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid value type\",\n\t\t\tinput: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"foo\", v: &Value{t: TypeObject}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\tkeys: []string{\"foo\"},\n\t\t\twant: nil,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.input.GetStringBytes(tt.keys...)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"GetStringBytes(%v) = %v, want %v\", tt.keys, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "164ccc2a2be2f8e88436d7a4daedb07f": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"too big depth\",\n\t\t\tinput:    \"{}\", // Assuming MaxDepth is 1\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds 1\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"valid object\",\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{s: \"value\", t: typeRawString}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"1\", t: TypeNumber},\n\t\t\t\t\t{s: \"2\", t: TypeNumber},\n\t\t\t\t\t{s: \"3\", t: TypeNumber},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{\n\t\t\t\ts: \"hello\",\n\t\t\t\tt: typeRawString,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid true\",\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid false\",\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid null\",\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"42\",\n\t\t\texpected: &Value{\n\t\t\t\ts: \"42\",\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, expected %v\", tc.input, err, tc.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else if tc.err != nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = nil, expected %v\", tc.input, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, expected %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\to1, _ := v1.Object()\n\t\to2, _ := v2.Object()\n\t\treturn compareObjects(o1, o2)\n\tcase TypeArray:\n\t\ta1, _ := v1.Array()\n\t\ta2, _ := v2.Array()\n\t\tif len(a1) != len(a2) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range a1 {\n\t\t\tif !compareValues(a1[i], a2[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase typeRawString, TypeString, TypeNumber, TypeTrue, TypeFalse, TypeNull:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc compareObjects(o1, o2 *Object) bool {\n\tif o1 == nil && o2 == nil {\n\t\treturn true\n\t}\n\tif o1 == nil || o2 == nil {\n\t\treturn false\n\t}\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i := range o1.kvs {\n\t\tif o1.kvs[i].k != o2.kvs[i].k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(o1.kvs[i].v, o2.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "1aa906ed44c98caf0327578912d5774d": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"hello world\",\n\t\t\texpected: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape double quote\",\n\t\t\tinput:    \"\\\"hello\\\" world\",\n\t\t\texpected: `\"hello\" world`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backslash\",\n\t\t\tinput:    \"hello\\\\ world\",\n\t\t\texpected: `hello\\\\ world`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape forward slash\",\n\t\t\tinput:    \"hello/ world\",\n\t\t\texpected: `hello/ world`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backspace\",\n\t\t\tinput:    \"hello\\b world\",\n\t\t\texpected: `hello\\b world`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape form feed\",\n\t\t\tinput:    \"hello\\f world\",\n\t\t\texpected: `hello\\f world`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape newline\",\n\t\t\tinput:    \"hello\\n world\",\n\t\t\texpected: `hello\\n world`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape carriage return\",\n\t\t\tinput:    \"hello\\r world\",\n\t\t\texpected: `hello\\r world`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape tab\",\n\t\t\tinput:    \"hello\\t world\",\n\t\t\texpected: `hello\\t world`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Unicode\",\n\t\t\tinput:    \"hello\\u0041 world\",\n\t\t\texpected: `helloA world`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Surrogate Pair\",\n\t\t\tinput:    \"hello\\uD83D\\uDE00 world\",\n\t\t\texpected: `helloðŸ˜€ world`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid Escape Sequence\",\n\t\t\tinput:    \"hello\\\\x world\",\n\t\t\texpected: `hello\\\\x world`,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "1c610a9276eeb78e756f2c509ddd525f": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Simple escape characters\",\n\t\t\tinput:    \"hello\\\\\\\"world\\\\\\\\\",\n\t\t\texpected: \"hello\\\"world\\\\\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Unicode escape characters\",\n\t\t\tinput:    \"hello\\\\u0123world\\\\u4567\",\n\t\t\texpected: \"hello\\u0123world\\u4567\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Surrogate pair escape characters\",\n\t\t\tinput:    \"hello\\\\ud83d\\\\ude00world\",\n\t\t\texpected: \"helloðŸ˜€world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid escape characters\",\n\t\t\tinput:    \"hello\\\\xyzworld\",\n\t\t\texpected: \"hello\\\\xyzworld\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "15d7ed731d71f30fb541c89324e4ba82": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty input\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"depth exceeds MaxDepth\",\n\t\t\tinput:    \"{}\", // Assuming MaxDepth is 1\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t},\n\t\t{\n\t\t\tname:     \"valid object\",\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{s: \"value\", t: typeRawString}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"1\", t: TypeNumber},\n\t\t\t\t\t{s: \"2\", t: TypeNumber},\n\t\t\t\t\t{s: \"3\", t: TypeNumber},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{\n\t\t\t\ts: \"hello\",\n\t\t\t\tt: typeRawString,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid true\",\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid false\",\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid null\",\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"42\",\n\t\t\texpected: &Value{\n\t\t\t\ts: \"42\",\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid value\",\n\t\t\tinput:    \"invalid\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"unexpected value found: %q\", \"invalid\"),\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tv, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, expected %v\", tc.input, err, tc.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else if tc.err != nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = nil, expected %v\", tc.input, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !compareValues(v, tc.expected) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, expected %v\", tc.input, v, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn compareObjects(v1.o, v2.o)\n\tcase TypeArray:\n\t\treturn compareArrays(v1.a, v2.a)\n\tcase typeRawString, TypeNumber, TypeTrue, TypeFalse, TypeNull:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc compareObjects(o1, o2 Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc compareArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tif !compareValues(v1, a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "19cc1c015d27484dc43e312ff7b721be": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty array\",\n\t\t\tinput: \"[]\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with one element\",\n\t\t\tinput: \"[1]\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with multiple elements\",\n\t\t\tinput: \"[1,2,3]\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with trailing comma\",\n\t\t\tinput: \"[1,2,3,]\",\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with missing closing bracket\",\n\t\t\tinput: \"[1,2,3\",\n\t\t\terr:   true,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, _, err := parseArray(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseArray(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !equalValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeArray:\n\t\ta1, _ := v1.Array()\n\t\ta2, _ := v2.Array()\n\t\tif len(a1) != len(a2) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range a1 {\n\t\t\tif !equalValues(a1[i], a2[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeObject:\n\t\to1, _ := v1.Object()\n\t\to2, _ := v2.Object()\n\t\tif o1.Len() != o2.Len() {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range o1.kvs {\n\t\t\tif o1.kvs[i].k != o2.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(o1.kvs[i].v, o2.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeString:\n\t\ts1, _ := v1.StringBytes()\n\t\ts2, _ := v2.StringBytes()\n\t\treturn string(s1) == string(s2)\n\tcase TypeNumber, TypeTrue, TypeFalse:\n\t\treturn v1.s == v2.s\n\tcase TypeNull:\n\t\treturn true\n\tdefault:\n\t\tpanic(\"unknown type\")\n\t}\n}",
    "1ce43c5fa81158f58acaadeba7b8f216": "package fastjson_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/valyala/fastjson\"\n)\n\nfunc TestTypeString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    fastjson.Type\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"TypeObject\",\n\t\t\tinput:    fastjson.TypeObject,\n\t\t\texpected: \"object\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeArray\",\n\t\t\tinput:    fastjson.TypeArray,\n\t\t\texpected: \"array\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeString\",\n\t\t\tinput:    fastjson.TypeString,\n\t\t\texpected: \"string\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeNumber\",\n\t\t\tinput:    fastjson.TypeNumber,\n\t\t\texpected: \"number\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeTrue\",\n\t\t\tinput:    fastjson.TypeTrue,\n\t\t\texpected: \"true\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeFalse\",\n\t\t\tinput:    fastjson.TypeFalse,\n\t\t\texpected: \"false\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeNull\",\n\t\t\tinput:    fastjson.TypeNull,\n\t\t\texpected: \"null\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Unknown\",\n\t\t\tinput:    fastjson.Type(100),\n\t\t\texpected: \"BUG: unknown Value type: 100\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := tc.input.String()\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"expected %q, got %q\", tc.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "1ea4de15947de5848d3c8cf899c4801a": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestType_String(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tt    Type\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"TypeObject\",\n\t\t\tt:    TypeObject,\n\t\t\twant: \"object\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeArray\",\n\t\t\tt:    TypeArray,\n\t\t\twant: \"array\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeString\",\n\t\t\tt:    TypeString,\n\t\t\twant: \"string\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeNumber\",\n\t\t\tt:    TypeNumber,\n\t\t\twant: \"number\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeTrue\",\n\t\t\tt:    TypeTrue,\n\t\t\twant: \"true\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeFalse\",\n\t\t\tt:    TypeFalse,\n\t\t\twant: \"false\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeNull\",\n\t\t\tt:    TypeNull,\n\t\t\twant: \"null\",\n\t\t},\n\t\t{\n\t\t\tname: \"Unknown\",\n\t\t\tt:    Type(100),\n\t\t\twant: \"BUG: unknown Value type: 100\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.t.String(); got != tt.want {\n\t\t\t\tt.Errorf(\"Type.String() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "1d6102038107577e8f368fb5065b7559": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.456e+78\",\n\t\t\texpected: []string{\"123.456e+78\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with leading sign\",\n\t\t\tinput:    \"-123.456e+78\",\n\t\t\texpected: []string{\"-123.456e+78\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with trailing characters\",\n\t\t\tinput:    \"123.456e+78abc\",\n\t\t\texpected: []string{\"123.456e+78\", \"abc\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number\",\n\t\t\tinput:    \"abc\",\n\t\t\texpected: []string{\"\", \"abc\"},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.expected[0] || rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = (%q, %q), expected (%q, %q)\", tc.input, num, rest, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "1dca8b16fd1f12843f54c38e028842d2": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetUint(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    *Value\n\t\tkeys     []string\n\t\texpected uint\n\t}{\n\t\t{\n\t\t\tname:     \"valid uint\",\n\t\t\tinput:    &Value{s: \"42\", t: TypeNumber},\n\t\t\tkeys:     []string{},\n\t\t\texpected: 42,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid value type\",\n\t\t\tinput:    &Value{s: \"true\", t: TypeTrue},\n\t\t\tkeys:     []string{},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"non-existing keys path\",\n\t\t\tinput:    &Value{s: \"42\", t: TypeNumber},\n\t\t\tkeys:     []string{\"foo\", \"bar\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"uint64 overflow\",\n\t\t\tinput:    &Value{s: \"18446744073709551616\", t: TypeNumber},\n\t\t\tkeys:     []string{},\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := tc.input.GetUint(tc.keys...)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"GetUint(%v) = %d, want %d\", tc.keys, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "20b5c1c1a4dfaafd124f9ff342248bef": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.456e+7\",\n\t\t\texpected: []string{\"123.456e+7\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with sign\",\n\t\t\tinput:    \"-123.456e-7\",\n\t\t\texpected: []string{\"-123.456e-7\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with exponent\",\n\t\t\tinput:    \"1e+10\",\n\t\t\texpected: []string{\"1e+10\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number\",\n\t\t\tinput:    \"abc\",\n\t\t\texpected: []string{\"\", \"abc\"},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"infinity\",\n\t\t\tinput:    \"inf\",\n\t\t\texpected: []string{\"inf\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN\",\n\t\t\tinput:    \"nan\",\n\t\t\texpected: []string{\"nan\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.expected[0] || rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, %q, want %q, %q\", tc.input, num, rest, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "1ef5dafc5651aab64d7c67dcd23d202e": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGet(t *testing.T) {\n\t// Test cases\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    *Value\n\t\tkeys     []string\n\t\texpected *Value\n\t}{\n\t\t{\n\t\t\tname: \"Existing keys path\",\n\t\t\tinput: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{a: []*Value{&Value{s: \"value2\"}, &Value{s: \"value3\"}}}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"key1\", \"key2\", \"0\"},\n\t\t\texpected: &Value{s: \"value2\"},\n\t\t},\n\t\t{\n\t\t\tname: \"Non-existing keys path\",\n\t\t\tinput: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{s: \"value1\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"key1\", \"key2\", \"0\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Array index out of range\",\n\t\t\tinput: &Value{\n\t\t\t\ta: []*Value{&Value{s: \"value1\"}, &Value{s: \"value2\"}},\n\t\t\t},\n\t\t\tkeys:     []string{\"2\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Nil input\",\n\t\t\tinput:    nil,\n\t\t\tkeys:     []string{\"key1\"},\n\t\t\texpected: nil,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := tc.input.Get(tc.keys...)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"Get(%v) = %v, expected %v\", tc.keys, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "20c0b47d55f6f1274b8c35f08b22d4a0": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected1, expected2 string\n\t\texpectedErr bool\n\t}{\n\t\t{\n\t\t\tname:  \"Simple string\",\n\t\t\tinput: `\"hello world\"`,\n\t\t\texpected1: \"hello world\",\n\t\t\texpected2: \"\",\n\t\t\texpectedErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"String with escaped quote\",\n\t\t\tinput: `\"hello \\\"world\\\"\"`,\n\t\t\texpected1: `hello \"world\"`,\n\t\t\texpected2: \"\",\n\t\t\texpectedErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"String with multiple escaped quotes\",\n\t\t\tinput: `\"hello \\\"world\\\" \\\"again\\\"\"`,\n\t\t\texpected1: `hello \"world\" \"again\"`,\n\t\t\texpected2: \"\",\n\t\t\texpectedErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"String with no closing quote\",\n\t\t\tinput: `\"hello world`,\n\t\t\texpected1: \"\",\n\t\t\texpected2: \"\",\n\t\t\texpectedErr: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult1, result2, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.expectedErr {\n\t\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expectedErr = %t\", tc.input, err, tc.expectedErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif result1 != tc.expected1 {\n\t\t\t\tt.Errorf(\"parseRawString(%q) result1 = %q, expected = %q\", tc.input, result1, tc.expected1)\n\t\t\t}\n\t\t\tif result2 != tc.expected2 {\n\t\t\t\tt.Errorf(\"parseRawString(%q) result2 = %q, expected = %q\", tc.input, result2, tc.expected2)\n\t\t\t}\n\t\t})\n\t}\n}",
    "20c410e6014f42776532d2abe3f935ad": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: []string{\"hello\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello\\\"world\"`,\n\t\t\texpected: []string{\"hello\\\"world\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello\\\"world\\\"foo\"`,\n\t\t\texpected: []string{\"hello\\\"world\\\"foo\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with no closing quote\",\n\t\t\tinput:    `\"hello`,\n\t\t\texpected: []string{},\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tc.expected[0] {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, expected %v\", got, tc.expected[0])\n\t\t\t}\n\t\t})\n\t}\n}",
    "20bdc202f514624e2445ff26eb23a8bf": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestObject_unescapeKeys(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\to    *Object\n\t\twant *Object\n\t}{\n\t\t{\n\t\t\tname: \"no keys to unescape\",\n\t\t\to: &Object{\n\t\t\t\tkvs:           []kv{{k: \"key1\", v: &Value{}}, {k: \"key2\", v: &Value{}}},\n\t\t\t\tkeysUnescaped: true,\n\t\t\t},\n\t\t\twant: &Object{\n\t\t\t\tkvs:           []kv{{k: \"key1\", v: &Value{}}, {k: \"key2\", v: &Value{}}},\n\t\t\t\tkeysUnescaped: true,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"keys to unescape\",\n\t\t\to: &Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: `key\\\"1`, v: &Value{}},\n\t\t\t\t\t{k: `key\\\"2`, v: &Value{}},\n\t\t\t\t},\n\t\t\t\tkeysUnescaped: false,\n\t\t\t},\n\t\t\twant: &Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: `key\"1`, v: &Value{}},\n\t\t\t\t\t{k: `key\"2`, v: &Value{}},\n\t\t\t\t},\n\t\t\t\tkeysUnescaped: true,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\ttt.o.unescapeKeys()\n\t\t\tif !reflect.DeepEqual(tt.o, tt.want) {\n\t\t\t\tt.Errorf(\"Object.unescapeKeys() = %v, want %v\", tt.o, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "20f4fca86896e8b2a8b5f24aff6e129d": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape double quote\",\n\t\t\tinput:    \"\\\"hello, world\\\"\",\n\t\t\texpected: `\"hello, world\"`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backslash\",\n\t\t\tinput:    \"\\\\hello, world\\\\\",\n\t\t\texpected: `\\hello, world\\`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape forward slash\",\n\t\t\tinput:    \"/hello, world/\",\n\t\t\texpected: `/hello, world/`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backspace\",\n\t\t\tinput:    \"h\\bello, world\",\n\t\t\texpected: \"h\\bello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape form feed\",\n\t\t\tinput:    \"h\\fello, world\",\n\t\t\texpected: \"h\\fello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape newline\",\n\t\t\tinput:    \"h\\nello, world\",\n\t\t\texpected: \"h\\nello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape carriage return\",\n\t\t\tinput:    \"h\\rello, world\",\n\t\t\texpected: \"h\\rello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape tab\",\n\t\t\tinput:    \"h\\tello, world\",\n\t\t\texpected: \"h\\tello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Unicode character\",\n\t\t\tinput:    \"\\\\u00a9 hello, world\",\n\t\t\texpected: \"Â© hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape surrogate pair\",\n\t\t\tinput:    \"\\\\ud83d\\\\ude00 hello, world\",\n\t\t\texpected: \"ðŸ˜€ hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid escape sequence\",\n\t\t\tinput:    \"\\\\x hello, world\",\n\t\t\texpected: \"\\\\x hello, world\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2013af45e79fe47fbf01b0eaa4ee45fa": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"empty array\",\n\t\t\tinput:    \"[]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with one value\",\n\t\t\tinput:    \"[1]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with multiple values\",\n\t\t\tinput:    \"[1,2,3]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}, &Value{t: TypeNumber, s: \"2\"}, &Value{t: TypeNumber, s: \"3\"}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with missing closing bracket\",\n\t\t\tinput:    \"[1,2,3\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with missing comma\",\n\t\t\tinput:    \"[1 2]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, _, err := parseArray(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseArray(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !compareValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !compareValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeTrue, TypeFalse, TypeNull:\n\t\treturn true\n\tdefault:\n\t\tpanic(\"unknown type\")\n\t}\n\treturn true\n}",
    "21563450aa831ddb46cebdbf589fe705": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestTypeString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    Type\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"TypeObject\",\n\t\t\tinput:    TypeObject,\n\t\t\texpected: \"object\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeArray\",\n\t\t\tinput:    TypeArray,\n\t\t\texpected: \"array\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeString\",\n\t\t\tinput:    TypeString,\n\t\t\texpected: \"string\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeNumber\",\n\t\t\tinput:    TypeNumber,\n\t\t\texpected: \"number\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeTrue\",\n\t\t\tinput:    TypeTrue,\n\t\t\texpected: \"true\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeFalse\",\n\t\t\tinput:    TypeFalse,\n\t\t\texpected: \"false\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeNull\",\n\t\t\tinput:    TypeNull,\n\t\t\texpected: \"null\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Unknown Type\",\n\t\t\tinput:    Type(100),\n\t\t\texpected: \"BUG: unknown Value type: 100\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := tc.input.String()\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"expected %q, got %q\", tc.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2450389b1bc6ad67b7ef7b1235a62386": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: []string{\"hello\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello\\\"world\"`,\n\t\t\texpected: []string{\"hello\\\"world\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello\\\"world\\\"foo\"`,\n\t\t\texpected: []string{\"hello\\\"world\\\"foo\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with unmatched quote\",\n\t\t\tinput:    `\"hello`,\n\t\t\texpected: []string{},\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot1, got2, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got1 != tc.expected[0] || got2 != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = (%q, %q), want (%q, %q)\", tc.input, got1, got2, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "21fe26a1eb0ca3f4d414e14beec4b95b": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":\"value1\",\"key2\":42}`),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"hello\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`[\"hello\",42,true]`),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42\",\n\t\t\t},\n\t\t\twant: []byte(\"42\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := make([]byte, 0, 64)\n\t\t\tgot := tt.v.MarshalTo(dst)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %s, want %s\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2476caea5205f813f94d185bcf37165b": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetUint64(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tjson     string\n\t\tkeys     []string\n\t\texpected uint64\n\t}{\n\t\t{\n\t\t\tname:     \"Existing key with valid uint64 value\",\n\t\t\tjson:     `{\"key\": 1234567890}`,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: 1234567890,\n\t\t},\n\t\t{\n\t\t\tname:     \"Existing key with invalid value type\",\n\t\t\tjson:     `{\"key\": \"value\"}`,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Non-existing key\",\n\t\t\tjson:     `{\"key1\": 1234567890}`,\n\t\t\tkeys:     []string{\"key2\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Array index in keys\",\n\t\t\tjson:     `{\"key\": [1, 2, 3]}`,\n\t\t\tkeys:     []string{\"key\", \"1\"},\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"Nested object\",\n\t\t\tjson:     `{\"key1\": {\"key2\": 1234567890}}`,\n\t\t\tkeys:     []string{\"key1\", \"key2\"},\n\t\t\texpected: 1234567890,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tv, err := ParseBytes([]byte(tc.json))\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tactual := v.GetUint64(tc.keys...)\n\t\t\tif actual != tc.expected {\n\t\t\t\tt.Errorf(\"Expected %d, got %d\", tc.expected, actual)\n\t\t\t}\n\t\t})\n\t}\n}",
    "24aa5034a511785e1541e0d1a6b12b78": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUint(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    *Value\n\t\texpected uint\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid uint\",\n\t\t\tinput:    &Value{s: \"42\", t: TypeNumber},\n\t\t\texpected: 42,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid type\",\n\t\t\tinput:    &Value{s: \"true\", t: TypeTrue},\n\t\t\texpected: 0,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"number too large\",\n\t\t\tinput:    &Value{s: \"18446744073709551616\", t: TypeNumber},\n\t\t\texpected: 0,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"non-numeric string\",\n\t\t\tinput:    &Value{s: \"foo\", t: TypeString},\n\t\t\texpected: 0,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult, err := tc.input.Uint()\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"Uint() error = %v, wantErr %v\", err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"Uint() = %v, want %v\", result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2100dd028b870c5605e39b71dc4b7a32": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"too big depth\",\n\t\t\tinput:    \"{}\", // Assuming MaxDepth is 1\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds 1\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"valid object\",\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{s: \"value\", t: typeRawString}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"1\", t: TypeNumber},\n\t\t\t\t\t{s: \"2\", t: TypeNumber},\n\t\t\t\t\t{s: \"3\", t: TypeNumber},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{s: \"hello\", t: typeRawString},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid true\",\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid false\",\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid null\",\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"42\",\n\t\t\texpected: &Value{s: \"42\", t: TypeNumber},\n\t\t\terr:      nil,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, expected %v\", tc.input, err, tc.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else if tc.err != nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = nil, expected %v\", tc.input, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, expected %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn compareObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn compareArrays(v1.a, v2.a)\n\tcase typeRawString, TypeNumber, TypeTrue, TypeFalse, TypeNull:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc compareObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc compareArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tif !compareValues(v1, a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "219d017f87ef89c0155d62b9adcf69a1": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: \"{}\",\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           []kv{},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"simple object\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with nested value\",\n\t\t\tinput: `{\"key1\":{\"subkey\":\"subvalue\"}}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{\n\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t{k: \"subkey\", v: &Value{t: TypeString, s: \"subvalue\"}},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tactual, _, err := parseObject(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn compareObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn compareArrays(v1.a, v2.a)\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber, TypeTrue, TypeFalse:\n\t\treturn v1.s == v2.s\n\tcase TypeNull:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc compareObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc compareArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tif !compareValues(v1, a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "21c8b9ab6e61b74c9c277e147ee024f4": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: \"{}\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with one key-value pair\",\n\t\t\tinput: `{\"key\":\"value\"}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with multiple key-value pairs\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42,\"key3\":true}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\ts: \"42\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\tinput: `{\"key1\":\"value1\",`,\n\t\t\texpected: nil,\n\t\t\terr:     true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tv, _, err := parseObject(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !v.Equal(tc.expected) {\n\t\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", tc.input, v, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc (v *Value) Equal(other *Value) bool {\n\tif v == nil && other == nil {\n\t\treturn true\n\t}\n\tif v == nil || other == nil {\n\t\treturn false\n\t}\n\tif v.t != other.t {\n\t\treturn false\n\t}\n\tswitch v.t {\n\tcase TypeObject:\n\t\treturn v.o.Equal(&other.o)\n\tcase TypeArray:\n\t\tif len(v.a) != len(other.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, vv := range v.a {\n\t\t\tif !vv.Equal(other.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeString:\n\t\treturn v.s == other.s\n\tcase TypeNumber, TypeTrue, TypeFalse, TypeNull:\n\t\treturn v.s == other.s\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc (o *Object) Equal(other *Object) bool {\n\tif len(o.kvs) != len(other.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv := range o.kvs {\n\t\tif kv.k != other.kvs[i].k {\n\t\t\treturn false\n\t\t}\n\t\tif !kv.v.Equal(other.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "24f6ab7fa227301c86006c63fd2bf228": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGet(t *testing.T) {\n\t// Test cases\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    *Value\n\t\tkeys     []string\n\t\texpected *Value\n\t}{\n\t\t{\n\t\t\tname: \"Existing keys path\",\n\t\t\tinput: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{a: []*Value{\n\t\t\t\t\t\t\t{s: \"array1\"},\n\t\t\t\t\t\t\t{s: \"array2\"},\n\t\t\t\t\t\t}}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"key1\"},\n\t\t\texpected: &Value{s: \"value1\"},\n\t\t},\n\t\t{\n\t\t\tname: \"Array index in keys path\",\n\t\t\tinput: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key2\", v: &Value{a: []*Value{\n\t\t\t\t\t\t\t{s: \"array1\"},\n\t\t\t\t\t\t\t{s: \"array2\"},\n\t\t\t\t\t\t}}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"key2\", \"1\"},\n\t\t\texpected: &Value{s: \"array2\"},\n\t\t},\n\t\t{\n\t\t\tname:     \"Nil input\",\n\t\t\tinput:    nil,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Non-existing keys path\",\n\t\t\tinput: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{s: \"value1\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"key2\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Invalid type in keys path\",\n\t\t\tinput: &Value{\n\t\t\t\ts: \"string\",\n\t\t\t},\n\t\t\tkeys:     []string{\"0\"},\n\t\t\texpected: nil,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := tc.input.Get(tc.keys...)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"Get(%v) = %v, expected %v\", tc.keys, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2442be74b57fe2079b5eff0a2bc0c33a": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"too big depth\",\n\t\t\tinput:    \"{}\", // Assuming MaxDepth is 1\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds 1\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"valid object\",\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{s: \"value\", t: typeRawString}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"1\", t: TypeNumber},\n\t\t\t\t\t{s: \"2\", t: TypeNumber},\n\t\t\t\t\t{s: \"3\", t: TypeNumber},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{\n\t\t\t\ts: \"hello\",\n\t\t\t\tt: typeRawString,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid true\",\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid false\",\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid null\",\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"42\",\n\t\t\texpected: &Value{\n\t\t\t\ts: \"42\",\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tv, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) returned error %v, expected %v\", tc.input, err, tc.err)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif tc.expected == nil {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) returned %v, expected nil\", tc.input, v)\n\t\t\t\t} else if !v.Equal(tc.expected) {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) returned %v, expected %v\", tc.input, v, tc.expected)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}",
    "24e116bdb8eb228efbb3cb4d39692562": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty input\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"too deep nested JSON\",\n\t\t\tinput:    \"{\\\"key\\\":{\\\"key2\\\":{\\\"key3\\\":{}}}}\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t},\n\t\t{\n\t\t\tname:     \"valid object\",\n\t\t\tinput:    `{\"key\":\"value\",\"key2\":123}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{s: \"value\", t: typeRawString}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{s: \"123\", t: TypeNumber}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"1\", t: TypeNumber},\n\t\t\t\t\t{s: \"2\", t: TypeNumber},\n\t\t\t\t\t{s: \"3\", t: TypeNumber},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{\n\t\t\t\ts: \"hello\",\n\t\t\t\tt: typeRawString,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid true\",\n\t\t\tinput:    `true`,\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid false\",\n\t\t\tinput:    `false`,\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid null\",\n\t\t\tinput:    `null`,\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    `123`,\n\t\t\texpected: &Value{\n\t\t\t\ts: \"123\",\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tv, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif tc.err != nil {\n\t\t\t\tt.Errorf(\"expected error: %v\", tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !v.Equal(tc.expected) {\n\t\t\t\tt.Errorf(\"unexpected value: got %v, want %v\", v, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2611c8b38fe13525416c8e88ca98ba23": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWS(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"no whitespace\",\n\t\t\tinput:    \"hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading whitespace\",\n\t\t\tinput:    \"   hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"trailing whitespace\",\n\t\t\tinput:    \"hello   \",\n\t\t\texpected: \"hello   \",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading and trailing whitespace\",\n\t\t\tinput:    \"   hello   \",\n\t\t\texpected: \"hello   \",\n\t\t},\n\t\t{\n\t\t\tname:     \"mixed whitespace\",\n\t\t\tinput:    \"   he\\tllo\\n \",\n\t\t\texpected: \"he\\tllo\\n \",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := skipWS(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"skipWS(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2571a7638b76ad2d74e4411f384573ac": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:  \"valid JSON\",\n\t\t\tinput: `{\"key1\": \"value1\", \"key2\": 42}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{s: \"value1\", t: TypeString}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{s: \"42\", t: TypeNumber}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid JSON\",\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\":`,\n\t\t\texpected: nil,\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty input\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tp := &Parser{}\n\t\t\tgot, err := p.Parse(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"Parse() error = %v, wantErr %v\", err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tc.wantErr && !got.Equal(tc.expected) {\n\t\t\t\tt.Errorf(\"Parse() = %v, want %v\", got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc (v *Value) Equal(other *Value) bool {\n\tif v == nil && other == nil {\n\t\treturn true\n\t}\n\tif v == nil || other == nil {\n\t\treturn false\n\t}\n\tif v.t != other.t {\n\t\treturn false\n\t}\n\tswitch v.t {\n\tcase TypeObject:\n\t\treturn v.o.Equal(&other.o)\n\tcase TypeArray:\n\t\tif len(v.a) != len(other.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, vv := range v.a {\n\t\t\tif !vv.Equal(other.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeString:\n\t\treturn v.s == other.s\n\tcase TypeNumber, TypeTrue, TypeFalse:\n\t\treturn v.s == other.s\n\tcase TypeNull:\n\t\treturn true\n\tdefault:\n\t\tpanic(\"unknown type\")\n\t}\n}\n\nfunc (o *Object) Equal(other *Object) bool {\n\tif len(o.kvs) != len(other.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv := range o.kvs {\n\t\tif kv.k != other.kvs[i].k {\n\t\t\treturn false\n\t\t}\n\t\tif !kv.v.Equal(other.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "26212585ff2cf80f2aa004def4351ae6": "package fastjson_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/valyala/fastjson\"\n)\n\nfunc TestTypeString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tt        fastjson.Type\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"TypeObject\",\n\t\t\tt:        fastjson.TypeObject,\n\t\t\texpected: \"object\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeArray\",\n\t\t\tt:        fastjson.TypeArray,\n\t\t\texpected: \"array\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeString\",\n\t\t\tt:        fastjson.TypeString,\n\t\t\texpected: \"string\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeNumber\",\n\t\t\tt:        fastjson.TypeNumber,\n\t\t\texpected: \"number\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeTrue\",\n\t\t\tt:        fastjson.TypeTrue,\n\t\t\texpected: \"true\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeFalse\",\n\t\t\tt:        fastjson.TypeFalse,\n\t\t\texpected: \"false\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeNull\",\n\t\t\tt:        fastjson.TypeNull,\n\t\t\texpected: \"null\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Unknown\",\n\t\t\tt:        fastjson.Type(100),\n\t\t\texpected: \"BUG: unknown Value type: 100\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := tc.t.String()\n\t\t\tif got != tc.expected {\n\t\t\t\tt.Errorf(\"String() = %q, want %q\", got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "240bda3681d592206cdcef8ff7978b96": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: \"{}\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with one key-value pair\",\n\t\t\tinput: `{\"key\":\"value\"}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with multiple key-value pairs\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":123,\"key3\":true}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\tinput: `{\"key1\":\"value1\",`,\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing colon\",\n\t\t\tinput: `{\"key1\" \"value1\"}`,\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing comma\",\n\t\t\tinput: `{\"key1\":\"value1\" \"key2\":\"value2\"}`,\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, _, err := parseObject(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseObject(%q) error = %v, expected %v\", tc.input, err, tc.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif tc.err != nil {\n\t\t\t\t\tt.Errorf(\"parseObject(%q) error = nil, expected %v\", tc.input, tc.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif !valuesEqual(actual, tc.expected) {\n\t\t\t\t\tt.Errorf(\"parseObject(%q) = %v, expected %v\", tc.input, actual, tc.expected)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc valuesEqual(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn objectsEqual(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn arraysEqual(v1.a, v2.a)\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber, TypeTrue, TypeFalse:\n\t\treturn v1.s == v2.s\n\tcase TypeNull:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc objectsEqual(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !valuesEqual(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc arraysEqual(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tv2 := a2[i]\n\t\tif !valuesEqual(v1, v2) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "25f24fcc36cc60aec68c7ede89d509c3": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.45e+6\",\n\t\t\texpected: []string{\"123.45e+6\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with leading zeros\",\n\t\t\tinput:    \"0123.45\",\n\t\t\texpected: []string{\"0123.45\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with sign\",\n\t\t\tinput:    \"-123.45\",\n\t\t\texpected: []string{\"-123.45\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with inf\",\n\t\t\tinput:    \"inf\",\n\t\t\texpected: []string{\"inf\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with nan\",\n\t\t\tinput:    \"nan\",\n\t\t\texpected: []string{\"nan\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number\",\n\t\t\tinput:    \"123.45a\",\n\t\t\texpected: []string{\"\", \"123.45a\"},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.expected[0] || rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, %q, want %q, %q\", tc.input, num, rest, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "27cd5aa55d8e553f006c9edbd010abf8": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestHasSpecialChars(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname:     \"Empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"String with no special characters\",\n\t\t\tinput:    \"hello world\",\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"String with double quote\",\n\t\t\tinput:    \"hello \\\"world\\\"\",\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"String with backslash\",\n\t\t\tinput:    \"hello\\\\world\",\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"String with control character\",\n\t\t\tinput:    \"hello\\nworld\",\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := hasSpecialChars(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"hasSpecialChars(%q) = %t, expected %t\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "297a10288aca5d542180707ce840f7cb": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"no whitespace\",\n\t\t\tinput:    \"hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading whitespace\",\n\t\t\tinput:    \"   hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"trailing whitespace\",\n\t\t\tinput:    \"hello   \",\n\t\t\texpected: \"hello   \",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading and trailing whitespace\",\n\t\t\tinput:    \"   hello   \",\n\t\t\texpected: \"hello   \",\n\t\t},\n\t\t{\n\t\t\tname:     \"mixed whitespace\",\n\t\t\tinput:    \"   \\t\\n\\r hello \\t\\n\\r\",\n\t\t\texpected: \"hello \\t\\n\\r\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := skipWSSlow(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"skipWSSlow(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "272c0c6a1e68be2b97a6035d445c2919": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape double quote\",\n\t\t\tinput:    \"\\\"hello, world\\\"\",\n\t\t\texpected: `\"hello, world\"`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backslash\",\n\t\t\tinput:    \"\\\\hello, world\\\\\",\n\t\t\texpected: `\\hello, world\\`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape forward slash\",\n\t\t\tinput:    \"/hello, world/\",\n\t\t\texpected: `/hello, world/`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backspace\",\n\t\t\tinput:    \"h\\bello, world\",\n\t\t\texpected: \"h\\bello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape form feed\",\n\t\t\tinput:    \"h\\fello, world\",\n\t\t\texpected: \"h\\fello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape newline\",\n\t\t\tinput:    \"h\\nello, world\",\n\t\t\texpected: \"h\\nello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape carriage return\",\n\t\t\tinput:    \"h\\rello, world\",\n\t\t\texpected: \"h\\rello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape tab\",\n\t\t\tinput:    \"h\\tello, world\",\n\t\t\texpected: \"h\\tello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Unicode\",\n\t\t\tinput:    \"\\\\u0041\\\\u0042\\\\u0043\",\n\t\t\texpected: \"ABC\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Surrogate Pair\",\n\t\t\tinput:    \"\\\\ud83d\\\\ude00\",\n\t\t\texpected: \"ðŸ˜€\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid Escape Sequence\",\n\t\t\tinput:    \"\\\\uABCD\",\n\t\t\texpected: \"\\\\uABCD\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "297412639b832349e7f5ce6fcb4c4db4": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected1, expected2 string\n\t\texpectedErr bool\n\t}{\n\t\t{\n\t\t\tname:  \"Simple string\",\n\t\t\tinput: `\"hello\"`,\n\t\t\texpected1: \"hello\",\n\t\t\texpected2: \"\",\n\t\t\texpectedErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"String with escaped quote\",\n\t\t\tinput: `\"hello\\\"world\"`,\n\t\t\texpected1: \"hello\\\"world\",\n\t\t\texpected2: \"\",\n\t\t\texpectedErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"String with multiple escaped quotes\",\n\t\t\tinput: `\"hello\\\"world\\\"foo\"`,\n\t\t\texpected1: \"hello\\\"world\\\"foo\",\n\t\t\texpected2: \"\",\n\t\t\texpectedErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"String with no closing quote\",\n\t\t\tinput: `\"hello`,\n\t\t\texpected1: \"\",\n\t\t\texpected2: \"\",\n\t\t\texpectedErr: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult1, result2, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.expectedErr {\n\t\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expectedErr = %v\", tc.input, err, tc.expectedErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif result1 != tc.expected1 {\n\t\t\t\tt.Errorf(\"parseRawString(%q) result1 = %q, expected = %q\", tc.input, result1, tc.expected1)\n\t\t\t}\n\t\t\tif result2 != tc.expected2 {\n\t\t\t\tt.Errorf(\"parseRawString(%q) result2 = %q, expected = %q\", tc.input, result2, tc.expected2)\n\t\t\t}\n\t\t})\n\t}\n}",
    "264992c214c752cc47b58bbf20058423": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: \"{}\",\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           []kv{},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with one key-value pair\",\n\t\t\tinput: `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with multiple key-value pairs\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":123,\"key3\":true}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":123`,\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing colon\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\"}`,\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing value\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":}`,\n\t\t\terr:   true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tv, _, err := parseObject(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tc.err && !v.Equal(tc.expected) {\n\t\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", tc.input, v, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc (v *Value) Equal(other *Value) bool {\n\tif v.t != other.t {\n\t\treturn false\n\t}\n\tswitch v.t {\n\tcase TypeObject:\n\t\treturn v.o.Equal(&other.o)\n\tcase TypeArray:\n\t\tif len(v.a) != len(other.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, vv := range v.a {\n\t\t\tif !vv.Equal(other.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeString:\n\t\treturn v.s == other.s\n\tcase TypeNumber:\n\t\treturn v.s == other.s\n\tcase TypeTrue, TypeFalse, TypeNull:\n\t\treturn true\n\tdefault:\n\t\tpanic(\"unreachable\")\n\t}\n}\n\nfunc (o *Object) Equal(other *Object) bool {\n\tif len(o.kvs) != len(other.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv := range o.kvs {\n\t\tif kv.k != other.kvs[i].k {\n\t\t\treturn false\n\t\t}\n\t\tif !kv.v.Equal(other.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "2598149e38f0e0fe920438f700e84475": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: `{}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs:           []kv{},\n\t\t\t\t\t\tkeysUnescaped: true,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"simple object\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tkeysUnescaped: true,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with whitespace\",\n\t\t\tinput: `{ \"key1\" : \"value1\" , \"key2\" : 42 }`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tkeysUnescaped: true,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing colon\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\" 42}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing comma\",\n\t\t\tinput: `{\"key1\":\"value1\" \"key2\":42}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{\n\t\t\t\tvs: make([]Value, 0, 8),\n\t\t\t}\n\t\t\tactual, _, err := parseObject(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !equalValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn equalObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn equalArrays(v1.a, v2.a)\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeTrue, TypeFalse, TypeNull:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc equalObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !equalValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc equalArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tif !equalValues(v1, a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "2cb611f73ab55538a6a679daf9e960b9": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Simple escape characters\",\n\t\t\tinput:    \"hello\\\\\\\"world\\\\\\\\\",\n\t\t\texpected: \"hello\\\"world\\\\\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Unicode escape characters\",\n\t\t\tinput:    \"hello\\\\u0041world\\\\u0042\",\n\t\t\texpected: \"helloAwordB\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Surrogate pair escape characters\",\n\t\t\tinput:    \"hello\\\\ud83d\\\\ude00world\",\n\t\t\texpected: \"helloðŸ˜€world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid escape characters\",\n\t\t\tinput:    \"hello\\\\xworld\",\n\t\t\texpected: \"hello\\\\xworld\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2ad93eb098464d4bf66381bf823da026": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGet(t *testing.T) {\n\t// Test cases\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    *Value\n\t\tkeys     []string\n\t\texpected *Value\n\t}{\n\t\t{\n\t\t\tname: \"Existing key in object\",\n\t\t\tinput: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"key2\"},\n\t\t\texpected: &Value{t: TypeNumber, s: \"42\"},\n\t\t},\n\t\t{\n\t\t\tname: \"Non-existing key in object\",\n\t\t\tinput: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"key3\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Existing index in array\",\n\t\t\tinput: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"value1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"1\"},\n\t\t\texpected: &Value{t: TypeNumber, s: \"42\"},\n\t\t},\n\t\t{\n\t\t\tname: \"Non-existing index in array\",\n\t\t\tinput: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"value1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"2\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Nil input\",\n\t\t\tinput:    nil,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: nil,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := tc.input.Get(tc.keys...)\n\t\t\tif tc.expected != result {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", tc.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2ae0ecdcd56d387cccfbe4e2f5863e58": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape double quote\",\n\t\t\tinput:    \"\\\"hello, world\\\"\",\n\t\t\texpected: `\"hello, world\"`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backslash\",\n\t\t\tinput:    \"\\\\hello, world\\\\\",\n\t\t\texpected: `\\hello, world\\`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape forward slash\",\n\t\t\tinput:    \"/hello, world/\",\n\t\t\texpected: `/hello, world/`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backspace\",\n\t\t\tinput:    \"h\\bello, world\",\n\t\t\texpected: \"h\\bello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape form feed\",\n\t\t\tinput:    \"h\\fello, world\",\n\t\t\texpected: \"h\\fello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape newline\",\n\t\t\tinput:    \"h\\nello, world\",\n\t\t\texpected: \"h\\nello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape carriage return\",\n\t\t\tinput:    \"h\\rello, world\",\n\t\t\texpected: \"h\\rello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape tab\",\n\t\t\tinput:    \"h\\tello, world\",\n\t\t\texpected: \"h\\tello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Unicode\",\n\t\t\tinput:    \"\\\\u0041\\\\u0042\\\\u0043\",\n\t\t\texpected: \"ABC\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Surrogate Pair\",\n\t\t\tinput:    \"\\\\ud83d\\\\ude00\",\n\t\t\texpected: \"ðŸ˜€\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid Escape Sequence\",\n\t\t\tinput:    \"\\\\uABCD\",\n\t\t\texpected: \"\\\\uABCD\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "26e7b14d9c8c2b77c7f3fa7a3edd517c": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"too deep\",\n\t\t\tinput:    \"{}\", // depth exceeds MaxDepth\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t},\n\t\t{\n\t\t\tname:     \"valid object\",\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: &Value{t: typeRawString, s: \"value\"}}}}},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t}},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{t: typeRawString, s: \"hello\"},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid true\",\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid false\",\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid null\",\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"42\",\n\t\t\texpected: &Value{t: TypeNumber, s: \"42\"},\n\t\t\terr:      nil,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tv, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, expected %v\", tc.input, err, tc.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else if tc.err != nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = nil, expected %v\", tc.input, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !compareValues(v, tc.expected) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, expected %v\", tc.input, v, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn compareObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn compareArrays(v1.a, v2.a)\n\tcase typeRawString, TypeNumber, TypeTrue, TypeFalse, TypeNull:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc compareObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc compareArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tif !compareValues(v1, a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "2806f695f214a4e8dff15db27c43a129": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: \"{}\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with one key-value pair\",\n\t\t\tinput: `{\"key\":\"value\"}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with multiple key-value pairs\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":123,\"key3\":true}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\tinput: `{\"key\":\"value\"`,\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing colon\",\n\t\t\tinput: `{\"key\" \"value\"}`,\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing comma\",\n\t\t\tinput: `{\"key1\":\"value1\" \"key2\":123}`,\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tactual, _, err := parseObject(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif tc.err != nil {\n\t\t\t\tt.Errorf(\"expected error %v, got nil\", tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tc.expected, actual)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn compareObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn compareArrays(v1.a, v2.a)\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber, TypeTrue, TypeFalse:\n\t\treturn v1.s == v2.s\n\tcase TypeNull:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc compareObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc compareArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tv2 := a2[i]\n\t\tif !compareValues(v1, v2) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "2ac68ec39b10b3df95bc31cb624004c3": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"empty array\",\n\t\t\tinput:    \"[]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with one value\",\n\t\t\tinput:    \"[1]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with multiple values\",\n\t\t\tinput:    \"[1,2,3]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}, &Value{t: TypeNumber, s: \"2\"}, &Value{t: TypeNumber, s: \"3\"}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with missing closing bracket\",\n\t\t\tinput:    \"[1,2,3\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with missing comma\",\n\t\t\tinput:    \"[1 2]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tactual, _, err := parseArray(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseArray(%q) error = %v, expected error: %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, expected %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeArray:\n\t\ta1, _ := v1.Array()\n\t\ta2, _ := v2.Array()\n\t\tif len(a1) != len(a2) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range a1 {\n\t\t\tif !compareValues(a1[i], a2[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeObject:\n\t\to1, _ := v1.Object()\n\t\to2, _ := v2.Object()\n\t\tif o1.Len() != o2.Len() {\n\t\t\treturn false\n\t\t}\n\t\tvar visited = make(map[string]bool)\n\t\to1.Visit(func(key []byte, v *Value) {\n\t\t\tvisited[string(key)] = true\n\t\t\tv1, _ := o1.Get(string(key))\n\t\t\tv2 := o2.Get(string(key))\n\t\t\tif !compareValues(v1, v2) {\n\t\t\t\treturn\n\t\t\t}\n\t\t})\n\t\to2.Visit(func(key []byte, v *Value) {\n\t\t\tif !visited[string(key)] {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tv1, _ := o1.Get(string(key))\n\t\t\tv2 := o2.Get(string(key))\n\t\t\tif !compareValues(v1, v2) {\n\t\t\t\treturn\n\t\t\t}\n\t\t})\n\t\treturn true\n\tcase TypeString, TypeNumber, TypeTrue, TypeFalse, TypeNull:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\tpanic(\"unknown type\")\n\t}\n}",
    "2d5f2487d64d711a19307d18f38dabf3": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantNum  string\n\t\twantRest string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.456e+78\",\n\t\t\twantNum:  \"123.456e+78\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with trailing non-numeric\",\n\t\t\tinput:    \"123.456abc\",\n\t\t\twantNum:  \"123.456\",\n\t\t\twantRest: \"abc\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number\",\n\t\t\tinput:    \"abc123\",\n\t\t\twantNum:  \"\",\n\t\t\twantRest: \"abc123\",\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"inf\",\n\t\t\tinput:    \"inf\",\n\t\t\twantNum:  \"inf\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"nan\",\n\t\t\tinput:    \"nan\",\n\t\t\twantNum:  \"nan\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.wantNum {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) num = %q, want %q\", tc.input, num, tc.wantNum)\n\t\t\t}\n\t\t\tif rest != tc.wantRest {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) rest = %q, want %q\", tc.input, rest, tc.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2ceadea7d3d22fb61a883ee6a8978095": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.45e+6\",\n\t\t\texpected: []string{\"123.45e+6\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with leading zeros\",\n\t\t\tinput:    \"0123.45\",\n\t\t\texpected: []string{\"0123.45\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with sign\",\n\t\t\tinput:    \"-123.45\",\n\t\t\texpected: []string{\"-123.45\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with exponent\",\n\t\t\tinput:    \"1.2e-3\",\n\t\t\texpected: []string{\"1.2e-3\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number\",\n\t\t\tinput:    \"abc123\",\n\t\t\texpected: []string{\"\", \"bc123\"},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty input\",\n\t\t\tinput:    \"\",\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"inf\",\n\t\t\tinput:    \"inf\",\n\t\t\texpected: []string{\"inf\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"nan\",\n\t\t\tinput:    \"nan\",\n\t\t\texpected: []string{\"nan\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.expected[0] || rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = (%q, %q), want (%q, %q)\", tc.input, num, rest, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "2cc3b709604c5951ce3e82ebc9f8d8ad": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: \"{}\",\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           []kv{},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with one key-value pair\",\n\t\t\tinput: `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with multiple key-value pairs\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":123,\"key3\":true}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\tinput: `{\"key1\":\"value1\",`,\n\t\t\terr:   true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tv, _, err := parseObject(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !v.Equal(tc.expected) {\n\t\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", tc.input, v, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2df992bd75b18193a3fe156e4b85d482": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.456e+7\",\n\t\t\texpected: []string{\"123.456e+7\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with leading zeros\",\n\t\t\tinput:    \"0123.456\",\n\t\t\texpected: []string{\"0123.456\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with sign\",\n\t\t\tinput:    \"-123.456\",\n\t\t\texpected: []string{\"-123.456\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with exponent\",\n\t\t\tinput:    \"1.2e-3\",\n\t\t\texpected: []string{\"1.2e-3\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with exponent and sign\",\n\t\t\tinput:    \"-1.2e+3\",\n\t\t\texpected: []string{\"-1.2e+3\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number\",\n\t\t\tinput:    \"123.456abc\",\n\t\t\texpected: []string{\"\", \"abc\"},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"inf\",\n\t\t\tinput:    \"inf\",\n\t\t\texpected: []string{\"inf\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"nan\",\n\t\t\tinput:    \"nan\",\n\t\t\texpected: []string{\"nan\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.expected[0] || rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, %q, want %q, %q\", tc.input, num, rest, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "2d6e38d353e304097ec83f3d45819f1d": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: \"{}\",\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           []kv{},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"simple object\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with whitespace\",\n\t\t\tinput: `{ \"key1\" : \"value1\" , \"key2\" : 42 }`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42`,\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing key\",\n\t\t\tinput: `{:42}`,\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing value\",\n\t\t\tinput: `{\"key1\":}`,\n\t\t\terr:   true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tv, _, err := parseObject(tt.input, c, 0)\n\t\t\tif (err != nil) != tt.err {\n\t\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", tt.input, err, tt.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.err && !v.Equal(tt.expected) {\n\t\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", tt.input, v, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2f909e3670e0008a815b20c6f7e8a3a7": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: []string{\"hello\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello\\\"world\"`,\n\t\t\texpected: []string{\"hello\\\"world\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello\\\"world\\\"foo\"`,\n\t\t\texpected: []string{\"hello\\\"world\\\"foo\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with no closing quote\",\n\t\t\tinput:    `\"hello`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot, rest, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tc.expected[0] || rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = %q, %q, want %q, %q\", tc.input, got, rest, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "2fa92d72de8793804a62897e8d2d73f2": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestTypeString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    Type\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"TypeObject\",\n\t\t\tinput:    TypeObject,\n\t\t\texpected: \"object\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeArray\",\n\t\t\tinput:    TypeArray,\n\t\t\texpected: \"array\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeString\",\n\t\t\tinput:    TypeString,\n\t\t\texpected: \"string\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeNumber\",\n\t\t\tinput:    TypeNumber,\n\t\t\texpected: \"number\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeTrue\",\n\t\t\tinput:    TypeTrue,\n\t\t\texpected: \"true\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeFalse\",\n\t\t\tinput:    TypeFalse,\n\t\t\texpected: \"false\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeNull\",\n\t\t\tinput:    TypeNull,\n\t\t\texpected: \"null\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Unknown Type\",\n\t\t\tinput:    Type(100),\n\t\t\texpected: \"BUG: unknown Value type: 100\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := tc.input.String()\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"expected %q, got %q\", tc.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2e1e87a1802ab10a8d0fff9413ec247c": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape double quote\",\n\t\t\tinput:    \"\\\"hello, world\\\"\",\n\t\t\texpected: `\"hello, world\"`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backslash\",\n\t\t\tinput:    \"\\\\hello, world\\\\\",\n\t\t\texpected: `\\hello, world\\`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape forward slash\",\n\t\t\tinput:    \"/hello, world/\",\n\t\t\texpected: `/hello, world/`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backspace\",\n\t\t\tinput:    \"h\\bello, world\",\n\t\t\texpected: \"h\\bello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape form feed\",\n\t\t\tinput:    \"h\\fello, world\",\n\t\t\texpected: \"h\\fello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape newline\",\n\t\t\tinput:    \"h\\nello, world\",\n\t\t\texpected: \"h\\nello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape carriage return\",\n\t\t\tinput:    \"h\\rello, world\",\n\t\t\texpected: \"h\\rello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape tab\",\n\t\t\tinput:    \"h\\tello, world\",\n\t\t\texpected: \"h\\tello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Unicode\",\n\t\t\tinput:    \"\\\\u0041\\\\u0042\\\\u0043\",\n\t\t\texpected: \"ABC\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape invalid Unicode\",\n\t\t\tinput:    \"\\\\u004G\",\n\t\t\texpected: \"\\\\u004G\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape surrogate pair\",\n\t\t\tinput:    \"\\\\uD83D\\\\uDE00\",\n\t\t\texpected: \"ðŸ˜€\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape invalid surrogate pair\",\n\t\t\tinput:    \"\\\\uD83D\",\n\t\t\texpected: \"\\\\uD83D\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2cbc97769b8869a07f477d36c29e51d9": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"too big depth\",\n\t\t\tinput:    \"{}\", // Assuming MaxDepth is 1\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds 1\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"valid object\",\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{\n\t\t\t\t\t\t\tt: typeRawString,\n\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid true\",\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid false\",\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid null\",\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"42\",\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42\",\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, expected %v\", tc.input, err, tc.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else if tc.err != nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = nil, expected %v\", tc.input, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, expected %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\to1, _ := v1.Object()\n\t\to2, _ := v2.Object()\n\t\treturn compareObjects(o1, o2)\n\tcase TypeArray:\n\t\ta1, _ := v1.Array()\n\t\ta2, _ := v2.Array()\n\t\tif len(a1) != len(a2) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range a1 {\n\t\t\tif !compareValues(a1[i], a2[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase typeRawString, TypeNumber, TypeTrue, TypeFalse, TypeNull:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc compareObjects(o1, o2 *Object) bool {\n\tif o1 == nil && o2 == nil {\n\t\treturn true\n\t}\n\tif o1 == nil || o2 == nil {\n\t\treturn false\n\t}\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i := range o1.kvs {\n\t\tif o1.kvs[i].k != o2.kvs[i].k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(o1.kvs[i].v, o2.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "2fb0fc2eb32e058ac2dd842299b25569": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGet(t *testing.T) {\n\t// Test cases\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    *Value\n\t\tkeys     []string\n\t\texpected *Value\n\t}{\n\t\t{\n\t\t\tname: \"Existing key in object\",\n\t\t\tinput: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: &Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"key2\"},\n\t\t\texpected: &Value{t: TypeNumber, s: \"42\"},\n\t\t},\n\t\t{\n\t\t\tname: \"Non-existing key in object\",\n\t\t\tinput: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: &Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"key3\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Existing index in array\",\n\t\t\tinput: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"value1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"1\"},\n\t\t\texpected: &Value{t: TypeNumber, s: \"42\"},\n\t\t},\n\t\t{\n\t\t\tname: \"Non-existing index in array\",\n\t\t\tinput: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"value1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"2\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Nil input\",\n\t\t\tinput:    nil,\n\t\t\tkeys:     []string{\"key1\"},\n\t\t\texpected: nil,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := tc.input.Get(tc.keys...)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"Get(%v) = %v, expected %v\", tc.keys, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2ff1850ae86de1ccc21484979242f638": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: []string{\"hello\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello\\\"world\"`,\n\t\t\texpected: []string{\"hello\\\"world\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello\\\"world\\\"foo\"`,\n\t\t\texpected: []string{\"hello\\\"world\\\"foo\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with no closing quote\",\n\t\t\tinput:    `\"hello`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot1, got2, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got1 != tc.expected[0] || got2 != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = (%q, %q), want (%q, %q)\", tc.input, got1, got2, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "303ad9d4dc410347d2cbd3bf7c648fec": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_getKV(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\to    *Object\n\t\twant *kv\n\t}{\n\t\t{\n\t\t\tname: \"empty kvs\",\n\t\t\to:    &Object{kvs: []kv{}},\n\t\t\twant: &kv{},\n\t\t},\n\t\t{\n\t\t\tname: \"kvs with capacity\",\n\t\t\to:    &Object{kvs: make([]kv, 1, 2)},\n\t\t\twant: &kv{},\n\t\t},\n\t\t{\n\t\t\tname: \"kvs with length equal to capacity\",\n\t\t\to:    &Object{kvs: make([]kv, 2, 2)},\n\t\t\twant: &kv{},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.o.getKV(); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Object.getKV() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2ff24b4095c848855256487499af5870": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGet(t *testing.T) {\n\t// Test cases\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    *Value\n\t\tkeys     []string\n\t\texpected *Value\n\t}{\n\t\t{\n\t\t\tname: \"Existing keys\",\n\t\t\tinput: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{a: []*Value{\n\t\t\t\t\t\t\t{s: \"arr1\"}, {s: \"arr2\"},\n\t\t\t\t\t\t}}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"key1\"},\n\t\t\texpected: &Value{s: \"value1\"},\n\t\t},\n\t\t{\n\t\t\tname: \"Non-existing keys\",\n\t\t\tinput: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{s: \"value1\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"key2\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Array index\",\n\t\t\tinput: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"arr1\"}, {s: \"arr2\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"1\"},\n\t\t\texpected: &Value{s: \"arr2\"},\n\t\t},\n\t\t{\n\t\t\tname:     \"Nil input\",\n\t\t\tinput:    nil,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: nil,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := tc.input.Get(tc.keys...)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"Get(%v) = %v, expected %v\", tc.keys, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "303b207c74ac5ea4ce5afbb436c3bd7f": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestTypeString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    Type\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"TypeObject\",\n\t\t\tinput:    TypeObject,\n\t\t\texpected: \"object\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeArray\",\n\t\t\tinput:    TypeArray,\n\t\t\texpected: \"array\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeString\",\n\t\t\tinput:    TypeString,\n\t\t\texpected: \"string\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeNumber\",\n\t\t\tinput:    TypeNumber,\n\t\t\texpected: \"number\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeTrue\",\n\t\t\tinput:    TypeTrue,\n\t\t\texpected: \"true\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeFalse\",\n\t\t\tinput:    TypeFalse,\n\t\t\texpected: \"false\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeNull\",\n\t\t\tinput:    TypeNull,\n\t\t\texpected: \"null\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Unknown Type\",\n\t\t\tinput:    Type(100),\n\t\t\texpected: \"BUG: unknown Value type: 100\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := tc.input.String()\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"expected %q, got %q\", tc.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2ff422ba8ebbc2fbda9512c1f666199b": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGet(t *testing.T) {\n\t// Test cases\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    *Value\n\t\tkeys     []string\n\t\texpected *Value\n\t}{\n\t\t{\n\t\t\tname: \"Get from object\",\n\t\t\tinput: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: &Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"key1\"},\n\t\t\texpected: &Value{t: TypeString, s: \"value1\"},\n\t\t},\n\t\t{\n\t\t\tname: \"Get from array\",\n\t\t\tinput: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"value1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"1\"},\n\t\t\texpected: &Value{t: TypeNumber, s: \"42\"},\n\t\t},\n\t\t{\n\t\t\tname:     \"Get from nil\",\n\t\t\tinput:    nil,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Get non-existing key\",\n\t\t\tinput: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: &Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"key2\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Get non-integer index from array\",\n\t\t\tinput: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"value1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"a\"},\n\t\t\texpected: nil,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := tc.input.Get(tc.keys...)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"Get(%v) = %v, expected %v\", tc.keys, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "30a6bbea29b047461f96d6422567f1ed": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetInt(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    *Value\n\t\tkeys     []string\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"valid int\",\n\t\t\tinput:    &Value{s: \"42\", t: TypeNumber},\n\t\t\tkeys:     []string{},\n\t\t\texpected: 42,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid type\",\n\t\t\tinput:    &Value{s: \"true\", t: TypeTrue},\n\t\t\tkeys:     []string{},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"non-existing keys\",\n\t\t\tinput:    &Value{s: \"42\", t: TypeNumber},\n\t\t\tkeys:     []string{\"foo\", \"bar\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"int overflow\",\n\t\t\tinput:    &Value{s: \"9223372036854775807\", t: TypeNumber},\n\t\t\tkeys:     []string{},\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := tc.input.GetInt(tc.keys...)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"GetInt(%v) = %d, expected %d\", tc.keys, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "3081f2b7867988b78d42025b66c8cccd": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t\trest     string\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.456e+7\",\n\t\t\texpected: \"123.456e+7\",\n\t\t\trest:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with leading sign\",\n\t\t\tinput:    \"-123.456e+7\",\n\t\t\texpected: \"-123.456e+7\",\n\t\t\trest:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with trailing non-digit\",\n\t\t\tinput:    \"123.456e+7x\",\n\t\t\texpected: \"123.456e+7\",\n\t\t\trest:     \"x\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty input\",\n\t\t\tinput:    \"\",\n\t\t\texpected: \"\",\n\t\t\trest:     \"\",\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"input with only non-digit\",\n\t\t\tinput:    \"abc\",\n\t\t\texpected: \"\",\n\t\t\trest:     \"abc\",\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, want error: %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.expected {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, want %q\", tc.input, num, tc.expected)\n\t\t\t}\n\t\t\tif rest != tc.rest {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) rest = %q, want %q\", tc.input, rest, tc.rest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2e2c86f97ac7952a6d612a1dfbcc2116": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty input\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"depth exceeds MaxDepth\",\n\t\t\tinput:    \"{}\", // Assuming MaxDepth is 1\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t},\n\t\t{\n\t\t\tname:     \"valid object\",\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{s: \"value\", t: typeRawString}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"1\", t: TypeNumber},\n\t\t\t\t\t{s: \"2\", t: TypeNumber},\n\t\t\t\t\t{s: \"3\", t: TypeNumber},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{\n\t\t\t\ts: \"hello\",\n\t\t\t\tt: typeRawString,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid true\",\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid false\",\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid null\",\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"42\",\n\t\t\texpected: &Value{\n\t\t\t\ts: \"42\",\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid value\",\n\t\t\tinput:    \"invalid\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"unexpected value found: %q\", \"invalid\"),\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tv, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, expected %v\", tc.input, err, tc.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else if tc.err != nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = nil, expected %v\", tc.input, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !compareValues(v, tc.expected) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, expected %v\", tc.input, v, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn compareObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn compareArrays(v1.a, v2.a)\n\tcase typeRawString, TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber, TypeTrue, TypeFalse, TypeNull:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc compareObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc compareArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tif !compareValues(v1, a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "3054603d186f99fd6bc0c1c19a1e5682": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"hello world\",\n\t\t\texpected: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape double quote\",\n\t\t\tinput:    \"\\\"hello\\\" world\",\n\t\t\texpected: `\"hello\" world`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backslash\",\n\t\t\tinput:    \"hello\\\\world\",\n\t\t\texpected: `hello\\world`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape forward slash\",\n\t\t\tinput:    \"hello/world\",\n\t\t\texpected: `hello/world`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backspace\",\n\t\t\tinput:    \"hello\\bworld\",\n\t\t\texpected: `hello\\bworld`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape form feed\",\n\t\t\tinput:    \"hello\\fworld\",\n\t\t\texpected: `hello\\fworld`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape newline\",\n\t\t\tinput:    \"hello\\nworld\",\n\t\t\texpected: `hello\\nworld`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape carriage return\",\n\t\t\tinput:    \"hello\\rworld\",\n\t\t\texpected: `hello\\rworld`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape tab\",\n\t\t\tinput:    \"hello\\tworld\",\n\t\t\texpected: `hello\\tworld`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Unicode character\",\n\t\t\tinput:    \"hello\\u0123world\",\n\t\t\texpected: `hello\\u0123world`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape surrogate pair\",\n\t\t\tinput:    \"hello\\uD834\\uDD1Eworld\",\n\t\t\texpected: `hello\\uD834\\uDD1Eworld`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Incomplete escape sequence\",\n\t\t\tinput:    \"hello\\u0123\",\n\t\t\texpected: `hello\\u0123`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid escape sequence\",\n\t\t\tinput:    \"hello\\u123Xworld\",\n\t\t\texpected: `hello\\u123Xworld`,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "33bbc286c9451caee7ebaaf46dcc21c3": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObjectReset(t *testing.T) {\n\t// Create a new Object\n\to := &Object{\n\t\tkvs: []kv{\n\t\t\t{k: \"key1\", v: &Value{}},\n\t\t\t{k: \"key2\", v: &Value{}},\n\t\t},\n\t\tkeysUnescaped: true,\n\t}\n\n\t// Call the reset function\n\to.reset()\n\n\t// Verify the expected state of the Object\n\tif len(o.kvs) != 1 {\n\t\tt.Errorf(\"expected 1 kv pair, got %d\", len(o.kvs))\n\t}\n\tif o.keysUnescaped {\n\t\tt.Error(\"expected keysUnescaped to be false, got true\")\n\t}\n}",
    "2fe3ae84a715a014fd4df63781c671e4": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"too big depth\",\n\t\t\tinput:    \"{}\", // Assuming MaxDepth is 1\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds 1\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"valid object\",\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{s: \"value\", t: typeRawString}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"1\", t: TypeNumber},\n\t\t\t\t\t{s: \"2\", t: TypeNumber},\n\t\t\t\t\t{s: \"3\", t: TypeNumber},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{s: \"hello\", t: typeRawString},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid true\",\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid false\",\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid null\",\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"42\",\n\t\t\texpected: &Value{s: \"42\", t: TypeNumber},\n\t\t\terr:      nil,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, expected %v\", tc.input, err, tc.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else if tc.err != nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = nil, expected %v\", tc.input, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, expected %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn compareObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn compareArrays(v1.a, v2.a)\n\tcase typeRawString, TypeNumber, TypeTrue, TypeFalse:\n\t\treturn v1.s == v2.s\n\tcase TypeNull:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc compareObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc compareArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tif !compareValues(v1, a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "333e884dc25e2d7b7f3d4f1c2e529dc0": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: []string{\"hello\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello\\\"world\"`,\n\t\t\texpected: []string{\"hello\\\"world\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello\\\"world\\\"foo\"`,\n\t\t\texpected: []string{\"hello\\\"world\\\"foo\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with no closing quote\",\n\t\t\tinput:    `\"hello`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    `\"\"`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult, rest, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif result != tc.expected[0] {\n\t\t\t\tt.Errorf(\"parseRawString(%q) result = %v, expected %v\", tc.input, result, tc.expected[0])\n\t\t\t}\n\t\t\tif rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawString(%q) rest = %v, expected %v\", tc.input, rest, tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "31708e9592fc730726c6da06f0a4e763": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tjson     string\n\t\tkeys     []string\n\t\texpected *Object\n\t\tisNil    bool\n\t}{\n\t\t{\n\t\t\tname: \"valid object\",\n\t\t\tjson: `{\"key1\": \"value1\", \"key2\": 123}`,\n\t\t\tkeys: []string{\"key1\", \"key2\"},\n\t\t\texpected: &Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"key1\", v: &Value{s: \"value1\", t: TypeString}},\n\t\t\t\t\t{k: \"key2\", v: &Value{s: \"123\", t: TypeNumber}},\n\t\t\t\t},\n\t\t\t\tkeysUnescaped: true,\n\t\t\t},\n\t\t\tisNil: false,\n\t\t},\n\t\t{\n\t\t\tname: \"non-existing key\",\n\t\t\tjson: `{\"key1\": \"value1\", \"key2\": 123}`,\n\t\t\tkeys: []string{\"key3\"},\n\t\t\texpected: nil,\n\t\t\tisNil:    true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid type\",\n\t\t\tjson: `{\"key1\": \"value1\", \"key2\": 123}`,\n\t\t\tkeys: []string{\"key1\", \"key2\", \"0\"},\n\t\t\texpected: nil,\n\t\t\tisNil:    true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tv, err := Parse(tc.json)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tobj := v.GetObject(tc.keys...)\n\t\t\tif tc.isNil {\n\t\t\t\tif obj != nil {\n\t\t\t\t\tt.Errorf(\"expected nil, got %v\", obj)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif obj == nil {\n\t\t\t\t\tt.Errorf(\"expected non-nil object, got nil\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tif !objectsEqual(obj, tc.expected) {\n\t\t\t\t\tt.Errorf(\"expected %v, got %v\", tc.expected, obj)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc objectsEqual(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !valuesEqual(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn o1.keysUnescaped == o2.keysUnescaped\n}\n\nfunc valuesEqual(v1, v2 *Value) bool {\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\n\tswitch v1.t {\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeObject:\n\t\treturn objectsEqual(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\ta1, _ := v1.Array()\n\t\ta2, _ := v2.Array()\n\t\tif len(a1) != len(a2) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, v := range a1 {\n\t\t\tif !valuesEqual(v, a2[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeTrue, TypeFalse, TypeNull:\n\t\treturn true\n\tdefault:\n\t\tpanic(\"unsupported type\")\n\t}\n}",
    "34b7165e20b8f325f1cd12eb03dfd9f7": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestInt(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    *Value\n\t\texpected int\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"valid integer\",\n\t\t\tinput:    &Value{s: \"42\", t: TypeNumber},\n\t\t\texpected: 42,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"non-number type\",\n\t\t\tinput:    &Value{s: \"true\", t: TypeTrue},\n\t\t\texpected: 0,\n\t\t\terr:      fmt.Errorf(\"value doesn't contain number; it contains true\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"integer overflow\",\n\t\t\tinput:    &Value{s: \"9223372036854775808\", t: TypeNumber},\n\t\t\texpected: 0,\n\t\t\terr:      fmt.Errorf(\"number \\\"9223372036854775808\\\" doesn't fit int\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number\",\n\t\t\tinput:    &Value{s: \"not a number\", t: TypeNumber},\n\t\t\texpected: 1,\n\t\t\terr:      fmt.Errorf(\"invalid syntax\"),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, err := tc.input.Int()\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t\t}\n\t\t\t} else if actual != tc.expected {\n\t\t\t\tt.Errorf(\"expected %d, got %d\", tc.expected, actual)\n\t\t\t}\n\t\t})\n\t}\n}",
    "387bddf6b1481bddeded9525ddd43a5d": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"no escape characters\",\n\t\t\tinput:    \"hello world\",\n\t\t\texpected: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"simple escape characters\",\n\t\t\tinput:    \"hello\\\\\\\"world\\\\\\\\\",\n\t\t\texpected: \"hello\\\"world\\\\\",\n\t\t},\n\t\t{\n\t\t\tname:     \"complex escape characters\",\n\t\t\tinput:    \"hello\\\\u0000world\\\\u1234\\\\u{10000}\",\n\t\t\texpected: \"hello\\x00world\\u1234\\U00010000\",\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid escape characters\",\n\t\t\tinput:    \"hello\\\\uworld\\\\u123\",\n\t\t\texpected: \"hello\\\\uworld\\\\u123\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "36b8bc01cb6a97aac3ef6a838c4f1a2d": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"no escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"simple escape characters\",\n\t\t\tinput:    \"hello\\\\\\\"world\\\\\\\\\",\n\t\t\texpected: \"hello\\\"world\\\\\",\n\t\t},\n\t\t{\n\t\t\tname:     \"complex escape characters\",\n\t\t\tinput:    \"hello\\\\u0041\\\\u0042\\\\u0043world\",\n\t\t\texpected: \"helloABCworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid escape sequence\",\n\t\t\tinput:    \"hello\\\\u0041\\\\u004\",\n\t\t\texpected: \"hello\\\\u0041\\\\u004\",\n\t\t},\n\t\t{\n\t\t\tname:     \"surrogate pair\",\n\t\t\tinput:    \"hello\\\\ud83d\\\\ude00world\",\n\t\t\texpected: \"helloðŸ˜€world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid surrogate pair\",\n\t\t\tinput:    \"hello\\\\ud83d\\\\u0041world\",\n\t\t\texpected: \"hello\\\\ud83d\\\\u0041world\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "352054701a05c0ea76f056039ee028d9": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape double quote\",\n\t\t\tinput:    \"\\\"hello, world\\\"\",\n\t\t\texpected: `\"hello, world\"`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backslash\",\n\t\t\tinput:    \"\\\\hello, world\\\\\",\n\t\t\texpected: `\\hello, world\\`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape forward slash\",\n\t\t\tinput:    \"/hello, world/\",\n\t\t\texpected: `/hello, world/`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backspace\",\n\t\t\tinput:    \"h\\bello, world\",\n\t\t\texpected: \"h\\bello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape form feed\",\n\t\t\tinput:    \"h\\fello, world\",\n\t\t\texpected: \"h\\fello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape newline\",\n\t\t\tinput:    \"h\\nello, world\",\n\t\t\texpected: \"h\\nello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape carriage return\",\n\t\t\tinput:    \"h\\rello, world\",\n\t\t\texpected: \"h\\rello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape tab\",\n\t\t\tinput:    \"h\\tello, world\",\n\t\t\texpected: \"h\\tello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Unicode character\",\n\t\t\tinput:    \"\\\\u0041hello, world\",\n\t\t\texpected: \"Ahello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape invalid Unicode character\",\n\t\t\tinput:    \"\\\\u004\",\n\t\t\texpected: \"\\\\u004\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape surrogate pair\",\n\t\t\tinput:    \"\\\\ud83d\\\\ude00hello, world\",\n\t\t\texpected: \"ðŸ˜€hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape unknown character\",\n\t\t\tinput:    \"\\\\xhello, world\",\n\t\t\texpected: \"\\\\xhello, world\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "3a398eada6bb87a5c52c84d718887602": "package fastjson_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/valyala/fastjson\"\n)\n\nfunc TestValue_Object(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tv       *fastjson.Value\n\t\twant    *fastjson.Object\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"valid object\",\n\t\t\tv: &fastjson.Value{\n\t\t\t\tt: fastjson.TypeObject,\n\t\t\t\to: fastjson.Object{\n\t\t\t\t\tkvs: []fastjson.kv{\n\t\t\t\t\t\t{k: \"key1\", v: &fastjson.Value{t: fastjson.TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &fastjson.Value{t: fastjson.TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant:    &fastjson.Value{t: fastjson.TypeObject, o: fastjson.Object{kvs: []fastjson.kv{}}}.o,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"non-object type\",\n\t\t\tv: &fastjson.Value{\n\t\t\t\tt: fastjson.TypeString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := tt.v.Object()\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Value.Object() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.Object() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "39322df48baace138a017c3d3bc1d3b5": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestGetArray(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tvalue *Value\n\t\tkeys  []string\n\t\twant  []*Value\n\t}{\n\t\t{\n\t\t\tname: \"valid array\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"foo\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t\t{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{t: TypeString, s: \"value\"}},\n\t\t\t\t\t}}},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys: []string{},\n\t\t\twant: []*Value{\n\t\t\t\t{t: TypeString, s: \"foo\"},\n\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t\t{k: \"key\", v: &Value{t: TypeString, s: \"value\"}},\n\t\t\t\t}}},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"non-existing keys path\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"foo\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys: []string{\"non\", \"existing\"},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid value type\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{kvs: []kv{\n\t\t\t\t\t{k: \"key\", v: &Value{t: TypeString, s: \"value\"}},\n\t\t\t\t}},\n\t\t\t},\n\t\t\tkeys: []string{\"key\"},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"nil value\",\n\t\t\tvalue: nil,\n\t\t\tkeys:  []string{},\n\t\t\twant:  nil,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.value.GetArray(tt.keys...)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"GetArray(%v) = %v, want %v\", tt.keys, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "3a0ad62efe4f25d6536920f0034c4190": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape double quote\",\n\t\t\tinput:    \"\\\"hello, world\\\"\",\n\t\t\texpected: `\"hello, world\"`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backslash\",\n\t\t\tinput:    \"\\\\hello, world\\\\\",\n\t\t\texpected: `\\hello, world\\`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape forward slash\",\n\t\t\tinput:    \"/hello, world/\",\n\t\t\texpected: `/hello, world/`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backspace\",\n\t\t\tinput:    \"h\\bello, world\",\n\t\t\texpected: \"h\\bello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape form feed\",\n\t\t\tinput:    \"h\\fello, world\",\n\t\t\texpected: \"h\\fello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape newline\",\n\t\t\tinput:    \"h\\nello, world\",\n\t\t\texpected: \"h\\nello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape carriage return\",\n\t\t\tinput:    \"h\\rello, world\",\n\t\t\texpected: \"h\\rello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape tab\",\n\t\t\tinput:    \"h\\tello, world\",\n\t\t\texpected: \"h\\tello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Unicode character\",\n\t\t\tinput:    \"\\\\u00A9 hello, world\",\n\t\t\texpected: \"Â© hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape invalid Unicode character\",\n\t\t\tinput:    \"\\\\u00Xg hello, world\",\n\t\t\texpected: \"\\\\u00Xg hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape surrogate pair\",\n\t\t\tinput:    \"\\\\uD83D\\\\uDE00 hello, world\",\n\t\t\texpected: \"ðŸ˜€ hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape unknown character\",\n\t\t\tinput:    \"\\\\z hello, world\",\n\t\t\texpected: \"\\\\z hello, world\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "3c5d58b5438759a28be54d5c21c2f82c": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestArray(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tv       *Value\n\t\twant    []*Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"valid array\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"foo\"},\n\t\t\t\t\t{s: \"bar\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant:    []*Value{{s: \"foo\"}, {s: \"bar\"}},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"non-array type\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"foo\",\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := tt.v.Array()\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Value.Array() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.Array() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "3aaf7a1aae8189f0ac66ba79a7f3d3ae": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":\"value1\",\"key2\":42}`),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"str1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`[\"str1\",42,true]`),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\\\"world\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello\\\"world\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"3.14\",\n\t\t\t},\n\t\t\twant: []byte(\"3.14\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %q, want %q\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "3c43fd358c0d29f9399e5e3093638908": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWS(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"string with no whitespace\",\n\t\t\tinput:    \"hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"string with leading whitespace\",\n\t\t\tinput:    \"   hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"string with trailing whitespace\",\n\t\t\tinput:    \"hello   \",\n\t\t\texpected: \"hello   \",\n\t\t},\n\t\t{\n\t\t\tname:     \"string with leading and trailing whitespace\",\n\t\t\tinput:    \"   hello   \",\n\t\t\texpected: \"hello   \",\n\t\t},\n\t\t{\n\t\t\tname:     \"string with mixed whitespace\",\n\t\t\tinput:    \"   hello\\t world\\n\",\n\t\t\texpected: \"hello\\t world\\n\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := skipWS(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"skipWS(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "3b184aa717383a10e0642287c3ad0201": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty array\",\n\t\t\tinput: \"[]\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with values\",\n\t\t\tinput: \"[1, 2, 3]\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv1 := &Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"1\",\n\t\t\t\t}\n\t\t\t\tv2 := &Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"2\",\n\t\t\t\t}\n\t\t\t\tv3 := &Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"3\",\n\t\t\t\t}\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{v1, v2, v3},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with missing comma\",\n\t\t\tinput: \"[1 2, 3]\",\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with unexpected end\",\n\t\t\tinput: \"[1, 2\",\n\t\t\terr:   true,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tv, _, err := parseArray(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseArray(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tc.err && !v.Equal(tc.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", tc.input, v, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "34e720be16f6ed3adf8118013d3b1dfe": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: \"{}\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs:           []kv{},\n\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with one key-value pair\",\n\t\t\tinput: `{\"key\":\"value\"}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with multiple key-value pairs\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":123,\"key3\":true}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":123`,\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"missing '}'\"\"),\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, _, err := parseObject(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseObject(%q) error = %v, expected %v\", tc.input, err, tc.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\t\tt.Errorf(\"parseObject(%q) = %v, expected %v\", tc.input, actual, tc.expected)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn compareObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn compareArrays(v1.a, v2.a)\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber, TypeTrue, TypeFalse:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\treturn true\n\t}\n}\n\nfunc compareObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc compareArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tif !compareValues(v1, a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "3d1a0785dcf3d2378895c989662c217c": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetInt(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tjson     string\n\t\tkeys     []string\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"Existing key with valid int value\",\n\t\t\tjson:     `{\"key1\": 42}`,\n\t\t\tkeys:     []string{\"key1\"},\n\t\t\texpected: 42,\n\t\t},\n\t\t{\n\t\t\tname:     \"Existing key with float value\",\n\t\t\tjson:     `{\"key1\": 3.14}`,\n\t\t\tkeys:     []string{\"key1\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Non-existing key\",\n\t\t\tjson:     `{\"key1\": 42}`,\n\t\t\tkeys:     []string{\"key2\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Array index key\",\n\t\t\tjson:     `{\"key1\": [10, 20, 30]}`,\n\t\t\tkeys:     []string{\"key1\", \"1\"},\n\t\t\texpected: 20,\n\t\t},\n\t\t{\n\t\t\tname:     \"Array index key with float\",\n\t\t\tjson:     `{\"key1\": [10, 20.5, 30]}`,\n\t\t\tkeys:     []string{\"key1\", \"1.0\"},\n\t\t\texpected: 20,\n\t\t},\n\t\t{\n\t\t\tname:     \"Array index key out of range\",\n\t\t\tjson:     `{\"key1\": [10, 20, 30]}`,\n\t\t\tkeys:     []string{\"key1\", \"3\"},\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tv, err := Parse(tc.json)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Failed to parse JSON: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tresult := v.GetInt(tc.keys...)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"GetInt(%v) = %d, expected %d\", tc.keys, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "3d6e3f3ce2b90894ed5585626a6d5265": "package fastjson\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n)\n\nfunc TestEscapeString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []byte\n\t}{\n\t\t{\n\t\t\tname:     \"No special characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: []byte(`\"hello, world\"`),\n\t\t},\n\t\t{\n\t\t\tname:     \"With special characters\",\n\t\t\tinput:    \"hello, \\\"world\\\"\",\n\t\t\texpected: []byte(`\"hello, \\\"world\\\"\"`),\n\t\t},\n\t\t{\n\t\t\tname:     \"Empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: []byte(`\"\"`),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdst := make([]byte, 0, len(tc.input)+2)\n\t\t\tresult := escapeString(dst, tc.input)\n\t\t\tif !bytes.Equal(result, tc.expected) {\n\t\t\t\tt.Errorf(\"escapeString(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "3f357661c008ff56cdc0f9cfad225fac": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestBool(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    *Value\n\t\texpected bool\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"true\",\n\t\t\tinput:    &Value{t: TypeTrue},\n\t\t\texpected: true,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"false\",\n\t\t\tinput:    &Value{t: TypeFalse},\n\t\t\texpected: false,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"null\",\n\t\t\tinput:    &Value{t: TypeNull},\n\t\t\texpected: false,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"string\",\n\t\t\tinput:    &Value{t: TypeString, s: \"hello\"},\n\t\t\texpected: false,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"number\",\n\t\t\tinput:    &Value{t: TypeNumber, s: \"42\"},\n\t\t\texpected: false,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"object\",\n\t\t\tinput:    &Value{t: TypeObject, o: Object{}},\n\t\t\texpected: false,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"array\",\n\t\t\tinput:    &Value{t: TypeArray, a: []*Value{}},\n\t\t\texpected: false,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, err := tc.input.Bool()\n\t\t\tif tc.err && err == nil {\n\t\t\t\tt.Errorf(\"expected error, got nil\")\n\t\t\t}\n\t\t\tif !tc.err && err != nil {\n\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t}\n\t\t\tif actual != tc.expected {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tc.expected, actual)\n\t\t\t}\n\t\t})\n\t}\n}",
    "40a195db240c45247c569f188288dc15": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: []string{\"hello\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello\\\"world\"`,\n\t\t\texpected: []string{\"hello\\\"world\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello\\\"world\\\"foo\"`,\n\t\t\texpected: []string{\"hello\\\"world\\\"foo\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with no closing quote\",\n\t\t\tinput:    `\"hello`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\ts, r, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif s != tc.expected[0] || r != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = %q, %q, want %q, %q\", tc.input, s, r, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "3f7572e75236edb893fcc23f31599964": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"no escape characters\",\n\t\t\tinput:    \"hello world\",\n\t\t\texpected: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"simple escape characters\",\n\t\t\tinput:    \"hello\\\\\\\"world\\\\\\\\\",\n\t\t\texpected: \"hello\\\"world\\\\\",\n\t\t},\n\t\t{\n\t\t\tname:     \"complex escape characters\",\n\t\t\tinput:    \"hello\\\\u0041\\\\u0042\\\\u0043world\",\n\t\t\texpected: \"helloABCworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"incomplete escape sequence\",\n\t\t\tinput:    \"hello\\\\u0041\\\\u004\",\n\t\t\texpected: \"hello\\\\u0041\\\\u004\",\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid escape sequence\",\n\t\t\tinput:    \"hello\\\\u004g\",\n\t\t\texpected: \"hello\\\\u004g\",\n\t\t},\n\t\t{\n\t\t\tname:     \"surrogate pair\",\n\t\t\tinput:    \"hello\\\\uD83D\\\\uDE00world\",\n\t\t\texpected: \"helloðŸ˜€world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"incomplete surrogate pair\",\n\t\t\tinput:    \"hello\\\\uD83D\",\n\t\t\texpected: \"hello\\\\uD83D\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "418c69497f59b9f493827f62e95a9c11": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetBool(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tjson     string\n\t\tkeys     []string\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname:     \"Existing key with true value\",\n\t\t\tjson:     `{\"key\": true}`,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Existing key with false value\",\n\t\t\tjson:     `{\"key\": false}`,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Non-existing key\",\n\t\t\tjson:     `{\"key1\": true}`,\n\t\t\tkeys:     []string{\"key2\"},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid value type\",\n\t\t\tjson:     `{\"key\": 42}`,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Array index in keys\",\n\t\t\tjson:     `{\"key\": [true, false]}`,\n\t\t\tkeys:     []string{\"key\", \"1\"},\n\t\t\texpected: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tv, err := Parse(tc.json)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Failed to parse JSON: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tactual := v.GetBool(tc.keys...)\n\t\t\tif actual != tc.expected {\n\t\t\t\tt.Errorf(\"GetBool(%v) = %v, expected %v\", tc.keys, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "3d8f6ad0ab0bfb926e53c4a95ced9ccd": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"empty array\",\n\t\t\tinput:    \"[]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with one value\",\n\t\t\tinput:    \"[1]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with multiple values\",\n\t\t\tinput:    \"[1,2,3]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}, &Value{t: TypeNumber, s: \"2\"}, &Value{t: TypeNumber, s: \"3\"}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with missing closing bracket\",\n\t\t\tinput:    \"[1,2,3\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with missing comma\",\n\t\t\tinput:    \"[1 2]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, _, err := parseArray(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseArray(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !compareValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\tcase TypeObject:\n\t\tif !compareObjects(&v1.o, &v2.o) {\n\t\t\treturn false\n\t\t}\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeTrue, TypeFalse, TypeNull:\n\t\treturn true\n\t}\n\treturn true\n}\n\nfunc compareObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i := range o1.kvs {\n\t\tif o1.kvs[i].k != o2.kvs[i].k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(o1.kvs[i].v, o2.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "41702ffcac5eb63c344593da8804a2ae": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: []string{\"hello\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello\\\"world\"`,\n\t\t\texpected: []string{\"hello\\\"world\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello\\\"world\\\"foo\"`,\n\t\t\texpected: []string{\"hello\\\"world\\\"foo\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with no closing quote\",\n\t\t\tinput:    `\"hello`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot1, got2, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got1 != tc.expected[0] || got2 != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = (%q, %q), want (%q, %q)\", tc.input, got1, got2, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "3d2d4a89f500c5677c5352bea33edf13": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: \"{}\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs:           []kv{},\n\t\t\t\t\t\tkeysUnescaped: true,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with one key-value pair\",\n\t\t\tinput: `{\"key\":\"value\"}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tkeysUnescaped: true,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with multiple key-value pairs\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":123,\"key3\":true}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tkeysUnescaped: true,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":123`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing colon\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\"}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing value\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tactual, _, err := parseObject(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !equalValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn equalObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn equalArrays(v1.a, v2.a)\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber, TypeTrue, TypeFalse:\n\t\treturn v1.s == v2.s\n\tcase TypeNull:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc equalObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !equalValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc equalArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tif !equalValues(v1, a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "3c85e974218694a7de9cb13fa4be2f63": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"too big depth\",\n\t\t\tinput:    \"{}\", // Assuming MaxDepth is 1\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds 1\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"valid object\",\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{\n\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\tt: typeRawString,\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"1\", t: TypeNumber},\n\t\t\t\t\t{s: \"2\", t: TypeNumber},\n\t\t\t\t\t{s: \"3\", t: TypeNumber},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{\n\t\t\t\ts: \"hello\",\n\t\t\t\tt: typeRawString,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid true\",\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid false\",\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid null\",\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"42\",\n\t\t\texpected: &Value{\n\t\t\t\ts: \"42\",\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, expected %v\", tc.input, err, tc.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else if tc.err != nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = nil, expected %v\", tc.input, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, expected %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn compareObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn compareArrays(v1.a, v2.a)\n\tcase typeRawString, TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber, TypeTrue, TypeFalse, TypeNull:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc compareObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc compareArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tif !compareValues(v1, a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "3f31a54f585efbbec2a16c87a8cbe8e0": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty array\",\n\t\t\tinput: \"[]\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with one value\",\n\t\t\tinput: \"[1]\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with multiple values\",\n\t\t\tinput: \"[1,2,3]\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with trailing comma\",\n\t\t\tinput: \"[1,2,3,]\",\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with missing closing bracket\",\n\t\t\tinput: \"[1,2,3\",\n\t\t\terr:   true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tactual, _, err := parseArray(tc.input, c, 0)\n\t\t\tif tc.err {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"expected error, got nil\")\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tc.expected, actual)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeArray:\n\t\ta1, _ := v1.Array()\n\t\ta2, _ := v2.Array()\n\t\tif len(a1) != len(a2) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range a1 {\n\t\t\tif !compareValues(a1[i], a2[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\tcase TypeObject:\n\t\to1, _ := v1.Object()\n\t\to2, _ := v2.Object()\n\t\tif o1.Len() != o2.Len() {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range o1.kvs {\n\t\t\tif o1.kvs[i].k != o2.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !compareValues(o1.kvs[i].v, o2.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\tcase TypeString:\n\t\ts1, _ := v1.StringBytes()\n\t\ts2, _ := v2.StringBytes()\n\t\treturn string(s1) == string(s2)\n\tcase TypeNumber:\n\t\tn1, _ := v1.Int64()\n\t\tn2, _ := v2.Int64()\n\t\treturn n1 == n2\n\tcase TypeTrue, TypeFalse:\n\t\tb1, _ := v1.Bool()\n\t\tb2, _ := v2.Bool()\n\t\treturn b1 == b2\n\tcase TypeNull:\n\t\treturn true\n\t}\n\treturn true\n}",
    "41eed9330e6f62c05d39e701011084a6": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.456e+78\",\n\t\t\texpected: []string{\"123.456e+78\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with leading zeros\",\n\t\t\tinput:    \"0123.456\",\n\t\t\texpected: []string{\"0123.456\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with sign\",\n\t\t\tinput:    \"-123.456\",\n\t\t\texpected: []string{\"-123.456\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with exponent\",\n\t\t\tinput:    \"1.2e-3\",\n\t\t\texpected: []string{\"1.2e-3\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number\",\n\t\t\tinput:    \"123.456.789\",\n\t\t\texpected: []string{\"\", \"123.456.789\"},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with leading invalid character\",\n\t\t\tinput:    \"a123.456\",\n\t\t\texpected: []string{\"\", \"a123.456\"},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.expected[0] || rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = (%q, %q), want (%q, %q)\", tc.input, num, rest, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "42a4581e9bcb47c9cae323e224321838": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":\"value1\",\"key2\":42}`),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"str1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`[\"str1\",42,true]`),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\\\"world\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello\\\"world\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42\",\n\t\t\t},\n\t\t\twant: []byte(\"42\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := make([]byte, 0, 100)\n\t\t\tgot := tt.v.MarshalTo(dst)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %q, want %q\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "40bce8756653a7f7b2a826f9d1e70a02": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: \"{}\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with one key-value pair\",\n\t\t\tinput: `{\"key\":\"value\"}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with multiple key-value pairs\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":123,\"key3\":true}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\tinput: `{\"key1\":\"value1\",`,\n\t\t\texpected: nil,\n\t\t\terr:     true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{\n\t\t\t\tvs: make([]Value, 0, 8),\n\t\t\t}\n\t\t\tactual, _, err := parseObject(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn compareObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn compareArrays(v1.a, v2.a)\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber, TypeTrue, TypeFalse:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\treturn true\n\t}\n}\n\nfunc compareObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc compareArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tif !compareValues(v1, a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "4317dd94c9c81cdfc7394fab018fe2c2": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.456\",\n\t\t\texpected: []string{\"123.456\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with sign\",\n\t\t\tinput:    \"-123.456\",\n\t\t\texpected: []string{\"-123.456\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with leading zeros\",\n\t\t\tinput:    \"0123.456\",\n\t\t\texpected: []string{\"0123.456\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with exponent\",\n\t\t\tinput:    \"1.23e+4\",\n\t\t\texpected: []string{\"1.23e+4\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with exponent and sign\",\n\t\t\tinput:    \"-1.23e-4\",\n\t\t\texpected: []string{\"-1.23e-4\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number\",\n\t\t\tinput:    \"abc\",\n\t\t\texpected: []string{\"\", \"abc\"},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with inf\",\n\t\t\tinput:    \"inf\",\n\t\t\texpected: []string{\"inf\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with nan\",\n\t\t\tinput:    \"nan\",\n\t\t\texpected: []string{\"nan\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.expected[0] || rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, %q, want %q, %q\", tc.input, num, rest, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "438cdd38c430e24205d861b12ce862a1": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello world\"`,\n\t\t\texpected: []string{\"hello world\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello \\\"world\\\"\"`,\n\t\t\texpected: []string{\"hello \\\"world\\\"\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello \\\"world\\\" \\\"foo\\\"\"`,\n\t\t\texpected: []string{\"hello \\\"world\\\" \\\"foo\\\"\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with no closing quote\",\n\t\t\tinput:    `\"hello world`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult1, result2, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif result1 != tc.expected[0] || result2 != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawString() = (%s, %s), expected (%s, %s)\", result1, result2, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "45e9f90038c7ac1a7282335fc1180fe8": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_getKV(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\to    *Object\n\t\twant *kv\n\t}{\n\t\t{\n\t\t\tname: \"empty kvs\",\n\t\t\to:    &Object{},\n\t\t\twant: &kv{},\n\t\t},\n\t\t{\n\t\t\tname: \"non-empty kvs\",\n\t\t\to: &Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"key1\", v: &Value{}},\n\t\t\t\t\t{k: \"key2\", v: &Value{}},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: &kv{k: \"key2\", v: &Value{}},\n\t\t},\n\t\t{\n\t\t\tname: \"kvs with capacity\",\n\t\t\to: &Object{\n\t\t\t\tkvs: make([]kv, 2, 3),\n\t\t\t},\n\t\t\twant: &kv{},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.o.getKV(); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Object.getKV() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "43f05169bea4b18464c3beff0572b019": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: []string{\"hello\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello\\\"world\"`,\n\t\t\texpected: []string{\"hello\\\"world\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello\\\"world\\\"foo\"`,\n\t\t\texpected: []string{\"hello\\\"world\\\"foo\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with no closing quote\",\n\t\t\tinput:    `\"hello`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot1, got2, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got1 != tc.expected[0] || got2 != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = (%q, %q), want (%q, %q)\", tc.input, got1, got2, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "46016ef0a20258ffb65f7446c875b298": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:  \"valid JSON\",\n\t\t\tinput: `{\"key1\": \"value1\", \"key2\": 42}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{s: \"value1\", t: TypeString}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{s: \"42\", t: TypeNumber}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid JSON\",\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\":`,\n\t\t\texpected: nil,\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty input\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tp := &Parser{}\n\t\t\tgot, err := p.Parse(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"Parse() error = %v, wantErr %v\", err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tc.wantErr && !got.Equal(tc.expected) {\n\t\t\t\tt.Errorf(\"Parse() = %v, want %v\", got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "474587a46759d9c9af305ffe6abc10cf": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestObject_unescapeKeys(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\to    *Object\n\t\twant *Object\n\t}{\n\t\t{\n\t\t\tname: \"unescaped keys\",\n\t\t\to: &Object{\n\t\t\t\tkvs:           []kv{{k: \"key1\", v: &Value{}}, {k: \"key2\", v: &Value{}}},\n\t\t\t\tkeysUnescaped: false,\n\t\t\t},\n\t\t\twant: &Object{\n\t\t\t\tkvs:           []kv{{k: \"key1\", v: &Value{}}, {k: \"key2\", v: &Value{}}},\n\t\t\t\tkeysUnescaped: true,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"already unescaped keys\",\n\t\t\to: &Object{\n\t\t\t\tkvs:           []kv{{k: \"key1\", v: &Value{}}, {k: \"key2\", v: &Value{}}},\n\t\t\t\tkeysUnescaped: true,\n\t\t\t},\n\t\t\twant: &Object{\n\t\t\t\tkvs:           []kv{{k: \"key1\", v: &Value{}}, {k: \"key2\", v: &Value{}}},\n\t\t\t\tkeysUnescaped: true,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\ttt.o.unescapeKeys()\n\t\t\tif !reflect.DeepEqual(tt.o, tt.want) {\n\t\t\t\tt.Errorf(\"Object.unescapeKeys() = %v, want %v\", tt.o, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "446abaebeeef376ebc93226303f531ed": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: \"{}\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs:           []kv{},\n\t\t\t\t\t\tkeysUnescaped: true,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with one key-value pair\",\n\t\t\tinput: `{\"key\":\"value\"}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tkeysUnescaped: true,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with multiple key-value pairs\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":123,\"key3\":true}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tkeysUnescaped: true,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":123`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{\n\t\t\t\tvs: make([]Value, 0, 8),\n\t\t\t}\n\t\t\tv, _, err := parseObject(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !v.Equal(tc.expected) {\n\t\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", tc.input, v, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "47b28de27696c7d835e66559172d7cdc": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tv        *Value\n\t\texpected []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\texpected: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: []byte(`{\"key1\":\"value1\",\"key2\":42}`),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"item1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: []byte(`[\"item1\",42,true]`),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\\\"world\",\n\t\t\t},\n\t\t\texpected: []byte(`\"hello\\\"world\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42\",\n\t\t\t},\n\t\t\texpected: []byte(\"42\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\texpected: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\texpected: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\texpected: []byte(\"null\"),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdst := make([]byte, 0, 64)\n\t\t\tresult := tc.v.MarshalTo(dst)\n\t\t\tif !reflect.DeepEqual(result, tc.expected) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %s, expected %s\", result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "482458ac461af40cdb53b92e922369b7": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: []string{\"hello\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello\\\"world\"`,\n\t\t\texpected: []string{\"hello\\\"world\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello\\\"world\\\"foo\"`,\n\t\t\texpected: []string{\"hello\\\"world\\\"foo\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with unmatched quote\",\n\t\t\tinput:    `\"hello`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot1, got2, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got1 != tc.expected[0] || got2 != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = (%q, %q), want (%q, %q)\", tc.input, got1, got2, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "48320e961bd2d8c9a3735fa076ff65ef": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestTypeString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    Type\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"TypeObject\",\n\t\t\tinput:    TypeObject,\n\t\t\texpected: \"object\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeArray\",\n\t\t\tinput:    TypeArray,\n\t\t\texpected: \"array\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeString\",\n\t\t\tinput:    TypeString,\n\t\t\texpected: \"string\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeNumber\",\n\t\t\tinput:    TypeNumber,\n\t\t\texpected: \"number\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeTrue\",\n\t\t\tinput:    TypeTrue,\n\t\t\texpected: \"true\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeFalse\",\n\t\t\tinput:    TypeFalse,\n\t\t\texpected: \"false\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeNull\",\n\t\t\tinput:    TypeNull,\n\t\t\texpected: \"null\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Unknown Type\",\n\t\t\tinput:    Type(100),\n\t\t\texpected: \"BUG: unknown Value type: 100\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := tc.input.String()\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"expected %q, got %q\", tc.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "4778417afe75368a35b2b6f4f35fc985": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"empty array\",\n\t\t\tinput:    \"[]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{}},\n\t\t},\n\t\t{\n\t\t\tname:     \"array with values\",\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}, &Value{t: TypeNumber, s: \"2\"}, &Value{t: TypeNumber, s: \"3\"}}},\n\t\t},\n\t\t{\n\t\t\tname:     \"array with nested objects\",\n\t\t\tinput:    `[{\"a\":1}, {\"b\":2}]`,\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeObject, o: Object{kvs: []kv{{k: \"a\", v: &Value{t: TypeNumber, s: \"1\"}}}}}, &Value{t: TypeObject, o: Object{kvs: []kv{{k: \"b\", v: &Value{t: TypeNumber, s: \"2\"}}}}}}},\n\t\t},\n\t\t{\n\t\t\tname:  \"missing closing bracket\",\n\t\t\tinput: \"[1, 2, 3\",\n\t\t\terr:   true,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, _, err := parseArray(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseArray(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeNull, TypeTrue, TypeFalse:\n\t\treturn true\n\tcase TypeNumber, TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeObject:\n\t\treturn compareObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !compareValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\tpanic(\"unknown type\")\n\t}\n}\n\nfunc compareObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i := range o1.kvs {\n\t\tif o1.kvs[i].k != o2.kvs[i].k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(o1.kvs[i].v, o2.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "4b129ab98d5c4c731411a79d4a5f508e": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"no leading whitespace\",\n\t\t\tinput:    \"hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading whitespace\",\n\t\t\tinput:    \"   hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading mixed whitespace\",\n\t\t\tinput:    \"\\t \\n\\r hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"all whitespace\",\n\t\t\tinput:    \"   \\t\\n\\r\",\n\t\t\texpected: \"\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := skipWSSlow(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"skipWSSlow(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "48d318ea87ed8fe26689b887bc8fd3c8": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"no leading whitespace\",\n\t\t\tinput:    \"hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading space\",\n\t\t\tinput:    \" hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading newline\",\n\t\t\tinput:    \"\\nhello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading tab\",\n\t\t\tinput:    \"\\thello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading carriage return\",\n\t\t\tinput:    \"\\rhello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple leading whitespace\",\n\t\t\tinput:    \"   \\t\\n\\r hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"whitespace in the middle\",\n\t\t\tinput:    \"hello   \\t\\n\\r world\",\n\t\t\texpected: \"hello   \\t\\n\\r world\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := skipWSSlow(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"skipWSSlow(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "487b4d87b952e68219b21d44a1371cea": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"empty array\",\n\t\t\tinput:    \"[]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with values\",\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}, &Value{t: TypeNumber, s: \"2\"}, &Value{t: TypeNumber, s: \"3\"}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with missing closing bracket\",\n\t\t\tinput:    \"[1, 2, 3\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with missing comma\",\n\t\t\tinput:    \"[1 2]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, _, err := parseArray(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseArray(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !equalValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\t}\n\treturn true\n}",
    "4b87cd4d52570dab9666b264f36b07db": "package fastjson_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/valyala/fastjson\"\n)\n\nfunc TestTypeString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    fastjson.Type\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"TypeObject\",\n\t\t\tinput:    fastjson.TypeObject,\n\t\t\texpected: \"object\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeArray\",\n\t\t\tinput:    fastjson.TypeArray,\n\t\t\texpected: \"array\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeString\",\n\t\t\tinput:    fastjson.TypeString,\n\t\t\texpected: \"string\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeNumber\",\n\t\t\tinput:    fastjson.TypeNumber,\n\t\t\texpected: \"number\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeTrue\",\n\t\t\tinput:    fastjson.TypeTrue,\n\t\t\texpected: \"true\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeFalse\",\n\t\t\tinput:    fastjson.TypeFalse,\n\t\t\texpected: \"false\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeNull\",\n\t\t\tinput:    fastjson.TypeNull,\n\t\t\texpected: \"null\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Unknown\",\n\t\t\tinput:    fastjson.Type(100),\n\t\t\texpected: \"BUG: unknown Value type: 100\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := tc.input.String()\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"expected %q, got %q\", tc.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "47a7a73c5d932bf8413c1aa7692b5419": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"too big depth\",\n\t\t\tinput:    \"{}\", // Assuming MaxDepth is 1\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds 1\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"valid object\",\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{\n\t\t\t\t\t\t\tt: typeRawString,\n\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid true\",\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid false\",\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid null\",\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"42\",\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42\",\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, expected %v\", tc.input, err, tc.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else if tc.err != nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = nil, expected %v\", tc.input, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, expected %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\to1, _ := v1.Object()\n\t\to2, _ := v2.Object()\n\t\treturn compareObjects(o1, o2)\n\tcase TypeArray:\n\t\ta1, _ := v1.Array()\n\t\ta2, _ := v2.Array()\n\t\tif len(a1) != len(a2) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range a1 {\n\t\t\tif !compareValues(a1[i], a2[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase typeRawString, TypeNumber, TypeTrue, TypeFalse, TypeNull:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc compareObjects(o1, o2 *Object) bool {\n\tif o1 == nil && o2 == nil {\n\t\treturn true\n\t}\n\tif o1 == nil || o2 == nil {\n\t\treturn false\n\t}\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i := range o1.kvs {\n\t\tif o1.kvs[i].k != o2.kvs[i].k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(o1.kvs[i].v, o2.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "4d0122a553f10d32bc49513bf0d9a989": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"hello world\",\n\t\t\texpected: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Single escape character\",\n\t\t\tinput:    \"hello\\\\world\",\n\t\t\texpected: \"helloworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Multiple escape characters\",\n\t\t\tinput:    \"hello\\\\\\\"world\\\\\\\\\",\n\t\t\texpected: \"hello\\\"world\\\\\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape sequence\",\n\t\t\tinput:    \"hello\\\\n\\\\tworld\",\n\t\t\texpected: \"hello\\n\\tworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid escape sequence\",\n\t\t\tinput:    \"hello\\\\uabcd\\\\world\",\n\t\t\texpected: \"hello\\\\uabcd\\\\world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Surrogate pair\",\n\t\t\tinput:    \"hello\\\\ud83d\\\\ude00world\",\n\t\t\texpected: \"helloðŸ˜€world\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "4cdd623a302712e4419ad2c3a2c97876": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: []string{\"hello\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello\\\"world\"`,\n\t\t\texpected: []string{\"hello\\\"world\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello\\\"world\\\"foo\"`,\n\t\t\texpected: []string{\"hello\\\"world\\\"foo\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with no closing quote\",\n\t\t\tinput:    `\"hello`,\n\t\t\texpected: []string{},\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult, rest, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif result != tc.expected[0] || rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = %q, %q, want %q, %q\", tc.input, result, rest, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "4bfd353ce394104c3e5e7330f2d8c37e": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: []string{\"hello\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello\\\"world\"`,\n\t\t\texpected: []string{\"hello\\\"world\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello\\\"world\\\"foo\"`,\n\t\t\texpected: []string{\"hello\\\"world\\\"foo\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with no closing quote\",\n\t\t\tinput:    `\"hello`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot, got2, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tc.expected[0] {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, expected %v\", got, tc.expected[0])\n\t\t\t}\n\t\t\tif got2 != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawString() got2 = %v, expected %v\", got2, tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "48c9e62e37da97e070e59a6c5e30e526": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: \"{}\",\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           []kv{},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with one key-value pair\",\n\t\t\tinput: `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with multiple key-value pairs\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":123,\"key3\":true}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\tinput: `{\"key\":\"value\"`,\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing colon\",\n\t\t\tinput: `{\"key\" \"value\"}`,\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing comma\",\n\t\t\tinput: `{\"key1\":\"value1\" \"key2\":123}`,\n\t\t\terr:   true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tv, _, err := parseObject(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tc.err && !v.Equal(tc.expected) {\n\t\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", tc.input, v, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc (v *Value) Equal(other *Value) bool {\n\tif v.t != other.t {\n\t\treturn false\n\t}\n\n\tswitch v.t {\n\tcase TypeObject:\n\t\treturn v.o.Equal(&other.o)\n\tcase TypeArray:\n\t\treturn v.ArrayEqual(other.a)\n\tcase TypeString:\n\t\treturn v.s == other.s\n\tcase TypeNumber, TypeTrue, TypeFalse:\n\t\treturn v.s == other.s\n\tcase TypeNull:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc (o *Object) Equal(other *Object) bool {\n\tif len(o.kvs) != len(other.kvs) {\n\t\treturn false\n\t}\n\n\tfor i, kv := range o.kvs {\n\t\tif kv.k != other.kvs[i].k {\n\t\t\treturn false\n\t\t}\n\t\tif !kv.v.Equal(other.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\nfunc (v *Value) ArrayEqual(other []*Value) bool {\n\tif len(v.a) != len(other) {\n\t\treturn false\n\t}\n\n\tfor i, val := range v.a {\n\t\tif !val.Equal(other[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}",
    "48615e4e0f80b59be18ffb71c44492a6": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty input\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"depth exceeds MaxDepth\",\n\t\t\tinput:    \"{}\", // Nested JSON with depth 1\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t},\n\t\t{\n\t\t\tname:     \"valid object\",\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{s: \"value\", t: typeRawString}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"1\", t: TypeNumber},\n\t\t\t\t\t{s: \"2\", t: TypeNumber},\n\t\t\t\t\t{s: \"3\", t: TypeNumber},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{\n\t\t\t\ts: \"hello\",\n\t\t\t\tt: typeRawString,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid true\",\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid false\",\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid null\",\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"42\",\n\t\t\texpected: &Value{\n\t\t\t\ts: \"42\",\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid value\",\n\t\t\tinput:    \"invalid\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"unexpected value found: %q\", \"invalid\"),\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, expected %v\", tc.input, err, tc.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else if tc.err != nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = nil, expected %v\", tc.input, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, expected %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(a, b *Value) bool {\n\tif a == nil && b == nil {\n\t\treturn true\n\t}\n\tif a == nil || b == nil {\n\t\treturn false\n\t}\n\tif a.t != b.t {\n\t\treturn false\n\t}\n\tswitch a.t {\n\tcase TypeObject:\n\t\treturn compareObjects(&a.o, &b.o)\n\tcase TypeArray:\n\t\treturn compareArrays(a.a, b.a)\n\tcase typeRawString, TypeString:\n\t\treturn a.s == b.s\n\tcase TypeNumber, TypeTrue, TypeFalse, TypeNull:\n\t\treturn a.s == b.s\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc compareObjects(a, b *Object) bool {\n\tif len(a.kvs) != len(b.kvs) {\n\t\treturn false\n\t}\n\tfor i := range a.kvs {\n\t\tif a.kvs[i].k != b.kvs[i].k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(a.kvs[i].v, b.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc compareArrays(a, b []*Value) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif !compareValues(a[i], b[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "49c1fd950447c90d34f273d87ba7c002": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: \"{}\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with one key-value pair\",\n\t\t\tinput: `{\"key\":\"value\"}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with multiple key-value pairs\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":123,\"key3\":true}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":123`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing colon\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\"}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tactual, _, err := parseObject(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !equalValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn equalObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn equalArrays(v1.a, v2.a)\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber, TypeTrue, TypeFalse:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\treturn true\n\t}\n}\n\nfunc equalObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !equalValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc equalArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tif !equalValues(v1, a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "4fc89e3a630b8e550765596372d584cd": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"no escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"simple escape characters\",\n\t\t\tinput:    \"hello\\\\\\\"world\\\\\\\\\",\n\t\t\texpected: \"hello\\\"world\\\\\",\n\t\t},\n\t\t{\n\t\t\tname:     \"unicode escape characters\",\n\t\t\tinput:    \"hello\\\\u0041world\\\\u0042\",\n\t\t\texpected: \"helloAwordB\",\n\t\t},\n\t\t{\n\t\t\tname:     \"surrogate pair escape characters\",\n\t\t\tinput:    \"hello\\\\ud83d\\\\ude00world\",\n\t\t\texpected: \"helloðŸ˜€world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid unicode escape characters\",\n\t\t\tinput:    \"hello\\\\u123world\",\n\t\t\texpected: \"hello\\\\u123world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"mixed escape characters\",\n\t\t\tinput:    \"hello\\\\\\\"world\\\\\\\\\\\\u0041\\\\u0042\",\n\t\t\texpected: \"hello\\\"world\\\\AB\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "507ed88071a072bb161e39e02811a740": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"no leading whitespace\",\n\t\t\tinput:    \"hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading space\",\n\t\t\tinput:    \" hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading newline\",\n\t\t\tinput:    \"\\nhello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading tab\",\n\t\t\tinput:    \"\\thello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading carriage return\",\n\t\t\tinput:    \"\\rhello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple leading whitespace\",\n\t\t\tinput:    \"  \\t\\n\\rhello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"whitespace only\",\n\t\t\tinput:    \"   \\t\\n\\r\",\n\t\t\texpected: \"\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := skipWSSlow(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"skipWSSlow(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "503f3922e45e669920f6725150e5602b": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"valid JSON\",\n\t\t\tinput: `{\"key1\": \"value1\", \"key2\": 42}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{s: \"value1\", t: TypeString}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{s: \"42\", t: TypeNumber}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"invalid JSON\",\n\t\t\tinput: `{\"key1\": \"value1\", \"key2\":`,\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty input\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tp := &Parser{}\n\t\t\tv, err := p.Parse(tc.input)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !tc.err && !v.Equal(tc.expected) {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tc.expected, v)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc (v *Value) Equal(other *Value) bool {\n\tif v == nil && other == nil {\n\t\treturn true\n\t}\n\tif v == nil || other == nil {\n\t\treturn false\n\t}\n\tif v.t != other.t {\n\t\treturn false\n\t}\n\tswitch v.t {\n\tcase TypeObject:\n\t\treturn v.o.Equal(&other.o)\n\tcase TypeArray:\n\t\tif len(v.a) != len(other.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, vv := range v.a {\n\t\t\tif !vv.Equal(other.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeString:\n\t\treturn v.s == other.s\n\tcase TypeNumber:\n\t\treturn v.s == other.s\n\tcase TypeTrue, TypeFalse, TypeNull:\n\t\treturn true\n\tdefault:\n\t\tpanic(\"unknown type\")\n\t}\n}\n\nfunc (o *Object) Equal(other *Object) bool {\n\tif len(o.kvs) != len(other.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv := range o.kvs {\n\t\tif kv.k != other.kvs[i].k {\n\t\t\treturn false\n\t\t}\n\t\tif !kv.v.Equal(other.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "51eb580ec9a46535500e7d56e243aafa": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"hello world\",\n\t\t\texpected: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape double quote\",\n\t\t\tinput:    \"\\\"hello\\\" world\",\n\t\t\texpected: `\"hello\" world`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backslash\",\n\t\t\tinput:    \"hello\\\\ world\",\n\t\t\texpected: `hello\\\\ world`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape forward slash\",\n\t\t\tinput:    \"hello/ world\",\n\t\t\texpected: `hello/ world`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backspace\",\n\t\t\tinput:    \"hello\\b world\",\n\t\t\texpected: `hello\\b world`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape form feed\",\n\t\t\tinput:    \"hello\\f world\",\n\t\t\texpected: `hello\\f world`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape newline\",\n\t\t\tinput:    \"hello\\n world\",\n\t\t\texpected: `hello\\n world`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape carriage return\",\n\t\t\tinput:    \"hello\\r world\",\n\t\t\texpected: `hello\\r world`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape tab\",\n\t\t\tinput:    \"hello\\t world\",\n\t\t\texpected: `hello\\t world`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Unicode character\",\n\t\t\tinput:    \"hello\\u0123 world\",\n\t\t\texpected: `hello\\u0123 world`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape surrogate pair\",\n\t\t\tinput:    \"hello\\uD83D\\uDE00 world\",\n\t\t\texpected: \"helloðŸ˜€ world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape invalid Unicode character\",\n\t\t\tinput:    \"hello\\uABCD world\",\n\t\t\texpected: `hello\\uABCD world`,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "51623eafceb80d06c6bf0fcefe4a047b": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"empty array\",\n\t\t\tinput:    \"[]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with one value\",\n\t\t\tinput:    \"[1]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with multiple values\",\n\t\t\tinput:    \"[1,2,3]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}, &Value{t: TypeNumber, s: \"2\"}, &Value{t: TypeNumber, s: \"3\"}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with missing closing bracket\",\n\t\t\tinput:    \"[1,2,3\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with missing comma\",\n\t\t\tinput:    \"[1 2]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, _, err := parseArray(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseArray(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !compareValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeTrue, TypeFalse, TypeNull:\n\t\treturn true\n\tdefault:\n\t\tpanic(\"unsupported type\")\n\t}\n\treturn true\n}",
    "528a2d825a6aee6a7ac7a372fbecd8b5": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":\"value1\",\"key2\":42}`),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"hello\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`[\"hello\",42,true]`),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42\",\n\t\t\t},\n\t\t\twant: []byte(\"42\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %q, want %q\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "526d23c85d09e89c801d9123b00e9a9b": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape double quote\",\n\t\t\tinput:    \"\\\"hello, world\\\"\",\n\t\t\texpected: `\"hello, world\"`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backslash\",\n\t\t\tinput:    \"\\\\hello, world\\\\\",\n\t\t\texpected: `\\hello, world\\`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape forward slash\",\n\t\t\tinput:    \"/hello, world/\",\n\t\t\texpected: `/hello, world/`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backspace\",\n\t\t\tinput:    \"h\\bello, world\",\n\t\t\texpected: \"h\\bello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape form feed\",\n\t\t\tinput:    \"h\\fello, world\",\n\t\t\texpected: \"h\\fello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape newline\",\n\t\t\tinput:    \"h\\nello, world\",\n\t\t\texpected: \"h\\nello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape carriage return\",\n\t\t\tinput:    \"h\\rello, world\",\n\t\t\texpected: \"h\\rello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape tab\",\n\t\t\tinput:    \"h\\tello, world\",\n\t\t\texpected: \"h\\tello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Unicode\",\n\t\t\tinput:    \"\\\\u0041\\\\u0042\\\\u0043\",\n\t\t\texpected: \"ABC\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Surrogate Pair\",\n\t\t\tinput:    \"\\\\ud83d\\\\ude00\",\n\t\t\texpected: \"ðŸ˜€\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid Escape Sequence\",\n\t\t\tinput:    \"\\\\uABCD\",\n\t\t\texpected: \"\\\\uABCD\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "4f4491cb7c5cc7f58615a05c592dd536": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"too deep\",\n\t\t\tinput:    \"{}\", // Assuming MaxDepth is 1\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t},\n\t\t{\n\t\t\tname:     \"valid object\",\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{s: \"value\", t: typeRawString}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"1\", t: TypeNumber},\n\t\t\t\t\t{s: \"2\", t: TypeNumber},\n\t\t\t\t\t{s: \"3\", t: TypeNumber},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{s: \"hello\", t: typeRawString},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid true\",\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid false\",\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid null\",\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"42\",\n\t\t\texpected: &Value{s: \"42\", t: TypeNumber},\n\t\t\terr:      nil,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, expected %v\", tc.input, err, tc.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else if tc.err != nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = nil, expected %v\", tc.input, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, expected %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn compareObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn compareArrays(v1.a, v2.a)\n\tcase typeRawString, TypeString, TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeTrue, TypeFalse, TypeNull:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc compareObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc compareArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tif !compareValues(v1, a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "52f0859c0121dc670dfa3c6394572777": "package fastjson_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/valyala/fastjson\"\n)\n\nfunc TestTypeString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    fastjson.Type\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"TypeObject\",\n\t\t\tinput:    fastjson.TypeObject,\n\t\t\texpected: \"object\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeArray\",\n\t\t\tinput:    fastjson.TypeArray,\n\t\t\texpected: \"array\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeString\",\n\t\t\tinput:    fastjson.TypeString,\n\t\t\texpected: \"string\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeNumber\",\n\t\t\tinput:    fastjson.TypeNumber,\n\t\t\texpected: \"number\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeTrue\",\n\t\t\tinput:    fastjson.TypeTrue,\n\t\t\texpected: \"true\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeFalse\",\n\t\t\tinput:    fastjson.TypeFalse,\n\t\t\texpected: \"false\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeNull\",\n\t\t\tinput:    fastjson.TypeNull,\n\t\t\texpected: \"null\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Unknown\",\n\t\t\tinput:    fastjson.Type(100),\n\t\t\texpected: \"BUG: unknown Value type: 100\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := tc.input.String()\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"expected %q, got %q\", tc.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "51deb49920dfc6e510077a17df92cc0a": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty input\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"too deep nested JSON\",\n\t\t\tinput:    \"{\\\"key\\\":{\\\"key2\\\":{\\\"key3\\\":{}}}}\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t},\n\t\t{\n\t\t\tname:     \"valid object\",\n\t\t\tinput:    `{\"key\":\"value\",\"key2\":123}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{s: \"value\", t: typeRawString}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{s: \"123\", t: TypeNumber}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"1\", t: TypeNumber},\n\t\t\t\t\t{s: \"2\", t: TypeNumber},\n\t\t\t\t\t{s: \"3\", t: TypeNumber},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{\n\t\t\t\ts: \"hello\",\n\t\t\t\tt: typeRawString,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid true\",\n\t\t\tinput:    `true`,\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid false\",\n\t\t\tinput:    `false`,\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid null\",\n\t\t\tinput:    `null`,\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    `123.45`,\n\t\t\texpected: &Value{\n\t\t\t\ts: \"123.45\",\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tv, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif tc.err != nil {\n\t\t\t\tt.Errorf(\"expected error: %v\", tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !v.Equal(tc.expected) {\n\t\t\t\tt.Errorf(\"unexpected value: got %v, want %v\", v, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "52b69c67d9b989e8d08cb882093db87e": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGet(t *testing.T) {\n\t// Test cases\n\ttestCases := []struct {\n\t\tname     string\n\t\tjson     string\n\t\tkeys     []string\n\t\texpected *Value\n\t}{\n\t\t{\n\t\t\tname:     \"Existing key in object\",\n\t\t\tjson:     `{\"key1\": \"value1\", \"key2\": 42}`,\n\t\t\tkeys:     []string{\"key2\"},\n\t\t\texpected: &Value{t: TypeNumber, s: \"42\"},\n\t\t},\n\t\t{\n\t\t\tname:     \"Non-existing key in object\",\n\t\t\tjson:     `{\"key1\": \"value1\", \"key2\": 42}`,\n\t\t\tkeys:     []string{\"key3\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Existing index in array\",\n\t\t\tjson:     `[1, 2, 3]`,\n\t\t\tkeys:     []string{\"1\"},\n\t\t\texpected: &Value{t: TypeNumber, s: \"2\"},\n\t\t},\n\t\t{\n\t\t\tname:     \"Non-existing index in array\",\n\t\t\tjson:     `[1, 2, 3]`,\n\t\t\tkeys:     []string{\"3\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Nested object\",\n\t\t\tjson:     `{\"key1\": {\"subkey1\": \"value1\", \"subkey2\": 42}}`,\n\t\t\tkeys:     []string{\"key1\", \"subkey2\"},\n\t\t\texpected: &Value{t: TypeNumber, s: \"42\"},\n\t\t},\n\t\t{\n\t\t\tname:     \"Nested array\",\n\t\t\tjson:     `[1, [10, 20, 30], 3]`,\n\t\t\tkeys:     []string{\"1\", \"1\"},\n\t\t\texpected: &Value{t: TypeNumber, s: \"20\"},\n\t\t},\n\t\t{\n\t\t\tname:     \"Nil value\",\n\t\t\tjson:     `{\"key1\": null}`,\n\t\t\tkeys:     []string{\"key1\"},\n\t\t\texpected: &Value{t: TypeNull},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tv, err := Parse(tc.json)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Failed to parse JSON: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tresult := v.Get(tc.keys...)\n\t\t\tif tc.expected == nil && result != nil {\n\t\t\t\tt.Errorf(\"Expected nil, got %v\", result)\n\t\t\t} else if tc.expected != nil && result == nil {\n\t\t\t\tt.Errorf(\"Expected %v, got nil\", tc.expected)\n\t\t\t} else if tc.expected != nil && result != nil && *tc.expected != *result {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", tc.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "53998db868a67109c659274b129aa427": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty array\",\n\t\t\tinput: \"[]\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with one value\",\n\t\t\tinput: \"[1]\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with multiple values\",\n\t\t\tinput: \"[1,2,3]\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with trailing comma\",\n\t\t\tinput: \"[1,2,3,]\",\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with missing closing bracket\",\n\t\t\tinput: \"[1,2,3\",\n\t\t\terr:   true,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, _, err := parseArray(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseArray(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !equalValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeArray:\n\t\ta1, _ := v1.Array()\n\t\ta2, _ := v2.Array()\n\t\tif len(a1) != len(a2) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range a1 {\n\t\t\tif !equalValues(a1[i], a2[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeObject:\n\t\to1, _ := v1.Object()\n\t\to2, _ := v2.Object()\n\t\tif o1.Len() != o2.Len() {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range o1.kvs {\n\t\t\tif o1.kvs[i].k != o2.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(o1.kvs[i].v, o2.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeString:\n\t\ts1, _ := v1.StringBytes()\n\t\ts2, _ := v2.StringBytes()\n\t\treturn string(s1) == string(s2)\n\tcase TypeNumber, TypeTrue, TypeFalse:\n\t\treturn v1.s == v2.s\n\tcase TypeNull:\n\t\treturn true\n\tdefault:\n\t\tpanic(\"unknown type\")\n\t}\n}",
    "567dc1a07a611eae451a61af6d9ce469": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetValue(t *testing.T) {\n\tc := &cache{\n\t\tvs: make([]Value, 0, 10),\n\t}\n\n\t// Test when the capacity of the slice is greater than the length\n\tv1 := c.getValue()\n\tif len(c.vs) != 1 {\n\t\tt.Errorf(\"expected length of vs to be 1, got %d\", len(c.vs))\n\t}\n\tif v1 != &c.vs[0] {\n\t\tt.Errorf(\"expected v1 to be the last element in vs, got %p\", v1)\n\t}\n\n\t// Test when the capacity of the slice is equal to the length\n\tfor i := 0; i < 9; i++ {\n\t\tc.getValue()\n\t}\n\tv2 := c.getValue()\n\tif len(c.vs) != 10 {\n\t\tt.Errorf(\"expected length of vs to be 10, got %d\", len(c.vs))\n\t}\n\tif v2 != &c.vs[9] {\n\t\tt.Errorf(\"expected v2 to be the last element in vs, got %p\", v2)\n\t}\n}",
    "52d2cdb7fd59ff3333585b77492b3dac": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: \"{}\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs:           []kv{},\n\t\t\t\t\t\tkeysUnescaped: true,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"simple object\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tkeysUnescaped: true,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with whitespace\",\n\t\t\tinput: `{ \"key1\" : \"value1\" , \"key2\" : 42 }`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tkeysUnescaped: true,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing key\",\n\t\t\tinput: `{\"key1\":\"value1\",:\"value2\"}`,\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing value\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":}`,\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing comma\",\n\t\t\tinput: `{\"key1\":\"value1\" \"key2\":42}`,\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42`,\n\t\t\terr:   true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tv, _, err := parseObject(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tc.err && !v.Equal(tc.expected) {\n\t\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", tc.input, v, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc (v *Value) Equal(other *Value) bool {\n\tif v.t != other.t {\n\t\treturn false\n\t}\n\tswitch v.t {\n\tcase TypeObject:\n\t\treturn v.o.Equal(&other.o)\n\tcase TypeArray:\n\t\tif len(v.a) != len(other.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, vv := range v.a {\n\t\t\tif !vv.Equal(other.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeString:\n\t\treturn v.s == other.s\n\tcase TypeNumber:\n\t\treturn v.s == other.s\n\tcase TypeTrue, TypeFalse, TypeNull:\n\t\treturn true\n\tdefault:\n\t\tpanic(\"unknown type\")\n\t}\n}\n\nfunc (o *Object) Equal(other *Object) bool {\n\tif len(o.kvs) != len(other.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv := range o.kvs {\n\t\tif kv.k != other.kvs[i].k {\n\t\t\treturn false\n\t\t}\n\t\tif !kv.v.Equal(other.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn o.keysUnescaped == other.keysUnescaped\n}",
    "5247ae134bd05d190a83b85d60a407ce": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"too big depth\",\n\t\t\tinput:    \"{}\", // Assuming MaxDepth is 1\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds 1\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"valid object\",\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{\n\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\tt: typeRawString,\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"1\", t: TypeNumber},\n\t\t\t\t\t{s: \"2\", t: TypeNumber},\n\t\t\t\t\t{s: \"3\", t: TypeNumber},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{\n\t\t\t\ts: \"hello\",\n\t\t\t\tt: typeRawString,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid true\",\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid false\",\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid null\",\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"42\",\n\t\t\texpected: &Value{\n\t\t\t\ts: \"42\",\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, expected %v\", tc.input, err, tc.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else if tc.err != nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = nil, expected %v\", tc.input, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, expected %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\to1, _ := v1.Object()\n\t\to2, _ := v2.Object()\n\t\treturn compareObjects(o1, o2)\n\tcase TypeArray:\n\t\ta1, _ := v1.Array()\n\t\ta2, _ := v2.Array()\n\t\tif len(a1) != len(a2) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range a1 {\n\t\t\tif !compareValues(a1[i], a2[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase typeRawString, TypeString, TypeNumber, TypeTrue, TypeFalse, TypeNull:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc compareObjects(o1, o2 *Object) bool {\n\tif o1 == nil && o2 == nil {\n\t\treturn true\n\t}\n\tif o1 == nil || o2 == nil {\n\t\treturn false\n\t}\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i := range o1.kvs {\n\t\tif o1.kvs[i].k != o2.kvs[i].k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(o1.kvs[i].v, o2.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "54d21dbd2f396078b3efb6b6942aa1c4": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: []string{\"hello\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello\\\"world\"`,\n\t\t\texpected: []string{\"hello\\\"world\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello\\\"world\\\"foo\"`,\n\t\t\texpected: []string{\"hello\\\"world\\\"foo\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with no closing quote\",\n\t\t\tinput:    `\"hello`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot1, got2, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got1 != tc.expected[0] || got2 != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = (%q, %q), want (%q, %q)\", tc.input, got1, got2, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "569ceb1896d923fc26f5c3de368f3449": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"no whitespace\",\n\t\t\tinput:    \"hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading whitespace\",\n\t\t\tinput:    \"   hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading and trailing whitespace\",\n\t\t\tinput:    \"   hello   \",\n\t\t\texpected: \"hello   \",\n\t\t},\n\t\t{\n\t\t\tname:     \"all whitespace\",\n\t\t\tinput:    \"   \\t\\n\\r\",\n\t\t\texpected: \"\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := skipWSSlow(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"skipWSSlow(%q) = %q, want %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "55c709ffad8143534ddeaf41a1e7bd19": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.456\",\n\t\t\texpected: []string{\"123.456\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with exponent\",\n\t\t\tinput:    \"1.23e+4\",\n\t\t\texpected: []string{\"1.23e+4\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with leading zero\",\n\t\t\tinput:    \"0123.456\",\n\t\t\texpected: []string{\"0123.456\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with sign\",\n\t\t\tinput:    \"-123.456\",\n\t\t\texpected: []string{\"-123.456\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with invalid character\",\n\t\t\tinput:    \"123.456a\",\n\t\t\texpected: []string{\"123.456\", \"a\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with only special characters\",\n\t\t\tinput:    \"!@#$%^&*\",\n\t\t\texpected: []string{\"\", \"!@#$%^&*\"},\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.expected[0] || rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = (%q, %q), want (%q, %q)\", tc.input, num, rest, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "55ae7eb91da475c49df165ec95632208": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":\"value1\",\"key2\":42}`),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"hello\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t\t{t: TypeFalse},\n\t\t\t\t\t{t: TypeNull},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`[\"hello\",42,true,false,null]`),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42\",\n\t\t\t},\n\t\t\twant: []byte(\"42\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"unknown type\",\n\t\t\tv: &Value{\n\t\t\t\tt: 100,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %q, want %q\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "569adecc916ae3f07b25462da44a89f4": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tv        *Value\n\t\texpected []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\texpected: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: []byte(`{\"key1\":\"value1\",\"key2\":42}`),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"item1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: []byte(`[\"item1\",42,true]`),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\\\"world\",\n\t\t\t},\n\t\t\texpected: []byte(`\"hello\\\"world\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42.5\",\n\t\t\t},\n\t\t\texpected: []byte(\"42.5\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\texpected: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\texpected: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\texpected: []byte(\"null\"),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdst := make([]byte, 0, 100)\n\t\t\tresult := tc.v.MarshalTo(dst)\n\t\t\tif !reflect.DeepEqual(result, tc.expected) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %q, expected %q\", result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "56d6cf5f0d301863de996118db5b3f31": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: []string{\"hello\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello\\\"world\"`,\n\t\t\texpected: []string{\"hello\\\"world\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello\\\"world\\\"foo\"`,\n\t\t\texpected: []string{\"hello\\\"world\\\"foo\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with no closing quote\",\n\t\t\tinput:    `\"hello`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\ts, rest, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif s != tc.expected[0] || rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = %q, %q, want %q, %q\", tc.input, s, rest, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "53b23725d802bd896fea42c9c410de4c": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"too big depth\",\n\t\t\tinput:    \"{}\", // Assuming MaxDepth is 1\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds 1\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"valid object\",\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{\n\t\t\t\t\t\t\tt: typeRawString,\n\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid true\",\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid false\",\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid null\",\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"42\",\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42\",\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, expected %v\", tc.input, err, tc.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else if tc.err != nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = nil, expected %v\", tc.input, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, expected %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\to1, _ := v1.Object()\n\t\to2, _ := v2.Object()\n\t\tif len(o1.kvs) != len(o2.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, kv1 := range o1.kvs {\n\t\t\tkv2 := o2.kvs[i]\n\t\t\tif kv1.k != kv2.k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !compareValues(kv1.v, kv2.v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\tcase TypeArray:\n\t\ta1, _ := v1.Array()\n\t\ta2, _ := v2.Array()\n\t\tif len(a1) != len(a2) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, v1 := range a1 {\n\t\t\tif !compareValues(v1, a2[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\tcase typeRawString, TypeNumber, TypeTrue, TypeFalse, TypeNull:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\tpanic(\"unknown type\")\n\t}\n\treturn true\n}",
    "58c7405e774342bc9822664969457783": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello world\"`,\n\t\t\texpected: []string{\"hello world\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello \\\"world\\\"\"`,\n\t\t\texpected: []string{\"hello \\\"world\\\"\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello \\\"world\\\" \\\"foo\\\"\"`,\n\t\t\texpected: []string{\"hello \\\"world\\\" \\\"foo\\\"\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with no closing quote\",\n\t\t\tinput:    `\"hello world`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot1, got2, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got1 != tc.expected[0] || got2 != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = (%q, %q), want (%q, %q)\", tc.input, got1, got2, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "59947fc5320ff2dac77bc86ecff32065": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: []string{\"hello\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello\\\"world\"`,\n\t\t\texpected: []string{\"hello\\\"world\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello\\\"world\\\"foo\"`,\n\t\t\texpected: []string{\"hello\\\"world\\\"foo\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with no closing quote\",\n\t\t\tinput:    `\"hello`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot, got2, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tc.expected[0] {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, expected %v\", got, tc.expected[0])\n\t\t\t}\n\t\t\tif got2 != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawString() got2 = %v, expected %v\", got2, tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "55ab33cd70885a9d7bec39d7c6952a4f": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"too big depth\",\n\t\t\tinput:    \"{}\", // Assuming MaxDepth is 1\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds 1\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"valid object\",\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{s: \"value\", t: typeRawString}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"1\", t: TypeNumber},\n\t\t\t\t\t{s: \"2\", t: TypeNumber},\n\t\t\t\t\t{s: \"3\", t: TypeNumber},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{s: \"hello\", t: typeRawString},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid true\",\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid false\",\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid null\",\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"42\",\n\t\t\texpected: &Value{s: \"42\", t: TypeNumber},\n\t\t\terr:      nil,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, expected %v\", tc.input, err, tc.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else if tc.err != nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = nil, expected %v\", tc.input, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, expected %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn compareObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn compareArrays(v1.a, v2.a)\n\tcase typeRawString, TypeNumber, TypeTrue, TypeFalse, TypeNull:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc compareObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc compareArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tif !compareValues(v1, a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "5babdb3951265dc321e891198b96edd4": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestHasSpecialChars(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname:     \"Empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"String with double quote\",\n\t\t\tinput:    \"hello\\\"world\",\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"String with backslash\",\n\t\t\tinput:    \"hello\\\\world\",\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"String with control character\",\n\t\t\tinput:    \"hello\\nworld\",\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"String with no special characters\",\n\t\t\tinput:    \"helloworld\",\n\t\t\texpected: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := hasSpecialChars(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"hasSpecialChars(%q) = %v, expected %v\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "5918e72973e48fabd54b0b57cef2017c": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape double quote\",\n\t\t\tinput:    \"\\\"hello, world\\\"\",\n\t\t\texpected: `\"hello, world\"`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backslash\",\n\t\t\tinput:    \"\\\\hello, world\\\\\",\n\t\t\texpected: `\\hello, world\\`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape forward slash\",\n\t\t\tinput:    \"/hello, world/\",\n\t\t\texpected: `/hello, world/`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backspace\",\n\t\t\tinput:    \"h\\bello, world\",\n\t\t\texpected: \"h\\bello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape form feed\",\n\t\t\tinput:    \"h\\fello, world\",\n\t\t\texpected: \"h\\fello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape newline\",\n\t\t\tinput:    \"h\\nello, world\",\n\t\t\texpected: \"h\\nello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape carriage return\",\n\t\t\tinput:    \"h\\rello, world\",\n\t\t\texpected: \"h\\rello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape tab\",\n\t\t\tinput:    \"h\\tello, world\",\n\t\t\texpected: \"h\\tello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Unicode character\",\n\t\t\tinput:    \"\\\\u00a9 hello, world\",\n\t\t\texpected: \"Â© hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape surrogate pair\",\n\t\t\tinput:    \"\\\\ud83d\\\\ude00 hello, world\",\n\t\t\texpected: \"ðŸ˜€ hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid escape sequence\",\n\t\t\tinput:    \"\\\\x hello, world\",\n\t\t\texpected: \"\\\\x hello, world\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "58c88278ce1d66a2a2e9a8ffad165b22": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: \"{}\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs:           []kv{},\n\t\t\t\t\t\tkeysUnescaped: true,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with one key-value pair\",\n\t\t\tinput: `{\"key\":\"value\"}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tkeysUnescaped: true,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with multiple key-value pairs\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":123,\"key3\":true}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tkeysUnescaped: true,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":123`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv, _, err := parseObject(tt.input, c, 0)\n\t\t\tif (err != nil) != tt.err {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !v.Equal(tt.expected) {\n\t\t\t\tt.Errorf(\"parseObject() = %v, want %v\", v, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "5839b963b0f00d47ba1ea71416983cae": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"valid JSON\",\n\t\t\tinput: `{\"key1\": \"value1\", \"key2\": 42}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{s: \"value1\", t: TypeString}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{s: \"42\", t: TypeNumber}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"invalid JSON\",\n\t\t\tinput: `{\"key1\": \"value1\", \"key2\": 42,}`,\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty input\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tp := &Parser{}\n\t\t\tactual, err := p.Parse(tc.input)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"Parse(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !equalValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"Parse(%q) = %v, want %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn equalObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn equalArrays(v1.a, v2.a)\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber, TypeTrue, TypeFalse:\n\t\treturn v1.s == v2.s\n\tcase TypeNull:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc equalObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !equalValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc equalArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tif !equalValues(v1, a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "5d423fabd7fd94b752240bfb62492b92": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestGetArray(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tvalue *Value\n\t\tkeys  []string\n\t\twant  []*Value\n\t}{\n\t\t{\n\t\t\tname: \"existing keys path\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"foo\"},\n\t\t\t\t\t{s: \"bar\"},\n\t\t\t\t\t{s: \"baz\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys: []string{\"0\", \"1\", \"2\"},\n\t\t\twant: []*Value{\n\t\t\t\t{s: \"foo\"},\n\t\t\t\t{s: \"bar\"},\n\t\t\t\t{s: \"baz\"},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"non-existing keys path\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"foo\", v: &Value{s: \"bar\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys: []string{\"non-existing\"},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid value type\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"foo\",\n\t\t\t},\n\t\t\tkeys: []string{\"0\"},\n\t\t\twant: nil,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.value.GetArray(tt.keys...)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"GetArray(%v) = %v, want %v\", tt.keys, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "5ec1cf68f235fec45dbd1b9bba550fd2": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"no escape characters\",\n\t\t\tinput:    \"hello world\",\n\t\t\texpected: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"simple escape characters\",\n\t\t\tinput:    \"hello\\\\\\\"world\\\\\\\\\",\n\t\t\texpected: \"hello\\\"world\\\\\",\n\t\t},\n\t\t{\n\t\t\tname:     \"unicode escape characters\",\n\t\t\tinput:    \"hello\\\\u0041world\\\\u0042\",\n\t\t\texpected: \"helloAwordB\",\n\t\t},\n\t\t{\n\t\t\tname:     \"surrogate pair escape characters\",\n\t\t\tinput:    \"hello\\\\ud83d\\\\ude00world\",\n\t\t\texpected: \"helloðŸ˜€world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid escape characters\",\n\t\t\tinput:    \"hello\\\\uworld\\\\u0041\",\n\t\t\texpected: \"hello\\\\uworld\\\\u0041\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "5d9ba318f485a038f98ce79add0f925e": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.456e+7\",\n\t\t\texpected: []string{\"123.456e+7\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with leading/trailing whitespace\",\n\t\t\tinput:    \"  123.456e+7  \",\n\t\t\texpected: []string{\"123.456e+7\", \"  \"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with invalid character\",\n\t\t\tinput:    \"123.456x\",\n\t\t\texpected: []string{\"\", \"123.456x\"},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"inf\",\n\t\t\tinput:    \"inf\",\n\t\t\texpected: []string{\"inf\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"nan\",\n\t\t\tinput:    \"nan\",\n\t\t\texpected: []string{\"nan\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.expected[0] || rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = (%q, %q), want (%q, %q)\", tc.input, num, rest, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "5871d8de5bda10f9c2f0957142902f82": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"too big depth\",\n\t\t\tinput:    \"{}\", // Assuming MaxDepth is 1\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds 1\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"valid object\",\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{\n\t\t\t\t\t\t\tt: typeRawString,\n\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid true\",\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid false\",\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid null\",\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"42\",\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42\",\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, expected %v\", tc.input, err, tc.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else if tc.err != nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = nil, expected %v\", tc.input, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !equalValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, expected %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn equalObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn equalArrays(v1.a, v2.a)\n\tcase typeRawString, TypeNumber, TypeTrue, TypeFalse, TypeNull:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc equalObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !equalValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc equalArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tif !equalValues(v1, a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "5f00dfe65b2cd06b1edd54aff1a38985": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestTypeString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    Type\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"TypeObject\",\n\t\t\tinput:    TypeObject,\n\t\t\texpected: \"object\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeArray\",\n\t\t\tinput:    TypeArray,\n\t\t\texpected: \"array\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeString\",\n\t\t\tinput:    TypeString,\n\t\t\texpected: \"string\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeNumber\",\n\t\t\tinput:    TypeNumber,\n\t\t\texpected: \"number\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeTrue\",\n\t\t\tinput:    TypeTrue,\n\t\t\texpected: \"true\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeFalse\",\n\t\t\tinput:    TypeFalse,\n\t\t\texpected: \"false\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeNull\",\n\t\t\tinput:    TypeNull,\n\t\t\texpected: \"null\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Unknown Type\",\n\t\t\tinput:    Type(100),\n\t\t\texpected: \"BUG: unknown Value type: 100\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := tc.input.String()\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"expected %q, got %q\", tc.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "5f2d638daec8a7a43d52ea4a7cee1688": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestType(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant Type\n\t}{\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv:    &Value{t: TypeNull},\n\t\t\twant: TypeNull,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv:    &Value{t: TypeObject},\n\t\t\twant: TypeObject,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv:    &Value{t: TypeArray},\n\t\t\twant: TypeArray,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv:    &Value{t: TypeString},\n\t\t\twant: TypeString,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv:    &Value{t: TypeNumber},\n\t\t\twant: TypeNumber,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv:    &Value{t: TypeTrue},\n\t\t\twant: TypeTrue,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv:    &Value{t: TypeFalse},\n\t\t\twant: TypeFalse,\n\t\t},\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv:    &Value{t: typeRawString},\n\t\t\twant: typeRawString,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := tc.v.Type()\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"Type() = %v, want %v\", got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "59b8e71ef0b4aca2099db261e7678633": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: \"{}\",\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           []kv{},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with one key-value pair\",\n\t\t\tinput: `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with multiple key-value pairs\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42,\"key3\":true}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"42\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\tinput: `{\"key1\":\"value1\",`,\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing colon\",\n\t\t\tinput: `{\"key1\" \"value1\"}`,\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing comma\",\n\t\t\tinput: `{\"key1\":\"value1\" \"key2\":\"value2\"}`,\n\t\t\terr:   true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{\n\t\t\t\tvs: make([]Value, 0, 8),\n\t\t\t}\n\t\t\tactual, _, err := parseObject(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !equalValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn equalObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn equalArrays(v1.a, v2.a)\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber, TypeTrue, TypeFalse:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\treturn true\n\t}\n}\n\nfunc equalObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !equalValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc equalArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tif !equalValues(v1, a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "5da18abcb95e96380f9c8fd275d622fd": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape double quote\",\n\t\t\tinput:    \"\\\"hello, world\\\"\",\n\t\t\texpected: `\"hello, world\"`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backslash\",\n\t\t\tinput:    \"\\\\hello, world\\\\\",\n\t\t\texpected: `\\hello, world\\`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape forward slash\",\n\t\t\tinput:    \"/hello, world/\",\n\t\t\texpected: `/hello, world/`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backspace\",\n\t\t\tinput:    \"h\\bello, world\",\n\t\t\texpected: \"h\\bello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape form feed\",\n\t\t\tinput:    \"h\\fello, world\",\n\t\t\texpected: \"h\\fello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape newline\",\n\t\t\tinput:    \"h\\nello, world\",\n\t\t\texpected: \"h\\nello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape carriage return\",\n\t\t\tinput:    \"h\\rello, world\",\n\t\t\texpected: \"h\\rello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape tab\",\n\t\t\tinput:    \"h\\tello, world\",\n\t\t\texpected: \"h\\tello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Unicode\",\n\t\t\tinput:    \"\\\\u0041\\\\u0042\\\\u0043\",\n\t\t\texpected: \"ABC\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Surrogate Pair\",\n\t\t\tinput:    \"\\\\ud83d\\\\ude00\",\n\t\t\texpected: \"ðŸ˜€\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid Escape Sequence\",\n\t\t\tinput:    \"\\\\uABCD\",\n\t\t\texpected: \"\\\\uABCD\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "5cd64ad2aa4560244f16feafbdcdc631": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: \"{}\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with one key-value pair\",\n\t\t\tinput: `{\"key\":\"value\"}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with multiple key-value pairs\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42,\"key3\":true}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\ts: \"42\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing key\",\n\t\t\tinput: `{:42}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing value\",\n\t\t\tinput: `{\"key\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{\n\t\t\t\tvs: make([]Value, 0, 8),\n\t\t\t}\n\t\t\tactual, _, err := parseObject(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn compareObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn compareArrays(v1.a, v2.a)\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber, TypeTrue, TypeFalse:\n\t\treturn v1.s == v2.s\n\tcase TypeNull:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc compareObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc compareArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tif !compareValues(v1, a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "5f7e1b408299a5feceba48dcfcc3c3e6": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: []string{\"hello\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello\\\"world\"`,\n\t\t\texpected: []string{\"hello\\\"world\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello\\\"world\\\"foo\"`,\n\t\t\texpected: []string{\"hello\\\"world\\\"foo\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with no closing quote\",\n\t\t\tinput:    `\"hello`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    `\"\"`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult, rest, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif result != tc.expected[0] {\n\t\t\t\tt.Errorf(\"parseRawString(%q) result = %v, expected %v\", tc.input, result, tc.expected[0])\n\t\t\t}\n\t\t\tif rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawString(%q) rest = %v, expected %v\", tc.input, rest, tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "5d50de60db0396b2d0bd0253f72fb162": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"too deep\",\n\t\t\tinput:    \"{}\", // Assuming MaxDepth is 1\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t},\n\t\t{\n\t\t\tname:     \"valid object\",\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{s: \"value\", t: typeRawString}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"1\", t: TypeNumber},\n\t\t\t\t\t{s: \"2\", t: TypeNumber},\n\t\t\t\t\t{s: \"3\", t: TypeNumber},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{s: \"hello\", t: typeRawString},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid true\",\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid false\",\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid null\",\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"42\",\n\t\t\texpected: &Value{s: \"42\", t: TypeNumber},\n\t\t\terr:      nil,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, expected %v\", tc.input, err, tc.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else if tc.err != nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = nil, expected %v\", tc.input, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, expected %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn compareObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn compareArrays(v1.a, v2.a)\n\tcase typeRawString, TypeNumber, TypeTrue, TypeFalse, TypeNull:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc compareObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc compareArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tif !compareValues(v1, a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "638aa3553dd719f069b9f6dffc648994": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObjectReset(t *testing.T) {\n\t// Create a new Object\n\tobj := &Object{\n\t\tkvs:           []kv{{k: \"key1\", v: &Value{}}, {k: \"key2\", v: &Value{}}},\n\t\tkeysUnescaped: true,\n\t}\n\n\t// Reset the Object\n\tobj.reset()\n\n\t// Verify that the Object has been reset\n\tif len(obj.kvs) != 0 {\n\t\tt.Errorf(\"expected kvs to be empty, got %d\", len(obj.kvs))\n\t}\n\tif obj.keysUnescaped {\n\t\tt.Errorf(\"expected keysUnescaped to be false, got true\")\n\t}\n}",
    "61c8116723a685d16e3b316f3a1002d9": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"no escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"simple escape characters\",\n\t\t\tinput:    \"hello\\\\\\\"world\\\\\\\\\",\n\t\t\texpected: \"hello\\\"world\\\\\",\n\t\t},\n\t\t{\n\t\t\tname:     \"complex escape characters\",\n\t\t\tinput:    \"hello\\\\n\\\\r\\\\t\\\\b\\\\f\\\\/\\\\u0123\\\\u4567\\\\u89ab\\\\ucdef\\\\U0010FFFF\",\n\t\t\texpected: \"hello\\n\\r\\t\\b\\f/\\u0123\\u4567\\u89ab\\ucdef\\U0010FFFF\",\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid escape characters\",\n\t\t\tinput:    \"hello\\\\x\\\\u123\",\n\t\t\texpected: \"hello\\\\x\\\\u123\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "621369ec062ba27fe0667dfb122818cd": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    *Value\n\t\tkeys     []string\n\t\texpected *Object\n\t}{\n\t\t{\n\t\t\tname: \"valid object\",\n\t\t\tinput: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"key1\", \"key2\"},\n\t\t\texpected: &Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:     \"nil input\",\n\t\t\tinput:    nil,\n\t\t\tkeys:     []string{\"key1\", \"key2\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"non-object input\",\n\t\t\tinput: &Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\tkeys:     []string{\"key1\", \"key2\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"non-existing keys\",\n\t\t\tinput: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"key3\", \"key4\"},\n\t\t\texpected: nil,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := tc.input.GetObject(tc.keys...)\n\t\t\tif tc.expected != result {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tc.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "63402e102f86c86928aec807fb0479ab": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.456e+7\",\n\t\t\texpected: []string{\"123.456e+7\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with leading sign\",\n\t\t\tinput:    \"-123.456e+7\",\n\t\t\texpected: []string{\"-123.456e+7\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with leading sign and trailing characters\",\n\t\t\tinput:    \"-123.456e+7abc\",\n\t\t\texpected: []string{\"-123.456e+7\", \"abc\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number with leading characters\",\n\t\t\tinput:    \"abc123.456e+7\",\n\t\t\texpected: []string{\"\", \"abc123.456e+7\"},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number with leading sign and trailing characters\",\n\t\t\tinput:    \"-abc123.456e+7def\",\n\t\t\texpected: []string{\"\", \"-abc123.456e+7def\"},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.expected[0] || rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = (%q, %q), want (%q, %q)\", tc.input, num, rest, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "60373dd5eb43b7806c0c2d73a68b5a1f": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"too deep\",\n\t\t\tinput:    \"{}\", // Assuming MaxDepth is 1\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t},\n\t\t{\n\t\t\tname:     \"valid object\",\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{s: \"value\", t: typeRawString}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"1\", t: TypeNumber},\n\t\t\t\t\t{s: \"2\", t: TypeNumber},\n\t\t\t\t\t{s: \"3\", t: TypeNumber},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{s: \"hello\", t: typeRawString},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid true\",\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid false\",\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid null\",\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"42\",\n\t\t\texpected: &Value{s: \"42\", t: TypeNumber},\n\t\t\terr:      nil,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, expected %v\", tc.input, err, tc.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else if tc.err != nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = nil, expected %v\", tc.input, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, expected %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\to1, _ := v1.Object()\n\t\to2, _ := v2.Object()\n\t\tif len(o1.kvs) != len(o2.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, kv1 := range o1.kvs {\n\t\t\tkv2 := o2.kvs[i]\n\t\t\tif kv1.k != kv2.k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !compareValues(kv1.v, kv2.v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\tcase TypeArray:\n\t\ta1, _ := v1.Array()\n\t\ta2, _ := v2.Array()\n\t\tif len(a1) != len(a2) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, v1 := range a1 {\n\t\t\tif !compareValues(v1, a2[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\tcase typeRawString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber, TypeTrue, TypeFalse, TypeNull:\n\t\treturn v1.s == v2.s\n\t}\n\treturn true\n}",
    "6430a06526b6fe0eb984404080988e8a": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello world\"`,\n\t\t\texpected: []string{\"hello world\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello \\\"world\\\"\"`,\n\t\t\texpected: []string{\"hello \\\"world\\\"\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello \\\"world\\\" \\\"foo\\\"\"`,\n\t\t\texpected: []string{\"hello \\\"world\\\" \\\"foo\\\"\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with no closing quote\",\n\t\t\tinput:    `\"hello world`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot1, got2, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got1 != tc.expected[0] || got2 != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = (%q, %q), want (%q, %q)\", tc.input, got1, got2, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "61b554d4a71f6eec4c4a774e11524106": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: \"{}\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs:           []kv{},\n\t\t\t\t\t\tkeysUnescaped: true,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with one key-value pair\",\n\t\t\tinput: `{\"key\":\"value\"}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tkeysUnescaped: true,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with multiple key-value pairs\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42,\"key3\":true}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\ts: \"42\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tkeysUnescaped: true,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing colon\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\"}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tv, _, err := parseObject(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !compareValues(t, v, tc.expected) {\n\t\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", tc.input, v, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(t *testing.T, v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn compareObjects(t, &v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn compareArrays(t, v1.a, v2.a)\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber, TypeTrue, TypeFalse:\n\t\treturn v1.s == v2.s\n\tcase TypeNull:\n\t\treturn true\n\tdefault:\n\t\tt.Errorf(\"unknown type: %v\", v1.t)\n\t\treturn false\n\t}\n}\n\nfunc compareObjects(t *testing.T, o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(t, kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc compareArrays(t *testing.T, a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tv2 := a2[i]\n\t\tif !compareValues(t, v1, v2) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "63d456ce66116ca7c6f98bdfaf7cb763": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.456e+78\",\n\t\t\texpected: []string{\"123.456e+78\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with leading sign\",\n\t\t\tinput:    \"-123.456e+78\",\n\t\t\texpected: []string{\"-123.456e+78\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with leading sign and space\",\n\t\t\tinput:    \" -123.456e+78\",\n\t\t\texpected: []string{\"\", \" -123.456e+78\"},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with invalid character\",\n\t\t\tinput:    \"123.456a+78\",\n\t\t\texpected: []string{\"\", \"123.456a+78\"},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with inf\",\n\t\t\tinput:    \"inf\",\n\t\t\texpected: []string{\"inf\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with nan\",\n\t\t\tinput:    \"nan\",\n\t\t\texpected: []string{\"nan\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.expected[0] || rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, %q, want %q, %q\", tc.input, num, rest, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "645caff14b02a94bc8655b0b42b8bae0": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: []string{\"hello\", `\"`, nil},\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello\\\"world\"`,\n\t\t\texpected: []string{\"hello\\\"world\", `\"`, nil},\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello\\\"world\\\"foo\"`,\n\t\t\texpected: []string{\"hello\\\"world\\\"foo\", `\"`, nil},\n\t\t},\n\t\t{\n\t\t\tname:     \"string with no closing quote\",\n\t\t\tinput:    `\"hello`,\n\t\t\texpected: []string{\"\", \"\", ErrMissingClosingQuote},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot, gotRest, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tc.expected[0] {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, expected %v\", got, tc.expected[0])\n\t\t\t}\n\t\t\tif gotRest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawString() gotRest = %v, expected %v\", gotRest, tc.expected[1])\n\t\t\t}\n\t\t\tif err != nil && err.Error() != tc.expected[2] {\n\t\t\t\tt.Errorf(\"parseRawString() err = %v, expected %v\", err, tc.expected[2])\n\t\t\t}\n\t\t})\n\t}\n}",
    "65d4ee93a3ee3af7d8087f02220faf12": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_getKV(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\to    *Object\n\t\twant *kv\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\to:    &Object{},\n\t\t\twant: &kv{},\n\t\t},\n\t\t{\n\t\t\tname: \"object with existing kvs\",\n\t\t\to: &Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"key1\", v: &Value{}},\n\t\t\t\t\t{k: \"key2\", v: &Value{}},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: &kv{},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.o.getKV(); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Object.getKV() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "649e83338fd51e1621a05feef82da083": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape double quote\",\n\t\t\tinput:    \"\\\"hello, world\\\"\",\n\t\t\texpected: `\"hello, world\"`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backslash\",\n\t\t\tinput:    \"\\\\hello, world\\\\\",\n\t\t\texpected: `\\hello, world\\`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape forward slash\",\n\t\t\tinput:    \"/hello, world/\",\n\t\t\texpected: `/hello, world/`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backspace\",\n\t\t\tinput:    \"h\\bello, world\",\n\t\t\texpected: \"h\\bello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape form feed\",\n\t\t\tinput:    \"h\\fello, world\",\n\t\t\texpected: \"h\\fello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape newline\",\n\t\t\tinput:    \"h\\nello, world\",\n\t\t\texpected: \"h\\nello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape carriage return\",\n\t\t\tinput:    \"h\\rello, world\",\n\t\t\texpected: \"h\\rello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape tab\",\n\t\t\tinput:    \"h\\tello, world\",\n\t\t\texpected: \"h\\tello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Unicode\",\n\t\t\tinput:    \"\\\\u0041\\\\u0042\\\\u0043\",\n\t\t\texpected: \"ABC\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Surrogate Pair\",\n\t\t\tinput:    \"\\\\ud83d\\\\ude00\",\n\t\t\texpected: \"ðŸ˜€\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid Escape Sequence\",\n\t\t\tinput:    \"\\\\uABCD\",\n\t\t\texpected: \"\\\\uABCD\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "65fc2fe3ed6e0aadf459c8a6722c7911": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCache_getValue(t *testing.T) {\n\tc := &cache{\n\t\tvs: make([]Value, 0, 1),\n\t}\n\n\t// Test when the capacity of the slice is greater than the length\n\tv := c.getValue()\n\tif v == nil {\n\t\tt.Errorf(\"getValue() returned nil\")\n\t}\n\tif len(c.vs) != 2 {\n\t\tt.Errorf(\"expected length of c.vs to be 2, got %d\", len(c.vs))\n\t}\n\n\t// Test when the capacity of the slice is equal to the length\n\tc.vs = c.vs[:1]\n\tv = c.getValue()\n\tif v == nil {\n\t\tt.Errorf(\"getValue() returned nil\")\n\t}\n\tif len(c.vs) != 2 {\n\t\tt.Errorf(\"expected length of c.vs to be 2, got %d\", len(c.vs))\n\t}\n}",
    "61fabe52f811641e8d99fbb89579e7fe": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"too big depth\",\n\t\t\tinput:    \"{}\", // Assuming MaxDepth is 1\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds 1\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"valid object\",\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{\n\t\t\t\t\t\t\tt: typeRawString,\n\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid true\",\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid false\",\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid null\",\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"42\",\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42\",\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, expected %v\", tc.input, err, tc.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else if tc.err != nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = nil, expected %v\", tc.input, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, expected %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn compareObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn compareArrays(v1.a, v2.a)\n\tcase typeRawString, TypeNumber, TypeTrue, TypeFalse, TypeNull:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc compareObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc compareArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tif !compareValues(v1, a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "63cc792ba38391a1dc1494e0e4f7ffab": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: \"{}\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs:           []kv{},\n\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with one key-value pair\",\n\t\t\tinput: `{\"key\":\"value\"}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with multiple key-value pairs\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":123,\"key3\":true}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":123`,\n\t\t\texpected: nil,\n\t\t\terr:    true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tv, _, err := parseObject(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !compareValues(t, v, tc.expected) {\n\t\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", tc.input, v, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(t *testing.T, v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn compareObjects(t, &v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn compareArrays(t, v1.a, v2.a)\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber, TypeTrue, TypeFalse:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\treturn true\n\t}\n}\n\nfunc compareObjects(t *testing.T, o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(t, kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc compareArrays(t *testing.T, a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tv2 := a2[i]\n\t\tif !compareValues(t, v1, v2) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "6731289aaef77b8400d83d46dbc76417": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestHasSpecialChars(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname:     \"Empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"String with double quote\",\n\t\t\tinput:    \"hello\\\"world\",\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"String with backslash\",\n\t\t\tinput:    \"hello\\\\world\",\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"String with control character\",\n\t\t\tinput:    \"hello\\nworld\",\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"String with no special characters\",\n\t\t\tinput:    \"helloworld\",\n\t\t\texpected: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := hasSpecialChars(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"hasSpecialChars(%q) = %v, expected %v\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "668a856045bb7eb8bad1930a3275cef9": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"no escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"simple escape characters\",\n\t\t\tinput:    \"hello\\\\\\\"world\\\\\\\\\",\n\t\t\texpected: \"hello\\\"world\\\\\",\n\t\t},\n\t\t{\n\t\t\tname:     \"unicode escape characters\",\n\t\t\tinput:    \"hello\\\\u0123world\\\\u4567\",\n\t\t\texpected: \"hello\\u0123world\\u4567\",\n\t\t},\n\t\t{\n\t\t\tname:     \"surrogate pair escape characters\",\n\t\t\tinput:    \"hello\\\\ud83d\\\\ude00world\",\n\t\t\texpected: \"helloðŸ˜€world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid escape characters\",\n\t\t\tinput:    \"hello\\\\xyzworld\",\n\t\t\texpected: \"hello\\\\xyzworld\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "6548e1529105cef09542af737bec500c": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty input\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"too deep nested JSON\",\n\t\t\tinput:    \"{\\\"key\\\":{\\\"key2\\\":{\\\"key3\\\":{}}}}\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t},\n\t\t{\n\t\t\tname:     \"valid object\",\n\t\t\tinput:    `{\"key\":\"value\",\"key2\":123}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{s: \"value\", t: typeRawString}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{s: \"123\", t: TypeNumber}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"1\", t: TypeNumber},\n\t\t\t\t\t{s: \"2\", t: TypeNumber},\n\t\t\t\t\t{s: \"3\", t: TypeNumber},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{\n\t\t\t\ts: \"hello\",\n\t\t\t\tt: typeRawString,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid true\",\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid false\",\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid null\",\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.456\",\n\t\t\texpected: &Value{\n\t\t\t\ts: \"123.456\",\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tv, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif tc.err != nil {\n\t\t\t\t\tt.Errorf(\"expected error: %v\", tc.err)\n\t\t\t\t}\n\t\t\t\tif !v.Equal(tc.expected) {\n\t\t\t\t\tt.Errorf(\"unexpected value: got %v, want %v\", v, tc.expected)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}",
    "687b07e488e0a192515ad3f89d12c2ca": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"no escape characters\",\n\t\t\tinput:    \"hello world\",\n\t\t\texpected: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"simple escape characters\",\n\t\t\tinput:    \"hello\\\\\\\"world\\\\\\\\\",\n\t\t\texpected: \"hello\\\"world\\\\\",\n\t\t},\n\t\t{\n\t\t\tname:     \"unicode escape characters\",\n\t\t\tinput:    \"hello\\\\u0123world\\\\u4567\",\n\t\t\texpected: \"hello\\u0123world\\u4567\",\n\t\t},\n\t\t{\n\t\t\tname:     \"surrogate pair escape characters\",\n\t\t\tinput:    \"hello\\\\ud83d\\\\ude00world\",\n\t\t\texpected: \"helloðŸ˜€world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid escape characters\",\n\t\t\tinput:    \"hello\\\\xyzworld\",\n\t\t\texpected: \"hello\\\\xyzworld\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "682443aef2bd906bc6223297b5892cb3": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"no escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"simple escape characters\",\n\t\t\tinput:    \"hello\\\\\\\"world\\\\\\\\\",\n\t\t\texpected: \"hello\\\"world\\\\\",\n\t\t},\n\t\t{\n\t\t\tname:     \"complex escape characters\",\n\t\t\tinput:    \"hello\\\\n\\\\r\\\\t\\\\b\\\\f\\\\/\\\\u0123\\\\u4567\\\\u89ab\\\\ucdef\\\\U00010000\",\n\t\t\texpected: \"hello\\n\\r\\t\\b\\f/\\u0123\\u4567\\u89ab\\ucdef\\U00010000\",\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid escape characters\",\n\t\t\tinput:    \"hello\\\\x\",\n\t\t\texpected: \"hello\\\\x\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "68808cd021a8ac028c0531f9704bfc29": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_getKV(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\to    *Object\n\t\twant *kv\n\t}{\n\t\t{\n\t\t\tname: \"empty kvs\",\n\t\t\to:    &Object{kvs: []kv{}},\n\t\t\twant: &kv{},\n\t\t},\n\t\t{\n\t\t\tname: \"kvs with capacity\",\n\t\t\to:    &Object{kvs: make([]kv, 0, 5)},\n\t\t\twant: &kv{},\n\t\t},\n\t\t{\n\t\t\tname: \"kvs with elements\",\n\t\t\to:    &Object{kvs: []kv{{k: \"key1\", v: &Value{}}, {k: \"key2\", v: &Value{}}}},\n\t\t\twant: &kv{},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.o.getKV(); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Object.getKV() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "6804e2a188450095521d19251089a3cd": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape double quote\",\n\t\t\tinput:    \"\\\"hello, world\\\"\",\n\t\t\texpected: `\"hello, world\"`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backslash\",\n\t\t\tinput:    \"\\\\hello, world\\\\\",\n\t\t\texpected: `\\hello, world\\`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape forward slash\",\n\t\t\tinput:    \"/hello, world/\",\n\t\t\texpected: `/hello, world/`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backspace\",\n\t\t\tinput:    \"h\\bello, world\",\n\t\t\texpected: \"h\\bello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape form feed\",\n\t\t\tinput:    \"h\\fello, world\",\n\t\t\texpected: \"h\\fello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape newline\",\n\t\t\tinput:    \"h\\nello, world\",\n\t\t\texpected: \"h\\nello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape carriage return\",\n\t\t\tinput:    \"h\\rello, world\",\n\t\t\texpected: \"h\\rello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape tab\",\n\t\t\tinput:    \"h\\tello, world\",\n\t\t\texpected: \"h\\tello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Unicode character\",\n\t\t\tinput:    \"\\\\u00A9hello, world\",\n\t\t\texpected: \"Â©hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape invalid Unicode character\",\n\t\t\tinput:    \"\\\\u00Xhello, world\",\n\t\t\texpected: \"\\\\u00Xhello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape surrogate pair\",\n\t\t\tinput:    \"\\\\uD83D\\\\uDE00hello, world\",\n\t\t\texpected: \"ðŸ˜€hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape invalid surrogate pair\",\n\t\t\tinput:    \"\\\\uD83D\\\\uXXXXhello, world\",\n\t\t\texpected: \"\\\\uD83D\\\\uXXXXhello, world\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "6aca4cb03aca002182ddf53b78161961": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestHasSpecialChars(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname:     \"Empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"String with no special characters\",\n\t\t\tinput:    \"hello world\",\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"String with double quote\",\n\t\t\tinput:    \"hello \\\"world\\\"\",\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"String with backslash\",\n\t\t\tinput:    \"hello\\\\world\",\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"String with control character\",\n\t\t\tinput:    \"hello\\nworld\",\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := hasSpecialChars(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"hasSpecialChars(%q) = %v, expected %v\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "69e14af1a1cf177e765068338ea97f04": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestBool(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\texpected bool\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"true\",\n\t\t\tvalue:    &Value{t: TypeTrue},\n\t\t\texpected: true,\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"false\",\n\t\t\tvalue:    &Value{t: TypeFalse},\n\t\t\texpected: false,\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"non-bool\",\n\t\t\tvalue:    &Value{t: TypeString},\n\t\t\texpected: false,\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot, err := tc.value.Bool()\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"Value.Bool() error = %v, wantErr %v\", err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tc.expected {\n\t\t\t\tt.Errorf(\"Value.Bool() = %v, want %v\", got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "667c7903ac2f443de1f8b57d78b53346": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty input\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"depth exceeds MaxDepth\",\n\t\t\tinput:    \"{}\", // Nested JSON with depth 1\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t},\n\t\t{\n\t\t\tname:     \"parse object\",\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{s: \"value\", t: typeRawString}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"parse array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"1\", t: TypeNumber},\n\t\t\t\t\t{s: \"2\", t: TypeNumber},\n\t\t\t\t\t{s: \"3\", t: TypeNumber},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"parse string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{s: \"hello\", t: typeRawString},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"parse true\",\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"parse false\",\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"parse null\",\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"parse number\",\n\t\t\tinput:    \"42\",\n\t\t\texpected: &Value{s: \"42\", t: TypeNumber},\n\t\t\terr:      nil,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, expected %v\", tc.input, err, tc.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else if tc.err != nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = nil, expected %v\", tc.input, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, expected %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn compareObjects(v1.o, v2.o)\n\tcase TypeArray:\n\t\treturn compareArrays(v1.a, v2.a)\n\tcase typeRawString, TypeNumber, TypeTrue, TypeFalse, TypeNull:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc compareObjects(o1, o2 Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc compareArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tif !compareValues(v1, a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "67b025a3b6f0c6ae2fda197859e96ab1": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"too big depth\",\n\t\t\tinput:    \"{}\", // Assuming MaxDepth is 1\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds 1\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"valid object\",\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{s: \"value\", t: typeRawString}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"1\", t: TypeNumber},\n\t\t\t\t\t{s: \"2\", t: TypeNumber},\n\t\t\t\t\t{s: \"3\", t: TypeNumber},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{s: \"hello\", t: typeRawString},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid true\",\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid false\",\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid null\",\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"42\",\n\t\t\texpected: &Value{s: \"42\", t: TypeNumber},\n\t\t\terr:      nil,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, expected %v\", tc.input, err, tc.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else if tc.err != nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = nil, expected %v\", tc.input, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !equalValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, expected %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn equalObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn equalArrays(v1.a, v2.a)\n\tcase typeRawString, TypeNumber, TypeTrue, TypeFalse, TypeNull:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc equalObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !equalValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc equalArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tif !equalValues(v1, a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "6978245fc46d5f25aaf2c8cac4473f73": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.456e+78\",\n\t\t\texpected: []string{\"123.456e+78\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with leading zeros\",\n\t\t\tinput:    \"0123.456\",\n\t\t\texpected: []string{\"0123.456\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with sign\",\n\t\t\tinput:    \"-123.456\",\n\t\t\texpected: []string{\"-123.456\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with exponent\",\n\t\t\tinput:    \"1.2e-3\",\n\t\t\texpected: []string{\"1.2e-3\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number\",\n\t\t\tinput:    \"123.456abc\",\n\t\t\texpected: []string{\"\", \"abc\"},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"inf\",\n\t\t\tinput:    \"inf\",\n\t\t\texpected: []string{\"inf\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"nan\",\n\t\t\tinput:    \"nan\",\n\t\t\texpected: []string{\"nan\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.expected[0] || rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, %q, want %q, %q\", tc.input, num, rest, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "691a36d7ea06c6aa770c81bab56634b6": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape double quote\",\n\t\t\tinput:    \"\\\"hello, world\\\"\",\n\t\t\texpected: `\"hello, world\"`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backslash\",\n\t\t\tinput:    \"\\\\hello, world\\\\\",\n\t\t\texpected: `\\hello, world\\`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape forward slash\",\n\t\t\tinput:    \"/hello, world/\",\n\t\t\texpected: `/hello, world/`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backspace\",\n\t\t\tinput:    \"h\\bello, world\",\n\t\t\texpected: \"h\\bello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape form feed\",\n\t\t\tinput:    \"h\\fello, world\",\n\t\t\texpected: \"h\\fello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape newline\",\n\t\t\tinput:    \"h\\nello, world\",\n\t\t\texpected: \"h\\nello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape carriage return\",\n\t\t\tinput:    \"h\\rello, world\",\n\t\t\texpected: \"h\\rello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape tab\",\n\t\t\tinput:    \"h\\tello, world\",\n\t\t\texpected: \"h\\tello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Unicode character\",\n\t\t\tinput:    \"\\\\u00A9hello, world\",\n\t\t\texpected: \"Â©hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape invalid Unicode character\",\n\t\t\tinput:    \"\\\\u00Xhello, world\",\n\t\t\texpected: \"\\\\u00Xhello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape surrogate pair\",\n\t\t\tinput:    \"\\\\uD83D\\\\uDE00hello, world\",\n\t\t\texpected: \"ðŸ˜€hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape invalid surrogate pair\",\n\t\t\tinput:    \"\\\\uD83D\\\\uXXXXhello, world\",\n\t\t\texpected: \"\\\\uD83D\\\\uXXXXhello, world\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "6b4af14a43e831b21c655ba7bacce0d5": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":\"value1\",\"key2\":42}`),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"str1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`[\"str1\",42,true]`),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42\",\n\t\t\t},\n\t\t\twant: []byte(\"42\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %q, want %q\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "6d3a5822e00fab03ff2f1d46789bc3de": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: []string{\"hello\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello\\\"world\"`,\n\t\t\texpected: []string{\"hello\\\"world\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello\\\"world\\\"foo\"`,\n\t\t\texpected: []string{\"hello\\\"world\\\"foo\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string without closing quote\",\n\t\t\tinput:    `\"hello`,\n\t\t\texpected: []string{},\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot1, got2, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got1 != tc.expected[0] || got2 != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = (%q, %q), want (%q, %q)\", tc.input, got1, got2, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "6d42cc491bb7931af5168fb29d450757": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.456e+7\",\n\t\t\texpected: []string{\"123.456e+7\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with leading sign\",\n\t\t\tinput:    \"-123.456\",\n\t\t\texpected: []string{\"-123.456\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with trailing characters\",\n\t\t\tinput:    \"123.456abc\",\n\t\t\texpected: []string{\"123.456\", \"abc\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number\",\n\t\t\tinput:    \"abc\",\n\t\t\texpected: []string{\"\", \"abc\"},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"infinity\",\n\t\t\tinput:    \"inf\",\n\t\t\texpected: []string{\"inf\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN\",\n\t\t\tinput:    \"nan\",\n\t\t\texpected: []string{\"nan\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.expected[0] || rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = (%q, %q), want (%q, %q)\", tc.input, num, rest, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "68fecac4233379e0ee0add4e25802abc": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty array\",\n\t\t\tinput: \"[]\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with one element\",\n\t\t\tinput: \"[1]\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with multiple elements\",\n\t\t\tinput: \"[1,2,3]\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with trailing comma\",\n\t\t\tinput: \"[1,2,3,]\",\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with missing closing bracket\",\n\t\t\tinput: \"[1,2,3\",\n\t\t\terr:   true,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, _, err := parseArray(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseArray(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !equalValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeArray:\n\t\ta1, _ := v1.Array()\n\t\ta2, _ := v2.Array()\n\t\tif len(a1) != len(a2) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range a1 {\n\t\t\tif !equalValues(a1[i], a2[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeObject:\n\t\to1, _ := v1.Object()\n\t\to2, _ := v2.Object()\n\t\tif o1.Len() != o2.Len() {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range o1.kvs {\n\t\t\tif o1.kvs[i].k != o2.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(o1.kvs[i].v, o2.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeString:\n\t\ts1, _ := v1.StringBytes()\n\t\ts2, _ := v2.StringBytes()\n\t\treturn string(s1) == string(s2)\n\tcase TypeNumber, TypeTrue, TypeFalse:\n\t\treturn v1.s == v2.s\n\tcase TypeNull:\n\t\treturn true\n\tdefault:\n\t\tpanic(\"unknown type\")\n\t}\n}",
    "6d5a8b1708e96dcfd891f4e6f778b2eb": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.45e+6\",\n\t\t\texpected: []string{\"123.45e+6\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with leading sign\",\n\t\t\tinput:    \"-123.45\",\n\t\t\texpected: []string{\"-123.45\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with trailing non-digit\",\n\t\t\tinput:    \"123.45x\",\n\t\t\texpected: []string{\"123.45\", \"x\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty input\",\n\t\t\tinput:    \"\",\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"input with only non-digit\",\n\t\t\tinput:    \"abc\",\n\t\t\texpected: []string{\"\", \"abc\"},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"input with 'inf'\",\n\t\t\tinput:    \"inf\",\n\t\t\texpected: []string{\"\", \"inf\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"input with 'nan'\",\n\t\t\tinput:    \"nan\",\n\t\t\texpected: []string{\"\", \"nan\"},\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.expected[0] || rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = (%q, %q), want (%q, %q)\", tc.input, num, rest, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "6da65682ce259312ae9b4cdb1e73416a": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.456e+7\",\n\t\t\texpected: []string{\"123.456e+7\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with leading zeros\",\n\t\t\tinput:    \"0123.456\",\n\t\t\texpected: []string{\"0123.456\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with sign\",\n\t\t\tinput:    \"-123.456\",\n\t\t\texpected: []string{\"-123.456\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with exponent\",\n\t\t\tinput:    \"1.2e-3\",\n\t\t\texpected: []string{\"1.2e-3\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with exponent and sign\",\n\t\t\tinput:    \"-1.2e+3\",\n\t\t\texpected: []string{\"-1.2e+3\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number\",\n\t\t\tinput:    \"123.456abc\",\n\t\t\texpected: []string{\"\", \"abc\"},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty input\",\n\t\t\tinput:    \"\",\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.expected[0] || rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = (%q, %q), want (%q, %q)\", tc.input, num, rest, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "6e33d0d62a23a8721caad8b3e9af809d": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\targs string\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: \"\",\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no leading whitespace\",\n\t\t\targs: \"hello\",\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading space\",\n\t\t\targs: \" hello\",\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading newline\",\n\t\t\targs: \"\\nhello\",\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading tab\",\n\t\t\targs: \"\\thello\",\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading carriage return\",\n\t\t\targs: \"\\rhello\",\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple leading whitespace\",\n\t\t\targs: \"   \\t\\n\\rhello\",\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"all whitespace\",\n\t\t\targs: \"   \\t\\n\\r\",\n\t\t\twant: \"\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.args); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "6df0d4e5d8c2ff606085628a104b67b6": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.45e+6\",\n\t\t\texpected: []string{\"123.45e+6\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with leading sign\",\n\t\t\tinput:    \"-123.45\",\n\t\t\texpected: []string{\"-123.45\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with trailing characters\",\n\t\t\tinput:    \"123.45abc\",\n\t\t\texpected: []string{\"123.45\", \"abc\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number\",\n\t\t\tinput:    \"abc123\",\n\t\t\texpected: []string{\"\", \"abc123\"},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty input\",\n\t\t\tinput:    \"\",\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.expected[0] || rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = (%q, %q), want (%q, %q)\", tc.input, num, rest, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "6b82b35fcceba03b7e2a861d1ca8a1bc": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"too big depth\",\n\t\t\tinput:    \"{}\", // Assuming MaxDepth is 1\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds 1\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"valid object\",\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{\n\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\tt: typeRawString,\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"1\", t: TypeNumber},\n\t\t\t\t\t{s: \"2\", t: TypeNumber},\n\t\t\t\t\t{s: \"3\", t: TypeNumber},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{\n\t\t\t\ts: \"hello\",\n\t\t\t\tt: typeRawString,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid true\",\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid false\",\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid null\",\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"42\",\n\t\t\texpected: &Value{\n\t\t\t\ts: \"42\",\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, expected %v\", tc.input, err, tc.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else if tc.err != nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = nil, expected %v\", tc.input, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, expected %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn compareObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn compareArrays(v1.a, v2.a)\n\tcase typeRawString, TypeNumber, TypeTrue, TypeFalse, TypeNull:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc compareObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc compareArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tif !compareValues(v1, a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "6e8502e4888bb33c5d31d62ffdb69b41": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape double quote\",\n\t\t\tinput:    \"\\\"hello, world\\\"\",\n\t\t\texpected: `\"hello, world\"`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backslash\",\n\t\t\tinput:    \"\\\\hello, world\\\\\",\n\t\t\texpected: `\\hello, world\\`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape forward slash\",\n\t\t\tinput:    \"/hello, world/\",\n\t\t\texpected: `/hello, world/`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backspace\",\n\t\t\tinput:    \"h\\bello, world\",\n\t\t\texpected: \"h\\bello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape form feed\",\n\t\t\tinput:    \"h\\fello, world\",\n\t\t\texpected: \"h\\fello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape newline\",\n\t\t\tinput:    \"h\\nello, world\",\n\t\t\texpected: \"h\\nello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape carriage return\",\n\t\t\tinput:    \"h\\rello, world\",\n\t\t\texpected: \"h\\rello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape tab\",\n\t\t\tinput:    \"h\\tello, world\",\n\t\t\texpected: \"h\\tello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Unicode character\",\n\t\t\tinput:    \"\\\\u00A9 hello, world\",\n\t\t\texpected: \"Â© hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape surrogate pair\",\n\t\t\tinput:    \"\\\\uD83D\\\\uDE00 hello, world\",\n\t\t\texpected: \"ðŸ˜€ hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid escape sequence\",\n\t\t\tinput:    \"\\\\x hello, world\",\n\t\t\texpected: \"\\\\x hello, world\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "6f51b309595c1399dbabe55956e4e70a": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: []string{\"hello\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello\\\"world\"`,\n\t\t\texpected: []string{\"hello\\\"world\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello\\\"world\\\"foo\"`,\n\t\t\texpected: []string{\"hello\\\"world\\\"foo\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with no closing quote\",\n\t\t\tinput:    `\"hello`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult, remainder, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif result != tc.expected[0] {\n\t\t\t\tt.Errorf(\"parseRawString() result = %v, expected %v\", result, tc.expected[0])\n\t\t\t}\n\t\t\tif remainder != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawString() remainder = %v, expected %v\", remainder, tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "6fab218b3923aaaeb15f025f2a5a7e40": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello world\"`,\n\t\t\texpected: []string{\"hello world\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello \\\"world\\\"\"`,\n\t\t\texpected: []string{\"hello \\\"world\\\"\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello \\\"world\\\" \\\"foo\\\"\"`,\n\t\t\texpected: []string{\"hello \\\"world\\\" \\\"foo\\\"\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with no closing quote\",\n\t\t\tinput:    `\"hello world`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot1, got2, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got1 != tc.expected[0] || got2 != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = (%q, %q), want (%q, %q)\", tc.input, got1, got2, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "6f19aa110e6aa422ecee615bd3adb1ca": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape double quote\",\n\t\t\tinput:    \"\\\"hello, world\\\"\",\n\t\t\texpected: `\"hello, world\"`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backslash\",\n\t\t\tinput:    \"\\\\hello, world\\\\\",\n\t\t\texpected: `\\hello, world\\`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape forward slash\",\n\t\t\tinput:    \"/hello, world/\",\n\t\t\texpected: `/hello, world/`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backspace\",\n\t\t\tinput:    \"h\\bello, world\",\n\t\t\texpected: \"h\\bello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape form feed\",\n\t\t\tinput:    \"h\\fello, world\",\n\t\t\texpected: \"h\\fello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape newline\",\n\t\t\tinput:    \"h\\nello, world\",\n\t\t\texpected: \"h\\nello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape carriage return\",\n\t\t\tinput:    \"h\\rello, world\",\n\t\t\texpected: \"h\\rello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape tab\",\n\t\t\tinput:    \"h\\tello, world\",\n\t\t\texpected: \"h\\tello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Unicode\",\n\t\t\tinput:    \"\\\\u0041\\\\u0042\\\\u0043\",\n\t\t\texpected: \"ABC\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Surrogate Pair\",\n\t\t\tinput:    \"\\\\ud83d\\\\ude00\",\n\t\t\texpected: \"ðŸ˜€\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid Escape Sequence\",\n\t\t\tinput:    \"\\\\uABCD\",\n\t\t\texpected: \"\\\\uABCD\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "6f44ad38d1750d682e4dc5ccc8c22331": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: \"{}\",\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           []kv{},\n\t\t\t\t\tkeysUnescaped: true,\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"simple object\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: true,\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with nested value\",\n\t\t\tinput: `{\"key1\":{\"subkey\":\"subvalue\"}}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{k: \"subkey\", v: &Value{t: TypeString, s: \"subvalue\"}},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: true,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: true,\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42`,\n\t\t\terr:   true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tv, _, err := parseObject(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !v.Equal(tc.expected) {\n\t\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", tc.input, v, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "7058efd0c56b597cc2d9223ff1700ad9": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestVisit(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\to    *Object\n\t\twant [][]byte\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\to:    &Object{},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"single key-value pair\",\n\t\t\to: &Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"key1\", v: &Value{s: \"value1\"}},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: [][]byte{[]byte(\"key1\")},\n\t\t},\n\t\t{\n\t\t\tname: \"multiple key-value pairs\",\n\t\t\to: &Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"key1\", v: &Value{s: \"value1\"}},\n\t\t\t\t\t{k: \"key2\", v: &Value{s: \"value2\"}},\n\t\t\t\t\t{k: \"key3\", v: &Value{s: \"value3\"}},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: [][]byte{[]byte(\"key1\"), []byte(\"key2\"), []byte(\"key3\")},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tvar keys [][]byte\n\t\t\ttt.o.Visit(func(key []byte, v *Value) {\n\t\t\t\tkeys = append(keys, key)\n\t\t\t})\n\n\t\t\tif !reflect.DeepEqual(keys, tt.want) {\n\t\t\t\tt.Errorf(\"Visit() = %v, want %v\", keys, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "6db00f06325b618d849dc56822ae75ec": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty input\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"too deep nested JSON\",\n\t\t\tinput:    \"{\\\"key\\\":{\\\"key2\\\":{\\\"key3\\\":{}}}}\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t},\n\t\t{\n\t\t\tname:     \"valid object\",\n\t\t\tinput:    `{\"key\":\"value\",\"key2\":123}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{s: \"value\", t: typeRawString}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{s: \"123\", t: TypeNumber}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"1\", t: TypeNumber},\n\t\t\t\t\t{s: \"2\", t: TypeNumber},\n\t\t\t\t\t{s: \"3\", t: TypeNumber},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{\n\t\t\t\ts: \"hello\",\n\t\t\t\tt: typeRawString,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid true\",\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid false\",\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid null\",\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.45\",\n\t\t\texpected: &Value{\n\t\t\t\ts: \"123.45\",\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tv, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif tc.err != nil {\n\t\t\t\t\tt.Errorf(\"expected error: %v\", tc.err)\n\t\t\t\t}\n\t\t\t\tif !compareValues(v, tc.expected) {\n\t\t\t\t\tt.Errorf(\"unexpected value: got %v, want %v\", v, tc.expected)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn compareObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn compareArrays(v1.a, v2.a)\n\tcase typeRawString, TypeNumber, TypeTrue, TypeFalse, TypeNull:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc compareObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc compareArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tif !compareValues(v1, a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "6fd24ebeaee11084b0c385bb63aecac6": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"empty array\",\n\t\t\tinput:    \"[]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{}},\n\t\t},\n\t\t{\n\t\t\tname:     \"array with one value\",\n\t\t\tinput:    \"[1]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}}},\n\t\t},\n\t\t{\n\t\t\tname:     \"array with multiple values\",\n\t\t\tinput:    \"[1,2,3]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}, &Value{t: TypeNumber, s: \"2\"}, &Value{t: TypeNumber, s: \"3\"}}},\n\t\t},\n\t\t{\n\t\t\tname:  \"missing closing bracket\",\n\t\t\tinput: \"[1,2,3\",\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"missing comma\",\n\t\t\tinput: \"[1 2]\",\n\t\t\terr:   true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tactual, _, err := parseArray(tc.input, c, 0)\n\t\t\tif tc.err {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"expected error, got nil\")\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tc.expected, actual)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\n\tswitch v1.t {\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !compareValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\t}\n\n\treturn true\n}",
    "706e5a0147669f36804cbc0a3f095f5e": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"no escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"simple escape characters\",\n\t\t\tinput:    \"hello\\\\\\\"world\\\\\\\\\",\n\t\t\texpected: \"hello\\\"world\\\\\",\n\t\t},\n\t\t{\n\t\t\tname:     \"complex escape characters\",\n\t\t\tinput:    \"hello\\\\u0123world\\\\u4567\",\n\t\t\texpected: \"hello\\u0123world\\u4567\",\n\t\t},\n\t\t{\n\t\t\tname:     \"incomplete escape sequence\",\n\t\t\tinput:    \"hello\\\\u0123\",\n\t\t\texpected: \"hello\\\\u0123\",\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid escape sequence\",\n\t\t\tinput:    \"hello\\\\uXYZW\",\n\t\t\texpected: \"hello\\\\uXYZW\",\n\t\t},\n\t\t{\n\t\t\tname:     \"surrogate pair\",\n\t\t\tinput:    \"hello\\\\ud83d\\\\ude00world\",\n\t\t\texpected: \"helloðŸ˜€world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"incomplete surrogate pair\",\n\t\t\tinput:    \"hello\\\\ud83d\",\n\t\t\texpected: \"hello\\\\ud83d\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "706865992798e2e97cf456a24af456c3": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape double quote\",\n\t\t\tinput:    \"\\\"hello, world\\\"\",\n\t\t\texpected: `\"hello, world\"`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backslash\",\n\t\t\tinput:    \"\\\\hello, world\\\\\",\n\t\t\texpected: `\\hello, world\\`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape forward slash\",\n\t\t\tinput:    \"/hello, world/\",\n\t\t\texpected: `/hello, world/`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backspace\",\n\t\t\tinput:    \"h\\bello, world\",\n\t\t\texpected: \"h\\bello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape form feed\",\n\t\t\tinput:    \"h\\fello, world\",\n\t\t\texpected: \"h\\fello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape newline\",\n\t\t\tinput:    \"h\\nello, world\",\n\t\t\texpected: \"h\\nello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape carriage return\",\n\t\t\tinput:    \"h\\rello, world\",\n\t\t\texpected: \"h\\rello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape tab\",\n\t\t\tinput:    \"h\\tello, world\",\n\t\t\texpected: \"h\\tello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Unicode\",\n\t\t\tinput:    \"\\\\u0041\\\\u0042\\\\u0043\",\n\t\t\texpected: \"ABC\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Surrogate Pair\",\n\t\t\tinput:    \"\\\\ud83d\\\\ude00\",\n\t\t\texpected: \"ðŸ˜€\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid Escape Sequence\",\n\t\t\tinput:    \"\\\\uABCD\",\n\t\t\texpected: \"\\\\uABCD\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "70a38a44496c23ee87fb465becf29b01": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":\"value1\",\"key2\":42}`),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"str1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t\t{t: TypeFalse},\n\t\t\t\t\t{t: TypeNull},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`[\"str1\",42,true,false,null]`),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\\\"world\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello\\\"world\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42.5\",\n\t\t\t},\n\t\t\twant: []byte(\"42.5\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %q, want %q\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "71635dd415056a10080843df1cfc642f": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"no leading whitespace\",\n\t\t\tinput:    \"hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading space\",\n\t\t\tinput:    \" hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading tab\",\n\t\t\tinput:    \"\\thello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading newline\",\n\t\t\tinput:    \"\\nhello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading carriage return\",\n\t\t\tinput:    \"\\rhello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple leading whitespace\",\n\t\t\tinput:    \"   \\t\\n\\rhello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"whitespace only\",\n\t\t\tinput:    \"   \\t\\n\\r\",\n\t\t\texpected: \"\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := skipWSSlow(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"skipWSSlow(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "7230092514433d8801df7477caa09618": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantKey  string\n\t\twantRest string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple key\",\n\t\t\tinput:    `\"key\":value`,\n\t\t\twantKey:  \"key\",\n\t\t\twantRest: \":value\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"key with escape sequence\",\n\t\t\tinput:    `\"key\\\"with\\\"escape\":value`,\n\t\t\twantKey:  `key\"with\"escape`,\n\t\t\twantRest: \":value\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing closing quote\",\n\t\t\tinput:    `\"key:value`,\n\t\t\twantKey:  \"\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tkey, rest, err := parseRawKey(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawKey(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif key != tc.wantKey {\n\t\t\t\tt.Errorf(\"parseRawKey(%q) key = %q, want %q\", tc.input, key, tc.wantKey)\n\t\t\t}\n\t\t\tif rest != tc.wantRest {\n\t\t\t\tt.Errorf(\"parseRawKey(%q) rest = %q, want %q\", tc.input, rest, tc.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "73637f7e1e8efbc7668ced1b35bb1c13": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\texpected []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\texpected: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: []byte(`{\"key1\":\"value1\",\"key2\":42}`),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"str1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t\t{t: TypeFalse},\n\t\t\t\t\t{t: TypeNull},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: []byte(`[\"str1\",42,true,false,null]`),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\\\"world\",\n\t\t\t},\n\t\t\texpected: []byte(`\"hello\\\"world\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42.5\",\n\t\t\t},\n\t\t\texpected: []byte(\"42.5\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\texpected: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\texpected: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\texpected: []byte(\"null\"),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdst := make([]byte, 0, 100)\n\t\t\tresult := tc.value.MarshalTo(dst)\n\t\t\tif !reflect.DeepEqual(result, tc.expected) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %q, expected %q\", result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "7401629604b0f70bcbc19d96baaedff5": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"no escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"simple escape characters\",\n\t\t\tinput:    \"hello\\\\\\\"world\\\\\\\\\",\n\t\t\texpected: \"hello\\\"world\\\\\",\n\t\t},\n\t\t{\n\t\t\tname:     \"complex escape characters\",\n\t\t\tinput:    \"hello\\\\n\\\\r\\\\t\\\\b\\\\f\\\\/\\\\u0123\\\\u00a9\\\\ud83d\\\\udc7b\",\n\t\t\texpected: \"hello\\n\\r\\t\\b\\f/\\u0123Â©\\U0001F47B\",\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid escape characters\",\n\t\t\tinput:    \"hello\\\\x\",\n\t\t\texpected: \"hello\\\\x\",\n\t\t},\n\t\t{\n\t\t\tname:     \"incomplete surrogate pair\",\n\t\t\tinput:    \"hello\\\\ud83d\",\n\t\t\texpected: \"hello\\\\ud83d\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "728d133d01cc468ecfd0317cc4c69179": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"valid JSON\",\n\t\t\tinput: `{\"key1\": \"value1\", \"key2\": 42}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{s: \"value1\", t: TypeString}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{s: \"42\", t: TypeNumber}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"invalid JSON\",\n\t\t\tinput: `{\"key1\": \"value1\", \"key2\":`,\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty input\",\n\t\t\tinput:    \"\",\n\t\t\texpected: &Value{},\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tp := &Parser{}\n\t\t\tactual, err := p.Parse(tc.input)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"Parse(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tc.err && !actual.Equal(tc.expected) {\n\t\t\t\tt.Errorf(\"Parse(%q) = %v, want %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc (v *Value) Equal(other *Value) bool {\n\tif v.t != other.t {\n\t\treturn false\n\t}\n\n\tswitch v.t {\n\tcase TypeObject:\n\t\treturn v.o.Equal(&other.o)\n\tcase TypeArray:\n\t\tif len(v.a) != len(other.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, vv := range v.a {\n\t\t\tif !vv.Equal(other.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeString:\n\t\treturn v.s == other.s\n\tcase TypeNumber:\n\t\treturn v.s == other.s\n\tcase TypeTrue, TypeFalse, TypeNull:\n\t\treturn true\n\tdefault:\n\t\tpanic(\"unknown type\")\n\t}\n}\n\nfunc (o *Object) Equal(other *Object) bool {\n\tif len(o.kvs) != len(other.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv := range o.kvs {\n\t\tif kv.k != other.kvs[i].k {\n\t\t\treturn false\n\t\t}\n\t\tif !kv.v.Equal(other.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "74d7cae76125b8d48ca978cf0f627552": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"no leading/trailing whitespace\",\n\t\t\tinput:    \"hello world\",\n\t\t\texpected: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading whitespace\",\n\t\t\tinput:    \"   hello world\",\n\t\t\texpected: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"trailing whitespace\",\n\t\t\tinput:    \"hello world   \",\n\t\t\texpected: \"hello world   \",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading and trailing whitespace\",\n\t\t\tinput:    \"   hello world   \",\n\t\t\texpected: \"hello world   \",\n\t\t},\n\t\t{\n\t\t\tname:     \"all whitespace\",\n\t\t\tinput:    \"   \\t\\n\\r\",\n\t\t\texpected: \"\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := skipWSSlow(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"skipWSSlow(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "73e81573c1097aa5d3bc8873077efe2d": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape double quote\",\n\t\t\tinput:    \"hello, \\\"world\\\"\",\n\t\t\texpected: \"hello, \\\"world\\\"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backslash\",\n\t\t\tinput:    \"hello, \\\\world\\\\\",\n\t\t\texpected: \"hello, \\\\world\\\\\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape forward slash\",\n\t\t\tinput:    \"hello, /world/\",\n\t\t\texpected: \"hello, /world/\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backspace\",\n\t\t\tinput:    \"hello, \\bworld\\b\",\n\t\t\texpected: \"hello, \\bworld\\b\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape form feed\",\n\t\t\tinput:    \"hello, \\fworld\\f\",\n\t\t\texpected: \"hello, \\fworld\\f\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape newline\",\n\t\t\tinput:    \"hello,\\nworld\\n\",\n\t\t\texpected: \"hello,\\nworld\\n\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape carriage return\",\n\t\t\tinput:    \"hello,\\rworld\\r\",\n\t\t\texpected: \"hello,\\rworld\\r\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape tab\",\n\t\t\tinput:    \"hello,\\tworld\\t\",\n\t\t\texpected: \"hello,\\tworld\\t\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Unicode\",\n\t\t\tinput:    \"hello, \\\\u0041world\\\\u0042\",\n\t\t\texpected: \"hello, Aworld B\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Surrogate Pair\",\n\t\t\tinput:    \"hello, \\\\ud83d\\\\ude00world\",\n\t\t\texpected: \"hello, ðŸ˜€world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid Escape Sequence\",\n\t\t\tinput:    \"hello, \\\\xworld\",\n\t\t\texpected: \"hello, \\\\xworld\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "75777daeca0c7bd8df52b21d1b780eff": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":\"value1\",\"key2\":42}`),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"str1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t\t{t: TypeFalse},\n\t\t\t\t\t{t: TypeNull},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`[\"str1\",42,true,false,null]`),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\\\"world\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello\\\"world\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42.5\",\n\t\t\t},\n\t\t\twant: []byte(\"42.5\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %q, want %q\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "724994c4227fea1f6874c6180fbf74e8": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: \"{}\",\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           []kv{},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with one key-value pair\",\n\t\t\tinput: `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with multiple key-value pairs\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":123,\"key3\":true}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\ts: \"true\",\n\t\t\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\tinput: `{\"key\":\"value\"`,\n\t\t\texpected: nil,\n\t\t\terr:    true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing colon\",\n\t\t\tinput: `{\"key\" \"value\"}`,\n\t\t\texpected: nil,\n\t\t\terr:    true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing comma\",\n\t\t\tinput: `{\"key\":\"value\" \"key2\":\"value2\"}`,\n\t\t\texpected: nil,\n\t\t\terr:    true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{\n\t\t\t\tvs: make([]Value, 0, 16),\n\t\t\t}\n\t\t\tactual, _, err := parseObject(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn compareObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn compareArrays(v1.a, v2.a)\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber, TypeTrue, TypeFalse:\n\t\treturn v1.s == v2.s\n\tcase TypeNull:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc compareObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc compareArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tif !compareValues(v1, a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "76c88dee15d18184fd5aae3fde728d6e": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: []string{\"hello\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello\\\"world\"`,\n\t\t\texpected: []string{\"hello\\\"world\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello\\\"world\\\"foo\"`,\n\t\t\texpected: []string{\"hello\\\"world\\\"foo\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with no closing quote\",\n\t\t\tinput:    `\"hello`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot, got2, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tc.expected[0] {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, expected %v\", got, tc.expected[0])\n\t\t\t}\n\t\t\tif got2 != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawString() got2 = %v, expected %v\", got2, tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "753a7a1e99cdb1733921791f2452aeb5": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"empty array\",\n\t\t\tinput:    \"[]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with one element\",\n\t\t\tinput:    \"[1]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with multiple elements\",\n\t\t\tinput:    \"[1,2,3]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}, &Value{t: TypeNumber, s: \"2\"}, &Value{t: TypeNumber, s: \"3\"}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with whitespace\",\n\t\t\tinput:    \"[ 1 , 2 , 3 ]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}, &Value{t: TypeNumber, s: \"2\"}, &Value{t: TypeNumber, s: \"3\"}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing closing bracket\",\n\t\t\tinput:    \"[1,2,3\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tv, _, err := parseArray(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseArray(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !v.Equal(tc.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", tc.input, v, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc (v *Value) Equal(other *Value) bool {\n\tif v == nil && other == nil {\n\t\treturn true\n\t}\n\tif v == nil || other == nil {\n\t\treturn false\n\t}\n\tif v.t != other.t {\n\t\treturn false\n\t}\n\tswitch v.t {\n\tcase TypeArray:\n\t\tif len(v.a) != len(other.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, vv := range v.a {\n\t\t\tif !vv.Equal(other.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeObject:\n\t\treturn v.o.Equal(&other.o)\n\tcase TypeString:\n\t\treturn v.s == other.s\n\tcase TypeNumber:\n\t\treturn v.s == other.s\n\tcase TypeTrue, TypeFalse, TypeNull:\n\t\treturn true\n\tdefault:\n\t\tpanic(\"unknown type\")\n\t}\n}\n\nfunc (o *Object) Equal(other *Object) bool {\n\tif len(o.kvs) != len(other.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv := range o.kvs {\n\t\tif kv.k != other.kvs[i].k {\n\t\t\treturn false\n\t\t}\n\t\tif !kv.v.Equal(other.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "73e9cfe5e08926c7976321a2a9cd9a45": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"too big depth\",\n\t\t\tinput:    \"{}\", // Assuming MaxDepth is 1\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds 1\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"valid object\",\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: typeRawString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid true\",\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid false\",\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid null\",\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"42\",\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42\",\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, expected %v\", tc.input, err, tc.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else if tc.err != nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = nil, expected %v\", tc.input, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, expected %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn compareObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn compareArrays(v1.a, v2.a)\n\tcase typeRawString, TypeNumber, TypeTrue, TypeFalse, TypeNull:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc compareObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc compareArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tif !compareValues(v1, a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "77bce0e6590e4b18937b930f84c13ca1": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: []string{\"hello\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello\\\"world\"`,\n\t\t\texpected: []string{\"hello\\\"world\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello\\\"world\\\"foo\"`,\n\t\t\texpected: []string{\"hello\\\"world\\\"foo\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with no closing quote\",\n\t\t\tinput:    `\"hello`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult, rest, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif result != tc.expected[0] {\n\t\t\t\tt.Errorf(\"parseRawString(%q) result = %v, expected %v\", tc.input, result, tc.expected[0])\n\t\t\t}\n\t\t\tif rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawString(%q) rest = %v, expected %v\", tc.input, rest, tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "798be09ae942c932c643af314a791107": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escaped double quotes\",\n\t\t\tinput:    \"\\\"hello, \\\\\\\"world\\\\\\\"\\\"\",\n\t\t\texpected: \"\\\"hello, \\\"world\\\"\\\"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escaped backslash\",\n\t\t\tinput:    \"hello, \\\\\\\\world\",\n\t\t\texpected: \"hello, \\\\world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escaped forward slash\",\n\t\t\tinput:    \"hello, \\\\/world\",\n\t\t\texpected: \"hello, /world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escaped backspace\",\n\t\t\tinput:    \"hello,\\bworld\",\n\t\t\texpected: \"hello,\\bworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escaped form feed\",\n\t\t\tinput:    \"hello,\\fworld\",\n\t\t\texpected: \"hello,\\fworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escaped newline\",\n\t\t\tinput:    \"hello,\\nworld\",\n\t\t\texpected: \"hello,\\nworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escaped carriage return\",\n\t\t\tinput:    \"hello,\\rworld\",\n\t\t\texpected: \"hello,\\rworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escaped tab\",\n\t\t\tinput:    \"hello,\\tworld\",\n\t\t\texpected: \"hello,\\tworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escaped Unicode character\",\n\t\t\tinput:    \"hello,\\\\u0123world\",\n\t\t\texpected: \"hello,\\u0123world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escaped surrogate pair\",\n\t\t\tinput:    \"hello,\\\\ud83d\\\\ude00world\",\n\t\t\texpected: \"hello,ðŸ˜€world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid escape sequence\",\n\t\t\tinput:    \"hello,\\\\xworld\",\n\t\t\texpected: \"hello,\\\\xworld\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "786947ac52c4718b1416b399695b5978": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"empty array\",\n\t\t\tinput:    \"[]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{}},\n\t\t},\n\t\t{\n\t\t\tname:     \"array with one value\",\n\t\t\tinput:    \"[1]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}}},\n\t\t},\n\t\t{\n\t\t\tname:     \"array with multiple values\",\n\t\t\tinput:    \"[1,2,3]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}, &Value{t: TypeNumber, s: \"2\"}, &Value{t: TypeNumber, s: \"3\"}}},\n\t\t},\n\t\t{\n\t\t\tname:  \"missing closing bracket\",\n\t\t\tinput: \"[1,2,3\",\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"missing comma\",\n\t\t\tinput: \"[1 2]\",\n\t\t\terr:   true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tactual, _, err := parseArray(tc.input, c, 0)\n\t\t\tif tc.err {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"expected error, got nil\")\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !actual.Equal(tc.expected) {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tc.expected, actual)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc (v *Value) Equal(other *Value) bool {\n\tif v.t != other.t {\n\t\treturn false\n\t}\n\n\tswitch v.t {\n\tcase TypeArray:\n\t\tif len(v.a) != len(other.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, vv := range v.a {\n\t\t\tif !vv.Equal(other.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\tcase TypeNumber, TypeString:\n\t\treturn v.s == other.s\n\tcase TypeTrue, TypeFalse, TypeNull:\n\t\treturn true\n\tcase TypeObject:\n\t\treturn v.o.Equal(&other.o)\n\t}\n\n\treturn true\n}\n\nfunc (o *Object) Equal(other *Object) bool {\n\tif len(o.kvs) != len(other.kvs) {\n\t\treturn false\n\t}\n\n\tfor i, kv := range o.kvs {\n\t\totherKV := other.kvs[i]\n\t\tif kv.k != otherKV.k {\n\t\t\treturn false\n\t\t}\n\t\tif !kv.v.Equal(otherKV.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}",
    "782108c696836cbdae2916bc481df792": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"empty array\",\n\t\t\tinput:    \"[]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with one value\",\n\t\t\tinput:    \"[1]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with multiple values\",\n\t\t\tinput:    \"[1,2,3]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}, &Value{t: TypeNumber, s: \"2\"}, &Value{t: TypeNumber, s: \"3\"}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with missing closing bracket\",\n\t\t\tinput:    \"[1,2,3\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with missing comma\",\n\t\t\tinput:    \"[1 2]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tactual, _, err := parseArray(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseArray(%q) error = %v, expected error: %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, expected %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !compareValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !compareValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeTrue, TypeFalse, TypeNull:\n\t\treturn true\n\t}\n\treturn true\n}",
    "7ae139e99d6004412db527f5cec86730": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple key\",\n\t\t\tinput:    `\"key\":`,\n\t\t\texpected: \"key\",\n\t\t},\n\t\t{\n\t\t\tname:     \"key with escape sequence\",\n\t\t\tinput:    `\"key\\\"with\\\"escape\":`,\n\t\t\texpected: `key\"with\"escape`,\n\t\t},\n\t\t{\n\t\t\tname:  \"missing closing quote\",\n\t\t\tinput: `\"key`,\n\t\t\terr:   true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tkey, rest, err := parseRawKey(tc.input)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseRawKey(%q) error = %v, want error: %t\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif key != tc.expected {\n\t\t\t\tt.Errorf(\"parseRawKey(%q) = %q, want %q\", tc.input, key, tc.expected)\n\t\t\t}\n\n\t\t\tif rest != \"\" {\n\t\t\t\tt.Errorf(\"parseRawKey(%q) rest = %q, want empty\", tc.input, rest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "7687ecf07cfcfde6c5776872c4fb9d33": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"too big depth\",\n\t\t\tinput:    \"{}\", // Assuming MaxDepth is 1\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds 1\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"valid object\",\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{s: \"value\", t: typeRawString}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"1\", t: TypeNumber},\n\t\t\t\t\t{s: \"2\", t: TypeNumber},\n\t\t\t\t\t{s: \"3\", t: TypeNumber},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{s: \"hello\", t: typeRawString},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid true\",\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid false\",\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid null\",\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"42\",\n\t\t\texpected: &Value{s: \"42\", t: TypeNumber},\n\t\t\terr:      nil,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, expected %v\", tc.input, err, tc.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else if tc.err != nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = nil, expected %v\", tc.input, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, expected %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\to1, _ := v1.Object()\n\t\to2, _ := v2.Object()\n\t\tif len(o1.kvs) != len(o2.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, kv1 := range o1.kvs {\n\t\t\tkv2 := o2.kvs[i]\n\t\t\tif kv1.k != kv2.k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !compareValues(kv1.v, kv2.v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\tcase TypeArray:\n\t\ta1, _ := v1.Array()\n\t\ta2, _ := v2.Array()\n\t\tif len(a1) != len(a2) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, v1 := range a1 {\n\t\t\tif !compareValues(v1, a2[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\tcase typeRawString, TypeNumber, TypeTrue, TypeFalse, TypeNull:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\tpanic(\"unknown type\")\n\t}\n\treturn true\n}",
    "7b0eb03b9c3c5c2a59058e32333f3f39": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantKey  string\n\t\twantRest string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple key\",\n\t\t\tinput:    `\"key\":value`,\n\t\t\twantKey:  \"key\",\n\t\t\twantRest: \":value\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"key with escape sequence\",\n\t\t\tinput:    `\"key\\\"with\\\"escape\":value`,\n\t\t\twantKey:  `key\"with\"escape`,\n\t\t\twantRest: \":value\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing closing quote\",\n\t\t\tinput:    `\"key:value`,\n\t\t\twantKey:  \"\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tkey, rest, err := parseRawKey(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawKey(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif key != tc.wantKey {\n\t\t\t\tt.Errorf(\"parseRawKey(%q) key = %q, want %q\", tc.input, key, tc.wantKey)\n\t\t\t}\n\t\t\tif rest != tc.wantRest {\n\t\t\t\tt.Errorf(\"parseRawKey(%q) rest = %q, want %q\", tc.input, rest, tc.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "7be990ce79cb1a8b124a128d9ab3387a": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: []string{\"hello\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello\\\"world\"`,\n\t\t\texpected: []string{\"hello\\\"world\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello\\\"world\\\"foo\"`,\n\t\t\texpected: []string{\"hello\\\"world\\\"foo\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with no closing quote\",\n\t\t\tinput:    `\"hello`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult, remainder, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif result != tc.expected[0] {\n\t\t\t\tt.Errorf(\"parseRawString() result = %v, expected %v\", result, tc.expected[0])\n\t\t\t}\n\t\t\tif remainder != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawString() remainder = %v, expected %v\", remainder, tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "76f5fd995e906a4073d48604a7268b3e": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"too deep\",\n\t\t\tinput:    \"{}\", // Assuming MaxDepth is 1\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t},\n\t\t{\n\t\t\tname:     \"valid object\",\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{s: \"value\", t: typeRawString}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"1\", t: TypeNumber},\n\t\t\t\t\t{s: \"2\", t: TypeNumber},\n\t\t\t\t\t{s: \"3\", t: TypeNumber},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{\n\t\t\t\ts: \"hello\",\n\t\t\t\tt: typeRawString,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid true\",\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid false\",\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid null\",\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"42\",\n\t\t\texpected: &Value{\n\t\t\t\ts: \"42\",\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, expected %v\", tc.input, err, tc.err)\n\t\t\t\t}\n\t\t\t} else if tc.err != nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = nil, expected %v\", tc.input, tc.err)\n\t\t\t} else if !equalValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, expected %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn equalObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn equalArrays(v1.a, v2.a)\n\tcase typeRawString, TypeNumber, TypeTrue, TypeFalse, TypeNull:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc equalObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !equalValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc equalArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tif !equalValues(v1, a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "79d8078e796dcbcc4dd823f358ec52aa": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"empty array\",\n\t\t\tinput:    \"[]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with one value\",\n\t\t\tinput:    \"[1]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with multiple values\",\n\t\t\tinput:    \"[1,2,3]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}, &Value{t: TypeNumber, s: \"2\"}, &Value{t: TypeNumber, s: \"3\"}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with trailing comma\",\n\t\t\tinput:    \"[1,2,3,]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with missing closing bracket\",\n\t\t\tinput:    \"[1,2,3\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tactual, _, err := parseArray(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseArray(%q) error = %v, expected error: %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, expected %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeArray:\n\t\ta1, _ := v1.Array()\n\t\ta2, _ := v2.Array()\n\t\tif len(a1) != len(a2) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range a1 {\n\t\t\tif !compareValues(a1[i], a2[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeObject:\n\t\to1, _ := v1.Object()\n\t\to2, _ := v2.Object()\n\t\tif o1.Len() != o2.Len() {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range o1.kvs {\n\t\t\tif o1.kvs[i].k != o2.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !compareValues(o1.kvs[i].v, o2.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeString:\n\t\ts1, _ := v1.StringBytes()\n\t\ts2, _ := v2.StringBytes()\n\t\treturn string(s1) == string(s2)\n\tcase TypeNumber:\n\t\tf1, _ := v1.Float64()\n\t\tf2, _ := v2.Float64()\n\t\treturn f1 == f2\n\tcase TypeTrue, TypeFalse:\n\t\tb1, _ := v1.Bool()\n\t\tb2, _ := v2.Bool()\n\t\treturn b1 == b2\n\tcase TypeNull:\n\t\treturn true\n\tdefault:\n\t\tpanic(\"unknown type\")\n\t}\n}",
    "7ca549d288828fbe5328bbd86e0db62a": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: []string{\"hello\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello\\\"world\"`,\n\t\t\texpected: []string{\"hello\\\"world\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello\\\"world\\\"foo\"`,\n\t\t\texpected: []string{\"hello\\\"world\\\"foo\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with no closing quote\",\n\t\t\tinput:    `\"hello`,\n\t\t\texpected: []string{},\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot1, got2, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got1 != tc.expected[0] || got2 != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = (%q, %q), want (%q, %q)\", tc.input, got1, got2, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "7dcd4b2020590e522e3b8a940cc501f3": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"no leading whitespace\",\n\t\t\tinput:    \"hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading space\",\n\t\t\tinput:    \" hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading newline\",\n\t\t\tinput:    \"\\nhello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading tab\",\n\t\t\tinput:    \"\\thello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading carriage return\",\n\t\t\tinput:    \"\\rhello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple leading whitespace\",\n\t\t\tinput:    \"  \\t\\r\\nhello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := skipWSSlow(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"skipWSSlow(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "7a92821e0adc82cb85ceea8247358d8a": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: \"{}\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"simple object\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with whitespace\",\n\t\t\tinput: `{ \"key1\" : \"value1\" , \"key2\" : 42 }`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing key\",\n\t\t\tinput: `{:42}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing value\",\n\t\t\tinput: `{\"key1\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tv, _, err := parseObject(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tc.err && !v.Equal(tc.expected) {\n\t\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", tc.input, v, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc (v *Value) Equal(other *Value) bool {\n\tif v == nil && other == nil {\n\t\treturn true\n\t}\n\tif v == nil || other == nil {\n\t\treturn false\n\t}\n\tif v.t != other.t {\n\t\treturn false\n\t}\n\tswitch v.t {\n\tcase TypeObject:\n\t\treturn v.o.Equal(&other.o)\n\tcase TypeArray:\n\t\tif len(v.a) != len(other.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, vv := range v.a {\n\t\t\tif !vv.Equal(other.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeString:\n\t\treturn v.s == other.s\n\tcase TypeNumber:\n\t\treturn v.s == other.s\n\tcase TypeTrue, TypeFalse, TypeNull:\n\t\treturn true\n\tdefault:\n\t\tpanic(\"unknown type\")\n\t}\n}\n\nfunc (o *Object) Equal(other *Object) bool {\n\tif len(o.kvs) != len(other.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv := range o.kvs {\n\t\tif kv.k != other.kvs[i].k {\n\t\t\treturn false\n\t\t}\n\t\tif !kv.v.Equal(other.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "7db1f88e3c96395375451e83de16c5b6": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.456e+7\",\n\t\t\texpected: []string{\"123.456e+7\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with leading zeros\",\n\t\t\tinput:    \"0123.456\",\n\t\t\texpected: []string{\"0123.456\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with sign\",\n\t\t\tinput:    \"-123.456\",\n\t\t\texpected: []string{\"-123.456\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with exponent\",\n\t\t\tinput:    \"1.2e-3\",\n\t\t\texpected: []string{\"1.2e-3\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number\",\n\t\t\tinput:    \"123.456x\",\n\t\t\texpected: []string{\"\", \"123.456x\"},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty input\",\n\t\t\tinput:    \"\",\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"inf\",\n\t\t\tinput:    \"inf\",\n\t\t\texpected: []string{\"inf\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"nan\",\n\t\t\tinput:    \"nan\",\n\t\t\texpected: []string{\"nan\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.expected[0] || rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, %q, want %q, %q\", tc.input, num, rest, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "7e8e562ef2d27c182d546cf4c9a07086": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestGetArray(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tinput string\n\t\tkeys  []string\n\t\twant  []*Value\n\t}{\n\t\t{\n\t\t\tname:  \"valid array\",\n\t\t\tinput: `{\"key1\": [1, 2, 3]}`,\n\t\t\tkeys:  []string{\"key1\"},\n\t\t\twant: []*Value{\n\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"non-existing key\",\n\t\t\tinput: `{\"key1\": [1, 2, 3]}`,\n\t\t\tkeys:  []string{\"key2\"},\n\t\t\twant:  nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"invalid value type\",\n\t\t\tinput: `{\"key1\": \"not an array\"}`,\n\t\t\tkeys:  []string{\"key1\"},\n\t\t\twant:  nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"array index\",\n\t\t\tinput: `{\"key1\": [1, 2, 3]}`,\n\t\t\tkeys:  []string{\"key1\", \"1\"},\n\t\t\twant: []*Value{\n\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv, err := Parse(tt.input)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Parse() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tgot := v.GetArray(tt.keys...)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"GetArray() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "7f4ba0b171c71cd762dba9c2e617f4ff": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetUint(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tjson     string\n\t\tkeys     []string\n\t\texpected uint\n\t}{\n\t\t{\n\t\t\tname:     \"Existing uint value\",\n\t\t\tjson:     `{\"key\": 42}`,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: 42,\n\t\t},\n\t\t{\n\t\t\tname:     \"Existing float value\",\n\t\t\tjson:     `{\"key\": 3.14}`,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"Non-existing key\",\n\t\t\tjson:     `{\"key1\": 42}`,\n\t\t\tkeys:     []string{\"key2\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid value type\",\n\t\t\tjson:     `{\"key\": true}`,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Array index\",\n\t\t\tjson:     `[0, 1, 2]`,\n\t\t\tkeys:     []string{\"1\"},\n\t\t\texpected: 1,\n\t\t},\n\t\t{\n\t\t\tname:     \"Array index with float\",\n\t\t\tjson:     `[0, 1.5, 2]`,\n\t\t\tkeys:     []string{\"1\"},\n\t\t\texpected: 1,\n\t\t},\n\t\t{\n\t\t\tname:     \"Non-existing array index\",\n\t\t\tjson:     `[0, 1, 2]`,\n\t\t\tkeys:     []string{\"3\"},\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tv, err := ParseBytes([]byte(tc.json))\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Failed to parse JSON: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tactual := v.GetUint(tc.keys...)\n\t\t\tif actual != tc.expected {\n\t\t\t\tt.Errorf(\"GetUint(%v) = %d, want %d\", tc.keys, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "7dad3b1c46ec53aac2f667a5953c1862": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape double quote\",\n\t\t\tinput:    \"\\\"hello, world\\\"\",\n\t\t\texpected: `\"hello, world\"`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backslash\",\n\t\t\tinput:    \"\\\\hello, world\\\\\",\n\t\t\texpected: `\\hello, world\\`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape forward slash\",\n\t\t\tinput:    \"/hello, world/\",\n\t\t\texpected: `/hello, world/`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backspace\",\n\t\t\tinput:    \"h\\bello, world\",\n\t\t\texpected: \"h\\bello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape form feed\",\n\t\t\tinput:    \"h\\fello, world\",\n\t\t\texpected: \"h\\fello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape newline\",\n\t\t\tinput:    \"h\\nello, world\",\n\t\t\texpected: \"h\\nello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape carriage return\",\n\t\t\tinput:    \"h\\rello, world\",\n\t\t\texpected: \"h\\rello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape tab\",\n\t\t\tinput:    \"h\\tello, world\",\n\t\t\texpected: \"h\\tello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Unicode character\",\n\t\t\tinput:    \"\\\\u00A9hello, world\",\n\t\t\texpected: \"Â©hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape invalid Unicode character\",\n\t\t\tinput:    \"\\\\u00Xhello, world\",\n\t\t\texpected: \"\\\\u00Xhello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape surrogate pair\",\n\t\t\tinput:    \"\\\\uD83D\\\\uDE00hello, world\",\n\t\t\texpected: \"ðŸ˜€hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape invalid surrogate pair\",\n\t\t\tinput:    \"\\\\uD83D\\\\uXXXXhello, world\",\n\t\t\texpected: \"\\\\uD83D\\\\uXXXXhello, world\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "807d013abe86474680c99a8397c44ef9": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGet(t *testing.T) {\n\t// Test cases\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    *Value\n\t\tkeys     []string\n\t\texpected *Value\n\t}{\n\t\t{\n\t\t\tname: \"Existing key in object\",\n\t\t\tinput: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: &Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"key2\"},\n\t\t\texpected: &Value{t: TypeNumber, s: \"42\"},\n\t\t},\n\t\t{\n\t\t\tname: \"Non-existing key in object\",\n\t\t\tinput: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: &Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"key3\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Existing index in array\",\n\t\t\tinput: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"value1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"1\"},\n\t\t\texpected: &Value{t: TypeNumber, s: \"42\"},\n\t\t},\n\t\t{\n\t\t\tname: \"Non-existing index in array\",\n\t\t\tinput: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"value1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"2\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Nil input\",\n\t\t\tinput:    nil,\n\t\t\tkeys:     []string{\"key1\"},\n\t\t\texpected: nil,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := tc.input.Get(tc.keys...)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"Get(%v) = %v, expected %v\", tc.keys, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "80eb4c1412d255ee46292aae604c32df": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.45e+6\",\n\t\t\texpected: []string{\"123.45e+6\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with leading zeros\",\n\t\t\tinput:    \"0123.45\",\n\t\t\texpected: []string{\"0123.45\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with sign\",\n\t\t\tinput:    \"-123.45\",\n\t\t\texpected: []string{\"-123.45\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with exponent\",\n\t\t\tinput:    \"1.2e-3\",\n\t\t\texpected: []string{\"1.2e-3\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number\",\n\t\t\tinput:    \"123.45x\",\n\t\t\texpected: []string{\"\", \"123.45x\"},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"inf\",\n\t\t\tinput:    \"inf\",\n\t\t\texpected: []string{\"inf\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"nan\",\n\t\t\tinput:    \"nan\",\n\t\t\texpected: []string{\"nan\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.expected[0] || rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, %q, want %q, %q\", tc.input, num, rest, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "7dd7034a21a9529c961f608a308225ae": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: \"{}\",\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           []kv{},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with one key-value pair\",\n\t\t\tinput: `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with multiple key-value pairs\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42,\"key3\":true}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"42\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42`,\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing colon\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\"}`,\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing value\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":}`,\n\t\t\terr:   true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tv, _, err := parseObject(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tc.err && !v.Equal(tc.expected) {\n\t\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", tc.input, v, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "7c09caf0ea87aa843bac1becd45191fc": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty input\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"too deep nested JSON\",\n\t\t\tinput:    \"{\\\"key\\\":{\\\"key2\\\":{\\\"key3\\\":{}}}}\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t},\n\t\t{\n\t\t\tname:     \"valid object\",\n\t\t\tinput:    `{\"key\":\"value\",\"key2\":123}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{s: \"value\", t: typeRawString}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{s: \"123\", t: TypeNumber}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"1\", t: TypeNumber},\n\t\t\t\t\t{s: \"2\", t: TypeNumber},\n\t\t\t\t\t{s: \"3\", t: TypeNumber},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{\n\t\t\t\ts: \"hello\",\n\t\t\t\tt: typeRawString,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid true\",\n\t\t\tinput:    `true`,\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid false\",\n\t\t\tinput:    `false`,\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid null\",\n\t\t\tinput:    `null`,\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    `123`,\n\t\t\texpected: &Value{\n\t\t\t\ts: \"123\",\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid value\",\n\t\t\tinput:    `invalid`,\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"unexpected value found: %q\", \"invalid\"),\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tv, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif tc.err != nil {\n\t\t\t\t\tt.Errorf(\"expected error: %v\", tc.err)\n\t\t\t\t}\n\t\t\t\tif !compareValues(v, tc.expected) {\n\t\t\t\t\tt.Errorf(\"expected %v, got %v\", tc.expected, v)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn compareObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn compareArrays(v1.a, v2.a)\n\tcase typeRawString, TypeNumber, TypeTrue, TypeFalse, TypeNull:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc compareObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc compareArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tif !compareValues(v1, a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "813b6cc65bfab253187227574002ee26": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGet(t *testing.T) {\n\t// Test cases\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    *Value\n\t\tkeys     []string\n\t\texpected *Value\n\t}{\n\t\t{\n\t\t\tname: \"Existing keys path\",\n\t\t\tinput: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{a: []*Value{\n\t\t\t\t\t\t\t{s: \"arr1\"}, {s: \"arr2\"}, {s: \"arr3\"},\n\t\t\t\t\t\t}}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"key1\"},\n\t\t\texpected: &Value{s: \"value1\"},\n\t\t},\n\t\t{\n\t\t\tname: \"Existing array index\",\n\t\t\tinput: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"arr1\"}, {s: \"arr2\"}, {s: \"arr3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"1\"},\n\t\t\texpected: &Value{s: \"arr2\"},\n\t\t},\n\t\t{\n\t\t\tname:     \"Nil input\",\n\t\t\tinput:    nil,\n\t\t\tkeys:     []string{\"key1\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Non-existing keys path\",\n\t\t\tinput: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{s: \"value1\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"key2\", \"key3\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Invalid array index\",\n\t\t\tinput: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"arr1\"}, {s: \"arr2\"}, {s: \"arr3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"3\"},\n\t\t\texpected: nil,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := tc.input.Get(tc.keys...)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"Get(%v) = %v, expected %v\", tc.keys, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "8177a350d4c4cce2597cc004623711f5": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello world\"`,\n\t\t\texpected: []string{\"hello world\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello \\\"world\\\"\"`,\n\t\t\texpected: []string{\"hello \\\"world\\\"\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello \\\"world\\\" \\\"foo\\\"\"`,\n\t\t\texpected: []string{\"hello \\\"world\\\" \\\"foo\\\"\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with no closing quote\",\n\t\t\tinput:    `\"hello world`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot1, got2, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got1 != tc.expected[0] || got2 != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = (%q, %q), want (%q, %q)\", tc.input, got1, got2, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "829f3bee55cc6c18e8df104328bf5e2b": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: []string{\"hello\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello\\\"world\"`,\n\t\t\texpected: []string{\"hello\\\"world\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello\\\"world\\\"foo\"`,\n\t\t\texpected: []string{\"hello\\\"world\\\"foo\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with no closing quote\",\n\t\t\tinput:    `\"hello`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot, got2, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tc.expected[0] {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, expected %v\", got, tc.expected[0])\n\t\t\t}\n\t\t\tif got2 != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawString() got2 = %v, expected %v\", got2, tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "7f60f1b39103ded7daa1b75a4ee76a2d": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"too big depth\",\n\t\t\tinput:    \"{}\", // Assuming MaxDepth is 1\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds 1\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"valid object\",\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{\n\t\t\t\t\t\t\tt: typeRawString,\n\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid true\",\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid false\",\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid null\",\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"42\",\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42\",\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tv, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, expected %v\", tc.input, err, tc.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else if tc.err != nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = nil, expected %v\", tc.input, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !compareValues(v, tc.expected) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, expected %v\", tc.input, v, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\to1, _ := v1.Object()\n\t\to2, _ := v2.Object()\n\t\tif len(o1.kvs) != len(o2.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, kv1 := range o1.kvs {\n\t\t\tkv2 := o2.kvs[i]\n\t\t\tif kv1.k != kv2.k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !compareValues(kv1.v, kv2.v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\tcase TypeArray:\n\t\ta1, _ := v1.Array()\n\t\ta2, _ := v2.Array()\n\t\tif len(a1) != len(a2) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, v1 := range a1 {\n\t\t\tif !compareValues(v1, a2[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\tcase typeRawString, TypeNumber, TypeTrue, TypeFalse, TypeNull:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\tpanic(\"unknown type\")\n\t}\n\treturn true\n}",
    "8717eb40e7c5b1502a86c46aec6f0a2f": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"no escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"simple escape characters\",\n\t\t\tinput:    \"hello\\\\\\\"world\\\\\\\\\",\n\t\t\texpected: \"hello\\\"world\\\\\",\n\t\t},\n\t\t{\n\t\t\tname:     \"unicode escape characters\",\n\t\t\tinput:    \"hello\\\\u0123world\\\\u4567\",\n\t\t\texpected: \"hello\\u0123world\\u4567\",\n\t\t},\n\t\t{\n\t\t\tname:     \"surrogate pair escape characters\",\n\t\t\tinput:    \"hello\\\\ud83d\\\\ude00world\",\n\t\t\texpected: \"helloðŸ˜€world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid escape characters\",\n\t\t\tinput:    \"hello\\\\xyzworld\",\n\t\t\texpected: \"hello\\\\xyzworld\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "8357f5d24e1cdb9aefc22a135c1b9466": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape double quote\",\n\t\t\tinput:    \"\\\"hello, world\\\"\",\n\t\t\texpected: `\"hello, world\"`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backslash\",\n\t\t\tinput:    \"\\\\hello, world\\\\\",\n\t\t\texpected: `\\hello, world\\`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape forward slash\",\n\t\t\tinput:    \"/hello, world/\",\n\t\t\texpected: `/hello, world/`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backspace\",\n\t\t\tinput:    \"h\\bello, world\",\n\t\t\texpected: \"h\\bello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape form feed\",\n\t\t\tinput:    \"h\\fello, world\",\n\t\t\texpected: \"h\\fello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape newline\",\n\t\t\tinput:    \"h\\nello, world\",\n\t\t\texpected: \"h\\nello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape carriage return\",\n\t\t\tinput:    \"h\\rello, world\",\n\t\t\texpected: \"h\\rello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape tab\",\n\t\t\tinput:    \"h\\tello, world\",\n\t\t\texpected: \"h\\tello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Unicode\",\n\t\t\tinput:    \"\\\\u0041\\\\u0042\\\\u0043\",\n\t\t\texpected: \"ABC\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Surrogate Pair\",\n\t\t\tinput:    \"\\\\uD83D\\\\uDE00\",\n\t\t\texpected: \"ðŸ˜€\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid Escape Sequence\",\n\t\t\tinput:    \"\\\\u123\",\n\t\t\texpected: \"\\\\u123\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "846b5a8936b60cdcefab9152a8a78e08": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.456e+7\",\n\t\t\texpected: []string{\"123.456e+7\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with trailing characters\",\n\t\t\tinput:    \"123.456e+7abc\",\n\t\t\texpected: []string{\"123.456e+7\", \"abc\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number\",\n\t\t\tinput:    \"abc\",\n\t\t\texpected: []string{\"\", \"abc\"},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"inf\",\n\t\t\tinput:    \"inf\",\n\t\t\texpected: []string{\"inf\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"nan\",\n\t\t\tinput:    \"nan\",\n\t\t\texpected: []string{\"nan\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.expected[0] || rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = (%q, %q), want (%q, %q)\", tc.input, num, rest, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "880ea0b271ad5f9e12e05cf9dcf137a3": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Simple escape characters\",\n\t\t\tinput:    \"hello\\\\\\\"world\\\\\\\\\",\n\t\t\texpected: \"hello\\\"world\\\\\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Unicode escape characters\",\n\t\t\tinput:    \"hello\\\\u0041world\\\\u0042\",\n\t\t\texpected: \"helloAwordB\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Surrogate pair escape characters\",\n\t\t\tinput:    \"hello\\\\ud83d\\\\ude00world\",\n\t\t\texpected: \"helloðŸ˜€world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid escape characters\",\n\t\t\tinput:    \"hello\\\\xyzworld\",\n\t\t\texpected: \"hello\\\\xyzworld\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "871e93cc734c52c098de30486d1c84ef": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetFloat64(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tjson     string\n\t\tkeys     []string\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"Existing float64 value\",\n\t\t\tjson:     `{\"key\": 3.14}`,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: 3.14,\n\t\t},\n\t\t{\n\t\t\tname:     \"Non-existing key\",\n\t\t\tjson:     `{\"key\": 3.14}`,\n\t\t\tkeys:     []string{\"non-existing\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid value type\",\n\t\t\tjson:     `{\"key\": \"string\"}`,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Array index\",\n\t\t\tjson:     `[1.0, 2.0, 3.0]`,\n\t\t\tkeys:     []string{\"1\"},\n\t\t\texpected: 2.0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Array index with decimal\",\n\t\t\tjson:     `[1.0, 2.0, 3.0]`,\n\t\t\tkeys:     []string{\"1.0\"},\n\t\t\texpected: 2.0,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tv, err := ParseBytes([]byte(tc.json))\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Failed to parse JSON: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tresult := v.GetFloat64(tc.keys...)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"GetFloat64(%v) = %f, want %f\", tc.keys, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "85860e752a54f3e60b619400d8ea0e22": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.456e+78\",\n\t\t\texpected: []string{\"123.456e+78\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with leading zeros\",\n\t\t\tinput:    \"0123.456\",\n\t\t\texpected: []string{\"0123.456\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with sign\",\n\t\t\tinput:    \"-123.456\",\n\t\t\texpected: []string{\"-123.456\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with exponent\",\n\t\t\tinput:    \"1.2e-3\",\n\t\t\texpected: []string{\"1.2e-3\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with exponent and sign\",\n\t\t\tinput:    \"-1.2e+3\",\n\t\t\texpected: []string{\"-1.2e+3\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number\",\n\t\t\tinput:    \"123.456abc\",\n\t\t\texpected: []string{\"\", \"abc\"},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"inf\",\n\t\t\tinput:    \"inf\",\n\t\t\texpected: []string{\"inf\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"nan\",\n\t\t\tinput:    \"nan\",\n\t\t\texpected: []string{\"nan\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.expected[0] || rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = (%q, %q), want (%q, %q)\", tc.input, num, rest, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "88843da73a4c0686070c97ea98d37280": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"empty array\",\n\t\t\tinput:    \"[]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{}},\n\t\t},\n\t\t{\n\t\t\tname:     \"array with one value\",\n\t\t\tinput:    \"[1]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}}},\n\t\t},\n\t\t{\n\t\t\tname:     \"array with multiple values\",\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}, &Value{t: TypeNumber, s: \"2\"}, &Value{t: TypeNumber, s: \"3\"}}},\n\t\t},\n\t\t{\n\t\t\tname:  \"missing closing bracket\",\n\t\t\tinput: \"[1, 2, 3\",\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"missing comma\",\n\t\t\tinput: \"[1 2]\",\n\t\t\terr:   true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tactual, _, err := parseArray(tc.input, c, 0)\n\t\t\tif tc.err {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"expected error, but got none\")\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !actual.Equal(tc.expected) {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tc.expected, actual)\n\t\t\t}\n\t\t})\n\t}\n}",
    "867153df9b6a69ea618b77a3fc27945c": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.456e+7\",\n\t\t\texpected: []string{\"123.456e+7\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with leading zeros\",\n\t\t\tinput:    \"0123.456\",\n\t\t\texpected: []string{\"0123.456\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with sign\",\n\t\t\tinput:    \"-123.456\",\n\t\t\texpected: []string{\"-123.456\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with exponent\",\n\t\t\tinput:    \"1.2e-3\",\n\t\t\texpected: []string{\"1.2e-3\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with invalid character\",\n\t\t\tinput:    \"123.456x\",\n\t\t\texpected: []string{\"\", \"x\"},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with leading zeros and exponent\",\n\t\t\tinput:    \"0123.456e+7\",\n\t\t\texpected: []string{\"0123.456e+7\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with leading sign and exponent\",\n\t\t\tinput:    \"-123.456e+7\",\n\t\t\texpected: []string{\"-123.456e+7\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with leading sign and exponent and plus\",\n\t\t\tinput:    \"+123.456e+7\",\n\t\t\texpected: []string{\"+123.456e+7\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with inf\",\n\t\t\tinput:    \"inf\",\n\t\t\texpected: []string{\"inf\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with nan\",\n\t\t\tinput:    \"nan\",\n\t\t\texpected: []string{\"nan\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.expected[0] || rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, %q, want %q, %q\", tc.input, num, rest, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "88bc848125f2ad9eae9f374f797cdd6d": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Simple escape characters\",\n\t\t\tinput:    \"hello\\\\\\\"world\\\\\\\\\",\n\t\t\texpected: \"hello\\\"world\\\\\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Unicode escape characters\",\n\t\t\tinput:    \"hello\\\\u0123world\\\\u4567\",\n\t\t\texpected: \"hello\\u0123world\\u4567\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Surrogate pair escape characters\",\n\t\t\tinput:    \"hello\\\\ud83d\\\\ude00world\",\n\t\t\texpected: \"helloðŸ˜€world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid escape characters\",\n\t\t\tinput:    \"hello\\\\xyzworld\",\n\t\t\texpected: \"hello\\\\xyzworld\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "88b3d88545e7b71fef3f2ddd387f7e6d": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: []string{\"hello\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello\\\"world\"`,\n\t\t\texpected: []string{\"hello\\\"world\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello\\\"world\\\"foo\"`,\n\t\t\texpected: []string{\"hello\\\"world\\\"foo\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with no closing quote\",\n\t\t\tinput:    `\"hello`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot, got2, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tc.expected[0] {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, expected %v\", got, tc.expected[0])\n\t\t\t}\n\t\t\tif got2 != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawString() got2 = %v, expected %v\", got2, tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "8a92d6cf40fb9967c46b22a97cd7d74c": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"no whitespace\",\n\t\t\tinput:    \"hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading whitespace\",\n\t\t\tinput:    \"   hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"trailing whitespace\",\n\t\t\tinput:    \"hello   \",\n\t\t\texpected: \"hello   \",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading and trailing whitespace\",\n\t\t\tinput:    \"   hello   \",\n\t\t\texpected: \"hello   \",\n\t\t},\n\t\t{\n\t\t\tname:     \"mixed whitespace\",\n\t\t\tinput:    \"\\t \\r\\n hello \\t\\n\\r\",\n\t\t\texpected: \"hello \\t\\n\\r\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := skipWSSlow(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"skipWSSlow(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "8a73b2899763b71a1e7be8fdde02f4a4": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.456e+7\",\n\t\t\texpected: []string{\"123.456e+7\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with leading/trailing whitespace\",\n\t\t\tinput:    \"   123.456e+7   \",\n\t\t\texpected: []string{\"123.456e+7\", \"   \"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number\",\n\t\t\tinput:    \"abc\",\n\t\t\texpected: []string{\"\", \"abc\"},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with 'inf'\",\n\t\t\tinput:    \"inf\",\n\t\t\texpected: []string{\"\", \"inf\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with 'nan'\",\n\t\t\tinput:    \"nan\",\n\t\t\texpected: []string{\"\", \"nan\"},\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.expected[0] {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) num = %q, expected %q\", tc.input, num, tc.expected[0])\n\t\t\t}\n\t\t\tif rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) rest = %q, expected %q\", tc.input, rest, tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "90accc99b0223bbeeeeba3f4b5a0306c": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObjectReset(t *testing.T) {\n\to := &Object{\n\t\tkvs: []kv{\n\t\t\t{k: \"key1\", v: &Value{}},\n\t\t\t{k: \"key2\", v: &Value{}},\n\t\t},\n\t\tkeysUnescaped: true,\n\t}\n\n\to.reset()\n\n\tif len(o.kvs) != 1 {\n\t\tt.Errorf(\"expected length of kvs to be 1, got %d\", len(o.kvs))\n\t}\n\n\tif o.keysUnescaped {\n\t\tt.Errorf(\"expected keysUnescaped to be false, got true\")\n\t}\n}",
    "8f3577abc1e9b4953cc10e31b104475d": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"no leading whitespace\",\n\t\t\tinput:    \"hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading space\",\n\t\t\tinput:    \" hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading newline\",\n\t\t\tinput:    \"\\nhello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading tab\",\n\t\t\tinput:    \"\\thello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading carriage return\",\n\t\t\tinput:    \"\\rhello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple leading whitespace\",\n\t\t\tinput:    \"   \\t\\n\\rhello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := skipWSSlow(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"skipWSSlow(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "8cebbaf56eed54ae7ac1f41dc7bca55a": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello world\"`,\n\t\t\texpected: []string{\"hello world\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello \\\"world\\\"\"`,\n\t\t\texpected: []string{\"hello \\\"world\\\"\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello \\\"world\\\" \\\"foo\\\"\"`,\n\t\t\texpected: []string{\"hello \\\"world\\\" \\\"foo\\\"\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with no closing quote\",\n\t\t\tinput:    `\"hello world`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot1, got2, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got1 != tc.expected[0] {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tc.expected[0])\n\t\t\t}\n\t\t\tif got2 != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawString() got2 = %v, want %v\", got2, tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "8f686768662947d3b2eeeb2bfd5865e5": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"no escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"simple escape characters\",\n\t\t\tinput:    \"hello\\\\\\\"world\\\\\\\\\",\n\t\t\texpected: \"hello\\\"world\\\\\",\n\t\t},\n\t\t{\n\t\t\tname:     \"unicode escape characters\",\n\t\t\tinput:    \"hello\\\\u0123world\\\\u4567\",\n\t\t\texpected: \"hello\\u0123world\\u4567\",\n\t\t},\n\t\t{\n\t\t\tname:     \"surrogate pair escape characters\",\n\t\t\tinput:    \"hello\\\\ud83d\\\\ude00world\",\n\t\t\texpected: \"helloðŸ˜€world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid unicode escape characters\",\n\t\t\tinput:    \"hello\\\\u123world\",\n\t\t\texpected: \"hello\\\\u123world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple escape characters\",\n\t\t\tinput:    \"hello\\\\\\\"\\\\\\\\\\\\b\\\\f\\\\n\\\\r\\\\tworld\",\n\t\t\texpected: \"hello\\\"\\\\\\b\\f\\n\\r\\tworld\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "8bd5ac54a8d97cb3498cac05c38ebb21": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.456e+7\",\n\t\t\texpected: []string{\"123.456e+7\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with leading zeros\",\n\t\t\tinput:    \"0123.456\",\n\t\t\texpected: []string{\"0123.456\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with sign\",\n\t\t\tinput:    \"-123.456\",\n\t\t\texpected: []string{\"-123.456\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with exponent\",\n\t\t\tinput:    \"1.2e-3\",\n\t\t\texpected: []string{\"1.2e-3\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number\",\n\t\t\tinput:    \"123.456abc\",\n\t\t\texpected: []string{\"\", \"abc\"},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"inf\",\n\t\t\tinput:    \"inf\",\n\t\t\texpected: []string{\"inf\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"nan\",\n\t\t\tinput:    \"nan\",\n\t\t\texpected: []string{\"nan\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.expected[0] || rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, %q, want %q, %q\", tc.input, num, rest, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "927442f535b7e4a37d3a499635756263": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"no leading whitespace\",\n\t\t\tinput:    \"hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading space\",\n\t\t\tinput:    \" hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading newline\",\n\t\t\tinput:    \"\\nhello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading tab\",\n\t\t\tinput:    \"\\thello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading carriage return\",\n\t\t\tinput:    \"\\rhello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"trailing whitespace\",\n\t\t\tinput:    \"hello \",\n\t\t\texpected: \"hello \",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading and trailing whitespace\",\n\t\t\tinput:    \" \\t\\nhello \\r\\n\",\n\t\t\texpected: \"hello \\r\\n\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := skipWSSlow(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"skipWSSlow(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "9077a4076d664e3c106ffc6a35892930": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.456e+7\",\n\t\t\texpected: []string{\"123.456e+7\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with leading sign\",\n\t\t\tinput:    \"-123.456\",\n\t\t\texpected: []string{\"-123.456\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with leading sign and exponent\",\n\t\t\tinput:    \"+123.456e-7\",\n\t\t\texpected: []string{\"+123.456e-7\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with invalid character\",\n\t\t\tinput:    \"123.456x\",\n\t\t\texpected: []string{\"\", \"123.456x\"},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with leading inf\",\n\t\t\tinput:    \"inf123\",\n\t\t\texpected: []string{\"inf\", \"123\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with leading nan\",\n\t\t\tinput:    \"nan123\",\n\t\t\texpected: []string{\"nan\", \"123\"},\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.expected[0] || rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = (%q, %q), want (%q, %q)\", tc.input, num, rest, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "931de4c9bc95fb1424329131cacd818c": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"no escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"simple escape characters\",\n\t\t\tinput:    \"hello\\\\\\\"world\\\\\\\\\",\n\t\t\texpected: \"hello\\\"world\\\\\",\n\t\t},\n\t\t{\n\t\t\tname:     \"complex escape characters\",\n\t\t\tinput:    \"hello\\\\n\\\\r\\\\t\\\\b\\\\f\\\\/\\\\u0123\\\\u4567\\\\u89ab\\\\ucdef\\\\U00010000\",\n\t\t\texpected: \"hello\\n\\r\\t\\b\\f/\\u0123\\u4567\\u89ab\\ucdef\\U00010000\",\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid escape characters\",\n\t\t\tinput:    \"hello\\\\x\",\n\t\t\texpected: \"hello\\\\x\",\n\t\t},\n\t\t{\n\t\t\tname:     \"incomplete escape characters\",\n\t\t\tinput:    \"hello\\\\u1234\",\n\t\t\texpected: \"hello\\\\u1234\",\n\t\t},\n\t\t{\n\t\t\tname:     \"surrogate pair escape characters\",\n\t\t\tinput:    \"hello\\\\ud800\\\\udc00\",\n\t\t\texpected: \"hello\\U00010000\",\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid surrogate pair escape characters\",\n\t\t\tinput:    \"hello\\\\ud800\",\n\t\t\texpected: \"hello\\\\ud800\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "944cf59ea2ceb697831d45af4347d2e0": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: []string{\"hello\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello\\\"world\"`,\n\t\t\texpected: []string{\"hello\\\"world\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello\\\"world\\\"foo\"`,\n\t\t\texpected: []string{\"hello\\\"world\\\"foo\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with no closing quote\",\n\t\t\tinput:    `\"hello`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot1, got2, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got1 != tc.expected[0] || got2 != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = (%q, %q), want (%q, %q)\", tc.input, got1, got2, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "973c84c52e171785247ca35616aa1d1f": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWS(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"string with no whitespace\",\n\t\t\tinput:    \"hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"string with leading whitespace\",\n\t\t\tinput:    \"   hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"string with trailing whitespace\",\n\t\t\tinput:    \"hello   \",\n\t\t\texpected: \"hello   \",\n\t\t},\n\t\t{\n\t\t\tname:     \"string with leading and trailing whitespace\",\n\t\t\tinput:    \"   hello   \",\n\t\t\texpected: \"hello   \",\n\t\t},\n\t\t{\n\t\t\tname:     \"string with mixed whitespace\",\n\t\t\tinput:    \"   hello\\t world\\n\",\n\t\t\texpected: \"hello\\t world\\n\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := skipWS(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"skipWS(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "8e7a2d1d824892a379375c34369f029f": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tinput   string\n\t\twantVal *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: \"{}\",\n\t\t\twantVal: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           []kv{},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"simple object\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42}`,\n\t\t\twantVal: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with nested value\",\n\t\t\tinput: `{\"key1\":{\"subkey\":\"subvalue\"}}`,\n\t\t\twantVal: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{\n\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t{k: \"subkey\", v: &Value{t: TypeString, s: \"subvalue\"}},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42`,\n\t\t\twantVal: nil,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tgotVal, _, err := parseObject(tt.input, c, 0)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !compareValues(gotVal, tt.wantVal) {\n\t\t\t\tt.Errorf(\"parseObject() = %v, want %v\", gotVal, tt.wantVal)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn compareObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn compareArrays(v1.a, v2.a)\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeTrue, TypeFalse, TypeNull:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc compareObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc compareArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tif !compareValues(v1, a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "962a6598fdf73728f2ed67799af5edd1": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"valid JSON\",\n\t\t\tinput: `{\"key1\": \"value1\", \"key2\": 42}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{s: \"value1\", t: TypeString}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{s: \"42\", t: TypeNumber}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"invalid JSON\",\n\t\t\tinput: `{\"key1\": \"value1\", \"key2\": 42,}`,\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty input\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tp := &Parser{}\n\t\t\tactual, err := p.Parse(tc.input)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"Parse(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tc.err && !actual.Equal(tc.expected) {\n\t\t\t\tt.Errorf(\"Parse(%q) = %v, want %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "95389a6837d9eb3a84111077fcf4a879": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.45e+6\",\n\t\t\texpected: []string{\"123.45e+6\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with trailing characters\",\n\t\t\tinput:    \"123.45e+6abc\",\n\t\t\texpected: []string{\"123.45e+6\", \"abc\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number\",\n\t\t\tinput:    \"abc\",\n\t\t\texpected: []string{\"\", \"abc\"},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with leading sign\",\n\t\t\tinput:    \"-123.45e+6\",\n\t\t\texpected: []string{\"-123.45e+6\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with leading plus sign\",\n\t\t\tinput:    \"+123.45e+6\",\n\t\t\texpected: []string{\"+123.45e+6\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN\",\n\t\t\tinput:    \"NaN\",\n\t\t\texpected: []string{\"NaN\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.expected[0] || rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = (%q, %q), want (%q, %q)\", tc.input, num, rest, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "98c795bf1798c0c906aef3710ac7839f": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestHasSpecialChars(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname:     \"Empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"String with no special characters\",\n\t\t\tinput:    \"abcdefghijklmnopqrstuvwxyz\",\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"String with backslash\",\n\t\t\tinput:    \"abc\\\\def\",\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"String with control character\",\n\t\t\tinput:    \"abc\\ndef\",\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"String with multiple special characters\",\n\t\t\tinput:    \"abc\\ndef\\\\ghi\",\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := hasSpecialChars(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"hasSpecialChars(%q) = %v, expected %v\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "8eae25ac5e53288751b9137800585cf9": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"too deep\",\n\t\t\tinput:    \"{}\", // Assuming MaxDepth is 1\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t},\n\t\t{\n\t\t\tname:     \"valid object\",\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{\n\t\t\t\t\t\t\tt: typeRawString,\n\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid true\",\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid false\",\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid null\",\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"42\",\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42\",\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tv, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, expected %v\", tc.input, err, tc.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else if tc.err != nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = nil, expected %v\", tc.input, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !compareValues(v, tc.expected) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, expected %v\", tc.input, v, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn compareObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn compareArrays(v1.a, v2.a)\n\tcase typeRawString, TypeNumber, TypeTrue, TypeFalse, TypeNull:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc compareObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc compareArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tif !compareValues(v1, a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "9914998199e4809edead0dd3661441c4": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello world\"`,\n\t\t\texpected: []string{\"hello world\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello \\\"world\\\"\"`,\n\t\t\texpected: []string{\"hello \\\"world\\\"\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello \\\"world\\\" \\\"foo\\\"\"`,\n\t\t\texpected: []string{\"hello \\\"world\\\" \\\"foo\\\"\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with no closing quote\",\n\t\t\tinput:    `\"hello world`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot1, got2, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got1 != tc.expected[0] || got2 != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = (%q, %q), want (%q, %q)\", tc.input, got1, got2, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "97f2c7add671ebe3902cf2bb0b7a7f33": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: \"{}\",\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           []kv{},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with one key-value pair\",\n\t\t\tinput: `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with multiple key-value pairs\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":123,\"key3\":true}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":123`,\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing colon\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\"}`,\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing value\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":}`,\n\t\t\terr:   true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tv, _, err := parseObject(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !v.Equal(tc.expected) {\n\t\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", tc.input, v, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "988e774d0c9bbf8ebec69401aa6197ef": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape double quote\",\n\t\t\tinput:    \"\\\"hello, world\\\"\",\n\t\t\texpected: `\"hello, world\"`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backslash\",\n\t\t\tinput:    \"\\\\hello, world\\\\\",\n\t\t\texpected: `\\hello, world\\`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape forward slash\",\n\t\t\tinput:    \"/hello, world/\",\n\t\t\texpected: `/hello, world/`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backspace\",\n\t\t\tinput:    \"h\\bello, world\",\n\t\t\texpected: \"h\\bello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape form feed\",\n\t\t\tinput:    \"h\\fello, world\",\n\t\t\texpected: \"h\\fello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape newline\",\n\t\t\tinput:    \"h\\nello, world\",\n\t\t\texpected: \"h\\nello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape carriage return\",\n\t\t\tinput:    \"h\\rello, world\",\n\t\t\texpected: \"h\\rello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape tab\",\n\t\t\tinput:    \"h\\tello, world\",\n\t\t\texpected: \"h\\tello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Unicode character\",\n\t\t\tinput:    \"\\\\u00A9hello, world\",\n\t\t\texpected: \"Â©hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape invalid Unicode character\",\n\t\t\tinput:    \"\\\\u00Xhello, world\",\n\t\t\texpected: \"\\\\u00Xhello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape surrogate pair\",\n\t\t\tinput:    \"\\\\uD83D\\\\uDE00hello, world\",\n\t\t\texpected: \"ðŸ˜€hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape invalid surrogate pair\",\n\t\t\tinput:    \"\\\\uD83D\\\\uXXXXhello, world\",\n\t\t\texpected: \"\\\\uD83D\\\\uXXXXhello, world\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "9c63bb399dab302f6903eab6bf141443": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCache_getValue(t *testing.T) {\n\tc := &cache{\n\t\tvs: make([]Value, 0, 1),\n\t}\n\n\t// Test when the capacity of the slice is greater than the length\n\tv := c.getValue()\n\tif v == nil {\n\t\tt.Errorf(\"getValue() returned nil, expected a non-nil Value\")\n\t}\n\tif len(c.vs) != 1 {\n\t\tt.Errorf(\"len(c.vs) = %d, want 1\", len(c.vs))\n\t}\n\n\t// Test when the capacity of the slice is equal to the length\n\tc.vs = c.vs[:cap(c.vs)]\n\tv = c.getValue()\n\tif v == nil {\n\t\tt.Errorf(\"getValue() returned nil, expected a non-nil Value\")\n\t}\n\tif len(c.vs) != 1 {\n\t\tt.Errorf(\"len(c.vs) = %d, want 1\", len(c.vs))\n\t}\n}",
    "9d1c733b765c6e5bb2e318b7bf7b1f1d": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetFloat64(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tinput  *Value\n\t\tkeys   []string\n\t\texpect float64\n\t}{\n\t\t{\n\t\t\tname:   \"existing float64 value\",\n\t\t\tinput:  &Value{s: \"3.14\", t: TypeNumber},\n\t\t\tkeys:   []string{},\n\t\t\texpect: 3.14,\n\t\t},\n\t\t{\n\t\t\tname:   \"non-existing keys path\",\n\t\t\tinput:  &Value{s: \"3.14\", t: TypeNumber},\n\t\t\tkeys:   []string{\"foo\", \"bar\"},\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"invalid value type\",\n\t\t\tinput:  &Value{s: \"true\", t: TypeTrue},\n\t\t\tkeys:   []string{},\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"array index in keys\",\n\t\t\tinput:  &Value{a: []*Value{{s: \"3.14\", t: TypeNumber}}},\n\t\t\tkeys:   []string{\"0\"},\n\t\t\texpect: 3.14,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tresult := test.input.GetFloat64(test.keys...)\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"GetFloat64(%v) = %f, want %f\", test.keys, result, test.expect)\n\t\t\t}\n\t\t})\n\t}\n}",
    "9d722c9775b36fd5ffebc9644db7afd5": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantKey  string\n\t\twantRest string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple key\",\n\t\t\tinput:    `\"key\":value`,\n\t\t\twantKey:  \"key\",\n\t\t\twantRest: \":value\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"key with escape sequence\",\n\t\t\tinput:    `\"key\\\"with\\\"escape\":value`,\n\t\t\twantKey:  `key\"with\"escape`,\n\t\t\twantRest: \":value\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing closing quote\",\n\t\t\tinput:    `\"key:value`,\n\t\t\twantKey:  \"\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tkey, rest, err := parseRawKey(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawKey(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif key != tc.wantKey {\n\t\t\t\tt.Errorf(\"parseRawKey(%q) key = %q, want %q\", tc.input, key, tc.wantKey)\n\t\t\t}\n\t\t\tif rest != tc.wantRest {\n\t\t\t\tt.Errorf(\"parseRawKey(%q) rest = %q, want %q\", tc.input, rest, tc.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "9e0ed56369c9670fc81d5c33642bb3d0": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWS(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"no whitespace\",\n\t\t\tinput:    \"hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading whitespace\",\n\t\t\tinput:    \"   hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"trailing whitespace\",\n\t\t\tinput:    \"hello   \",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading and trailing whitespace\",\n\t\t\tinput:    \"   hello   \",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"mixed whitespace\",\n\t\t\tinput:    \"   hello\\t world\\n\",\n\t\t\texpected: \"hello\\t world\\n\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := skipWS(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"skipWS(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "99f957235d301b83e920e28e6e699f3b": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"empty array\",\n\t\t\tinput:    \"[]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with one value\",\n\t\t\tinput:    \"[1]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with multiple values\",\n\t\t\tinput:    \"[1,2,3]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}, &Value{t: TypeNumber, s: \"2\"}, &Value{t: TypeNumber, s: \"3\"}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with missing closing bracket\",\n\t\t\tinput:    \"[1,2,3\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with missing comma\",\n\t\t\tinput:    \"[1 2]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{vs: make([]Value, 0, 8)}\n\t\t\tactual, _, err := parseArray(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseArray(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(a, b *Value) bool {\n\tif a == nil && b == nil {\n\t\treturn true\n\t}\n\tif a == nil || b == nil {\n\t\treturn false\n\t}\n\tif a.t != b.t {\n\t\treturn false\n\t}\n\tswitch a.t {\n\tcase TypeArray:\n\t\tif len(a.a) != len(b.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range a.a {\n\t\t\tif !compareValues(a.a[i], b.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\tcase TypeObject:\n\t\tif len(a.o.kvs) != len(b.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range a.o.kvs {\n\t\t\tif a.o.kvs[i].k != b.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !compareValues(a.o.kvs[i].v, b.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\tcase TypeString, TypeNumber:\n\t\treturn a.s == b.s\n\tcase TypeTrue, TypeFalse, TypeNull:\n\t\treturn true\n\tdefault:\n\t\tpanic(\"unknown type\")\n\t}\n\treturn true\n}",
    "9ded4cbbfb091b99193517a3125351b6": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"no escape characters\",\n\t\t\tinput:    \"hello world\",\n\t\t\texpected: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"simple escape characters\",\n\t\t\tinput:    \"hello\\\\\\\"world\\\\\\\\\",\n\t\t\texpected: \"hello\\\"world\\\\\",\n\t\t},\n\t\t{\n\t\t\tname:     \"unicode escape characters\",\n\t\t\tinput:    \"hello\\\\u0123world\\\\u4567\",\n\t\t\texpected: \"hello\\u0123world\\u4567\",\n\t\t},\n\t\t{\n\t\t\tname:     \"surrogate pair escape characters\",\n\t\t\tinput:    \"hello\\\\ud83d\\\\ude00world\",\n\t\t\texpected: \"helloðŸ˜€world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid unicode escape characters\",\n\t\t\tinput:    \"hello\\\\u123world\",\n\t\t\texpected: \"hello\\\\u123world\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "9b380eec8fa2e09aba0eeacd0f8da3ef": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape double quote\",\n\t\t\tinput:    \"\\\"hello, world\\\"\",\n\t\t\texpected: `\"hello, world\"`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backslash\",\n\t\t\tinput:    \"\\\\hello, world\\\\\",\n\t\t\texpected: `\\hello, world\\`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape forward slash\",\n\t\t\tinput:    \"/hello, world/\",\n\t\t\texpected: `/hello, world/`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backspace\",\n\t\t\tinput:    \"h\\bello, world\",\n\t\t\texpected: \"h\\bello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape form feed\",\n\t\t\tinput:    \"h\\fello, world\",\n\t\t\texpected: \"h\\fello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape newline\",\n\t\t\tinput:    \"h\\nello, world\",\n\t\t\texpected: \"h\\nello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape carriage return\",\n\t\t\tinput:    \"h\\rello, world\",\n\t\t\texpected: \"h\\rello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape tab\",\n\t\t\tinput:    \"h\\tello, world\",\n\t\t\texpected: \"h\\tello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Unicode character\",\n\t\t\tinput:    \"\\\\u0041hello, world\",\n\t\t\texpected: \"Ahello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape invalid Unicode character\",\n\t\t\tinput:    \"\\\\u004\",\n\t\t\texpected: \"\\\\u004\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape surrogate pair\",\n\t\t\tinput:    \"\\\\ud83d\\\\ude00hello, world\",\n\t\t\texpected: \"ðŸ˜€hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape unknown character\",\n\t\t\tinput:    \"\\\\xhello, world\",\n\t\t\texpected: \"\\\\xhello, world\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "9e524aa14aefac4ab3ed67beab293c90": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"no leading/trailing whitespace\",\n\t\t\tinput:    \"hello world\",\n\t\t\texpected: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading whitespace\",\n\t\t\tinput:    \"   hello world\",\n\t\t\texpected: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"trailing whitespace\",\n\t\t\tinput:    \"hello world   \",\n\t\t\texpected: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading and trailing whitespace\",\n\t\t\tinput:    \"   hello world   \",\n\t\t\texpected: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"only whitespace\",\n\t\t\tinput:    \"   \",\n\t\t\texpected: \"\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := skipWSSlow(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"skipWSSlow(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "9ecd12b15090c9fb41c1b44b254548bd": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: []string{\"hello\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello\\\"world\"`,\n\t\t\texpected: []string{\"hello\\\"world\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello\\\"world\\\"foo\"`,\n\t\t\texpected: []string{\"hello\\\"world\\\"foo\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with no closing quote\",\n\t\t\tinput:    `\"hello`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot, got2, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tc.expected[0] || got2 != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = %q, %q, want %q, %q\", tc.input, got, got2, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "9e07e1684a9175571829fc4b6c2848ae": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGet(t *testing.T) {\n\t// Test cases\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    *Value\n\t\tkeys     []string\n\t\texpected *Value\n\t}{\n\t\t{\n\t\t\tname: \"Existing key in object\",\n\t\t\tinput: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: &Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"key2\"},\n\t\t\texpected: &Value{t: TypeNumber, s: \"42\"},\n\t\t},\n\t\t{\n\t\t\tname: \"Non-existing key in object\",\n\t\t\tinput: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: &Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"key3\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Existing index in array\",\n\t\t\tinput: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"value1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"1\"},\n\t\t\texpected: &Value{t: TypeNumber, s: \"42\"},\n\t\t},\n\t\t{\n\t\t\tname: \"Non-existing index in array\",\n\t\t\tinput: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"value1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"2\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Nil input\",\n\t\t\tinput:    nil,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: nil,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := tc.input.Get(tc.keys...)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"Get(%v) = %v, expected %v\", tc.keys, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "9f91440c10436878372c66e4c407c431": "package fastjson\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n)\n\nfunc TestEscapeString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []byte\n\t}{\n\t\t{\n\t\t\tname:     \"no special characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: []byte(`\"hello, world\"`),\n\t\t},\n\t\t{\n\t\t\tname:     \"with special characters\",\n\t\t\tinput:    `hello, \"world\"`,\n\t\t\texpected: []byte(`\"hello, \\\"world\\\"\"\"`),\n\t\t},\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: []byte(`\"\"`),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdst := make([]byte, 0, len(tc.input)+2)\n\t\t\tresult := escapeString(dst, tc.input)\n\t\t\tif !bytes.Equal(result, tc.expected) {\n\t\t\t\tt.Errorf(\"escapeString(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "9a400049bc667439078b6f295edaa514": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty array\",\n\t\t\tinput: \"[]\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with one value\",\n\t\t\tinput: \"[1]\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with multiple values\",\n\t\t\tinput: \"[1,2,3]\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with trailing comma\",\n\t\t\tinput: \"[1,2,3,]\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with missing closing bracket\",\n\t\t\tinput: \"[1,2,3\",\n\t\t\texpected: nil,\n\t\t\terr:    true,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, _, err := parseArray(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseArray(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !equalValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeArray:\n\t\ta1, _ := v1.Array()\n\t\ta2, _ := v2.Array()\n\t\tif len(a1) != len(a2) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range a1 {\n\t\t\tif !equalValues(a1[i], a2[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeObject:\n\t\to1, _ := v1.Object()\n\t\to2, _ := v2.Object()\n\t\tif o1.Len() != o2.Len() {\n\t\t\treturn false\n\t\t}\n\t\tvar visited = make(map[string]bool)\n\t\tfor _, kv1 := range o1.kvs {\n\t\t\tkv2 := o2.getKV(kv1.k)\n\t\t\tif kv2 == nil {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(kv1.v, kv2.v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tvisited[kv1.k] = true\n\t\t}\n\t\tfor _, kv2 := range o2.kvs {\n\t\t\tif !visited[kv2.k] {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeString:\n\t\ts1, _ := v1.StringBytes()\n\t\ts2, _ := v2.StringBytes()\n\t\treturn string(s1) == string(s2)\n\tcase TypeNumber, TypeTrue, TypeFalse:\n\t\treturn v1.s == v2.s\n\tcase TypeNull:\n\t\treturn true\n\tdefault:\n\t\tpanic(\"unknown type\")\n\t}\n}",
    "9fedd9038220768c2bac39e510f99dc1": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCache_getValue(t *testing.T) {\n\tc := &cache{\n\t\tvs: make([]Value, 0, 1),\n\t}\n\n\t// Test when the capacity of the slice is greater than or equal to the length\n\tv := c.getValue()\n\tif v == nil {\n\t\tt.Errorf(\"getValue() returned nil, expected a non-nil Value\")\n\t}\n\tif len(c.vs) != 1 {\n\t\tt.Errorf(\"len(c.vs) = %d, want 1\", len(c.vs))\n\t}\n\n\t// Test when the capacity of the slice is less than the length\n\tc.vs = c.vs[:cap(c.vs)]\n\tv = c.getValue()\n\tif v == nil {\n\t\tt.Errorf(\"getValue() returned nil, expected a non-nil Value\")\n\t}\n\tif len(c.vs) != 1 {\n\t\tt.Errorf(\"len(c.vs) = %d, want 1\", len(c.vs))\n\t}\n}",
    "a0be294fe6b017709180cd40c5a0fee5": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetFloat64(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tinput  *Value\n\t\tkeys   []string\n\t\texpect float64\n\t}{\n\t\t{\n\t\t\tname:   \"Existing float64 value\",\n\t\t\tinput:  &Value{s: \"3.14\", t: TypeNumber},\n\t\t\tkeys:   []string{},\n\t\t\texpect: 3.14,\n\t\t},\n\t\t{\n\t\t\tname:   \"Non-existing keys path\",\n\t\t\tinput:  &Value{s: \"3.14\", t: TypeNumber},\n\t\t\tkeys:   []string{\"foo\", \"bar\"},\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"Invalid value type\",\n\t\t\tinput:  &Value{s: \"true\", t: TypeTrue},\n\t\t\tkeys:   []string{},\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"Array index in keys\",\n\t\t\tinput:  &Value{a: []*Value{{s: \"3.14\", t: TypeNumber}}},\n\t\t\tkeys:   []string{\"0\"},\n\t\t\texpect: 3.14,\n\t\t},\n\t\t{\n\t\t\tname:   \"Decimal array index in keys\",\n\t\t\tinput:  &Value{a: []*Value{{s: \"3.14\", t: TypeNumber}, {s: \"2.71\", t: TypeNumber}}},\n\t\t\tkeys:   []string{\"1.0\"},\n\t\t\texpect: 2.71,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tresult := test.input.GetFloat64(test.keys...)\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"GetFloat64(%v) = %f, want %f\", test.keys, result, test.expect)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a1df8c3e567b7b354393345c6fe5b1af": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGet(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tinput *Value\n\t\tkeys  []string\n\t\twant  *Value\n\t}{\n\t\t{\n\t\t\tname: \"get from object\",\n\t\t\tinput: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: &Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys: []string{\"key1\"},\n\t\t\twant: &Value{t: TypeString, s: \"value1\"},\n\t\t},\n\t\t{\n\t\t\tname: \"get from array\",\n\t\t\tinput: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"value1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys: []string{\"1\"},\n\t\t\twant: &Value{t: TypeNumber, s: \"42\"},\n\t\t},\n\t\t{\n\t\t\tname:  \"nil input\",\n\t\t\tinput: nil,\n\t\t\tkeys:  []string{\"key1\"},\n\t\t\twant:  nil,\n\t\t},\n\t\t{\n\t\t\tname: \"non-existing key\",\n\t\t\tinput: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: &Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys: []string{\"key2\"},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid array index\",\n\t\t\tinput: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"value1\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys: []string{\"2\"},\n\t\t\twant: nil,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.input.Get(tt.keys...)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Get() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a182a5363911766a168f3e7aaec2dfd7": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\texpected []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\texpected: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: []byte(`{\"key1\":\"value1\",\"key2\":42}`),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"item1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: []byte(`[\"item1\",42,true]`),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\texpected: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42\",\n\t\t\t},\n\t\t\texpected: []byte(\"42\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\texpected: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\texpected: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\texpected: []byte(\"null\"),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdst := make([]byte, 0, 64)\n\t\t\tresult := tc.value.MarshalTo(dst)\n\t\t\tif !reflect.DeepEqual(result, tc.expected) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %q, expected %q\", result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a1999ce8c66e2667b511eb94b5a41394": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.45e+6\",\n\t\t\texpected: []string{\"123.45e+6\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with leading zeros\",\n\t\t\tinput:    \"0123.45\",\n\t\t\texpected: []string{\"0123.45\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with sign\",\n\t\t\tinput:    \"-123.45\",\n\t\t\texpected: []string{\"-123.45\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with exponent\",\n\t\t\tinput:    \"1.2e-3\",\n\t\t\texpected: []string{\"1.2e-3\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number\",\n\t\t\tinput:    \"123.45x\",\n\t\t\texpected: []string{\"\", \"123.45x\"},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty input\",\n\t\t\tinput:    \"\",\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"inf\",\n\t\t\tinput:    \"inf\",\n\t\t\texpected: []string{\"inf\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"nan\",\n\t\t\tinput:    \"nan\",\n\t\t\texpected: []string{\"nan\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.expected[0] || rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, %q, want %q, %q\", tc.input, num, rest, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "a2c3d304cfd86c61fd58859dae8a49a4": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"no escape characters\",\n\t\t\tinput:    \"hello world\",\n\t\t\texpected: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"simple escape characters\",\n\t\t\tinput:    \"hello\\\\\\\"world\\\\\\\\\",\n\t\t\texpected: \"hello\\\"world\\\\\",\n\t\t},\n\t\t{\n\t\t\tname:     \"complex escape characters\",\n\t\t\tinput:    \"hello\\\\u0000world\\\\u1234\\\\u{10FFFF}\",\n\t\t\texpected: \"hello\\x00world\\u1234\\U0010FFFF\",\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid escape characters\",\n\t\t\tinput:    \"hello\\\\uABCD\\\\uXYZ\\\\u123\",\n\t\t\texpected: \"hello\\\\uABCD\\\\uXYZ\\\\u123\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "9f53176c39cd51e97ea861dcb0f5391f": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty input\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"too deep nested JSON\",\n\t\t\tinput:    \"{\\\"key\\\":{\\\"key2\\\":{\\\"key3\\\":{}}}}\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t},\n\t\t{\n\t\t\tname:     \"valid object\",\n\t\t\tinput:    `{\"key\":\"value\",\"key2\":123}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{t: typeRawString, s: \"value\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid true\",\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid false\",\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid null\",\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123\",\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tv, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif tc.err != nil {\n\t\t\t\t\tt.Errorf(\"expected error: %v\", tc.err)\n\t\t\t\t}\n\t\t\t\tif !compareValues(v, tc.expected) {\n\t\t\t\t\tt.Errorf(\"expected %+v, got %+v\", tc.expected, v)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\to1, _ := v1.Object()\n\t\to2, _ := v2.Object()\n\t\tif len(o1.kvs) != len(o2.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, kv1 := range o1.kvs {\n\t\t\tkv2 := o2.kvs[i]\n\t\t\tif kv1.k != kv2.k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !compareValues(kv1.v, kv2.v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\tcase TypeArray:\n\t\ta1, _ := v1.Array()\n\t\ta2, _ := v2.Array()\n\t\tif len(a1) != len(a2) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, v1 := range a1 {\n\t\t\tif !compareValues(v1, a2[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\tcase typeRawString, TypeNumber, TypeTrue, TypeFalse, TypeNull:\n\t\treturn v1.s == v2.s\n\t}\n\treturn true\n}",
    "a26ff4e2909ed2e5edc90ee00447e0ab": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":\"value1\",\"key2\":42}`),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"str1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`[\"str1\",42,true]`),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\\\"world\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello\\\"world\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42.5\",\n\t\t\t},\n\t\t\twant: []byte(\"42.5\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := make([]byte, 0, 64)\n\t\t\tgot := tt.v.MarshalTo(dst)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %q, want %q\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a0373d3677e79e645b6cf3ae1430e524": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty array\",\n\t\t\tinput: \"[]\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with one value\",\n\t\t\tinput: \"[1]\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with multiple values\",\n\t\t\tinput: \"[1, 2, 3]\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with trailing comma\",\n\t\t\tinput: \"[1, 2, 3,]\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with missing closing bracket\",\n\t\t\tinput: \"[1, 2, 3\",\n\t\t\texpected: nil,\n\t\t\terr:    true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tactual, _, err := parseArray(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseArray(%q) error = %v, expected error: %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !equalValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, expected %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeArray:\n\t\ta1, _ := v1.Array()\n\t\ta2, _ := v2.Array()\n\t\tif len(a1) != len(a2) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range a1 {\n\t\t\tif !equalValues(a1[i], a2[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeObject:\n\t\to1, _ := v1.Object()\n\t\to2, _ := v2.Object()\n\t\tif o1.Len() != o2.Len() {\n\t\t\treturn false\n\t\t}\n\t\to1.Visit(func(key []byte, v *Value) {\n\t\t\tv2val := o2.Get(string(key))\n\t\t\tif !equalValues(v, v2val) {\n\t\t\t\tt.Errorf(\"object key %q does not match\", key)\n\t\t\t}\n\t\t})\n\t\treturn true\n\tcase TypeString:\n\t\ts1, _ := v1.StringBytes()\n\t\ts2, _ := v2.StringBytes()\n\t\treturn string(s1) == string(s2)\n\tcase TypeNumber, TypeTrue, TypeFalse:\n\t\treturn v1.s == v2.s\n\tcase TypeNull:\n\t\treturn true\n\tdefault:\n\t\tpanic(\"unknown type\")\n\t}\n}",
    "a25d25f02f8b86580274389aa74aef8f": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty input\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"too deep nested JSON\",\n\t\t\tinput:    \"{\\\"key\\\":{\\\"key2\\\":{\\\"key3\\\":{}}}}\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t},\n\t\t{\n\t\t\tname:     \"valid object\",\n\t\t\tinput:    `{\"key\":\"value\",\"key2\":123}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{s: \"value\", t: typeRawString}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{s: \"123\", t: TypeNumber}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"1\", t: TypeNumber},\n\t\t\t\t\t{s: \"2\", t: TypeNumber},\n\t\t\t\t\t{s: \"3\", t: TypeNumber},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{\n\t\t\t\ts: \"hello\",\n\t\t\t\tt: typeRawString,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid true\",\n\t\t\tinput:    `true`,\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid false\",\n\t\t\tinput:    `false`,\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid null\",\n\t\t\tinput:    `null`,\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    `123`,\n\t\t\texpected: &Value{\n\t\t\t\ts: \"123\",\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tv, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif tc.err != nil {\n\t\t\t\tt.Errorf(\"expected error: %v\", tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !v.Equal(tc.expected) {\n\t\t\t\tt.Errorf(\"unexpected value: got %v, want %v\", v, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a2f4f8f4570d0c7dbc3af7e259d2ec73": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape double quote\",\n\t\t\tinput:    \"\\\"hello, world\\\"\",\n\t\t\texpected: `\"hello, world\"`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backslash\",\n\t\t\tinput:    \"\\\\hello, world\\\\\",\n\t\t\texpected: `\\hello, world\\`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape forward slash\",\n\t\t\tinput:    \"/hello, world/\",\n\t\t\texpected: `/hello, world/`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backspace\",\n\t\t\tinput:    \"h\\bello, world\",\n\t\t\texpected: \"h\\bello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape form feed\",\n\t\t\tinput:    \"h\\fello, world\",\n\t\t\texpected: \"h\\fello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape newline\",\n\t\t\tinput:    \"h\\nello, world\",\n\t\t\texpected: \"h\\nello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape carriage return\",\n\t\t\tinput:    \"h\\rello, world\",\n\t\t\texpected: \"h\\rello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape tab\",\n\t\t\tinput:    \"h\\tello, world\",\n\t\t\texpected: \"h\\tello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Unicode character\",\n\t\t\tinput:    \"\\\\u00a9hello, world\",\n\t\t\texpected: \"Â©hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape invalid Unicode character\",\n\t\t\tinput:    \"\\\\u00zzhello, world\",\n\t\t\texpected: \"\\\\u00zzhello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape surrogate pair\",\n\t\t\tinput:    \"\\\\ud83d\\\\ude00hello, world\",\n\t\t\texpected: \"ðŸ˜€hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape invalid surrogate pair\",\n\t\t\tinput:    \"\\\\ud83d\\\\uzzzzhello, world\",\n\t\t\texpected: \"\\\\ud83d\\\\uzzzzhello, world\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a31ab6e2a85edb4433203a49ee3c665e": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape double quote\",\n\t\t\tinput:    \"\\\"hello, world\\\"\",\n\t\t\texpected: `\"hello, world\"`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backslash\",\n\t\t\tinput:    \"\\\\hello, world\\\\\",\n\t\t\texpected: `\\hello, world\\`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape forward slash\",\n\t\t\tinput:    \"/hello, world/\",\n\t\t\texpected: `/hello, world/`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backspace\",\n\t\t\tinput:    \"h\\bello, world\",\n\t\t\texpected: \"h\\bello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape form feed\",\n\t\t\tinput:    \"h\\fello, world\",\n\t\t\texpected: \"h\\fello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape newline\",\n\t\t\tinput:    \"h\\nello, world\",\n\t\t\texpected: \"h\\nello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape carriage return\",\n\t\t\tinput:    \"h\\rello, world\",\n\t\t\texpected: \"h\\rello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape tab\",\n\t\t\tinput:    \"h\\tello, world\",\n\t\t\texpected: \"h\\tello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Unicode character\",\n\t\t\tinput:    \"\\\\u00A9hello, world\",\n\t\t\texpected: \"Â©hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape surrogate pair\",\n\t\t\tinput:    \"\\\\uD83D\\\\uDE00hello, world\",\n\t\t\texpected: \"ðŸ˜€hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid escape sequence\",\n\t\t\tinput:    \"\\\\xhello, world\",\n\t\t\texpected: \"\\\\xhello, world\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a235cfa8a800f97d978cf0010f204605": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"too big depth\",\n\t\t\tinput:    \"{}\", // Assuming MaxDepth is 1\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds 1\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"valid object\",\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{\n\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\tt: typeRawString,\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"1\", t: TypeNumber},\n\t\t\t\t\t{s: \"2\", t: TypeNumber},\n\t\t\t\t\t{s: \"3\", t: TypeNumber},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{\n\t\t\t\ts: \"hello\",\n\t\t\t\tt: typeRawString,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid true\",\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid false\",\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid null\",\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"42\",\n\t\t\texpected: &Value{\n\t\t\t\ts: \"42\",\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tv, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, expected %v\", tc.input, err, tc.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else if tc.err != nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = nil, expected %v\", tc.input, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !compareValues(v, tc.expected) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, expected %v\", tc.input, v, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn compareObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn compareArrays(v1.a, v2.a)\n\tcase typeRawString, TypeNumber, TypeTrue, TypeFalse, TypeNull:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc compareObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc compareArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tif !compareValues(v1, a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "a26b80d5cf03fc8984eb5057109c119c": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"too big depth\",\n\t\t\tinput:    \"{}\", // Assuming MaxDepth is 1\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds 1\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"valid object\",\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{s: \"value\", t: typeRawString}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"1\", t: TypeNumber},\n\t\t\t\t\t{s: \"2\", t: TypeNumber},\n\t\t\t\t\t{s: \"3\", t: TypeNumber},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{s: \"hello\", t: typeRawString},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid true\",\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid false\",\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid null\",\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"42\",\n\t\t\texpected: &Value{s: \"42\", t: TypeNumber},\n\t\t\terr:      nil,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, expected %v\", tc.input, err, tc.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else if tc.err != nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = nil, expected %v\", tc.input, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, expected %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\to1, _ := v1.Object()\n\t\to2, _ := v2.Object()\n\t\treturn compareObjects(o1, o2)\n\tcase TypeArray:\n\t\ta1, _ := v1.Array()\n\t\ta2, _ := v2.Array()\n\t\tif len(a1) != len(a2) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range a1 {\n\t\t\tif !compareValues(a1[i], a2[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase typeRawString, TypeNumber, TypeTrue, TypeFalse, TypeNull:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc compareObjects(o1, o2 *Object) bool {\n\tif o1 == nil && o2 == nil {\n\t\treturn true\n\t}\n\tif o1 == nil || o2 == nil {\n\t\treturn false\n\t}\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i := range o1.kvs {\n\t\tif o1.kvs[i].k != o2.kvs[i].k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(o1.kvs[i].v, o2.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "a5e01f7b9aa5ec2f7147d5827f47b853": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestTypeString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    Type\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"TypeObject\",\n\t\t\tinput:    TypeObject,\n\t\t\texpected: \"object\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeArray\",\n\t\t\tinput:    TypeArray,\n\t\t\texpected: \"array\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeString\",\n\t\t\tinput:    TypeString,\n\t\t\texpected: \"string\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeNumber\",\n\t\t\tinput:    TypeNumber,\n\t\t\texpected: \"number\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeTrue\",\n\t\t\tinput:    TypeTrue,\n\t\t\texpected: \"true\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeFalse\",\n\t\t\tinput:    TypeFalse,\n\t\t\texpected: \"false\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeNull\",\n\t\t\tinput:    TypeNull,\n\t\t\texpected: \"null\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Unknown Type\",\n\t\t\tinput:    Type(100),\n\t\t\texpected: \"BUG: unknown Value type: 100\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := tc.input.String()\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"expected %q, got %q\", tc.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a3df68aeb767bb59890390b17452dac4": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: \"{}\",\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           []kv{},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with one key-value pair\",\n\t\t\tinput: `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with multiple key-value pairs\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42,\"key3\":true}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"42\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42`,\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing colon\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\"}`,\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing value\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":}`,\n\t\t\terr:   true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tv, _, err := parseObject(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !v.Equal(tc.expected) {\n\t\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", tc.input, v, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a33528d332979ee2e87754f0c86d20ab": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"empty array\",\n\t\t\tinput:    \"[]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with one value\",\n\t\t\tinput:    \"[1]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with multiple values\",\n\t\t\tinput:    \"[1,2,3]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}, &Value{t: TypeNumber, s: \"2\"}, &Value{t: TypeNumber, s: \"3\"}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with trailing comma\",\n\t\t\tinput:    \"[1,2,3,]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with missing closing bracket\",\n\t\t\tinput:    \"[1,2,3\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tactual, _, err := parseArray(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseArray(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !equalValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeObject:\n\t\t// TODO: implement object equality check\n\t\treturn true\n\tcase TypeString, TypeNumber, TypeTrue, TypeFalse:\n\t\treturn v1.s == v2.s\n\tcase TypeNull:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}",
    "a5b8556bdc21d1ed32652816cb936193": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello, world\",\n\t\t\t},\n\t\t\twant: []byte(\"hello, world\"),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":\"value1\",\"key2\":42}`),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"hello\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t\t{t: TypeFalse},\n\t\t\t\t\t{t: TypeNull},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`[\"hello\",42,true,false,null]`),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello, world\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello, world\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42\",\n\t\t\t},\n\t\t\twant: []byte(\"42\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := make([]byte, 0, 100)\n\t\t\tgot := tt.v.MarshalTo(dst)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %q, want %q\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a3e48b7e8794256346743472b05097d3": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape double quote\",\n\t\t\tinput:    \"\\\"hello, world\\\"\",\n\t\t\texpected: `\"hello, world\"`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backslash\",\n\t\t\tinput:    \"\\\\hello, world\\\\\",\n\t\t\texpected: `\\hello, world\\`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape forward slash\",\n\t\t\tinput:    \"/hello, world/\",\n\t\t\texpected: `/hello, world/`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backspace\",\n\t\t\tinput:    \"h\\bello, world\",\n\t\t\texpected: \"h\\bello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape form feed\",\n\t\t\tinput:    \"h\\fello, world\",\n\t\t\texpected: \"h\\fello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape newline\",\n\t\t\tinput:    \"h\\nello, world\",\n\t\t\texpected: \"h\\nello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape carriage return\",\n\t\t\tinput:    \"h\\rello, world\",\n\t\t\texpected: \"h\\rello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape tab\",\n\t\t\tinput:    \"h\\tello, world\",\n\t\t\texpected: \"h\\tello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Unicode\",\n\t\t\tinput:    \"h\\\\u0061llo, world\",\n\t\t\texpected: \"hallo, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Unicode surrogate pair\",\n\t\t\tinput:    \"h\\\\ud83d\\\\ude00llo, world\",\n\t\t\texpected: \"hðŸ˜€llo, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Incomplete escape sequence\",\n\t\t\tinput:    \"h\\\\uello, world\",\n\t\t\texpected: \"h\\\\uello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Unknown escape sequence\",\n\t\t\tinput:    \"h\\\\xello, world\",\n\t\t\texpected: \"h\\\\xello, world\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a4fba82f647f277618decc132ad6bbbd": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape double quote\",\n\t\t\tinput:    \"\\\"hello, world\\\"\",\n\t\t\texpected: `\"hello, world\"`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backslash\",\n\t\t\tinput:    \"\\\\hello, world\\\\\",\n\t\t\texpected: `\\hello, world\\`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape forward slash\",\n\t\t\tinput:    \"/hello, world/\",\n\t\t\texpected: `/hello, world/`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backspace\",\n\t\t\tinput:    \"h\\bello, world\",\n\t\t\texpected: \"h\\bello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape form feed\",\n\t\t\tinput:    \"h\\fello, world\",\n\t\t\texpected: \"h\\fello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape newline\",\n\t\t\tinput:    \"h\\nello, world\",\n\t\t\texpected: \"h\\nello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape carriage return\",\n\t\t\tinput:    \"h\\rello, world\",\n\t\t\texpected: \"h\\rello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape tab\",\n\t\t\tinput:    \"h\\tello, world\",\n\t\t\texpected: \"h\\tello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Unicode\",\n\t\t\tinput:    \"\\\\u0041\\\\u0042\\\\u0043\",\n\t\t\texpected: \"ABC\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Surrogate Pair\",\n\t\t\tinput:    \"\\\\ud83d\\\\ude00\",\n\t\t\texpected: \"ðŸ˜€\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid Escape Sequence\",\n\t\t\tinput:    \"\\\\uABCD\",\n\t\t\texpected: \"\\\\uABCD\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a811fb62916e790dd566077bd6a35109": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestTypeString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    Type\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"TypeObject\",\n\t\t\tinput:    TypeObject,\n\t\t\texpected: \"object\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeArray\",\n\t\t\tinput:    TypeArray,\n\t\t\texpected: \"array\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeString\",\n\t\t\tinput:    TypeString,\n\t\t\texpected: \"string\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeNumber\",\n\t\t\tinput:    TypeNumber,\n\t\t\texpected: \"number\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeTrue\",\n\t\t\tinput:    TypeTrue,\n\t\t\texpected: \"true\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeFalse\",\n\t\t\tinput:    TypeFalse,\n\t\t\texpected: \"false\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeNull\",\n\t\t\tinput:    TypeNull,\n\t\t\texpected: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Unknown Type\",\n\t\t\tinput:    Type(100),\n\t\t\texpected: \"BUG: unknown Value type: 100\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := tc.input.String()\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"expected %q, got %q\", tc.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a5e6d71fa8c194773dae5aec918f7650": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tinput   string\n\t\twant    *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: \"{}\",\n\t\t\twant: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           []kv{},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with one key-value pair\",\n\t\t\tinput: `{\"key\":\"value\"}`,\n\t\t\twant: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with multiple key-value pairs\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42,\"key3\":true}`,\n\t\t\twant: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"42\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"missing closing brace\",\n\t\t\tinput:   `{\"key\":\"value\"`,\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"missing colon\",\n\t\t\tinput:   `{\"key\" \"value\"}`,\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"missing opening quote for key\",\n\t\t\tinput:   `{key:\"value\"}`,\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tgot, _, err := parseObject(tt.input, c, 0)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a9e232b93b484e6e3469207334efc237": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCache_getValue(t *testing.T) {\n\tc := &cache{\n\t\tvs: make([]Value, 0, 1),\n\t}\n\n\t// Test when the capacity of the slice is greater than the length\n\tv := c.getValue()\n\tif v == nil {\n\t\tt.Errorf(\"getValue() returned nil, expected a non-nil Value\")\n\t}\n\tif len(c.vs) != 1 {\n\t\tt.Errorf(\"len(c.vs) = %d, want 1\", len(c.vs))\n\t}\n\n\t// Test when the capacity of the slice is equal to the length\n\tc.vs = c.vs[:cap(c.vs)]\n\tv = c.getValue()\n\tif v == nil {\n\t\tt.Errorf(\"getValue() returned nil, expected a non-nil Value\")\n\t}\n\tif len(c.vs) != 1 {\n\t\tt.Errorf(\"len(c.vs) = %d, want 1\", len(c.vs))\n\t}\n}",
    "a70e42d00ffb9791be3db5ccdfec5efc": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":\"value1\",\"key2\":42}`),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"str1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`[\"str1\",42,true]`),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\\\"world\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello\\\"world\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42\",\n\t\t\t},\n\t\t\twant: []byte(\"42\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %q, want %q\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "aa6b9126a55855fa7d61ff927be5d07b": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestObject_unescapeKeys(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\to    *Object\n\t\twant *Object\n\t}{\n\t\t{\n\t\t\tname: \"no keys to unescape\",\n\t\t\to: &Object{\n\t\t\t\tkvs:           []kv{{k: \"key1\", v: &Value{}}, {k: \"key2\", v: &Value{}}},\n\t\t\t\tkeysUnescaped: false,\n\t\t\t},\n\t\t\twant: &Object{\n\t\t\t\tkvs:           []kv{{k: \"key1\", v: &Value{}}, {k: \"key2\", v: &Value{}}},\n\t\t\t\tkeysUnescaped: true,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"keys with escaped characters\",\n\t\t\to: &Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"key\\\\1\", v: &Value{}},\n\t\t\t\t\t{k: \"key\\\\2\", v: &Value{}},\n\t\t\t\t\t{k: \"key\\\\3\", v: &Value{}},\n\t\t\t\t},\n\t\t\t\tkeysUnescaped: false,\n\t\t\t},\n\t\t\twant: &Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"key1\", v: &Value{}},\n\t\t\t\t\t{k: \"key2\", v: &Value{}},\n\t\t\t\t\t{k: \"key3\", v: &Value{}},\n\t\t\t\t},\n\t\t\t\tkeysUnescaped: true,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\ttt.o.unescapeKeys()\n\t\t\tif !reflect.DeepEqual(tt.o, tt.want) {\n\t\t\t\tt.Errorf(\"Object.unescapeKeys() = %v, want %v\", tt.o, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "abaa0a9b4a1101f0ffe6fbdd0d47f13e": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\targs string\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: \"\",\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no leading whitespace\",\n\t\t\targs: \"hello\",\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading space\",\n\t\t\targs: \" hello\",\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading newline\",\n\t\t\targs: \"\\nhello\",\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading tab\",\n\t\t\targs: \"\\thello\",\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading carriage return\",\n\t\t\targs: \"\\rhello\",\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple leading whitespace\",\n\t\t\targs: \"  \\t\\n\\rhello\",\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"whitespace only\",\n\t\t\targs: \"  \\t\\n\\r\",\n\t\t\twant: \"\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.args); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "ac3e7c0295a352264e9924a302df5bfd": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple key\",\n\t\t\tinput:    `\"key\":`,\n\t\t\texpected: \"key\",\n\t\t},\n\t\t{\n\t\t\tname:     \"key with escape sequence\",\n\t\t\tinput:    `\"key\\\"with\\\"escape\":`,\n\t\t\texpected: `key\"with\"escape`,\n\t\t},\n\t\t{\n\t\t\tname:  \"missing closing quote\",\n\t\t\tinput: `\"key`,\n\t\t\terr:   true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tkey, rest, err := parseRawKey(tc.input)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseRawKey(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif key != tc.expected {\n\t\t\t\tt.Errorf(\"parseRawKey(%q) = %q, want %q\", tc.input, key, tc.expected)\n\t\t\t}\n\t\t\tif rest != tc.input[len(key)+1:] {\n\t\t\t\tt.Errorf(\"parseRawKey(%q) rest = %q, want %q\", tc.input, rest, tc.input[len(key)+1:])\n\t\t\t}\n\t\t})\n\t}\n}",
    "ab7254c63d697a2098f1843de7716d02": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetFloat64(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tinput  *Value\n\t\tkeys   []string\n\t\texpect float64\n\t}{\n\t\t{\n\t\t\tname:   \"valid float64\",\n\t\t\tinput:  &Value{s: \"3.14\", t: TypeNumber},\n\t\t\tkeys:   []string{},\n\t\t\texpect: 3.14,\n\t\t},\n\t\t{\n\t\t\tname:   \"non-existing keys\",\n\t\t\tinput:  &Value{s: \"3.14\", t: TypeNumber},\n\t\t\tkeys:   []string{\"foo\", \"bar\"},\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"invalid value type\",\n\t\t\tinput:  &Value{s: \"true\", t: TypeTrue},\n\t\t\tkeys:   []string{},\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"array index in keys\",\n\t\t\tinput:  &Value{a: []*Value{{s: \"3.14\", t: TypeNumber}}},\n\t\t\tkeys:   []string{\"0\"},\n\t\t\texpect: 3.14,\n\t\t},\n\t\t{\n\t\t\tname:   \"array index in keys with decimal\",\n\t\t\tinput:  &Value{a: []*Value{{s: \"3.14\", t: TypeNumber}, {s: \"4.56\", t: TypeNumber}}},\n\t\t\tkeys:   []string{\"1.0\"},\n\t\t\texpect: 4.56,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := test.input.GetFloat64(test.keys...)\n\t\t\tif got != test.expect {\n\t\t\t\tt.Errorf(\"GetFloat64(%v) = %v, want %v\", test.keys, got, test.expect)\n\t\t\t}\n\t\t})\n\t}\n}",
    "aadbb8a32afe4362ea210a5afd1631b3": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGet(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    *Value\n\t\tkeys     []string\n\t\texpected *Value\n\t}{\n\t\t{\n\t\t\tname: \"Existing keys path\",\n\t\t\tinput: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{a: []*Value{\n\t\t\t\t\t\t\t{s: \"array1\"},\n\t\t\t\t\t\t\t{s: \"array2\"},\n\t\t\t\t\t\t}}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"key1\"},\n\t\t\texpected: &Value{s: \"value1\"},\n\t\t},\n\t\t{\n\t\t\tname: \"Existing array index\",\n\t\t\tinput: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"value1\"},\n\t\t\t\t\t{s: \"value2\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"1\"},\n\t\t\texpected: &Value{s: \"value2\"},\n\t\t},\n\t\t{\n\t\t\tname:     \"Nil input\",\n\t\t\tinput:    nil,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Non-existing keys path\",\n\t\t\tinput: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{s: \"value1\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"key2\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Invalid array index\",\n\t\t\tinput: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"value1\"},\n\t\t\t\t\t{s: \"value2\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"2\"},\n\t\t\texpected: nil,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := tc.input.Get(tc.keys...)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"Get(%v) = %v, expected %v\", tc.keys, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a68b8acf83004d4b6f250b3f0d6d4899": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: \"{}\",\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           []kv{},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with one key-value pair\",\n\t\t\tinput: `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with multiple key-value pairs\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":123,\"key3\":true}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\tinput: `{\"key\":\"value\"`,\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing colon\",\n\t\t\tinput: `{\"key\" \"value\"}`,\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing comma\",\n\t\t\tinput: `{\"key1\":\"value1\" \"key2\":123}`,\n\t\t\terr:   true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tv, _, err := parseObject(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tc.err && !v.Equal(tc.expected) {\n\t\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", tc.input, v, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc (v *Value) Equal(other *Value) bool {\n\tif v.t != other.t {\n\t\treturn false\n\t}\n\n\tswitch v.t {\n\tcase TypeObject:\n\t\treturn v.o.Equal(&other.o)\n\tcase TypeArray:\n\t\treturn v.ArrayEqual(other.a)\n\tcase TypeString:\n\t\treturn v.s == other.s\n\tcase TypeNumber, TypeTrue, TypeFalse:\n\t\treturn v.s == other.s\n\tcase TypeNull:\n\t\treturn true\n\tdefault:\n\t\tpanic(\"unknown type\")\n\t}\n}\n\nfunc (o *Object) Equal(other *Object) bool {\n\tif len(o.kvs) != len(other.kvs) {\n\t\treturn false\n\t}\n\n\tfor i, kv := range o.kvs {\n\t\tif kv.k != other.kvs[i].k {\n\t\t\treturn false\n\t\t}\n\t\tif !kv.v.Equal(other.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\nfunc (v *Value) ArrayEqual(other []*Value) bool {\n\tif len(v.a) != len(other) {\n\t\treturn false\n\t}\n\n\tfor i, val := range v.a {\n\t\tif !val.Equal(other[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}",
    "abc7cd4d914a92eeb50b3ac0d0168973": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.45e+6\",\n\t\t\texpected: []string{\"123.45e+6\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with leading zeros\",\n\t\t\tinput:    \"0123.45\",\n\t\t\texpected: []string{\"0123.45\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with sign\",\n\t\t\tinput:    \"-123.45\",\n\t\t\texpected: []string{\"-123.45\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with leading sign\",\n\t\t\tinput:    \"+123.45\",\n\t\t\texpected: []string{\"+123.45\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with 'inf'\",\n\t\t\tinput:    \"inf\",\n\t\t\texpected: []string{\"inf\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with 'nan'\",\n\t\t\tinput:    \"nan\",\n\t\t\texpected: []string{\"nan\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number\",\n\t\t\tinput:    \"123.45a\",\n\t\t\texpected: []string{\"\", \"123.45a\"},\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.expected[0] || rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, %q, want %q, %q\", tc.input, num, rest, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "adf277bf36616eaa81aa73858644bb63": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestTypeString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    Type\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"TypeObject\",\n\t\t\tinput:    TypeObject,\n\t\t\texpected: \"object\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeArray\",\n\t\t\tinput:    TypeArray,\n\t\t\texpected: \"array\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeString\",\n\t\t\tinput:    TypeString,\n\t\t\texpected: \"string\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeNumber\",\n\t\t\tinput:    TypeNumber,\n\t\t\texpected: \"number\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeTrue\",\n\t\t\tinput:    TypeTrue,\n\t\t\texpected: \"true\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeFalse\",\n\t\t\tinput:    TypeFalse,\n\t\t\texpected: \"false\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeNull\",\n\t\t\tinput:    TypeNull,\n\t\t\texpected: \"null\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Unknown Type\",\n\t\t\tinput:    Type(100),\n\t\t\texpected: \"BUG: unknown Value type: 100\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := tc.input.String()\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"expected %q, got %q\", tc.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "ae4d8039b488babc11d0ff7d99cdce09": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_getKV(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\to    *Object\n\t\twant *kv\n\t}{\n\t\t{\n\t\t\tname: \"empty kvs\",\n\t\t\to:    &Object{},\n\t\t\twant: &kv{},\n\t\t},\n\t\t{\n\t\t\tname: \"kvs with capacity\",\n\t\t\to: &Object{\n\t\t\t\tkvs: make([]kv, 1, 2),\n\t\t\t},\n\t\t\twant: &kv{},\n\t\t},\n\t\t{\n\t\t\tname: \"kvs without capacity\",\n\t\t\to: &Object{\n\t\t\t\tkvs: make([]kv, 0, 0),\n\t\t\t},\n\t\t\twant: &kv{},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.o.getKV(); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Object.getKV() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "ac7b78a14ebcaa3e2da32258ce951a82": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t\trest     string\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.45e+6\",\n\t\t\texpected: \"123.45e+6\",\n\t\t\trest:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with leading sign\",\n\t\t\tinput:    \"-123.45e+6\",\n\t\t\texpected: \"-123.45e+6\",\n\t\t\trest:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with trailing non-digit\",\n\t\t\tinput:    \"123.45e+6x\",\n\t\t\texpected: \"123.45e+6\",\n\t\t\trest:     \"x\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty input\",\n\t\t\tinput:    \"\",\n\t\t\texpected: \"\",\n\t\t\trest:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number\",\n\t\t\tinput:    \"123.45e+6x123\",\n\t\t\texpected: \"123.45e+6\",\n\t\t\trest:     \"x123\",\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, want error %t\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.expected {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) number = %q, want %q\", tc.input, num, tc.expected)\n\t\t\t}\n\t\t\tif rest != tc.rest {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) rest = %q, want %q\", tc.input, rest, tc.rest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "ae9123f503428ba5692e3ea27ac17461": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: []string{\"hello\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello\\\"world\"`,\n\t\t\texpected: []string{\"hello\\\"world\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello\\\"world\\\"foo\"`,\n\t\t\texpected: []string{\"hello\\\"world\\\"foo\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with no closing quote\",\n\t\t\tinput:    `\"hello`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult, rest, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif result != tc.expected[0] || rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = %q, %q, want %q, %q\", tc.input, result, rest, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "af10a7f04b7057fbe477a26022125bc6": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: []string{\"hello\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello\\\"world\"`,\n\t\t\texpected: []string{\"hello\\\"world\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello\\\"world\\\"foo\"`,\n\t\t\texpected: []string{\"hello\\\"world\\\"foo\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with no closing quote\",\n\t\t\tinput:    `\"hello`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot, got2, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tc.expected[0] {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, expected %v\", got, tc.expected[0])\n\t\t\t}\n\t\t\tif got2 != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawString() got2 = %v, expected %v\", got2, tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "ae9693e983789f3217631b97120308a1": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.456\",\n\t\t\texpected: []string{\"123.456\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with exponent\",\n\t\t\tinput:    \"1.2e3\",\n\t\t\texpected: []string{\"1.2e3\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with sign\",\n\t\t\tinput:    \"-123.456\",\n\t\t\texpected: []string{\"-123.456\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number\",\n\t\t\tinput:    \"abc\",\n\t\t\texpected: []string{\"\", \"abc\"},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"infinity\",\n\t\t\tinput:    \"inf\",\n\t\t\texpected: []string{\"inf\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN\",\n\t\t\tinput:    \"nan\",\n\t\t\texpected: []string{\"nan\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.expected[0] || rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, %q, want %q, %q\", tc.input, num, rest, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "abf55f53ceb89bc55eca47b43f24c5c4": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: \"{}\",\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           []kv{},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with one key-value pair\",\n\t\t\tinput: `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with multiple key-value pairs\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42,\"key3\":true}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"42\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\tinput: `{\"key1\":\"value1\",`,\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing colon\",\n\t\t\tinput: `{\"key1\" \"value1\"}`,\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing comma\",\n\t\t\tinput: `{\"key1\":\"value1\" \"key2\":\"value2\"}`,\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tactual, _, err := parseObject(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseObject(%q) error = %v, expected %v\", tc.input, err, tc.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else if tc.err != nil {\n\t\t\t\tt.Errorf(\"parseObject(%q) error = nil, expected %v\", tc.input, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseObject(%q) = %v, expected %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn compareObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn compareArrays(v1.a, v2.a)\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber, TypeTrue, TypeFalse:\n\t\treturn v1.s == v2.s\n\tcase TypeNull:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc compareObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc compareArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tv2 := a2[i]\n\t\tif !compareValues(v1, v2) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "afef6c05b46268a259be59a5a9fca661": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":\"value1\",\"key2\":42}`),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"str1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t\t{t: TypeFalse},\n\t\t\t\t\t{t: TypeNull},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`[\"str1\",42,true,false,null]`),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\\\"world\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello\\\"world\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42.5\",\n\t\t\t},\n\t\t\twant: []byte(\"42.5\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %q, want %q\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b0b5fd686ad16fef8e8d59f74a9f67c4": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGet(t *testing.T) {\n\t// Test cases\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    *Value\n\t\tkeys     []string\n\t\texpected *Value\n\t}{\n\t\t{\n\t\t\tname: \"Existing key in object\",\n\t\t\tinput: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: &Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"key2\"},\n\t\t\texpected: &Value{t: TypeNumber, s: \"42\"},\n\t\t},\n\t\t{\n\t\t\tname: \"Non-existing key in object\",\n\t\t\tinput: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: &Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"key3\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Existing index in array\",\n\t\t\tinput: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"value1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"1\"},\n\t\t\texpected: &Value{t: TypeNumber, s: \"42\"},\n\t\t},\n\t\t{\n\t\t\tname: \"Non-existing index in array\",\n\t\t\tinput: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"value1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"2\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Nil input\",\n\t\t\tinput:    nil,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: nil,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := tc.input.Get(tc.keys...)\n\t\t\tif tc.expected != result {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", tc.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b19489aa7c40cead98db30a214543112": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantNum  string\n\t\twantRest string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.45e+6\",\n\t\t\twantNum:  \"123.45e+6\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with trailing characters\",\n\t\t\tinput:    \"123.45e+6abc\",\n\t\t\twantNum:  \"123.45e+6\",\n\t\t\twantRest: \"abc\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number\",\n\t\t\tinput:    \"abc\",\n\t\t\twantNum:  \"\",\n\t\t\twantRest: \"abc\",\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty input\",\n\t\t\tinput:    \"\",\n\t\t\twantNum:  \"\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"inf\",\n\t\t\tinput:    \"inf\",\n\t\t\twantNum:  \"inf\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"nan\",\n\t\t\tinput:    \"nan\",\n\t\t\twantNum:  \"nan\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.wantNum {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) num = %q, want %q\", tc.input, num, tc.wantNum)\n\t\t\t}\n\t\t\tif rest != tc.wantRest {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) rest = %q, want %q\", tc.input, rest, tc.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "ae0b572cc88c22817952f3cafbbcef57": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"too big depth\",\n\t\t\tinput:    \"{}\", // Assuming MaxDepth is 1\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds 1\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"valid object\",\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{s: \"value\", t: typeRawString}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"1\", t: TypeNumber},\n\t\t\t\t\t{s: \"2\", t: TypeNumber},\n\t\t\t\t\t{s: \"3\", t: TypeNumber},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{s: \"hello\", t: typeRawString},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid true\",\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid false\",\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid null\",\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"42\",\n\t\t\texpected: &Value{s: \"42\", t: TypeNumber},\n\t\t\terr:      nil,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, expected %v\", tc.input, err, tc.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else if tc.err != nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = nil, expected %v\", tc.input, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, expected %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\to1, _ := v1.Object()\n\t\to2, _ := v2.Object()\n\t\treturn compareObjects(o1, o2)\n\tcase TypeArray:\n\t\ta1, _ := v1.Array()\n\t\ta2, _ := v2.Array()\n\t\tif len(a1) != len(a2) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range a1 {\n\t\t\tif !compareValues(a1[i], a2[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase typeRawString, TypeString, TypeNumber, TypeTrue, TypeFalse, TypeNull:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc compareObjects(o1, o2 *Object) bool {\n\tif o1 == nil && o2 == nil {\n\t\treturn true\n\t}\n\tif o1 == nil || o2 == nil {\n\t\treturn false\n\t}\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i := range o1.kvs {\n\t\tif o1.kvs[i].k != o2.kvs[i].k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(o1.kvs[i].v, o2.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "b04b74319d940f0635ec6c3ab0c4f8db": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty array\",\n\t\t\tinput: \"[]\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with one value\",\n\t\t\tinput: \"[1]\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with multiple values\",\n\t\t\tinput: \"[1,2,3]\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with trailing comma\",\n\t\t\tinput: \"[1,2,3,]\",\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with missing closing bracket\",\n\t\t\tinput: \"[1,2,3\",\n\t\t\terr:   true,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, _, err := parseArray(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseArray(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !equalValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeArray:\n\t\ta1, _ := v1.Array()\n\t\ta2, _ := v2.Array()\n\t\tif len(a1) != len(a2) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range a1 {\n\t\t\tif !equalValues(a1[i], a2[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeObject:\n\t\to1, _ := v1.Object()\n\t\to2, _ := v2.Object()\n\t\tif o1.Len() != o2.Len() {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range o1.kvs {\n\t\t\tif o1.kvs[i].k != o2.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(o1.kvs[i].v, o2.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeString:\n\t\ts1, _ := v1.StringBytes()\n\t\ts2, _ := v2.StringBytes()\n\t\treturn string(s1) == string(s2)\n\tcase TypeNumber:\n\t\tn1, _ := v1.Float64()\n\t\tn2, _ := v2.Float64()\n\t\treturn n1 == n2\n\tcase TypeTrue, TypeFalse:\n\t\tb1, _ := v1.Bool()\n\t\tb2, _ := v2.Bool()\n\t\treturn b1 == b2\n\tcase TypeNull:\n\t\treturn true\n\tdefault:\n\t\tpanic(\"unknown type\")\n\t}\n}",
    "b514df76d6af14fc4f444c942cde5ac8": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"no whitespace\",\n\t\t\tinput:    \"hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading whitespace\",\n\t\t\tinput:    \"   hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"trailing whitespace\",\n\t\t\tinput:    \"hello   \",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"mixed whitespace\",\n\t\t\tinput:    \"   hello   \",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"all whitespace\",\n\t\t\tinput:    \"   \\t\\n\\r \",\n\t\t\texpected: \"\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := skipWSSlow(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"skipWSSlow(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b274ce25e34f5619bedd4d1f51c52eb9": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty array\",\n\t\t\tinput: \"[]\",\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with one value\",\n\t\t\tinput: \"[1]\",\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with multiple values\",\n\t\t\tinput: \"[1,2,3]\",\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with trailing comma\",\n\t\t\tinput: \"[1,2,3,]\",\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with missing value\",\n\t\t\tinput: \"[1,,3]\",\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with nested array\",\n\t\t\tinput: \"[[1,2],[3,4]]\",\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"4\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tv, _, err := parseArray(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseArray(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !v.Equal(tc.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", tc.input, v, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b450486b468a9852733fdb3976569a3c": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetFloat64(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    *Value\n\t\tkeys     []string\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname: \"valid float64\",\n\t\t\tinput: &Value{\n\t\t\t\ts: \"3.14\",\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\tkeys:     []string{},\n\t\t\texpected: 3.14,\n\t\t},\n\t\t{\n\t\t\tname: \"non-existing keys\",\n\t\t\tinput: &Value{\n\t\t\t\ts: \"3.14\",\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\tkeys:     []string{\"foo\", \"bar\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid value type\",\n\t\t\tinput: &Value{\n\t\t\t\ts: \"true\",\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\tkeys:     []string{},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"nil input\",\n\t\t\tinput:    nil,\n\t\t\tkeys:     []string{},\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := tc.input.GetFloat64(tc.keys...)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"GetFloat64(%v) = %f, want %f\", tc.keys, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b2cf84a6aeb0b423ad46a2a92b4babdf": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\texpected []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\texpected: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: []byte(`{\"key1\":\"value1\",\"key2\":42}`),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"item1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: []byte(`[\"item1\",42,true]`),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\texpected: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42\",\n\t\t\t},\n\t\t\texpected: []byte(\"42\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\texpected: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\texpected: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\texpected: []byte(\"null\"),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdst := make([]byte, 0, 64)\n\t\t\tresult := tc.value.MarshalTo(dst)\n\t\t\tif !reflect.DeepEqual(result, tc.expected) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %s, expected %s\", result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b677050dbcec629c8d29f82e2c3f2fd6": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestType(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant Type\n\t}{\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: TypeNull,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\twant: TypeObject,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\twant: TypeArray,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeString,\n\t\t\t},\n\t\t\twant: TypeString,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\twant: TypeNumber,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: TypeTrue,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: TypeFalse,\n\t\t},\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t},\n\t\t\twant: typeRawString,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := tc.v.Type()\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"Type() = %v, want %v\", got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b23f165790dec92592a71e74e8fd8fd3": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty array\",\n\t\t\tinput: \"[]\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with one value\",\n\t\t\tinput: \"[1]\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with multiple values\",\n\t\t\tinput: \"[1,2,3]\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with trailing comma\",\n\t\t\tinput: \"[1,2,3,]\",\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with missing closing bracket\",\n\t\t\tinput: \"[1,2,3\",\n\t\t\terr:   true,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, _, err := parseArray(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseArray(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !equalValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeArray:\n\t\ta1, _ := v1.Array()\n\t\ta2, _ := v2.Array()\n\t\tif len(a1) != len(a2) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range a1 {\n\t\t\tif !equalValues(a1[i], a2[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeObject:\n\t\to1, _ := v1.Object()\n\t\to2, _ := v2.Object()\n\t\tif o1.Len() != o2.Len() {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range o1.kvs {\n\t\t\tif o1.kvs[i].k != o2.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(o1.kvs[i].v, o2.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeString:\n\t\ts1, _ := v1.StringBytes()\n\t\ts2, _ := v2.StringBytes()\n\t\treturn string(s1) == string(s2)\n\tcase TypeNumber, TypeTrue, TypeFalse:\n\t\treturn v1.s == v2.s\n\tcase TypeNull:\n\t\treturn true\n\tdefault:\n\t\tpanic(\"unknown type\")\n\t}\n}",
    "b702b7f64b16cbf5e64694750a7a6b86": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t\trest     string\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple key\",\n\t\t\tinput:    `\"key\":`,\n\t\t\texpected: \"key\",\n\t\t\trest:     \":\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"key with escape sequence\",\n\t\t\tinput:    `\"key\\\"with\\\"escape\":`,\n\t\t\texpected: `key\"with\"escape`,\n\t\t\trest:     \":\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing closing quote\",\n\t\t\tinput:    `\"key`,\n\t\t\texpected: \"\",\n\t\t\trest:     \"\",\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tkey, rest, err := parseRawKey(tc.input)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseRawKey(%q) error = %v, want error %t\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif key != tc.expected {\n\t\t\t\tt.Errorf(\"parseRawKey(%q) key = %q, want %q\", tc.input, key, tc.expected)\n\t\t\t}\n\t\t\tif rest != tc.rest {\n\t\t\t\tt.Errorf(\"parseRawKey(%q) rest = %q, want %q\", tc.input, rest, tc.rest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b2c1c16f19f788e01adcb94f55cad0b0": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: \"{}\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with one key-value pair\",\n\t\t\tinput: `{\"key\":\"value\"}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with multiple key-value pairs\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":123,\"key3\":true}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\tinput: `{\"key1\":\"value1\",`,\n\t\t\texpected: nil,\n\t\t\terr:     true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing colon\",\n\t\t\tinput: `{\"key1\" \"value1\"}`,\n\t\t\texpected: nil,\n\t\t\terr:     true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing comma\",\n\t\t\tinput: `{\"key1\":\"value1\" \"key2\":\"value2\"}`,\n\t\t\texpected: nil,\n\t\t\terr:     true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tactual, _, err := parseObject(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn compareObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn compareArrays(v1.a, v2.a)\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber, TypeTrue, TypeFalse:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\treturn true\n\t}\n}\n\nfunc compareObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc compareArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tif !compareValues(v1, a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "b649516c92ed84646401f9a0c8be1b42": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGet(t *testing.T) {\n\t// Test cases\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    *Value\n\t\tkeys     []string\n\t\texpected *Value\n\t}{\n\t\t{\n\t\t\tname: \"Existing keys path\",\n\t\t\tinput: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{a: []*Value{\n\t\t\t\t\t\t\t&Value{s: \"value2_1\"},\n\t\t\t\t\t\t\t&Value{s: \"value2_2\"},\n\t\t\t\t\t\t}}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"key1\"},\n\t\t\texpected: &Value{s: \"value1\"},\n\t\t},\n\t\t{\n\t\t\tname: \"Array index in keys path\",\n\t\t\tinput: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key2\", v: &Value{a: []*Value{\n\t\t\t\t\t\t\t&Value{s: \"value2_1\"},\n\t\t\t\t\t\t\t&Value{s: \"value2_2\"},\n\t\t\t\t\t\t}}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"key2\", \"1\"},\n\t\t\texpected: &Value{s: \"value2_2\"},\n\t\t},\n\t\t{\n\t\t\tname:     \"Non-existing keys path\",\n\t\t\tinput:    &Value{},\n\t\t\tkeys:     []string{\"non-existing\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Non-object value type\",\n\t\t\tinput: &Value{\n\t\t\t\ts: \"string value\",\n\t\t\t},\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: nil,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := tc.input.Get(tc.keys...)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"Get(%v) = %v, expected %v\", tc.keys, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b77435e569aff9b55cf6558a968f476c": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello world\"`,\n\t\t\texpected: []string{\"hello world\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello \\\"world\\\"\"`,\n\t\t\texpected: []string{\"hello \\\"world\\\"\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello \\\"world\\\" \\\"foo\\\"\"`,\n\t\t\texpected: []string{\"hello \\\"world\\\" \\\"foo\\\"\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with no closing quote\",\n\t\t\tinput:    `\"hello world`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot1, got2, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got1 != tc.expected[0] || got2 != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawString() = (%q, %q), want (%q, %q)\", got1, got2, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "b820683300c14c36357582b48bac4df3": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: []string{\"hello\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello\\\"world\"`,\n\t\t\texpected: []string{\"hello\\\"world\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello\\\"world\\\"foo\"`,\n\t\t\texpected: []string{\"hello\\\"world\\\"foo\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with no closing quote\",\n\t\t\tinput:    `\"hello`,\n\t\t\texpected: []string{},\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot1, got2, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got1 != tc.expected[0] || got2 != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = (%q, %q), want (%q, %q)\", tc.input, got1, got2, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "b7a19dad9f8dc44de63625c70135f9cb": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.45e+6\",\n\t\t\texpected: []string{\"123.45e+6\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with leading sign\",\n\t\t\tinput:    \"-123.45\",\n\t\t\texpected: []string{\"-123.45\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with trailing garbage\",\n\t\t\tinput:    \"123.45abc\",\n\t\t\texpected: []string{\"123.45\", \"abc\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number\",\n\t\t\tinput:    \"abc\",\n\t\t\texpected: []string{\"\", \"abc\"},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"inf\",\n\t\t\tinput:    \"inf\",\n\t\t\texpected: []string{\"inf\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"nan\",\n\t\t\tinput:    \"nan\",\n\t\t\texpected: []string{\"nan\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.expected[0] || rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, %q, want %q, %q\", tc.input, num, rest, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "b986d4c589f56a16c52eb378505a2e52": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestTypeString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    Type\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"TypeObject\",\n\t\t\tinput:    TypeObject,\n\t\t\texpected: \"object\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeArray\",\n\t\t\tinput:    TypeArray,\n\t\t\texpected: \"array\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeString\",\n\t\t\tinput:    TypeString,\n\t\t\texpected: \"string\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeNumber\",\n\t\t\tinput:    TypeNumber,\n\t\t\texpected: \"number\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeTrue\",\n\t\t\tinput:    TypeTrue,\n\t\t\texpected: \"true\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeFalse\",\n\t\t\tinput:    TypeFalse,\n\t\t\texpected: \"false\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeNull\",\n\t\t\tinput:    TypeNull,\n\t\t\texpected: \"null\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Unknown Type\",\n\t\t\tinput:    Type(100),\n\t\t\texpected: \"BUG: unknown Value type: 100\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := tc.input.String()\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"expected %q, got %q\", tc.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b9027e608afcd64bdeefc42196d68462": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":\"value1\",\"key2\":42}`),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"str1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`[\"str1\",42,true]`),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\\\"world\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello\\\"world\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42\",\n\t\t\t},\n\t\t\twant: []byte(\"42\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := make([]byte, 0, 64)\n\t\t\tgot := tt.v.MarshalTo(dst)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %q, want %q\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b5ba9e305ed271a13086bb75c92eeb74": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"too big depth\",\n\t\t\tinput:    \"{}\", // Assuming MaxDepth is 1\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds 1\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"valid object\",\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{s: \"value\", t: typeRawString}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"1\", t: TypeNumber},\n\t\t\t\t\t{s: \"2\", t: TypeNumber},\n\t\t\t\t\t{s: \"3\", t: TypeNumber},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{s: \"hello\", t: typeRawString},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid true\",\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid false\",\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid null\",\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"42\",\n\t\t\texpected: &Value{s: \"42\", t: TypeNumber},\n\t\t\terr:      nil,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, expected %v\", tc.input, err, tc.err)\n\t\t\t\t}\n\t\t\t} else if tc.err != nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = nil, expected %v\", tc.input, tc.err)\n\t\t\t} else if !valuesEqual(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, expected %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc valuesEqual(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\to1, _ := v1.Object()\n\t\to2, _ := v2.Object()\n\t\treturn objectsEqual(o1, o2)\n\tcase TypeArray:\n\t\ta1, _ := v1.Array()\n\t\ta2, _ := v2.Array()\n\t\tif len(a1) != len(a2) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range a1 {\n\t\t\tif !valuesEqual(a1[i], a2[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase typeRawString, TypeNumber, TypeTrue, TypeFalse, TypeNull:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\tpanic(\"unknown type\")\n\t}\n}\n\nfunc objectsEqual(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i := range o1.kvs {\n\t\tif o1.kvs[i].k != o2.kvs[i].k {\n\t\t\treturn false\n\t\t}\n\t\tif !valuesEqual(o1.kvs[i].v, o2.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "bae59786f5c861d477ca897b14a101e7": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":\"value1\",\"key2\":42}`),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"hello\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`[\"hello\",42,true]`),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42\",\n\t\t\t},\n\t\t\twant: []byte(\"42\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %q, want %q\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "bae6aaeb6d2dde466a9d225e8b25689e": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tv        *Value\n\t\texpected []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\texpected: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: []byte(`{\"key1\":\"value1\",\"key2\":42}`),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"str1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: []byte(`[\"str1\",42,true]`),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\\\"world\",\n\t\t\t},\n\t\t\texpected: []byte(`\"hello\\\"world\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42\",\n\t\t\t},\n\t\t\texpected: []byte(\"42\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\texpected: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\texpected: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\texpected: []byte(\"null\"),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdst := make([]byte, 0, 64)\n\t\t\tresult := tc.v.MarshalTo(dst)\n\t\t\tif !reflect.DeepEqual(result, tc.expected) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %q, expected %q\", result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "bbd4aacd501b5510c301e28e2c99a7a2": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestGetStringBytes(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tinput string\n\t\tkeys  []string\n\t\twant  []byte\n\t}{\n\t\t{\n\t\t\tname:  \"Existing key path\",\n\t\t\tinput: `{\"key1\":{\"key2\":\"value\"}}`,\n\t\t\tkeys:  []string{\"key1\", \"key2\"},\n\t\t\twant:  []byte(\"value\"),\n\t\t},\n\t\t{\n\t\t\tname:  \"Non-existing key path\",\n\t\t\tinput: `{\"key1\":{\"key2\":\"value\"}}`,\n\t\t\tkeys:  []string{\"key1\", \"key3\"},\n\t\t\twant:  nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"Invalid value type\",\n\t\t\tinput: `{\"key1\":123}`,\n\t\t\tkeys:  []string{\"key1\"},\n\t\t\twant:  nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"Array index in key path\",\n\t\t\tinput: `{\"key1\":[{\"key2\":\"value1\"},{\"key2\":\"value2\"}]}`,\n\t\t\tkeys:  []string{\"key1\", \"1\", \"key2\"},\n\t\t\twant:  []byte(\"value2\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tp := &Parser{}\n\t\t\tv, err := p.ParseBytes([]byte(tt.input))\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"ParseBytes() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tgot := v.GetStringBytes(tt.keys...)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"GetStringBytes() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "bba33bd45299023ca8b7a83a78d12329": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty array\",\n\t\t\tinput: \"[]\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with one element\",\n\t\t\tinput: \"[1]\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with multiple elements\",\n\t\t\tinput: \"[1,2,3]\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with trailing comma\",\n\t\t\tinput: \"[1,2,3,]\",\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with missing closing bracket\",\n\t\t\tinput: \"[1,2,3\",\n\t\t\terr:   true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tactual, _, err := parseArray(tc.input, c, 0)\n\t\t\tif tc.err {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"expected error, got nil\")\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !actual.Equal(tc.expected) {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tc.expected, actual)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b94c8a675ca01c0e5705f4898a327a1f": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty array\",\n\t\t\tinput: \"[]\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with one value\",\n\t\t\tinput: \"[1]\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with multiple values\",\n\t\t\tinput: \"[1,2,3]\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with missing closing bracket\",\n\t\t\tinput: \"[1,2,3\",\n\t\t\texpected: nil,\n\t\t\terr:     true,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, _, err := parseArray(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseArray(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !equalValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeArray:\n\t\ta1, _ := v1.Array()\n\t\ta2, _ := v2.Array()\n\t\tif len(a1) != len(a2) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range a1 {\n\t\t\tif !equalValues(a1[i], a2[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeObject:\n\t\to1, _ := v1.Object()\n\t\to2, _ := v2.Object()\n\t\tif o1.Len() != o2.Len() {\n\t\t\treturn false\n\t\t}\n\t\tkv1 := o1.getKV()\n\t\tkv2 := o2.getKV()\n\t\tfor i := range kv1 {\n\t\t\tif kv1[i].k != kv2[i].k || !equalValues(kv1[i].v, kv2[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeString:\n\t\ts1, _ := v1.StringBytes()\n\t\ts2, _ := v2.StringBytes()\n\t\treturn string(s1) == string(s2)\n\tcase TypeNumber, TypeTrue, TypeFalse:\n\t\treturn v1.s == v2.s\n\tcase TypeNull:\n\t\treturn true\n\tdefault:\n\t\tpanic(\"unknown type\")\n\t}\n}",
    "bc32bb4bd7cd7c280d27c80f1da62f5b": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantNum  string\n\t\twantRest string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.45e+6\",\n\t\t\twantNum:  \"123.45e+6\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with trailing characters\",\n\t\t\tinput:    \"123.45abc\",\n\t\t\twantNum:  \"123.45\",\n\t\t\twantRest: \"abc\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number\",\n\t\t\tinput:    \"abc123\",\n\t\t\twantNum:  \"\",\n\t\t\twantRest: \"abc123\",\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"inf\",\n\t\t\tinput:    \"inf\",\n\t\t\twantNum:  \"inf\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"nan\",\n\t\t\tinput:    \"nan\",\n\t\t\twantNum:  \"nan\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.wantNum {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) num = %q, want %q\", tc.input, num, tc.wantNum)\n\t\t\t}\n\t\t\tif rest != tc.wantRest {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) rest = %q, want %q\", tc.input, rest, tc.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "bd43f4fafcaeeba798c3f402040ffc31": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"no escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"simple escape characters\",\n\t\t\tinput:    \"hello\\\\\\\"world\\\\\\\\\",\n\t\t\texpected: \"hello\\\"world\\\\\",\n\t\t},\n\t\t{\n\t\t\tname:     \"complex escape characters\",\n\t\t\tinput:    \"hello\\\\u0000world\\\\u1234\\\\u{10000}\",\n\t\t\texpected: \"hello\\x00world\\u1234\\U00010000\",\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid escape characters\",\n\t\t\tinput:    \"hello\\\\uworld\\\\u123\",\n\t\t\texpected: \"hello\\\\uworld\\\\u123\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "be3fef38b753fb00b2dd27df1c22fb9f": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestTypeString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    Type\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"TypeObject\",\n\t\t\tinput:    TypeObject,\n\t\t\texpected: \"object\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeArray\",\n\t\t\tinput:    TypeArray,\n\t\t\texpected: \"array\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeString\",\n\t\t\tinput:    TypeString,\n\t\t\texpected: \"string\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeNumber\",\n\t\t\tinput:    TypeNumber,\n\t\t\texpected: \"number\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeTrue\",\n\t\t\tinput:    TypeTrue,\n\t\t\texpected: \"true\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeFalse\",\n\t\t\tinput:    TypeFalse,\n\t\t\texpected: \"false\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeNull\",\n\t\t\tinput:    TypeNull,\n\t\t\texpected: \"null\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Unknown Type\",\n\t\t\tinput:    Type(100),\n\t\t\texpected: \"BUG: unknown Value type: 100\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := tc.input.String()\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"expected %q, got %q\", tc.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "bfd9bf47990529b6e2f1fe69b5593909": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestHasSpecialChars(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with double quote\",\n\t\t\tinput:    \"hello\\\"world\",\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with backslash\",\n\t\t\tinput:    \"hello\\\\world\",\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with control character\",\n\t\t\tinput:    \"hello\\nworld\",\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"string without special characters\",\n\t\t\tinput:    \"helloworld\",\n\t\t\texpected: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := hasSpecialChars(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"hasSpecialChars(%q) = %v, expected %v\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "bd08cdc2e23161062627047e003b8850": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape double quote\",\n\t\t\tinput:    \"\\\"hello, world\\\"\",\n\t\t\texpected: `\"hello, world\"`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backslash\",\n\t\t\tinput:    \"\\\\hello, world\\\\\",\n\t\t\texpected: `\\hello, world\\`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape forward slash\",\n\t\t\tinput:    \"/hello, world/\",\n\t\t\texpected: `/hello, world/`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backspace\",\n\t\t\tinput:    \"h\\bello, world\",\n\t\t\texpected: \"h\\bello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape form feed\",\n\t\t\tinput:    \"h\\fello, world\",\n\t\t\texpected: \"h\\fello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape newline\",\n\t\t\tinput:    \"h\\nello, world\",\n\t\t\texpected: \"h\\nello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape carriage return\",\n\t\t\tinput:    \"h\\rello, world\",\n\t\t\texpected: \"h\\rello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape tab\",\n\t\t\tinput:    \"h\\tello, world\",\n\t\t\texpected: \"h\\tello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Unicode\",\n\t\t\tinput:    \"\\\\u0041\\\\u0042\\\\u0043\",\n\t\t\texpected: \"ABC\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Surrogate Pair\",\n\t\t\tinput:    \"\\\\ud83d\\\\ude00\",\n\t\t\texpected: \"ðŸ˜€\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid Escape Sequence\",\n\t\t\tinput:    \"\\\\uABCD\",\n\t\t\texpected: \"\\\\uABCD\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "bbe3e673670e6d1a8100b95f3f3b6604": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: \"{}\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with one key-value pair\",\n\t\t\tinput: `{\"key\":\"value\"}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with multiple key-value pairs\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":123,\"key3\":true}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\tinput: `{\"key\":\"value\"`,\n\t\t\texpected: nil,\n\t\t\terr:     true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing colon\",\n\t\t\tinput: `{\"key\" \"value\"}`,\n\t\t\texpected: nil,\n\t\t\terr:     true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing comma\",\n\t\t\tinput: `{\"key1\":\"value1\" \"key2\":123}`,\n\t\t\texpected: nil,\n\t\t\terr:     true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tactual, _, err := parseObject(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn compareObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn compareArrays(v1.a, v2.a)\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber, TypeTrue, TypeFalse:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\treturn true\n\t}\n}\n\nfunc compareObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc compareArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tif !compareValues(v1, a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "c139b8b840fd95c233cf58a5b0b8e307": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: []string{\"hello\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello\\\"world\"`,\n\t\t\texpected: []string{\"hello\\\"world\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello\\\"world\\\"foo\"`,\n\t\t\texpected: []string{\"hello\\\"world\\\"foo\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with no closing quote\",\n\t\t\tinput:    `\"hello`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult, rest, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif result != tc.expected[0] || rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = %q, %q, want %q, %q\", tc.input, result, rest, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "bc5d285469a1c0d8fc4ef44b5183d6ea": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"empty array\",\n\t\t\tinput:    \"[]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with one value\",\n\t\t\tinput:    \"[1]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with multiple values\",\n\t\t\tinput:    \"[1,2,3]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}, &Value{t: TypeNumber, s: \"2\"}, &Value{t: TypeNumber, s: \"3\"}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with trailing comma\",\n\t\t\tinput:    \"[1,2,3,]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with missing closing bracket\",\n\t\t\tinput:    \"[1,2,3\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tv, _, err := parseArray(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseArray(%q) error = %v, want error %t\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !equalValues(v, tc.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", tc.input, v, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeArray:\n\t\ta1, _ := v1.Array()\n\t\ta2, _ := v2.Array()\n\t\tif len(a1) != len(a2) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range a1 {\n\t\t\tif !equalValues(a1[i], a2[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeObject:\n\t\to1, _ := v1.Object()\n\t\to2, _ := v2.Object()\n\t\tif o1.Len() != o2.Len() {\n\t\t\treturn false\n\t\t}\n\t\tvar found bool\n\t\to1.Visit(func(key []byte, v *Value) {\n\t\t\tv2, _ := o2.Get(string(key))\n\t\t\tfound = equalValues(v, v2)\n\t\t})\n\t\treturn found\n\tcase TypeString, TypeNumber, TypeTrue, TypeFalse, TypeNull:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\tpanic(\"unknown type\")\n\t}\n}",
    "c3af1e47e08002ea2a66ba4555dc8b2c": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestGetStringBytes(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tvalue *Value\n\t\tkeys  []string\n\t\twant  []byte\n\t}{\n\t\t{\n\t\t\tname: \"existing key\",\n\t\t\tvalue: &Value{\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\tkeys: []string{\"key\"},\n\t\t\twant: []byte(\"hello\"),\n\t\t},\n\t\t{\n\t\t\tname: \"non-existing key\",\n\t\t\tvalue: &Value{\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\tkeys: []string{\"non-existing\"},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid value type\",\n\t\t\tvalue: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\tkeys: []string{\"key\"},\n\t\t\twant: nil,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.value.GetStringBytes(tt.keys...)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"GetStringBytes() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c0874c7164c921c92d5c73b5e96f2adc": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.456e+7\",\n\t\t\texpected: []string{\"123.456e+7\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with leading zeros\",\n\t\t\tinput:    \"0123.456\",\n\t\t\texpected: []string{\"0123.456\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with sign\",\n\t\t\tinput:    \"-123.456\",\n\t\t\texpected: []string{\"-123.456\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with exponent\",\n\t\t\tinput:    \"1.2e-3\",\n\t\t\texpected: []string{\"1.2e-3\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number\",\n\t\t\tinput:    \"123.456.789\",\n\t\t\texpected: []string{\"\", \"123.456.789\"},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with leading invalid character\",\n\t\t\tinput:    \"a123.456\",\n\t\t\texpected: []string{\"\", \"a123.456\"},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with trailing invalid character\",\n\t\t\tinput:    \"123.456a\",\n\t\t\texpected: []string{\"123.456\", \"a\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.expected[0] || rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = (%q, %q), want (%q, %q)\", tc.input, num, rest, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "c32a429bd8165819c0e2efc39c6b825a": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: []string{\"hello\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello\\\"world\"`,\n\t\t\texpected: []string{\"hello\\\"world\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello\\\"world\\\"foo\"`,\n\t\t\texpected: []string{\"hello\\\"world\\\"foo\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with no closing quote\",\n\t\t\tinput:    `\"hello`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot, got2, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tc.expected[0] {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, expected %v\", got, tc.expected[0])\n\t\t\t}\n\t\t\tif got2 != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawString() got2 = %v, expected %v\", got2, tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "bfff9a81256b0c60aeeaa312fc7ea322": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"empty array\",\n\t\t\tinput:    \"[]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{}},\n\t\t},\n\t\t{\n\t\t\tname:     \"array with values\",\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}, &Value{t: TypeNumber, s: \"2\"}, &Value{t: TypeNumber, s: \"3\"}}},\n\t\t},\n\t\t{\n\t\t\tname:     \"array with whitespace\",\n\t\t\tinput:    \"[ 1 , 2 , 3 ]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}, &Value{t: TypeNumber, s: \"2\"}, &Value{t: TypeNumber, s: \"3\"}}},\n\t\t},\n\t\t{\n\t\t\tname:  \"missing closing bracket\",\n\t\t\tinput: \"[1, 2, 3\",\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"missing comma\",\n\t\t\tinput: \"[1 2, 3]\",\n\t\t\terr:   true,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, _, err := parseArray(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseArray(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !equalValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeTrue, TypeFalse, TypeNull:\n\t\treturn true\n\tdefault:\n\t\tpanic(\"unknown type\")\n\t}\n\treturn true\n}",
    "c3d3743fdc801655ec63135d7bb59672": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCache_getValue(t *testing.T) {\n\t// Test case 1: Capacity of the slice is greater than the length\n\tc := &cache{\n\t\tvs: make([]Value, 2),\n\t}\n\tv := c.getValue()\n\tif len(c.vs) != 3 {\n\t\tt.Errorf(\"Expected length of c.vs to be 3, got %d\", len(c.vs))\n\t}\n\tif v != &c.vs[2] {\n\t\tt.Errorf(\"Expected v to be the last element in c.vs, got %p\", v)\n\t}\n\n\t// Test case 2: Capacity of the slice is less than the length\n\tc = &cache{\n\t\tvs: make([]Value, 10, 10),\n\t}\n\tv = c.getValue()\n\tif len(c.vs) != 11 {\n\t\tt.Errorf(\"Expected length of c.vs to be 11, got %d\", len(c.vs))\n\t}\n\tif v != &c.vs[10] {\n\t\tt.Errorf(\"Expected v to be the last element in c.vs, got %p\", v)\n\t}\n}",
    "c2da5751cd2c5398838167b28b6919cf": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":\"value1\",\"key2\":42}`),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"str1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`[\"str1\",42,true]`),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\\\"world\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello\\\"world\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42.5\",\n\t\t\t},\n\t\t\twant: []byte(\"42.5\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %q, want %q\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c41fada46f28a36a945f14b1dabf43f8": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"no leading whitespace\",\n\t\t\tinput:    \"hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading space\",\n\t\t\tinput:    \" hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading newline\",\n\t\t\tinput:    \"\\nhello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading tab\",\n\t\t\tinput:    \"\\thello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading carriage return\",\n\t\t\tinput:    \"\\rhello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple leading whitespace\",\n\t\t\tinput:    \"   \\t\\n\\r hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"whitespace in the middle\",\n\t\t\tinput:    \"he llo\",\n\t\t\texpected: \"he llo\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := skipWSSlow(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"skipWSSlow(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c5cdd5f26f85c8b4f71fd4ad327b5a2e": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObjectReset(t *testing.T) {\n\t// Create a new Object\n\to := &Object{\n\t\tkvs:           []kv{{k: \"key1\", v: &Value{s: \"value1\"}}, {k: \"key2\", v: &Value{s: \"value2\"}}},\n\t\tkeysUnescaped: true,\n\t}\n\n\t// Call the reset method\n\to.reset()\n\n\t// Verify that the kvs slice is empty\n\tif len(o.kvs) != 0 {\n\t\tt.Errorf(\"expected kvs to be empty, got %v\", o.kvs)\n\t}\n\n\t// Verify that the keysUnescaped flag is false\n\tif o.keysUnescaped {\n\t\tt.Errorf(\"expected keysUnescaped to be false, got true\")\n\t}\n}",
    "c3ca300ea3ef3c2d58924dcfd3e7b4d8": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape double quotes\",\n\t\t\tinput:    \"\\\"hello, world\\\"\",\n\t\t\texpected: `\"hello, world\"`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backslash\",\n\t\t\tinput:    \"\\\\hello, world\\\\\",\n\t\t\texpected: `\\hello, world\\`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape forward slash\",\n\t\t\tinput:    \"/hello, world/\",\n\t\t\texpected: `/hello, world/`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backspace\",\n\t\t\tinput:    \"h\\bello, world\",\n\t\t\texpected: \"h\\bello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape form feed\",\n\t\t\tinput:    \"h\\fello, world\",\n\t\t\texpected: \"h\\fello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape newline\",\n\t\t\tinput:    \"h\\nello, world\",\n\t\t\texpected: \"h\\nello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape carriage return\",\n\t\t\tinput:    \"h\\rello, world\",\n\t\t\texpected: \"h\\rello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape tab\",\n\t\t\tinput:    \"h\\tello, world\",\n\t\t\texpected: \"h\\tello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Unicode character\",\n\t\t\tinput:    \"\\\\u00A9hello, world\",\n\t\t\texpected: \"Â©hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape surrogate pair\",\n\t\t\tinput:    \"\\\\uD83D\\\\uDE00hello, world\",\n\t\t\texpected: \"ðŸ˜€hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid escape sequence\",\n\t\t\tinput:    \"\\\\xhello, world\",\n\t\t\texpected: \"\\\\xhello, world\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c3f9de78bc4ab5f2c224c68fe6a512d2": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tjson     string\n\t\tkeys     []string\n\t\texpected *Object\n\t}{\n\t\t{\n\t\t\tname: \"Existing keys path\",\n\t\t\tjson: `{\"a\":{\"b\":1,\"c\":2}}`,\n\t\t\tkeys: []string{\"a\"},\n\t\t\texpected: &Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"b\", v: &Value{t: TypeNumber, s: \"1\"}},\n\t\t\t\t\t{k: \"c\", v: &Value{t: TypeNumber, s: \"2\"}},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"Non-existing keys path\",\n\t\t\tjson: `{\"a\":{\"b\":1,\"c\":2}}`,\n\t\t\tkeys: []string{\"x\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Invalid value type\",\n\t\t\tjson: `{\"a\":1}`,\n\t\t\tkeys: []string{\"a\"},\n\t\t\texpected: nil,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tv, err := Parse(tc.json)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t\t\t}\n\n\t\t\tobj := v.GetObject(tc.keys...)\n\t\t\tif obj != tc.expected {\n\t\t\t\tt.Errorf(\"unexpected object: got %v, want %v\", obj, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c4ca0fa3d11b72162681fabfbab58d61": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCache_getValue(t *testing.T) {\n\tc := &cache{\n\t\tvs: make([]Value, 0, 10),\n\t}\n\n\t// Test when the capacity is greater than the length\n\tv1 := c.getValue()\n\tif len(c.vs) != 1 {\n\t\tt.Errorf(\"expected length of c.vs to be 1, got %d\", len(c.vs))\n\t}\n\tif v1 != &c.vs[0] {\n\t\tt.Errorf(\"expected v1 to be the same as c.vs[0], got %p and %p\", v1, &c.vs[0])\n\t}\n\n\t// Test when the capacity is equal to the length\n\tfor i := 0; i < 9; i++ {\n\t\tc.getValue()\n\t}\n\tv2 := c.getValue()\n\tif len(c.vs) != 10 {\n\t\tt.Errorf(\"expected length of c.vs to be 10, got %d\", len(c.vs))\n\t}\n\tif v2 != &c.vs[9] {\n\t\tt.Errorf(\"expected v2 to be the same as c.vs[9], got %p and %p\", v2, &c.vs[9])\n\t}\n}",
    "c55ae409893aa760b6837960ae6d3139": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"no escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"simple escape characters\",\n\t\t\tinput:    \"hello\\\\\\\"world\\\\\\\\\",\n\t\t\texpected: \"hello\\\"world\\\\\",\n\t\t},\n\t\t{\n\t\t\tname:     \"complex escape characters\",\n\t\t\tinput:    \"hello\\\\n\\\\r\\\\t\\\\b\\\\f\\\\/\\\\u0123\\\\u4567\\\\u89ab\\\\ucdef\\\\U00010000\",\n\t\t\texpected: \"hello\\n\\r\\t\\b\\f/\\u0123\\u4567\\u89ab\\ucdef\\U00010000\",\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid escape characters\",\n\t\t\tinput:    \"hello\\\\x\",\n\t\t\texpected: \"hello\\\\x\",\n\t\t},\n\t\t{\n\t\t\tname:     \"incomplete surrogate pair\",\n\t\t\tinput:    \"hello\\\\u1234\",\n\t\t\texpected: \"hello\\\\u1234\",\n\t\t},\n\t\t{\n\t\t\tname:     \"valid surrogate pair\",\n\t\t\tinput:    \"hello\\\\u1234\\\\u5678\",\n\t\t\texpected: \"hello\\U00012345\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c5586c4ceae5d3f167bcc3ee23c33dbe": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.456e+78\",\n\t\t\texpected: []string{\"123.456e+78\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with leading sign\",\n\t\t\tinput:    \"-123.456\",\n\t\t\texpected: []string{\"-123.456\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with trailing characters\",\n\t\t\tinput:    \"123.456abc\",\n\t\t\texpected: []string{\"123.456\", \"abc\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number\",\n\t\t\tinput:    \"abc\",\n\t\t\texpected: []string{\"\", \"abc\"},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with 'inf' suffix\",\n\t\t\tinput:    \"inf\",\n\t\t\texpected: []string{\"inf\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with 'nan' suffix\",\n\t\t\tinput:    \"nan\",\n\t\t\texpected: []string{\"nan\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.expected[0] || rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, %q, want %q, %q\", tc.input, num, rest, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "c7df6ab3486acf816f4a9b764f6a03d8": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello world\"`,\n\t\t\texpected: []string{\"hello world\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello \\\"world\\\"\"`,\n\t\t\texpected: []string{\"hello \\\"world\\\"\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello \\\"world\\\" \\\"foo\\\"\"`,\n\t\t\texpected: []string{\"hello \\\"world\\\" \\\"foo\\\"\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with no closing quote\",\n\t\t\tinput:    `\"hello world`,\n\t\t\texpected: []string{},\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot1, got2, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got1 != tc.expected[0] || got2 != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, got2 = %v, want %v, %v\", got1, got2, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "c5cb7d728cb8fdc34f85c406b961cc9e": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape double quote\",\n\t\t\tinput:    \"\\\"hello, world\\\"\",\n\t\t\texpected: `\"hello, world\"`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backslash\",\n\t\t\tinput:    \"\\\\hello, world\\\\\",\n\t\t\texpected: `\\hello, world\\`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape forward slash\",\n\t\t\tinput:    \"/hello, world/\",\n\t\t\texpected: `/hello, world/`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backspace\",\n\t\t\tinput:    \"h\\bello, world\",\n\t\t\texpected: \"h\\bello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape form feed\",\n\t\t\tinput:    \"h\\fello, world\",\n\t\t\texpected: \"h\\fello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape newline\",\n\t\t\tinput:    \"h\\nello, world\",\n\t\t\texpected: \"h\\nello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape carriage return\",\n\t\t\tinput:    \"h\\rello, world\",\n\t\t\texpected: \"h\\rello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape tab\",\n\t\t\tinput:    \"h\\tello, world\",\n\t\t\texpected: \"h\\tello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Unicode\",\n\t\t\tinput:    \"\\\\u0041\\\\u0042\\\\u0043\",\n\t\t\texpected: \"ABC\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Surrogate Pair\",\n\t\t\tinput:    \"\\\\ud83d\\\\ude00\",\n\t\t\texpected: \"ðŸ˜€\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid Escape Sequence\",\n\t\t\tinput:    \"\\\\x\",\n\t\t\texpected: \"\\\\x\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c764ce35ca14ae6a72207278122d0d5b": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":\"value1\",\"key2\":42}`),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"hello\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`[\"hello\",42,true]`),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42\",\n\t\t\t},\n\t\t\twant: []byte(\"42\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %q, want %q\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c862c57bfd6664eb3772ddfd9cc5ec8c": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Simple escape characters\",\n\t\t\tinput:    \"hello\\\\\\\"world\\\\\\\\\",\n\t\t\texpected: \"hello\\\"world\\\\\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Unicode escape characters\",\n\t\t\tinput:    \"hello\\\\u0123world\\\\u4567\",\n\t\t\texpected: \"hello\\u0123world\\u4567\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Surrogate pair escape characters\",\n\t\t\tinput:    \"hello\\\\ud83d\\\\ude00world\",\n\t\t\texpected: \"helloðŸ˜€world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid escape characters\",\n\t\t\tinput:    \"hello\\\\xyzworld\",\n\t\t\texpected: \"hello\\\\xyzworld\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "cac4f04680835dd843013cfc1b730880": "package fastjson\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n)\n\nfunc TestEscapeString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []byte\n\t}{\n\t\t{\n\t\t\tname:     \"no special characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: []byte(`\"hello, world\"`),\n\t\t},\n\t\t{\n\t\t\tname:     \"with special characters\",\n\t\t\tinput:    `hello, \"world\"`,\n\t\t\texpected: []byte(`\"hello, \\\"world\\\"\"\"`),\n\t\t},\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: []byte(`\"\"`),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdst := make([]byte, 0, len(tc.input)+2)\n\t\t\tresult := escapeString(dst, tc.input)\n\t\t\tif !bytes.Equal(result, tc.expected) {\n\t\t\t\tt.Errorf(\"escapeString(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c9f4acd3cb04b2ed994e2e7099cc5b41": "package fastjson_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/valyala/fastjson\"\n)\n\nfunc TestTypeString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    fastjson.Type\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"TypeObject\",\n\t\t\tinput:    fastjson.TypeObject,\n\t\t\texpected: \"object\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeArray\",\n\t\t\tinput:    fastjson.TypeArray,\n\t\t\texpected: \"array\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeString\",\n\t\t\tinput:    fastjson.TypeString,\n\t\t\texpected: \"string\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeNumber\",\n\t\t\tinput:    fastjson.TypeNumber,\n\t\t\texpected: \"number\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeTrue\",\n\t\t\tinput:    fastjson.TypeTrue,\n\t\t\texpected: \"true\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeFalse\",\n\t\t\tinput:    fastjson.TypeFalse,\n\t\t\texpected: \"false\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeNull\",\n\t\t\tinput:    fastjson.TypeNull,\n\t\t\texpected: \"null\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Unknown Type\",\n\t\t\tinput:    fastjson.Type(100),\n\t\t\texpected: \"BUG: unknown Value type: 100\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := tc.input.String()\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"expected %q, got %q\", tc.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "cb8b337a5da945f53db16b6db1e7cef5": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid key without escape sequences\",\n\t\t\tinput:    `\"key\"`,\n\t\t\texpected: \"key\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"key with escape sequence\",\n\t\t\tinput:    `\"key\\\"with\\\"escape\"`,\n\t\t\texpected: \"\",\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing closing quote\",\n\t\t\tinput:    `\"key`,\n\t\t\texpected: \"\",\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tkey, _, err := parseRawKey(tc.input)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseRawKey(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif key != tc.expected {\n\t\t\t\tt.Errorf(\"parseRawKey(%q) = %q, want %q\", tc.input, key, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c8009aa53c1b79da028713d43677a10e": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty array\",\n\t\t\tinput: \"[]\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with values\",\n\t\t\tinput: \"[1, 2, 3]\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv1 := &Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"1\",\n\t\t\t\t}\n\t\t\t\tv2 := &Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"2\",\n\t\t\t\t}\n\t\t\t\tv3 := &Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"3\",\n\t\t\t\t}\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{v1, v2, v3},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with missing closing bracket\",\n\t\t\tinput: \"[1, 2, 3\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with missing comma\",\n\t\t\tinput: \"[1 2]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tactual, _, err := parseArray(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseArray(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !compareValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !compareValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeTrue, TypeFalse, TypeNull:\n\t\treturn true\n\t}\n\treturn true\n}",
    "c89109383f77829fd96d34eb2ecc83ef": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: &Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":\"value1\",\"key2\":42}`),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"str1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`[\"str1\",42,true]`),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\\\"world\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello\\\"world\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42.5\",\n\t\t\t},\n\t\t\twant: []byte(\"42.5\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %q, want %q\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "cb85710523cfb04cdcdf04451f7449d2": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: []string{\"hello\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello\\\"world\"`,\n\t\t\texpected: []string{\"hello\\\"world\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello\\\"world\\\"foo\"`,\n\t\t\texpected: []string{\"hello\\\"world\\\"foo\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with no closing quote\",\n\t\t\tinput:    `\"hello`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\ts, r, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif s != tc.expected[0] || r != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = %q, %q, want %q, %q\", tc.input, s, r, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "c6faba2bbfc994b9485296bddc91361b": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: \"{}\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with one key-value pair\",\n\t\t\tinput: `{\"key\":\"value\"}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with multiple key-value pairs\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":123,\"key3\":true}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\tinput: `{\"key1\":\"value1\",`,\n\t\t\texpected: nil,\n\t\t\terr:     true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing colon\",\n\t\t\tinput: `{\"key1\" \"value1\"}`,\n\t\t\texpected: nil,\n\t\t\terr:     true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing comma\",\n\t\t\tinput: `{\"key1\":\"value1\" \"key2\":\"value2\"}`,\n\t\t\texpected: nil,\n\t\t\terr:     true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tactual, _, err := parseObject(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn compareObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn compareArrays(v1.a, v2.a)\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber, TypeTrue, TypeFalse:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\treturn true\n\t}\n}\n\nfunc compareObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc compareArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tif !compareValues(v1, a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "cc2ca3ffb95a189c0927b89f2ea28794": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: []string{\"hello\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello\\\"world\"`,\n\t\t\texpected: []string{\"hello\\\"world\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello\\\"world\\\"foo\"`,\n\t\t\texpected: []string{\"hello\\\"world\\\"foo\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with no closing quote\",\n\t\t\tinput:    `\"hello`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult, rest, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif result != tc.expected[0] || rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = %q, %q, want %q, %q\", tc.input, result, rest, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "ce19768ad4ca3977d0976120357c68d6": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"no whitespace\",\n\t\t\tinput:    \"hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading whitespace\",\n\t\t\tinput:    \"   hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"trailing whitespace\",\n\t\t\tinput:    \"hello   \",\n\t\t\texpected: \"hello   \",\n\t\t},\n\t\t{\n\t\t\tname:     \"mixed whitespace\",\n\t\t\tinput:    \"   hello   \",\n\t\t\texpected: \"hello   \",\n\t\t},\n\t\t{\n\t\t\tname:     \"all whitespace\",\n\t\t\tinput:    \"   \\t\\n\\r   \",\n\t\t\texpected: \"\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := skipWSSlow(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"skipWSSlow(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "cd09872ff98ed51df9fc60253203ac1c": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: []string{\"hello\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello\\\"world\"`,\n\t\t\texpected: []string{\"hello\\\"world\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello\\\"world\\\"foo\"`,\n\t\t\texpected: []string{\"hello\\\"world\\\"foo\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with no closing quote\",\n\t\t\tinput:    `\"hello`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\ts, rest, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif s != tc.expected[0] {\n\t\t\t\tt.Errorf(\"parseRawString() s = %v, want %v\", s, tc.expected[0])\n\t\t\t}\n\t\t\tif rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawString() rest = %v, want %v\", rest, tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "cc89c1bed9800d39da5e4dc1a0fd47ba": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.456e+78\",\n\t\t\texpected: []string{\"123.456e+78\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with leading zeros\",\n\t\t\tinput:    \"0123.456\",\n\t\t\texpected: []string{\"0123.456\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with sign\",\n\t\t\tinput:    \"-123.456\",\n\t\t\texpected: []string{\"-123.456\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with inf\",\n\t\t\tinput:    \"inf\",\n\t\t\texpected: []string{\"inf\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with nan\",\n\t\t\tinput:    \"nan\",\n\t\t\texpected: []string{\"nan\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number\",\n\t\t\tinput:    \"123.456a\",\n\t\t\texpected: []string{\"\", \"a\"},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.expected[0] || rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = (%q, %q), want (%q, %q)\", tc.input, num, rest, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "c80f450b5ed4b0fa2ce024b7f69bb8fc": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: \"{}\",\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           []kv{},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with one key-value pair\",\n\t\t\tinput: `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with multiple key-value pairs\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42,\"key3\":true}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"42\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42`,\n\t\t\texpected: nil,\n\t\t\terr:      ErrMissingClosingBrace,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing colon\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\"}`,\n\t\t\texpected: nil,\n\t\t\terr:      ErrMissingColon,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing value\",\n\t\t\tinput: `{\"key1\":\"value1\",,\"key2\":42}`,\n\t\t\texpected: nil,\n\t\t\terr:      ErrMissingValue,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tactual, _, err := parseObject(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil {\n\t\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t\t} else if err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"expected error %v, got %v\", tc.err, err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif tc.err != nil {\n\t\t\t\tt.Errorf(\"expected error %v, got nil\", tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !equalValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"expected %+v, got %+v\", tc.expected, actual)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn equalObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn equalArrays(v1.a, v2.a)\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber, TypeTrue, TypeFalse:\n\t\treturn v1.s == v2.s\n\tcase TypeNull:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc equalObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !equalValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc equalArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tif !equalValues(v1, a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "cf569eccca807a583e3e1abb4542ed42": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: []string{\"hello\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello\\\"world\"`,\n\t\t\texpected: []string{\"hello\\\"world\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello\\\"world\\\"foo\"`,\n\t\t\texpected: []string{\"hello\\\"world\\\"foo\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with no closing quote\",\n\t\t\tinput:    `\"hello`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot1, got2, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got1 != tc.expected[0] || got2 != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = (%q, %q), want (%q, %q)\", tc.input, got1, got2, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "cee6ab93546cb62c80fb31265cc0b0c3": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.45e+6\",\n\t\t\texpected: []string{\"123.45e+6\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with leading zeros\",\n\t\t\tinput:    \"0123.45\",\n\t\t\texpected: []string{\"0123.45\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with sign\",\n\t\t\tinput:    \"-123.45\",\n\t\t\texpected: []string{\"-123.45\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with inf\",\n\t\t\tinput:    \"inf\",\n\t\t\texpected: []string{\"inf\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with nan\",\n\t\t\tinput:    \"nan\",\n\t\t\texpected: []string{\"nan\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid character\",\n\t\t\tinput:    \"123.45a\",\n\t\t\texpected: []string{\"\", \"a\"},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.expected[0] || rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, %q, want %q, %q\", tc.input, num, rest, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "cd6cb6e8218d1f8c8539694471a3eebe": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"hello world\",\n\t\t\texpected: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape double quote\",\n\t\t\tinput:    \"\\\"hello\\\" world\",\n\t\t\texpected: `\"hello\" world`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backslash\",\n\t\t\tinput:    \"hello\\\\ world\",\n\t\t\texpected: `hello\\\\ world`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape forward slash\",\n\t\t\tinput:    \"hello/ world\",\n\t\t\texpected: `hello/ world`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backspace\",\n\t\t\tinput:    \"hello\\b world\",\n\t\t\texpected: `hello\\b world`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape form feed\",\n\t\t\tinput:    \"hello\\f world\",\n\t\t\texpected: `hello\\f world`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape newline\",\n\t\t\tinput:    \"hello\\n world\",\n\t\t\texpected: `hello\\n world`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape carriage return\",\n\t\t\tinput:    \"hello\\r world\",\n\t\t\texpected: `hello\\r world`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape tab\",\n\t\t\tinput:    \"hello\\t world\",\n\t\t\texpected: `hello\\t world`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Unicode character\",\n\t\t\tinput:    \"hello\\u0123 world\",\n\t\t\texpected: `hello\\u0123 world`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape surrogate pair\",\n\t\t\tinput:    \"hello\\uD83D\\uDE00 world\",\n\t\t\texpected: \"helloðŸ˜€ world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Incomplete escape sequence\",\n\t\t\tinput:    \"hello\\u001 world\",\n\t\t\texpected: `hello\\u001 world`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid escape sequence\",\n\t\t\tinput:    \"hello\\u123g world\",\n\t\t\texpected: `hello\\u123g world`,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "cfc916037e0bc9ef8c3ad68cd5ccc315": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGet(t *testing.T) {\n\t// Test cases\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    *Value\n\t\tkeys     []string\n\t\texpected *Value\n\t}{\n\t\t{\n\t\t\tname: \"Existing keys path\",\n\t\t\tinput: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{a: []*Value{&Value{s: \"value2\"}, &Value{s: \"value3\"}}}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"key1\", \"key2\", \"0\"},\n\t\t\texpected: &Value{s: \"value2\"},\n\t\t},\n\t\t{\n\t\t\tname: \"Non-existing keys path\",\n\t\t\tinput: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{s: \"value1\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"key1\", \"key2\", \"0\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Array index out of range\",\n\t\t\tinput: &Value{\n\t\t\t\ta: []*Value{&Value{s: \"value1\"}, &Value{s: \"value2\"}},\n\t\t\t},\n\t\t\tkeys:     []string{\"2\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Nil input\",\n\t\t\tinput:    nil,\n\t\t\tkeys:     []string{\"key1\"},\n\t\t\texpected: nil,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := tc.input.Get(tc.keys...)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"Get(%v) = %v, expected %v\", tc.keys, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "cd096a26bec96244813fa324ca0118d3": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tinput   string\n\t\twantVal *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty string\",\n\t\t\tinput: \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"depth exceeded\",\n\t\t\tinput: \"{}\", // Assuming MaxDepth is 1\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"valid object\",\n\t\t\tinput: `{\"key\":\"value\"}`,\n\t\t\twantVal: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{t: typeRawString, s: \"value\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"valid array\",\n\t\t\tinput: `[1,2,3]`,\n\t\t\twantVal: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"valid string\",\n\t\t\tinput: `\"hello\"`,\n\t\t\twantVal: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"valid true\",\n\t\t\tinput: \"true\",\n\t\t\twantVal: valueTrue,\n\t\t},\n\t\t{\n\t\t\tname:  \"valid false\",\n\t\t\tinput: \"false\",\n\t\t\twantVal: valueFalse,\n\t\t},\n\t\t{\n\t\t\tname:  \"valid null\",\n\t\t\tinput: \"null\",\n\t\t\twantVal: valueNull,\n\t\t},\n\t\t{\n\t\t\tname:  \"valid number\",\n\t\t\tinput: \"42\",\n\t\t\twantVal: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42\",\n\t\t\t},\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotVal, _, err := parseValue(tt.input, c, 0)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !equalValues(gotVal, tt.wantVal) {\n\t\t\t\tt.Errorf(\"parseValue() = %v, want %v\", gotVal, tt.wantVal)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn equalObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn equalArrays(v1.a, v2.a)\n\tcase typeRawString, TypeNumber, TypeTrue, TypeFalse, TypeNull:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc equalObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !equalValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc equalArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tif !equalValues(v1, a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "cbef8bb22fee92b10afa87f54f0a53b0": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty input\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"too deep nested JSON\",\n\t\t\tinput:    \"{\\\"key\\\":{\\\"key2\\\":{\\\"key3\\\":{\\\"key4\\\":\\\"value\\\"}}}}\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t},\n\t\t{\n\t\t\tname:     \"valid object\",\n\t\t\tinput:    `{\"key\":\"value\",\"key2\":123,\"key3\":true,\"key4\":null}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{s: \"value\", t: TypeString}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{s: \"123\", t: TypeNumber}},\n\t\t\t\t\t\t{k: \"key3\", v: &Value{t: TypeTrue}},\n\t\t\t\t\t\t{k: \"key4\", v: &Value{t: TypeNull}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid array\",\n\t\t\tinput:    `[1,2,3,4,5]`,\n\t\t\texpected: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"1\", t: TypeNumber},\n\t\t\t\t\t{s: \"2\", t: TypeNumber},\n\t\t\t\t\t{s: \"3\", t: TypeNumber},\n\t\t\t\t\t{s: \"4\", t: TypeNumber},\n\t\t\t\t\t{s: \"5\", t: TypeNumber},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid string\",\n\t\t\tinput:    `\"hello, world\"`,\n\t\t\texpected: &Value{\n\t\t\t\ts: \"hello, world\",\n\t\t\t\tt: TypeString,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid true\",\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid false\",\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid null\",\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.456\",\n\t\t\texpected: &Value{\n\t\t\t\ts: \"123.456\",\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, expected %v\", tc.input, err, tc.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else if tc.err != nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = nil, expected %v\", tc.input, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, expected %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn compareObjects(v1.o, v2.o)\n\tcase TypeArray:\n\t\treturn compareArrays(v1.a, v2.a)\n\tcase TypeString, TypeNumber, TypeTrue, TypeFalse, TypeNull, typeRawString:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc compareObjects(o1, o2 Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc compareArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tif !compareValues(v1, a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "d17936696f61395fe3f9b52667ef3ece": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"no leading whitespace\",\n\t\t\tinput:    \"hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading space\",\n\t\t\tinput:    \" hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading newline\",\n\t\t\tinput:    \"\\nhello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading tab\",\n\t\t\tinput:    \"\\thello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading carriage return\",\n\t\t\tinput:    \"\\rhello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"trailing whitespace\",\n\t\t\tinput:    \"hello \",\n\t\t\texpected: \"hello \",\n\t\t},\n\t\t{\n\t\t\tname:     \"all whitespace\",\n\t\t\tinput:    \"   \\n\\t\\r\",\n\t\t\texpected: \"\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := skipWSSlow(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"skipWSSlow(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "d37f73f2514549345a227ae9b96d41ee": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantKey  string\n\t\twantRest string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple key\",\n\t\t\tinput:    `\"key\":`,\n\t\t\twantKey:  \"key\",\n\t\t\twantRest: \":\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"key with escape sequence\",\n\t\t\tinput:    `\"key\\\"with\\\"escape\":`,\n\t\t\twantKey:  `key\"with\"escape`,\n\t\t\twantRest: \":\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing closing quote\",\n\t\t\tinput:    `\"key`,\n\t\t\twantKey:  \"key\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tkey, rest, err := parseRawKey(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawKey(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif key != tc.wantKey {\n\t\t\t\tt.Errorf(\"parseRawKey(%q) key = %q, want %q\", tc.input, key, tc.wantKey)\n\t\t\t}\n\t\t\tif rest != tc.wantRest {\n\t\t\t\tt.Errorf(\"parseRawKey(%q) rest = %q, want %q\", tc.input, rest, tc.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "ce393aeae9568082d69d7a6c00ded17e": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"too big depth\",\n\t\t\tinput:    \"{}\", // Assuming MaxDepth is 1\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds 1\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"valid object\",\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t\tt: typeRawString,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{\n\t\t\t\ts: \"hello\",\n\t\t\t\tt: typeRawString,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid true\",\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid false\",\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid null\",\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"42\",\n\t\t\texpected: &Value{\n\t\t\t\ts: \"42\",\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, expected %v\", tc.input, err, tc.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else if tc.err != nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = nil, expected %v\", tc.input, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, expected %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn compareObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn compareArrays(v1.a, v2.a)\n\tcase typeRawString, TypeNumber, TypeTrue, TypeFalse, TypeNull:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc compareObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i := range o1.kvs {\n\t\tif o1.kvs[i].k != o2.kvs[i].k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(o1.kvs[i].v, o2.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc compareArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i := range a1 {\n\t\tif !compareValues(a1[i], a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "d022cd027712a505cb7c482afa838bb6": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"too deep\",\n\t\t\tinput:    \"{}\", // depth exceeds MaxDepth\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t},\n\t\t{\n\t\t\tname:     \"valid object\",\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{s: \"value\", t: typeRawString}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"1\", t: TypeNumber},\n\t\t\t\t\t{s: \"2\", t: TypeNumber},\n\t\t\t\t\t{s: \"3\", t: TypeNumber},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{s: \"hello\", t: typeRawString},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid true\",\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid false\",\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid null\",\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"42\",\n\t\t\texpected: &Value{s: \"42\", t: TypeNumber},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid value\",\n\t\t\tinput:    \"invalid\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"unexpected value found: %q\", \"invalid\"),\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tv, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, expected %v\", tc.input, err, tc.err)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif !v.Equal(tc.expected) {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) = %v, expected %v\", tc.input, v, tc.expected)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}",
    "d08a0b4bda078a33a560fef033579209": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape double quote\",\n\t\t\tinput:    \"\\\"hello, world\\\"\",\n\t\t\texpected: `\"hello, world\"`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backslash\",\n\t\t\tinput:    \"\\\\hello, world\\\\\",\n\t\t\texpected: `\\hello, world\\`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape forward slash\",\n\t\t\tinput:    \"/hello, world/\",\n\t\t\texpected: `/hello, world/`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backspace\",\n\t\t\tinput:    \"h\\bello, world\",\n\t\t\texpected: \"h\\bello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape form feed\",\n\t\t\tinput:    \"h\\fello, world\",\n\t\t\texpected: \"h\\fello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape newline\",\n\t\t\tinput:    \"h\\nello, world\",\n\t\t\texpected: \"h\\nello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape carriage return\",\n\t\t\tinput:    \"h\\rello, world\",\n\t\t\texpected: \"h\\rello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape tab\",\n\t\t\tinput:    \"h\\tello, world\",\n\t\t\texpected: \"h\\tello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Unicode character\",\n\t\t\tinput:    \"\\\\u00A9hello, world\",\n\t\t\texpected: \"Â©hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape invalid Unicode character\",\n\t\t\tinput:    \"\\\\u00Xhello, world\",\n\t\t\texpected: \"\\\\u00Xhello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape surrogate pair\",\n\t\t\tinput:    \"\\\\uD83D\\\\uDE00hello, world\",\n\t\t\texpected: \"ðŸ˜€hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape invalid surrogate pair\",\n\t\t\tinput:    \"\\\\uD83D\\\\uXXXXhello, world\",\n\t\t\texpected: \"\\\\uD83D\\\\uXXXXhello, world\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "d384e78a0455b8094e0cc981c2bfffd0": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestObject_unescapeKeys(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\to    *Object\n\t\twant *Object\n\t}{\n\t\t{\n\t\t\tname: \"unescaped keys\",\n\t\t\to: &Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"key1\", v: &Value{}},\n\t\t\t\t\t{k: \"key2\", v: &Value{}},\n\t\t\t\t},\n\t\t\t\tkeysUnescaped: false,\n\t\t\t},\n\t\t\twant: &Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"key1\", v: &Value{}},\n\t\t\t\t\t{k: \"key2\", v: &Value{}},\n\t\t\t\t},\n\t\t\t\tkeysUnescaped: true,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"already unescaped keys\",\n\t\t\to: &Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"key1\", v: &Value{}},\n\t\t\t\t\t{k: \"key2\", v: &Value{}},\n\t\t\t\t},\n\t\t\t\tkeysUnescaped: true,\n\t\t\t},\n\t\t\twant: &Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"key1\", v: &Value{}},\n\t\t\t\t\t{k: \"key2\", v: &Value{}},\n\t\t\t\t},\n\t\t\t\tkeysUnescaped: true,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\ttt.o.unescapeKeys()\n\t\t\tif !reflect.DeepEqual(tt.o, tt.want) {\n\t\t\t\tt.Errorf(\"Object.unescapeKeys() = %v, want %v\", tt.o, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "d19552cb4a85b8bdc7ee59d416f1defb": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":\"value1\",\"key2\":42}`),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"str1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t\t{t: TypeFalse},\n\t\t\t\t\t{t: TypeNull},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`[\"str1\",42,true,false,null]`),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\\\"world\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello\\\"world\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"3.14\",\n\t\t\t},\n\t\t\twant: []byte(\"3.14\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %q, want %q\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "d2756c18d2278ae148d9b3426eb9553b": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"valid object\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"missing closing brace\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42`,\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"missing colon\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\" 42}`,\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"missing key\",\n\t\t\tinput: `{:\"value1\",\"key2\":42}`,\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"invalid value\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":true}`,\n\t\t\terr:   true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tv, _, err := parseObject(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err == nil && !v.Equal(tc.expected) {\n\t\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", tc.input, v, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "d1c42aa0ff9a668dfcf23c9f797c946e": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: \"{}\",\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           []kv{},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with one key-value pair\",\n\t\t\tinput: `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with multiple key-value pairs\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":123,\"key3\":true}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\tinput: `{\"key1\":\"value1\",`,\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing colon\",\n\t\t\tinput: `{\"key1\" \"value1\"}`,\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing comma\",\n\t\t\tinput: `{\"key1\":\"value1\" \"key2\":\"value2\"}`,\n\t\t\terr:   true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tv, _, err := parseObject(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !v.Equal(tc.expected) {\n\t\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", tc.input, v, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "d6b58a3300f6f0aa3be4fdc50d3224d9": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestStringBytes(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tv       *Value\n\t\twant    []byte\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"valid string\",\n\t\t\tv: &Value{\n\t\t\t\ts: \"hello, world\",\n\t\t\t\tt: TypeString,\n\t\t\t},\n\t\t\twant:    []byte(\"hello, world\"),\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"non-string type\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := tt.v.StringBytes()\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"StringBytes() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"StringBytes() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "d4b604f7b013fd7cbb085e5d0f4c170d": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.456\",\n\t\t\texpected: []string{\"123.456\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with exponent\",\n\t\t\tinput:    \"1.2e+3\",\n\t\t\texpected: []string{\"1.2e+3\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with sign\",\n\t\t\tinput:    \"-0.789\",\n\t\t\texpected: []string{\"-0.789\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number\",\n\t\t\tinput:    \"abc\",\n\t\t\texpected: []string{\"\", \"abc\"},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"infinity\",\n\t\t\tinput:    \"inf\",\n\t\t\texpected: []string{\"inf\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN\",\n\t\t\tinput:    \"nan\",\n\t\t\texpected: []string{\"nan\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.expected[0] || rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, %q, want %q, %q\", tc.input, num, rest, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "d82823f69afa030b585520cf90bdf567": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestTypeString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    Type\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"TypeObject\",\n\t\t\tinput:    TypeObject,\n\t\t\texpected: \"object\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeArray\",\n\t\t\tinput:    TypeArray,\n\t\t\texpected: \"array\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeString\",\n\t\t\tinput:    TypeString,\n\t\t\texpected: \"string\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeNumber\",\n\t\t\tinput:    TypeNumber,\n\t\t\texpected: \"number\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeTrue\",\n\t\t\tinput:    TypeTrue,\n\t\t\texpected: \"true\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeFalse\",\n\t\t\tinput:    TypeFalse,\n\t\t\texpected: \"false\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeNull\",\n\t\t\tinput:    TypeNull,\n\t\t\texpected: \"null\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Unknown Type\",\n\t\t\tinput:    Type(100),\n\t\t\texpected: \"<unknown>\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := tc.input.String()\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"expected %q, got %q\", tc.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "dd219a2aa44bcb66c6744f5b2ba36ce9": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"no escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"simple escape characters\",\n\t\t\tinput:    \"hello\\\\\\\"world\\\\\\\\\",\n\t\t\texpected: \"hello\\\"world\\\\\",\n\t\t},\n\t\t{\n\t\t\tname:     \"unicode escape characters\",\n\t\t\tinput:    \"hello\\\\u0041world\",\n\t\t\texpected: \"helloAworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"surrogate pair escape characters\",\n\t\t\tinput:    \"hello\\\\ud83d\\\\ude00world\",\n\t\t\texpected: \"helloðŸ˜€world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid unicode escape characters\",\n\t\t\tinput:    \"hello\\\\u123world\",\n\t\t\texpected: \"hello\\\\u123world\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "dc8ba8ea3d6e15a7873c4367652b2c60": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"no leading whitespace\",\n\t\t\tinput:    \"hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading space\",\n\t\t\tinput:    \" hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading newline\",\n\t\t\tinput:    \"\\nhello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading tab\",\n\t\t\tinput:    \"\\thello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading carriage return\",\n\t\t\tinput:    \"\\rhello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple leading whitespace\",\n\t\t\tinput:    \"   \\t\\n\\rhello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"whitespace only\",\n\t\t\tinput:    \"   \\t\\n\\r\",\n\t\t\texpected: \"\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := skipWSSlow(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"skipWSSlow(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "d5afcbd21334131754f319a21296c8e1": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"empty array\",\n\t\t\tinput:    \"[]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with values\",\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{&Value{t: TypeNumber, s: \"1\"}, &Value{t: TypeNumber, s: \"2\"}, &Value{t: TypeNumber, s: \"3\"}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with missing closing bracket\",\n\t\t\tinput:    \"[1, 2, 3\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with missing comma\",\n\t\t\tinput:    \"[1 2]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, _, err := parseArray(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseArray(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeArray:\n\t\ta1, _ := v1.Array()\n\t\ta2, _ := v2.Array()\n\t\tif len(a1) != len(a2) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range a1 {\n\t\t\tif !compareValues(a1[i], a2[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\tcase TypeObject:\n\t\to1, _ := v1.Object()\n\t\to2, _ := v2.Object()\n\t\tif o1.Len() != o2.Len() {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range o1.kvs {\n\t\t\tif o1.kvs[i].k != o2.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !compareValues(o1.kvs[i].v, o2.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\tcase TypeString:\n\t\ts1, _ := v1.StringBytes()\n\t\ts2, _ := v2.StringBytes()\n\t\treturn string(s1) == string(s2)\n\tcase TypeNumber, TypeTrue, TypeFalse:\n\t\treturn v1.s == v2.s\n\tcase TypeNull:\n\t\treturn true\n\t}\n\treturn true\n}",
    "db61f8c8bafafa3f785b8278370ea805": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected1, expected2 string\n\t\texpectedErr bool\n\t}{\n\t\t{\n\t\t\tname:  \"simple string\",\n\t\t\tinput: `\"hello\"`,\n\t\t\texpected1: \"hello\",\n\t\t\texpected2: \"\",\n\t\t\texpectedErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"string with escaped quote\",\n\t\t\tinput: `\"hello\\\"world\"`,\n\t\t\texpected1: \"hello\\\"world\",\n\t\t\texpected2: \"\",\n\t\t\texpectedErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"string with multiple escaped quotes\",\n\t\t\tinput: `\"hello\\\"world\\\"foo\"`,\n\t\t\texpected1: \"hello\\\"world\\\"foo\",\n\t\t\texpected2: \"\",\n\t\t\texpectedErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"string with no closing quote\",\n\t\t\tinput: `\"hello`,\n\t\t\texpected1: \"\",\n\t\t\texpected2: \"\",\n\t\t\texpectedErr: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult1, result2, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.expectedErr {\n\t\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expectedErr = %t\", tc.input, err, tc.expectedErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif result1 != tc.expected1 {\n\t\t\t\tt.Errorf(\"parseRawString(%q) result1 = %q, expected %q\", tc.input, result1, tc.expected1)\n\t\t\t}\n\t\t\tif result2 != tc.expected2 {\n\t\t\t\tt.Errorf(\"parseRawString(%q) result2 = %q, expected %q\", tc.input, result2, tc.expected2)\n\t\t\t}\n\t\t})\n\t}\n}",
    "de1d09d9d4effb17d78a1263560aee71": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"no whitespace\",\n\t\t\tinput:    \"hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading whitespace\",\n\t\t\tinput:    \"   hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading and trailing whitespace\",\n\t\t\tinput:    \"   hello   \",\n\t\t\texpected: \"hello   \",\n\t\t},\n\t\t{\n\t\t\tname:     \"all whitespace\",\n\t\t\tinput:    \"   \\t\\n\\r\",\n\t\t\texpected: \"\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := skipWSSlow(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"skipWSSlow(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "dc8534c514a95ac790249388b3fb0c86": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.45e+6\",\n\t\t\texpected: []string{\"123.45e+6\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with leading zeros\",\n\t\t\tinput:    \"0123.45\",\n\t\t\texpected: []string{\"0123.45\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with sign\",\n\t\t\tinput:    \"-123.45\",\n\t\t\texpected: []string{\"-123.45\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with inf\",\n\t\t\tinput:    \"inf\",\n\t\t\texpected: []string{\"inf\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with nan\",\n\t\t\tinput:    \"nan\",\n\t\t\texpected: []string{\"nan\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number\",\n\t\t\tinput:    \"123.45x\",\n\t\t\texpected: []string{\"\", \"123.45x\"},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.expected[0] || rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = (%q, %q), want (%q, %q)\", tc.input, num, rest, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "dde25cf643e56e97e53ca4ead8c2e7f0": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.456e+7\",\n\t\t\texpected: []string{\"123.456e+7\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with leading zeros\",\n\t\t\tinput:    \"0123.456\",\n\t\t\texpected: []string{\"0123.456\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with sign\",\n\t\t\tinput:    \"-123.456\",\n\t\t\texpected: []string{\"-123.456\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with exponent\",\n\t\t\tinput:    \"1.2e-3\",\n\t\t\texpected: []string{\"1.2e-3\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number\",\n\t\t\tinput:    \"123.456abc\",\n\t\t\texpected: []string{\"\", \"abc\"},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty input\",\n\t\t\tinput:    \"\",\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"inf\",\n\t\t\tinput:    \"inf\",\n\t\t\texpected: []string{\"inf\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"nan\",\n\t\t\tinput:    \"nan\",\n\t\t\texpected: []string{\"nan\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.expected[0] || rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = (%q, %q), want (%q, %q)\", tc.input, num, rest, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "df4c44fc41f3659b59dbb32405ad0613": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetBool(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    *Value\n\t\tkeys     []string\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname:     \"true value\",\n\t\t\tinput:    &Value{t: TypeTrue},\n\t\t\tkeys:     []string{},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"false value\",\n\t\t\tinput:    &Value{t: TypeFalse},\n\t\t\tkeys:     []string{},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"non-existing key\",\n\t\t\tinput:    &Value{},\n\t\t\tkeys:     []string{\"non-existing\"},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid value type\",\n\t\t\tinput:    &Value{t: TypeString, s: \"string value\"},\n\t\t\tkeys:     []string{},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"nested object\",\n\t\t\tinput:    &Value{o: Object{kvs: []kv{{\"key\", &Value{t: TypeTrue}}}}, t: TypeObject},\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"nested array\",\n\t\t\tinput:    &Value{a: []*Value{&Value{t: TypeTrue}}, t: TypeArray},\n\t\t\tkeys:     []string{\"0\"},\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := tc.input.GetBool(tc.keys...)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"GetBool(%v) = %v, expected %v\", tc.keys, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "d4399876666ac672c67f3ad25ddf2cf4": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"too deep\",\n\t\t\tinput:    \"{}\", // depth exceeds MaxDepth\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t},\n\t\t{\n\t\t\tname:     \"valid object\",\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{s: \"value\", t: typeRawString}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"1\", t: TypeNumber},\n\t\t\t\t\t{s: \"2\", t: TypeNumber},\n\t\t\t\t\t{s: \"3\", t: TypeNumber},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{s: \"hello\", t: typeRawString},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid true\",\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid false\",\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid null\",\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"42\",\n\t\t\texpected: &Value{s: \"42\", t: TypeNumber},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid value\",\n\t\t\tinput:    \"invalid\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"unexpected value found: %q\", \"invalid\"),\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tv, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, expected %v\", tc.input, err, tc.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else if tc.err != nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = nil, expected %v\", tc.input, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !compareValues(v, tc.expected) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, expected %v\", tc.input, v, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\to1, _ := v1.Object()\n\t\to2, _ := v2.Object()\n\t\treturn compareObjects(o1, o2)\n\tcase TypeArray:\n\t\ta1, _ := v1.Array()\n\t\ta2, _ := v2.Array()\n\t\tif len(a1) != len(a2) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range a1 {\n\t\t\tif !compareValues(a1[i], a2[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase typeRawString, TypeNumber, TypeTrue, TypeFalse, TypeNull:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc compareObjects(o1, o2 *Object) bool {\n\tif o1 == nil && o2 == nil {\n\t\treturn true\n\t}\n\tif o1 == nil || o2 == nil {\n\t\treturn false\n\t}\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i := range o1.kvs {\n\t\tif o1.kvs[i].k != o2.kvs[i].k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(o1.kvs[i].v, o2.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "e0c44423b42e12e4986c689637048fc2": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"no escape characters\",\n\t\t\tinput:    \"hello world\",\n\t\t\texpected: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"simple escape characters\",\n\t\t\tinput:    \"hello\\\\\\\"world\\\\\\\\\",\n\t\t\texpected: \"hello\\\"world\\\\\",\n\t\t},\n\t\t{\n\t\t\tname:     \"unicode escape characters\",\n\t\t\tinput:    \"hello\\\\u0041world\\\\u0042\",\n\t\t\texpected: \"helloAwordB\",\n\t\t},\n\t\t{\n\t\t\tname:     \"surrogate pair escape characters\",\n\t\t\tinput:    \"hello\\\\ud83d\\\\ude00world\",\n\t\t\texpected: \"helloðŸ˜€world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid escape characters\",\n\t\t\tinput:    \"hello\\\\uworld\\\\u0041\",\n\t\t\texpected: \"hello\\\\uworld\\\\u0041\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e08540605cae6ed9a666d3cee7b412f7": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape double quote\",\n\t\t\tinput:    \"\\\"hello, world\\\"\",\n\t\t\texpected: `\"hello, world\"`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backslash\",\n\t\t\tinput:    \"\\\\hello, world\\\\\",\n\t\t\texpected: `\\hello, world\\`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape forward slash\",\n\t\t\tinput:    \"/hello, world/\",\n\t\t\texpected: `/hello, world/`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backspace\",\n\t\t\tinput:    \"h\\bello, world\",\n\t\t\texpected: \"h\\bello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape form feed\",\n\t\t\tinput:    \"h\\fello, world\",\n\t\t\texpected: \"h\\fello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape newline\",\n\t\t\tinput:    \"h\\nello, world\",\n\t\t\texpected: \"h\\nello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape carriage return\",\n\t\t\tinput:    \"h\\rello, world\",\n\t\t\texpected: \"h\\rello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape tab\",\n\t\t\tinput:    \"h\\tello, world\",\n\t\t\texpected: \"h\\tello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Unicode character\",\n\t\t\tinput:    \"\\\\u00A9hello, world\",\n\t\t\texpected: \"Â©hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape surrogate pair\",\n\t\t\tinput:    \"\\\\uD83D\\\\uDE00hello, world\",\n\t\t\texpected: \"ðŸ˜€hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid escape sequence\",\n\t\t\tinput:    \"\\\\xhello, world\",\n\t\t\texpected: \"\\\\xhello, world\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e21671345d404e178d58a9be757c585b": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty array\",\n\t\t\tinput: \"[]\",\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with one element\",\n\t\t\tinput: \"[1]\",\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with multiple elements\",\n\t\t\tinput: \"[1,2,3]\",\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with trailing comma\",\n\t\t\tinput: \"[1,2,3,]\",\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with missing closing bracket\",\n\t\t\tinput: \"[1,2,3\",\n\t\t\terr:   true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tv, _, err := parseArray(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseArray(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !v.Equal(tc.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", tc.input, v, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e23f2363915a7f8671a8500fbf19be5d": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: &Value{\n\t\t\t\ts: \"hello\",\n\t\t\t\tt: typeRawString,\n\t\t\t},\n\t\t\twant: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{s: \"value1\", t: TypeString}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{s: \"value2\", t: TypeString}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":\"value1\",\"key2\":\"value2\"}`),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"value1\", t: TypeString},\n\t\t\t\t\t{s: \"value2\", t: TypeString},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\twant: []byte(`[\"value1\",\"value2\"]`),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: &Value{\n\t\t\t\ts: \"hello\",\n\t\t\t\tt: TypeString,\n\t\t\t},\n\t\t\twant: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: &Value{\n\t\t\t\ts: \"42\",\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\twant: []byte(\"42\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %q, want %q\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e29ea33cab5b9f9fb4523fdea62a7bfd": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.456e+78\",\n\t\t\texpected: []string{\"123.456e+78\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with leading zeros\",\n\t\t\tinput:    \"0123.456\",\n\t\t\texpected: []string{\"0123.456\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with sign\",\n\t\t\tinput:    \"-123.456\",\n\t\t\texpected: []string{\"-123.456\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with exponent\",\n\t\t\tinput:    \"1.2e+3\",\n\t\t\texpected: []string{\"1.2e+3\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number\",\n\t\t\tinput:    \"abc\",\n\t\t\texpected: []string{\"\", \"abc\"},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with leading sign\",\n\t\t\tinput:    \"+123.456\",\n\t\t\texpected: []string{\"\", \"+123.456\"},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with leading inf\",\n\t\t\tinput:    \"inf123.456\",\n\t\t\texpected: []string{\"inf\", \"123.456\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with leading nan\",\n\t\t\tinput:    \"nan123.456\",\n\t\t\texpected: []string{\"nan\", \"123.456\"},\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.expected[0] || rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = (%q, %q), want (%q, %q)\", tc.input, num, rest, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "e367c07855bfa56e25589782286ec8b7": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello world\"`,\n\t\t\texpected: []string{\"hello world\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello \\\"world\\\"\"`,\n\t\t\texpected: []string{\"hello \\\"world\\\"\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello \\\"world\\\" \\\"foo\\\"\"`,\n\t\t\texpected: []string{\"hello \\\"world\\\" \\\"foo\\\"\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with no closing quote\",\n\t\t\tinput:    `\"hello world`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot1, got2, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got1 != tc.expected[0] || got2 != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = (%q, %q), want (%q, %q)\", tc.input, got1, got2, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "dca2d006634fa60407c962b9f0af8fda": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: \"{}\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"simple object\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with nested object\",\n\t\t\tinput: `{\"key1\":{\"subkey1\":\"subvalue1\"},\"key2\":42}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{k: \"key1\", v: &Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{k: \"subkey1\", v: &Value{t: TypeString, s: \"subvalue1\"}},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with nested array\",\n\t\t\tinput: `{\"key1\":[\"value1\",\"value2\"],\"key2\":42}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{k: \"key1\", v: &Value{\n\t\t\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t\t\t{t: TypeString, s: \"value1\"},\n\t\t\t\t\t\t\t\t\t{t: TypeString, s: \"value2\"},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42`,\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing colon\",\n\t\t\tinput: `{\"key1\" \"value1\",\"key2\":42}`,\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing comma\",\n\t\t\tinput: `{\"key1\":\"value1\" \"key2\":42}`,\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tactual, _, err := parseObject(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil {\n\t\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t\t} else if err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"expected error %v, got %v\", tc.err, err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif tc.err != nil {\n\t\t\t\tt.Errorf(\"expected error %v, got nil\", tc.err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tc.expected, actual)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn compareObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn compareArrays(v1.a, v2.a)\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeTrue, TypeFalse, TypeNull:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc compareObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc compareArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tv2 := a2[i]\n\t\tif !compareValues(v1, v2) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "e2f1c5765c1a8aba24c0ebf5d434d945": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: \"{}\",\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           []kv{},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with one key-value pair\",\n\t\t\tinput: `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with multiple key-value pairs\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":123,\"key3\":true}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\tinput: `{\"key1\":\"value1\",`,\n\t\t\terr:   true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tv, _, err := parseObject(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !v.Equal(tc.expected) {\n\t\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", tc.input, v, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e3f590dbf2ba58be97e9c05ed05fbb1a": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestTypeString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    Type\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"TypeObject\",\n\t\t\tinput:    TypeObject,\n\t\t\texpected: \"object\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeArray\",\n\t\t\tinput:    TypeArray,\n\t\t\texpected: \"array\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeString\",\n\t\t\tinput:    TypeString,\n\t\t\texpected: \"string\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeNumber\",\n\t\t\tinput:    TypeNumber,\n\t\t\texpected: \"number\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeTrue\",\n\t\t\tinput:    TypeTrue,\n\t\t\texpected: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeFalse\",\n\t\t\tinput:    TypeFalse,\n\t\t\texpected: \"false\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeNull\",\n\t\t\tinput:    TypeNull,\n\t\t\texpected: \"null\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Unknown Type\",\n\t\t\tinput:    Type(100),\n\t\t\texpected: \"BUG: unknown Value type: 100\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := tc.input.String()\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"expected %q, got %q\", tc.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e310404b1d11354d4286fbf82a7a9788": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: \"{}\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs:           []kv{},\n\t\t\t\t\t\tkeysUnescaped: true,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with one key-value pair\",\n\t\t\tinput: `{\"key\":\"value\"}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tkeysUnescaped: true,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with multiple key-value pairs\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":123,\"key3\":true}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tkeysUnescaped: true,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":123`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tv, _, err := parseObject(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tc.expected.Equal(v) {\n\t\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", tc.input, v, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e32f3799b5fb1bcda0719fd195661530": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape double quote\",\n\t\t\tinput:    \"\\\"hello, world\\\"\",\n\t\t\texpected: `\"hello, world\"`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backslash\",\n\t\t\tinput:    \"\\\\hello, world\\\\\",\n\t\t\texpected: `\\hello, world\\`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape forward slash\",\n\t\t\tinput:    \"/hello, world/\",\n\t\t\texpected: `/hello, world/`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backspace\",\n\t\t\tinput:    \"h\\bello, world\",\n\t\t\texpected: \"h\\bello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape form feed\",\n\t\t\tinput:    \"h\\fello, world\",\n\t\t\texpected: \"h\\fello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape newline\",\n\t\t\tinput:    \"h\\nello, world\",\n\t\t\texpected: \"h\\nello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape carriage return\",\n\t\t\tinput:    \"h\\rello, world\",\n\t\t\texpected: \"h\\rello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape tab\",\n\t\t\tinput:    \"h\\tello, world\",\n\t\t\texpected: \"h\\tello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Unicode character\",\n\t\t\tinput:    \"\\\\u00A9hello, world\",\n\t\t\texpected: \"Â©hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape invalid Unicode character\",\n\t\t\tinput:    \"\\\\u00Xhello, world\",\n\t\t\texpected: \"\\\\u00Xhello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape surrogate pair\",\n\t\t\tinput:    \"\\\\uD83D\\\\uDE00hello, world\",\n\t\t\texpected: \"ðŸ˜€hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape invalid surrogate pair\",\n\t\t\tinput:    \"\\\\uD83D\\\\uXXXXhello, world\",\n\t\t\texpected: \"\\\\uD83D\\\\uXXXXhello, world\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e3eb0620aefa4f7a91429e17a5df1d87": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape double quote\",\n\t\t\tinput:    \"\\\"hello, world\\\"\",\n\t\t\texpected: `\"hello, world\"`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backslash\",\n\t\t\tinput:    \"\\\\hello, world\\\\\",\n\t\t\texpected: `\\hello, world\\`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape forward slash\",\n\t\t\tinput:    \"/hello, world/\",\n\t\t\texpected: `/hello, world/`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backspace\",\n\t\t\tinput:    \"h\\bello, world\",\n\t\t\texpected: \"h\\bello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape form feed\",\n\t\t\tinput:    \"h\\fello, world\",\n\t\t\texpected: \"h\\fello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape newline\",\n\t\t\tinput:    \"h\\nello, world\",\n\t\t\texpected: \"h\\nello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape carriage return\",\n\t\t\tinput:    \"h\\rello, world\",\n\t\t\texpected: \"h\\rello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape tab\",\n\t\t\tinput:    \"h\\tello, world\",\n\t\t\texpected: \"h\\tello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Unicode\",\n\t\t\tinput:    \"\\\\u0041\\\\u0042\\\\u0043\",\n\t\t\texpected: \"ABC\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Surrogate Pair\",\n\t\t\tinput:    \"\\\\ud83d\\\\ude00\",\n\t\t\texpected: \"ðŸ˜€\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid Escape Sequence\",\n\t\t\tinput:    \"\\\\uABCD\",\n\t\t\texpected: \"\\\\uABCD\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e51e94608dd11bf35b4e80233aad4416": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":\"value1\",\"key2\":42}`),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"str1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t\t{t: TypeFalse},\n\t\t\t\t\t{t: TypeNull},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`[\"str1\",42,true,false,null]`),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\\\"world\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello\\\"world\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42.5\",\n\t\t\t},\n\t\t\twant: []byte(\"42.5\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %q, want %q\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e6cb490bb2c0d83ed347c3d9f08ba14a": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWS(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"string with no whitespace\",\n\t\t\tinput:    \"abcd\",\n\t\t\texpected: \"abcd\",\n\t\t},\n\t\t{\n\t\t\tname:     \"string with leading whitespace\",\n\t\t\tinput:    \"   abcd\",\n\t\t\texpected: \"abcd\",\n\t\t},\n\t\t{\n\t\t\tname:     \"string with trailing whitespace\",\n\t\t\tinput:    \"abcd   \",\n\t\t\texpected: \"abcd   \",\n\t\t},\n\t\t{\n\t\t\tname:     \"string with leading and trailing whitespace\",\n\t\t\tinput:    \"   abcd   \",\n\t\t\texpected: \"abcd   \",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := skipWS(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"skipWS(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e5485be886fbf998b404fd9392355eb6": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetFloat64(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tkeys   []string\n\t\tvalue  float64\n\t\texpect float64\n\t}{\n\t\t{\n\t\t\tname:   \"Existing key path\",\n\t\t\tkeys:   []string{\"key1\", \"key2\", \"0.5\"},\n\t\t\tvalue:  3.14,\n\t\t\texpect: 3.14,\n\t\t},\n\t\t{\n\t\t\tname:   \"Non-existing key path\",\n\t\t\tkeys:   []string{\"key1\", \"key3\", \"1.2\"},\n\t\t\tvalue:  0,\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"Invalid value type\",\n\t\t\tkeys:   []string{\"key1\", \"key4\"},\n\t\t\tvalue:  true,\n\t\t\texpect: 0,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tv := &Value{\n\t\t\t\ts: \"{}\",\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{\n\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t{k: \"key2\", v: &Value{s: \"3.14\"}},\n\t\t\t\t\t\t\t\t\t{k: \"key4\", v: &Value{t: TypeTrue}},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}\n\n\t\t\tgot := v.GetFloat64(test.keys...)\n\t\t\tif got != test.expect {\n\t\t\t\tt.Errorf(\"GetFloat64(%v) = %v, want %v\", test.keys, got, test.expect)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e3b625c10b9083a177ee75bf2554ab5a": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"empty array\",\n\t\t\tinput:    \"[]\",\n\t\t\texpected: &Value{t: TypeArray, a: []*Value{}},\n\t\t},\n\t\t{\n\t\t\tname:  \"array with values\",\n\t\t\tinput: \"[1, 2, 3]\",\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"array with nested objects\",\n\t\t\tinput: `[{\"a\":1}, {\"b\":2}]`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t{k: \"a\", v: &Value{t: TypeNumber, s: \"1\"}},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t{k: \"b\", v: &Value{t: TypeNumber, s: \"2\"}},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"array with missing closing bracket\",\n\t\t\tinput: \"[1, 2, 3\",\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with missing comma\",\n\t\t\tinput: \"[1 2]\",\n\t\t\terr:   true,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tv, _, err := parseArray(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseArray(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !equalValues(v, tc.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", tc.input, v, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeNull, TypeTrue, TypeFalse:\n\t\treturn true\n\tcase TypeNumber, TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeObject:\n\t\treturn equalObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\tpanic(\"unknown type\")\n\t}\n}\n\nfunc equalObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i := range o1.kvs {\n\t\tif o1.kvs[i].k != o2.kvs[i].k {\n\t\t\treturn false\n\t\t}\n\t\tif !equalValues(o1.kvs[i].v, o2.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "e59539ec2cf73eea40662f8b045e72c5": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestVisit(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\to    *Object\n\t\twant [][]byte\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\to:    &Object{},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"single key-value pair\",\n\t\t\to: &Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{\n\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\tv: &Value{s: \"value1\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: [][]byte{[]byte(\"key1\")},\n\t\t},\n\t\t{\n\t\t\tname: \"multiple key-value pairs\",\n\t\t\to: &Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{\n\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\tv: &Value{s: \"value1\"},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\tv: &Value{s: \"value2\"},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\tv: &Value{s: \"value3\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: [][]byte{[]byte(\"key1\"), []byte(\"key2\"), []byte(\"key3\")},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tvar keys [][]byte\n\t\t\ttt.o.Visit(func(key []byte, v *Value) {\n\t\t\t\tkeys = append(keys, key)\n\t\t\t})\n\n\t\t\tif !reflect.DeepEqual(keys, tt.want) {\n\t\t\t\tt.Errorf(\"Visit() = %v, want %v\", keys, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e5859f88ecff2e15e312b6c54fde32c3": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tv        *Value\n\t\texpected []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\texpected: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: []byte(`{\"key1\":\"value1\",\"key2\":42}`),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"item1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: []byte(`[\"item1\",42,true]`),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\texpected: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42\",\n\t\t\t},\n\t\t\texpected: []byte(\"42\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\texpected: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\texpected: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\texpected: []byte(\"null\"),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdst := make([]byte, 0, 64)\n\t\t\tresult := tc.v.MarshalTo(dst)\n\t\t\tif !reflect.DeepEqual(result, tc.expected) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %q, expected %q\", result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e68dfded8d2b26a44da71ff5e78c83dd": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.456e+78\",\n\t\t\texpected: []string{\"123.456e+78\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with leading zeros\",\n\t\t\tinput:    \"0123.456\",\n\t\t\texpected: []string{\"0123.456\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with sign\",\n\t\t\tinput:    \"-123.456\",\n\t\t\texpected: []string{\"-123.456\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with inf\",\n\t\t\tinput:    \"inf\",\n\t\t\texpected: []string{\"inf\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with nan\",\n\t\t\tinput:    \"nan\",\n\t\t\texpected: []string{\"nan\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number\",\n\t\t\tinput:    \"123.456a\",\n\t\t\texpected: []string{\"\", \"a\"},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.expected[0] || rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, %q, want %q, %q\", tc.input, num, rest, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "e783a3e5d0076d408007be0cbdc07566": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObjectReset(t *testing.T) {\n\t// Create a new Object\n\tobj := &Object{\n\t\tkvs:           []kv{{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}}, {k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}}},\n\t\tkeysUnescaped: true,\n\t}\n\n\t// Call the reset() method\n\tobj.reset()\n\n\t// Verify that the kvs slice is empty and keysUnescaped is false\n\tif len(obj.kvs) != 0 {\n\t\tt.Errorf(\"expected kvs to be empty, got %v\", obj.kvs)\n\t}\n\tif obj.keysUnescaped {\n\t\tt.Errorf(\"expected keysUnescaped to be false, got true\")\n\t}\n}",
    "e6b2976f720156be6211fd77b2f75c07": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: &Value{\n\t\t\t\ts: \"hello\",\n\t\t\t\tt: typeRawString,\n\t\t\t},\n\t\t\twant: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{s: \"value1\", t: TypeString}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{s: \"value2\", t: TypeString}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":\"value1\",\"key2\":\"value2\"}`),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"value1\", t: TypeString},\n\t\t\t\t\t{s: \"value2\", t: TypeString},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\twant: []byte(`[\"value1\",\"value2\"]`),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: &Value{\n\t\t\t\ts: \"hello\",\n\t\t\t\tt: TypeString,\n\t\t\t},\n\t\t\twant: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: &Value{\n\t\t\t\ts: \"42\",\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\twant: []byte(\"42\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %q, want %q\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e7490200a8c15ff50bab2c7d5fde9cac": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: []string{\"hello\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello\\\"world\"`,\n\t\t\texpected: []string{\"hello\\\"world\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello\\\"world\\\"foo\"`,\n\t\t\texpected: []string{\"hello\\\"world\\\"foo\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with no closing quote\",\n\t\t\tinput:    `\"hello`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot, got2, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tc.expected[0] {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, expected %v\", got, tc.expected[0])\n\t\t\t}\n\t\t\tif got2 != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawString() got2 = %v, expected %v\", got2, tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "e7400b10fb6d7115b93dba7c2dfd9129": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape double quote\",\n\t\t\tinput:    \"\\\"hello, world\\\"\",\n\t\t\texpected: `\"hello, world\"`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backslash\",\n\t\t\tinput:    \"\\\\hello, world\\\\\",\n\t\t\texpected: `\\hello, world\\`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape forward slash\",\n\t\t\tinput:    \"/hello, world/\",\n\t\t\texpected: `/hello, world/`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backspace\",\n\t\t\tinput:    \"h\\bello, world\",\n\t\t\texpected: \"h\\bello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape form feed\",\n\t\t\tinput:    \"h\\fello, world\",\n\t\t\texpected: \"h\\fello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape newline\",\n\t\t\tinput:    \"h\\nello, world\",\n\t\t\texpected: \"h\\nello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape carriage return\",\n\t\t\tinput:    \"h\\rello, world\",\n\t\t\texpected: \"h\\rello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape tab\",\n\t\t\tinput:    \"h\\tello, world\",\n\t\t\texpected: \"h\\tello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Unicode\",\n\t\t\tinput:    \"\\\\u0041\\\\u0042\\\\u0043\",\n\t\t\texpected: \"ABC\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Surrogate Pair\",\n\t\t\tinput:    \"\\\\ud83d\\\\ude00\",\n\t\t\texpected: \"ðŸ˜€\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid Escape Sequence\",\n\t\t\tinput:    \"\\\\uABCD\",\n\t\t\texpected: \"\\\\uABCD\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "ea1af124e3f14fce95ff74dac77cb87e": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_getKV(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\to    *Object\n\t\twant *kv\n\t}{\n\t\t{\n\t\t\tname: \"empty kvs\",\n\t\t\to:    &Object{kvs: []kv{}},\n\t\t\twant: &kv{},\n\t\t},\n\t\t{\n\t\t\tname: \"kvs with capacity\",\n\t\t\to:    &Object{kvs: make([]kv, 2, 5)},\n\t\t\twant: &kv{},\n\t\t},\n\t\t{\n\t\t\tname: \"kvs with length equal to capacity\",\n\t\t\to:    &Object{kvs: make([]kv, 5, 5)},\n\t\t\twant: &kv{},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.o.getKV(); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Object.getKV() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e74702fd6fc7d1ac731ed0c5591cd278": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: \"{}\",\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           []kv{},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with one key-value pair\",\n\t\t\tinput: `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with multiple key-value pairs\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42,\"key3\":true}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"42\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42`,\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing colon\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\"}`,\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing value\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":}`,\n\t\t\terr:   true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tv, _, err := parseObject(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !v.Equal(tc.expected) {\n\t\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", tc.input, v, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e897c35ec322a812216cfd3f5ff03ffd": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetInt(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tjson     string\n\t\tkeys     []string\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"Existing key with valid int value\",\n\t\t\tjson:     `{\"key1\": 42}`,\n\t\t\tkeys:     []string{\"key1\"},\n\t\t\texpected: 42,\n\t\t},\n\t\t{\n\t\t\tname:     \"Existing key with float value\",\n\t\t\tjson:     `{\"key1\": 3.14}`,\n\t\t\tkeys:     []string{\"key1\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Non-existing key\",\n\t\t\tjson:     `{\"key1\": 42}`,\n\t\t\tkeys:     []string{\"key2\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Array index access\",\n\t\t\tjson:     `{\"key1\": [10, 20, 30]}`,\n\t\t\tkeys:     []string{\"key1\", \"1\"},\n\t\t\texpected: 20,\n\t\t},\n\t\t{\n\t\t\tname:     \"Array index out of range\",\n\t\t\tjson:     `{\"key1\": [10, 20, 30]}`,\n\t\t\tkeys:     []string{\"key1\", \"3\"},\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tv, err := Parse(tc.json)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Failed to parse JSON: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tactual := v.GetInt(tc.keys...)\n\t\t\tif actual != tc.expected {\n\t\t\t\tt.Errorf(\"GetInt(%v) = %d, expected %d\", tc.keys, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "eb0bed6b248796ac2aa5e59b1e4f4066": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestTypeString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    Type\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"TypeObject\",\n\t\t\tinput:    TypeObject,\n\t\t\texpected: \"object\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeArray\",\n\t\t\tinput:    TypeArray,\n\t\t\texpected: \"array\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeString\",\n\t\t\tinput:    TypeString,\n\t\t\texpected: \"string\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeNumber\",\n\t\t\tinput:    TypeNumber,\n\t\t\texpected: \"number\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeTrue\",\n\t\t\tinput:    TypeTrue,\n\t\t\texpected: \"true\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeFalse\",\n\t\t\tinput:    TypeFalse,\n\t\t\texpected: \"false\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeNull\",\n\t\t\tinput:    TypeNull,\n\t\t\texpected: \"null\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Unknown Type\",\n\t\t\tinput:    Type(100),\n\t\t\texpected: \"BUG: unknown Value type: 100\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := tc.input.String()\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"expected %q, got %q\", tc.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "eb071f816583aa7cfc1e96a4582d81f2": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.45e+6\",\n\t\t\texpected: []string{\"123.45e+6\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with leading zeros\",\n\t\t\tinput:    \"0123.45\",\n\t\t\texpected: []string{\"0123.45\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with sign\",\n\t\t\tinput:    \"-123.45\",\n\t\t\texpected: []string{\"-123.45\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with exponent\",\n\t\t\tinput:    \"1.2e-3\",\n\t\t\texpected: []string{\"1.2e-3\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number\",\n\t\t\tinput:    \"abc\",\n\t\t\texpected: []string{\"\", \"abc\"},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with inf\",\n\t\t\tinput:    \"inf\",\n\t\t\texpected: []string{\"inf\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with nan\",\n\t\t\tinput:    \"nan\",\n\t\t\texpected: []string{\"nan\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.expected[0] || rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, %q, want %q, %q\", tc.input, num, rest, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "eb885289b7d2fd99a584dd8528e7a597": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello world\"`,\n\t\t\texpected: []string{\"hello world\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello \\\"world\\\"\"`,\n\t\t\texpected: []string{\"hello \\\"world\\\"\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello \\\"world\\\" \\\"foo\\\"\"`,\n\t\t\texpected: []string{\"hello \\\"world\\\" \\\"foo\\\"\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with no closing quote\",\n\t\t\tinput:    `\"hello world`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot1, got2, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got1 != tc.expected[0] || got2 != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = (%q, %q), want (%q, %q)\", tc.input, got1, got2, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "eb2f7a09786ed520e3c0026730fb8e56": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tv        *Value\n\t\texpected []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\texpected: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: []byte(`{\"key1\":\"value1\",\"key2\":42}`),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"str1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t\t{t: TypeFalse},\n\t\t\t\t\t{t: TypeNull},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: []byte(`[\"str1\",42,true,false,null]`),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\\\"world\",\n\t\t\t},\n\t\t\texpected: []byte(`\"hello\\\"world\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42.5\",\n\t\t\t},\n\t\t\texpected: []byte(\"42.5\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\texpected: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\texpected: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\texpected: []byte(\"null\"),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdst := make([]byte, 0, 100)\n\t\t\tresult := tc.v.MarshalTo(dst)\n\t\t\tif !reflect.DeepEqual(result, tc.expected) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %q, expected %q\", result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "ed2bbe5d8b0addacee0007eb6c33fdd0": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestTypeString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    Type\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"TypeObject\",\n\t\t\tinput:    TypeObject,\n\t\t\texpected: \"object\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeArray\",\n\t\t\tinput:    TypeArray,\n\t\t\texpected: \"array\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeString\",\n\t\t\tinput:    TypeString,\n\t\t\texpected: \"string\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeNumber\",\n\t\t\tinput:    TypeNumber,\n\t\t\texpected: \"number\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeTrue\",\n\t\t\tinput:    TypeTrue,\n\t\t\texpected: \"true\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeFalse\",\n\t\t\tinput:    TypeFalse,\n\t\t\texpected: \"false\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeNull\",\n\t\t\tinput:    TypeNull,\n\t\t\texpected: \"null\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Unknown Type\",\n\t\t\tinput:    Type(100),\n\t\t\texpected: \"BUG: unknown Value type: 100\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := tc.input.String()\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"expected %q, got %q\", tc.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "ebf2cbcce69e6375a3f5bae521ef8b70": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t\trest     string\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.45e+6\",\n\t\t\texpected: \"123.45e+6\",\n\t\t\trest:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with sign\",\n\t\t\tinput:    \"-123.45e-6\",\n\t\t\texpected: \"-123.45e-6\",\n\t\t\trest:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with inf\",\n\t\t\tinput:    \"inf\",\n\t\t\texpected: \"inf\",\n\t\t\trest:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with nan\",\n\t\t\tinput:    \"nan\",\n\t\t\texpected: \"nan\",\n\t\t\trest:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number\",\n\t\t\tinput:    \"123.45x\",\n\t\t\texpected: \"\",\n\t\t\trest:     \"123.45x\",\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, expected error: %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.expected {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, expected %q\", tc.input, num, tc.expected)\n\t\t\t}\n\t\t\tif rest != tc.rest {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) rest = %q, expected %q\", tc.input, rest, tc.rest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "ecb9681ec50f26f5fdb26414aabd3121": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"no escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"simple escape characters\",\n\t\t\tinput:    \"hello\\\\\\\"world\\\\\\\\\",\n\t\t\texpected: \"hello\\\"world\\\\\",\n\t\t},\n\t\t{\n\t\t\tname:     \"complex escape characters\",\n\t\t\tinput:    \"hello\\\\u0000world\\\\u1234\\\\u{10000}\",\n\t\t\texpected: \"hello\\x00world\\u1234\\U00010000\",\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid escape characters\",\n\t\t\tinput:    \"hello\\\\u000world\\\\u123\",\n\t\t\texpected: \"hello\\\\u000world\\\\u123\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "ec026c231b0d836d21a262081a7a59a0": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetObject(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tjson     string\n\t\tkeys     []string\n\t\texpected *Object\n\t}{\n\t\t{\n\t\t\tname: \"existing keys\",\n\t\t\tjson: `{\"a\":{\"b\":1,\"c\":2},\"d\":[1,2,3]}`,\n\t\t\tkeys: []string{\"a\"},\n\t\t\texpected: &Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"b\", v: &Value{t: TypeNumber, s: \"1\"}},\n\t\t\t\t\t{k: \"c\", v: &Value{t: TypeNumber, s: \"2\"}},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"non-existing keys\",\n\t\t\tjson: `{\"a\":{\"b\":1,\"c\":2},\"d\":[1,2,3]}`,\n\t\t\tkeys: []string{\"x\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid value type\",\n\t\t\tjson: `{\"a\":1,\"b\":\"foo\"}`,\n\t\t\tkeys: []string{\"b\"},\n\t\t\texpected: nil,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv, err := Parse(tt.json)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to parse JSON: %v\", err)\n\t\t\t}\n\n\t\t\tobj := v.GetObject(tt.keys...)\n\t\t\tif obj != tt.expected {\n\t\t\t\tt.Errorf(\"GetObject(%v) = %v, want %v\", tt.keys, obj, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e83bb0b3a53e8c49660f6e11d35138f1": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: \"{}\",\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           []kv{},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with one key-value pair\",\n\t\t\tinput: `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with multiple key-value pairs\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":123,\"key3\":true}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":123`,\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing colon\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\"}`,\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing comma\",\n\t\t\tinput: `{\"key1\":\"value1\" \"key2\":123}`,\n\t\t\terr:   true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{\n\t\t\t\tvs: make([]Value, 0, 16),\n\t\t\t}\n\t\t\tactual, _, err := parseObject(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn compareObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn compareArrays(v1.a, v2.a)\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber, TypeTrue, TypeFalse:\n\t\treturn v1.s == v2.s\n\tcase TypeNull:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc compareObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc compareArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tif !compareValues(v1, a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "e7853b1995be2a7e0f2c932045cca477": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"too deep\",\n\t\t\tinput:    \"{}\", // Assuming MaxDepth is 1\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t},\n\t\t{\n\t\t\tname:     \"valid object\",\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{\n\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\tt: typeRawString,\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"1\", t: TypeNumber},\n\t\t\t\t\t{s: \"2\", t: TypeNumber},\n\t\t\t\t\t{s: \"3\", t: TypeNumber},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{\n\t\t\t\ts: \"hello\",\n\t\t\t\tt: typeRawString,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid true\",\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid false\",\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid null\",\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"42\",\n\t\t\texpected: &Value{\n\t\t\t\ts: \"42\",\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, expected %v\", tc.input, err, tc.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else if tc.err != nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = nil, expected %v\", tc.input, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, expected %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn compareObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn compareArrays(v1.a, v2.a)\n\tcase typeRawString, TypeNumber, TypeTrue, TypeFalse, TypeNull:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc compareObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc compareArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tif !compareValues(v1, a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "ed60335579948b7d973b557c9487f30f": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestUint64(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    *Value\n\t\texpected uint64\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"valid uint64\",\n\t\t\tinput:    &Value{s: \"123456789\", t: TypeNumber},\n\t\t\texpected: 123456789,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"non-number type\",\n\t\t\tinput:    &Value{s: \"true\", t: TypeTrue},\n\t\t\texpected: 0,\n\t\t\terr:      fmt.Errorf(\"value doesn't contain number; it contains true\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number\",\n\t\t\tinput:    &Value{s: \"abc\", t: TypeNumber},\n\t\t\texpected: 0,\n\t\t\terr:      fmt.Errorf(\"invalid syntax\"),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult, err := tc.input.Uint64()\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif result != tc.expected {\n\t\t\t\t\tt.Errorf(\"expected %d, got %d\", tc.expected, result)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}",
    "ebf877e63e90ebbf0504c5ddb8afea58": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"too deep\",\n\t\t\tinput:    \"{}\", // Assuming MaxDepth is 1\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t},\n\t\t{\n\t\t\tname:     \"valid object\",\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{s: \"value\", t: typeRawString}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"1\", t: TypeNumber},\n\t\t\t\t\t{s: \"2\", t: TypeNumber},\n\t\t\t\t\t{s: \"3\", t: TypeNumber},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{s: \"hello\", t: typeRawString},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid true\",\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid false\",\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid null\",\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"42\",\n\t\t\texpected: &Value{s: \"42\", t: TypeNumber},\n\t\t\terr:      nil,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, expected %v\", tc.input, err, tc.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else if tc.err != nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = nil, expected %v\", tc.input, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, expected %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn compareObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn compareArrays(v1.a, v2.a)\n\tcase typeRawString, TypeNumber, TypeTrue, TypeFalse, TypeNull:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc compareObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc compareArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tif !compareValues(v1, a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "efa4903c7248777618b60131d2acc577": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"no escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"simple escape characters\",\n\t\t\tinput:    \"hello\\\\\\\"world\\\\\\\\\",\n\t\t\texpected: \"hello\\\"world\\\\\",\n\t\t},\n\t\t{\n\t\t\tname:     \"complex escape characters\",\n\t\t\tinput:    \"hello\\\\u0123\\\\u4567\\\\u89ab\\\\ucdef\\\\U00010123world\",\n\t\t\texpected: \"hello\\u0123\\u4567\\u89ab\\ucdef\\U00010123world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid escape characters\",\n\t\t\tinput:    \"hello\\\\u123world\",\n\t\t\texpected: \"hello\\\\u123world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"incomplete escape characters\",\n\t\t\tinput:    \"hello\\\\uworld\",\n\t\t\texpected: \"hello\\\\uworld\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "ed7f1f9db9ebf8c730e6dec6ab9e2901": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"valid JSON\",\n\t\t\tinput: `{\"key1\": \"value1\", \"key2\": 42}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{s: \"value1\", t: TypeString}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{s: \"42\", t: TypeNumber}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"invalid JSON\",\n\t\t\tinput: `{\"key1\": \"value1\", \"key2\"`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty input\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tp := &Parser{}\n\t\t\tactual, err := p.Parse(tc.input)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !tc.err && !actual.Equal(tc.expected) {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tc.expected, actual)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc (v *Value) Equal(other *Value) bool {\n\tif v == nil && other == nil {\n\t\treturn true\n\t}\n\tif v == nil || other == nil {\n\t\treturn false\n\t}\n\tif v.t != other.t {\n\t\treturn false\n\t}\n\tswitch v.t {\n\tcase TypeObject:\n\t\treturn v.o.Equal(&other.o)\n\tcase TypeArray:\n\t\treturn v.ArrayEqual(other.a)\n\tcase TypeString:\n\t\treturn v.s == other.s\n\tcase TypeNumber, TypeTrue, TypeFalse:\n\t\treturn v.s == other.s\n\tcase TypeNull:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc (o *Object) Equal(other *Object) bool {\n\tif len(o.kvs) != len(other.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv := range o.kvs {\n\t\tif kv.k != other.kvs[i].k {\n\t\t\treturn false\n\t\t}\n\t\tif !kv.v.Equal(other.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc (v *Value) ArrayEqual(other []*Value) bool {\n\tif len(v.a) != len(other) {\n\t\treturn false\n\t}\n\tfor i, val := range v.a {\n\t\tif !val.Equal(other[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "edc73e729f5fb16c77ddb02f2d62c7f4": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":\"value1\",\"key2\":42}`),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"str1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t\t{t: TypeFalse},\n\t\t\t\t\t{t: TypeNull},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`[\"str1\",42,true,false,null]`),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\\\"world\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello\\\"world\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42.5\",\n\t\t\t},\n\t\t\twant: []byte(\"42.5\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %q, want %q\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f05845715af1ed66ea29327c8a4a23ec": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetValue(t *testing.T) {\n\tc := &cache{\n\t\tvs: []Value{},\n\t}\n\n\t// Test when the capacity of the slice is greater than the length\n\tv1 := c.getValue()\n\tif v1 == nil {\n\t\tt.Errorf(\"getValue() returned nil, expected a non-nil Value\")\n\t}\n\tif len(c.vs) != 2 {\n\t\tt.Errorf(\"Expected length of c.vs to be 2, got %d\", len(c.vs))\n\t}\n\n\t// Test when the capacity of the slice is equal to the length\n\tc.vs = make([]Value, 10)\n\tv2 := c.getValue()\n\tif v2 == nil {\n\t\tt.Errorf(\"getValue() returned nil, expected a non-nil Value\")\n\t}\n\tif len(c.vs) != 11 {\n\t\tt.Errorf(\"Expected length of c.vs to be 11, got %d\", len(c.vs))\n\t}\n}",
    "ee281fd673e0e5921d985e16d66274ec": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape double quote\",\n\t\t\tinput:    \"\\\"hello, world\\\"\",\n\t\t\texpected: `\"hello, world\"`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backslash\",\n\t\t\tinput:    \"\\\\hello, world\\\\\",\n\t\t\texpected: `\\hello, world\\`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape forward slash\",\n\t\t\tinput:    \"/hello, world/\",\n\t\t\texpected: `/hello, world/`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backspace\",\n\t\t\tinput:    \"h\\bello, world\",\n\t\t\texpected: \"h\\bello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape form feed\",\n\t\t\tinput:    \"h\\fello, world\",\n\t\t\texpected: \"h\\fello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape newline\",\n\t\t\tinput:    \"h\\nello, world\",\n\t\t\texpected: \"h\\nello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape carriage return\",\n\t\t\tinput:    \"h\\rello, world\",\n\t\t\texpected: \"h\\rello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape tab\",\n\t\t\tinput:    \"h\\tello, world\",\n\t\t\texpected: \"h\\tello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Unicode\",\n\t\t\tinput:    \"\\\\u0041\\\\u0042\\\\u0043\",\n\t\t\texpected: \"ABC\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Unicode with surrogate pair\",\n\t\t\tinput:    \"\\\\ud83d\\\\ude00\",\n\t\t\texpected: \"ðŸ˜€\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid escape sequence\",\n\t\t\tinput:    \"\\\\x hello, world\",\n\t\t\texpected: \"\\\\x hello, world\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f131920ae34d0848f01ae4cda57a1695": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_getKV(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\to    *Object\n\t\twant *kv\n\t}{\n\t\t{\n\t\t\tname: \"empty kvs\",\n\t\t\to:    &Object{kvs: []kv{}},\n\t\t\twant: &kv{},\n\t\t},\n\t\t{\n\t\t\tname: \"kvs with capacity\",\n\t\t\to:    &Object{kvs: make([]kv, 1, 2)},\n\t\t\twant: &o.kvs[0],\n\t\t},\n\t\t{\n\t\t\tname: \"kvs without capacity\",\n\t\t\to:    &Object{kvs: []kv{{}}},\n\t\t\twant: &o.kvs[1],\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.o.getKV(); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Object.getKV() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f23543cc8a2f20450756636e16c7ac84": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetKV(t *testing.T) {\n\t// Test case 1: Append a new kv to the slice\n\to := &Object{}\n\tkv := o.getKV()\n\tif len(o.kvs) != 1 {\n\t\tt.Errorf(\"Expected length of kvs to be 1, got %d\", len(o.kvs))\n\t}\n\tif kv != &o.kvs[0] {\n\t\tt.Errorf(\"Expected kv to be the last element in the kvs slice\")\n\t}\n\n\t// Test case 2: Expand the slice capacity\n\tfor i := 0; i < cap(o.kvs)-len(o.kvs); i++ {\n\t\to.getKV()\n\t}\n\tkv = o.getKV()\n\tif len(o.kvs) != cap(o.kvs) {\n\t\tt.Errorf(\"Expected length of kvs to be equal to capacity, got %d/%d\", len(o.kvs), cap(o.kvs))\n\t}\n\tif kv != &o.kvs[len(o.kvs)-1] {\n\t\tt.Errorf(\"Expected kv to be the last element in the kvs slice\")\n\t}\n}",
    "f4bcb92947eb553e92ce8b89aba331e3": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"no escape characters\",\n\t\t\tinput:    \"hello world\",\n\t\t\texpected: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"simple escape characters\",\n\t\t\tinput:    \"hello\\\\\\\"world\\\\\\\\\",\n\t\t\texpected: \"hello\\\"world\\\\\",\n\t\t},\n\t\t{\n\t\t\tname:     \"unicode escape characters\",\n\t\t\tinput:    \"hello\\\\u0041world\",\n\t\t\texpected: \"helloAworld\",\n\t\t},\n\t\t{\n\t\t\tname:     \"surrogate pair escape characters\",\n\t\t\tinput:    \"hello\\\\ud83d\\\\ude00world\",\n\t\t\texpected: \"helloðŸ˜€world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid escape characters\",\n\t\t\tinput:    \"hello\\\\xworld\",\n\t\t\texpected: \"hello\\\\xworld\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f43be1abf4b1b32657a9009cca3aa5f7": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: []string{\"hello\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello\\\"world\"`,\n\t\t\texpected: []string{\"hello\\\"world\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello\\\"world\\\"foo\"`,\n\t\t\texpected: []string{\"hello\\\"world\\\"foo\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with no closing quote\",\n\t\t\tinput:    `\"hello`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot, got2, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tc.expected[0] {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, expected %v\", got, tc.expected[0])\n\t\t\t}\n\t\t\tif got2 != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawString() got2 = %v, expected %v\", got2, tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "f0667afc84cf5da4eedaac8df46a195b": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: \"{}\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with one key-value pair\",\n\t\t\tinput: `{\"key\":\"value\"}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with multiple key-value pairs\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":123,\"key3\":true}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\tinput: `{\"key\":\"value\"`,\n\t\t\texpected: nil,\n\t\t\terr:    true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing colon\",\n\t\t\tinput: `{\"key\" \"value\"}`,\n\t\t\texpected: nil,\n\t\t\terr:    true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing comma\",\n\t\t\tinput: `{\"key1\":\"value1\" \"key2\":123}`,\n\t\t\texpected: nil,\n\t\t\terr:    true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tactual, _, err := parseObject(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn compareObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn compareArrays(v1.a, v2.a)\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber, TypeTrue, TypeFalse:\n\t\treturn v1.s == v2.s\n\tcase TypeNull:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc compareObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc compareArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tif !compareValues(v1, a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "f4ec22d1a5a18bc89b39a41074f20a98": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.456e+78\",\n\t\t\texpected: []string{\"123.456e+78\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with leading zeros\",\n\t\t\tinput:    \"0123.456\",\n\t\t\texpected: []string{\"0123.456\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with sign\",\n\t\t\tinput:    \"-123.456\",\n\t\t\texpected: []string{\"-123.456\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with leading sign\",\n\t\t\tinput:    \"+123.456\",\n\t\t\texpected: []string{\"+123.456\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with 'inf'\",\n\t\t\tinput:    \"inf\",\n\t\t\texpected: []string{\"inf\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with 'nan'\",\n\t\t\tinput:    \"nan\",\n\t\t\texpected: []string{\"nan\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number\",\n\t\t\tinput:    \"123.456abc\",\n\t\t\texpected: []string{\"\", \"abc\"},\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.expected[0] || rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = (%q, %q), want (%q, %q)\", tc.input, num, rest, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "f090bde8d09c3c16eb0203495d317a50": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: \"{}\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with one key-value pair\",\n\t\t\tinput: `{\"key\":\"value\"}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with multiple key-value pairs\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42,\"key3\":true}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\ts: \"42\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\tinput: `{\"key1\":\"value1\",`,\n\t\t\texpected: nil,\n\t\t\terr:      ErrUnexpectedEndOfObject,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tv, _, err := parseObject(tc.input, c, 0)\n\t\t\tif err != tc.err {\n\t\t\t\tt.Errorf(\"expected error %v, got %v\", tc.err, err)\n\t\t\t}\n\t\t\tif !equalValues(v, tc.expected) {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tc.expected, v)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn equalObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn equalArrays(v1.a, v2.a)\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber, TypeTrue, TypeFalse:\n\t\treturn v1.s == v2.s\n\tcase TypeNull:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc equalObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !equalValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc equalArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tv2 := a2[i]\n\t\tif !equalValues(v1, v2) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "f52a9ba437685c8435afc8b5272bb656": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetInt(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    *Value\n\t\tkeys     []string\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname: \"Existing key with valid number\",\n\t\t\tinput: &Value{\n\t\t\t\ts: \"123\",\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: 123,\n\t\t},\n\t\t{\n\t\t\tname: \"Existing key with invalid number\",\n\t\t\tinput: &Value{\n\t\t\t\ts: \"123.45\",\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Non-existing key\",\n\t\t\tinput: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{s: \"123\", t: TypeNumber}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"key2\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Invalid value type\",\n\t\t\tinput: &Value{\n\t\t\t\ts: \"hello\",\n\t\t\t\tt: TypeString,\n\t\t\t},\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Nested key\",\n\t\t\tinput: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"outer\", v: &Value{\n\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t{k: \"inner\", v: &Value{s: \"456\", t: TypeNumber}},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"outer\", \"inner\"},\n\t\t\texpected: 456,\n\t\t},\n\t\t{\n\t\t\tname: \"Array index key\",\n\t\t\tinput: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"123\", t: TypeNumber},\n\t\t\t\t\t{s: \"456\", t: TypeNumber},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"1\"},\n\t\t\texpected: 456,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := tc.input.GetInt(tc.keys...)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"GetInt(%v) = %d, expected %d\", tc.keys, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f507afd9a2e710907103163f30938768": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape double quote\",\n\t\t\tinput:    \"\\\"hello, world\\\"\",\n\t\t\texpected: `\"hello, world\"`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backslash\",\n\t\t\tinput:    \"\\\\hello, world\\\\\",\n\t\t\texpected: `\\hello, world\\`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape forward slash\",\n\t\t\tinput:    \"/hello, world/\",\n\t\t\texpected: `/hello, world/`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backspace\",\n\t\t\tinput:    \"h\\bello, world\",\n\t\t\texpected: \"h\\bello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape form feed\",\n\t\t\tinput:    \"h\\fello, world\",\n\t\t\texpected: \"h\\fello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape newline\",\n\t\t\tinput:    \"h\\nello, world\",\n\t\t\texpected: \"h\\nello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape carriage return\",\n\t\t\tinput:    \"h\\rello, world\",\n\t\t\texpected: \"h\\rello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape tab\",\n\t\t\tinput:    \"h\\tello, world\",\n\t\t\texpected: \"h\\tello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Unicode\",\n\t\t\tinput:    \"\\\\u0041\\\\u0042\\\\u0043\",\n\t\t\texpected: \"ABC\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Surrogate Pair\",\n\t\t\tinput:    \"\\\\ud83d\\\\ude00\",\n\t\t\texpected: \"ðŸ˜€\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid Escape Sequence\",\n\t\t\tinput:    \"\\\\uABCD\",\n\t\t\texpected: \"\\\\uABCD\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f1fe434c7c5c4eee4f1b5f499d63ef52": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"too deep\",\n\t\t\tinput:    \"{}\", // Assuming MaxDepth is 1\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t},\n\t\t{\n\t\t\tname:     \"valid object\",\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{\n\t\t\t\t\t\t\tt: typeRawString,\n\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid true\",\n\t\t\tinput:    `true`,\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid false\",\n\t\t\tinput:    `false`,\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid null\",\n\t\t\tinput:    `null`,\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    `42`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42\",\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, expected %v\", tc.input, err, tc.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else if tc.err != nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = nil, expected %v\", tc.input, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, expected %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\to1, _ := v1.Object()\n\t\to2, _ := v2.Object()\n\t\tif len(o1.kvs) != len(o2.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, kv1 := range o1.kvs {\n\t\t\tkv2 := o2.kvs[i]\n\t\t\tif kv1.k != kv2.k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !compareValues(kv1.v, kv2.v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\tcase TypeArray:\n\t\ta1 := v1.a\n\t\ta2 := v2.a\n\t\tif len(a1) != len(a2) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, v1 := range a1 {\n\t\t\tif !compareValues(v1, a2[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\tcase typeRawString, TypeNumber, TypeTrue, TypeFalse, TypeNull:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\tpanic(\"unknown type\")\n\t}\n\treturn true\n}",
    "f1d4a580fbdf8c143281df8713dc7b06": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"too big depth\",\n\t\t\tinput:    \"{}\", // Assuming MaxDepth is 1\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds 1\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"valid object\",\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{\n\t\t\t\t\t\t\tt: typeRawString,\n\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid true\",\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid false\",\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid null\",\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"42\",\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42\",\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, expected %v\", tc.input, err, tc.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else if tc.err != nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = nil, expected %v\", tc.input, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, expected %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\to1, _ := v1.Object()\n\t\to2, _ := v2.Object()\n\t\treturn compareObjects(o1, o2)\n\tcase TypeArray:\n\t\ta1, _ := v1.Array()\n\t\ta2, _ := v2.Array()\n\t\tif len(a1) != len(a2) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range a1 {\n\t\t\tif !compareValues(a1[i], a2[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase typeRawString, TypeNumber, TypeTrue, TypeFalse, TypeNull:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc compareObjects(o1, o2 *Object) bool {\n\tif o1 == nil && o2 == nil {\n\t\treturn true\n\t}\n\tif o1 == nil || o2 == nil {\n\t\treturn false\n\t}\n\tif o1.Len() != o2.Len() {\n\t\treturn false\n\t}\n\tfor i := range o1.kvs {\n\t\tkv1 := o1.kvs[i]\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "f59ee05c8531a20d9be7e8f6127935d7": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"No escape characters\",\n\t\t\tinput:    \"hello, world\",\n\t\t\texpected: \"hello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape double quote\",\n\t\t\tinput:    \"\\\"hello, world\\\"\",\n\t\t\texpected: `\"hello, world\"`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backslash\",\n\t\t\tinput:    \"\\\\hello, world\\\\\",\n\t\t\texpected: `\\hello, world\\`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape forward slash\",\n\t\t\tinput:    \"/hello, world/\",\n\t\t\texpected: `/hello, world/`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape backspace\",\n\t\t\tinput:    \"h\\bello, world\",\n\t\t\texpected: \"h\\bello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape form feed\",\n\t\t\tinput:    \"h\\fello, world\",\n\t\t\texpected: \"h\\fello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape newline\",\n\t\t\tinput:    \"h\\nello, world\",\n\t\t\texpected: \"h\\nello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape carriage return\",\n\t\t\tinput:    \"h\\rello, world\",\n\t\t\texpected: \"h\\rello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape tab\",\n\t\t\tinput:    \"h\\tello, world\",\n\t\t\texpected: \"h\\tello, world\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Unicode\",\n\t\t\tinput:    \"\\\\u0041\\\\u0042\\\\u0043\",\n\t\t\texpected: \"ABC\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Escape Surrogate Pair\",\n\t\t\tinput:    \"\\\\ud83d\\\\ude00\",\n\t\t\texpected: \"ðŸ˜€\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid Escape Sequence\",\n\t\t\tinput:    \"\\\\uABCD\",\n\t\t\texpected: \"\\\\uABCD\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f5e0639406a7ac149ef59ce46b9fd877": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_getKV(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\to    *Object\n\t\twant *kv\n\t}{\n\t\t{\n\t\t\tname: \"empty kvs\",\n\t\t\to:    &Object{kvs: []kv{}},\n\t\t\twant: &kv{},\n\t\t},\n\t\t{\n\t\t\tname: \"non-empty kvs\",\n\t\t\to: &Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"key1\", v: &Value{}},\n\t\t\t\t\t{k: \"key2\", v: &Value{}},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: &kv{k: \"key2\", v: &Value{}},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.o.getKV(); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Object.getKV() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f61bfa80baef78dd9ee3035bba841ed5": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"no leading whitespace\",\n\t\t\tinput:    \"hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading space\",\n\t\t\tinput:    \" hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading newline\",\n\t\t\tinput:    \"\\nhello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading tab\",\n\t\t\tinput:    \"\\thello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading carriage return\",\n\t\t\tinput:    \"\\rhello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple leading whitespace\",\n\t\t\tinput:    \"   \\t\\n\\r hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"whitespace only\",\n\t\t\tinput:    \"   \\t\\n\\r \",\n\t\t\texpected: \"\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := skipWSSlow(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"skipWSSlow(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f6f799d652f95548df1454b0da524481": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: []string{\"hello\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello\\\"world\"`,\n\t\t\texpected: []string{\"hello\\\"world\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello\\\"world\\\"foo\"`,\n\t\t\texpected: []string{\"hello\\\"world\\\"foo\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with no closing quote\",\n\t\t\tinput:    `\"hello`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot1, got2, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got1 != tc.expected[0] {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tc.expected[0])\n\t\t\t}\n\t\t\tif got2 != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawString() got2 = %v, want %v\", got2, tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "f7c57cc5d4987c63433126e4c45ef159": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"no whitespace\",\n\t\t\tinput:    \"hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading whitespace\",\n\t\t\tinput:    \"   hello\",\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname:     \"trailing whitespace\",\n\t\t\tinput:    \"hello   \",\n\t\t\texpected: \"hello   \",\n\t\t},\n\t\t{\n\t\t\tname:     \"leading and trailing whitespace\",\n\t\t\tinput:    \"   hello   \",\n\t\t\texpected: \"hello   \",\n\t\t},\n\t\t{\n\t\t\tname:     \"mixed whitespace\",\n\t\t\tinput:    \"   \\t\\n\\r hello \\t\\n\\r\",\n\t\t\texpected: \"hello \\t\\n\\r\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := skipWSSlow(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"skipWSSlow(%q) = %q, expected %q\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f42b808694ac056f3434ca48d3a97f42": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: \"{}\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs:           []kv{},\n\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with one key-value pair\",\n\t\t\tinput: `{\"key\":\"value\"}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with multiple key-value pairs\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":123,\"key3\":true}`,\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\t\tv: &Value{\n\t\t\t\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\tinput: `{\"key1\":\"value1\",`,\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"unexpected end of object\"),\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing colon\",\n\t\t\tinput: `{\"key1\" \"value1\"}`,\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{\n\t\t\t\tvs: make([]Value, 0, 8),\n\t\t\t}\n\t\t\tactual, _, err := parseObject(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseObject(%q) error = %v, expected %v\", tc.input, err, tc.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif tc.err != nil {\n\t\t\t\t\tt.Errorf(\"parseObject(%q) error = nil, expected %v\", tc.input, tc.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif !equalValues(actual, tc.expected) {\n\t\t\t\t\tt.Errorf(\"parseObject(%q) = %v, expected %v\", tc.input, actual, tc.expected)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn equalObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn equalArrays(v1.a, v2.a)\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber, TypeTrue, TypeFalse:\n\t\treturn v1.s == v2.s\n\tcase TypeNull:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc equalObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !equalValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc equalArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tv2 := a2[i]\n\t\tif !equalValues(v1, v2) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "f583068e21b7ee06f424a489cd2eb93d": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"too big depth\",\n\t\t\tinput:    \"{}\", // Assuming MaxDepth is 1\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds 1\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"valid object\",\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{s: \"value\", t: TypeString}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"1\", t: TypeNumber},\n\t\t\t\t\t{s: \"2\", t: TypeNumber},\n\t\t\t\t\t{s: \"3\", t: TypeNumber},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{s: \"hello\", t: TypeString},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid true\",\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid false\",\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid null\",\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"42\",\n\t\t\texpected: &Value{s: \"42\", t: TypeNumber},\n\t\t\terr:      nil,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, expected %v\", tc.input, err, tc.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else if tc.err != nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = nil, expected %v\", tc.input, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, expected %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn compareObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn compareArrays(v1.a, v2.a)\n\tcase TypeString, TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeTrue, TypeFalse, TypeNull:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc compareObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc compareArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tif !compareValues(v1, a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "f625b903fe1f87df3db897c6edb4f6ae": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: &Value{\n\t\t\t\ts: \"hello\",\n\t\t\t\tt: typeRawString,\n\t\t\t},\n\t\t\twant: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{s: \"value1\", t: TypeString}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{s: \"value2\", t: TypeString}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":\"value1\",\"key2\":\"value2\"}`),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"value1\", t: TypeString},\n\t\t\t\t\t{s: \"value2\", t: TypeString},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\twant: []byte(`[\"value1\",\"value2\"]`),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: &Value{\n\t\t\t\ts: \"hello\",\n\t\t\t\tt: TypeString,\n\t\t\t},\n\t\t\twant: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: &Value{\n\t\t\t\ts: \"42\",\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\twant: []byte(\"42\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %q, want %q\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f8928951972e02af89edabbec7377750": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestInt(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    *Value\n\t\texpected int\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    &Value{s: \"42\", t: TypeNumber},\n\t\t\texpected: 42,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"non-number type\",\n\t\t\tinput:    &Value{s: \"true\", t: TypeTrue},\n\t\t\texpected: 0,\n\t\t\terr:      fmt.Errorf(\"value doesn't contain number; it contains true\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"number out of int range\",\n\t\t\tinput:    &Value{s: \"9223372036854775808\", t: TypeNumber},\n\t\t\texpected: 0,\n\t\t\terr:      fmt.Errorf(\"number \\\"9223372036854775808\\\" doesn't fit int\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number format\",\n\t\t\tinput:    &Value{s: \"3.14\", t: TypeNumber},\n\t\t\texpected: -1,\n\t\t\terr:      fmt.Errorf(\"invalid syntax\"),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, err := tc.input.Int()\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil {\n\t\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t\t} else if err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"expected error %v, got %v\", tc.err, err)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif actual != tc.expected {\n\t\t\t\t\tt.Errorf(\"expected %d, got %d\", tc.expected, actual)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}",
    "f95819b73bedc0740878a7252e4ef62b": "package fastjson_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/valyala/fastjson\"\n)\n\nfunc TestTypeString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    fastjson.Type\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"TypeObject\",\n\t\t\tinput:    fastjson.TypeObject,\n\t\t\texpected: \"object\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeArray\",\n\t\t\tinput:    fastjson.TypeArray,\n\t\t\texpected: \"array\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeString\",\n\t\t\tinput:    fastjson.TypeString,\n\t\t\texpected: \"string\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeNumber\",\n\t\t\tinput:    fastjson.TypeNumber,\n\t\t\texpected: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeTrue\",\n\t\t\tinput:    fastjson.TypeTrue,\n\t\t\texpected: \"true\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeFalse\",\n\t\t\tinput:    fastjson.TypeFalse,\n\t\t\texpected: \"false\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeNull\",\n\t\t\tinput:    fastjson.TypeNull,\n\t\t\texpected: \"null\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Unknown Type\",\n\t\t\tinput:    fastjson.Type(100),\n\t\t\texpected: \"BUG: unknown Value type: 100\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := tc.input.String()\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"expected %q, got %q\", tc.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f8da9bdf20008c2b106a9e69d349e4ba": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello world\"`,\n\t\t\texpected: []string{\"hello world\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello \\\"world\\\"\"`,\n\t\t\texpected: []string{\"hello \\\"world\\\"\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello \\\"world\\\" \\\"foo\\\"\"`,\n\t\t\texpected: []string{\"hello \\\"world\\\" \\\"foo\\\"\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with no closing quote\",\n\t\t\tinput:    `\"hello world`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot1, got2, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got1 != tc.expected[0] || got2 != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = (%q, %q), want (%q, %q)\", tc.input, got1, got2, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "f9747230c68e23c0a3a3fc2165b2b8a6": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":\"value1\",\"key2\":42}`),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"hello\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`[\"hello\",42,true]`),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42\",\n\t\t\t},\n\t\t\twant: []byte(\"42\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %q, want %q\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f981bfe9171513de09c0681357443d27": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: []string{\"hello\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello\\\"world\"`,\n\t\t\texpected: []string{\"hello\\\"world\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello\\\"world\\\"foo\"`,\n\t\t\texpected: []string{\"hello\\\"world\\\"foo\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with no closing quote\",\n\t\t\tinput:    `\"hello`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot, got2, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tc.expected[0] {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, expected %v\", got, tc.expected[0])\n\t\t\t}\n\t\t\tif got2 != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawString() got2 = %v, expected %v\", got2, tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "f7174365718278f6c246af3c02df800c": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"valid JSON\",\n\t\t\tinput: `{\"key1\": \"value1\", \"key2\": 42}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{s: \"value1\", t: TypeString}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{s: \"42\", t: TypeNumber}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"invalid JSON\",\n\t\t\tinput: `{\"key1\": \"value1\", \"key2\":`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:  \"JSON with trailing whitespace\",\n\t\t\tinput: `{\"key1\": \"value1\", \"key2\": 42}   `,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{s: \"value1\", t: TypeString}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{s: \"42\", t: TypeNumber}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tp := &Parser{}\n\t\t\tactual, err := p.Parse(tc.input)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !equalValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"expected %+v, got %+v\", tc.expected, actual)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn equalObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn equalArrays(v1.a, v2.a)\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber, TypeTrue, TypeFalse:\n\t\treturn v1.s == v2.s\n\tcase TypeNull:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc equalObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !equalValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc equalArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tif !equalValues(v1, a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "fb729c9e664590824f43d00dd4575e18": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"simple string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: []string{\"hello\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with escaped quote\",\n\t\t\tinput:    `\"hello\\\"world\"`,\n\t\t\texpected: []string{\"hello\\\"world\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with multiple escaped quotes\",\n\t\t\tinput:    `\"hello\\\"world\\\"foo\"`,\n\t\t\texpected: []string{\"hello\\\"world\\\"foo\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"string with no closing quote\",\n\t\t\tinput:    `\"hello`,\n\t\t\texpected: []string{\"\", \"\"},\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot, got2, err := parseRawString(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tc.expected[0] {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, expected %v\", got, tc.expected[0])\n\t\t\t}\n\t\t\tif got2 != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawString() got2 = %v, expected %v\", got2, tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "fad2cd55a1437b3ce0da7feb21a2c28c": "package fastjson\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: &Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":\"value1\",\"key2\":42}`),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"str1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`[\"str1\",42,true]`),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\\\"world\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello\\\"world\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42.5\",\n\t\t\t},\n\t\t\twant: []byte(\"42.5\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: &Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := make([]byte, 0, 100)\n\t\t\tgot := tt.v.MarshalTo(dst)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %q, want %q\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "fce70cc9e40ba2c400ed89f3e0ba423b": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetInt(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tjson     string\n\t\tkeys     []string\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"Existing integer value\",\n\t\t\tjson:     `{\"key1\": 42}`,\n\t\t\tkeys:     []string{\"key1\"},\n\t\t\texpected: 42,\n\t\t},\n\t\t{\n\t\t\tname:     \"Existing float value\",\n\t\t\tjson:     `{\"key1\": 3.14}`,\n\t\t\tkeys:     []string{\"key1\"},\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"Non-existing key\",\n\t\t\tjson:     `{\"key1\": 42}`,\n\t\t\tkeys:     []string{\"key2\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid value type\",\n\t\t\tjson:     `{\"key1\": true}`,\n\t\t\tkeys:     []string{\"key1\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Array index\",\n\t\t\tjson:     `[1, 2, 3]`,\n\t\t\tkeys:     []string{\"1\"},\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"Nested object\",\n\t\t\tjson:     `{\"key1\": {\"key2\": 100}}`,\n\t\t\tkeys:     []string{\"key1\", \"key2\"},\n\t\t\texpected: 100,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tv, err := Parse(tc.json)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Failed to parse JSON: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tactual := v.GetInt(tc.keys...)\n\t\t\tif actual != tc.expected {\n\t\t\t\tt.Errorf(\"GetInt(%v) = %d, want %d\", tc.keys, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "fafe949e40ef0e679a1dce9f0ab14244": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: \"{}\",\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           []kv{},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"simple object\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with whitespace\",\n\t\t\tinput: `{ \"key1\" : \"value1\" , \"key2\" : 42 }`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42`,\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing colon\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\" 42}`,\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing comma\",\n\t\t\tinput: `{\"key1\":\"value1\" \"key2\":42}`,\n\t\t\terr:   true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tv, _, err := parseObject(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tc.err && !v.Equal(tc.expected) {\n\t\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", tc.input, v, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "fa1f625cfa6f647e389ef8b2e4a2b0f7": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: \"{}\",\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           []kv{},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"simple object\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with whitespace\",\n\t\t\tinput: `{ \"key1\" : \"value1\" , \"key2\" : 42 }`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing colon\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\" 42}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing comma\",\n\t\t\tinput: `{\"key1\":\"value1\" \"key2\":42}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{\n\t\t\t\tvs: make([]Value, 0, 8),\n\t\t\t}\n\t\t\tactual, _, err := parseObject(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn compareObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn compareArrays(v1.a, v2.a)\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber, TypeTrue, TypeFalse:\n\t\treturn v1.s == v2.s\n\tcase TypeNull:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc compareObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc compareArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tif !compareValues(v1, a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "ff2e64941735c4b5b5fb0f73d2564232": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetUint(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    *Value\n\t\tkeys     []string\n\t\texpected uint\n\t}{\n\t\t{\n\t\t\tname:     \"valid uint\",\n\t\t\tinput:    &Value{s: \"42\", t: TypeNumber},\n\t\t\tkeys:     []string{},\n\t\t\texpected: 42,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid value type\",\n\t\t\tinput:    &Value{s: \"true\", t: TypeTrue},\n\t\t\tkeys:     []string{},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"non-existing keys path\",\n\t\t\tinput:    &Value{s: \"42\", t: TypeNumber},\n\t\t\tkeys:     []string{\"foo\", \"bar\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"uint64 overflow\",\n\t\t\tinput:    &Value{s: \"18446744073709551616\", t: TypeNumber},\n\t\t\tkeys:     []string{},\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := tc.input.GetUint(tc.keys...)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"GetUint(%v) = %d, expected %d\", tc.keys, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "fb7e9ab90d925bed85b64d15b8032d26": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty array\",\n\t\t\tinput: \"[]\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with values\",\n\t\t\tinput: \"[1, 2, 3]\",\n\t\t\texpected: func() *Value {\n\t\t\t\tv1 := &Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"1\",\n\t\t\t\t}\n\t\t\t\tv2 := &Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"2\",\n\t\t\t\t}\n\t\t\t\tv3 := &Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"3\",\n\t\t\t\t}\n\t\t\t\tv := &Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{v1, v2, v3},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with missing closing bracket\",\n\t\t\tinput: \"[1, 2, 3\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with missing comma\",\n\t\t\tinput: \"[1 2]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{}\n\t\t\tactual, _, err := parseArray(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseArray(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !compareValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeTrue, TypeFalse, TypeNull:\n\t\treturn true\n\tdefault:\n\t\tpanic(\"unsupported type\")\n\t}\n}",
    "fa43a2f1438e1f409b9dcf9d2fc25dc6": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: \"{}\",\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           []kv{},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"simple object\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: &Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with nested value\",\n\t\t\tinput: `{\"key1\":{\"subkey\":\"subvalue\"}}`,\n\t\t\texpected: &Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: &Value{\n\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t{k: \"subkey\", v: &Value{t: TypeString, s: \"subvalue\"}},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object with missing closing brace\",\n\t\t\tinput: `{\"key1\":\"value1\",\"key2\":42`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := &cache{\n\t\t\t\tvs: make([]Value, 0, 8),\n\t\t\t}\n\t\t\tactual, _, err := parseObject(tc.input, c, 0)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", tc.input, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn compareObjects(&v1.o, &v2.o)\n\tcase TypeArray:\n\t\treturn compareArrays(v1.a, v2.a)\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeTrue, TypeFalse, TypeNull:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc compareObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc compareArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tif !compareValues(v1, a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "ff75975ea5cedab01a573834e62bf964": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"123.456e+78\",\n\t\t\texpected: []string{\"123.456e+78\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"number with trailing characters\",\n\t\t\tinput:    \"123.456e+78abc\",\n\t\t\texpected: []string{\"123.456e+78\", \"abc\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number\",\n\t\t\tinput:    \"abc\",\n\t\t\texpected: []string{\"\", \"abc\"},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"inf\",\n\t\t\tinput:    \"inf\",\n\t\t\texpected: []string{\"inf\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"nan\",\n\t\t\tinput:    \"nan\",\n\t\t\texpected: []string{\"nan\", \"\"},\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tc.input)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tc.input, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif num != tc.expected[0] || rest != tc.expected[1] {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, %q, want %q, %q\", tc.input, num, rest, tc.expected[0], tc.expected[1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "ff29818ed9c5eb2e04b751c3ad5a474c": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty input\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"depth exceeds MaxDepth\",\n\t\t\tinput:    \"{}\", // Assuming MaxDepth is 1\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t},\n\t\t{\n\t\t\tname:     \"parse object\",\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{s: \"value\", t: typeRawString}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"parse array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"1\", t: TypeNumber},\n\t\t\t\t\t{s: \"2\", t: TypeNumber},\n\t\t\t\t\t{s: \"3\", t: TypeNumber},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"parse string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{\n\t\t\t\ts: \"hello\",\n\t\t\t\tt: typeRawString,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"parse true\",\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"parse false\",\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"parse null\",\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"parse number\",\n\t\t\tinput:    \"42\",\n\t\t\texpected: &Value{\n\t\t\t\ts: \"42\",\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, expected %v\", tc.input, err, tc.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else if tc.err != nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = nil, expected %v\", tc.input, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, expected %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\to1, _ := v1.Object()\n\t\to2, _ := v2.Object()\n\t\tif len(o1.kvs) != len(o2.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, kv1 := range o1.kvs {\n\t\t\tkv2 := o2.kvs[i]\n\t\t\tif kv1.k != kv2.k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !compareValues(kv1.v, kv2.v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\tcase TypeArray:\n\t\ta1, _ := v1.Array()\n\t\ta2, _ := v2.Array()\n\t\tif len(a1) != len(a2) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, v1 := range a1 {\n\t\t\tif !compareValues(v1, a2[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\tcase typeRawString, TypeString, TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeTrue, TypeFalse, TypeNull:\n\t\treturn true\n\t}\n\treturn true\n}",
    "feacaa5e88202caacf33cb33a02608a6": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"too deep\",\n\t\t\tinput:    \"{}\", // Assuming MaxDepth is 1\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t},\n\t\t{\n\t\t\tname:     \"valid object\",\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: &Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: &Value{s: \"value\", t: typeRawString}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\texpected: &Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"1\", t: TypeNumber},\n\t\t\t\t\t{s: \"2\", t: TypeNumber},\n\t\t\t\t\t{s: \"3\", t: TypeNumber},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: &Value{\n\t\t\t\ts: \"hello\",\n\t\t\t\tt: typeRawString,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid true\",\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid false\",\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid null\",\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid number\",\n\t\t\tinput:    \"42\",\n\t\t\texpected: &Value{\n\t\t\t\ts: \"42\",\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t}\n\n\tc := &cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tc.err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, expected %v\", tc.input, err, tc.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else if tc.err != nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = nil, expected %v\", tc.input, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !compareValues(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, expected %v\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil && v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\to1, _ := v1.Object()\n\t\to2, _ := v2.Object()\n\t\treturn compareObjects(o1, o2)\n\tcase TypeArray:\n\t\ta1, _ := v1.Array()\n\t\ta2, _ := v2.Array()\n\t\tif len(a1) != len(a2) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range a1 {\n\t\t\tif !compareValues(a1[i], a2[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase typeRawString, TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber, TypeTrue, TypeFalse, TypeNull:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc compareObjects(o1, o2 *Object) bool {\n\tif o1 == nil && o2 == nil {\n\t\treturn true\n\t}\n\tif o1 == nil || o2 == nil {\n\t\treturn false\n\t}\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i := range o1.kvs {\n\t\tif o1.kvs[i].k != o2.kvs[i].k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(o1.kvs[i].v, o2.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}"
}