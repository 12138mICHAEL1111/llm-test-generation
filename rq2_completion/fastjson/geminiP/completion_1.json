{"00278ae3692fa09d9f958ad63beba116":"package fastjson\n\nimport \"testing\"\n\nfunc TestValue_Exists(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tjson  string\n\t\tkeys  []string\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname:  \"simple_object_existing_key\",\n\t\t\tjson:  `{\"a\": 1}`,\n\t\t\tkeys:  []string{\"a\"},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"simple_object_nonexisting_key\",\n\t\t\tjson:  `{\"a\": 1}`,\n\t\t\tkeys:  []string{\"b\"},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"nested_object_existing_key\",\n\t\t\tjson:  `{\"a\": {\"b\": 1}}`,\n\t\t\tkeys:  []string{\"a\", \"b\"},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"nested_object_nonexisting_key\",\n\t\t\tjson:  `{\"a\": {\"b\": 1}}`,\n\t\t\tkeys:  []string{\"a\", \"c\"},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array_existing_index\",\n\t\t\tjson:  `[1, 2, 3]`,\n\t\t\tkeys:  []string{\"1\"},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array_nonexisting_index\",\n\t\t\tjson:  `[1, 2, 3]`,\n\t\t\tkeys:  []string{\"5\"},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array_out_of_bounds_index\",\n\t\t\tjson:  `[1, 2, 3]`,\n\t\t\tkeys:  []string{\"-1\"},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"nested_array_existing_index\",\n\t\t\tjson:  `[[1, 2], [3, 4]]`,\n\t\t\tkeys:  []string{\"1\", \"0\"},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"nested_array_nonexisting_index\",\n\t\t\tjson:  `[[1, 2], [3, 4]]`,\n\t\t\tkeys:  []string{\"1\", \"2\"},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"empty_keys\",\n\t\t\tjson:  `{\"a\": 1}`,\n\t\t\tkeys:  []string{},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"empty_json\",\n\t\t\tjson:  ``,\n\t\t\tkeys:  []string{\"a\"},\n\t\t\twant: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv, err := ParseBytes([]byte(tt.json))\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"ParseBytes() error = %v, wantErr %v\", err, nil)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got := v.Exists(tt.keys...); got != tt.want {\n\t\t\t\tt.Errorf(\"Exists() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","0144670a849d18faf8a4f3ce07fa7a09":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_Visit(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tjson string\n\t\twant map[string]string\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\tjson: \"{}\",\n\t\t\twant: map[string]string{},\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\tjson: `{\"a\": \"b\", \"c\": \"d\"}`,\n\t\t\twant: map[string]string{\"a\": \"b\", \"c\": \"d\"},\n\t\t},\n\t\t{\n\t\t\tname: \"nested object\",\n\t\t\tjson: `{\"a\": \"b\", \"c\": {\"d\": \"e\"}}`,\n\t\t\twant: map[string]string{\"a\": \"b\", \"c\": `{\"d\": \"e\"}`},\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tjson: `{\"a\": [1,2,3]}`,\n\t\t\twant: map[string]string{\"a\": \"[1,2,3]\"},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tvar o Object\n\t\t\tif err := json.Unmarshal([]byte(tt.json), \u0026o); err != nil {\n\t\t\t\tt.Errorf(\"Unmarshal() error = %v, wantErr %v\", err, nil)\n\t\t\t}\n\n\t\t\tgot := make(map[string]string)\n\t\t\to.Visit(func(key []byte, v *Value) {\n\t\t\t\tgot[string(key)] = v.String()\n\t\t\t})\n\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Visit() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","02a8269c4ee18a4fbb8c09411ab1841f":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestValue_Uint(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  uint\n\t\terr   error\n\t}{\n\t\t{input: `123`, want: 123, err: nil},\n\t\t{input: `123.456`, want: 0, err: fmt.Errorf(\"number \\\"123.456\\\" doesn't fit uint\")},\n\t\t{input: `\"123\"`, want: 0, err: fmt.Errorf(\"value doesn't contain number; it contains string\")},\n\t\t{input: `null`, want: 0, err: fmt.Errorf(\"value doesn't contain number; it contains null\")},\n\t\t{input: `{\"key\": 123}`, want: 0, err: fmt.Errorf(\"value doesn't contain number; it contains object\")},\n\t\t{input: `[1,2,3]`, want: 0, err: fmt.Errorf(\"value doesn't contain number; it contains array\")},\n\t\t{input: `true`, want: 0, err: fmt.Errorf(\"value doesn't contain number; it contains true\")},\n\t\t{input: `false`, want: 0, err: fmt.Errorf(\"value doesn't contain number; it contains false\")},\n\t\t{input: `9223372036854775808`, want: 0, err: fmt.Errorf(\"number \\\"9223372036854775808\\\" doesn't fit uint\")},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tv := \u0026Value{t: TypeNumber, s: tt.input}\n\t\t\tgot, err := v.Uint()\n\t\t\tif tt.err != nil {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"expected error, got nil\")\n\t\t\t\t} else if err.Error() != tt.err.Error() {\n\t\t\t\t\tt.Errorf(\"want error: %v, got: %v\", tt.err, err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"want: %v, got: %v\", tt.want, got)\n\t\t\t}\n\t\t})\n\t}\n}","030050b2471e57cd0d6c0d511578aae8":"package fastjson\n\nimport \"testing\"\n\nfunc TestSkipWS(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"  \\n\\t\\r foo\", \"foo\"},\n\t\t{\"foo\", \"foo\"},\n\t\t{\"\\x00foo\", \"\\x00foo\"},\n\t\t{\"\\x1ffoo\", \"\\x1ffoo\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := skipWS(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"skipWS(%q) = %q, want %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}\n","030088fada765edfb609350d13c2384f":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantN    string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Empty input\n\t\t{\"\", \"\", \"\", nil},\n\n\t\t// Valid numbers\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"123.45\", \"123.45\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"+123\", \"+123\", \"\", nil},\n\t\t{\"1e5\", \"1e5\", \"\", nil},\n\t\t{\"1.2e-5\", \"1.2e-5\", \"\", nil},\n\n\t\t// Valid numbers with trailing characters\n\t\t{\"123a\", \"123\", \"a\", nil},\n\t\t{\"123.45b\", \"123.45\", \"b\", nil},\n\t\t{\"-123c\", \"-123\", \"c\", nil},\n\n\t\t// Invalid numbers\n\t\t{\"a123\", \"\", \"a123\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\".123\", \"\", \".123\", fmt.Errorf(\"unexpected char: %q\", \".\")},\n\t\t{\"+a123\", \"\", \"+a123\", fmt.Errorf(\"unexpected char: %q\", \"+\")},\n\t\t{\"-a123\", \"\", \"-a123\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\n\t\t// Special cases: \"inf\", \"nan\"\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"+inf\", \"+inf\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"in\", \"\", \"in\", fmt.Errorf(\"unexpected char: %q\", \"i\")},\n\t\t{\"infx\", \"inf\", \"x\", nil},\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"+nan\", \"+nan\", \"\", nil},\n\t\t{\"-nan\", \"-nan\", \"\", nil},\n\t\t{\"na\", \"\", \"na\", fmt.Errorf(\"unexpected char: %q\", \"n\")},\n\t\t{\"nanx\", \"nan\", \"x\", nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tgotN, gotTail, gotErr := parseRawNumber(tt.input)\n\t\t\tif gotN != tt.wantN || gotTail != tt.wantTail || (gotErr != nil \u0026\u0026 tt.wantErr == nil) || (gotErr == nil \u0026\u0026 tt.wantErr != nil) || (gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error()) {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = (%q, %q, %v), want (%q, %q, %v)\", tt.input, gotN, gotTail, gotErr, tt.wantN, tt.wantTail, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","033289b6ad4a2cc3c8f2036ab17e5a0b":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twant     *Value\n\t\twantRest string\n\t\twantErr  error\n\t}{\n\t\t{\n\t\t\tname:     \"empty array\",\n\t\t\tinput:    \"[]\",\n\t\t\twant:     \u0026Value{t: TypeArray, a: []*Value{}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"single element array\",\n\t\t\tinput:    \"[1]\",\n\t\t\twant:     \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple element array\",\n\t\t\tinput:    \"[1,2,3]\",\n\t\t\twant: \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with whitespace\",\n\t\t\tinput:    \" [ 1 , 2 , 3 ] \",\n\t\t\twant: \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"nested array\",\n\t\t\tinput:    \"[[1,2],[3,4]]\",\n\t\t\twant: \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeArray, a: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t}},\n\t\t\t\t{t: TypeArray, a: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t\t{t: TypeNumber, s: \"4\"},\n\t\t\t\t}},\n\t\t\t}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing closing bracket\",\n\t\t\tinput:    \"[1,2,3\",\n\t\t\twant:     nil,\n\t\t\twantRest: \"\",\n\t\t\twantErr:  fmt.Errorf(\"unexpected end of array\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"missing comma\",\n\t\t\tinput:    \"[1 2 3]\",\n\t\t\twant:     nil,\n\t\t\twantRest: \"\",\n\t\t\twantErr:  fmt.Errorf(\"missing ',' after array value\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid value\",\n\t\t\tinput:    \"[1,a,3]\",\n\t\t\twant:     nil,\n\t\t\twantRest: \"\",\n\t\t\twantErr:  fmt.Errorf(\"cannot parse array value: invalid character 'a' looking for beginning of value\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, rest, err := parseArray(tt.input, c, 0)\n\n\t\t\tif tt.wantErr != nil {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"parseArray() error = nil, wantErr %v\", tt.wantErr)\n\t\t\t\t} else if err.Error() != tt.wantErr.Error() {\n\t\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr nil\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif rest != tt.wantRest {\n\t\t\t\tt.Errorf(\"parseArray() rest = %s, wantRest %s\", rest, tt.wantRest)\n\t\t\t}\n\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(a, b *Value) bool {\n\tif a == nil \u0026\u0026 b == nil {\n\t\treturn true\n\t}\n\tif a == nil || b == nil {\n\t\treturn false\n\t}\n\tif a.t != b.t {\n\t\treturn false\n\t}\n\tif a.t == TypeArray {\n\t\tif len(a.a) != len(b.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range a.a {\n\t\t\tif !equalValues(a.a[i], b.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\treturn a.s == b.s\n}","033e68fd7e13f2d9c2f9e28af7b159b4":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput  string\n\t\texpect string\n\t}{\n\t\t// Basic cases.\n\t\t{\"\", \"\"},\n\t\t{\"foo\", \"foo\"},\n\t\t{\"foo bar\", \"foo bar\"},\n\n\t\t// Escaped characters.\n\t\t{`\"`, `\"`},\n\t\t{`\\`, `\\`},\n\t\t{`/`, `/`},\n\t\t{`\\b`, \"\\b\"},\n\t\t{`\\f`, \"\\f\"},\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\r`, \"\\r\"},\n\t\t{`\\t`, \"\\t\"},\n\n\t\t// Unicode escape sequences.\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A0`, \"\\u00A0\"},\n\t\t{`\\uFFFF`, \"\\uFFFF\"},\n\t\t{`\\uD83D\\uDE01`, \"üòÅ\"},\n\n\t\t// Invalid escape sequences.\n\t\t{`\\u`, `\\u`},\n\t\t{`\\u00`, `\\u00`},\n\t\t{`\\u002`, `\\u002`},\n\t\t{`\\u002X`, `\\u002X`},\n\t\t{`\\uD800`, `\\uD800`},\n\t\t{`\\uD800\\u`, `\\uD800\\u`},\n\t\t{`\\uD800\\uD800`, `\\uD800\\uD800`},\n\n\t\t// Mixed cases.\n\t\t{`foo\\nbar`, \"foo\\nbar\"},\n\t\t{`foo\\uD83D\\uDE01bar`, \"fooüòÅbar\"},\n\t\t{`foo\\u002Xbar`, `foo\\u002Xbar`},\n\t}\n\n\tfor i, tt := range tests {\n\t\tactual := unescapeStringBestEffort(tt.input)\n\t\tif actual != tt.expect {\n\t\t\tt.Errorf(\"Test %d: Expected %q, got %q\", i, tt.expect, actual)\n\t\t}\n\t}\n}\n","038822c39cb85eb822913d7b1c215e0d":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantValue  *Value\n\t\twantTail string\n\t\twantErr   error\n\t}{\n\t\t// Empty string\n\t\t{\n\t\t\tname:     \"EmptyString\",\n\t\t\tinput:    \"\",\n\t\t\twantValue:  nil,\n\t\t\twantTail: \"\",\n\t\t\twantErr:   fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t// Object\n\t\t{\n\t\t\tname:     \"Object\",\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\twantValue:  \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{t: typeRawString, s: \"value\"}}}}}},\n\t\t\twantTail: \"\",\n\t\t\twantErr:   nil,\n\t\t},\n\t\t// Array\n\t\t{\n\t\t\tname:     \"Array\",\n\t\t\tinput:    `[1, \"test\"]`,\n\t\t\twantValue:  \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: typeRawString, s: \"test\"}}},\n\t\t\twantTail: \"\",\n\t\t\twantErr:   nil,\n\t\t},\n\t\t// String\n\t\t{\n\t\t\tname:     \"String\",\n\t\t\tinput:    `\"test\"`,\n\t\t\twantValue:  \u0026Value{t: typeRawString, s: \"test\"},\n\t\t\twantTail: \"\",\n\t\t\twantErr:   nil,\n\t\t},\n\t\t// True\n\t\t{\n\t\t\tname:     \"True\",\n\t\t\tinput:    \"true\",\n\t\t\twantValue:  valueTrue,\n\t\t\twantTail: \"\",\n\t\t\twantErr:   nil,\n\t\t},\n\t\t// False\n\t\t{\n\t\t\tname:     \"False\",\n\t\t\tinput:    \"false\",\n\t\t\twantValue:  valueFalse,\n\t\t\twantTail: \"\",\n\t\t\twantErr:   nil,\n\t\t},\n\t\t// Null\n\t\t{\n\t\t\tname:     \"Null\",\n\t\t\tinput:    \"null\",\n\t\t\twantValue:  valueNull,\n\t\t\twantTail: \"\",\n\t\t\twantErr:   nil,\n\t\t},\n\t\t// NaN\n\t\t{\n\t\t\tname:     \"NaN\",\n\t\t\tinput:    \"NaN\",\n\t\t\twantValue:  \u0026Value{t: TypeNumber, s: \"NaN\"},\n\t\t\twantTail: \"\",\n\t\t\twantErr:   nil,\n\t\t},\n\t\t// Number\n\t\t{\n\t\t\tname:     \"Number\",\n\t\t\tinput:    \"123.456\",\n\t\t\twantValue:  \u0026Value{t: TypeNumber, s: \"123.456\"},\n\t\t\twantTail: \"\",\n\t\t\twantErr:   nil,\n\t\t},\n\t\t// Unexpected value\n\t\t{\n\t\t\tname:     \"UnexpectedValue\",\n\t\t\tinput:    \"invalid\",\n\t\t\twantValue:  nil,\n\t\t\twantTail: \"invalid\",\n\t\t\twantErr:   fmt.Errorf(\"unexpected value found: %q\", \"invalid\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgotValue, gotTail, gotErr := parseValue(tt.input, c, 0)\n\n\t\t\tif gotErr != nil {\n\t\t\t\tif tt.wantErr == nil {\n\t\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", gotErr, tt.wantErr)\n\t\t\t\t} else if gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", gotErr, tt.wantErr)\n\t\t\t\t}\n\t\t\t} else if tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"parseValue() error = nil, wantErr %v\", tt.wantErr)\n\t\t\t}\n\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseValue() gotTail = %v, want %v\", gotTail, tt.wantTail)\n\t\t\t}\n\n\t\t\tif !equalValues(gotValue, tt.wantValue) {\n\t\t\t\tt.Errorf(\"parseValue() gotValue = %v, want %v\", gotValue, tt.wantValue)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.t == TypeObject {\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\tif v1.t == TypeArray {\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\treturn v1.s == v2.s\n}\n","04d0d806717ea36eb17f2b72144f32a0":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetBool(t *testing.T) {\n\ttests := []struct {\n\t\tjson string\n\t\targs []string\n\t\twant bool\n\t}{\n\t\t// Existing key, bool value\n\t\t{`{\"a\": true}`, []string{\"a\"}, true},\n\t\t{`{\"a\": {\"b\": true}}`, []string{\"a\", \"b\"}, true},\n\n\t\t// Existing key, non-bool value\n\t\t{`{\"a\": 123}`, []string{\"a\"}, false},\n\t\t{`{\"a\": \"true\"}`, []string{\"a\"}, false},\n\n\t\t// Non-existing key\n\t\t{`{\"a\": true}`, []string{\"b\"}, false},\n\t\t{`{\"a\": {\"b\": true}}`, []string{\"a\", \"c\"}, false},\n\n\t\t// Array access\n\t\t{`{\"a\": [true, false]}`, []string{\"a\", \"0\"}, true},\n\t\t{`{\"a\": [true, false]}`, []string{\"a\", \"1\"}, false},\n\t\t{`{\"a\": [true, false]}`, []string{\"a\", \"2\"}, false},\n\n\t\t// Invalid array index\n\t\t{`{\"a\": [true, false]}`, []string{\"a\", \"abc\"}, false},\n\t}\n\tfor i, tt := range tests {\n\t\tv, err := Parse([]byte(tt.json))\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Test %d: Error parsing JSON: %v\", i, err)\n\t\t\tcontinue\n\t\t}\n\t\tif got := v.GetBool(tt.args...); got != tt.want {\n\t\t\tt.Errorf(\"Test %d: GetBool(%v) = %v, want %v\", i, tt.args, got, tt.want)\n\t\t}\n\t}\n}","04d6e97909589953719868a25b6e57cd":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey   string\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Simple keys\n\t\t{`\"key\": \"value\"`, \"key\", `: \"value\"`, nil},\n\t\t{`\"another_key\": 123`, \"another_key\", `: 123`, nil},\n\n\t\t// Empty key\n\t\t{`\"\": \"value\"`, \"\", `: \"value\"`, nil},\n\n\t\t// Key with escaped quotes\n\t\t// {`\"key\\\"with_quotes\": \"value\"`, `key\\\"with_quotes`, `: \"value\"`, nil},\n\n\t\t// Missing closing quote\n\t\t{`\"key: \"value\"`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"key`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tkey, tail, err := parseRawKey(tt.input)\n\n\t\t\tif key != tt.key {\n\t\t\t\tt.Errorf(\"expected key %q, got %q\", tt.key, key)\n\t\t\t}\n\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"expected tail %q, got %q\", tt.tail, tail)\n\t\t\t}\n\n\t\t\tif (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"expected error %v, got %v\", tt.err, err)\n\t\t\t}\n\t\t})\n\t}\n}","04dc8272468e903ebae88b5145747003":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_reset(t *testing.T) {\n\to := \u0026Object{\n\t\tkvs: []kv{\n\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\"}},\n\t\t\t{k: \"key2\", v: \u0026Value{s: \"value2\"}},\n\t\t},\n\t\tkeysUnescaped: true,\n\t}\n\to.reset()\n\tif len(o.kvs) != 0 {\n\t\tt.Errorf(\"Expected o.kvs to be empty after reset, got %v\", o.kvs)\n\t}\n\tif o.keysUnescaped {\n\t\tt.Error(\"Expected o.keysUnescaped to be false after reset\")\n\t}\n}","0579ad30148187ef9637d5bc4d216b67":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"raw string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"raw string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"12345\",\n\t\t\t},\n\t\t\twant: []byte(\"12345\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"string1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"12345\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"[\\\"string1\\\",12345]\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif string(got) != string(tt.want) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %v, want %v\", string(got), string(tt.want))\n\t\t\t}\n\t\t})\n\t}\n}","05d5d41f64663ccd061a86a2c50439e7":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput  string\n\t\texpect string\n\t\ttail   string\n\t\terr    error\n\t}{\n\t\t// Basic cases\n\t\t{`\"hello\" world`, \"hello\", \" world\", nil},\n\t\t{`\"hello\"`, \"hello\", \"\", nil},\n\t\t{`\"\"`, \"\", \"\", nil},\n\n\t\t// Escaped quotes\n\t\t{`\"hello \\\"world\\\"\"`, `hello \"world\"`, \"\", nil},\n\t\t{`\"hello\\\\\"`, `hello\\`, \"\", nil},\n\t\t{`\"\\\\\"hello\"`, `\\\"hello`, \"\", nil},\n\t\t{`\"\\\\\\\\\"`, `\\\\`, \"\", nil},\n\n\t\t// Invalid cases\n\t\t{`\"hello`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"hello\"world`, `hello`, `world`, nil}, // No space after quote is valid\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i+1), func(t *testing.T) {\n\t\t\tresult, tail, err := parseRawString(tt.input)\n\n\t\t\tif result != tt.expect {\n\t\t\t\tt.Errorf(\"Test-%d: Expected result %q, got %q\", i+1, tt.expect, result)\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"Test-%d: Expected tail %q, got %q\", i+1, tt.tail, tail)\n\t\t\t}\n\t\t\tif err != nil \u0026\u0026 tt.err == nil {\n\t\t\t\tt.Errorf(\"Test-%d: Unexpected error: %v\", i+1, err)\n\t\t\t} else if err == nil \u0026\u0026 tt.err != nil {\n\t\t\t\tt.Errorf(\"Test-%d: Expected error %v, got nil\", i+1, tt.err)\n\t\t\t} else if err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error() {\n\t\t\t\tt.Errorf(\"Test-%d: Expected error %v, got %v\", i+1, tt.err, err)\n\t\t\t}\n\t\t})\n\t}\n}\n","05f386d6426b2ba51ab1618802020780":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic strings\n\t\t{\"hello\", \"hello\"},\n\t\t{\"world\", \"world\"},\n\t\t// Escaped characters\n\t\t{`\\\"hello\\\"`, `\"hello\"`},\n\t\t{`\\\\world\\\\`, `\\world\\`},\n\t\t{`\\n\\r\\t`, \"\\n\\r\\t\"},\n\t\t// Unicode escape sequences\n\t\t{`\\u0041\\u0062\\u0063`, \"ABC\"},\n\t\t{`\\u20AC`, \"‚Ç¨\"},\n\t\t// Surrogate pairs\n\t\t{`\\uD83D\\uDE02`, \"üòÇ\"},\n\t\t// Invalid escape sequences\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\u`, `\\u`},\n\t\t// Mixed strings\n\t\t{`hello\\t\"world\"`, \"hello\\t\\\"world\\\"\"},\n\t\t{`\\u0041\\u0062\\u0063\\n\\r\\t\\\\\\\"`, \"ABC\\n\\r\\t\\\\\\\"\"},\n\t}\n\tfor i, tt := range tests {\n\t\tactual := unescapeStringBestEffort(tt.input)\n\t\tif actual != tt.expected {\n\t\t\tt.Errorf(\"Test %d: Expected %q, got %q\", i, tt.expected, actual)\n\t\t}\n\t}\n}","07b09c2d02a2a43bf3bdfe6d215f6090":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestValue_Int(t *testing.T) {\n\ttests := []struct {\n\t\tinput  string\n\t\twant   int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tinput:  \"123\",\n\t\t\twant:   123,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tinput:  \"-123\",\n\t\t\twant:   -123,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tinput:  \"9223372036854775807\",\n\t\t\twant:   0,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tinput:  \"-9223372036854775808\",\n\t\t\twant:   0,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tinput:  \"1.23\",\n\t\t\twant:   0,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tinput:  `\"123\"`,\n\t\t\twant:   0,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tinput:  \"null\",\n\t\t\twant:   0,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tv := \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: tt.input,\n\t\t\t}\n\n\t\t\tgot, err := v.Int()\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Int() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Int() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","0939d19a198a44e82a69f74a6213352e":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey   string\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Basic cases\n\t\t{`\"foo\"bar`, \"foo\", \"bar\", nil},\n\t\t{`\"fo\\\"o\"bar`, \"fo\\\"o\", \"bar\", nil},\n\t\t{`\"foo\" bar`, \"foo\", \" bar\", nil},\n\t\t{`\"\"bar`, \"\", \"bar\", nil},\n\n\t\t// Escaped quotes\n\t\t{`\"foo\\\\\"bar`, `foo\\\\`, \"bar\", nil},\n\t\t{`\"foo\\\\\\\\\"bar`, \"foo\\\\\\\\\", \"bar\", nil},\n\t\t{`\"foo\\\\\\\"bar`, `foo\\\\\\\"bar`, \"\", nil},\n\t\t{`\"foo\\\\\\\"\"bar`, `foo\\\\\"`, \"bar\", nil},\n\n\t\t// Invalid cases\n\t\t{`\"foo`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`foo\"`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo\"bar\"`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t}\n\n\tfor i, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tkey, tail, err := parseRawString(test.input)\n\t\t\tif key != test.key {\n\t\t\t\tt.Errorf(\"Expected key %q, got %q\", test.key, key)\n\t\t\t}\n\t\t\tif tail != test.tail {\n\t\t\t\tt.Errorf(\"Expected tail %q, got %q\", test.tail, tail)\n\t\t\t}\n\t\t\tif (err != nil \u0026\u0026 test.err == nil) || (err == nil \u0026\u0026 test.err != nil) || (err != nil \u0026\u0026 test.err != nil \u0026\u0026 err.Error() != test.err.Error()) {\n\t\t\t\tt.Errorf(\"Expected error %v, got %v\", test.err, err)\n\t\t\t}\n\t\t})\n\t}\n}","09ab002c025559c976b4c2b3658e55f7":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t// Add test cases here\n\t\t{\n\t\t\tinput:    \"{\\\"key\\\": \\\"value\\\"}\",\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{t: TypeString, s: \"value\"}}}}},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"true\",\n\t\t\texpected: \u0026Value{t: TypeTrue},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"null\",\n\t\t\texpected: \u0026Value{t: TypeNull},\n\t\t\terr:      nil,\n\t\t},\n\t\t// Add more test cases\n\t}\n\n\tfor _, test := range tests {\n\t\tp := Parser{}\n\t\tactual, err := p.Parse(test.input)\n\n\t\tif test.err != nil {\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"Parse(%q) expected error, got nil\", test.input)\n\t\t\t} else if err.Error() != test.err.Error() {\n\t\t\t\tt.Errorf(\"Parse(%q) wrong error, expected %q, got %q\", test.input, test.err.Error(), err.Error())\n\t\t\t}\n\t\t} else {\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Parse(%q) unexpected error: %v\", test.input, err)\n\t\t\t} else if !compareValues(actual, test.expected) {\n\t\t\t\tt.Errorf(\"Parse(%q) expected %v, got %v\", test.input, test.expected, actual)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t} else if v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn compareObjects(\u0026v1.o, \u0026v2.o)\n\tcase TypeArray:\n\t\treturn compareArrays(v1.a, v2.a)\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\treturn true\n\t}\n}\n\nfunc compareObjects(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\n\tfor i := range o1.kvs {\n\t\tif o1.kvs[i].k != o2.kvs[i].k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(o1.kvs[i].v, o2.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\nfunc compareArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\n\tfor i := range a1 {\n\t\tif !compareValues(a1[i], a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n","0a78ec200670858320d02e398f83adb6":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Empty string\n\t\t{\"\", nil, \"\", fmt.Errorf(\"cannot parse empty string\")},\n\t\t// Invalid JSON\n\t\t{\"{\", nil, \"{\", fmt.Errorf(\"cannot parse object: missing '}'\")},\n\t\t// Simple object\n\t\t{`{\"foo\": \"bar\"}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: typeRawString, s: \"bar\"}}}}}}, \"\", nil},\n\t\t// Simple array\n\t\t{`[1, \"two\", true]`, \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: typeRawString, s: \"two\"}, {t: TypeTrue}}}, \"\", nil},\n\t\t// String with escaped characters\n\t\t{`\"hello\\nworld\"`, \u0026Value{t: typeRawString, s: \"hello\\nworld\"}, \"\", nil},\n\t\t// True boolean\n\t\t{\"true\", valueTrue, \"\", nil},\n\t\t// False boolean\n\t\t{\"false\", valueFalse, \"\", nil},\n\t\t// Null value\n\t\t{\"null\", valueNull, \"\", nil},\n\t\t// Number\n\t\t{\"12345\", \u0026Value{t: TypeNumber, s: \"12345\"}, \"\", nil},\n\t\t// NaN\n\t\t{\"NaN\", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"\", nil},\n\t\t// Trailing whitespace\n\t\t{`\"foo\" `, \u0026Value{t: typeRawString, s: \"foo\"}, \" \", nil},\n\t\t// Leading whitespace\n\t\t{` \"foo\"`, \u0026Value{t: typeRawString, s: \"foo\"}, \"\", nil},\n\t\t// Nested object\n\t\t{`{\"foo\": {\"bar\": 123}}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"bar\", v: \u0026Value{t: TypeNumber, s: \"123\"}}}}}}}}}}, \"\", nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, tail, err := parseValue(tt.input, c, 0)\n\t\t\tif fmt.Sprintf(\"%v\", err) != fmt.Sprintf(\"%v\", tt.err) {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, want %v\", tt.input, err, tt.err)\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"parseValue(%q) tail = %q, want %q\", tt.input, tail, tt.tail)\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", tt.input, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// Helper function to compare two *Value instances\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase typeRawString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k || !equalValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\treturn v1.t == v2.t\n\t}\n}\n","0ac5d665a06f3aea0c44fc787c1e6312":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantObj  string\n\t\twantRest string\n\t\twantErr  error\n\t}{\n\t\t{\n\t\t\tname:     \"empty object\",\n\t\t\tinput:    \"{}\",\n\t\t\twantObj:  `{\"t\":1}`,\n\t\t\twantRest: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t// Add more test cases here for various scenarios:\n\t\t// - Valid JSON objects with different key-value types\n\t\t// - Objects with nested objects and arrays\n\t\t// - Invalid JSON strings\n\t\t// - ...\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgotObj, gotRest, gotErr := parseObject(tt.input, c, 0)\n\n\t\t\t// Compare error\n\t\t\tif gotErr != nil {\n\t\t\t\tif tt.wantErr == nil || gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", gotErr, tt.wantErr)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else if tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", gotErr, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Compare object\n\t\t\tgotObjStr := fmt.Sprintf(\"%#v\", *gotObj)\n\t\t\tif gotObjStr != tt.wantObj {\n\t\t\t\tt.Errorf(\"parseObject() gotObj = %v, wantObj %v\", gotObjStr, tt.wantObj)\n\t\t\t}\n\n\t\t\t// Compare remaining string\n\t\t\tif gotRest != tt.wantRest {\n\t\t\t\tt.Errorf(\"parseObject() gotRest = %v, wantRest %v\", gotRest, tt.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}\n","0b937229edec31861deb151c4b2bde02":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput       string\n\t\twantValue   string\n\t\twantTail    string\n\t\twantErr     bool\n\t\twantErrText string\n\t}{\n\t\t// Empty array.\n\t\t{\n\t\t\tinput:       \"[]\",\n\t\t\twantValue:   \"[]\",\n\t\t\twantTail:    \"\",\n\t\t\twantErr:     false,\n\t\t\twantErrText: \"\",\n\t\t},\n\t\t// Simple array of numbers.\n\t\t{\n\t\t\tinput:       \"[1,2,3]\",\n\t\t\twantValue:   \"[1,2,3]\",\n\t\t\twantTail:    \"\",\n\t\t\twantErr:     false,\n\t\t\twantErrText: \"\",\n\t\t},\n\t\t// Array with nested arrays.\n\t\t{\n\t\t\tinput:       \"[1,[2,3],[4,5,6]]\",\n\t\t\twantValue:   \"[1,[2,3],[4,5,6]]\",\n\t\t\twantTail:    \"\",\n\t\t\twantErr:     false,\n\t\t\twantErrText: \"\",\n\t\t},\n\t\t// Array with various data types.\n\t\t{\n\t\t\tinput:       \"[1,true,\\\"hello\\\",{\\\"key\\\":\\\"value\\\"}]\",\n\t\t\twantValue:   \"[1,true,\\\"hello\\\",{\\\"key\\\":\\\"value\\\"}]\",\n\t\t\twantTail:    \"\",\n\t\t\twantErr:     false,\n\t\t\twantErrText: \"\",\n\t\t},\n\t\t// Trailing comma.\n\t\t{\n\t\t\tinput:       \"[1,]\",\n\t\t\twantValue:   \"\",\n\t\t\twantTail:    \"[1,]\",\n\t\t\twantErr:     true,\n\t\t\twantErrText: \"cannot parse array value: missing ']' after array value\",\n\t\t},\n\t\t// Missing closing bracket.\n\t\t{\n\t\t\tinput:       \"[1,2,3\",\n\t\t\twantValue:   \"\",\n\t\t\twantTail:    \"[1,2,3\",\n\t\t\twantErr:     true,\n\t\t\twantErrText: \"unexpected end of array\",\n\t\t},\n\t\t// Invalid value.\n\t\t{\n\t\t\tinput:       \"[1,2,invalid,3]\",\n\t\t\twantValue:   \"\",\n\t\t\twantTail:    \"[1,2,invalid,3]\",\n\t\t\twantErr:     true,\n\t\t\twantErrText: \"cannot parse array value: unknown char 'i' looking for beginning of value\",\n\t\t},\n\t\t// Whitespace handling.\n\t\t{\n\t\t\tinput:       \" [ 1 , 2 , 3 ] \",\n\t\t\twantValue:   \"[1,2,3]\",\n\t\t\twantTail:    \" \",\n\t\t\twantErr:     false,\n\t\t\twantErrText: \"\",\n\t\t},\n\t}\n\n\tfor i, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i+1), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgotValue, gotTail, gotErr := parseArray(test.input, c, 0)\n\n\t\t\tif test.wantErr {\n\t\t\t\tif gotErr == nil {\n\t\t\t\t\tt.Errorf(\"expected error, got nil\")\n\t\t\t\t} else if gotErr.Error() != test.wantErrText {\n\t\t\t\t\tt.Errorf(\"error text mismatch. \\nwant: %s\\ngot:  %s\", test.wantErrText, gotErr.Error())\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif gotErr != nil {\n\t\t\t\tt.Errorf(\"unexpected error: %v\", gotErr)\n\t\t\t}\n\n\t\t\tif gotValue.String() != test.wantValue {\n\t\t\t\tt.Errorf(\"value mismatch. \\nwant: %s\\ngot:  %s\", test.wantValue, gotValue.String())\n\t\t\t}\n\n\t\t\tif gotTail != test.wantTail {\n\t\t\t\tt.Errorf(\"tail mismatch. \\nwant: %s\\ngot:  %s\", test.wantTail, gotTail)\n\t\t\t}\n\t\t})\n\t}\n}\n","0caf733fa5305edee132705c431f4cb5":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestValue_Uint(t *testing.T) {\n\tt.Parallel()\n\ttests := []struct {\n\t\tname    string\n\t\ts       string\n\t\twant    uint\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"empty\",\n\t\t\ts:       \"\",\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"null\",\n\t\t\ts:       \"null\",\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"true\",\n\t\t\ts:       \"true\",\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"false\",\n\t\t\ts:       \"false\",\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"object\",\n\t\t\ts:       \"{}\",\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"array\",\n\t\t\ts:       \"[]\",\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"string\",\n\t\t\ts:       `\"foo\"`,\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"zero\",\n\t\t\ts:       \"0\",\n\t\t\twant:    0,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"one\",\n\t\t\ts:       \"1\",\n\t\t\twant:    1,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"maxUint\",\n\t\t\ts:       \"18446744073709551615\",\n\t\t\twant:    18446744073709551615,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"negativeOne\",\n\t\t\ts:       \"-1\",\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"float\",\n\t\t\ts:       \"1.23\",\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"tooLargeUint\",\n\t\t\ts:       \"18446744073709551616\",\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tvar p Parser\n\t\t\tv, err := p.Parse(tt.s)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Parse() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgot, err := v.Uint()\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Uint() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Uint() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","0cd53799171f8eab7a7786371d5f8f6a":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantN    string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Basic cases.\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"123.456\", \"123.456\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"+123\", \"+123\", \"\", nil},\n\t\t{\"1.2e3\", \"1.2e3\", \"\", nil},\n\t\t{\"1.2E-3\", \"1.2E-3\", \"\", nil},\n\n\t\t// Trailing garbage.\n\t\t{\"123x\", \"123\", \"x\", nil},\n\t\t{\"123.456x\", \"123.456\", \"x\", nil},\n\t\t{\"-123x\", \"-123\", \"x\", nil},\n\n\t\t// Leading garbage.\n\t\t{\"x123\", \"\", \"x123\", fmt.Errorf(\"unexpected char: %q\", \"x\")},\n\n\t\t// Invalid numbers.\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t\t{\"-\", \"\", \"-\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t\t{\"+\", \"\", \"+\", fmt.Errorf(\"unexpected char: %q\", \"+\")},\n\t\t{\".\", \"\", \".\", fmt.Errorf(\"unexpected char: %q\", \".\")},\n\t\t{\"e\", \"\", \"e\", fmt.Errorf(\"unexpected char: %q\", \"e\")},\n\n\t\t// Special cases: inf, nan\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"+inf\", \"+inf\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"InF\", \"InF\", \"\", nil},\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"+nan\", \"+nan\", \"\", nil},\n\t\t{\"-nan\", \"-nan\", \"\", nil},\n\t\t{\"123inf\", \"123\", \"inf\", nil},\n\t\t{\"-123inf\", \"-123\", \"inf\", nil},\n\n\t\t// Special cases: invalid inf, nan\n\t\t{\"in\", \"\", \"in\", fmt.Errorf(\"unexpected char: %q\", \"i\")},\n\t\t{\"na\", \"\", \"na\", fmt.Errorf(\"unexpected char: %q\", \"n\")},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d:%s\", i, tt.input), func(t *testing.T) {\n\t\t\tgotN, gotTail, gotErr := parseRawNumber(tt.input)\n\t\t\tif gotN != tt.wantN || gotTail != tt.wantTail || !equalError(gotErr, tt.wantErr) {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = (%q, %q, %v), want (%q, %q, %v)\", tt.input, gotN, gotTail, gotErr, tt.wantN, tt.wantTail, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// equalError reports whether errors a and b are considered equal.\n// They're equal if both are nil, or both are not nil and a.Error() == b.Error().\nfunc equalError(a, b error) bool {\n\treturn a == nil \u0026\u0026 b == nil || a != nil \u0026\u0026 b != nil \u0026\u0026 a.Error() == b.Error()\n}","0d8972029cfd570b7b6fadd35e2a9a42":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueType(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected Type\n\t}{\n\t\t{`null`, TypeNull},\n\t\t{`{}`, TypeObject},\n\t\t{`[]`, TypeArray},\n\t\t{`\"hello\"`, TypeString},\n\t\t{`123`, TypeNumber},\n\t\t{`true`, TypeTrue},\n\t\t{`false`, TypeFalse},\n\t\t{`\"raw string\"`, TypeString}, // Test for typeRawString conversion\n\t}\n\n\tfor _, test := range tests {\n\t\tv := ParseString(test.input)\n\t\tactual := v.Type()\n\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Input: %s, Expected Type: %v, Actual Type: %v\", test.input, test.expected, actual)\n\t\t}\n\t}\n}\n","0dd52c43968564e6763558b0b79bfa78":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantVal  *Value\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\twantVal:  nil,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t// Add more test cases here\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgotVal, gotTail, gotErr := parseValue(tt.input, c, 0)\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseValue() gotTail = %v, want %v\", gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif gotErr != nil \u0026\u0026 tt.wantErr == nil {\n\t\t\t\tt.Errorf(\"parseValue() got unexpected error: %v\", gotErr)\n\t\t\t}\n\t\t\tif gotErr == nil \u0026\u0026 tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"parseValue() expected error: %v\", tt.wantErr)\n\t\t\t}\n\t\t\t// Compare the values based on the expected type\n\t\t\tif tt.wantVal != nil {\n\t\t\t\tcompareValues(t, gotVal, tt.wantVal)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(t *testing.T, got, want *Value) {\n\tif got.t != want.t {\n\t\tt.Errorf(\"parseValue() got value type = %v, want %v\", got.t, want.t)\n\t\treturn\n\t}\n\tswitch want.t {\n\tcase TypeString:\n\t\tif got.s != want.s {\n\t\t\tt.Errorf(\"parseValue() got string value = %v, want %v\", got.s, want.s)\n\t\t}\n\tcase TypeNumber:\n\t\tif got.s != want.s {\n\t\t\tt.Errorf(\"parseValue() got number value = %v, want %v\", got.s, want.s)\n\t\t}\n\tcase TypeObject:\n\t\t// Compare objects\n\tcase TypeArray:\n\t\t// Compare arrays\n\tcase TypeTrue, TypeFalse, TypeNull:\n\t\t// No values to compare for these types\n\t}\n}","0e137cd85ee0d22389c92c89df6ce95f":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantObj  string\n\t\twantTail string\n\t\twantErr  string\n\t}{\n\t\t{\n\t\t\tname:     \"EmptyObject\",\n\t\t\tinput:    \"{}\",\n\t\t\twantObj:  `{\"t\":1}`,\n\t\t\twantTail: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"SimpleObject\",\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\twantObj:  `{\"t\":1,\"o\":{\"kvs\":[{\"k\":\"key\",\"v\":{\"t\":3,\"s\":\"value\"}}]}}`,\n\t\t\twantTail: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"ComplexObject\",\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 123, \"key3\": true, \"key4\": null, \"key5\": [1, 2, 3], \"key6\": {\"subkey\": \"subvalue\"}}`,\n\t\t\twantObj:  `{\"t\":1,\"o\":{\"kvs\":[{\"k\":\"key1\",\"v\":{\"t\":3,\"s\":\"value1\"}},{\"k\":\"key2\",\"v\":{\"t\":4,\"s\":\"123\"}},{\"k\":\"key3\",\"v\":{\"t\":5}},{\"k\":\"key4\",\"v\":{\"t\":0}},{\"k\":\"key5\",\"v\":{\"t\":2,\"a\":[{\"t\":4,\"s\":\"1\"},{\"t\":4,\"s\":\"2\"},{\"t\":4,\"s\":\"3\"}]}},{\"k\":\"key6\",\"v\":{\"t\":1,\"o\":{\"kvs\":[{\"k\":\"subkey\",\"v\":{\"t\":3,\"s\":\"subvalue\"}}]}}}]}}`,\n\t\t\twantTail: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"MissingQuote\",\n\t\t\tinput:    `{key: \"value\"}`,\n\t\t\twantObj:  \"\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  \"cannot find opening '\\\"' for object key\",\n\t\t},\n\t\t{\n\t\t\tname:     \"MissingColon\",\n\t\t\tinput:    `{\"key\" \"value\"}`,\n\t\t\twantObj:  \"\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  \"missing ':' after object key\",\n\t\t},\n\t\t{\n\t\t\tname:     \"MissingComma\",\n\t\t\tinput:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantObj:  \"\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  \"missing ',' after object value\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TrailingComma\",\n\t\t\tinput:    `{\"key\": \"value\",}`,\n\t\t\twantObj:  \"\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  \"unexpected end of object\",\n\t\t},\n\t\t{\n\t\t\tname:     \"InvalidValue\",\n\t\t\tinput:    `{\"key\": invalid}`,\n\t\t\twantObj:  \"\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  \"cannot parse object value: invalid character 'i' looking for beginning of value\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgotObj, gotTail, err := parseObject(tt.input, c, 0)\n\n\t\t\tif tt.wantErr != \"\" {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"Expected error, but got nil\")\n\t\t\t\t} else if err.Error() != tt.wantErr {\n\t\t\t\t\tt.Errorf(\"Error mismatch. Expected: %s, Got: %s\", tt.wantErr, err.Error())\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t\t}\n\n\t\t\tgotObjStr := fmt.Sprintf(\"%#v\", gotObj)\n\t\t\tif gotObjStr != tt.wantObj {\n\t\t\t\tt.Errorf(\"Object mismatch. Expected: %s, Got: %s\", tt.wantObj, gotObjStr)\n\t\t\t}\n\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"Tail mismatch. Expected: %s, Got: %s\", tt.wantTail, gotTail)\n\t\t\t}\n\t\t})\n\t}\n}","0e2fc36867a75303a40fd010715ca652":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\t// Add your test cases for the Parse function here.\n\t//\n\t// Example test case:\n\t//\n\t//     p := \u0026Parser{}\n\t//     v, err := p.Parse(`{\"foo\": \"bar\"}`)\n\t//     if err != nil {\n\t//         t.Errorf(\"Parse() error = %v\", err)\n\t//         return\n\t//     }\n\t//     // Add assertions to check the value of v here.\n}\n","0e9eb289cd868b9e3366eb39a10000e2":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ts     string\n\t\terr   error\n\t}{\n\t\t// Empty array\n\t\t{\n\t\t\tinput: \"[]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Simple array\n\t\t{\n\t\t\tinput: \"[1,2,3]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Array with different types\n\t\t{\n\t\t\tinput: `[1,\"test\",true,null]`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeString, s: \"test\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t\t{t: TypeNull},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Array with nested array\n\t\t{\n\t\t\tinput: \"[1,[2,3],4]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeArray, a: []*Value{\n\t\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t\t}},\n\t\t\t\t\t{t: TypeNumber, s: \"4\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Array with whitespace\n\t\t{\n\t\t\tinput: \" [ 1 , 2 , 3 ] \",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Invalid array - missing closing bracket\n\t\t{\n\t\t\tinput: \"[1,2,3\",\n\t\t\twant:  nil,\n\t\t\ts:     \"[1,2,3\",\n\t\t\terr:   fmt.Errorf(\"missing ']'\"),\n\t\t},\n\t\t// Invalid array - missing comma\n\t\t{\n\t\t\tinput: \"[1,2 3]\",\n\t\t\twant:  nil,\n\t\t\ts:     \" 3]\",\n\t\t\terr:   fmt.Errorf(\"missing ',' after array value\"),\n\t\t},\n\t}\n\n\tfor i, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseArray(test.input, c, 0)\n\n\t\t\tif (err != nil \u0026\u0026 test.err == nil) || (err == nil \u0026\u0026 test.err != nil) || (err != nil \u0026\u0026 test.err != nil \u0026\u0026 err.Error() != test.err.Error()) {\n\t\t\t\tt.Errorf(\"Test %d failed: Expected error '%v', got '%v'\", i, test.err, err)\n\t\t\t}\n\n\t\t\tif s != test.s {\n\t\t\t\tt.Errorf(\"Test %d failed: Expected remaining string '%s', got '%s'\", i, test.s, s)\n\t\t\t}\n\n\t\t\tif !equalValues(got, test.want) {\n\t\t\t\tt.Errorf(\"Test %d failed: Expected value '%+v', got '%+v'\", i, test.want, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// Helper function to compare two *Value\nfunc equalValues(v1 *Value, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.s != v2.s {\n\t\treturn false\n\t}\n\tif len(v1.a) != len(v2.a) {\n\t\treturn false\n\t}\n\tfor i := range v1.a {\n\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n","0f26a105e8a6525daf65d26615bb027c":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic strings\n\t\t{\"hello\", \"hello\"},\n\t\t{\"world\", \"world\"},\n\n\t\t// Escaped characters\n\t\t{`\\\"hello\\\"`, `\"hello\"`},\n\t\t{`\\\\world\\\\`, `\\world\\`},\n\t\t{`\\b\\f\\n\\r\\t`, \"\\b\\f\\n\\r\\t\"},\n\n\t\t// Unicode escape sequences\n\t\t{`\\u0041`, \"A\"},\n\t\t{`\\u00e9`, \"√©\"},\n\t\t{`\\u20ac`, \"‚Ç¨\"},\n\n\t\t// Surrogate pairs\n\t\t{`\\uD83D\\uDE02`, \"üòÇ\"},\n\n\t\t// Invalid escape sequences\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\uD800`, `\\uD800`},\n\t\t{`\\uD800\\u`, `\\uD800\\u`},\n\t\t{`\\uD800\\uD800`, `\\uD800\\uD800`},\n\n\t\t// Mixed strings\n\t\t{`hello\\tworld`, \"hello\\tworld\"},\n\t\t{`\\u0041\\u0020\\u0026\\u0020\\u0042`, \"A \u0026 B\"},\n\t}\n\n\tfor i, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Test %d failed: expected '%s', got '%s'\", i+1, test.expected, actual)\n\t\t}\n\t}\n}\n","0f616e71d39628a3904565c42de8b8bc":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCache_getValue(t *testing.T) {\n\tt.Run(\"empty cache\", func(t *testing.T) {\n\t\tc := \u0026cache{}\n\t\tval := c.getValue()\n\n\t\tif val == nil {\n\t\t\tt.Fatal(\"Expected value pointer, got nil\")\n\t\t}\n\t\tif len(c.vs) != 1 {\n\t\t\tt.Errorf(\"Expected cache length 1, got %d\", len(c.vs))\n\t\t}\n\t})\n\n\tt.Run(\"cache with capacity\", func(t *testing.T) {\n\t\tc := \u0026cache{vs: make([]Value, 0, 2)}\n\t\tval1 := c.getValue()\n\t\tval2 := c.getValue()\n\n\t\tif val1 == nil || val2 == nil {\n\t\t\tt.Fatal(\"Expected value pointers, got nil\")\n\t\t}\n\t\tif len(c.vs) != 2 {\n\t\t\tt.Errorf(\"Expected cache length 2, got %d\", len(c.vs))\n\t\t}\n\t\tif cap(c.vs) != 2 {\n\t\t\tt.Errorf(\"Expected cache capacity 2, got %d\", cap(c.vs))\n\t\t}\n\t})\n\n\tt.Run(\"cache exceeding capacity\", func(t *testing.T) {\n\t\tc := \u0026cache{vs: make([]Value, 0, 2)}\n\t\t_ = c.getValue()\n\t\t_ = c.getValue()\n\t\tval3 := c.getValue()\n\n\t\tif val3 == nil {\n\t\t\tt.Fatal(\"Expected value pointer, got nil\")\n\t\t}\n\t\tif len(c.vs) != 3 {\n\t\t\tt.Errorf(\"Expected cache length 3, got %d\", len(c.vs))\n\t\t}\n\t\tif cap(c.vs) \u003c= 3 {\n\t\t\tt.Errorf(\"Expected cache capacity greater than 3, got %d\", cap(c.vs))\n\t\t}\n\t})\n}","102240021d6c63d042cc29f0cf5c3c80":"package fastjson\n\nimport \"testing\"\n\nfunc TestObject_getKV(t *testing.T) {\n\to := Object{}\n\t// Test adding a kv when the capacity is less than the length\n\tkv1 := o.getKV()\n\tkv1.k = \"key1\"\n\tkv1.v = \u0026Value{t: TypeString, s: \"value1\"}\n\twantKV1 := \u0026kv{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}}\n\tif kv1.k != wantKV1.k || kv1.v.s != wantKV1.v.s {\n\t\tt.Errorf(\"Got kv1 = %+v, want %+v\", *kv1, *wantKV1)\n\t}\n\n\t// Test adding a kv when the capacity is equal to the length\n\tkv2 := o.getKV()\n\tkv2.k = \"key2\"\n\tkv2.v = \u0026Value{t: TypeNumber, s: \"123\"}\n\twantKV2 := \u0026kv{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}}\n\tif kv2.k != wantKV2.k || kv2.v.s != wantKV2.v.s {\n\t\tt.Errorf(\"Got kv2 = %+v, want %+v\", *kv2, *wantKV2)\n\t}\n\n\t// Check the length of the kvs slice\n\twantLen := 2\n\tif len(o.kvs) != wantLen {\n\t\tt.Errorf(\"Got kvs length = %d, want %d\", len(o.kvs), wantLen)\n\t}\n}\n","10bbc6828a6fc03332fc16f5cfb25807":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantNum  string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Valid numbers\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"123.456\", \"123.456\", \"\", nil},\n\t\t{\"1.2e3\", \"1.2e3\", \"\", nil},\n\t\t{\"1.2E-3\", \"1.2E-3\", \"\", nil},\n\t\t{\"+123\", \"+123\", \"\", nil},\n\n\t\t// Valid numbers with trailing characters\n\t\t{\"123a\", \"123\", \"a\", nil},\n\t\t{\"-123!\", \"-123\", \"!\", nil},\n\t\t{\"123.456,\", \"123.456\", \",\", nil},\n\n\t\t// Invalid numbers\n\t\t{\"a123\", \"\", \"a123\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\"+a123\", \"\", \"+a123\", fmt.Errorf(\"unexpected char: %q\", \"+\")},\n\n\t\t// Special cases - INF/NAN\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"InF\", \"InF\", \"\", nil},\n\t\t{\"+inf\", \"+inf\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"NaN\", \"NaN\", \"\", nil},\n\n\t\t// Special cases - INF/NAN with trailing characters\n\t\t{\"inf,\", \"inf\", \",\", nil},\n\t\t{\"NaN}\", \"NaN\", \"}\", nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test #%d\", i+1), func(t *testing.T) {\n\t\t\tgotNum, gotTail, gotErr := parseRawNumber(tt.input)\n\n\t\t\tif gotNum != tt.wantNum {\n\t\t\t\tt.Errorf(\"Num mismatch: got %q, want %q\", gotNum, tt.wantNum)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"Tail mismatch: got %q, want %q\", gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif gotErr != nil \u0026\u0026 tt.wantErr == nil {\n\t\t\t\tt.Errorf(\"Unexpected error: %v\", gotErr)\n\t\t\t} else if gotErr == nil \u0026\u0026 tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"Error mismatch: got nil, want %v\", tt.wantErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"Error mismatch: got %v, want %v\", gotErr, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","127578a71a6a36cc5701f713d549647a":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantObj  string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Empty object.\n\t\t{\n\t\t\tinput:    \"{}\",\n\t\t\twantObj:  `{}`,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t// Simple object.\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 123}`,\n\t\t\twantObj:  `{\"key1\": \"value1\", \"key2\": 123}`,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t// Whitespace handling.\n\t\t{\n\t\t\tinput:    \" { \\\"key1\\\" : \\\"value1\\\" , \\\"key2\\\" : 123 } \",\n\t\t\twantObj:  `{\"key1\": \"value1\", \"key2\": 123}`,\n\t\t\twantTail: \" \",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t// Escaped characters in keys.\n\t\t{\n\t\t\tinput:    `{\"key\\t1\": \"value1\", \"key2\": 123}`,\n\t\t\twantObj:  `{\"key\\t1\": \"value1\", \"key2\": 123}`,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t// Nested object.\n\t\t{\n\t\t\tinput: `{\"key1\": {\"nestedKey\": \"nestedValue\"}, \"key2\": 123}`,\n\t\t\twantObj: `{\"key1\": {\"nestedKey\": \"nestedValue\"}, \"key2\": 123}`,\n\t\t\twantTail: \"\",\n\t\t\twantErr: nil,\n\t\t},\n\t\t// Missing closing brace.\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\"`,\n\t\t\twantObj:  \"\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t\t// Missing colon.\n\t\t{\n\t\t\tinput:    `{\"key1\" \"value1\"}`,\n\t\t\twantObj:  \"\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t\t// Invalid value.\n\t\t{\n\t\t\tinput:    `{\"key1\": invalid}`,\n\t\t\twantObj:  \"\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  fmt.Errorf(\"cannot parse object value: %s\", \"invalid character 'i' looking for beginning of value\"),\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgotObj, gotTail, gotErr := parseObject(tt.input, c, 0)\n\n\t\t\tif gotErr != nil {\n\t\t\t\tif tt.wantErr == nil {\n\t\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", gotErr, tt.wantErr)\n\t\t\t\t} else if gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", gotErr, tt.wantErr)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", gotErr, tt.wantErr)\n\t\t\t}\n\t\t\tif gotObj.String() != tt.wantObj {\n\t\t\t\tt.Errorf(\"parseObject() gotObj = %s, want %s\", gotObj, tt.wantObj)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseObject() gotTail = %s, want %s\", gotTail, tt.wantTail)\n\t\t\t}\n\t\t})\n\t}\n}\n","131c5e909188ccddbdbc641839726007":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput       string\n\t\texpected    *Value\n\t\texpectedStr string\n\t\texpectErr   bool\n\t}{\n\t\t// Empty array.\n\t\t{\n\t\t\tinput:       \"[]\",\n\t\t\texpected:    \u0026Value{t: TypeArray},\n\t\t\texpectedStr: \"\",\n\t\t\texpectErr:   false,\n\t\t},\n\t\t// Simple array of numbers.\n\t\t{\n\t\t\tinput: \"[1,2,3]\",\n\t\t\texpected: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedStr: \"\",\n\t\t\texpectErr:   false,\n\t\t},\n\t\t// Array with whitespace.\n\t\t{\n\t\t\tinput: \" [ 1 , 2 , 3 ] \",\n\t\t\texpected: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedStr: \" \",\n\t\t\texpectErr:   false,\n\t\t},\n\t\t// Nested arrays.\n\t\t{\n\t\t\tinput: \"[[1,2], [3,4]]\",\n\t\t\texpected: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t\t\t\t{t: TypeNumber, s: \"4\"},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedStr: \"\",\n\t\t\texpectErr:   false,\n\t\t},\n\t\t// Array with different value types.\n\t\t{\n\t\t\tinput: `[1, \"hello\", true, null]`,\n\t\t\texpected: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeString, s: \"hello\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t\t{t: TypeNull},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedStr: \"\",\n\t\t\texpectErr:   false,\n\t\t},\n\t\t// Invalid array - missing closing bracket.\n\t\t{\n\t\t\tinput:       \"[1, 2, 3\",\n\t\t\texpected:    nil,\n\t\t\texpectedStr: \"[1, 2, 3\",\n\t\t\texpectErr:   true,\n\t\t},\n\t\t// Invalid array - missing comma.\n\t\t{\n\t\t\tinput:       \"[1, 2 3]\",\n\t\t\texpected:    nil,\n\t\t\texpectedStr: \"[1, 2 3]\",\n\t\t\texpectErr:   true,\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tactual, str, err := parseArray(tt.input, c, 0)\n\n\t\t\tif tt.expectErr \u0026\u0026 err == nil {\n\t\t\t\tt.Errorf(\"Expected error for input '%s' but got nil\", tt.input)\n\t\t\t} else if !tt.expectErr \u0026\u0026 err != nil {\n\t\t\t\tt.Errorf(\"Unexpected error for input '%s': %v\", tt.input, err)\n\t\t\t}\n\n\t\t\tif actual != nil \u0026\u0026 tt.expected != nil \u0026\u0026 actual.Type() != tt.expected.Type() {\n\t\t\t\tt.Errorf(\"Type mismatch for input '%s'. Expected %v, but got %v\", tt.input, tt.expected.Type(), actual.Type())\n\t\t\t}\n\n\t\t\tif str != tt.expectedStr {\n\t\t\t\tt.Errorf(\"Expected remaining string '%s', but got '%s'\", tt.expectedStr, str)\n\t\t\t}\n\t\t})\n\t}\n}","13ac2e84e94bb35e0a1906d0f00aa5aa":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc Test_unescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"basic escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"\\\\/\\\\\\\\\\\\b\\\\f\\\\n\\\\r\\\\t\"},\n\t\t\twant: \"\\\\\\\"\\\\/\\\\\\\\\\\\b\\\\f\\\\n\\\\r\\\\t\",\n\t\t},\n\t\t{\n\t\t\tname: \"unicode escape sequences\",\n\t\t\targs: args{s: \"\\\\u0020\\\\u00A0\\\\u20AC\"},\n\t\t\twant: \" \\u00A0‚Ç¨\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid unicode escape sequences\",\n\t\t\targs: args{s: \"\\\\u002\\\\u00A\"},\n\t\t\twant: \"\\\\u002\\\\u00A\",\n\t\t},\n\t\t{\n\t\t\tname: \"surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\"},\n\t\t\twant: \"\\\\uD83D\",\n\t\t},\n\t\t{\n\t\t\tname: \"mixed escape sequences\",\n\t\t\targs: args{s: \"hello\\\\tworld\\\\n\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"hello\\tworld\\nüòÅ\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","148ad80a180eea71a492d6b0b24097d2":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetStringBytes(t *testing.T) {\n\tt.Parallel()\n\tvar str []byte\n\ttests := []struct {\n\t\tname  string\n\t\tjson  string\n\t\tkeys  []string\n\t\twant  []byte\n\t\twant1 bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tjson:  `{}`,\n\t\t\tkeys:  []string{\"foo\"},\n\t\t\twant:  nil,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"empty array\",\n\t\t\tjson:  `[]`,\n\t\t\tkeys:  []string{\"0\"},\n\t\t\twant:  nil,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"simple object\",\n\t\t\tjson:  `{\"foo\": \"bar\"}`,\n\t\t\tkeys:  []string{\"foo\"},\n\t\t\twant:  []byte(\"bar\"),\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"nested object\",\n\t\t\tjson:  `{\"foo\": {\"bar\": \"baz\"}}`,\n\t\t\tkeys:  []string{\"foo\", \"bar\"},\n\t\t\twant:  []byte(\"baz\"),\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array index\",\n\t\t\tjson:  `[\"foo\", \"bar\"]`,\n\t\t\tkeys:  []string{\"1\"},\n\t\t\twant:  []byte(\"bar\"),\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array index not exist\",\n\t\t\tjson:  `[\"foo\", \"bar\"]`,\n\t\t\tkeys:  []string{\"3\"},\n\t\t\twant:  str,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"nested array\",\n\t\t\tjson:  `{\"foo\": [\"bar\", \"baz\"]}`,\n\t\t\tkeys:  []string{\"foo\", \"1\"},\n\t\t\twant:  []byte(\"baz\"),\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array decimal index\",\n\t\t\tjson:  `[\"foo\", \"bar\"]`,\n\t\t\tkeys:  []string{\"1.0\"},\n\t\t\twant:  []byte(\"bar\"),\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"non-existing key\",\n\t\t\tjson:  `{\"foo\": \"bar\"}`,\n\t\t\tkeys:  []string{\"baz\"},\n\t\t\twant:  nil,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"null value\",\n\t\t\tjson:  `{\"foo\": null}`,\n\t\t\tkeys:  []string{\"foo\"},\n\t\t\twant:  nil,\n\t\t\twant1: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv, err := Parse(tt.json)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Parse() error = %v, wantErr %v\", err, nil)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgot := v.GetStringBytes(tt.keys...)\n\t\t\tif !bytesEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"GetStringBytes() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc bytesEqual(a, b []byte) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i, v := range a {\n\t\tif v != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","1490d6cb217dd451490dc28ee87e21f0":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantNum  string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Basic cases\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"123.456\", \"123.456\", \"\", nil},\n\t\t{\"1.2e3\", \"1.2e3\", \"\", nil},\n\t\t{\"1.2E+3\", \"1.2E+3\", \"\", nil},\n\n\t\t// Trailing characters\n\t\t{\"123a\", \"123\", \"a\", nil},\n\t\t{\"123.456xyz\", \"123.456\", \"xyz\", nil},\n\t\t{\"-123 \", \"-123\", \" \", nil},\n\n\t\t// Invalid numbers\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t\t{\"+\", \"\", \"+\", fmt.Errorf(\"unexpected char: %q\", \"+\")},\n\t\t(\"-\", \"\", \"-\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t\t(\"a123\", \"\", \"a123\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t(\".123\", \"\", \".123\", fmt.Errorf(\"unexpected char: %q\", \".\")),\n\n\t\t// Special values (inf, nan)\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"+inf\", \"+inf\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"InF\", \"InF\", \"\", nil}, // Case insensitive\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"+nan\", \"+nan\", \"\", nil},\n\t\t{\"-nan\", \"-nan\", \"\", nil},\n\t\t{\"nAn\", \"nAn\", \"\", nil}, // Case insensitive\n\n\t\t// Special values with trailing characters\n\t\t{\"infx\", \"inf\", \"x\", nil},\n\t\t{\"nan,\", \"nan\", \",\", nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d-%s\", i, tt.input), func(t *testing.T) {\n\t\t\tgotNum, gotTail, gotErr := parseRawNumber(tt.input)\n\n\t\t\tif gotNum != tt.wantNum {\n\t\t\t\tt.Errorf(\"Num mismatch. Want: %q, Got: %q\", tt.wantNum, gotNum)\n\t\t\t}\n\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"Tail mismatch. Want: %q, Got: %q\", tt.wantTail, gotTail)\n\t\t\t}\n\n\t\t\tif (gotErr != nil \u0026\u0026 tt.wantErr == nil) ||\n\t\t\t\t(gotErr == nil \u0026\u0026 tt.wantErr != nil) ||\n\t\t\t\t(gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error()) {\n\t\t\t\tt.Errorf(\"Error mismatch. Want: %v, Got: %v\", tt.wantErr, gotErr)\n\t\t\t}\n\t\t})\n\t}\n}","14c58917c9d82fa6db5387dd24350ac4":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Empty string.\n\t\t{\"\", nil, \"\", fmt.Errorf(\"cannot parse empty string\")},\n\n\t\t// Invalid JSON.\n\t\t{\"{invalid}\", nil, \"\", fmt.Errorf(\"cannot parse object: invalid character 'i' looking for beginning of value\")},\n\n\t\t// Too deep nesting.\n\t\t{`{\"a\": {\"b\": {\"c\": {\"d\": {\"e\": {\"f\": {\"g\": {\"h\": {\"i\": {\"j\": {\"k\": {\"l\": {\"m\": {\"n\": {\"o\": {\"p\": {\"q\": {\"r\": {\"s\": {\"t\": {\"u\": {\"v\": {\"w\": {\"x\": {\"y\": {\"z\": {}}}}}}}}}}}}}}}}}}}}}}}}}}}}`, nil, \"\", fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth)},\n\n\t\t// Object.\n\t\t{`{\"foo\": \"bar\"}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: typeRawString, s: \"bar\"}}}}}}, \"\", nil},\n\n\t\t// Array.\n\t\t{`[1, \"foo\", true]`, \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: typeRawString, s: \"foo\"}, {t: TypeTrue}}}, \"\", nil},\n\n\t\t// String.\n\t\t{`\"foo\"`, \u0026Value{t: typeRawString, s: \"foo\"}, \"\", nil},\n\n\t\t// True.\n\t\t{\"true\", valueTrue, \"\", nil},\n\n\t\t// False.\n\t\t{\"false\", valueFalse, \"\", nil},\n\n\t\t// Null.\n\t\t{\"null\", valueNull, \"\", nil},\n\n\t\t// Number.\n\t\t{\"123\", \u0026Value{t: TypeNumber, s: \"123\"}, \"\", nil},\n\t\t{\"-123.456\", \u0026Value{t: TypeNumber, s: \"-123.456\"}, \"\", nil},\n\n\t\t// Trailing whitespace.\n\t\t{`\"foo\" `, \u0026Value{t: typeRawString, s: \"foo\"}, \" \", nil},\n\t}\n\n\tc := \u0026cache{}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test%d\", i+1), func(t *testing.T) {\n\t\t\tgot, tail, err := parseValue(tt.input, c, 0)\n\t\t\tif (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, want %v\", tt.input, err, tt.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", tt.input, got, tt.want)\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"parseValue(%q) tail = %q, want %q\", tt.input, tail, tt.tail)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.t == typeRawString \u0026\u0026 v1.s != v2.s {\n\t\treturn false\n\t}\n\tif v1.t == TypeNumber \u0026\u0026 v1.s != v2.s {\n\t\treturn false\n\t}\n\tif v1.t == TypeObject \u0026\u0026 !equalObjects(\u0026v1.o, \u0026v2.o) {\n\t\treturn false\n\t}\n\tif v1.t == TypeArray \u0026\u0026 !equalArrays(v1.a, v2.a) {\n\t\treturn false\n\t}\n\treturn true\n}\n\nfunc equalObjects(o1, o2 *Object) bool {\n\tif o1.Len() != o2.Len() {\n\t\treturn false\n\t}\n\tfor i := 0; i \u003c o1.Len(); i++ {\n\t\tkv1 := o1.kvs[i]\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !equalValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc equalArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i := 0; i \u003c len(a1); i++ {\n\t\tif !equalValues(a1[i], a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","14fbe10b0680f4221116e7b1870b9a89":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twant     *Value\n\t\twantRest string\n\t\twantErr  error\n\t}{\n\t\t{\n\t\t\tname:     \"empty array\",\n\t\t\tinput:    \"[]\",\n\t\t\twant:     \u0026Value{t: TypeArray},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"simple array\",\n\t\t\tinput:    \"[1,2,3]\",\n\t\t\twant:     \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"nested array\",\n\t\t\tinput:    \"[[1,2],[3,4]]\",\n\t\t\twant: \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}}},\n\t\t\t\t{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"3\"}, {t: TypeNumber, s: \"4\"}}},\n\t\t\t}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with different types\",\n\t\t\tinput:    \"[1,\\\"hello\\\",true]\",\n\t\t\twant: \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t{t: TypeString, s: \"hello\"},\n\t\t\t\t{t: TypeTrue},\n\t\t\t}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with whitespace\",\n\t\t\tinput:    \" [ 1 , 2 , 3 ] \",\n\t\t\twant:     \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}},\n\t\t\twantRest: \" \",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid array: missing closing bracket\",\n\t\t\tinput:    \"[1,2,3\",\n\t\t\twant:     nil,\n\t\t\twantRest: \"\",\n\t\t\twantErr:  fmt.Errorf(\"missing ']'\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid array: missing comma\",\n\t\t\tinput:    \"[1 2 3]\",\n\t\t\twant:     nil,\n\t\t\twantRest: \"\",\n\t\t\twantErr:  fmt.Errorf(\"missing ',' after array value\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, rest, err := parseArray(tt.input, c, 0)\n\t\t\tif fmt.Sprintf(\"%v\", err) != fmt.Sprintf(\"%v\", tt.wantErr) {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != nil \u0026\u0026 tt.want != nil \u0026\u0026 got.t != tt.want.t {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got != nil \u0026\u0026 tt.want != nil \u0026\u0026 !compareValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif rest != tt.wantRest {\n\t\t\t\tt.Errorf(\"parseArray() rest = %v, wantRest %v\", rest, tt.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := 0; i \u003c len(v1.a); i++ {\n\t\t\tif !compareValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeString, TypeNumber:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\treturn true\n\t}\n}","15857d05467c9fab2c5649930ceed954":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"  \\n\\t  foo\", \"foo\"},\n\t\t{\" \\n\\t  foo bar\", \"foo bar\"},\n\t\t{\"foo  \\n\\t  \", \"foo  \\n\\t  \"},\n\t\t{\"\\n\\tfoo\", \"foo\"},\n\t\t{\"\\r\\nfoo\", \"foo\"},\n\t\t{\"foo\", \"foo\"},\n\t\t{\"\", \"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := skipWSSlow(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"skipWSSlow(%q) = %q, want %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}","15a1bd9c4cb7d2c8250487d176211055":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic strings with no escape sequences.\n\t\t{\"hello\", \"hello\"},\n\t\t{\"world\", \"world\"},\n\n\t\t// Strings with simple escape sequences.\n\t\t{`\\\"hello\\\"`, `\"hello\"`},\n\t\t{`\\\\world\\\\`, `\\world\\`},\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\t`, \"\\t\"},\n\t\t{`\\r`, \"\\r\"},\n\t\t{`\\b`, \"\\b\"},\n\t\t{`\\f`, \"\\f\"},\n\t\t{`\\/`, \"/\"},\n\n\t\t// Unicode escape sequences.\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A9`, \"¬©\"},\n\t\t{`\\u20AC`, \"‚Ç¨\"},\n\n\t\t// Handling of invalid or incomplete escape sequences.\n\t\t{`\\u002`, `\\u002`},   // Invalid - too short.\n\t\t{`\\u002G`, `\\u002G`},  // Invalid - non-hex character.\n\t\t{`\\x0020`, `\\x0020`},  // Invalid - not \\u.\n\t\t{`\\\\`, `\\`},            // Single backslash.\n\t\t{`\\\\\\`, `\\\\`},           // Backslash followed by escaped backslash.\n\n\t\t// Surrogate pairs\n\t\t{`\\uD83D\\uDE02`, \"üòÇ\"},\n\t\t{`\\uD83D\\uDE0`, `\\uD83D\\uDE0`},  // Invalid - incomplete surrogate pair.\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.input, func(t *testing.T) {\n\t\t\tactual := unescapeStringBestEffort(test.input)\n\t\t\tif actual != test.expected {\n\t\t\t\tt.Errorf(\"For input %q, expected %q but got %q\", test.input, test.expected, actual)\n\t\t\t}\n\t\t})\n\t}\n}\n","15d7ed731d71f30fb541c89324e4ba82":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\t// Test cases for different JSON values\n\ttestCases := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\ttail     string\n\t\terr      error\n\t}{\n\t\t// Empty string\n\t\t{\"\", nil, \"\", fmt.Errorf(\"cannot parse empty string\")},\n\n\t\t// Null value\n\t\t{\"null\", valueNull, \"\", nil},\n\t\t{\"   null\", valueNull, \"   \", nil},\n\t\t{\"null   \", valueNull, \"   \", nil},\n\t\t{\"  null  \", valueNull, \"  \", nil},\n\n\t\t// True value\n\t\t{\"true\", valueTrue, \"\", nil},\n\t\t{\"   true\", valueTrue, \"   \", nil},\n\t\t{\"true   \", valueTrue, \"   \", nil},\n\t\t{\"  true  \", valueTrue, \"  \", nil},\n\n\t\t// False value\n\t\t{\"false\", valueFalse, \"\", nil},\n\t\t{\"   false\", valueFalse, \"   \", nil},\n\t\t{\"false   \", valueFalse, \"   \", nil},\n\t\t{\"  false  \", valueFalse, \"  \", nil},\n\n\t\t// String value\n\t\t{`\"hello\"`, \u0026Value{t: typeRawString, s: \"hello\"}, \"\", nil},\n\t\t{`  \"hello\"`, \u0026Value{t: typeRawString, s: \"hello\"}, \"  \", nil},\n\t\t{`\"hello\"  `, \u0026Value{t: typeRawString, s: \"hello\"}, \"  \", nil},\n\t\t{`  \"hello\"  `, \u0026Value{t: typeRawString, s: \"hello\"}, \"  \", nil},\n\n\t\t// Number value\n\t\t{\"123\", \u0026Value{t: TypeNumber, s: \"123\"}, \"\", nil},\n\t\t{\"   123\", \u0026Value{t: TypeNumber, s: \"123\"}, \"   \", nil},\n\t\t{\"123   \", \u0026Value{t: TypeNumber, s: \"123\"}, \"   \", nil},\n\t\t{\"  123  \", \u0026Value{t: TypeNumber, s: \"123\"}, \"  \", nil},\n\n\t\t// NaN value\n\t\t{\"NaN\", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"\", nil},\n\t\t{\"   NaN\", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"   \", nil},\n\t\t{\"NaN   \", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"   \", nil},\n\t\t{\"  NaN  \", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"  \", nil},\n\n\t\t// Object value\n\t\t{\"{  }\", \u0026Value{t: TypeObject, o: Object{}}, \"\", nil},\n\n\t\t// Array value\n\t\t{\"[  ]\", \u0026Value{t: TypeArray}, \"\", nil},\n\n\t\t// Invalid value\n\t\t{\"invalid\", nil, \"invalid\", fmt.Errorf(\"unexpected value found: %q\", \"invalid\")},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"TestCase_%d\", i+1), func(t *testing.T) {\n\t\t\tv, tail, err := parseValue(tc.input, c, 0)\n\n\t\t\t// Check error\n\t\t\tif (err != nil \u0026\u0026 tc.err == nil) || (err == nil \u0026\u0026 tc.err != nil) || (err != nil \u0026\u0026 tc.err != nil \u0026\u0026 err.Error() != tc.err.Error()) {\n\t\t\t\tt.Fatalf(\"Test case %d failed: Expected error '%v', but got '%v'\", i+1, tc.err, err)\n\t\t\t}\n\n\t\t\t// Check value\n\t\t\tif tc.expected == nil \u0026\u0026 v != nil {\n\t\t\t\tt.Fatalf(\"Test case %d failed: Expected nil value, but got '%v'\", i+1, v)\n\t\t\t}\n\t\t\tif tc.expected != nil {\n\t\t\t\tif v == nil {\n\t\t\t\t\tt.Fatalf(\"Test case %d failed: Expected value '%v', but got nil\", i+1, tc.expected)\n\t\t\t\t}\n\t\t\t\tif tc.expected.t != v.t {\n\t\t\t\t\tt.Fatalf(\"Test case %d failed: Expected value type '%v', but got '%v'\", i+1, tc.expected.t, v.t)\n\t\t\t\t}\n\t\t\t\tif tc.expected.t == typeRawString \u0026\u0026 tc.expected.s != v.s {\n\t\t\t\t\tt.Fatalf(\"Test case %d failed: Expected value '%v', but got '%v'\", i+1, tc.expected.s, v.s)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check tail\n\t\t\tif tc.tail != tail {\n\t\t\t\tt.Fatalf(\"Test case %d failed: Expected tail '%s', but got '%s'\", i+1, tc.tail, tail)\n\t\t\t}\n\t\t})\n\t}\n}","164ccc2a2be2f8e88436d7a4daedb07f":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Empty string\n\t\t{\"\", nil, \"\", fmt.Errorf(\"cannot parse empty string\")},\n\t\t// Invalid JSON\n\t\t{\"{invalid}\", nil, \"\", fmt.Errorf(\"cannot parse object: invalid character 'i' looking for beginning of value\")},\n\t\t// Object\n\t\t{`{\"key\": \"value\"}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{t: typeRawString, s: \"value\"}}}}}}, \"\", nil},\n\t\t// Array\n\t\t{`[1, \"two\", true]`, \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: typeRawString, s: \"two\"}, {t: TypeTrue}}}, \"\", nil},\n\t\t// String\n\t\t{`\"hello\"`, \u0026Value{t: typeRawString, s: \"hello\"}, \"\", nil},\n\t\t// True\n\t\t{\"true\", valueTrue, \"\", nil},\n\t\t// False\n\t\t{\"false\", valueFalse, \"\", nil},\n\t\t// Null\n\t\t{\"null\", valueNull, \"\", nil},\n\t\t// Number\n\t\t{\"123\", \u0026Value{t: TypeNumber, s: \"123\"}, \"\", nil},\n\t\t// NaN\n\t\t{\"NaN\", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"\", nil},\n\t\t// Trailing whitespace\n\t\t{\"true \", valueTrue, \" \", nil},\n\t\t// Nested values\n\t\t{`{\"array\": [1,2,3], \"object\": {\"key\": \"value\"}}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"array\", v: \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}}}, {k: \"object\", v: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{t: typeRawString, s: \"value\"}}}}}}}}}}, \"\", nil},\n\t}\n\n\tc := \u0026cache{}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test #%d: %s\", i, tt.input), func(t *testing.T) {\n\t\t\tgot, tail, err := parseValue(tt.input, c, 0)\n\t\t\tif (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"parseValue() tail = %v, want %v\", tail, tt.tail)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase typeRawString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\treturn true\n\t}\n}\n","16723f2ffc32b29d413163cff8fbb420":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput  string\n\t\texpect string\n\t\ttail   string\n\t\terr    error\n\t}{\n\t\t// Basic cases.\n\t\t{`\"foo\"bar`, `foo`, `bar`, nil},\n\t\t{`\"fo\\o\"bar`, `fo\\o`, `bar`, nil},\n\t\t{`\"foo\"`, `foo`, ``, nil},\n\n\t\t// Escaped quotes.\n\t\t{`\"fo\\\"o\"bar`, `fo\"o`, `bar`, nil},\n\t\t{`\"fo\\\\\"o\"bar`, `fo\\\\`, `o\"bar`, nil},\n\t\t{`\"fo\\\\\\\\\"o\"bar`, `fo\\\\\"o`, `bar`, nil},\n\t\t{`\"fo\\\\\\\\\\\"\"o\"bar`, `fo\\\\\\\"\"o`, `bar`, nil},\n\n\t\t// Invalid cases.\n\t\t{`\"foo`, ``, ``, fmt.Errorf(`missing closing '\"'`)}\n\t\t{`\"fo\\`, ``, ``, fmt.Errorf(`missing closing '\"'`)}\n\t\t{`\"fo\\\\\\\"`, ``, ``, fmt.Errorf(`missing closing '\"'`)}\n\t}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tresult, tail, err := parseRawString(tt.input)\n\t\t\tif result != tt.expect || tail != tt.tail || (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = %q, %q, %v, want %q, %q, %v\", tt.input, result, tail, err, tt.expect, tt.tail, tt.err)\n\t\t\t}\n\t\t})\n\n\t}\n}","1776fcb07dc4d492159b07148dfcd15c":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Get(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant *Value\n\t}{\n\t\t{\n\t\t\tname: \"nil value\",\n\t\t\tv:    nil,\n\t\t\targs: args{keys: []string{\"key\"}},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"empty keys\",\n\t\t\tv:    \u0026Value{t: TypeObject},\n\t\t\targs: args{keys: []string{}},\n\t\t\twant: \u0026Value{t: TypeObject},\n\t\t},\n\t\t{\n\t\t\tname: \"object key exists\",\n\t\t\tv:    \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{t: TypeString, s: \"value\"}}}}},\n\t\t\targs: args{keys: []string{\"key\"}},\n\t\t\twant: \u0026Value{t: TypeString, s: \"value\"},\n\t\t},\n\t\t{\n\t\t\tname: \"object key does not exist\",\n\t\t\tv:    \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{t: TypeString, s: \"value\"}}}}},\n\t\t\targs: args{keys: []string{\"nonexistent\"}},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"array index in range\",\n\t\t\tv:    \u0026Value{t: TypeArray, a: []*Value{{t: TypeString, s: \"value1\"}, {t: TypeString, s: \"value2\"}}},\n\t\t\targs: args{keys: []string{\"1\"}},\n\t\t\twant: \u0026Value{t: TypeString, s: \"value2\"},\n\t\t},\n\t\t{\n\t\t\tname: \"array index out of range\",\n\t\t\tv:    \u0026Value{t: TypeArray, a: []*Value{{t: TypeString, s: \"value1\"}, {t: TypeString, s: \"value2\"}}},\n\t\t\targs: args{keys: []string{\"2\"}},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"array invalid index\",\n\t\t\tv:    \u0026Value{t: TypeArray, a: []*Value{{t: TypeString, s: \"value1\"}, {t: TypeString, s: \"value2\"}}},\n\t\t\targs: args{keys: []string{\"invalid\"}},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"non-object, non-array value\",\n\t\t\tv:    \u0026Value{t: TypeString, s: \"value\"},\n\t\t\targs: args{keys: []string{\"key\"}},\n\t\t\twant: nil,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.Get(tt.args.keys...); got != tt.want {\n\t\t\t\tt.Errorf(\"Value.Get() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","17b32a79b708d7306585f51b4a70cf38":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey   string\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Basic cases.\n\t\t{`\"foo\"bar`, `foo`, `bar`, nil},\n\t\t{`\"fo\\\"o\"bar`, `fo\"o`, `bar`, nil},\n\t\t{`\"foo\"`, `foo`, ``, nil},\n\t\t{`\"\"bar`, ``, `bar`, nil},\n\n\t\t// Escaped quotes.\n\t\t{`\"foo\\\\\"bar`, `foo\\`, `bar`, nil},\n\t\t{`\"foo\\\\\\\\\"bar`, `foo\\\\`, `bar`, nil},\n\t\t{`\"foo\\\\\\\"bar`, `foo\\\"bar`, ``, nil},\n\n\t\t// Missing closing quote.\n\t\t{`\"foo`, ``, ``, fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"fo\\\"`, ``, ``, fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo\\\\`, ``, ``, fmt.Errorf(`missing closing '\"'`)},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tkey, tail, err := parseRawString(tt.input)\n\t\t\tif key != tt.key || tail != tt.tail || !equalError(err, tt.err) {\n\t\t\t\tt.Errorf(\"input: %q, want (%q, %q, %v), got (%q, %q, %v)\", tt.input, tt.key, tt.tail, tt.err, key, tail, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// equalError reports whether errors a and b are considered equal.\n// They're equal if both are nil, or both are not nil and a.Error() == b.Error().\nfunc equalError(a, b error) bool {\n\treturn a == nil \u0026\u0026 b == nil || a != nil \u0026\u0026 b != nil \u0026\u0026 a.Error() == b.Error()\n}","19b178d5d315f1ee4a910530c85798c5":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic strings\n\t\t{\"hello\", \"hello\"},\n\t\t{\"world\", \"world\"},\n\n\t\t// Escaped characters\n\t\t{`\\\"`, `\"`},\n\t\t{`\\\\`, `\\`},\n\t\t{`\\/`, `/`},\n\t\t{`\\b`, \"\\b\"},\n\t\t{`\\f`, \"\\f\"},\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\r`, \"\\r\"},\n\t\t{`\\t`, \"\\t\"},\n\n\t\t// Unicode escape sequences\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A0`, \"\\u00A0\"},\n\t\t{`\\u20AC`, \"\\u20AC\"},\n\t\t{`\\uD83D\\uDE02`, \"\\U0001F602\"},\n\n\t\t// Invalid escape sequences\n\t\t{`\\u`, `\\u`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\uD800`, `\\uD800`},\n\t\t{`\\uD83D\\u`, `\\uD83D\\u`},\n\n\t\t// Mixed strings\n\t\t{`hello\\tworld`, \"hello\\tworld\"},\n\t\t{`\\u0041\\u0020string\\twith\\nescapes`, \"A string\\twith\\nescapes\"},\n\n\t\t// Complex strings\n\t\t{`{\\\"key\\\": \\\"value\\\"}`, `{\"key\": \"value\"}`},\n\t\t{`[1, 2, \"three\\nlines\"]`, `[1, 2, \"three\\nlines\"]`},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tactual := unescapeStringBestEffort(tt.input)\n\t\t\tif actual != tt.expected {\n\t\t\t\tt.Errorf(\"Expected: %q, Actual: %q\", tt.expected, actual)\n\t\t\t}\n\t\t})\n\t}\n}","19b3a5701e18b77f98195cf754c31c57":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t\tremain   string\n\t\terr      error\n\t}{\n\t\t// Simple cases\n\t\t{`\"foo\"bar`, \"foo\", \"bar\", nil},\n\t\t{`\"foo\"`, \"foo\", \"\", nil},\n\t\t{`\"\"bar`, \"\", \"bar\", nil},\n\n\t\t// Escaped quotes\n\t\t{`\"fo\\\\\"o\"bar`, `fo\\\"o`, \"bar\", nil},\n\t\t{`\"fo\\\\\\\\\"o\"bar`, `fo\\\\`, `o\"bar`, nil},\n\t\t{`\"foo\\\\\"bar`, `foo\\`, `bar`, nil},\n\t\t{`\"\\\\\"bar`, `\\\"`, \"bar\", nil},\n\t\t{`\"\\\\\\\\\"bar`, `\\\\`, `bar`, nil},\n\n\t\t// Missing closing quote\n\t\t{`\"foobar`, \"\", \"\", fmt.Errorf(`missing closing '\"`)},\n\t\t{`\"fo\\\\obar`, \"\", \"\", fmt.Errorf(`missing closing '\"`)},\n\n\t\t// Empty strings\n\t\t{`\"\"`, \"\", \"\", nil},\n\t\t{`\"`, \"\", \"\", fmt.Errorf(`missing closing '\"`)},\n\t}\n\n\tfor i, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test case %d: %s\", i, test.input), func(t *testing.T) {\n\t\t\tactual, remain, err := parseRawString(test.input)\n\n\t\t\tif actual != test.expected {\n\t\t\t\tt.Errorf(\"Expected string: %q, got: %q\", test.expected, actual)\n\t\t\t}\n\t\t\tif remain != test.remain {\n\t\t\t\tt.Errorf(\"Expected remaining string: %q, got: %q\", test.remain, remain)\n\t\t\t}\n\t\t\tif test.err != nil {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"Expected error, got nil\")\n\t\t\t\t} else if err.Error() != test.err.Error() {\n\t\t\t\t\tt.Errorf(\"Expected error: %v, got: %v\", test.err, err)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","19cc1c015d27484dc43e312ff7b721be":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ts     string\n\t\terr   error\n\t}{\n\t\t// Empty array\n\t\t{\n\t\t\tinput: \"[]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Simple array\n\t\t{\n\t\t\tinput: \"[1,2,3]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Array with whitespace\n\t\t{\n\t\t\tinput: \" [ 1 , 2 , 3 ] \",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Nested array\n\t\t{\n\t\t\tinput: \"[1,[2,3],4]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeArray, a: []*Value{\n\t\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t\t}},\n\t\t\t\t\t{t: TypeNumber, s: \"4\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Array with different value types\n\t\t{\n\t\t\tinput: `[1,\"hello\",true,null]`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeString, s: \"hello\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t\t{t: TypeNull},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Invalid array - missing closing bracket\n\t\t{\n\t\t\tinput: \"[1,2,3\",\n\t\t\twant:  nil,\n\t\t\ts:     \"[1,2,3\",\n\t\t\terr:   fmt.Errorf(\"unexpected end of array\"),\n\t\t},\n\t\t// Invalid array - missing comma\n\t\t{\n\t\t\tinput: \"[1 2 3]\",\n\t\t\twant:  nil,\n\t\t\ts:     \"2 3]\",\n\t\t\terr:   fmt.Errorf(\"missing ',' after array value\"),\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test %d\", i+1), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseArray(tt.input, c, 0)\n\n\t\t\tif (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"parseArray(%s) error mismatch: got %v, want %v\", tt.input, err, tt.err)\n\t\t\t}\n\n\t\t\tif s != tt.s {\n\t\t\t\tt.Errorf(\"parseArray(%s) remaining string mismatch: got %q, want %q\", tt.input, s, tt.s)\n\t\t\t}\n\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray(%s) value mismatch:\\ngot  %+v\\nwant %+v\", tt.input, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeString, TypeNumber:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\treturn true\n\t}\n}","1aa906ed44c98caf0327578912d5774d":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic tests\n\t\t{\"simple string\", \"simple string\"},\n\t\t{\"escaped \\\\\\\" string\", \"escaped \\\" string\"},\n\t\t{\"escaped \\\\\\\\ string\", \"escaped \\\\ string\"},\n\t\t{\"escaped \\\\/ string\", \"escaped / string\"},\n\t\t{\"escaped \\\\b string\", \"escaped \\b string\"},\n\t\t{\"escaped \\\\f string\", \"escaped \\f string\"},\n\t\t{\"escaped \\\\n string\", \"escaped \\n string\"},\n\t\t{\"escaped \\\\r string\", \"escaped \\r string\"},\n\t\t{\"escaped \\\\t string\", \"escaped \\t string\"},\n\n\t\t// Unicode tests\n\t\t{\"escaped \\\\u0020 string\", \"escaped   string\"},\n\t\t{\"escaped \\\\u00A9 string\", \"escaped ¬© string\"},\n\t\t{\"escaped \\\\u20AC string\", \"escaped ‚Ç¨ string\"},\n\t\t{\"invalid escape \\\\u123 string\", \"invalid escape \\\\u123 string\"},\n\t\t{\"invalid escape \\\\u12345 string\", \"invalid escape \\\\u12345 string\"},\n\n\t\t// Surrogate tests\n\t\t{\"escaped \\\\uD83D\\\\uDE02 string\", \"escaped üòÇ string\"},\n\t\t{\"invalid surrogate \\\\uD83D string\", \"invalid surrogate \\\\uD83D string\"},\n\t\t{\"invalid surrogate \\\\uD83D\\\\u1234 string\", \"invalid surrogate \\\\uD83D\\\\u1234 string\"},\n\n\t\t// Mixed tests\n\t\t{\"escaped \\\\\\\"\\\\nslashes\\\\t\\\\u0020and unicode\", \"escaped \\\"\\nslashes\\t and unicode\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Input: %q, Expected: %q, Actual: %q\", test.input, test.expected, actual)\n\t\t}\n\t}\n}\n","1b0cb5367fdb39bc465b2887e82894b3":"package fastjson\n\nimport \"testing\"\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tinput Type\n\t\twant  string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\tfor i, tt := range tests {\n\t\tgot := tt.input.String()\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"test[%d]: String() = %q, want %q\", i, got, tt.want)\n\t\t}\n\t}\n}","1bca194f17562f1a6b2bfbc4f35dc226":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCache_getValue(t *testing.T) {\n\tt.Run(\"initial allocation\", func(t *testing.T) {\n\t\tc := \u0026cache{}\n\t\tval := c.getValue()\n\n\t\tif val == nil {\n\t\t\tt.Fatal(\"Expected non-nil value, got nil\")\n\t\t}\n\n\t\tif len(c.vs) != 2 {\n\t\t\tt.Errorf(\"Expected cache length 2, got %d\", len(c.vs))\n\t\t}\n\t})\n\n\tt.Run(\"reuse existing capacity\", func(t *testing.T) {\n\t\tc := \u0026cache{\n\t\t\tvs: make([]Value, 0, 4),\n\t\t}\n\t\tc.getValue()\n\n\t\tval := c.getValue()\n\n\t\tif val == nil {\n\t\t\tt.Fatal(\"Expected non-nil value, got nil\")\n\t\t}\n\n\t\tif len(c.vs) != 2 {\n\t\t\tt.Errorf(\"Expected cache length 2, got %d\", len(c.vs))\n\t\t}\n\n\t\tif cap(c.vs) != 4 {\n\t\t\tt.Errorf(\"Expected cache capacity 4, got %d\", cap(c.vs))\n\t\t}\n\t})\n\n\tt.Run(\"extend capacity\", func(t *testing.T) {\n\t\tc := \u0026cache{\n\t\t\tvs: make([]Value, 0, 2),\n\t\t}\n\t\tc.getValue()\n\t\tc.getValue()\n\n\t\tval := c.getValue()\n\n\t\tif val == nil {\n\t\t\tt.Fatal(\"Expected non-nil value, got nil\")\n\t\t}\n\n\t\tif len(c.vs) != 4 {\n\t\t\tt.Errorf(\"Expected cache length 4, got %d\", len(c.vs))\n\t\t}\n\n\t\tif cap(c.vs) != 4 {\n\t\t\tt.Errorf(\"Expected cache capacity 4, got %d\", cap(c.vs))\n\t\t}\n\t})\n}\n","1c00ead46802235ac5eed2c1d0ca0b65":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetStringBytes(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tjson  string\n\t\tkeys  []string\n\t\twant  []byte\n\t\twant1 bool\n\t}{\n\t\t{\n\t\t\tname:  \"simple\",\n\t\t\tjson:  `{\"foo\": \"bar\"}`,\n\t\t\tkeys:  []string{\"foo\"},\n\t\t\twant:  []byte(\"bar\"),\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"nested\",\n\t\t\tjson:  `{\"foo\": {\"bar\": \"baz\"}}`,\n\t\t\tkeys:  []string{\"foo\", \"bar\"},\n\t\t\twant:  []byte(\"baz\"),\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array\",\n\t\t\tjson:  `{\"foo\": [\"bar\", \"baz\"]}`,\n\t\t\tkeys:  []string{\"foo\", \"1\"},\n\t\t\twant:  []byte(\"baz\"),\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array decimal index\",\n\t\t\tjson:  `{\"foo\": [\"bar\", \"baz\"]}`,\n\t\t\tkeys:  []string{\"foo\", \"1.0\"},\n\t\t\twant:  []byte(\"baz\"),\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"non-existent key\",\n\t\t\tjson:  `{\"foo\": \"bar\"}`,\n\t\t\tkeys:  []string{\"baz\"},\n\t\t\twant:  nil,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"invalid value type\",\n\t\t\tjson:  `{\"foo\": 123}`,\n\t\t\tkeys:  []string{\"foo\"},\n\t\t\twant:  nil,\n\t\t\twant1: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv, err := ParseBytes([]byte(tt.json))\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"ParseBytes() error = %v, wantErr %v\", err, nil)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tgot := v.GetStringBytes(tt.keys...)\n\t\t\tif !bytesEquals(got, tt.want) {\n\t\t\t\tt.Errorf(\"GetStringBytes() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc bytesEquals(a, b []byte) bool {\n\tif (a == nil \u0026\u0026 b != nil) || (a != nil \u0026\u0026 b == nil) {\n\t\treturn false\n\t}\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n","1c610a9276eeb78e756f2c509ddd525f":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic escapes\n\t\t{`\\t\\b\\n\\f\\r\\\\\\/\\\"`, \"\\t\\b\\n\\f\\r\\\\/\\\"\"},\n\n\t\t// Unicode escapes\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A0`, \"\\u00A0\"},\n\t\t{`\\u00A1`, \"¬°\"},\n\t\t{`\\uD83D\\uDE02`, \"üòÇ\"}, // Surrogate pair\n\n\t\t// Invalid escapes\n\t\t{`\\a\\c\\v\\?`, \"\\\\a\\\\c\\\\v\\\\?\"},  // Invalid escape sequences\n\t\t{`\\u00`, \"\\\\u00\"},              // Short escape sequence\n\t\t{`\\u002`, \"\\\\u002\"},             // Short escape sequence\n\t\t{`\\uD800`, \"\\\\uD800\"},         // Unpaired surrogate\n\t\t{`\\uD800\\u`, \"\\\\uD800\\\\u\"},        // Unpaired surrogate\n\t\t{`\\uD800\\uD800`, \"\\\\uD800\\\\uD800\"}, // Two high surrogates\n\t\t{`\\uDC00\\uDC00`, \"\\\\uDC00\\\\uDC00\"}, // Two low surrogates\n\n\t\t// Mixed valid and invalid escapes\n\t\t{`Hello\\tworld\\u0020!\\uDC00`, \"Hello\\tworld !\\\\uDC00\"},\n\n\t\t// Escaped backslashes\n\t\t{`\\\\\\\\`, \"\\\\\\\\\"},\n\t\t{`\\\\\\\\\\`, \"\\\\\\\\\\\\\"},\n\n\t\t// No escapes\n\t\t{`Hello, world!`, \"Hello, world!\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}\n","1ce43c5fa81158f58acaadeba7b8f216":"package fastjson\n\nimport \"testing\"\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tt    Type\n\t\twant string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.want, func(t *testing.T) {\n\t\t\tif got := tt.t.String(); got != tt.want {\n\t\t\t\tt.Errorf(\"Type.String() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","1d6102038107577e8f368fb5065b7559":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput    string\n\t\twantNum  string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Valid numbers\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"123.456\", \"123.456\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"+123\", \"+123\", \"\", nil},\n\t\t{\"1.2e3\", \"1.2e3\", \"\", nil},\n\t\t{\"1.2E-3\", \"1.2E-3\", \"\", nil},\n\n\t\t// Valid numbers with trailing characters\n\t\t{\"123abc\", \"123\", \"abc\", nil},\n\t\t{\"123.456xyz\", \"123.456\", \"xyz\", nil},\n\t\t{\"-123 \", \"-123\", \" \", nil},\n\n\t\t// Invalid numbers\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t\t{\"-\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t\t{\"+\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"+\")},\n\t\t{\".\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \".\")},\n\t\t{\"a123\", \"\", \"a123\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\n\t\t// Special cases with \"inf\"\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"+inf\", \"+inf\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"infin\", \"inf\", \"in\", nil},\n\t\t{\"+infin\", \"+inf\", \"in\", nil},\n\t\t{\"-infin\", \"-inf\", \"in\", nil},\n\t\t{\"123inf\", \"123\", \"inf\", nil},\n\t\t{\"in\", \"\", \"in\", fmt.Errorf(\"unexpected char: %q\", \"i\")},\n\t\t{\"+in\", \"\", \"+in\", fmt.Errorf(\"unexpected char: %q\", \"+i\")},\n\t\t{\"-in\", \"\", \"-in\", fmt.Errorf(\"unexpected char: %q\", \"-i\")},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"Case_%d\", i+1), func(t *testing.T) {\n\t\t\tgotNum, gotTail, gotErr := parseRawNumber(tc.input)\n\n\t\t\tif gotNum != tc.wantNum {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got number = %q, want %q\", tc.input, gotNum, tc.wantNum)\n\t\t\t}\n\t\t\tif gotTail != tc.wantTail {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got tail = %q, want %q\", tc.input, gotTail, tc.wantTail)\n\t\t\t}\n\t\t\tif gotErr == nil \u0026\u0026 tc.wantErr != nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got err = nil, want error: %v\", tc.input, tc.wantErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tc.wantErr == nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got unexpected error: %v\", tc.input, gotErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tc.wantErr != nil \u0026\u0026 gotErr.Error() != tc.wantErr.Error() {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got error = %v, want error: %v\", tc.input, gotErr, tc.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}\n","1dca8b16fd1f12843f54c38e028842d2":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetUint(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tjson  string\n\t\tkeys  []string\n\t\twant  uint\n\t\twant1 bool\n\t}{\n\t\t{\n\t\t\tname:  \"simple\",\n\t\t\tjson:  `{\"a\":123}`,\n\t\t\tkeys:  []string{\"a\"},\n\t\t\twant:  123,\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"nested\",\n\t\t\tjson:  `{\"a\":{\"b\":123}}`,\n\t\t\tkeys:  []string{\"a\", \"b\"},\n\t\t\twant:  123,\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array\",\n\t\t\tjson:  `{\"a\":[123,456]}`,\n\t\t\tkeys:  []string{\"a\", \"1\"},\n\t\t\twant:  456,\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array decimal\",\n\t\t\tjson:  `{\"a\":[123,456]}`,\n\t\t\tkeys:  []string{\"a\", \"1.0\"},\n\t\t\twant:  456,\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"non-existing key\",\n\t\t\tjson:  `{\"a\":123}`,\n\t\t\tkeys:  []string{\"b\"},\n\t\t\twant:  0,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"invalid value type\",\n\t\t\tjson:  `{\"a\":\"string\"}`,\n\t\t\tkeys:  []string{\"a\"},\n\t\t\twant:  0,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"number from string\",\n\t\t\tjson:  `{\"a\":\"123\"}`,\n\t\t\tkeys:  []string{\"a\"},\n\t\t\twant:  0,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"overflow\",\n\t\t\tjson:  `{\"a\":18446744073709551616}`,\n\t\t\tkeys:  []string{\"a\"},\n\t\t\twant:  0,\n\t\t\twant1: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv := GetFromString(tt.json)\n\t\t\tgot := v.GetUint(tt.keys...)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Value.GetUint() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc GetFromString(s string) *Value {\n\tvar p Parser\n\tv, err := p.Parse(s)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn v\n}","1ea4de15947de5848d3c8cf899c4801a":"package fastjson\n\nimport \"testing\"\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tt    Type\n\t\twant string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\tfor i, tt := range tests {\n\t\tgot := tt.t.String()\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"test[%d]: String() = %q, want %q\", i, got, tt.want)\n\t\t}\n\t}\n}","1ef5dafc5651aab64d7c67dcd23d202e":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Get(t *testing.T) {\n\tt.Run(\"object\", func(t *testing.T) {\n\t\tv, _ := Parse(`{\"a\": 123, \"b\": \"456\", \"c\": {\"d\": \"789\"}, \"d\": [1,2,3]}`)\n\n\t\ttests := []struct {\n\t\t\tkeys   []string\n\t\t\texpect *Value\n\t\t}{\n\t\t\t{\n\t\t\t\tkeys:   []string{\"a\"},\n\t\t\t\texpect: \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t},\n\t\t\t{\n\t\t\t\tkeys:   []string{\"b\"},\n\t\t\t\texpect: \u0026Value{t: TypeString, s: \"456\"},\n\t\t\t},\n\t\t\t{\n\t\t\t\tkeys:   []string{\"c\", \"d\"},\n\t\t\t\texpect: \u0026Value{t: TypeString, s: \"789\"},\n\t\t\t},\n\t\t\t{\n\t\t\t\tkeys:   []string{\"d\", \"1\"},\n\t\t\t\texpect: \u0026Value{t: TypeNumber, s: \"2\"},\n\t\t\t},\n\t\t\t{\n\t\t\t\tkeys:   []string{\"e\"},\n\t\t\t\texpect: nil,\n\t\t\t},\n\t\t}\n\n\t\tfor i, test := range tests {\n\t\t\tif got := v.Get(test.keys...); got != nil \u0026\u0026 got.String() != test.expect.String() {\n\t\t\t\tt.Errorf(\"Test[%d] expect %v, but got %v\", i, test.expect, got)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"array\", func(t *testing.T) {\n\t\tv, _ := Parse(`[{\"a\": 123}, {\"b\": \"456\"}]`)\n\n\t\ttests := []struct {\n\t\t\tkeys   []string\n\t\t\texpect *Value\n\t\t}{\n\t\t\t{\n\t\t\t\tkeys:   []string{\"0\", \"a\"},\n\t\t\t\texpect: \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t},\n\t\t\t{\n\t\t\t\tkeys:   []string{\"1\", \"b\"},\n\t\t\t\texpect: \u0026Value{t: TypeString, s: \"456\"},\n\t\t\t},\n\t\t\t{\n\t\t\t\tkeys:   []string{\"2\"},\n\t\t\t\texpect: nil,\n\t\t\t},\n\t\t\t{\n\t\t\t\tkeys:   []string{\"0\", \"c\"},\n\t\t\t\texpect: nil,\n\t\t\t},\n\t\t}\n\n\t\tfor i, test := range tests {\n\t\t\tif got := v.Get(test.keys...); got != nil \u0026\u0026 got.String() != test.expect.String() {\n\t\t\t\tt.Errorf(\"Test[%d] expect %v, but got %v\", i, test.expect, got)\n\t\t\t}\n\t\t}\n\t})\n}\n","2013af45e79fe47fbf01b0eaa4ee45fa":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twant     *Value\n\t\twantRest string\n\t\twantErr  error\n\t}{\n\t\t{\n\t\t\tname:     \"empty array\",\n\t\t\tinput:    \"[]\",\n\t\t\twant:     \u0026Value{t: TypeArray},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"simple array\",\n\t\t\tinput:    \"[1,2,3]\",\n\t\t\twant:     \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with spaces\",\n\t\t\tinput:    \" [ 1 , 2 , 3 ] \",\n\t\t\twant:     \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}},\n\t\t\twantRest: \" \",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with nested array\",\n\t\t\tinput:    \"[1,[2,3],4]\",\n\t\t\twant: \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeArray, a: []*Value{{t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}}, {t: TypeNumber, s: \"4\"}}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid array missing comma\",\n\t\t\tinput:    \"[1 2]\",\n\t\t\twant:     nil,\n\t\t\twantRest: \"\",\n\t\t\twantErr:  fmt.Errorf(\"missing ',' after array value\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid array missing closing bracket\",\n\t\t\tinput:    \"[1,2\",\n\t\t\twant:     nil,\n\t\t\twantRest: \"\",\n\t\t\twantErr:  fmt.Errorf(\"missing ']'\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, rest, err := parseArray(tt.input, c, 0)\n\t\t\tif (err != nil \u0026\u0026 tt.wantErr == nil) || (err == nil \u0026\u0026 tt.wantErr != nil) || (err != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 err.Error() != tt.wantErr.Error()) {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif rest != tt.wantRest {\n\t\t\t\tt.Errorf(\"parseArray() rest = %v, wantRest %v\", rest, tt.wantRest)\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.t == TypeArray {\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\treturn v1.s == v2.s\n}","20b5c1c1a4dfaafd124f9ff342248bef":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantN    string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Empty input.\n\t\t{\"\", \"\", \"\", nil},\n\n\t\t// Valid numbers.\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"123.456\", \"123.456\", \"\", nil},\n\t\t{\"-123.456\", \"-123.456\", \"\", nil},\n\t\t{\"1e10\", \"1e10\", \"\", nil},\n\t\t{\"1e+10\", \"1e+10\", \"\", nil},\n\t\t{\"1e-10\", \"1e-10\", \"\", nil},\n\n\t\t// Valid numbers with trailing characters.\n\t\t{\"123a\", \"123\", \"a\", nil},\n\t\t{\"-123a\", \"-123\", \"a\", nil},\n\t\t{\"123.456a\", \"123.456\", \"a\", nil},\n\n\t\t// Invalid numbers.\n\t\t{\"a123\", \"\", \"a123\", fmt.Errorf(`unexpected char: \"a\"`)},\n\t\t{\"+a123\", \"\", \"+a123\", fmt.Errorf(`unexpected char: \"+\"`)},\n\t\t{\"-a123\", \"\", \"-a123\", fmt.Errorf(`unexpected char: \"-\"`)},\n\t\t{\"123.456.789\", \"123.456\", \".789\", nil},\n\n\t\t// Special values.\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"+inf\", \"+inf\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"InF\", \"InF\", \"\", nil},\n\t\t{\"+InF\", \"+InF\", \"\", nil},\n\t\t{\"-InF\", \"-InF\", \"\", nil},\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"+nan\", \"+nan\", \"\", nil},\n\t\t{\"-nan\", \"-nan\", \"\", nil},\n\t\t{\"nAn\", \"nAn\", \"\", nil},\n\t\t{\"+nAn\", \"+nAn\", \"\", nil},\n\t\t{\"-nAn\", \"-nAn\", \"\", nil},\n\n\t\t// Special values with trailing characters.\n\t\t{\"infa\", \"inf\", \"a\", nil},\n\t\t{\"nana\", \"nan\", \"a\", nil},\n\n\t\t// Invalid special values.\n\t\t{\"in\", \"\", \"in\", fmt.Errorf(`unexpected char: \"i\"`)},\n\t\t{\"na\", \"\", \"na\", fmt.Errorf(`unexpected char: \"n\"`)},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test %d\", i), func(t *testing.T) {\n\t\t\tgotN, gotTail, gotErr := parseRawNumber(tt.input)\n\t\t\tif gotN != tt.wantN {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got number = %q, want %q\", tt.input, gotN, tt.wantN)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got tail = %q, want %q\", tt.input, gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif gotErr == nil \u0026\u0026 tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got err = nil, want %v\", tt.input, tt.wantErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr == nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got err = %v, want nil\", tt.input, gotErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got err = %v, want %v\", tt.input, gotErr, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","20bdc202f514624e2445ff26eb23a8bf":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_unescapeKeys(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tkvs  []kv\n\t\twant []kv\n\t}{\n\t\t{\n\t\t\tname: \"escapeString\",\n\t\t\tkvs: []kv{\n\t\t\t\t{k: `\\x61\\xbc\\xde`, v: \u0026Value{t: TypeString, s: \"foo\"}},\n\t\t\t},\n\t\t\twant: []kv{\n\t\t\t\t{k: \"a¬º¬æ\", v: \u0026Value{t: TypeString, s: \"foo\"}},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"escapeCharacter\",\n\t\t\tkvs: []kv{\n\t\t\t\t{k: `\\t\\b\\n\\f\\r\\\"\\/\\\\`, v: \u0026Value{t: TypeString, s: \"foo\"}},\n\t\t\t},\n\t\t\twant: []kv{\n\t\t\t\t{k: \"\\t\\b\\n\\f\\r\\\"/\\\\\", v: \u0026Value{t: TypeString, s: \"foo\"}},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\to := \u0026Object{\n\t\t\t\tkvs: tt.kvs,\n\t\t\t}\n\t\t\to.unescapeKeys()\n\t\t\tfor i := range o.kvs {\n\t\t\t\tif o.kvs[i].k != tt.want[i].k {\n\t\t\t\t\tt.Errorf(\"unescapeKeys() = %v, want %v\", o.kvs[i].k, tt.want[i].k)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","20c0b47d55f6f1274b8c35f08b22d4a0":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey   string\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Basic cases.\n\t\t{`\"foo\"bar`, `foo`, `bar`, nil},\n\t\t{`\"fo\\o\"bar`, `fo\\o`, `bar`, nil},\n\t\t{`\"foo\"`, `foo`, ``, nil},\n\t\t{`\"\"bar`, ``, `bar`, nil},\n\n\t\t// Escaped quotes.\n\t\t{`\"foo\\\"bar\"baz`, `foo\"bar`, `baz`, nil},\n\t\t{`\"foo\\\\\\\"bar\"baz`, `foo\\\"bar`, `baz`, nil},\n\t\t{`\"foo\\\\\\\\\"bar\"baz`, `foo\\\\`, `bar\"baz`, nil},\n\n\t\t// Missing closing quote.\n\t\t{`\"foobar`, ``, ``, fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo\\\"bar`, ``, ``, fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo\\\\\\\"bar`, ``, ``, fmt.Errorf(`missing closing '\"'`)},\n\t}\n\n\tfor i, tt := range tests {\n\t\tk, tail, err := parseRawString(tt.input)\n\t\tif k != tt.key || tail != tt.tail || !equalError(err, tt.err) {\n\t\t\tt.Errorf(\"#%d. Expected %q, %q, %v, got %q, %q, %v\",\n\t\t\t\ti, tt.key, tt.tail, tt.err, k, tail, err)\n\t\t}\n\t}\n}\n\n// equalError reports whether errors a and b are considered equal.\n// They're equal if both are nil, or both are not nil and a.Error() == b.Error().\nfunc equalError(a, b error) bool {\n\treturn a == nil \u0026\u0026 b == nil || a != nil \u0026\u0026 b != nil \u0026\u0026 a.Error() == b.Error()\n}","20c410e6014f42776532d2abe3f935ad":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput    string\n\t\twantStr  string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Simple cases.\n\t\t{`\"foo\"bar`, \"foo\", \"bar\", nil},\n\t\t{`\"fo\\o\"bar`, \"fo\\o\", \"bar\", nil},\n\t\t{`\"foo\"`, \"foo\", \"\", nil},\n\n\t\t// Empty strings.\n\t\t{`\"\"bar`, \"\", \"bar\", nil},\n\t\t{`\"\"`, \"\", \"\", nil},\n\n\t\t// Escaped quotes.\n\t\t{`\"foo\\\"bar\"baz`, `foo\"bar`, \"baz\", nil},\n\t\t{`\"foo\\\\\"bar`, `foo\\\\`, \"bar\", nil},\n\t\t{`\"foo\\\\\\\"\"bar`, `foo\\\"`, \"bar\", nil},\n\t\t{`\"foo\\\\\\\\\"bar`, `foo\\\\`, \"bar\", nil},\n\n\t\t// Missing closing quote.\n\t\t{`\"foobar`, \"foobar\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo\\\"bar`, `foo\\\"bar`, \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo\\\\\\\"bar`, `foo\\\\\\\"bar`, \"\", fmt.Errorf(`missing closing '\"'`)},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case %d: %s\", i, tc.input), func(t *testing.T) {\n\t\t\tgotStr, gotTail, gotErr := parseRawString(tc.input)\n\t\t\tif gotStr != tc.wantStr {\n\t\t\t\tt.Errorf(\"got string %q, want %q\", gotStr, tc.wantStr)\n\t\t\t}\n\t\t\tif gotTail != tc.wantTail {\n\t\t\t\tt.Errorf(\"got tail %q, want %q\", gotTail, tc.wantTail)\n\t\t\t}\n\t\t\tif gotErr != nil \u0026\u0026 tc.wantErr != nil \u0026\u0026 gotErr.Error() != tc.wantErr.Error() {\n\t\t\t\tt.Errorf(\"got error %v, want %v\", gotErr, tc.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","20f4fca86896e8b2a8b5f24aff6e129d":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic escapes\n\t\t{`\\b`, \"\\b\"},\n\t\t{`\\f`, \"\\f\"},\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\r`, \"\\r\"},\n\t\t{`\\t`, \"\\t\"},\n\t\t{`\\\\`, `\\`},\n\t\t{`\\/`, `/`},\n\t\t{`\\\"`, `\"`},\n\n\t\t// Unicode escapes\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A0`, \"\\u00A0\"},\n\t\t{`\\u20AC`, \"\\u20AC\"},\n\t\t{`\\uD83D\\uDE02`, \"\\U0001F602\"},\n\n\t\t// Invalid escapes\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u`, `\\u`},\n\t\t{`\\u002`, `\\u002`},\n\t\t{`\\uD83D`, `\\uD83D`},\n\t\t{`\\uD83D\\u`, `\\uD83D\\u`},\n\t\t{`\\uD83D\\uXXXX`, `\\uD83D\\uXXXX`},\n\n\t\t// Mixed\n\t\t{`Hello\\tworld\\n`, \"Hello\\tworld\\n\"},\n\t\t{`{\\\"foo\\\":\\\"bar\\\"}`, `{\"foo\":\"bar\"}`},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Input: %q, Expected: %q, Actual: %q\", test.input, test.expected, actual)\n\t\t}\n\t}\n}","2100dd028b870c5605e39b71dc4b7a32":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantVal  *Value\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\twantVal:  nil,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"object\",\n\t\t\tinput:    `{\"foo\":\"bar\"}`,\n\t\t\twantVal:  \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: typeRawString, s: \"bar\"}}}}}},\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\twantVal:  \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}},\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\twantVal:  \u0026Value{t: typeRawString, s: \"hello\"},\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"true\",\n\t\t\tinput:    \"true\",\n\t\t\twantVal:  valueTrue,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"false\",\n\t\t\tinput:    \"false\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"null\",\n\t\t\tinput:    \"null\",\n\t\t\twantVal:  valueNull,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"number\",\n\t\t\tinput:    \"123\",\n\t\t\twantVal:  \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN\",\n\t\t\tinput:    \"NaN\",\n\t\t\twantVal:  \u0026Value{t: TypeNumber, s: \"NaN\"},\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"unexpected value\",\n\t\t\tinput:    \"xyz\",\n\t\t\twantVal:  nil,\n\t\t\twantTail: \"xyz\",\n\t\t\twantErr:  fmt.Errorf(\"unexpected value found: %q\", \"xyz\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgotVal, gotTail, gotErr := parseValue(tt.input, c, 0)\n\t\t\tif fmt.Sprintf(\"%v\", gotErr) != fmt.Sprintf(\"%v\", tt.wantErr) {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", gotErr, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseValue() gotTail = %v, want %v\", gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif !equalValues(gotVal, tt.wantVal) {\n\t\t\t\tt.Errorf(\"parseValue() gotVal = %v, want %v\", gotVal, tt.wantVal)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.s != v2.s {\n\t\treturn false\n\t}\n\tif (v1.o != Object{} || v2.o != Object{}) \u0026\u0026 !equalObjects(\u0026v1.o, \u0026v2.o) {\n\t\treturn false\n\t}\n\tif len(v1.a) != len(v2.a) {\n\t\treturn false\n\t}\n\tfor i := range v1.a {\n\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc equalObjects(o1, o2 *Object) bool {\n\tif o1.keysUnescaped != o2.keysUnescaped {\n\t\treturn false\n\t}\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i := range o1.kvs {\n\t\tif o1.kvs[i].k != o2.kvs[i].k {\n\t\t\treturn false\n\t\t}\n\t\tif !equalValues(o1.kvs[i].v, o2.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","21563450aa831ddb46cebdbf589fe705":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tt        Type\n\t\texpected string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\tfor i, tt := range tests {\n\t\tif got := tt.t.String(); got != tt.expected {\n\t\t\tt.Errorf(\"test %d: incorrect string representation - got: %s, want: %s\", i, got, tt.expected)\n\t\t}\n\t}\n}","219d017f87ef89c0155d62b9adcf69a1":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantJSON string\n\t\twantErr  error\n\t}{\n\t\t{\n\t\t\tname:     \"empty object\",\n\t\t\tinput:    \"{}\",\n\t\t\twantJSON: `{}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"simple object\",\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 123}`,\n\t\t\twantJSON: `{\"key1\": \"value1\", \"key2\": 123}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"nested object\",\n\t\t\tinput:    `{\"key1\": {\"key2\": \"value2\"}, \"key3\": [1,2,3]}`,\n\t\t\twantJSON: `{\"key1\": {\"key2\": \"value2\"}, \"key3\": [1, 2, 3]}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"object with escaped characters\",\n\t\t\tinput:    `{\"key1\": \"value with \\\"escaped\\\" characters\"}`,\n\t\t\twantJSON: `{\"key1\": \"value with \\\"escaped\\\" characters\"}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid object: missing colon\",\n\t\t\tinput:    `{\"key1\" \"value1\"}`,\n\t\t\twantErr: fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid object: missing closing brace\",\n\t\t\tinput:    `{\"key1\": \"value1\"`,\n\t\t\twantErr: fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, tail, err := parseObject(tt.input, c, 0)\n\t\t\tif tt.wantErr != nil {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"parseObject() error = nil, wantErr %v\", tt.wantErr)\n\t\t\t\t} else if err.Error() != tt.wantErr.Error() {\n\t\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr nil\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif tail != \"\" {\n\t\t\t\tt.Errorf(\"parseObject() tail = %v, want empty string\", tail)\n\t\t\t}\n\t\t\tgotJSON, err := got.StringBytes()\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"StringBytes() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif string(gotJSON) != tt.wantJSON {\n\t\t\t\tt.Errorf(\"parseObject() = %s, want %s\", gotJSON, tt.wantJSON)\n\t\t\t}\n\t\t})\n\t}\n}\n","21c8b9ab6e61b74c9c277e147ee024f4":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ts     string\n\t\terr   error\n\t}{\n\t\t// Add your test cases here\n\t\t// Example test case:\n\t\t{\n\t\t\tinput: `{\"key1\": \"value1\", \"key2\": 123}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseObject(tt.input, c, 0)\n\t\t\tif fmt.Sprintf(\"%v\", err) != fmt.Sprintf(\"%v\", tt.err) {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, want %v\", err, tt.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif s != tt.s {\n\t\t\t\tt.Errorf(\"parseObject() s = %s, want %s\", s, tt.s)\n\t\t\t}\n\t\t\tif got != nil \u0026\u0026 tt.want != nil \u0026\u0026 got.Type() == TypeObject \u0026\u0026 tt.want.Type() == TypeObject {\n\t\t\t\tif got.o.Len() != tt.want.o.Len() {\n\t\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t\t} else {\n\t\t\t\t\tfor j := 0; j \u003c got.o.Len(); j++ {\n\t\t\t\t\t\tif got.o.kvs[j].k != tt.want.o.kvs[j].k || got.o.kvs[j].v.String() != tt.want.o.kvs[j].v.String() {\n\t\t\t\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if got != nil \u0026\u0026 tt.want != nil {\n\t\t\t\tif got.String() != tt.want.String() {\n\t\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t\t}\n\t\t\t} else if (got != nil \u0026\u0026 tt.want == nil) || (got == nil \u0026\u0026 tt.want != nil) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","21fe26a1eb0ca3f4d414e14beec4b95b":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"raw string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"raw string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"12345\",\n\t\t\t},\n\t\t\twant: []byte(\"12345\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"[1,\\\"2\\\"]\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif string(got) != string(tt.want) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %v, want %v\", string(got), string(tt.want))\n\t\t\t}\n\t\t})\n\t}\n}","240bda3681d592206cdcef8ff7978b96":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tin         string\n\t\twantResult *Value\n\t\twantTail   string\n\t\twantErr    error\n\t}{\n\t\t// Empty object.\n\t\t{\n\t\t\tin:         \"{}\",\n\t\t\twantResult: \u0026Value{t: TypeObject, o: Object{}},\n\t\t\twantTail:   \"\",\n\t\t},\n\n\t\t// Simple object.\n\t\t{\n\t\t\tin: `{\"foo\": \"bar\"}`,\n\t\t\twantResult: \u0026Value{t: TypeObject, o: Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"foo\", v: \u0026Value{t: TypeString, s: \"bar\"}},\n\t\t\t\t},\n\t\t\t}},\n\t\t\twantTail: \"\",\n\t\t},\n\n\t\t// Missing closing bracket.\n\t\t{\n\t\t\tin:       `{\"foo\": \"bar\"`,\n\t\t\twantTail: `{\"foo\": \"bar\"`,\n\t\t\twantErr:  fmt.Errorf(\"missing '}'\"),\n\t\t},\n\n\t\t// Missing key.\n\t\t{\n\t\t\tin:       `{:\"bar\"}`,\n\t\t\twantTail: `{:\"bar\"}`,\n\t\t\twantErr:  fmt.Errorf(`cannot find opening '\"\" for object key`),\n\t\t},\n\n\t\t// Invalid key.\n\t\t{\n\t\t\tin:       `{invalid: \"bar\"}`,\n\t\t\twantTail: `{invalid: \"bar\"}`,\n\t\t\twantErr:  fmt.Errorf(\"cannot parse object key: invalid character 'i' looking for beginning of value\"),\n\t\t},\n\n\t\t// Missing colon.\n\t\t{\n\t\t\tin:       `{\"foo\" \"bar\"}`,\n\t\t\twantTail: `{\"foo\" \"bar\"}`,\n\t\t\twantErr:  fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\n\t\t// Missing comma.\n\t\t{\n\t\t\tin:       `{\"foo\":\"bar\" \"baz\":\"qux\"}`,\n\t\t\twantTail: `{\"foo\":\"bar\" \"baz\":\"qux\"}`,\n\t\t\twantErr:  fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\n\t\t// Trailing comma.\n\t\t{\n\t\t\tin:       `{\"foo\":\"bar\",}`,\n\t\t\twantTail: `{\"foo\":\"bar\",}`,\n\t\t\twantErr:  fmt.Errorf(\"unexpected end of object\"),\n\t\t},\n\n\t\t// Whitespace handling.\n\t\t{\n\t\t\tin: \" { \\n\\t\\\"foo\\\" \\n\\t: \\n\\t\\\"bar\\\"\\n\\t} \",\n\t\t\twantResult: \u0026Value{t: TypeObject, o: Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"foo\", v: \u0026Value{t: TypeString, s: \"bar\"}},\n\t\t\t\t},\n\t\t\t}},\n\t\t\twantTail: \"\",\n\t\t},\n\t}\n\n\tfor i, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgotResult, gotTail, gotErr := parseObject(test.in, c, 0)\n\n\t\t\tif gotErr != nil {\n\t\t\t\tif test.wantErr == nil {\n\t\t\t\t\tt.Errorf(\"unexpected error: %v\", gotErr)\n\t\t\t\t} else if gotErr.Error() != test.wantErr.Error() {\n\t\t\t\t\tt.Errorf(\"error mismatch: got %q, want %q\", gotErr, test.wantErr)\n\t\t\t\t}\n\t\t\t} else if test.wantErr != nil {\n\t\t\t\tt.Errorf(\"expected error, got nil\")\n\t\t\t}\n\n\t\t\tif gotTail != test.wantTail {\n\t\t\t\tt.Errorf(\"tail mismatch: got %q, want %q\", gotTail, test.wantTail)\n\t\t\t}\n\n\t\t\tif !equalValues(gotResult, test.wantResult) {\n\t\t\t\tt.Errorf(\"result mismatch:\\ngot  %+v\\nwant %+v\", gotResult, test.wantResult)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(a, b *Value) bool {\n\tif a == nil \u0026\u0026 b == nil {\n\t\treturn true\n\t}\n\tif a == nil || b == nil {\n\t\treturn false\n\t}\n\tif a.t != b.t {\n\t\treturn false\n\t}\n\tswitch a.t {\n\tcase TypeObject:\n\t\tif len(a.o.kvs) != len(b.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range a.o.kvs {\n\t\t\tif a.o.kvs[i].k != b.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(a.o.kvs[i].v, b.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeString:\n\t\treturn a.s == b.s\n\tdefault:\n\t\tpanic(fmt.Sprintf(\"unsupported type: %v\", a.t))\n\t}\n}","2442be74b57fe2079b5eff0a2bc0c33a":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Empty input.\n\t\t{\"\", nil, \"\", fmt.Errorf(\"cannot parse empty string\")},\n\t\t// Invalid JSON.\n\t\t{\"{\", nil, \"{\", fmt.Errorf(\"cannot parse object: missing '}'\")},\n\t\t// Simple object.\n\t\t{`{\"foo\": \"bar\"}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: typeRawString, s: \"bar\"}}}}}, \"\", nil},\n\t\t// Simple array.\n\t\t{`[1, \"two\", true]`, \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: typeRawString, s: \"two\"}, {t: TypeTrue}}}, \"\", nil},\n\t\t// String with escaped characters.\n\t\t{`\"hello\\nworld\"`, \u0026Value{t: typeRawString, s: \"hello\\nworld\"}, \"\", nil},\n\t\t// True boolean.\n\t\t{\"true\", valueTrue, \"\", nil},\n\t\t// False boolean.\n\t\t{\"false\", valueFalse, \"\", nil},\n\t\t// Null value.\n\t\t{\"null\", valueNull, \"\", nil},\n\t\t// Number.\n\t\t{\"12345\", \u0026Value{t: TypeNumber, s: \"12345\"}, \"\", nil},\n\t\t// Trailing whitespace.\n\t\t{`\"foo\" `, \u0026Value{t: typeRawString, s: \"foo\"}, \" \", nil},\n\t\t// NaN value.\n\t\t{\"NaN\", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"\", nil},\n\t}\n\n\tc := \u0026cache{}\n\tfor i, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tgot, tail, err := parseValue(test.input, c, 0)\n\n\t\t\tif test.err != nil {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"Expected error, got nil\")\n\t\t\t\t} else if err.Error() != test.err.Error() {\n\t\t\t\t\tt.Errorf(\"Expected error %q, got %q\", test.err, err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t\t}\n\t\t\tif tail != test.tail {\n\t\t\t\tt.Errorf(\"Expected tail %q, got %q\", test.tail, tail)\n\t\t\t}\n\t\t\tif !equalValues(got, test.want) {\n\t\t\t\tt.Errorf(\"Expected value %v, got %v\", test.want, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(a, b *Value) bool {\n\tif a == nil \u0026\u0026 b == nil {\n\t\treturn true\n\t}\n\tif a == nil || b == nil {\n\t\treturn false\n\t}\n\tif a.t != b.t {\n\t\treturn false\n\t}\n\tswitch a.t {\n\tcase typeRawString:\n\t\treturn a.s == b.s\n\tcase TypeNumber:\n\t\treturn a.s == b.s\n\tcase TypeObject:\n\t\tif len(a.o.kvs) != len(b.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range a.o.kvs {\n\t\t\tif a.o.kvs[i].k != b.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(a.o.kvs[i].v, b.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeArray:\n\t\tif len(a.a) != len(b.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range a.a {\n\t\t\tif !equalValues(a.a[i], b.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeTrue, TypeFalse, TypeNull:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}","2450389b1bc6ad67b7ef7b1235a62386":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey   string\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Basic cases.\n\t\t{`\"foo\"bar`, \"foo\", \"bar\", nil},\n\t\t{`\"fo\\o\"bar`, \"fo\\o\", \"bar\", nil},\n\t\t{`\"foo\"`, \"foo\", \"\", nil},\n\n\t\t// Escaped quotes.\n\t\t{`\"foo\\\"bar\"baz`, `foo\"bar`, \"baz\", nil},\n\t\t{`\"foo\\\\\\\"bar\"baz`, `foo\\\"bar`, \"baz\", nil},\n\t\t{`\"foo\\\\\\\\\"bar\"baz`, `foo\\\\`, `bar\"baz`, nil},\n\n\t\t// Missing closing quote.\n\t\t{`\"foobar`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo\\\"bar`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\n\t\t// Empty strings.\n\t\t{`\"\"bar`, \"\", \"bar\", nil},\n\t\t{`\"\"\"\"bar`, \"\", `\"bar`, nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tkey, tail, err := parseRawString(tt.input)\n\t\t\tif key != tt.key || tail != tt.tail || !equalError(err, tt.err) {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = (%q, %q, %v); want (%q, %q, %v)\", tt.input, key, tail, err, tt.key, tt.tail, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalError(e1, e2 error) bool {\n\tif e1 == nil \u0026\u0026 e2 == nil {\n\t\treturn true\n\t}\n\tif e1 == nil || e2 == nil {\n\t\treturn false\n\t}\n\treturn e1.Error() == e2.Error()\n}\n","2476caea5205f813f94d185bcf37165b":"package fastjson\n\nimport \"testing\"\n\nfunc TestValue_GetUint64(t *testing.T) {\n\tvar tests = []struct {\n\t\tname string\n\t\tjson string\n\t\tkeys []string\n\t\twant uint64\n\t}{\n\t\t{\n\t\t\tname: \"simple\",\n\t\t\tjson: `{\"foo\":1234}`,\n\t\t\tkeys: []string{\"foo\"},\n\t\t\twant: 1234,\n\t\t},\n\t\t{\n\t\t\tname: \"nested\",\n\t\t\tjson: `{\"bar\":{\"baz\":5678}}`,\n\t\t\tkeys: []string{\"bar\", \"baz\"},\n\t\t\twant: 5678,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tjson: `{\"qux\":[9101,1213]}`,\n\t\t\tkeys: []string{\"qux\", \"1\"},\n\t\t\twant: 1213,\n\t\t},\n\t\t{\n\t\t\tname: \"array decimal key\",\n\t\t\tjson: `{\"qux\":[9101,1213]}`,\n\t\t\tkeys: []string{\"qux\", \"0.0\"},\n\t\t\twant: 9101,\n\t\t},\n\t\t{\n\t\t\tname: \"non-existing key\",\n\t\t\tjson: `{\"foo\":1234}`,\n\t\t\tkeys: []string{\"bar\"},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid value type\",\n\t\t\tjson: `{\"foo\":\"string\"}`,\n\t\t\tkeys: []string{\"foo\"},\n\t\t\twant: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv, err := Parse(tt.json)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"error parsing json: %v\", err)\n\t\t\t}\n\t\t\tgot := v.GetUint64(tt.keys...)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"GetUint64(%v) = %v, want %v\", tt.keys, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","24aa5034a511785e1541e0d1a6b12b78":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestValue_Uint(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  uint\n\t\terr   error\n\t}{\n\t\t{\n\t\t\tinput: \"123\",\n\t\t\twant:  123,\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: \"-123\",\n\t\t\twant:  0,\n\t\t\terr:   fmt.Errorf(\"number \\\"-123\\\" doesn't fit uint\"),\n\t\t},\n\t\t{\n\t\t\tinput: \"9223372036854775808\", // MaxUint64 + 1\n\t\t\twant:  0,\n\t\t\terr:   fmt.Errorf(\"number \\\"9223372036854775808\\\" doesn't fit uint\"),\n\t\t},\n\t\t{\n\t\t\tinput: \"18446744073709551615\", // MaxUint64\n\t\t\twant:  18446744073709551615,\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `\"123\"`,\n\t\t\twant:  0,\n\t\t\terr:   fmt.Errorf(\"value doesn't contain number; it contains string\"),\n\t\t},\n\t\t{\n\t\t\tinput: \"null\",\n\t\t\twant:  0,\n\t\t\terr:   fmt.Errorf(\"value doesn't contain number; it contains null\"),\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tv := \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: tt.input,\n\t\t\t}\n\t\t\tgot, err := v.Uint()\n\t\t\tif fmt.Sprintf(\"%v\", err) != fmt.Sprintf(\"%v\", tt.err) {\n\t\t\t\tt.Errorf(\"error mismatch, got: %v, want: %v\", err, tt.err)\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"value mismatch, got: %v, want: %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","24e116bdb8eb228efbb3cb4d39692562":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Empty string.\n\t\t{\"\", nil, \"\", fmt.Errorf(\"cannot parse empty string\")},\n\t\t// Invalid JSON.\n\t\t{\"{\", nil, \"{\", fmt.Errorf(\"cannot parse object: unexpected end of JSON\")},\n\t\t// Object.\n\t\t{`{\"foo\": \"bar\"}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: typeRawString, s: \"bar\"}}}}}, \"\", nil},\n\t\t// Array.\n\t\t{`[1, \"foo\"]`, \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: typeRawString, s: \"foo\"}}}, \"\", nil},\n\t\t// String.\n\t\t{`\"foo\"`, \u0026Value{t: typeRawString, s: \"foo\"}, \"\", nil},\n\t\t// True.\n\t\t{\"true\", valueTrue, \"\", nil},\n\t\t// False.\n\t\t{\"false\", valueFalse, \"\", nil},\n\t\t// Null.\n\t\t{\"null\", valueNull, \"\", nil},\n\t\t// Number.\n\t\t{\"123\", \u0026Value{t: TypeNumber, s: \"123\"}, \"\", nil},\n\t\t// NaN.\n\t\t{\"NaN\", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"\", nil},\n\t\t// Trailing space.\n\t\t{`\"foo\" `, \u0026Value{t: typeRawString, s: \"foo\"}, \" \", nil},\n\t}\n\tc := \u0026cache{}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tgot, tail, err := parseValue(tt.input, c, 0)\n\t\t\tif (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, wantErr %v\", tt.input, err, tt.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"parseValue(%q) tail = %q, wantTail %q\", tt.input, tail, tt.tail)\n\t\t\t}\n\t\t\tif got == nil \u0026\u0026 tt.want == nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got == nil || tt.want == nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) got = %v, want %v\", tt.input, got, tt.want)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got.t != tt.want.t {\n\t\t\t\tt.Errorf(\"parseValue(%q) got type = %v, want type %v\", tt.input, got.t, tt.want.t)\n\t\t\t}\n\t\t\tif got.s != tt.want.s {\n\t\t\t\tt.Errorf(\"parseValue(%q) got string = %q, want string %q\", tt.input, got.s, tt.want.s)\n\t\t\t}\n\t\t\tif got.t == TypeObject \u0026\u0026 !testEqualObject(\u0026got.o, \u0026tt.want.o) {\n\t\t\t\tt.Errorf(\"parseValue(%q) got object = %v, want object %v\", tt.input, got.o, tt.want.o)\n\t\t\t}\n\t\t\tif got.t == TypeArray \u0026\u0026 !testEqualArray(got.a, tt.want.a) {\n\t\t\t\tt.Errorf(\"parseValue(%q) got array = %v, want array %v\", tt.input, got.a, tt.want.a)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc testEqualObject(o1, o2 *Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i := range o1.kvs {\n\t\tif o1.kvs[i].k != o2.kvs[i].k {\n\t\t\treturn false\n\t\t}\n\t\tif !testEqualValue(o1.kvs[i].v, o2.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc testEqualArray(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i := range a1 {\n\t\tif !testEqualValue(a1[i], a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc testEqualValue(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.s != v2.s {\n\t\treturn false\n\t}\n\tif v1.t == TypeObject \u0026\u0026 !testEqualObject(\u0026v1.o, \u0026v2.o) {\n\t\treturn false\n\t}\n\tif v1.t == TypeArray \u0026\u0026 !testEqualArray(v1.a, v2.a) {\n\t\treturn false\n\t}\n\treturn true\n}\n","24f6ab7fa227301c86006c63fd2bf228":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Get(t *testing.T) {\n\tt.Run(\"object\", func(t *testing.T) {\n\t\tvar v Value\n\t\tv.t = TypeObject\n\t\tv.o.kvs = []kv{\n\t\t\t{\"a\", \u0026Value{t: TypeString, s: \"b\"}},\n\t\t\t{\"c\", \u0026Value{t: TypeNumber, s: \"1.2\"}},\n\t\t\t{\"d\", \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t{\"e\", \u0026Value{t: TypeString, s: \"f\"}},\n\t\t\t}}}},\n\t\t}\n\n\t\ttests := []struct {\n\t\t\tkeys   []string\n\t\t\texpect *Value\n\t\t}{\n\t\t\t{[]string{\"a\"}, \u0026Value{t: TypeString, s: \"b\"}},\n\t\t\t{[]string{\"c\"}, \u0026Value{t: TypeNumber, s: \"1.2\"}},\n\t\t\t{[]string{\"d\"}, \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t{\"e\", \u0026Value{t: TypeString, s: \"f\"}},\n\t\t\t}}}},\n\t\t\t{[]string{\"d\", \"e\"}, \u0026Value{t: TypeString, s: \"f\"}},\n\t\t\t{[]string{\"x\"}, nil},\n\t\t\t{[]string{\"d\", \"x\"}, nil},\n\t\t}\n\t\tfor _, test := range tests {\n\t\t\tval := v.Get(test.keys...)\n\t\t\tif test.expect == nil {\n\t\t\t\tif val != nil {\n\t\t\t\t\tt.Errorf(\"Expect nil, got %v\", val)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif val == nil {\n\t\t\t\t\tt.Errorf(\"Expect %v, got nil\", test.expect)\n\t\t\t\t} else if val.Type() != test.expect.Type() {\n\t\t\t\t\tt.Errorf(\"Expect type %v, got %v\", test.expect.Type(), val.Type())\n\t\t\t\t} else if val.Type() == TypeString \u0026\u0026 val.s != test.expect.s {\n\t\t\t\t\tt.Errorf(\"Expect %q, got %q\", test.expect.s, val.s)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"array\", func(t *testing.T) {\n\t\tvar v Value\n\t\tv.t = TypeArray\n\t\tv.a = []*Value{\n\t\t\t{t: TypeString, s: \"a\"},\n\t\t\t{t: TypeNumber, s: \"1.2\"},\n\t\t\t{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t{\"a\", \u0026Value{t: TypeString, s: \"b\"}},\n\t\t\t}}},\n\t\t}\n\n\t\ttests := []struct {\n\t\t\tkeys   []string\n\t\t\texpect *Value\n\t\t}{\n\t\t\t{[]string{\"0\"}, \u0026Value{t: TypeString, s: \"a\"}},\n\t\t\t{[]string{\"1\"}, \u0026Value{t: TypeNumber, s: \"1.2\"}},\n\t\t\t{[]string{\"2\"}, \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t{\"a\", \u0026Value{t: TypeString, s: \"b\"}},\n\t\t\t}}}},\n\t\t\t{[]string{\"2\", \"a\"}, \u0026Value{t: TypeString, s: \"b\"}},\n\t\t\t{[]string{\"3\"}, nil},\n\t\t\t{[]string{\"2\", \"x\"}, nil},\n\t\t}\n\t\tfor _, test := range tests {\n\t\t\tval := v.Get(test.keys...)\n\t\t\tif test.expect == nil {\n\t\t\t\tif val != nil {\n\t\t\t\t\tt.Errorf(\"Expect nil, got %v\", val)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif val == nil {\n\t\t\t\t\tt.Errorf(\"Expect %v, got nil\", test.expect)\n\t\t\t\t} else if val.Type() != test.expect.Type() {\n\t\t\t\t\tt.Errorf(\"Expect type %v, got %v\", test.expect.Type(), val.Type())\n\t\t\t\t} else if val.Type() == TypeString \u0026\u0026 val.s != test.expect.s {\n\t\t\t\t\tt.Errorf(\"Expect %q, got %q\", test.expect.s, val.s)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"invalid\", func(t *testing.T) {\n\t\tvar v Value\n\t\tv.t = TypeString\n\t\tv.s = \"abc\"\n\n\t\tif val := v.Get(\"a\"); val != nil {\n\t\t\tt.Errorf(\"Expect nil, got %v\", val)\n\t\t}\n\t})\n}","2571a7638b76ad2d74e4411f384573ac":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\ttests := []struct {\n\t\tinput       string\n\t\twantJSON    string\n\t\twantErr     bool\n\t\twantValue   interface{}\n\t\twantValueStr string\n\t}{\n\t\t// Add your test cases here\n\t\t{\n\t\t\tinput:       `{\"key\": \"value\"}`,\n\t\t\twantJSON:    `{\"key\":\"value\"}`,\n\t\t\twantErr:     false,\n\t\t\twantValue:   map[string]interface{}{\"key\": \"value\"},\n\t\t\twantValueStr: `{\"key\":\"value\"}`,\n\t\t},\n\t\t{\n\t\t\tinput:       `[1, 2, 3]`,\n\t\t\twantJSON:    `[1,2,3]`,\n\t\t\twantErr:     false,\n\t\t\twantValue:   []interface{}{float64(1), float64(2), float64(3)},\n\t\t\twantValueStr: `[1,2,3]`,\n\t\t},\n\t\t{\n\t\t\tinput:       `\"hello world\"`,\n\t\t\twantJSON:    `\"hello world\"`,\n\t\t\twantErr:     false,\n\t\t\twantValue:   \"hello world\",\n\t\t\twantValueStr: `\"hello world\"`,\n\t\t},\n\t\t// Add more test cases for various JSON inputs and expected values\n\t}\n\n\tfor i, tt := range tests {\n\t\tp := Parser{}\n\t\tgot, err := p.Parse(tt.input)\n\t\tif (err != nil) != tt.wantErr {\n\t\t\tt.Errorf(\"Test %d: Parse() error = %v, wantErr %v\", i, err, tt.wantErr)\n\t\t\tcontinue\n\t\t}\n\t\tif tt.wantErr {\n\t\t\tcontinue\n\t\t}\n\t\tif got == nil {\n\t\t\tt.Errorf(\"Test %d: Parse() returned nil value\", i)\n\t\t\tcontinue\n\t\t}\n\n\t\tgotJSON := got.MarshalTo(nil)\n\t\tif string(gotJSON) != tt.wantJSON {\n\t\t\tt.Errorf(\"Test %d: got JSON %q, want %q\", i, gotJSON, tt.wantJSON)\n\t\t}\n\n\t\t// You may need to write custom comparison logic for your wantValue\n\t\t// depending on the complexity of the data structures.\n\t}\n}","2598149e38f0e0fe920438f700e84475":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ts     string\n\t\terr   error\n\t}{\n\t\t// Empty object.\n\t\t{\n\t\t\tinput: \"{}\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Single key-value pair.\n\t\t{\n\t\t\tinput: `{\"key\": \"value\"}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: \u0026Value{t: TypeString, s: \"value\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Multiple key-value pairs.\n\t\t{\n\t\t\tinput: `{\"key1\": \"value1\", \"key2\": 123, \"key3\": true}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t\t{k: \"key3\", v: \u0026Value{t: TypeTrue}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Nested objects.\n\t\t{\n\t\t\tinput: `{\"key1\": {\"key2\": \"value2\"}, \"key3\": \"value3\"}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{k: \"key3\", v: \u0026Value{t: TypeString, s: \"value3\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// With whitespace.\n\t\t{\n\t\t\tinput: \" { \\\"key\\\" : \\\"value\\\" } \",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: \u0026Value{t: TypeString, s: \"value\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \" \",\n\t\t\terr: nil,\n\t\t},\n\t\t// Invalid JSON.\n\t\t{\n\t\t\tinput: `{\"key\": \"value\"`,\n\t\t\twant:  nil,\n\t\t\ts:     `{\"key\": \"value\"`,\n\t\t\terr:   fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t\t// Missing colon.\n\t\t{\n\t\t\tinput: `{\"key\" \"value\"}`,\n\t\t\twant:  nil,\n\t\t\ts:     `\"value\"}`,\n\t\t\terr:   fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t\t// Missing comma.\n\t\t{\n\t\t\tinput: `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twant:  nil,\n\t\t\ts:     `\"key2\": \"value2\"}`,\n\t\t\terr:   fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseObject(tt.input, c, 0)\n\t\t\tif (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif s != tt.s {\n\t\t\t\tt.Errorf(\"parseObject() s = %s, want %s\", s, tt.s)\n\t\t\t}\n\t\t\tif got == nil \u0026\u0026 tt.want == nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got.t != tt.want.t {\n\t\t\t\tt.Errorf(\"parseObject() got type = %v, want %v\", got.t, tt.want.t)\n\t\t\t}\n\t\t\tif got.o.Len() != tt.want.o.Len() {\n\t\t\t\tt.Errorf(\"parseObject() got len = %v, want %v\", got.o.Len(), tt.want.o.Len())\n\t\t\t}\n\t\t\tfor j := 0; j \u003c got.o.Len(); j++ {\n\t\t\t\tif got.o.kvs[j].k != tt.want.o.kvs[j].k {\n\t\t\t\t\tt.Errorf(\"parseObject() got key = %s, want %s\", got.o.kvs[j].k, tt.want.o.kvs[j].k)\n\t\t\t\t}\n\t\t\t\tif got.o.kvs[j].v.t != tt.want.o.kvs[j].v.t {\n\t\t\t\t\tt.Errorf(\"parseObject() got value type = %v, want %v\", got.o.kvs[j].v.t, tt.want.o.kvs[j].v.t)\n\t\t\t\t}\n\t\t\t\tif got.o.kvs[j].v.s != tt.want.o.kvs[j].v.s {\n\t\t\t\t\tt.Errorf(\"parseObject() got value = %s, want %s\", got.o.kvs[j].v.s, tt.want.o.kvs[j].v.s)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n","25f24fcc36cc60aec68c7ede89d509c3":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantN    string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Valid numbers\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"123.456\", \"123.456\", \"\", nil},\n\t\t{\"1.2e3\", \"1.2e3\", \"\", nil},\n\t\t{\"1.2E+3\", \"1.2E+3\", \"\", nil},\n\t\t{\"-1.2e-3\", \"-1.2e-3\", \"\", nil},\n\n\t\t// Valid numbers with trailing characters\n\t\t{\"123a\", \"123\", \"a\", nil},\n\t\t{\"-123 \", \"-123\", \" \", nil},\n\t\t{\"123.456,\", \"123.456\", \",\", nil},\n\n\t\t// Valid inf/nan\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"+Inf\", \"+Inf\", \"\", nil},\n\t\t{\"-INFINITY\", \"-INFINITY\", \"\", nil},\n\t\t{\"nAn\", \"nAn\", \"\", nil},\n\n\t\t// Invalid numbers\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t\t{\"a\", \"\", \"a\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\"+a\", \"\", \"+a\", fmt.Errorf(\"unexpected char: %q\", \"+a\")},\n\t\t{\"-b\", \"\", \"-b\", fmt.Errorf(\"unexpected char: %q\", \"-b\")},\n\t\t{\"1.2e\", \"\", \"1.2e\", nil},\n\t\t{\"in\", \"\", \"in\", nil},\n\t\t{\"+infini\", \"\", \"+infini\", nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tgotN, gotTail, gotErr := parseRawNumber(tt.input)\n\t\t\tif gotN != tt.wantN {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got number = %q, want %q\", tt.input, gotN, tt.wantN)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got tail = %q, want %q\", tt.input, gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif gotErr == nil \u0026\u0026 tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got no error, want %v\", tt.input, tt.wantErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr == nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got error = %v, want no error\", tt.input, gotErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got error = %v, want %v\", tt.input, gotErr, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}\n","2611c8b38fe13525416c8e88ca98ba23":"package fastjson\n\nimport \"testing\"\n\nfunc TestSkipWS(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Test cases for strings with leading whitespace.\n\t\t{\"  foo\", \"foo\"},\n\t\t{\"\\n\\tbar\", \"bar\"},\n\t\t{\"\\r \\tfoobar\", \"foobar\"},\n\n\t\t// Test cases for strings without leading whitespace.\n\t\t{\"baz\", \"baz\"},\n\t\t{\"qux \", \"qux \"},\n\t\t{\" foobar \", \"foobar \"},\n\t}\n\n\tfor i, tt := range tests {\n\t\tactual := skipWS(tt.input)\n\t\tif actual != tt.expected {\n\t\t\tt.Errorf(\"Test case %d: Expected '%s', but got '%s'\", i, tt.expected, actual)\n\t\t}\n\t}\n}\n","26212585ff2cf80f2aa004def4351ae6":"package fastjson\n\nimport \"testing\"\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tt    Type\n\t\twant string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\tfor i, tt := range tests {\n\t\tgot := tt.t.String()\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"test %d: String() = %q; want %q\", i, got, tt.want)\n\t\t}\n\t}\n}","264992c214c752cc47b58bbf20058423":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twant     *Value\n\t\twantRest string\n\t\twantErr  error\n\t}{\n\t\t{\n\t\t\tname:     \"empty object\",\n\t\t\tinput:    \"{}\",\n\t\t\twant:     \u0026Value{t: TypeObject, o: Object{}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"single key-value pair\",\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\twant:     \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{t: TypeString, s: \"value\"}}}}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple key-value pairs\",\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\twant: \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}},\n\t\t\t}}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"nested object\",\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": {\"nestedKey\": \"nestedValue\"}}`,\n\t\t\twant: \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"nestedKey\", v: \u0026Value{t: TypeString, s: \"nestedValue\"}}}}}},\n\t\t\t}}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing '}'\",\n\t\t\tinput:    `{\"key\": \"value\"`,\n\t\t\twant:     nil,\n\t\t\twantRest: \"\",\n\t\t\twantErr:  fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"missing ':' after object key\",\n\t\t\tinput:    `{\"key\" \"value\"}`,\n\t\t\twant:     nil,\n\t\t\twantRest: \"\",\n\t\t\twantErr:  fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"missing ',' after object value\",\n\t\t\tinput:    `{\"key\": \"value\" \"key2\": \"value2\"}`,\n\t\t\twant:     nil,\n\t\t\twantRest: \"\",\n\t\t\twantErr:  fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, rest, err := parseObject(tt.input, c, 0)\n\n\t\t\tif (err != nil \u0026\u0026 tt.wantErr == nil) || (err == nil \u0026\u0026 tt.wantErr != nil) || (err != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 err.Error() != tt.wantErr.Error()) {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif rest != tt.wantRest {\n\t\t\t\tt.Errorf(\"parseObject() rest = %v, wantRest %v\", rest, tt.wantRest)\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}","26e7b14d9c8c2b77c7f3fa7a3edd517c":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Test cases here\n\t\t{\n\t\t\tinput: `{}`,\n\t\t\twant:  \u0026Value{t: TypeObject},\n\t\t\ttail:  \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `[]`,\n\t\t\twant:  \u0026Value{t: TypeArray},\n\t\t\ttail:  \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `\"test\"`,\n\t\t\twant:  \u0026Value{t: typeRawString, s: \"test\"},\n\t\t\ttail:  \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `true`,\n\t\t\twant:  valueTrue,\n\t\t\ttail:  \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `false`,\n\t\t\twant:  valueFalse,\n\t\t\ttail:  \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `null`,\n\t\t\twant:  valueNull,\n\t\t\ttail:  \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `123`,\n\t\t\twant:  \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\ttail:  \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `123.456`,\n\t\t\twant:  \u0026Value{t: TypeNumber, s: \"123.456\"},\n\t\t\ttail:  \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `-123`,\n\t\t\twant:  \u0026Value{t: TypeNumber, s: \"-123\"},\n\t\t\ttail:  \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `\"test\"xxx`,\n\t\t\twant:  \u0026Value{t: typeRawString, s: \"test\"},\n\t\t\ttail:  \"xxx\",\n\t\t\terr:   nil,\n\t\t},\n\t\t// Error cases\n\t\t{\n\t\t\tinput: ``,\n\t\t\twant:  nil,\n\t\t\ttail:  \"\",\n\t\t\terr:   fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tinput: `{`,\n\t\t\twant:  nil,\n\t\t\ttail:  \"{\",\n\t\t\terr:   fmt.Errorf(\"cannot parse object: missing '}'\"),\n\t\t},\n\t\t{\n\t\t\tinput: `[`,\n\t\t\twant:  nil,\n\t\t\ttail:  \"[\",\n\t\t\terr:   fmt.Errorf(\"cannot parse array: missing ']'\"),\n\t\t},\n\t\t{\n\t\t\tinput: `\"test`,\n\t\t\twant:  nil,\n\t\t\ttail:  `\"test`,\n\t\t\terr:   fmt.Errorf(\"cannot parse string: missing '\\\"'\"),\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, tail, err := parseValue(tt.input, c, 0)\n\n\t\t\tif tt.err != nil {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"Expected error, got nil\")\n\t\t\t\t} else if err.Error() != tt.err.Error() {\n\t\t\t\t\tt.Errorf(\"Expected error %v, got %v\", tt.err, err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"Expected tail %q, got %q\", tt.tail, tail)\n\t\t\t}\n\n\t\t\tif got == nil \u0026\u0026 tt.want == nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got == nil \u0026\u0026 tt.want != nil {\n\t\t\t\tt.Errorf(\"Expected value %v, got nil\", tt.want)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != nil \u0026\u0026 tt.want == nil {\n\t\t\t\tt.Errorf(\"Expected nil, got %v\", got)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got.t != tt.want.t {\n\t\t\t\tt.Errorf(\"Expected type %v, got %v\", tt.want.t, got.t)\n\t\t\t}\n\t\t\tif got.s != tt.want.s {\n\t\t\t\tt.Errorf(\"Expected string %q, got %q\", tt.want.s, got.s)\n\t\t\t}\n\t\t})\n\t}\n}\n","272c0c6a1e68be2b97a6035d445c2919":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic escapes\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\t`, \"\\t\"},\n\t\t{`\\\\`, \"\\\\\"},\n\t\t{`\\\"`, \"\\\"\"},\n\t\t{`\\/`, \"/\"},\n\n\t\t// Unicode escapes\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A0`, \"\\u00A0\"},\n\t\t{`\\u20AC`, \"\\u20AC\"},\n\t\t{`\\uD83D\\uDE01`, \"\\U0001F601\"}, // Surrogate pair\n\n\t\t// Invalid escapes\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\uD800`, `\\uD800`}, // Unpaired surrogate\n\n\t\t// Mixed content\n\t\t{`Hello\\tworld\\n`, \"Hello\\tworld\\n\"},\n\t\t{`\"This is a string with \\\\backslashes\\\\ and \\nnewlines\\n\"`, \"\\\"This is a string with \\\\backslashes\\\\ and \\nnewlines\\n\\\"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}\n","27cd5aa55d8e553f006c9edbd010abf8":"package fastjson\n\nimport \"testing\"\n\nfunc Test_hasSpecialChars(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    string\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"Empty String\",\n\t\t\ts:    \"\",\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Simple String\",\n\t\t\ts:    \"hello\",\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"String with space\",\n\t\t\ts:    \"hello world\",\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"String with double quote\",\n\t\t\ts:    \"hello\\\"world\",\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"String with backslash\",\n\t\t\ts:    \"hello\\\\world\",\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"String with control character\",\n\t\t\ts:    \"hello\\nworld\",\n\t\t\twant: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := hasSpecialChars(tt.s); got != tt.want {\n\t\t\t\tt.Errorf(\"hasSpecialChars() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","2806f695f214a4e8dff15db27c43a129":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantObj  string\n\t\twantTail string\n\t\twantErr  string\n\t}{\n\t\t{\n\t\t\tname:     \"empty object\",\n\t\t\tinput:    \"{}\",\n\t\t\twantObj:  `{\"t\":1}`,\n\t\t\twantTail: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"single key-value\",\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\twantObj:  `{\"t\":1,\"o\":{\"kvs\":[{\"k\":\"key\",\"v\":{\"t\":3,\"s\":\"value\"}}]}}`,\n\t\t\twantTail: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple key-values\",\n\t\t\tinput:    `{\"key1\":\"value1\", \"key2\":\"value2\"}`,\n\t\t\twantObj:  `{\"t\":1,\"o\":{\"kvs\":[{\"k\":\"key1\",\"v\":{\"t\":3,\"s\":\"value1\"}},{\"k\":\"key2\",\"v\":{\"t\":3,\"s\":\"value2\"}}]}}`,\n\t\t\twantTail: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"nested object\",\n\t\t\tinput:    `{\"key1\":{\"key2\":\"value2\"}}`,\n\t\t\twantObj:  `{\"t\":1,\"o\":{\"kvs\":[{\"k\":\"key1\",\"v\":{\"t\":1,\"o\":{\"kvs\":[{\"k\":\"key2\",\"v\":{\"t\":3,\"s\":\"value2\"}}]}}}]}}`,\n\t\t\twantTail: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"missing closing brace\",\n\t\t\tinput:    `{\"key\":\"value\"`,\n\t\t\twantErr:  \"missing '}'\",\n\t\t\twantTail: `{\"key\":\"value\"`,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing colon\",\n\t\t\tinput:    `{\"key\"\"value\"}`,\n\t\t\twantErr:  \"missing ':' after object key\",\n\t\t\twantTail: `\"value\"}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing comma\",\n\t\t\tinput:    `{\"key1\":\"value1\" \"key2\":\"value2\"}`,\n\t\t\twantErr:  \"missing ',' after object value\",\n\t\t\twantTail: ` \"key2\":\"value2\"}`,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, tail, err := parseObject(tt.input, c, 0)\n\t\t\tif tt.wantErr != \"\" {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"parseObject() error = nil, wantErr %v\", tt.wantErr)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif err.Error() != tt.wantErr {\n\t\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr nil\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got == nil {\n\t\t\t\tt.Errorf(\"parseObject() got = nil, want not nil\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgotStr := fmt.Sprintf(\"%v\", *got)\n\t\t\tif gotStr != tt.wantObj {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", gotStr, tt.wantObj)\n\t\t\t}\n\t\t\tif tail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseObject() tail = %v, want %v\", tail, tt.wantTail)\n\t\t\t}\n\t\t})\n\t}\n}\n","297412639b832349e7f5ce6fcb4c4db4":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantStr  string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Basic cases\n\t\t{`\"hello\"world`, \"hello\", `world`, nil},\n\t\t{`\"hello\"`, \"hello\", \"\", nil},\n\t\t{`\"\"world`, \"\", `world`, nil},\n\n\t\t// Escaped quotes\n\t\t{`\"\\\\\"world`, `\\`, `world`, nil},\n\t\t{`\"\\\\\\\"\"world`, `\\\"`, `world`, nil},\n\t\t{`\"hello\\\\\"world`, `hello\\`, `world`, nil},\n\t\t{`\"hello\\\\\\\\\"world`, `hello\\\\`, `world`, nil},\n\n\t\t// Missing closing quote\n\t\t{`\"hello world`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"hello\\`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"\\\\world`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tgotStr, gotTail, gotErr := parseRawString(tt.input)\n\t\t\tif gotStr != tt.wantStr {\n\t\t\t\tt.Errorf(\"parseRawString(%q) got str = %q, want %q\", tt.input, gotStr, tt.wantStr)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseRawString(%q) got tail = %q, want %q\", tt.input, gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif gotErr != nil \u0026\u0026 tt.wantErr == nil {\n\t\t\t\tt.Errorf(\"parseRawString(%q) got unexpected error: %v\", tt.input, gotErr)\n\t\t\t} else if gotErr == nil \u0026\u0026 tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"parseRawString(%q) want error %v, got nil\", tt.input, tt.wantErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"parseRawString(%q) got error %v, want %v\", tt.input, gotErr, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","297a10288aca5d542180707ce840f7cb":"package fastjson\n\nimport \"testing\"\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"\", \"\"},\n\t\t{\"   abc\", \"abc\"},\n\t\t{\"\\t\\t\\tdef\", \"def\"},\n\t\t{\"\\n\\n\\nghi\", \"ghi\"},\n\t\t{\"\\r\\r\\rjkl\", \"jkl\"},\n\t\t{\" \\t\\n\\rabc\", \"abc\"},\n\t\t{\"abc \\t\\n\\r\", \"abc \\t\\n\\r\"},\n\t\t{\"abc\", \"abc\"},\n\t\t{\"\\x00abc\", \"\\x00abc\"},\n\t}\n\tfor i, tt := range tests {\n\t\tactual := skipWSSlow(tt.input)\n\t\tif actual != tt.expected {\n\t\t\tt.Errorf(\"Test %d: Expected '%s', but got '%s'\", i, tt.expected, actual)\n\t\t}\n\t}\n}","2ac68ec39b10b3df95bc31cb624004c3":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twant     *Value\n\t\twantRest string\n\t\twantErr  error\n\t}{\n\t\t{\n\t\t\tname:     \"empty array\",\n\t\t\tinput:    \"[]\",\n\t\t\twant:     \u0026Value{t: TypeArray},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"single element array\",\n\t\t\tinput:    \"[1]\",\n\t\t\twant:     \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple elements array\",\n\t\t\tinput:    \"[1,2,3]\",\n\t\t\twant:     \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with spaces\",\n\t\t\tinput:    \" [ 1 , 2 , 3 ] \",\n\t\t\twant:     \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}},\n\t\t\twantRest: \" \",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"nested array\",\n\t\t\tinput:    \"[[1,2],[3,4]]\",\n\t\t\twant: \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}}},\n\t\t\t\t{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"3\"}, {t: TypeNumber, s: \"4\"}}},\n\t\t\t}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing ]\",\n\t\t\tinput:    \"[1,2\",\n\t\t\twant:     nil,\n\t\t\twantRest: \"\",\n\t\t\twantErr:  fmt.Errorf(\"unexpected end of array\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"missing ,\",\n\t\t\tinput:    \"[1 2]\",\n\t\t\twant:     nil,\n\t\t\twantRest: \" 2]\",\n\t\t\twantErr:  fmt.Errorf(\"missing ',' after array value\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, rest, err := parseArray(tt.input, c, 0)\n\t\t\tif (err != nil \u0026\u0026 tt.wantErr == nil) || (err == nil \u0026\u0026 tt.wantErr != nil) || (err != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 err.Error() != tt.wantErr.Error()) {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif rest != tt.wantRest {\n\t\t\t\tt.Errorf(\"parseArray() rest = %v, wantRest %v\", rest, tt.wantRest)\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.t == TypeArray {\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\treturn v1.s == v2.s\n}","2ad93eb098464d4bf66381bf823da026":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Get(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tjson  string\n\t\tkeys  []string\n\t\twant  *Value\n\t\twant1 bool\n\t}{\n\t\t{\n\t\t\tname:  \"object\",\n\t\t\tjson:  `{\"foo\":{\"bar\":\"baz\"}}`,\n\t\t\tkeys:  []string{\"foo\", \"bar\"},\n\t\t\twant:  \u0026Value{t: TypeString, s: \"baz\"},\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array\",\n\t\t\tjson:  `[1,2,3]`,\n\t\t\tkeys:  []string{\"1\"},\n\t\t\twant:  \u0026Value{t: TypeNumber, s: \"2\"},\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object_not_found\",\n\t\t\tjson:  `{\"foo\":{\"bar\":\"baz\"}}`,\n\t\t\tkeys:  []string{\"foo\", \"baz\"},\n\t\t\twant:  nil,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array_not_found\",\n\t\t\tjson:  `[1,2,3]`,\n\t\t\tkeys:  []string{\"5\"},\n\t\t\twant:  nil,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array_invalid_index\",\n\t\t\tjson:  `[1,2,3]`,\n\t\t\tkeys:  []string{\"foo\"},\n\t\t\twant:  nil,\n\t\t\twant1: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv, _ := Parse(tt.json)\n\t\t\tgot := v.Get(tt.keys...)\n\t\t\tif got == nil \u0026\u0026 tt.want == nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got.Type() != tt.want.Type() || got.String() != tt.want.String() {\n\t\t\t\tt.Errorf(\"Get() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","2ae0ecdcd56d387cccfbe4e2f5863e58":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc Test_unescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"simple\",\n\t\t\targs: args{\n\t\t\t\ts: `\\n\\\\\\\"\\r\\t\\b\\f\\/`,\n\t\t\t},\n\t\t\twant: \"\\n\\\\\\\"\\r\\t\\b\\f/\",\n\t\t},\n\t\t{\n\t\t\tname: \"unicode\",\n\t\t\targs: args{\n\t\t\t\ts: `\\u0020\\u00A2\\u20AC`,\n\t\t\t},\n\t\t\twant: \" \\u00A2‚Ç¨\",\n\t\t},\n\t\t{\n\t\t\tname: \"surrogate\",\n\t\t\targs: args{\n\t\t\t\ts: `\\uD83D\\uDE02`,\n\t\t\t},\n\t\t\twant: \"üòÇ\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","2cb611f73ab55538a6a679daf9e960b9":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic strings without escape sequences.\n\t\t{\"hello\", \"hello\"},\n\t\t{\"world\", \"world\"},\n\t\t{\"\", \"\"},\n\n\t\t// Simple escape sequences.\n\t\t{`\\\"`, `\"`},\n\t\t{`\\\\`, `\\`},\n\t\t{`\\/`, `/`},\n\t\t{`\\b`, \"\\b\"},\n\t\t{`\\f`, \"\\f\"},\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\r`, \"\\r\"},\n\t\t{`\\t`, \"\\t\"},\n\n\t\t// Unicode escape sequences.\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A9`, \"¬©\"},\n\t\t{`\\u20AC`, \"‚Ç¨\"},\n\t\t{\"\\\\u20aC\", \"\\\\u20aC\"}, // Invalid - lower case 'c'\n\t\t{\"\\\\u20ACx\", \"\\\\u20ACx\"}, // Valid prefix, but should stop parsing at x\n\n\t\t// Handling of invalid escape sequences.\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\u123g`, `\\u123g`},\n\n\t\t// Combining multiple escape sequences.\n\t\t{`\\r\\n`, \"\\r\\n\"},\n\t\t{`Hello\\tWorld!`, \"Hello\\tWorld!\"},\n\t\t{`\"This is a \\\\\"test\\\\\" string.\"`, `\"This is a \"test\" string.\"`},\n\n\t\t// Surrogate pairs\n\t\t{`\\uD83D\\uDE01\", \"üòÅ`,\n\t\t{`\\uD800\\uDC00`, \"\\U00010000\"},\n\t\t{`a\\uD800b\\uDC00c`, \"a\\U00010000c\"},\n\t\t{`a\\uD800\\uDC00c`, \"a\\U00010000c\"},\n\t}\n\n\tfor i, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Test %d failed: Input: %q, Expected: %q, Got: %q\", i+1, test.input, test.expected, actual)\n\t\t}\n\t}\n}","2cbc97769b8869a07f477d36c29e51d9":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tt.Run(\"empty string\", func(t *testing.T) {\n\t\tc := \u0026cache{}\n\t\t_, _, err := parseValue(\"\", c, 0)\n\t\tif err == nil {\n\t\t\tt.Errorf(\"Expected error for empty string\")\n\t\t}\n\t})\n\n\tt.Run(\"object\", func(t *testing.T) {\n\t\tc := \u0026cache{}\n\t\tv, tail, err := parseValue(`{\"foo\":\"bar\"}`, c, 0)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t}\n\t\tif tail != \"\" {\n\t\t\tt.Errorf(\"Unexpected tail: %q\", tail)\n\t\t}\n\t\tif v.t != TypeObject {\n\t\t\tt.Errorf(\"Expected object, got %v\", v.t)\n\t\t}\n\t})\n\n\tt.Run(\"array\", func(t *testing.T) {\n\t\tc := \u0026cache{}\n\t\tv, tail, err := parseValue(`[1,2,3]`, c, 0)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t}\n\t\tif tail != \"\" {\n\t\t\tt.Errorf(\"Unexpected tail: %q\", tail)\n\t\t}\n\t\tif v.t != TypeArray {\n\t\t\tt.Errorf(\"Expected array, got %v\", v.t)\n\t\t}\n\t})\n\n\tt.Run(\"string\", func(t *testing.T) {\n\t\tc := \u0026cache{}\n\t\tv, tail, err := parseValue(`\"foo\"`, c, 0)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t}\n\t\tif tail != \"\" {\n\t\t\tt.Errorf(\"Unexpected tail: %q\", tail)\n\t\t}\n\t\tif v.t != typeRawString {\n\t\t\tt.Errorf(\"Expected string, got %v\", v.t)\n\t\t}\n\t\tif v.s != \"foo\" {\n\t\t\tt.Errorf(\"Expected 'foo', got %q\", v.s)\n\t\t}\n\t})\n\n\tt.Run(\"true\", func(t *testing.T) {\n\t\tc := \u0026cache{}\n\t\tv, tail, err := parseValue(`true`, c, 0)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t}\n\t\tif tail != \"\" {\n\t\t\tt.Errorf(\"Unexpected tail: %q\", tail)\n\t\t}\n\t\tif v != valueTrue {\n\t\t\tt.Errorf(\"Expected true, got %v\", v)\n\t\t}\n\t})\n\n\tt.Run(\"false\", func(t *testing.T) {\n\t\tc := \u0026cache{}\n\t\tv, tail, err := parseValue(`false`, c, 0)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t}\n\t\tif tail != \"\" {\n\t\t\tt.Errorf(\"Unexpected tail: %q\", tail)\n\t\t}\n\t\tif v != valueFalse {\n\t\t\tt.Errorf(\"Expected false, got %v\", v)\n\t\t}\n\t})\n\n\tt.Run(\"null\", func(t *testing.T) {\n\t\tc := \u0026cache{}\n\t\tv, tail, err := parseValue(`null`, c, 0)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t}\n\t\tif tail != \"\" {\n\t\t\tt.Errorf(\"Unexpected tail: %q\", tail)\n\t\t}\n\t\tif v != valueNull {\n\t\t\tt.Errorf(\"Expected null, got %v\", v)\n\t\t}\n\t})\n\n\tt.Run(\"NaN\", func(t *testing.T) {\n\t\tc := \u0026cache{}\n\t\tv, tail, err := parseValue(`NaN`, c, 0)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t}\n\t\tif tail != \"\" {\n\t\t\tt.Errorf(\"Unexpected tail: %q\", tail)\n\t\t}\n\t\tif v.t != TypeNumber {\n\t\t\tt.Errorf(\"Expected number, got %v\", v.t)\n\t\t}\n\t\tif v.s != \"NaN\" {\n\t\t\tt.Errorf(\"Expected 'NaN', got %q\", v.s)\n\t\t}\n\t})\n\n\tt.Run(\"number\", func(t *testing.T) {\n\t\tc := \u0026cache{}\n\t\tv, tail, err := parseValue(`1234`, c, 0)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t}\n\t\tif tail != \"\" {\n\t\t\tt.Errorf(\"Unexpected tail: %q\", tail)\n\t\t}\n\t\tif v.t != TypeNumber {\n\t\t\tt.Errorf(\"Expected number, got %v\", v.t)\n\t\t}\n\t\tif v.s != \"1234\" {\n\t\t\tt.Errorf(\"Expected '1234', got %q\", v.s)\n\t\t}\n\t})\n}\n","2cc3b709604c5951ce3e82ebc9f8d8ad":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ts     string\n\t\terr   error\n\t}{\n\t\t// Empty object\n\t\t{\n\t\t\tinput: `{}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: nil,\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Single key-value pair\n\t\t{\n\t\t\tinput: `{\"key\": \"value\"}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Multiple key-value pairs\n\t\t{\n\t\t\tinput: `{\"key1\": \"value1\", \"key2\": 123, \"key3\": true}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Nested object\n\t\t{\n\t\t\tinput: `{\"key1\": {\"key2\": \"value2\"}, \"key3\": \"value3\"}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Invalid JSON\n\t\t{\n\t\t\tinput: `{\"key\": \"value\"`,\n\t\t\twant:  nil,\n\t\t\ts:     `{\"key\": \"value\"`,\n\t\t\terr:   fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t\t{\n\t\t\tinput: `{\"key\": \"value\",`,\n\t\t\twant:  nil,\n\t\t\ts:     `{\"key\": \"value\",`,\n\t\t\terr:   fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t\t{\n\t\t\tinput: `{key\": \"value\"}`,\n\t\t\twant:  nil,\n\t\t\ts:     `{key\": \"value\"}`,\n\t\t\terr:   fmt.Errorf(`cannot find opening '\"\" for object key`),\n\t\t},\n\t\t{\n\t\t\tinput: `{\"key\" \"value\"}`,\n\t\t\twant:  nil,\n\t\t\ts:     `{\"key\" \"value\"}`,\n\t\t\terr:   fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseObject(tt.input, c, 0)\n\t\t\tif fmt.Sprintf(\"%v\", err) != fmt.Sprintf(\"%v\", tt.err) {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif s != tt.s {\n\t\t\t\tt.Errorf(\"parseObject() s = %s, want %s\", s, tt.s)\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\treturn true\n\t}\n}\n","2ceadea7d3d22fb61a883ee6a8978095":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantNum  string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Basic cases\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"123.456\", \"123.456\", \"\", nil},\n\t\t{\"-123.456\", \"-123.456\", \"\", nil},\n\t\t{\"1.2e3\", \"1.2e3\", \"\", nil},\n\t\t{\"1.2E3\", \"1.2E3\", \"\", nil},\n\t\t{\"1.2e+3\", \"1.2e+3\", \"\", nil},\n\t\t{\"1.2e-3\", \"1.2e-3\", \"\", nil},\n\t\t{\"+123\", \"+123\", \"\", nil},\n\n\t\t// Trailing characters\n\t\t{\"123a\", \"123\", \"a\", nil},\n\t\t{\"123.456a\", \"123.456\", \"a\", nil},\n\t\t{\"123 \", \"123\", \" \", nil},\n\n\t\t// Invalid numbers\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t\t{\"a\", \"\", \"a\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\"+a\", \"\", \"+a\", fmt.Errorf(\"unexpected char: %q\", \"+a\")},\n\t\t{\"-a\", \"\", \"-a\", fmt.Errorf(\"unexpected char: %q\", \"-a\")},\n\t\t{\"123a456\", \"123\", \"a456\", nil},\n\t\t{\".123\", \"\", \".123\", fmt.Errorf(\"unexpected char: %q\", \".\")},\n\n\t\t// Special values\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"+inf\", \"+inf\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"InF\", \"InF\", \"\", nil},\n\t\t{\"infa\", \"inf\", \"a\", nil},\n\t\t{\"inf123\", \"inf\", \"123\", nil},\n\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"+nan\", \"+nan\", \"\", nil},\n\t\t{\"-nan\", \"-nan\", \"\", nil},\n\t\t{\"nAn\", \"nAn\", \"\", nil},\n\t\t{\"nana\", \"nan\", \"a\", nil},\n\t\t{\"nan123\", \"nan\", \"123\", nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test%d_%s\", i, tt.input), func(t *testing.T) {\n\t\t\tgotNum, gotTail, gotErr := parseRawNumber(tt.input)\n\t\t\tif gotNum != tt.wantNum || gotTail != tt.wantTail || !equalError(gotErr, tt.wantErr) {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = (%q, %q, %v), want (%q, %q, %v)\", tt.input, gotNum, gotTail, gotErr, tt.wantNum, tt.wantTail, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// equalError compares two errors for equality.\nfunc equalError(err1, err2 error) bool {\n\tif err1 == nil \u0026\u0026 err2 == nil {\n\t\treturn true\n\t}\n\tif err1 == nil || err2 == nil {\n\t\treturn false\n\t}\n\treturn err1.Error() == err2.Error()\n}","2d5f2487d64d711a19307d18f38dabf3":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantN    string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Basic cases\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"123.456\", \"123.456\", \"\", nil},\n\t\t{\"-123.456\", \"-123.456\", \"\", nil},\n\t\t{\"1.2e3\", \"1.2e3\", \"\", nil},\n\t\t{\"1.2E3\", \"1.2E3\", \"\", nil},\n\t\t{\"-1.2e3\", \"-1.2e3\", \"\", nil},\n\t\t{\"-1.2E3\", \"-1.2E3\", \"\", nil},\n\n\t\t// Trailing characters\n\t\t{\"123a\", \"123\", \"a\", nil},\n\t\t{\"-123a\", \"-123\", \"a\", nil},\n\t\t{\"123.456a\", \"123.456\", \"a\", nil},\n\t\t{\"-123.456a\", \"-123.456\", \"a\", nil},\n\t\t{\"1.2e3a\", \"1.2e3\", \"a\", nil},\n\t\t{\"1.2E3a\", \"1.2E3\", \"a\", nil},\n\t\t{\"-1.2e3a\", \"-1.2e3\", \"a\", nil},\n\t\t{\"-1.2E3a\", \"-1.2E3\", \"a\", nil},\n\n\t\t// Invalid numbers\n\t\t{\"a\", \"\", \"a\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\"+a\", \"\", \"+a\", fmt.Errorf(\"unexpected char: %q\", \"+a\")},\n\t\t{\"-a\", \"\", \"-a\", fmt.Errorf(\"unexpected char: %q\", \"-a\")},\n\n\t\t// inf and nan\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"+inf\", \"+inf\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"InF\", \"InF\", \"\", nil},\n\t\t{\"+InF\", \"+InF\", \"\", nil},\n\t\t{\"-InF\", \"-InF\", \"\", nil},\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"+nan\", \"+nan\", \"\", nil},\n\t\t{\"-nan\", \"-nan\", \"\", nil},\n\t\t{\"nAn\", \"nAn\", \"\", nil},\n\t\t{\"+nAn\", \"+nAn\", \"\", nil},\n\t\t{\"-nAn\", \"-nAn\", \"\", nil},\n\t\t{\"123inf\", \"123\", \"inf\", nil},\n\t\t{\"123InF\", \"123\", \"InF\", nil},\n\t\t{\"123nan\", \"123\", \"nan\", nil},\n\t\t{\"123nAn\", \"123\", \"nAn\", nil},\n\t\t{\"inf123\", \"inf\", \"123\", nil},\n\t\t{\"InF123\", \"InF\", \"123\", nil},\n\t\t{\"nan123\", \"nan\", \"123\", nil},\n\t\t{\"nAn123\", \"nAn\", \"123\", nil},\n\n\t\t// Invalid inf and nan\n\t\t{\"in\", \"\", \"in\", fmt.Errorf(\"unexpected char: %q\", \"i\")},\n\t\t{\"+in\", \"\", \"+in\", fmt.Errorf(\"unexpected char: %q\", \"+i\")},\n\t\t{\"-in\", \"\", \"-in\", fmt.Errorf(\"unexpected char: %q\", \"-i\")},\n\t\t{\"na\", \"\", \"na\", fmt.Errorf(\"unexpected char: %q\", \"n\")},\n\t\t{\"+na\", \"\", \"+na\", fmt.Errorf(\"unexpected char: %q\", \"+n\")},\n\t\t{\"-na\", \"\", \"-na\", fmt.Errorf(\"unexpected char: %q\", \"-n\")},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tgotN, gotTail, gotErr := parseRawNumber(tt.input)\n\t\t\tif gotN != tt.wantN {\n\t\t\t\tt.Errorf(\"input %q: got number %q, want %q\", tt.input, gotN, tt.wantN)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"input %q: got tail %q, want %q\", tt.input, gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif gotErr == nil \u0026\u0026 tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"input %q: got no error, want %v\", tt.input, tt.wantErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr == nil {\n\t\t\t\tt.Errorf(\"input %q: got error %v, want no error\", tt.input, gotErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"input %q: got error %v, want %v\", tt.input, gotErr, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","2d6e38d353e304097ec83f3d45819f1d":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ts     string\n\t\terr   error\n\t}{\n\t\t// Test cases here\n\t\t{\n\t\t\tinput: `{}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tinput: `{\"key\": \"value\"}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tinput: `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Add more test cases to cover different scenarios\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i+1), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseObject(tt.input, c, 0)\n\n\t\t\tif (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif s != tt.s {\n\t\t\t\tt.Errorf(\"parseObject() remaining string = %v, want %v\", s, tt.s)\n\t\t\t}\n\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeObject:\n\t\tif v1.o.Len() != v2.o.Len() {\n\t\t\treturn false\n\t\t}\n\t\tfor i := 0; i \u003c v1.o.Len(); i++ {\n\t\t\tkv1 := \u0026v1.o.kvs[i]\n\t\t\tkv2 := \u0026v2.o.kvs[i]\n\t\t\tif kv1.k != kv2.k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(kv1.v, kv2.v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t// Add cases for other types as needed\n\tdefault:\n\t\treturn false\n\t}\n}\n","2df992bd75b18193a3fe156e4b85d482":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc Test_parseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantNum  string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Valid numbers\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"+123.456\", \"+123.456\", \"\", nil},\n\t\t{\"1.0e+10\", \"1.0e+10\", \"\", nil},\n\t\t{\"1.0e-10\", \"1.0e-10\", \"\", nil},\n\n\t\t// Valid numbers with trailing characters\n\t\t{\"123abc\", \"123\", \"abc\", nil},\n\t\t{\"-123 \", \"-123\", \" \", nil},\n\t\t{\"1.23,456\", \"1.23\", \",456\", nil},\n\n\t\t// Valid numbers with \"inf\" and \"nan\"\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"+inf\", \"+inf\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"NaN\", \"NaN\", \"\", nil},\n\t\t{\"infxxx\", \"inf\", \"xxx\", nil},\n\t\t{\"+InF\", \"+InF\", \"\", nil}, // Case-insensitive\n\n\t\t// Invalid numbers\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t\t{\"x\", \"\", \"x\", fmt.Errorf(\"unexpected char: %q\", \"x\")},\n\t\t{\"-x\", \"\", \"-x\", fmt.Errorf(\"unexpected char: %q\", \"-x\")},\n\t\t{\"+x\", \"\", \"+x\", fmt.Errorf(\"unexpected char: %q\", \"+x\")},\n\t\t{\"1.2.3\", \"\", \"1.2.3\", nil},\n\t\t{\"in\", \"\", \"in\", fmt.Errorf(\"unexpected char: %q\", \"in\")},\n\t\t{\"+in\", \"\", \"+in\", fmt.Errorf(\"unexpected char: %q\", \"+in\")},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tgotNum, gotTail, gotErr := parseRawNumber(tt.input)\n\t\t\tif gotNum != tt.wantNum {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) gotNum = %q, want %q\", tt.input, gotNum, tt.wantNum)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) gotTail = %q, want %q\", tt.input, gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif gotErr == nil \u0026\u0026 tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) gotErr = nil, want error %v\", tt.input, tt.wantErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr == nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) gotErr = %v, want nil error\", tt.input, gotErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) gotErr = %v, want error %v\", tt.input, gotErr, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}\n","2e1e87a1802ab10a8d0fff9413ec247c":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic escapes\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\t`, \"\\t\"},\n\t\t{`\\\\`, \"\\\\\"},\n\t\t{`\\\"`, \"\\\"\"},\n\t\t{`\\/`, \"/\"},\n\n\t\t// Unicode escapes\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u03c0`, \"œÄ\"},\n\t\t{`\\uFFFF`, \"Ôøø\"},\n\n\t\t// Surrogate pairs\n\t\t{`\\uD83D\\uDE02`, \"üòÇ\"},\n\t\t{`\\uD834\\uDD1E`, \"ùÑû\"},\n\n\t\t// Invalid escapes - should be passed through unchanged\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\uD800`, `\\uD800`},  // Unpaired surrogate\n\t\t{`\\uDC00`, `\\uDC00`},  // Unpaired surrogate\n\t\t{`\\uD800\\u0020`, `\\uD800 `}, // Invalid surrogate pair\n\n\t\t// Mixed strings\n\t\t{`This is a test\\nwith some escapes\\t!`, \"This is a test\\nwith some escapes\\t!\"},\n\t\t{`This string has \\\"\\u0022escaped quotes\\u0022\\\"`, \"This string has \\\"escaped quotes\\\"\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tactual := unescapeStringBestEffort(tt.input)\n\t\t\tif actual != tt.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", tt.input, actual, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n","2e2c86f97ac7952a6d612a1dfbcc2116":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\ts   string\n\t\tv   *Value\n\t\ttail string\n\t\terr error\n\t}{\n\t\t// Test cases for various JSON values.\n\t\t{\"{\\\"key\\\": \\\"value\\\"}\", \u0026Value{t: TypeObject}, \"\", nil},\n\t\t{\"[1, 2, 3]\", \u0026Value{t: TypeArray}, \"\", nil},\n\t\t{\"\\\"hello\\\"\", \u0026Value{t: typeRawString, s: \"hello\"}, \"\", nil},\n\t\t{\"true\", valueTrue, \"\", nil},\n\t\t{\"false\", valueFalse, \"\", nil},\n\t\t{\"null\", valueNull, \"\", nil},\n\t\t{\"123\", \u0026Value{t: TypeNumber, s: \"123\"}, \"\", nil},\n\t\t{\"-123.456\", \u0026Value{t: TypeNumber, s: \"-123.456\"}, \"\", nil},\n\n\t\t// Test cases for handling whitespace and errors.\n\t\t{\"  {\\\"key\\\": \\\"value\\\"}\", \u0026Value{t: TypeObject}, \"\", nil},\n\t\t{\"  [1, 2, 3]  \", \u0026Value{t: TypeArray}, \"  \", nil},\n\t\t{\"invalid json\", nil, \"invalid json\", fmt.Errorf(\"cannot parse object: unexpected value found: %q\", \"invalid json\")},\n\t}\n\n\tc := \u0026cache{}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tv, tail, err := parseValue(tt.s, c, 0)\n\n\t\t\tif !equalError(err, tt.err) {\n\t\t\t\tt.Fatalf(\"Test-%d: Expected error '%v', but got '%v'\", i, tt.err, err)\n\t\t\t}\n\t\t\tif v != nil \u0026\u0026 tt.v != nil \u0026\u0026 v.t != tt.v.t {\n\t\t\t\tt.Fatalf(\"Test-%d: Expected type '%v', but got '%v'\", i, tt.v.t, v.t)\n\t\t\t}\n\t\t\tif tt.v != nil \u0026\u0026 v != nil \u0026\u0026 tt.v.s != v.s {\n\t\t\t\tt.Fatalf(\"Test-%d: Expected value '%v', but got '%v'\", i, tt.v.s, v.s)\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Fatalf(\"Test-%d: Expected tail '%v', but got '%v'\", i, tt.tail, tail)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// equalError compares two errors for equality.\nfunc equalError(err1, err2 error) bool {\n\tif err1 == nil \u0026\u0026 err2 == nil {\n\t\treturn true\n\t}\n\tif err1 != nil \u0026\u0026 err2 != nil {\n\t\treturn err1.Error() == err2.Error()\n\t}\n\treturn false\n}","2f909e3670e0008a815b20c6f7e8a3a7":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey   string\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Unescaped strings\n\t\t{`\"hello\"`, \"hello\", \"\", nil},\n\t\t{`\"hello, world\"`, \"hello, world\", \"\", nil},\n\t\t{`\"\"`, \"\", \"\", nil},\n\n\t\t// Escaped strings\n\t\t{`\"hello\\\\world\"`, `hello\\world`, \"\", nil},\n\t\t{`\"hello\\\"world\\\"\"`, `hello\"world\"`, \"\", nil},\n\t\t{`\"\\\\\"`, `\\`, \"\", nil},\n\t\t{`\"\\\\ \\\"\"`, `\\ \"`, \"\", nil},\n\n\t\t// Invalid strings\n\t\t{`\"missing quote`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"escaped quote at end\\\"`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`invalid string`, \"invalid string\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test #%d\", i), func(t *testing.T) {\n\t\t\tkey, tail, err := parseRawString(tt.input)\n\t\t\tif key != tt.key {\n\t\t\t\tt.Errorf(\"key mismatch: want %q, got %q\", tt.key, key)\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"tail mismatch: want %q, got %q\", tt.tail, tail)\n\t\t\t}\n\t\t\tif (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err == nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"error mismatch: want %v, got %v\", tt.err, err)\n\t\t\t}\n\t\t})\n\t}\n}","2fa92d72de8793804a62897e8d2d73f2":"package fastjson\n\nimport \"testing\"\n\nfunc TestTypeString(t *testing.T) {\n\t// Test cases for Type.String()\n\ttests := []struct {\n\t\tinput Type\n\t\twant  string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.want, func(t *testing.T) {\n\t\t\thave := tc.input.String()\n\t\t\tif have != tc.want {\n\t\t\t\tt.Errorf(\"Type.String() = %q, want %q\", have, tc.want)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test case for invalid type, should panic\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Error(\"Type.String() did not panic for invalid type\")\n\t\t}\n\t}()\n\n\t// Trigger the panic\n\tvar invalidType Type\n\tinvalidType = 100 // Set to an unknown type\n\tinvalidType.String()\n}","2fb0fc2eb32e058ac2dd842299b25569":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Get(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tjson string\n\t\targs []string\n\t\twant *Value\n\t}{\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\tjson: `{\"a\": 123}`,\n\t\t\targs: []string{\"a\"},\n\t\t\twant: \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t},\n\t\t{\n\t\t\tname: \"nested object\",\n\t\t\tjson: `{\"a\": {\"b\": 123}}`,\n\t\t\targs: []string{\"a\", \"b\"},\n\t\t\twant: \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t},\n\t\t{\n\t\t\tname: \"array index\",\n\t\t\tjson: `{\"a\": [1, 2, 3]}`,\n\t\t\targs: []string{\"a\", \"1\"},\n\t\t\twant: \u0026Value{t: TypeNumber, s: \"2\"},\n\t\t},\n\t\t{\n\t\t\tname: \"non-existing key\",\n\t\t\tjson: `{\"a\": 123}`,\n\t\t\targs: []string{\"b\"},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid array index\",\n\t\t\tjson: `{\"a\": [1, 2, 3]}`,\n\t\t\targs: []string{\"a\", \"abc\"},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"out of range array index\",\n\t\t\tjson: `{\"a\": [1, 2, 3]}`,\n\t\t\targs: []string{\"a\", \"3\"},\n\t\t\twant: nil,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv, _ := Parse(tt.json)\n\t\t\tgot := v.Get(tt.args...)\n\t\t\tif got == nil \u0026\u0026 tt.want == nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got == nil || tt.want == nil {\n\t\t\t\tt.Errorf(\"Value.Get() = %v, want %v\", got, tt.want)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got.Type() != tt.want.Type() || got.String() != tt.want.String() {\n\t\t\t\tt.Errorf(\"Value.Get() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","2fe3ae84a715a014fd4df63781c671e4":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tt.Run(\"empty string\", func(t *testing.T) {\n\t\t_, _, err := parseValue(\"\", \u0026cache{}, 0)\n\t\tif err == nil {\n\t\t\tt.Fatal(\"expected error, got nil\")\n\t\t}\n\t\tif err.Error() != \"cannot parse empty string\" {\n\t\t\tt.Errorf(\"expected error 'cannot parse empty string', got '%s'\", err.Error())\n\t\t}\n\t})\n\tt.Run(\"object\", func(t *testing.T) {\n\t\tc := \u0026cache{}\n\t\tv, tail, err := parseValue(`{\"foo\":\"bar\"}`, c, 0)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t\t}\n\t\tif tail != \"\" {\n\t\t\tt.Errorf(\"expected tail to be empty, got '%s'\", tail)\n\t\t}\n\t\tif v.t != TypeObject {\n\t\t\tt.Errorf(\"expected type TypeObject, got %d\", v.t)\n\t\t}\n\t\tif len(v.o.kvs) != 1 {\n\t\t\tt.Errorf(\"expected 1 key-value pair, got %d\", len(v.o.kvs))\n\t\t} else {\n\t\t\tif v.o.kvs[0].k != \"foo\" {\n\t\t\t\tt.Errorf(\"expected key 'foo', got '%s'\", v.o.kvs[0].k)\n\t\t\t}\n\t\t\tif v.o.kvs[0].v.t != typeRawString {\n\t\t\t\tt.Errorf(\"expected type typeRawString, got %d\", v.o.kvs[0].v.t)\n\t\t\t}\n\t\t\tif v.o.kvs[0].v.s != \"bar\" {\n\t\t\t\tt.Errorf(\"expected value 'bar', got '%s'\", v.o.kvs[0].v.s)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"array\", func(t *testing.T) {\n\t\tc := \u0026cache{}\n\t\tv, tail, err := parseValue(`[1,2,3]`, c, 0)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t\t}\n\t\tif tail != \"\" {\n\t\t\tt.Errorf(\"expected tail to be empty, got '%s'\", tail)\n\t\t}\n\t\tif v.t != TypeArray {\n\t\t\tt.Errorf(\"expected type TypeArray, got %d\", v.t)\n\t\t}\n\t\tif len(v.a) != 3 {\n\t\t\tt.Errorf(\"expected 3 elements, got %d\", len(v.a))\n\t\t} else {\n\t\t\tfor i := 0; i \u003c 3; i++ {\n\t\t\t\tif v.a[i].t != TypeNumber {\n\t\t\t\t\tt.Errorf(\"expected type TypeNumber for element %d, got %d\", i, v.a[i].t)\n\t\t\t\t}\n\t\t\t\tif v.a[i].s != fmt.Sprintf(\"%d\", i+1) {\n\t\t\t\t\tt.Errorf(\"expected value '%d', got '%s'\", i+1, v.a[i].s)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t})\n\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\ttail    string\n\t}{\n\t\t{\n\t\t\tname:  \"string\",\n\t\t\tinput: `\"foo\"`,\n\t\t\texpected: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"foo\",\n\t\t\t},\n\t\t\ttail: \"\",\n\t\t},\n\t\t{\n\t\t\tname:  \"true\",\n\t\t\tinput: \"true\",\n\t\t\texpected: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\ttail: \"\",\n\t\t},\n\t\t{\n\t\t\tname:  \"false\",\n\t\t\tinput: \"false\",\n\t\t\texpected: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\ttail: \"\",\n\t\t},\n\t\t{\n\t\t\tname:  \"null\",\n\t\t\tinput: \"null\",\n\t\t\texpected: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\ttail: \"\",\n\t\t},\n\t\t{\n\t\t\tname:  \"number\",\n\t\t\tinput: \"123.456\",\n\t\t\texpected: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\ttail: \"\",\n\t\t},\n\t\t{\n\t\t\tname:  \"NaN\",\n\t\t\tinput: \"NaN\",\n\t\t\texpected: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\ttail: \"\",\n\t\t},\n\t\t{\n\t\t\tname:  \"string with tail\",\n\t\t\tinput: `\"foo\"bar`,\n\t\t\texpected: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"foo\",\n\t\t\t},\n\t\t\ttail: \"bar\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tv, tail, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t\t\t}\n\t\t\tif tail != tc.tail {\n\t\t\t\tt.Errorf(\"expected tail '%s', got '%s'\", tc.tail, tail)\n\t\t\t}\n\t\t\tif v.t != tc.expected.t {\n\t\t\t\tt.Errorf(\"expected type %d, got %d\", tc.expected.t, v.t)\n\t\t\t}\n\t\t\tif v.s != tc.expected.s {\n\t\t\t\tt.Errorf(\"expected value '%s', got '%s'\", tc.expected.s, v.s)\n\t\t\t}\n\t\t})\n\t}\n}","2ff1850ae86de1ccc21484979242f638":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantStr  string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Simple cases\n\t\t{`\"hello\"world`, \"hello\", \"world\", nil},\n\t\t{`\"hello\" world`, \"hello\", \" world\", nil},\n\t\t{`\"hello\"`, \"hello\", \"\", nil},\n\n\t\t// Escaped quotes\n\t\t{`\"hel\\\\\"lo\"world`, `hel\\\"lo`, \"world\", nil},\n\t\t{`\"hel\\\\\\\\\"lo\"world`, `hel\\\\`, `lo\"world`, nil},\n\t\t{`\"hello\\\\\"\"world`, \"hello\\\\\\\"\", \"world\", nil},\n\n\t\t// Missing closing quote\n\t\t{`\"hello`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"he\\\\\"llo`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\n\t\t// Empty string\n\t\t{`\"\"`, \"\", \"\", nil},\n\n\t\t// Special characters\n\t\t{`\"\\n\\t\\r\\b\\f\\\\\\\"\"`, \"\\n\\t\\r\\b\\f\\\\\\\"\", \"\", nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tgotStr, gotTail, gotErr := parseRawString(tt.input)\n\t\t\tif gotStr != tt.wantStr || gotTail != tt.wantTail || !errorEqual(gotErr, tt.wantErr) {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = (%q, %q, %v), want (%q, %q, %v)\", tt.input, gotStr, gotTail, gotErr, tt.wantStr, tt.wantTail, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc errorEqual(e1, e2 error) bool {\n\tif e1 == nil \u0026\u0026 e2 == nil {\n\t\treturn true\n\t}\n\tif e1 == nil || e2 == nil {\n\t\treturn false\n\t}\n\treturn e1.Error() == e2.Error()\n}\n","2ff24b4095c848855256487499af5870":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Get(t *testing.T) {\n\tt.Run(\"object\", func(t *testing.T) {\n\t\tv := MustParse(`{\"foo\": {\"bar\": \"baz\"}}`)\n\t\tAssert(t, v.Get(\"foo\", \"bar\").String() == \"baz\", \"want baz, got %s\", v.Get(\"foo\", \"bar\"))\n\t\tAssert(t, v.Get(\"foo\", \"bar\").Type() == TypeString, \"want TypeString, got %s\", v.Get(\"foo\", \"bar\").Type())\n\t})\n\tt.Run(\"array\", func(t *testing.T) {\n\t\tv := MustParse(`{\"foo\": [{\"bar\": \"baz\"}]}`)\n\t\tAssert(t, v.Get(\"foo\", \"0\", \"bar\").String() == \"baz\", \"want baz, got %s\", v.Get(\"foo\", \"0\", \"bar\"))\n\t})\n\tt.Run(\"non-existing key\", func(t *testing.T) {\n\t\tv := MustParse(`{\"foo\": \"bar\"}`)\n\t\tAssert(t, v.Get(\"baz\") == nil, \"want nil, got %s\", v.Get(\"baz\"))\n\t})\n\n\tt.Run(\"array index out of range\", func(t *testing.T) {\n\t\tv := MustParse(`{\"foo\": [{\"bar\": \"baz\"}]}`)\n\t\tAssert(t, v.Get(\"foo\", \"1\") == nil, \"want nil, got %s\", v.Get(\"foo\", \"1\"))\n\t})\n}","2ff422ba8ebbc2fbda9512c1f666199b":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Get(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tjson  string\n\t\tkeys  []string\n\t\twant  *Value\n\t\twant1 bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty\",\n\t\t\tjson:  `{}`,\n\t\t\tkeys:  []string{\"nonexisting\"},\n\t\t\twant:  nil,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"oneKey\",\n\t\t\tjson:  `{\"key1\": 123}`,\n\t\t\tkeys:  []string{\"key1\"},\n\t\t\twant:  \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"number\",\n\t\t\tjson:  `{\"key1\": 123}`,\n\t\t\tkeys:  []string{\"key1\"},\n\t\t\twant:  \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"string\",\n\t\t\tjson:  `{\"key1\": \"value1\"}`,\n\t\t\tkeys:  []string{\"key1\"},\n\t\t\twant:  \u0026Value{t: TypeString, s: \"value1\"},\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"true\",\n\t\t\tjson:  `{\"key1\": true}`,\n\t\t\tkeys:  []string{\"key1\"},\n\t\t\twant:  \u0026Value{t: TypeTrue},\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"false\",\n\t\t\tjson:  `{\"key1\": false}`,\n\t\t\tkeys:  []string{\"key1\"},\n\t\t\twant:  \u0026Value{t: TypeFalse},\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"null\",\n\t\t\tjson:  `{\"key1\": null}`,\n\t\t\tkeys:  []string{\"key1\"},\n\t\t\twant:  \u0026Value{t: TypeNull},\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"twoKeys\",\n\t\t\tjson:  `{\"key1\": {\"key2\": \"value2\"}}`,\n\t\t\tkeys:  []string{\"key1\", \"key2\"},\n\t\t\twant:  \u0026Value{t: TypeString, s: \"value2\"},\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"arrayIndex\",\n\t\t\tjson:  `{\"key1\": [1,2,3]}`,\n\t\t\tkeys:  []string{\"key1\", \"1\"},\n\t\t\twant:  \u0026Value{t: TypeNumber, s: \"2\"},\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"arrayIndexOutOfRange\",\n\t\t\tjson:  `{\"key1\": [1,2,3]}`,\n\t\t\tkeys:  []string{\"key1\", \"4\"},\n\t\t\twant:  nil,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"arrayIndexNegative\",\n\t\t\tjson:  `{\"key1\": [1,2,3]}`,\n\t\t\tkeys:  []string{\"key1\", \"-1\"},\n\t\t\twant:  nil,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"arrayIndexNotNumber\",\n\t\t\tjson:  `{\"key1\": [1,2,3]}`,\n\t\t\tkeys:  []string{\"key1\", \"abc\"},\n\t\t\twant:  nil,\n\t\t\twant1: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv, _ := ParseBytes([]byte(tt.json))\n\t\t\tgot := v.Get(tt.keys...)\n\t\t\tif got == nil \u0026\u0026 tt.want == nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got == nil || tt.want == nil {\n\t\t\t\tt.Errorf(\"Value.Get() = %v, want %v\", got, tt.want)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got.Type() != tt.want.Type() {\n\t\t\t\tt.Errorf(\"Value.Get() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got.Type() == TypeString \u0026\u0026 got.s != tt.want.s {\n\t\t\t\tt.Errorf(\"Value.Get() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","303ad9d4dc410347d2cbd3bf7c648fec":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_getKV(t *testing.T) {\n\to := \u0026Object{}\n\n\t// Test adding the first kv\n\tkv1 := o.getKV()\n\tif kv1 == nil {\n\t\tt.Errorf(\"Expected a non-nil kv, got nil\")\n\t}\n\n\t// Test adding a second kv\n\tkv2 := o.getKV()\n\tif kv2 == nil {\n\t\tt.Errorf(\"Expected a non-nil kv, got nil\")\n\t}\n\tif kv1 == kv2 {\n\t\tt.Errorf(\"Expected different kv instances, got the same\")\n\t}\n\n\t// Test reusing existing capacity\n\to.kvs = o.kvs[:1]\n\tkv3 := o.getKV()\n\tif kv3 == nil {\n\t\tt.Errorf(\"Expected a non-nil kv, got nil\")\n\t}\n\tif kv3 != kv1 {\n\t\tt.Errorf(\"Expected kv3 to reuse the first kv instance, got a different one\")\n\t}\n}","303b207c74ac5ea4ce5afbb436c3bd7f":"package fastjson\n\nimport \"testing\"\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tinput Type\n\t\twant  string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\n\tfor i, tt := range tests {\n\t\tgot := tt.input.String()\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"test %d failed: Input: %v, got: %v, want: %v\", i, tt.input, got, tt.want)\n\t\t}\n\t}\n}","3054603d186f99fd6bc0c1c19a1e5682":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic strings\n\t\t{\"hello\", \"hello\"},\n\t\t{\"world\", \"world\"},\n\n\t\t// Simple escaping\n\t\t{`\\\"hello\\\"`, `\"hello\"`},\n\t\t{`\\\\world\\\\`, `\\world\\`},\n\t\t{`\\bfoo\\tbar\\n`, \"\\bfoo\\tbar\\n\"},\n\n\t\t// Unicode escaping\n\t\t{`\\u0041`, \"A\"},\n\t\t{`\\u00e9`, \"√©\"},\n\t\t{`\\u20ac`, \"‚Ç¨\"},\n\n\t\t// Surrogate pairs\n\t\t{`\\uD83D\\uDE02`, \"üòÇ\"},\n\n\t\t// Invalid escape sequences\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\uD800`, `\\uD800`}, // Invalid surrogate pair\n\t\t{`\\uD800\\u1234`, `\\uD800\\u1234`}, // Invalid surrogate pair\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tactual := unescapeStringBestEffort(tt.input)\n\t\t\tif actual != tt.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", tt.input, actual, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}","3081f2b7867988b78d42025b66c8cccd":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tns    string\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Valid numbers\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"+123\", \"+123\", \"\", nil},\n\t\t{\"123.456\", \"123.456\", \"\", nil},\n\t\t{\"-123.456\", \"-123.456\", \"\", nil},\n\t\t{\"1.2e3\", \"1.2e3\", \"\", nil},\n\t\t{\"1.2E3\", \"1.2E3\", \"\", nil},\n\t\t{\"1.2e+3\", \"1.2e+3\", \"\", nil},\n\t\t{\"1.2e-3\", \"1.2e-3\", \"\", nil},\n\n\t\t// Valid numbers with trailing characters\n\t\t{\"123a\", \"123\", \"a\", nil},\n\t\t{\"-123a\", \"-123\", \"a\", nil},\n\t\t{\"123.456a\", \"123.456\", \"a\", nil},\n\t\t{\"1.2e3a\", \"1.2e3\", \"a\", nil},\n\n\t\t// Invalid numbers\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t\t{\"a\", \"\", \"a\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\"-\", \"-\", \"\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t\t{\"+\", \"+\", \"\", fmt.Errorf(\"unexpected char: %q\", \"+\")},\n\t\t(\".123\", \"\", \".123\", fmt.Errorf(\"unexpected char: %q\", \".\")},\n\t\t{\"123.\", \"123\", \".\", nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tns, tail, err := parseRawNumber(tt.input)\n\t\t\tif ns != tt.ns || tail != tt.tail || !errorEqual(err, tt.err) {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = (%q, %q, %v), want (%q, %q, %v)\", tt.input, ns, tail, err, tt.ns, tt.tail, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc errorEqual(e1, e2 error) bool {\n\tif e1 == nil \u0026\u0026 e2 == nil {\n\t\treturn true\n\t}\n\tif e1 == nil || e2 == nil {\n\t\treturn false\n\t}\n\treturn e1.Error() == e2.Error()\n}","30a6bbea29b047461f96d6422567f1ed":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetInt(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tjson  string\n\t\tkeys  []string\n\t\twant  int\n\t\twant1 bool\n\t}{\n\t\t{\n\t\t\tname:  \"simple\",\n\t\t\tjson:  `{\"foo\":123}`,\n\t\t\tkeys:  []string{\"foo\"},\n\t\t\twant:  123,\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"nested\",\n\t\t\tjson:  `{\"foo\":{\"bar\":123}}`,\n\t\t\tkeys:  []string{\"foo\", \"bar\"},\n\t\t\twant:  123,\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array\",\n\t\t\tjson:  `{\"foo\":[123,456]}`,\n\t\t\tkeys:  []string{\"foo\", \"1\"},\n\t\t\twant:  456,\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array decimal\",\n\t\t\tjson:  `{\"foo\":[123,456]}`,\n\t\t\tkeys:  []string{\"foo\", \"1.0\"},\n\t\t\twant:  456,\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"non-existing key\",\n\t\t\tjson:  `{\"foo\":123}`,\n\t\t\tkeys:  []string{\"bar\"},\n\t\t\twant:  0,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"invalid value type\",\n\t\t\tjson:  `{\"foo\":\"bar\"}`,\n\t\t\tkeys:  []string{\"foo\"},\n\t\t\twant:  0,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"number from string\",\n\t\t\tjson:  `{\"foo\":\"123\"}`,\n\t\t\tkeys:  []string{\"foo\"},\n\t\t\twant:  0,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"overflow int\",\n\t\t\tjson:  `{\"foo\":9223372036854775808}`,\n\t\t\tkeys:  []string{\"foo\"},\n\t\t\twant:  0,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"underflow int\",\n\t\t\tjson:  `{\"foo\":-9223372036854775809}`,\n\t\t\tkeys:  []string{\"foo\"},\n\t\t\twant:  0,\n\t\t\twant1: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tvar v Value\n\t\t\tif err := v.Parse(tt.json); err != nil {\n\t\t\t\tt.Errorf(\"Parse() error = %v, wantErr %v\", err, false)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tgot := v.GetInt(tt.keys...)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"GetInt() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","31708e9592fc730726c6da06f0a4e763":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetObject(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tjson  string\n\t\tkeys  []string\n\t\twant  *Object\n\t\twant1 bool\n\t}{\n\t\t{\n\t\t\tname:  \"simple object\",\n\t\t\tjson:  `{\"foo\": {\"bar\": \"baz\"}}`,\n\t\t\tkeys:  []string{\"foo\"},\n\t\t\twant:  \u0026Object{kvs: []kv{{k: \"bar\", v: \u0026Value{t: TypeString, s: \"baz\"}}}},\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"nested object\",\n\t\t\tjson:  `{\"foo\": {\"bar\": {\"baz\": \"qux\"}}}`,\n\t\t\tkeys:  []string{\"foo\", \"bar\"},\n\t\t\twant:  \u0026Object{kvs: []kv{{k: \"baz\", v: \u0026Value{t: TypeString, s: \"qux\"}}}},\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array index\",\n\t\t\tjson:  `{\"foo\": [{\"bar\": \"baz\"}]}`,\n\t\t\tkeys:  []string{\"foo\", \"0\"},\n\t\t\twant:  \u0026Object{kvs: []kv{{k: \"bar\", v: \u0026Value{t: TypeString, s: \"baz\"}}}},\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"non-existing key\",\n\t\t\tjson:  `{\"foo\": {\"bar\": \"baz\"}}`,\n\t\t\tkeys:  []string{\"qux\"},\n\t\t\twant:  nil,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"invalid key type\",\n\t\t\tjson:  `{\"foo\": {\"bar\": \"baz\"}}`,\n\t\t\tkeys:  []string{\"foo\", \"bar\", \"baz\"},\n\t\t\twant:  nil,\n\t\t\twant1: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv, err := ParseBytes([]byte(tt.json))\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"ParseBytes() error = %v, wantErr %v\", err, nil)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tgot, got1 := v.GetObject(tt.keys...)\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"Value.GetObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t\tif (got == nil \u0026\u0026 tt.want != nil) || (got != nil \u0026\u0026 tt.want == nil) {\n\t\t\t\tt.Errorf(\"Value.GetObject() = %v, want %v\", got, tt.want)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != nil {\n\t\t\t\tfor i, kv := range got.kvs {\n\t\t\t\t\tif kv.k != tt.want.kvs[i].k {\n\t\t\t\t\t\tt.Errorf(\"Value.GetObject() key = %v, want %v\", kv.k, tt.want.kvs[i].k)\n\t\t\t\t\t}\n\t\t\t\t\tif kv.v.Type() != tt.want.kvs[i].v.Type() {\n\t\t\t\t\t\tt.Errorf(\"Value.GetObject() value type = %v, want %v\", kv.v.Type(), tt.want.kvs[i].v.Type())\n\t\t\t\t\t}\n\t\t\t\t\tif kv.v.Type() == TypeString \u0026\u0026 kv.v.s != tt.want.kvs[i].v.s {\n\t\t\t\t\t\tt.Errorf(\"Value.GetObject() value = %v, want %v\", kv.v.s, tt.want.kvs[i].v.s)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","333e884dc25e2d7b7f3d4f1c2e529dc0":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput  string\n\t\texpect string\n\t\ttail   string\n\t\terr    error\n\t}{\n\t\t// Basic cases\n\t\t{`\"hello\"world`, \"hello\", \"world\", nil},\n\t\t{`\"hello\"\"world\"`, \"hello\", `\"world\"`, nil},\n\t\t{`\"hello`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\n\t\t// Escaped quotes\n\t\t{`\"hello \\\"world\\\"\"`, `hello \"world\"`, \"\", nil},\n\t\t{`\"hello\\\\\"world\"`, `hello\\`, `world\"`, nil},\n\t\t{`\"hello\\\\\\\\\"world\"`, `hello\\\\`, `world\"`, nil},\n\n\t\t// Complex cases\n\t\t{`\"hello\\\\\\\"world\\\\\\\" \"tail`, `hello\\\"world\\\" `, `tail`, nil},\n\t\t{`\"\\\\\"escaped quotes\\\\\"\"`, `\\\"escaped quotes\\\"`, \"\", nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tresult, tail, err := parseRawString(tt.input)\n\t\t\tif result != tt.expect {\n\t\t\t\tt.Errorf(\"Expected result '%s', but got '%s'\", tt.expect, result)\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"Expected tail '%s', but got '%s'\", tt.tail, tail)\n\t\t\t}\n\t\t\tif (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"Expected error '%v', but got '%v'\", tt.err, err)\n\t\t\t}\n\t\t})\n\t}\n}","33bbc286c9451caee7ebaaf46dcc21c3":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_reset(t *testing.T) {\n\to := \u0026Object{\n\t\tkvs: []kv{\n\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t},\n\t}\n\n\to.reset()\n\n\tif len(o.kvs) != 1 {\n\t\tt.Errorf(\"Expected length of kvs to be 1 after reset, got %d\", len(o.kvs))\n\t}\n\n\tif o.kvs[0].k != \"key1\" {\n\t\tt.Errorf(\"Expected key to be 'key1' after reset, got '%s'\", o.kvs[0].k)\n\t}\n}","34b7165e20b8f325f1cd12eb03dfd9f7":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestValue_Int(t *testing.T) {\n\tvar v Value\n\tif _, err := v.Int(); err == nil {\n\t\tt.Errorf(\"expecting error when trying to extract int from %s\", v.Type())\n\t}\n\tv.t = TypeNumber\n\tv.s = \"1234\"\n\tn, err := v.Int()\n\tif err != nil {\n\t\tt.Errorf(\"unexpected error: %s\", err)\n\t}\n\tif n != 1234 {\n\t\tt.Errorf(\"unexpected int %d. Expecting 1234\", n)\n\t}\n}\n\nfunc TestValue_IntError(t *testing.T) {\n\tvar v Value\n\tv.t = TypeNumber\n\tv.s = \"9223372036854775808\"\n\tif _, err := v.Int(); err == nil {\n\t\tt.Error(\"expecting error when trying to extract int from too big number\")\n\t}\n}","34e720be16f6ed3adf8118013d3b1dfe":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\tserr  string\n\t}{\n\t\t//TODO: Add test cases.\n\t}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseObject(tt.input, c, 0)\n\t\t\tif tt.serr != \"\" {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"expected error %q but got nil\", tt.serr)\n\t\t\t\t} else if err.Error() != tt.serr {\n\t\t\t\t\tt.Errorf(\"expected error %q but got %q\", tt.serr, err.Error())\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t}\n\t\t\tif s != \"\" {\n\t\t\t\tt.Errorf(\"unexpected remaining string: %q\", s)\n\t\t\t}\n\t\t\tif got == nil \u0026\u0026 tt.want == nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got == nil \u0026\u0026 tt.want != nil {\n\t\t\t\tt.Errorf(\"want non-nil but got nil\")\n\t\t\t\treturn\n\t\t\t} else if got != nil \u0026\u0026 tt.want == nil {\n\t\t\t\tt.Errorf(\"want nil but got %v\", got)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got.Type() != tt.want.Type() {\n\t\t\t\tt.Errorf(\"type mismatch. want: %v, got: %v\", tt.want.Type(), got.Type())\n\t\t\t}\n\t\t})\n\t}\n}\n","352054701a05c0ea76f056039ee028d9":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic escapes\n\t\t{`\\b`, \"\\b\"},\n\t\t{`\\f`, \"\\f\"},\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\r`, \"\\r\"},\n\t\t{`\\t`, \"\\t\"},\n\t\t{`\\\\`, \"\\\\\"},\n\t\t{`\\/`, \"/\"},\n\t\t{`\\\"`, \"\\\"\"},\n\n\t\t// Unicode escapes\n\t\t{`\\u0000`, \"\\x00\"},\n\t\t{`\\u001A`, \"\\x1A\"},\n\t\t{`\\u007F`, \"\\x7F\"},\n\t\t{`\\u0080`, \"\\xC2\\x80\"},\n\t\t{`\\u07FF`, \"\\xDF\\xBF\"},\n\t\t{`\\u0800`, \"\\xE0\\xA0\\x80\"},\n\t\t{`\\uFFFF`, \"\\xEF\\xBF\\xBF\"},\n\t\t{`\\uD800\\uDC00`, \"\\xF0\\x90\\x80\\x80\"}, // surrogate pair\n\t\t{`\\uD83D\\uDE01`, \"üòÅ\"},             // emoji\n\n\t\t// Invalid escapes\n\t\t{`\\a`, `\\a`},\n\t\t{`\\x`, `\\x`},\n\t\t{`\\`, `\\`},\n\t\t{`\\u`, `\\u`},\n\t\t{`\\u00`, `\\u00`},\n\t\t{`\\u000`, `\\u000`},\n\t\t{`\\u000G`, `\\u000G`},\n\t\t{`\\uD800`, `\\uD800`}, // unpaired surrogate\n\t\t{`\\uDC00`, `\\uDC00`}, // unpaired surrogate\n\t\t{`\\uD800\\uD800`, `\\uD800\\uD800`}, // two high surrogates\n\t\t{`\\uDC00\\uDC00`, `\\uDC00\\uDC00`}, // two low surrogates\n\n\t\t// Mixed strings\n\t\t{`Hello, \\tworld! This is a test.\\n`, \"Hello, \\tworld! This is a test.\\n\"},\n\t\t{`This string has \\u0022quotes\\u0022 in it.`, \"This string has \\\"quotes\\\" in it.\"},\n\t\t{`Invalid escapes are left alone: \\a\\x\\`, \"Invalid escapes are left alone: \\a\\x\\\\\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Input: %q\\nExpected: %q\\nActual:   %q\", test.input, test.expected, actual)\n\t\t}\n\t}\n}","36b8bc01cb6a97aac3ef6a838c4f1a2d":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic escapes\n\t\t{`\\b`, \"\\b\"},\n\t\t{`\\f`, \"\\f\"},\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\r`, \"\\r\"},\n\t\t{`\\t`, \"\\t\"},\n\t\t{`\\\\`, `\\`},\n\t\t{`\\/`, `/`},\n\t\t{`\\\"`, `\"`},\n\n\t\t// Unicode escapes\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A0`, \"\\u00A0\"},\n\t\t{`\\uFFFF`, \"\\uFFFF\"},\n\t\t{`\\uD83D\\uDE01`, \"\\U0001F601\"}, // Surrogate pair\n\n\t\t// Invalid escapes\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u`, `\\u`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\uD800`, `\\uD800`}, // Unpaired surrogate\n\t\t{`\\uDC00`, `\\uDC00`}, // Unpaired surrogate\n\n\t\t// Mixed content\n\t\t{`Hello\\tworld\\n`, \"Hello\\tworld\\n\"},\n\t\t{`\"This is a string with \\\\ escapes\"`, `\"This is a string with \\ escapes\"`},\n\t\t{`Path: C:\\\\Users\\\\John\\\\Documents`, `Path: C:\\Users\\John\\Documents`},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.input, func(t *testing.T) {\n\t\t\tactual := unescapeStringBestEffort(test.input)\n\t\t\tif actual != test.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", test.input, actual, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}","387bddf6b1481bddeded9525ddd43a5d":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic escapes\n\t\t{\"\\\\\\\"\", \"\\\"\"},\n\t\t{\"\\\\\\\\\", \"\\\\\"},\n\t\t{\"\\\\/\", \"/\"},\n\t\t{\"\\\\b\", \"\\b\"},\n\t\t{\"\\\\f\", \"\\f\"},\n\t\t{\"\\\\n\", \"\\n\"},\n\t\t{\"\\\\r\", \"\\r\"},\n\t\t{\"\\\\t\", \"\\t\"},\n\n\t\t// Unicode escapes\n\t\t{\"\\\\u0020\", \" \"},\n\t\t{\"\\\\u00A9\", \"¬©\"},\n\t\t{\"\\\\uD83D\\\\uDE04\", \"üòÑ\"}, // Surrogate pair\n\n\t\t// Invalid escapes\n\t\t{\"\\\\a\", \"\\\\a\"},\n\t\t{\"\\\\x\", \"\\\\x\"},\n\t\t{\"\\\\u123\", \"\\\\u123\"},\n\t\t{\"\\\\uD800\\\\uDC00\\\\\", \"\\\\uD800\\\\uDC00\\\\\"}, // Incomplete surrogate pair\n\n\t\t// Mixed content\n\t\t{\"hello\\\\tworld\\\\n\", \"hello\\tworld\\n\"},\n\t\t{\"{\\\"foo\\\":\\\"bar\\\\nbaz\\\"}\", \"{\\\"foo\\\":\\\"bar\\nbaz\\\"}\"},\n\n\t\t// No escapes\n\t\t{\"\", \"\"},\n\t\t{\"hello world\", \"hello world\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}\n","39322df48baace138a017c3d3bc1d3b5":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetArray(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tjson  string\n\t\tkeys  []string\n\t\twant  []*Value\n\t\twant1 bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty_array\",\n\t\t\tjson:  `[]`,\n\t\t\tkeys:  []string{},\n\t\t\twant:  []*Value{},\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"simple_array\",\n\t\t\tjson:  `[1,2,3]`,\n\t\t\tkeys:  []string{},\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"nested_array\",\n\t\t\tjson:  `[[1,2],[3,4]]`,\n\t\t\tkeys:  []string{\"1\"},\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"index_out_of_range\",\n\t\t\tjson:  `[1,2,3]`,\n\t\t\tkeys:  []string{\"3\"},\n\t\t\twant:  nil,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"key_is_not_array\",\n\t\t\tjson:  `{\"a\":1}`,\n\t\t\tkeys:  []string{\"a\"},\n\t\t\twant:  nil,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"key_does_not_exist\",\n\t\t\tjson:  `{\"a\":1}`,\n\t\t\tkeys:  []string{\"b\"},\n\t\t\twant:  nil,\n\t\t\twant1: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv, _ := Parse(tt.json)\n\t\t\tgot := v.GetArray(tt.keys...)\n\t\t\tif (got == nil) != (tt.want == nil) {\n\t\t\t\tt.Errorf(\"Value.GetArray() got = %v, want %v\", got, tt.want)\n\t\t\t} else if got != nil \u0026\u0026 len(got) != len(tt.want) {\n\t\t\t\tt.Errorf(\"Value.GetArray() got = %v, want %v\", got, tt.want)\n\t\t\t} else if got != nil {\n\t\t\t\tfor i := range got {\n\t\t\t\t\tif got[i].Type() != tt.want[i].Type() {\n\t\t\t\t\t\tt.Errorf(\"Value.GetArray() got = %v, want %v\", got, tt.want)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t})\n\t}\n}\n","3a0ad62efe4f25d6536920f0034c4190":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic strings without escape sequences.\n\t\t{\"hello\", \"hello\"},\n\t\t{\"world\", \"world\"},\n\t\t{\"12345\", \"12345\"},\n\n\t\t// Simple escape sequences.\n\t\t{`\\\"hello\\\"`, `\"hello\"`},\n\t\t{`\\\\world\\\\`, `\\world\\`},\n\t\t{`\\/path\\/to\\/file`, `/path/to/file`},\n\t\t{`\\b\\f\\n\\r\\t`, \"\\b\\f\\n\\r\\t\"},\n\n\t\t// Unicode escape sequences.\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A9`, \"¬©\"},\n\t\t{`\\u20AC`, \"‚Ç¨\"},\n\t\t{\"\\u2018Single quotes\\u2019\", \"‚ÄòSingle quotes‚Äô\"},\n\t\t{\"\\u201CSingle quotes\\u201D\", \"‚ÄúSingle quotes‚Äù\"},\n\n\t\t// Surrogate pairs.\n\t\t{`\\uD83D\\uDE01`, \"üòÅ\"},\n\t\t{\"This is a \\uD83D\\uDE01 smiley face.\", \"This is a üòÅ smiley face.\"},\n\n\t\t// Invalid escape sequences.\n\t\t{`\\a\\c\\v`, \"\\\\a\\\\c\\\\v\"},\n\t\t{`\\u123`, \"\\\\u123\"},\n\t\t{`\\uD800`, \"\\\\uD800\"},\n\t\t{`\\uD83D\\u1234`, \"\\\\uD83D\\u1234\"},\n\n\t\t// Mixed valid and invalid escape sequences.\n\t\t{`\"This is a \\uD83D\\uDE01 smiley face with a \\uD800 problem.\"`, \"This is a üòÅ smiley face with a \\\\uD800 problem.\"},\n\n\t\t// Empty strings and strings with only escape sequences.\n\t\t{\"\", \"\"},\n\t\t{`\\\"\\\"`, `\"\"`},\n\t\t{`\\\\\\\\`, `\\\\`},\n\t}\n\n\tfor i, tt := range tests {\n\t\tactual := unescapeStringBestEffort(tt.input)\n\t\tif actual != tt.expected {\n\t\t\tt.Errorf(\"Test %d: Expected '%s', but got '%s'\", i, tt.expected, actual)\n\t\t}\n\t}\n}\n","3a398eada6bb87a5c52c84d718887602":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Object(t *testing.T) {\n\ttests := [1]struct {\n\t\tname    string\n\t\tv       *Value\n\t\twant    *Object\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{},\n\t\t\t},\n\t\t\twant:    \u0026Object{},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := tt.v.Object()\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Value.Object() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Value.Object() = %p, want %p\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","3aaf7a1aae8189f0ac66ba79a7f3d3ae":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"raw string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"raw string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"12345\",\n\t\t\t},\n\t\t\twant: []byte(\"12345\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"hello\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"12345\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"[\\\"hello\\\",12345]\"),\n\t\t},\n\t\t// Add more test cases for other types and nested objects/arrays\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif string(got) != string(tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", string(got), string(tt.want))\n\t\t\t}\n\t\t})\n\t}\n}\n","3b184aa717383a10e0642287c3ad0201":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Empty array\n\t\t{\"[]\", \u0026Value{t: TypeArray, a: []*Value{}}, \"\", nil},\n\t\t// Simple array\n\t\t{\"[1,2,3]\", \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t}}, \"\", nil},\n\t\t// Array with whitespace\n\t\t{\" [ 1 , 2 , 3 ] \", \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t}}, \"\", nil},\n\t\t// Nested array\n\t\t{\"[[1,2],[3,4]]\", \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t}},\n\t\t\t{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t{t: TypeNumber, s: \"4\"},\n\t\t\t}},\n\t\t}}, \"\", nil},\n\t\t// Array with different types\n\t\t{\"[1,\\\"hello\\\",true]\", \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t{t: TypeString, s: \"hello\"},\n\t\t\t{t: TypeTrue},\n\t\t}}, \"\", nil},\n\t\t// Invalid array: missing closing bracket\n\t\t{\"[1,2,3\", nil, \"\", fmt.Errorf(\"unexpected end of array\")},\n\t\t// Invalid array: missing comma\n\t\t{\"[1 2 3]\", nil, \"2 3]\", fmt.Errorf(\"missing ',' after array value\")},\n\t\t// Invalid array: trailing comma\n\t\t{\"[1,2,]\", nil, \"\", fmt.Errorf(\"cannot parse array value: unexpected end of object\")},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d:%s\", i, tt.input), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, tail, err := parseArray(tt.input, c, 0)\n\n\t\t\tif (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err == nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"parseArray(%s) error = %v, wantErr %v\", tt.input, err, tt.err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"parseArray(%s) tail = %s, wantTail %s\", tt.input, tail, tt.tail)\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray(%s) = %v, want %v\", tt.input, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\treturn v1.s == v2.s\n\t}\n}","3c43fd358c0d29f9399e5e3093638908":"package fastjson\n\nimport \"testing\"\n\nfunc TestSkipWS(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"  \\n\\t\\r foo\", \"foo\"},\n\t\t{\"foo\", \"foo\"},\n\t\t{\"\\x00foo\", \"\\x00foo\"},\n\t\t{\"  \\n\\t\\r \", \"\"},\n\t}\n\tfor _, test := range tests {\n\t\tactual := skipWS(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"skipWS(%q) = %q, want %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}\n","3c5d58b5438759a28be54d5c21c2f82c":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Array(t *testing.T) {\n\ttests := []struct {\n\t\tinput       string\n\t\twantArray   []*Value\n\t\twantErr     bool\n\t\twantErrText string\n\t}{\n\t\t{\n\t\t\tinput:       \"[]\",\n\t\t\twantArray:   []*Value{},\n\t\t\twantErr:     false,\n\t\t\twantErrText: \"\",\n\t\t},\n\t\t{\n\t\t\tinput:       \"[1,2,3]\",\n\t\t\twantArray:   []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}},\n\t\t\twantErr:     false,\n\t\t\twantErrText: \"\",\n\t\t},\n\t\t{\n\t\t\tinput:       `[{\"a\":1},{\"b\":2}]`,\n\t\t\twantArray: []*Value{{t: TypeObject, o: \u0026Object{kvs: []kv{{k: \"a\", v: \u0026Value{t: TypeNumber, s: \"1\"}}}}}}, {t: TypeObject, o: \u0026Object{kvs: []kv{{k: \"b\", v: \u0026Value{t: TypeNumber, s: \"2\"}}}}}}},\n\t\t\twantErr:     false,\n\t\t\twantErrText: \"\",\n\t\t},\n\t\t{\n\t\t\tinput:       \"null\",\n\t\t\twantArray:   nil,\n\t\t\twantErr:     true,\n\t\t\twantErrText: \"json: cannot unmarshal null into Go value of type []*fastjson.Value\",\n\t\t},\n\t\t{\n\t\t\tinput:       \"123\",\n\t\t\twantArray:   nil,\n\t\t\twantErr:     true,\n\t\t\twantErrText: \"json: cannot unmarshal number into Go value of type []*fastjson.Value\",\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tp := Parser{}\n\t\tv, err := p.Parse(test.input)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Parse error: %v\", err)\n\t\t}\n\n\t\tgotArray, err := v.Array()\n\n\t\tif test.wantErr {\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"Expected error, got nil for input: %s\", test.input)\n\t\t\t}\n\t\t\tif err.Error() != test.wantErrText {\n\t\t\t\tt.Errorf(\"Error mismatch. Want: %s, Got: %s\", test.wantErrText, err.Error())\n\t\t\t}\n\t\t} else {\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Unexpected error for input %s: %v\", test.input, err)\n\t\t\t}\n\n\t\t\tif len(gotArray) != len(test.wantArray) {\n\t\t\t\tt.Errorf(\"Array length mismatch. Want: %v, Got: %v\", len(test.wantArray), len(gotArray))\n\t\t\t}\n\n\t\t\tfor i, wantVal := range test.wantArray {\n\t\t\t\tgotVal := gotArray[i]\n\t\t\t\tif wantVal.t != gotVal.t {\n\t\t\t\t\tt.Errorf(\"Type mismatch for index %d. Want: %v, Got: %v\", i, wantVal.t, gotVal.t)\n\t\t\t\t}\n\n\t\t\t\tif wantVal.s != gotVal.s {\n\t\t\t\t\tt.Errorf(\"String value mismatch for index %d. Want: %s, Got: %s\", i, wantVal.s, gotVal.s)\n\t\t\t\t}\n\n\t\t\t\tif wantVal.o != nil \u0026\u0026 gotVal.o != nil {\n\t\t\t\t\t// Compare the objects here\n\t\t\t\t\tif len(wantVal.o.kvs) != len(gotVal.o.kvs) {\n\t\t\t\t\t\tt.Errorf(\"Object key-value pair count mismatch for index %d. Want: %d, Got: %d\", i, len(wantVal.o.kvs), len(gotVal.o.kvs))\n\t\t\t\t\t}\n\t\t\t\t\t// Add more detailed comparison if needed\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","3c85e974218694a7de9cb13fa4be2f63":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Empty string\n\t\t{\"\", nil, \"\", fmt.Errorf(\"cannot parse empty string\")},\n\t\t// Invalid JSON\n\t\t{\"{\", nil, \"\", fmt.Errorf(\"cannot parse object: missing '}'\")},\n\t\t// Object\n\t\t{`{\"foo\": \"bar\"}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: typeRawString, s: \"bar\"}}}}}, \"}\", nil},\n\t\t// Array\n\t\t{`[1, \"foo\", true]`, \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: typeRawString, s: \"foo\"}, {t: TypeTrue}}}, \"]\", nil},\n\t\t// String\n\t\t{`\"foo\"`, \u0026Value{t: typeRawString, s: \"foo\"}, \"\", nil},\n\t\t// True\n\t\t{\"true\", valueTrue, \"\", nil},\n\t\t// False\n\t\t{\"false\", valueFalse, \"\", nil},\n\t\t// Null\n\t\t{\"null\", valueNull, \"\", nil},\n\t\t// Number\n\t\t{\"123\", \u0026Value{t: TypeNumber, s: \"123\"}, \"\", nil},\n\t\t// NaN\n\t\t{\"NaN\", \u0026Value{t: TypeNumber, s: \"Na\"}, \"N\", nil},\n\t\t// Whitespace handling\n\t\t{\"  \\n\\t\\r null\", valueNull, \"\", nil},\n\t}\n\n\tc := \u0026cache{}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tgot, tail, err := parseValue(tt.input, c, 0)\n\t\t\tif fmt.Sprintf(\"%v\", err) != fmt.Sprintf(\"%v\", tt.err) {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, want %v\", tt.input, err, tt.err)\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"parseValue(%q) tail = %q, want %q\", tt.input, tail, tt.tail)\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", tt.input, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.t == TypeObject {\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\tif v1.t == TypeArray {\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\treturn v1.s == v2.s\n}\n","3d1a0785dcf3d2378895c989662c217c":"package fastjson\n\nimport \"testing\"\n\nfunc TestValue_GetInt(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tjson  string\n\t\tkeys  []string\n\t\twant  int\n\t\twant1 bool\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv, _ := Parse(tt.json)\n\t\t\tgot := v.GetInt(tt.keys...)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Value.GetInt() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","3d2d4a89f500c5677c5352bea33edf13":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantObj  string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t{\n\t\t\tname:     \"empty object\",\n\t\t\tinput:    \"{}\",\n\t\t\twantObj:  `{\"t\":1}`,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"simple object\",\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\twantObj:  `{\"t\":1,\"o\":{\"kvs\":[{\"k\":\"key\",\"v\":{\"t\":3,\"s\":\"value\"}}]}}`,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple key-value pairs\",\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 123, \"key3\": true}`,\n\t\t\twantObj:  `{\"t\":1,\"o\":{\"kvs\":[{\"k\":\"key1\",\"v\":{\"t\":3,\"s\":\"value1\"}},{\"k\":\"key2\",\"v\":{\"t\":4,\"s\":\"123\"}},{\"k\":\"key3\",\"v\":{\"t\":5}}]}}`,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"nested object\",\n\t\t\tinput:    `{\"key1\": {\"key2\": \"value2\"}, \"key3\": \"value3\"}`,\n\t\t\twantObj:  `{\"t\":1,\"o\":{\"kvs\":[{\"k\":\"key1\",\"v\":{\"t\":1,\"o\":{\"kvs\":[{\"k\":\"key2\",\"v\":{\"t\":3,\"s\":\"value2\"}}]}}},{\"k\":\"key3\",\"v\":{\"t\":3,\"s\":\"value3\"}}]}}`,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing closing brace\",\n\t\t\tinput:    `{\"key\": \"value\"`,\n\t\t\twantObj:  \"\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"missing colon\",\n\t\t\tinput:    `{\"key\" \"value\"}`,\n\t\t\twantObj:  \"\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"missing comma\",\n\t\t\tinput:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantObj:  \"\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgotObj, gotTail, gotErr := parseObject(tt.input, c, 0)\n\n\t\t\tif gotErr != nil {\n\t\t\t\tif gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", gotErr, tt.wantErr)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif fmt.Sprintf(\"%+v\", gotObj) != tt.wantObj {\n\t\t\t\tt.Errorf(\"parseObject() gotObj = %+v, wantObj %v\", gotObj, tt.wantObj)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseObject() gotTail = %v, wantTail %v\", gotTail, tt.wantTail)\n\t\t\t}\n\t\t})\n\t}\n}","3d6e3f3ce2b90894ed5585626a6d5265":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEscapeString(t *testing.T) {\n\ttests := []struct {\n\t\tin     string\n\t\texpect []byte\n\t}{\n\t\t{\"\", []byte{`\"\"`}},\n\t\t{\"hello\", []byte{`\"hello\"`}},\n\t\t{\"\\t\\n\", []byte{`\"\\t\\n\"`}},\n\t\t{\"\\\"\\x00\\x01\", []byte{`\"\\\"\\u0000\\u0001\"`}},\n\t}\n\n\tfor i, test := range tests {\n\t\tout := escapeString(nil, test.in)\n\t\tif string(out) != string(test.expect) {\n\t\t\tt.Errorf(\"Test %d: expected %q, got %q\", i, test.expect, out)\n\t\t}\n\t}\n}","3d8f6ad0ab0bfb926e53c4a95ced9ccd":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twant     *Value\n\t\twantRest string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"empty array\",\n\t\t\tinput:    \"[]\",\n\t\t\twant:     \u0026Value{t: TypeArray, a: []*Value{}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"simple array\",\n\t\t\tinput:    \"[1,2,3]\",\n\t\t\twant:     \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with spaces\",\n\t\t\tinput:    \" [ 1 , 2 , 3 ] \",\n\t\t\twant:     \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"nested array\",\n\t\t\tinput:    \"[[1,2],[3,4]]\",\n\t\t\twant: \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}}},\n\t\t\t\t{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"3\"}, {t: TypeNumber, s: \"4\"}}},\n\t\t\t}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing ]\",\n\t\t\tinput:    \"[1,2,3\",\n\t\t\twant:     nil,\n\t\t\twantRest: \"\",\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing ,\",\n\t\t\tinput:    \"[1,2 3]\",\n\t\t\twant:     nil,\n\t\t\twantRest: \"\",\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, rest, err := parseArray(tt.input, c, 0)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif fmt.Sprintf(\"%v\", got) != fmt.Sprintf(\"%v\", tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif rest != tt.wantRest {\n\t\t\t\tt.Errorf(\"parseArray() rest = %v, wantRest %v\", rest, tt.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}\n","3f31a54f585efbbec2a16c87a8cbe8e0":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twant     *Value\n\t\twantRest string\n\t\twantErr  error\n\t}{\n\t\t{\n\t\t\tname:     \"empty array\",\n\t\t\tinput:    \"[]\",\n\t\t\twant:     \u0026Value{t: TypeArray},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"single element array\",\n\t\t\tinput:    \"[1]\",\n\t\t\twant:     \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple elements array\",\n\t\t\tinput:    \"[1,2,3]\",\n\t\t\twant:     \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with whitespace\",\n\t\t\tinput:    \" [ 1 , 2 , 3 ] \",\n\t\t\twant:     \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"nested array\",\n\t\t\tinput:    \"[[1,2],[3,4]]\",\n\t\t\twant: \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}}},\n\t\t\t\t{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"3\"}, {t: TypeNumber, s: \"4\"}}},\n\t\t\t}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing ]\",\n\t\t\tinput:    \"[1,2\",\n\t\t\twant:     nil,\n\t\t\twantRest: \"\",\n\t\t\twantErr:  fmt.Errorf(\"unexpected end of array\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"missing ,\",\n\t\t\tinput:    \"[1 2]\",\n\t\t\twant:     nil,\n\t\t\twantRest: \"\",\n\t\t\twantErr:  fmt.Errorf(\"missing ',' after array value\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, rest, err := parseArray(tt.input, c, 0)\n\t\t\tif (err != nil \u0026\u0026 tt.wantErr == nil) || (err == nil \u0026\u0026 tt.wantErr != nil) || (err != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 err.Error() != tt.wantErr.Error()) {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif rest != tt.wantRest {\n\t\t\t\tt.Errorf(\"parseArray() rest = %v, wantRest %v\", rest, tt.wantRest)\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.t == TypeArray {\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\treturn v1.s == v2.s\n}","3f357661c008ff56cdc0f9cfad225fac":"package fastjson\n\nimport \"testing\"\n\nfunc TestValue_Bool(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tv       *Value\n\t\twant    bool\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"true\",\n\t\t\tv:       \u0026Value{t: TypeTrue},\n\t\t\twant:    true,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"false\",\n\t\t\tv:       \u0026Value{t: TypeFalse},\n\t\t\twant:    false,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid\",\n\t\t\tv:       \u0026Value{t: TypeString},\n\t\t\twant:    false,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := tt.v.Bool()\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Bool() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Bool() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","3f7572e75236edb893fcc23f31599964":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic strings\n\t\t{\"hello\", \"hello\"},\n\t\t{\"world\", \"world\"},\n\n\t\t// Escaped characters\n\t\t{`\\\"hello\\\"`, `\"hello\"`},\n\t\t{`\\\\hello\\\\`, `\\hello\\`},\n\t\t{`\\/hello\\/`, `/hello/`},\n\t\t{`\\bhello\\b`, \"\\bhello\\b\"},\n\t\t{`\\fhello\\f`, \"\\fhello\\f\"},\n\t\t{`\\nhello\\n`, \"\\nhello\\n\"},\n\t\t{`\\rhello\\r`, \"\\rhello\\r\"},\n\t\t{`\\thello\\t`, \"\\thello\\t\"},\n\n\t\t// Unicode escape sequences\n\t\t{`\\u0041`, \"A\"},\n\t\t{`\\u00e9`, \"√©\"},\n\t\t{`\\u20ac`, \"‚Ç¨\"},\n\n\t\t// Surrogate pairs\n\t\t{`\\uD83D\\uDE02`, \"üòÇ\"},\n\n\t\t// Invalid escape sequences\n\t\t{`\\u004`, `\\u004`},\n\t\t{`\\u004x`, `\\u004x`},\n\t\t{`\\uD800`, `\\uD800`},\n\t\t{`\\uD800\\uDC00x`, `\\uD800\\uDC00x`},\n\n\t\t// Mixed strings\n\t\t{`hello\\tworld`, \"hello\\tworld\"},\n\t\t{`\"hello\\tworld\"`, `\"hello\\tworld\"`},\n\t\t{`\\u0041\\u00e9\\u20ac`, \"A√©‚Ç¨\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}","40a195db240c45247c569f188288dc15":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey   string\n\t\tvalue string\n\t\terr   error\n\t}{\n\t\t{`\"foo\"`, \"foo\", \"\", nil},\n\t\t{`\"fo\\\"o\"`, `fo\"o`, \"\", nil},\n\t\t{`\"fo\\\\o\"`, `fo\\o`, \"\", nil},\n\t\t{`\"fo\\ooo\"`, `fo\\ooo`, \"\", nil},\n\t\t{`\"fo\\\\oo\"`, `fo\\\\oo`, \"\", nil},\n\t\t{`\"fo\\\\\\\\o\"`, `fo\\\\o`, \"\", nil},\n\t\t{`\"foo`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"fo\\o\"`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"fo\\o`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test %d\", i), func(t *testing.T) {\n\t\t\tkey, value, err := parseRawString(tt.input)\n\t\t\tif key != tt.key || value != tt.value || (err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"input: %q, expect got %q %q %v, but got %q %q %v\", tt.input, tt.key, tt.value, tt.err, key, value, err)\n\t\t\t}\n\t\t})\n\t}\n}\n","40bce8756653a7f7b2a826f9d1e70a02":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantJSON string\n\t\twantErr  error\n\t}{\n\t\t{\n\t\t\tname:     \"empty object\",\n\t\t\tinput:    \"{}\",\n\t\t\twantJSON: `{}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"simple object\",\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\twantJSON: `{\"key\":\"value\"}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"object with multiple keys\",\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantJSON: `{\"key1\":\"value1\",\"key2\":\"value2\"}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"object with nested object\",\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": {\"nestedKey\": \"nestedValue\"}}`,\n\t\t\twantJSON: `{\"key1\":\"value1\",\"key2\":{\"nestedKey\":\"nestedValue\"}}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"object with array\",\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": [\"item1\", \"item2\"]}`,\n\t\t\twantJSON: `{\"key1\":\"value1\",\"key2\":[\"item1\",\"item2\"]}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"object with escaped characters\",\n\t\t\tinput:    `{\"key1\": \"value1\\nwith\\tescapes\", \"key2\": \"value2\"}`,\n\t\t\twantJSON: `{\"key1\":\"value1\\nwith\\tescapes\",\"key2\":\"value2\"}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid object: missing closing brace\",\n\t\t\tinput:    `{\"key\": \"value\"`,\n\t\t\twantErr:  fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid object: missing colon\",\n\t\t\tinput:    `{\"key\" \"value\"}`,\n\t\t\twantErr:  fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid object: missing comma\",\n\t\t\tinput:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr:  fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseObject(tt.input, c, 0)\n\t\t\tif tt.wantErr != nil {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"parseObject() error = nil, wantErr %v\", tt.wantErr)\n\t\t\t\t} else if err.Error() != tt.wantErr.Error() {\n\t\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr nil\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif s != \"\" {\n\t\t\t\tt.Errorf(\"parseObject() extra characters at the end: %s\", s)\n\t\t\t}\n\t\t\tgotJSON := got.MarshalTo(nil)\n\t\t\tif string(gotJSON) != tt.wantJSON {\n\t\t\t\tt.Errorf(\"parseObject() = %s, want %s\", gotJSON, tt.wantJSON)\n\t\t\t}\n\t\t})\n\t}\n}\n","41702ffcac5eb63c344593da8804a2ae":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey   string\n\t\tvalue string\n\t\terr   error\n\t}{\n\t\t// Basic cases\n\t\t{`\"foo\":\"bar\"`, \"foo\", \"bar\", nil},\n\t\t{`\"key\":\"value\"`, \"key\", \"value\", nil},\n\n\t\t// Escaped quotes\n\t\t{`\"foo\\\":\\\"bar\\\"\"`, \"foo\", `bar\"`, nil},\n\t\t{`\"key\\\\\"\":\\\"value\\\"\"`, `key\\\"`, `\"value\"`, nil},\n\n\t\t// Missing closing quote\n\t\t{`\"foo\":\"bar`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo:bar\"`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\n\t\t// Empty key\n\t\t{`\"\":\"\"`, \"\", \"\", nil},\n\t\t{`:\"value\"`, \"\", \"value\", nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tkey, value, err := parseRawString(tt.input)\n\t\t\tif key != tt.key || value != tt.value || !equalError(err, tt.err) {\n\t\t\t\tt.Errorf(\"parseRawString(%q): got (%q, %q, %v), want (%q, %q, %v)\", tt.input, key, value, err, tt.key, tt.value, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalError(err1, err2 error) bool {\n\tif err1 == nil \u0026\u0026 err2 == nil {\n\t\treturn true\n\t}\n\tif err1 == nil || err2 == nil {\n\t\treturn false\n\t}\n\treturn err1.Error() == err2.Error()\n}","418c69497f59b9f493827f62e95a9c11":"package fastjson\n\nimport \"testing\"\n\nfunc TestValue_GetBool(t *testing.T) {\n\tvar v Value\n\ttests := []struct {\n\t\tname  string\n\t\tjson  string\n\t\targs  []string\n\t\twantB bool\n\t}{\n\t\t{\n\t\t\tname:  \"simple true\",\n\t\t\tjson:  `{\"foo\":true}`,\n\t\t\targs:  []string{\"foo\"},\n\t\t\twantB: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"simple false\",\n\t\t\tjson:  `{\"foo\":false}`,\n\t\t\targs:  []string{\"foo\"},\n\t\t\twantB: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"number true\",\n\t\t\tjson:  `{\"foo\":1}`,\n\t\t\targs:  []string{\"foo\"},\n\t\t\twantB: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"string true\",\n\t\t\tjson:  `{\"foo\":\"true\"}`,\n\t\t\targs:  []string{\"foo\"},\n\t\t\twantB: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"nested true\",\n\t\t\tjson:  `{\"foo\":{\"bar\":true}}`,\n\t\t\targs:  []string{\"foo\", \"bar\"},\n\t\t\twantB: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"nested false\",\n\t\t\tjson:  `{\"foo\":{\"bar\":false}}`,\n\t\t\targs:  []string{\"foo\", \"bar\"},\n\t\t\twantB: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array true\",\n\t\t\tjson:  `{\"foo\":[true]}`,\n\t\t\targs:  []string{\"foo\", \"0\"},\n\t\t\twantB: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array false\",\n\t\t\tjson:  `{\"foo\":[false]}`,\n\t\t\targs:  []string{\"foo\", \"0\"},\n\t\t\twantB: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"missing key\",\n\t\t\tjson:  `{\"foo\":true}`,\n\t\t\targs:  []string{\"bar\"},\n\t\t\twantB: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"null\",\n\t\t\tjson:  `null`,\n\t\t\targs:  []string{\"foo\"},\n\t\t\twantB: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv.Parse(tt.json)\n\t\t\tif gotB := v.GetBool(tt.args...); gotB != tt.wantB {\n\t\t\t\tt.Errorf(\"Value.GetBool() = %v, want %v\", gotB, tt.wantB)\n\t\t\t}\n\t\t})\n\t}\n}","41eed9330e6f62c05d39e701011084a6":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput  string\n\t\tns     string\n\t\tremain string\n\t\terr    error\n\t}{\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"123a\", \"123\", \"a\", nil},\n\t\t{\"123.456\", \"123.456\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"+123\", \"+123\", \"\", nil},\n\t\t{\"1e5\", \"1e5\", \"\", nil},\n\t\t{\"1E5\", \"1E5\", \"\", nil},\n\t\t{\"1e+5\", \"1e+5\", \"\", nil},\n\t\t{\"1e-5\", \"1e-5\", \"\", nil},\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"+inf\", \"+inf\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"Inf\", \"Inf\", \"\", nil},\n\t\t{\"+Inf\", \"+Inf\", \"\", nil},\n\t\t{\"-Inf\", \"-Inf\", \"\", nil},\n\t\t{\"iN\", \"\", \"iN\", fmt.Errorf(\"unexpected char: %q\", \"i\")},\n\t\t{\"-iN\", \"\", \"-iN\", fmt.Errorf(\"unexpected char: %q\", \"-i\")},\n\t\t{\"+iN\", \"\", \"+iN\", fmt.Errorf(\"unexpected char: %q\", \"+i\")},\n\t}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tns, remain, err := parseRawNumber(tt.input)\n\t\t\tif ns != tt.ns || remain != tt.remain || (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"input: %q, expected: %q,%q,%v, got: %q,%q,%v\", tt.input, tt.ns, tt.remain, tt.err, ns, remain, err)\n\t\t\t}\n\t\t})\n\t}\n}","42a4581e9bcb47c9cae323e224321838":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"12345\",\n\t\t\t},\n\t\t\twant: []byte(`12345`),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(`true`),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(`false`),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(`null`),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"hello\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"12345\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`[\"hello\",12345]`),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"message\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"hello\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"code\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"12345\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`{\"message\":\"hello\",\"code\":\"12345\"}`),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif string(got) != string(tt.want) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","4317dd94c9c81cdfc7394fab018fe2c2":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantN    string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Basic cases.\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"+123\", \"+123\", \"\", nil},\n\t\t{\"123.456\", \"123.456\", \"\", nil},\n\t\t{\"-123.456\", \"-123.456\", \"\", nil},\n\t\t{\"+123.456\", \"+123.456\", \"\", nil},\n\t\t{\"1.2e3\", \"1.2e3\", \"\", nil},\n\t\t{\"1.2E3\", \"1.2E3\", \"\", nil},\n\t\t{\"1.2e+3\", \"1.2e+3\", \"\", nil},\n\t\t{\"1.2e-3\", \"1.2e-3\", \"\", nil},\n\t\t{\"1e3\", \"1e3\", \"\", nil},\n\t\t{\"1e+3\", \"1e+3\", \"\", nil},\n\t\t{\"1e-3\", \"1e-3\", \"\", nil},\n\t\t{\"123abc\", \"123\", \"abc\", nil},\n\t\t{\"-123abc\", \"-123\", \"abc\", nil},\n\t\t{\"+123abc\", \"+123\", \"abc\", nil},\n\n\t\t// Invalid cases.\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t\t{\"a\", \"\", \"a\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\"+a\", \"\", \"+a\", fmt.Errorf(\"unexpected char: %q\", \"+a\")},\n\t\t{\"-a\", \"\", \"-a\", fmt.Errorf(\"unexpected char: %q\", \"-a\")},\n\t\t{\"+abc\", \"\", \"+abc\", fmt.Errorf(\"unexpected char: %q\", \"+a\")},\n\t\t{\"-abc\", \"\", \"-abc\", fmt.Errorf(\"unexpected char: %q\", \"-a\")},\n\n\t\t// Special values.\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"+inf\", \"+inf\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"InF\", \"InF\", \"\", nil},\n\t\t{\"+InF\", \"+InF\", \"\", nil},\n\t\t{\"-InF\", \"-InF\", \"\", nil},\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"+nan\", \"+nan\", \"\", nil},\n\t\t{\"-nan\", \"-nan\", \"\", nil},\n\t\t{\"nAn\", \"nAn\", \"\", nil},\n\t\t{\"+nAn\", \"+nAn\", \"\", nil},\n\t\t{\"-nAn\", \"-nAn\", \"\", nil},\n\t\t{\"infabc\", \"inf\", \"abc\", nil},\n\t\t{\"+infabc\", \"+inf\", \"abc\", nil},\n\t\t{\"-infabc\", \"-inf\", \"abc\", nil},\n\t\t{\"nanabc\", \"nan\", \"abc\", nil},\n\t\t{\"+nanabc\", \"+nan\", \"abc\", nil},\n\t\t{\"-nanabc\", \"-nan\", \"abc\", nil},\n\t\t{\"in\", \"\", \"in\", fmt.Errorf(\"unexpected char: %q\", \"i\")},\n\t\t{\"+in\", \"\", \"+in\", fmt.Errorf(\"unexpected char: %q\", \"+i\")},\n\t\t{\"-in\", \"\", \"-in\", fmt.Errorf(\"unexpected char: %q\", \"-i\")},\n\t\t{\"na\", \"\", \"na\", fmt.Errorf(\"unexpected char: %q\", \"n\")},\n\t\t{\"+na\", \"\", \"+na\", fmt.Errorf(\"unexpected char: %q\", \"+n\")},\n\t\t{\"-na\", \"\", \"-na\", fmt.Errorf(\"unexpected char: %q\", \"-n\")},\n\t}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tgotN, gotTail, gotErr := parseRawNumber(tt.input)\n\t\t\tif gotN != tt.wantN {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got number = %q, want %q\", tt.input, gotN, tt.wantN)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got tail = %q, want %q\", tt.input, gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif gotErr == nil \u0026\u0026 tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got no error, want %v\", tt.input, tt.wantErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr == nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got error = %v, want nil\", tt.input, gotErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got error = %v, want %v\", tt.input, gotErr, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","438cdd38c430e24205d861b12ce862a1":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput    string\n\t\texpected string\n\t\tremain   string\n\t\terr      error\n\t}{\n\t\t// Simple cases\n\t\t{`\"hello\"world`, \"hello\", \"world\", nil},\n\t\t{`\"hello\"`, \"hello\", \"\", nil},\n\t\t{`\"\"world`, \"\", \"world\", nil},\n\n\t\t// Escaped quotes\n\t\t{`\"hello\\\\\"world\"`, \"hello\\\\\\\"world\", \"\", nil},\n\t\t{`\"hello\\\\\\\\\"world`, \"hello\\\\\\\\\", \"world\", nil},\n\t\t{`\"\\\\\"world\"`, \"\\\\\\\"world\", \"\", nil},\n\t\t{`\"\\\\\"world`, \"\\\\\", \"world\", nil},\n\n\t\t// Missing closing quote\n\t\t{`\"hello`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"hello\\\\`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\n\t\t// Empty string\n\t\t{`\"\"`, \"\", \"\", nil},\n\t\t{`\"`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"TestCase_%d\", i), func(t *testing.T) {\n\t\t\tactual, remain, err := parseRawString(tc.input)\n\n\t\t\tif actual != tc.expected {\n\t\t\t\tt.Errorf(\"Expected: %s, Actual: %s\", tc.expected, actual)\n\t\t\t}\n\n\t\t\tif remain != tc.remain {\n\t\t\t\tt.Errorf(\"Expected remaining: %s, Actual: %s\", tc.remain, remain)\n\t\t\t}\n\n\t\t\tif (err == nil \u0026\u0026 tc.err != nil) || (err != nil \u0026\u0026 tc.err == nil) || (err != nil \u0026\u0026 tc.err != nil \u0026\u0026 err.Error() != tc.err.Error()) {\n\t\t\t\tt.Errorf(\"Expected error: %v, Actual: %v\", tc.err, err)\n\t\t\t}\n\t\t})\n\t}\n}\n","43f05169bea4b18464c3beff0572b019":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey string\n\t\tvalue string\n\t\terr error\n\t}{\n\t\t// Basic cases\n\t\t{`\"foo\"bar`, `foo`, `bar`, nil},\n\t\t{`\"foo\" bar`, `foo`, ` bar`, nil},\n\t\t{`\"foo\"  bar`, `foo`, `  bar`, nil},\n\t\t{`\"foo\"\t\t\tbar`, `foo`, `\t\t\tbar`, nil},\n\t\t{`\"foo\"\\nbar`, `foo`, `\\nbar`, nil},\n\t\t{`\"foo\"`, `foo`, ``, nil},\n\n\t\t// Escaped quotes\n\t\t{`\"fo\\\"o\"bar`, `fo\"o`, `bar`, nil},\n\t\t{`\"fo\\\\\"o\"bar`, `fo\\\"o`, `bar`, nil},\n\t\t{`\"fo\\\\\\\"o\"bar`, `fo\\\\\"o`, `bar`, nil},\n\t\t{`\"fo\\\\\\\\\"o\"bar`, `fo\\\\\"o`, `bar`, nil},\n\t\t{`\"fo\\\\\\\\\\\"\"o\"bar`, `fo\\\\\\\\\"o`, `bar`, nil},\n\t\t{`\"\\\\\"foo\"bar`, `\"foo`, `bar`, nil},\n\n\t\t// Invalid cases\n\t\t{`\"foo`, ``, ``, fmt.Errorf(`missing closing '\"'`)},\n\t\t{`foo\"`, ``, ``, fmt.Errorf(`missing closing '\"'`)},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tkey, value, err := parseRawString(tt.input)\n\t\t\tif fmt.Sprintf(\"%v\", err) != fmt.Sprintf(\"%v\", tt.err)  {\n\t\t\t\tt.Errorf(\"Test %d - Error mismatch: expected %v, got %v\", i, tt.err, err)\n\t\t\t}\n\t\t\tif key != tt.key {\n\t\t\t\tt.Errorf(\"Test %d - Key mismatch: expected '%s', got '%s'\", i, tt.key, key)\n\t\t\t}\n\t\t\tif value != tt.value {\n\t\t\t\tt.Errorf(\"Test %d - Value mismatch: expected '%s', got '%s'\", i, tt.value, value)\n\t\t\t}\n\t\t})\n\t}\n}","446abaebeeef376ebc93226303f531ed":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ts     string\n\t\terr   error\n\t}{\n\t\t// Empty object\n\t\t{\n\t\t\tinput: `{}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Single key-value pair\n\t\t{\n\t\t\tinput: `{\"key\": \"value\"}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: \u0026Value{t: TypeString, s: \"value\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Multiple key-value pairs\n\t\t{\n\t\t\tinput: `{\"key1\": \"value1\", \"key2\": 123, \"key3\": true}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t\t{k: \"key3\", v: \u0026Value{t: TypeTrue}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Nested object\n\t\t{\n\t\t\tinput: `{\"key1\": {\"key2\": \"value2\"}}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Missing closing brace\n\t\t{\n\t\t\tinput: `{\"key\": \"value\"`,\n\t\t\twant:  nil,\n\t\t\ts:     `\"value\"`,\n\t\t\terr:   fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t\t// Invalid key\n\t\t{\n\t\t\tinput: `{key: \"value\"}`,\n\t\t\twant:  nil,\n\t\t\ts:     `key: \"value\"}`,\n\t\t\terr:   fmt.Errorf(\"cannot find opening '\\\"' for object key\"),\n\t\t},\n\t\t// Missing colon\n\t\t{\n\t\t\tinput: `{\"key\" \"value\"}`,\n\t\t\twant:  nil,\n\t\t\ts:     `\"value\"}`,\n\t\t\terr:   fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t\t// Invalid value\n\t\t{\n\t\t\tinput: `{\"key\": invalid}`,\n\t\t\twant:  nil,\n\t\t\ts:     `invalid}`,\n\t\t\terr:   fmt.Errorf(\"cannot parse object value: invalid character 'i' looking for beginning of value\"),\n\t\t},\n\t\t// Missing comma\n\t\t{\n\t\t\tinput: `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twant:  nil,\n\t\t\ts:     `\"key2\": \"value2\"}`,\n\t\t\terr:   fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i+1), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseObject(tt.input, c, 0)\n\t\t\tif (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"parseObject(%s) error = %v, wantErr %v\", tt.input, err, tt.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif s != tt.s {\n\t\t\t\tt.Errorf(\"parseObject(%s) s = %s, want %s\", tt.input, s, tt.s)\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject(%s) = %v, want %v\", tt.input, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeTrue, TypeFalse, TypeNull:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n","45e9f90038c7ac1a7282335fc1180fe8":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_getKV(t *testing.T) {\n\t// Test cases for getKV function\n\ttests := []struct {\n\t\tname string\n\t\tobj  *Object\n\t\twant *kv\n\t}{\n\t\t{\n\t\t\tname: \"EmptyObject\",\n\t\t\tobj:  \u0026Object{},\n\t\t\twant: \u0026kv{},\n\t\t},\n\t\t{\n\t\t\tname: \"NonEmptyObject\",\n\t\t\tobj: \u0026Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: \u0026kv{},\n\t\t},\n\t}\n\n\t// Run the test cases\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.obj.getKV()\n\t\t\tif got.k != tt.want.k || got.v != tt.want.v {\n\t\t\t\tt.Errorf(\"Object.getKV() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","46016ef0a20258ffb65f7446c875b298":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tinput   string\n\t\twant    *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: \"{}\",\n\t\t\twant: \u0026Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: true,\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"empty array\",\n\t\t\tinput: \"[]\",\n\t\t\twant: \u0026Value{\n\t\t\t\ta: nil,\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"simple string\",\n\t\t\tinput: `\"hello\"`,\n\t\t\twant: \u0026Value{\n\t\t\t\ts: \"hello\",\n\t\t\t\tt: TypeString,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"simple number\",\n\t\t\tinput: \"123\",\n\t\t\twant: \u0026Value{\n\t\t\t\ts: \"123\",\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"simple true\",\n\t\t\tinput: \"true\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"simple false\",\n\t\t\tinput: \"false\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"simple null\",\n\t\t\tinput: \"null\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"complex object\",\n\t\t\tinput: `{\"key1\": \"value1\", \"key2\": 123, \"key3\": [1,2,3], \"key4\": {\"subkey1\": \"subvalue1\"}}`,\n\t\t\twant: \u0026Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{s: \"123\", t: TypeNumber}},\n\t\t\t\t\t\t{k: \"key3\", v: \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"2\", t: TypeNumber}, {s: \"3\", t: TypeNumber}}, t: TypeArray}},\n\t\t\t\t\t\t{k: \"key4\", v: \u0026Value{o: Object{kvs: []kv{{k: \"subkey1\", v: \u0026Value{s: \"subvalue1\", t: TypeString}}}, keysUnescaped: true}, t: TypeObject}},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: true,\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid json\",\n\t\t\tinput:   `{key1\": \"value1\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tp := \u0026Parser{}\n\t\t\tgot, err := p.Parse(tt.input)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Parse() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != nil \u0026\u0026 tt.want != nil \u0026\u0026 got.Type() != tt.want.Type() {\n\t\t\t\tt.Errorf(\"Parse() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","474587a46759d9c9af305ffe6abc10cf":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_unescapeKeys(t *testing.T) {\n\t// TODO: Implement test cases.\n}","4778417afe75368a35b2b6f4f35fc985":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantValue *Value\n\t\twantTail string\n\t\twantErr   error\n\t}{\n\t\t{\n\t\t\tname:     \"empty array\",\n\t\t\tinput:    \"[]\",\n\t\t\twantValue: \u0026Value{t: TypeArray, a: []*Value{}},\n\t\t\twantTail: \"\",\n\t\t\twantErr:   nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"simple array\",\n\t\t\tinput:    \"[1,2,3]\",\n\t\t\twantValue: \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}},\n\t\t\twantTail: \"\",\n\t\t\twantErr:   nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"nested array\",\n\t\t\tinput:    \"[[1,2],[3,4]]\",\n\t\t\twantValue: \u0026Value{t: TypeArray, a: []*Value{{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}}}, {t: TypeArray, a: []*Value{{t: TypeNumber, s: \"3\"}, {t: TypeNumber, s: \"4\"}}}}},\n\t\t\twantTail: \"\",\n\t\t\twantErr:   nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with different types\",\n\t\t\tinput:    \"[1,\\\"hello\\\",true]\",\n\t\t\twantValue: \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeString, s: \"hello\"}, {t: TypeTrue}}},\n\t\t\twantTail: \"\",\n\t\t\twantErr:   nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid array: missing closing bracket\",\n\t\t\tinput:    \"[1,2,3\",\n\t\t\twantValue: nil,\n\t\t\twantTail: \"\",\n\t\t\twantErr:   fmt.Errorf(\"unexpected end of array\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid array: missing comma\",\n\t\t\tinput:    \"[1 2 3]\",\n\t\t\twantValue: nil,\n\t\t\twantTail: \"\",\n\t\t\twantErr:   fmt.Errorf(\"missing ',' after array value\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgotValue, gotTail, gotErr := parseArray(tt.input, c, 0)\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseArray() gotTail = %v, want %v\", gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif (gotErr != nil \u0026\u0026 tt.wantErr == nil) || (gotErr == nil \u0026\u0026 tt.wantErr != nil) || (gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error()) {\n\t\t\t\tt.Errorf(\"parseArray() gotErr = %v, want %v\", gotErr, tt.wantErr)\n\t\t\t}\n\t\t\tif !equalValues(gotValue, tt.wantValue) {\n\t\t\t\tt.Errorf(\"parseArray() gotValue = %v, want %v\", gotValue, tt.wantValue)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(a, b *Value) bool {\n\tif a == nil \u0026\u0026 b == nil {\n\t\treturn true\n\t}\n\tif a == nil || b == nil {\n\t\treturn false\n\t}\n\tif a.t != b.t {\n\t\treturn false\n\t}\n\tswitch a.t {\n\tcase TypeArray:\n\t\tif len(a.a) != len(b.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range a.a {\n\t\t\tif !equalValues(a.a[i], b.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeString, TypeNumber:\n\t\treturn a.s == b.s\n\tcase TypeTrue, TypeFalse, TypeNull:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}","47a7a73c5d932bf8413c1aa7692b5419":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Empty string.\n\t\t{\"\", nil, \"\", fmt.Errorf(\"cannot parse empty string\")},\n\n\t\t// Invalid JSON.\n\t\t{\"{\", nil, \"{\", fmt.Errorf(\"cannot parse object: missing '}'\")},\n\t\t{\"[\", nil, \"[\", fmt.Errorf(\"cannot parse array: missing ']'\")},\n\t\t{\"\\\"unclosed string\", nil, \"\", fmt.Errorf(\"cannot parse string: missing '\\\"'\")},\n\t\t{\"invaild token\", nil, \"invaild token\", fmt.Errorf(\"unexpected value found: %q\", \"invaild token\")},\n\n\t\t// Valid JSON values.\n\t\t{\"null\", valueNull, \"\", nil},\n\t\t{\"true\", valueTrue, \"\", nil},\n\t\t{\"false\", valueFalse, \"\", nil},\n\t\t{\"123\", \u0026Value{t: TypeNumber, s: \"123\"}, \"\", nil},\n\t\t{\"-123.456e7\", \u0026Value{t: TypeNumber, s: \"-123.456e7\"}, \"\", nil},\n\t\t{\"\\\"hello\\\"\", \u0026Value{t: typeRawString, s: \"hello\"}, \"\", nil},\n\n\t\t// Whitespace handling.\n\t\t{\n\t\t\t\" \\n\\t\\rnull\",\n\t\t\tvalueNull,\n\t\t\t\"\",\n\t\t\tnil,\n\t\t},\n\t\t{\n\t\t\t\"null \\n\\t\\r\",\n\t\t\tvalueNull,\n\t\t\t\" \\n\\t\\r\",\n\t\t\tnil,\n\t\t},\n\t\t{\n\t\t\t\" \\n\\t\\r\\\"hello\\\"\",\n\t\t\t\u0026Value{t: typeRawString, s: \"hello\"},\n\t\t\t\"\",\n\t\t\tnil,\n\t\t},\n\t\t{\n\t\t\t\"\\\"hello\\\" \\n\\t\\r\",\n\t\t\t\u0026Value{t: typeRawString, s: \"hello\"},\n\t\t\t\" \\n\\t\\r\",\n\t\t\tnil,\n\t\t},\n\n\t\t// NaN handling.\n\t\t{\"NaN\", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"\", nil},\n\t\t{\"nan\", \u0026Value{t: TypeNumber, s: \"nan\"}, \"\", nil},\n\t\t{\"NAN\", \u0026Value{t: TypeNumber, s: \"NAN\"}, \"\", nil},\n\t}\n\n\tc := \u0026cache{}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tgot, tail, err := parseValue(tt.input, c, 0)\n\n\t\t\tif got == nil \u0026\u0026 tt.want == nil {\n\t\t\t\t// Both are nil, nothing to compare.\n\t\t\t} else if got == nil || tt.want == nil {\n\t\t\t\tt.Errorf(\"Test case %d failed: got nil while expecting non-nil or vice versa\", i)\n\t\t\t} else if got.t != tt.want.t || got.s != tt.want.s {\n\t\t\t\tt.Errorf(\"Test case %d failed: value mismatch, got: %v, want: %v\", i, got, tt.want)\n\t\t\t}\n\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"Test case %d failed: tail mismatch, got: %q, want: %q\", i, tail, tt.tail)\n\t\t\t}\n\n\t\t\tif err == nil \u0026\u0026 tt.err != nil {\n\t\t\t\tt.Errorf(\"Test case %d failed: expected error but got nil\", i)\n\t\t\t} else if err != nil \u0026\u0026 tt.err == nil {\n\t\t\t\tt.Errorf(\"Test case %d failed: unexpected error: %v\", i, err)\n\t\t\t} else if err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error() {\n\t\t\t\tt.Errorf(\"Test case %d failed: error mismatch, got: %v, want: %v\", i, err, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}","47b28de27696c7d835e66559172d7cdc":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"raw string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"raw string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"12345\",\n\t\t\t},\n\t\t\twant: []byte(\"12345\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"string\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"12345\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"[\\\"string\\\",12345]\"),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"string\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"string\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"number\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"12345\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"{\\\"string\\\":\\\"string\\\",\\\"number\\\":12345}\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif string(got) != string(tt.want) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %v, want %v\", string(got), string(tt.want))\n\t\t\t}\n\t\t})\n\t}\n}\n","482458ac461af40cdb53b92e922369b7":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput  string\n\t\texpect string\n\t\ttail   string\n\t\terr    error\n\t}{\n\t\t// Basic cases\n\t\t{`\"hello\"world`, \"hello\", \"world\", nil},\n\t\t{`\"hello\"`, \"hello\", \"\", nil},\n\t\t{`\"\"`, \"\", \"\", nil},\n\n\t\t// Escaped quotes\n\t\t{`\"hello \\\\\"world\\\\\"\"`, `hello \"world\"`, \"\", nil},\n\t\t{`\"hello\\\\\"\"`, \"hello\\\"\", \"\", nil},\n\t\t{`\"\\\\\"hello\\\\\"\"`, `\"hello\"`, \"\", nil},\n\n\t\t// Invalid JSON\n\t\t{`\"hello`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`hello\"`, \"hello\\\"\", \"\", nil},\n\t\t{`\"hello\"world\"`, \"hello\", `world\"`, nil},\n\n\t\t// Special characters\n\t\t{`\"\\n\\t\\r\\\\\\\"\"`, \"\\n\\t\\r\\\\\\\"\", \"\", nil},\n\t\t{`\"\\\\\\n\\\\\\t\\\\\\r\\\\\\\\\\\\\\\"\"`, \"\\\\\\n\\\\\\t\\\\\\r\\\\\\\\\\\"\", \"\", nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tresult, tail, err := parseRawString(tt.input)\n\t\t\tif result != tt.expect || tail != tt.tail || (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"Input: %s, Expect: (%s, %s, %v), got: (%s, %s, %v)\", tt.input, tt.expect, tt.tail, tt.err, result, tail, err)\n\t\t\t}\n\t\t})\n\t}\n}\n","48320e961bd2d8c9a3735fa076ff65ef":"package fastjson\n\nimport \"testing\"\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tt    Type\n\t\twant string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\tfor i, tt := range tests {\n\t\tif got := tt.t.String(); got != tt.want {\n\t\t\tt.Errorf(\"test[%d]: String() = %v, want %v\", i, got, tt.want)\n\t\t}\n\t}\n}\n","48615e4e0f80b59be18ffb71c44492a6":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Empty string\n\t\t{\"\", nil, \"\", fmt.Errorf(\"cannot parse empty string\")},\n\t\t// Invalid JSON\n\t\t{\"{\", nil, \"{\", fmt.Errorf(\"cannot parse object: missing '}'\")},\n\t\t// Object\n\t\t{`{\"foo\":\"bar\"}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: typeRawString, s: \"bar\"}}}}}, \"}\", nil},\n\t\t// Array\n\t\t{`[1,2,3]`, \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}}, \"]\", nil},\n\t\t// String\n\t\t{`\"hello\"`, \u0026Value{t: typeRawString, s: \"hello\"}, \"\", nil},\n\t\t// True\n\t\t{\"true\", valueTrue, \"\", nil},\n\t\t// False\n\t\t{\"false\", valueFalse, \"\", nil},\n\t\t// Null\n\t\t{\"null\", valueNull, \"\", nil},\n\t\t// Number\n\t\t{\"123\", \u0026Value{t: TypeNumber, s: \"123\"}, \"\", nil},\n\t\t// NaN\n\t\t{\"NaN\", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"\", nil},\n\t\t// Number with exponent\n\t\t{\"1.23e4\", \u0026Value{t: TypeNumber, s: \"1.23e4\"}, \"\", nil},\n\t\t// Number with whitespace\n\t\t{\" 123 \", \u0026Value{t: TypeNumber, s: \"123\"}, \" \", nil},\n\t\t// String with escaped characters\n\t\t{`\"hello\\nworld\\\"\\\\\\\"\"`, \u0026Value{t: typeRawString, s: \"hello\\nworld\\\"\\\\\\\"\"}, \"\", nil},\n\t\t// String with invalid escape character\n\t\t{`\"hello\\xworld\"`, nil, `\"hello\\xworld\"`, fmt.Errorf(\"cannot parse string: invalid escape char 'x'\")},\n\t}\n\n\tc := \u0026cache{}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tgot, tail, err := parseValue(tt.input, c, 0)\n\t\t\tif err != nil \u0026\u0026 tt.err == nil {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err == nil \u0026\u0026 tt.err != nil {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error() {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got == nil \u0026\u0026 tt.want != nil {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got != nil \u0026\u0026 tt.want == nil {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got != nil \u0026\u0026 tt.want != nil {\n\t\t\t\tif got.t != tt.want.t {\n\t\t\t\t\tt.Errorf(\"parseValue() got type = %v, want %v\", got.t, tt.want.t)\n\t\t\t\t}\n\t\t\t\tif got.s != tt.want.s {\n\t\t\t\t\tt.Errorf(\"parseValue() got string = %v, want %v\", got.s, tt.want.s)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"parseValue() got tail = %v, want %v\", tail, tt.tail)\n\t\t\t}\n\t\t})\n\t}\n}","487b4d87b952e68219b21d44a1371cea":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twant     *Value\n\t\twantRest string\n\t\twantErr  string\n\t}{\n\t\t// Empty array\n\t\t{\n\t\t\tinput:    \"[]\",\n\t\t\twant:     \u0026Value{t: TypeArray},\n\t\t\twantRest: \"\",\n\t\t},\n\t\t// Simple array\n\t\t{\n\t\t\tinput:    \"[1,2,3]\",\n\t\t\twant:     \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}},\n\t\t\twantRest: \"\",\n\t\t},\n\t\t// Array with different types\n\t\t{\n\t\t\tinput:    \"[1,\\\"hello\\\",true]\",\n\t\t\twant:     \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeString, s: \"hello\"}, {t: TypeTrue}}},\n\t\t\twantRest: \"\",\n\t\t},\n\t\t// Array with whitespace\n\t\t{\n\t\t\tinput:    \" [ 1 , 2 , 3 ] \",\n\t\t\twant:     \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}},\n\t\t\twantRest: \" \",\n\t\t},\n\t\t// Nested array\n\t\t{\n\t\t\tinput:    \"[1,[2,3],4]\",\n\t\t\twant: \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}},\n\t\t\t\t{t: TypeNumber, s: \"4\"},\n\t\t\t}},\n\t\t\twantRest: \"\",\n\t\t},\n\t\t// Missing closing bracket\n\t\t{\n\t\t\tinput:    \"[1,2,3\",\n\t\t\twantErr: \"unexpected end of array\",\n\t\t},\n\t\t// Missing comma\n\t\t{\n\t\t\tinput:    \"[1 2 3]\",\n\t\t\twantErr: \"missing ',' after array value\",\n\t\t},\n\t\t// Invalid value\n\t\t{\n\t\t\tinput:    \"[1,2,invalid]\",\n\t\t\twantErr: \"cannot parse array value: invalid character 'i' looking for beginning of value\",\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test #%d\", i+1), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, rest, err := parseArray(tt.input, c, 0)\n\n\t\t\tif tt.wantErr != \"\" {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"expected error %q but got nil\", tt.wantErr)\n\t\t\t\t} else if err.Error() != tt.wantErr {\n\t\t\t\t\tt.Errorf(\"expected error %q but got %q\", tt.wantErr, err.Error())\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t}\n\n\t\t\tif rest != tt.wantRest {\n\t\t\t\tt.Errorf(\"expected rest %q but got %q\", tt.wantRest, rest)\n\t\t\t}\n\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"test %d failed: expected\\n%#v\\ngot\\n%#v\", i+1, tt.want, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(a, b *Value) bool {\n\tif a == nil \u0026\u0026 b == nil {\n\t\treturn true\n\t}\n\tif a == nil || b == nil {\n\t\treturn false\n\t}\n\tif a.t != b.t {\n\t\treturn false\n\t}\n\tif a.t == TypeArray {\n\t\tif len(a.a) != len(b.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, v := range a.a {\n\t\t\tif !equalValues(v, b.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\treturn a.s == b.s\n}","48c9e62e37da97e070e59a6c5e30e526":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantObj  string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t{\n\t\t\tname:     \"EmptyObject\",\n\t\t\tinput:    \"{}\",\n\t\t\twantObj:  \"{}\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"SimpleObject\",\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\twantObj:  `{\"key\": \"value\"}`,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"ComplexObject\",\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 123, \"key3\": true, \"key4\": null}`,\n\t\t\twantObj:  `{\"key1\": \"value1\", \"key2\": 123, \"key3\": true, \"key4\": null}`,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"NestedObject\",\n\t\t\tinput:    `{\"key1\": {\"key2\": \"value2\"}, \"key3\": \"value3\"}`,\n\t\t\twantObj:  `{\"key1\": {\"key2\": \"value2\"}, \"key3\": \"value3\"}`,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"MissingColon\",\n\t\t\tinput:    `{\"key\" \"value\"}`,\n\t\t\twantObj:  \"\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"MissingQuote\",\n\t\t\tinput:    `{key\": \"value\"}`,\n\t\t\twantObj:  \"\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  fmt.Errorf(\"cannot parse object key: missing '\\\"' after object key\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"MissingComma\",\n\t\t\tinput:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantObj:  \"\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"TrailingComma\",\n\t\t\tinput:    `{\"key\": \"value\",}`,\n\t\t\twantObj:  \"\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgotObj, gotTail, gotErr := parseObject(tt.input, c, 0)\n\n\t\t\t// Compare error\n\t\t\tif gotErr == nil \u0026\u0026 tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"parseObject() error = nil, wantErr %v\", tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotErr != nil \u0026\u0026 tt.wantErr == nil {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr nil\", gotErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", gotErr, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Compare object\n\t\t\tif gotObj != nil {\n\t\t\t\tgotObjStr := gotObj.String()\n\t\t\t\tif gotObjStr != tt.wantObj {\n\t\t\t\t\tt.Errorf(\"parseObject() gotObj = %s, wantObj %s\", gotObjStr, tt.wantObj)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Compare tail\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseObject() gotTail = %s, wantTail %s\", gotTail, tt.wantTail)\n\t\t\t}\n\t\t})\n\t}\n}\n","48d318ea87ed8fe26689b887bc8fd3c8":"package fastjson\n\nimport \"testing\"\n\nfunc Test_skipWSSlow(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no leading whitespace\",\n\t\t\targs: args{s: \"abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading space\",\n\t\t\targs: args{s: \" abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading tab\",\n\t\t\targs: args{s: \"\\tabc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading newline\",\n\t\t\targs: args{s: \"\\nabc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading carriage return\",\n\t\t\targs: args{s: \"\\rabc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple leading whitespace\",\n\t\t\targs: args{s: \" \\t\\r\\nabc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"all whitespace\",\n\t\t\targs: args{s: \" \\t\\r\\n\"},\n\t\t\twant: \"\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","49c1fd950447c90d34f273d87ba7c002":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tin   string\n\t\twant *Value\n\t\ts    string\n\t\terr  error\n\t}{\n\t\t// Basic object tests.\n\t\t{\n\t\t\tin:   `{}`,\n\t\t\twant: \u0026Value{t: TypeObject, o: Object{}},\n\t\t\ts:    ``,\n\t\t\terr:  nil,\n\t\t},\n\t\t{\n\t\t\tin:   `{\"foo\": \"bar\"}`,\n\t\t\twant: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: TypeString, s: \"bar\"}}}}},\n\t\t\ts:    ``,\n\t\t\terr:  nil,\n\t\t},\n\t\t{\n\t\t\tin:   `{\"foo\": \"bar\", \"baz\": 123}`,\n\t\t\twant: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: TypeString, s: \"bar\"}}, {k: \"baz\", v: \u0026Value{t: TypeNumber, s: \"123\"}}}}},\n\t\t\ts:    ``,\n\t\t\terr:  nil,\n\t\t},\n\n\t\t// Handling of whitespace.\n\t\t{\n\t\t\tin:   ` { \"foo\" : \"bar\" } `,\n\t\t\twant: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: TypeString, s: \"bar\"}}}}},\n\t\t\ts:    ` `,\n\t\t\terr:  nil,\n\t\t},\n\n\t\t// Error cases.\n\t\t{\n\t\t\tin:   ``,\n\t\t\twant: nil,\n\t\t\ts:    ``,\n\t\t\terr:  fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t\t{\n\t\t\tin:   `{`,\n\t\t\twant: nil,\n\t\t\ts:    `{`,\n\t\t\terr:  fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t\t{\n\t\t\tin:   `{}}`,\n\t\t\twant: nil,\n\t\t\ts:    `}`,\n\t\t\terr:  fmt.Errorf(\"unexpected end of object\"),\n\t\t},\n\t\t{\n\t\t\tin:   `{\"foo\"`,\n\t\t\twant: nil,\n\t\t\ts:    `{\"foo\"`,\n\t\t\terr:  fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t\t{\n\t\t\tin:   `{\"foo\":`,\n\t\t\twant: nil,\n\t\t\ts:    `{\"foo\":`,\n\t\t\terr:  fmt.Errorf(\"cannot parse object value: missing '}'\"),\n\t\t},\n\t\t{\n\t\t\tin:   `{\"foo\": \"bar\"`,\n\t\t\twant: nil,\n\t\t\ts:    `{\"foo\": \"bar\"`,\n\t\t\terr:  fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t\t{\n\t\t\tin:   `{\"foo\": \"bar\",`,\n\t\t\twant: nil,\n\t\t\ts:    `{\"foo\": \"bar\",`,\n\t\t\terr:  fmt.Errorf(\"cannot parse object value: missing '}'\"),\n\t\t},\n\t\t{\n\t\t\tin:   `{foo: \"bar\"}`,\n\t\t\twant: nil,\n\t\t\ts:    `{foo: \"bar\"}`,\n\t\t\terr:  fmt.Errorf(`cannot find opening '\"\" for object key`),\n\t\t},\n\t\t{\n\t\t\tin:   `{\"foo\" \"bar\"}`,\n\t\t\twant: nil,\n\t\t\ts:    ` \"bar\"}`,\n\t\t\terr:  fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test #%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseObject(tt.in, c, 0)\n\n\t\t\tif got != nil \u0026\u0026 tt.want != nil \u0026\u0026 got.t == tt.want.t {\n\t\t\t\t// For easier comparison of objects.\n\t\t\t\tif !compareObjects(got, tt.want) {\n\t\t\t\t\tt.Errorf(\"test %d failed. Expected:\\n\\t%v\\ngot:\\n\\t%v\", i, tt.want, got)\n\t\t\t\t}\n\t\t\t} else if got != tt.want {\n\t\t\t\tt.Errorf(\"test %d failed. Expected:\\n\\t%v\\ngot:\\n\\t%v\", i, tt.want, got)\n\t\t\t}\n\n\t\t\tif s != tt.s {\n\t\t\t\tt.Errorf(\"test %d failed. Expected remaining string:\\n\\t'%s'\\ngot:\\n\\t'%s'\", i, tt.s, s)\n\t\t\t}\n\n\t\t\tif err == nil \u0026\u0026 tt.err != nil {\n\t\t\t\tt.Errorf(\"test %d failed. Expected error:\\n\\t%v\\ngot nil\", i, tt.err)\n\t\t\t} else if err != nil \u0026\u0026 tt.err == nil {\n\t\t\t\tt.Errorf(\"test %d failed. Expected nil error, got:\\n\\t%v\", i, err)\n\t\t\t} else if err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error() {\n\t\t\t\tt.Errorf(\"test %d failed. Expected error:\\n\\t%v\\ngot:\\n\\t%v\", i, tt.err, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareObjects(a, b *Value) bool {\n\tif len(a.o.kvs) != len(b.o.kvs) {\n\t\treturn false\n\t}\n\n\tfor i := range a.o.kvs {\n\t\tif a.o.kvs[i].k != b.o.kvs[i].k {\n\t\t\treturn false\n\t\t}\n\n\t\tif a.o.kvs[i].v.t != b.o.kvs[i].v.t {\n\t\t\treturn false\n\t\t}\n\n\t\tswitch a.o.kvs[i].v.t {\n\t\tcase TypeString:\n\t\t\tif a.o.kvs[i].v.s != b.o.kvs[i].v.s {\n\t\t\t\treturn false\n\t\t\t}\n\t\tcase TypeNumber:\n\t\t\tif a.o.kvs[i].v.s != b.o.kvs[i].v.s {\n\t\t\t\treturn false\n\t\t\t}\n\t\tdefault:\n\t\t\t// Add more type comparisons as needed.\n\t\t}\n\t}\n\n\treturn true\n}\n","4b129ab98d5c4c731411a79d4a5f508e":"package fastjson\n\nimport \"testing\"\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    string\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\ts:    \"\",\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with leading whitespace\",\n\t\t\ts:    \"  foo\",\n\t\t\twant: \"foo\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with no leading whitespace\",\n\t\t\ts:    \"bar\",\n\t\t\twant: \"bar\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with only whitespace\",\n\t\t\ts:    \" \\t\\n\\r\",\n\t\t\twant: \"\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %q, want %q\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","4b87cd4d52570dab9666b264f36b07db":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tinput Type\n\t\twant  string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\tfor i, tt := range tests {\n\t\tgot := tt.input.String()\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"test[%d]: String() = %q, want %q\", i, got, tt.want)\n\t\t}\n\t}\n}","4bfd353ce394104c3e5e7330f2d8c37e":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantStr  string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Basic cases\n\t\t{`\"foo\"bar`, `foo`, `bar`, nil},\n\t\t{`\"fo\\\"o\"bar`, `fo\\\"o`, `bar`, nil},\n\t\t{`\"foo\"`, `foo`, ``, nil},\n\t\t{`\"\"bar`, ``, `bar`, nil},\n\n\t\t// Escaped quotes\n\t\t{`\"\\\\\"bar`, `\\\\`, `bar`, nil},\n\t\t{`\"\\\\\\\"\"bar`, `\\\\\"`, `bar`, nil},\n\t\t{`\"\\\\\\\"bar\"baz`, `\\\\\\\"bar`, `baz`, nil},\n\n\t\t// Errors\n\t\t{`\"foo`, ``, ``, fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo\"bar\"`, ``, ``, fmt.Errorf(`missing closing '\"'`)},\n\t\t{`foo\"bar`, ``, ``, fmt.Errorf(`missing closing '\"'`)},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tgotStr, gotTail, gotErr := parseRawString(tt.input)\n\t\t\tif gotStr != tt.wantStr || gotTail != tt.wantTail || !errorEqual(gotErr, tt.wantErr) {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = (%q, %q, %v), want (%q, %q, %v)\", tt.input, gotStr, gotTail, gotErr, tt.wantStr, tt.wantTail, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc errorEqual(e1, e2 error) bool {\n\tif e1 == nil \u0026\u0026 e2 == nil {\n\t\treturn true\n\t}\n\tif e1 == nil || e2 == nil {\n\t\treturn false\n\t}\n\treturn e1.Error() == e2.Error()\n}","4cdd623a302712e4419ad2c3a2c97876":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey   string\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Unescaped strings.\n\t\t{`\"foo\"bar`, `foo`, `bar`, nil},\n\t\t{`\"foo\" bar`, `foo`, ` bar`, nil},\n\t\t{`\"foo\"   bar`, `foo`, `   bar`, nil},\n\n\t\t// Escaped strings.\n\t\t{`\"fo\\\"o\"bar`, `fo\"o`, `bar`, nil},\n\t\t{`\"fo\\\\o\"bar`, `fo\\o`, `bar`, nil},\n\t\t{`\"fo\\to\"bar`, `fo\to`, `bar`, nil},\n\t\t{`\"fo\\ro\"bar`, `fo\no`, `bar`, nil},\n\t\t{`\"fo\\no\"bar`, `fo\no`, `bar`, nil},\n\n\t\t// Missing closing quote.\n\t\t{`\"foo`, ``, ``, fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"fo\\\"o`, ``, ``, fmt.Errorf(`missing closing '\"'`)},\n\n\t\t// Empty strings.\n\t\t{`\"\"bar`, ``, `bar`, nil},\n\t\t{`\"\" bar`, ``, ` bar`, nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i+1), func(t *testing.T) {\n\t\t\tkey, tail, err := parseRawString(tt.input)\n\t\t\tif key != tt.key || tail != tt.tail || !equalError(err, tt.err) {\n\t\t\t\tt.Errorf(\"input: %q, want (%q, %q, %v), got (%q, %q, %v)\", tt.input, tt.key, tt.tail, tt.err, key, tail, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// equalError reports whether errors a and b are considered equal.\n// They're equal if both are nil, or both are not nil and a.Error() == b.Error().\nfunc equalError(a, b error) bool {\n\treturn a == nil \u0026\u0026 b == nil || a != nil \u0026\u0026 b != nil \u0026\u0026 a.Error() == b.Error()\n}\n","4d0122a553f10d32bc49513bf0d9a989":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic escapes\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\t`, \"\\t\"},\n\t\t{`\\\\`, \"\\\\\"},\n\t\t{`\\\"`, \"\\\"\"},\n\t\t{`\\/`, \"/\"},\n\n\t\t// Unicode escapes\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A0`, \"\\u00A0\"},\n\t\t{`\\u20AC`, \"\\u20AC\"},\n\n\t\t// Surrogate pairs\n\t\t{`\\uD83D\\uDE02`, \"\\U0001F602\"}, // üòÇ\n\n\t\t// Invalid escapes (should be left as-is)\n\t\t{`\\`, `\\`},\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u`, `\\u`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\uD800`, `\\uD800`},\n\t\t{`\\uD83D`, `\\uD83D`},\n\t\t{`\\uD83D\\u1234`, `\\uD83D\\u1234`},\n\n\t\t// Mixed\n\t\t{`Hello\\tworld\\n`, \"Hello\\tworld\\n\"},\n\t\t{`\"This is a \\\\\"test\\\\\" string.\"`, \"\\\"This is a \\\\\\\"test\\\\\\\" string.\\\"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.input, func(t *testing.T) {\n\t\t\tactual := unescapeStringBestEffort(test.input)\n\t\t\tif actual != test.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", test.input, actual, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}","4f4491cb7c5cc7f58615a05c592dd536":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Empty string\n\t\t{\"\", nil, \"\", fmt.Errorf(\"cannot parse empty string\")},\n\n\t\t// Object\n\t\t{`{\"foo\": \"bar\"}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: typeRawString, s: \"bar\"}}}}}}, \"\", nil},\n\n\t\t// Array\n\t\t{`[1, \"two\", true]`, \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: typeRawString, s: \"two\"}, {t: TypeTrue}}}, \"\", nil},\n\n\t\t// String\n\t\t{`\"hello\"`, \u0026Value{t: typeRawString, s: \"hello\"}, \"\", nil},\n\n\t\t// True\n\t\t{\"true\", valueTrue, \"\", nil},\n\n\t\t// False\n\t\t{\"false\", valueFalse, \"\", nil},\n\n\t\t// Null\n\t\t{\"null\", valueNull, \"\", nil},\n\n\t\t// Number\n\t\t{\"123\", \u0026Value{t: TypeNumber, s: \"123\"}, \"\", nil},\n\t\t{\"-123.456\", \u0026Value{t: TypeNumber, s: \"-123.456\"}, \"\", nil},\n\n\t\t// NaN\n\t\t{\"NaN\", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"\", nil},\n\n\t\t// Invalid value\n\t\t{\"invalid\", nil, \"invalid\", fmt.Errorf(\"unexpected value found: \\\"invalid\\\"\")},\n\n\t\t// Too deep nesting\n\t\t{`{\"a\": {\"b\": {\"c\": {\"d\": {\"e\": {\"f\": {\"g\": {\"h\": {\"i\": {\"j\": {\"k\": {\"l\": {\"m\": {\"n\": {\"o\": {\"p\": {\"q\": {\"r\": {\"s\": {\"t\": {\"u\": {\"v\": {\"w\": {\"x\": {\"y\": {\"z\": {}}}}}}}}}}}}}}}}}}}}}}}}}}}}`, nil, \"\", fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth)},\n\t}\n\n\tc := \u0026cache{}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i+1), func(t *testing.T) {\n\t\t\tgot, tail, err := parseValue(tt.input, c, 0)\n\t\t\tif !equalError(err, tt.err) {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, want %v\", tt.input, err, tt.err)\n\t\t\t}\n\t\t\tif !equalValue(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", tt.input, got, tt.want)\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"parseValue(%q) tail = %q, want %q\", tt.input, tail, tt.tail)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// equalError compares two errors.\nfunc equalError(err1, err2 error) bool {\n\tif err1 == nil \u0026\u0026 err2 == nil {\n\t\treturn true\n\t}\n\tif err1 == nil || err2 == nil {\n\t\treturn false\n\t}\n\treturn err1.Error() == err2.Error()\n}\n\n// equalValue compares two *Value.\nfunc equalValue(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn equalObject(\u0026v1.o, \u0026v2.o)\n\tcase TypeArray:\n\t\treturn equalArray(v1.a, v2.a)\n\tcase typeRawString, TypeNumber:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\treturn true\n\t}\n}\n\n// equalObject compares two *Object.\nfunc equalObject(o1, o2 *Object) bool {\n\tif o1 == nil \u0026\u0026 o2 == nil {\n\t\treturn true\n\t}\n\tif o1 == nil || o2 == nil {\n\t\treturn false\n\t}\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i := range o1.kvs {\n\t\tif o1.kvs[i].k != o2.kvs[i].k {\n\t\t\treturn false\n\t\t}\n\t\tif !equalValue(o1.kvs[i].v, o2.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n// equalArray compares two []*Value.\nfunc equalArray(a1, a2 []*Value) bool {\n\tif a1 == nil \u0026\u0026 a2 == nil {\n\t\treturn true\n\t}\n\tif a1 == nil || a2 == nil {\n\t\treturn false\n\t}\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i := range a1 {\n\t\tif !equalValue(a1[i], a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","4fc89e3a630b8e550765596372d584cd":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\ts string\n\t\tw string\n\t}{\n\t\t// Basic tests.\n\t\t{\"\", \"\"},\n\t\t{\"foo\", \"foo\"},\n\t\t{\"\\\"foo\\\"\", \"\\\"foo\\\"\"},\n\t\t{\"\\\\foo\", \"\\\\foo\"},\n\t\t{\"\\n\", \"\\n\"},\n\t\t{\"\\r\", \"\\r\"},\n\t\t{\"\\t\", \"\\t\"},\n\t\t{\"\\\\\\\"\", \"\\\"\"},\n\t\t{\"\\\\\\\\\", \"\\\\\"},\n\n\t\t// Unicode tests.\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A0`, \"¬†\"},\n\t\t{`\\uFFFF`, \"Ôøø\"},\n\t\t{\"\\u0800\", \"‡†Ä\"},\n\t\t{\"\\uD83D\\uDE04\", \"üòÑ\"},\n\t\t{`\\uD83D\\uDE04\\uD83D\\uDE04`, \"üòÑüòÑ\"},\n\n\t\t// Broken unicode tests.\n\t\t{`\\u`, `\\u`},\n\t\t{`\\uZ`, `\\uZ`},\n\t\t{`\\u002`, `\\u002`},\n\t\t{`\\u002`, `\\u002`},\n\t\t{`\\u0020Z`, `\\u0020Z`},\n\t\t{`\\uD83D`, `\\uD83D`},\n\t\t{`\\uD83D\\u`, `\\uD83D\\u`},\n\t\t{`\\uD83D\\uD`, `\\uD83D\\uD`},\n\t\t{`\\uD83D\\uD83D`, `\\uD83D\\uD83D`},\n\t\t{`\\uD83D\\uDZZZ`, `\\uD83D\\uDZZZ`},\n\t\t{`\\uD83D\\uDE04\\uD83`, `\\uD83D\\uDE04\\uD83`},\n\t}\n\n\tfor i, test := range tests {\n\t\ts := unescapeStringBestEffort(test.s)\n\t\tif s != test.w {\n\t\t\tt.Errorf(\"#%d: unescapeStringBestEffort(%q) = %q; want %q\", i, test.s, s, test.w)\n\t\t}\n\t}\n}","503f3922e45e669920f6725150e5602b":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\ts       string\n\t\twantV   *Value\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tp := \u0026Parser{}\n\t\t\tgotV, err := p.Parse(tt.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Parser.Parse() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotV != tt.wantV {\n\t\t\t\tt.Errorf(\"Parser.Parse() = %v, want %v\", gotV, tt.wantV)\n\t\t\t}\n\t\t})\n\t}\n}","507ed88071a072bb161e39e02811a740":"package fastjson\n\nimport \"testing\"\n\nfunc Test_skipWSSlow(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no leading whitespace\",\n\t\t\targs: args{s: \"abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading space\",\n\t\t\targs: args{s: \" abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading tab\",\n\t\t\targs: args{s: \"\\tabc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading newline\",\n\t\t\targs: args{s: \"\\nabc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading carriage return\",\n\t\t\targs: args{s: \"\\rabc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple leading whitespace\",\n\t\t\targs: args{s: \" \\t\\r\\nabc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"all whitespace\",\n\t\t\targs: args{s: \" \\t\\r\\n\"},\n\t\t\twant: \"\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","51623eafceb80d06c6bf0fcefe4a047b":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twant     *Value\n\t\twantRest string\n\t\twantErr  error\n\t}{\n\t\t{\n\t\t\tname:     \"empty array\",\n\t\t\tinput:    \"[]\",\n\t\t\twant:     \u0026Value{t: TypeArray, a: []*Value{}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"simple array\",\n\t\t\tinput:    \"[1,2,3]\",\n\t\t\twant:     \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with spaces\",\n\t\t\tinput:    \" [ 1 , 2 , 3 ] \",\n\t\t\twant:     \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}},\n\t\t\twantRest: \" \",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"nested array\",\n\t\t\tinput:    \"[1,[2,3],4]\",\n\t\t\twant: \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeArray, a: []*Value{{t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}}, {t: TypeNumber, s: \"4\"}}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing ]\",\n\t\t\tinput:    \"[1,2,3\",\n\t\t\twant:     nil,\n\t\t\twantRest: \"\",\n\t\t\twantErr:  fmt.Errorf(\"missing ']'\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"missing comma\",\n\t\t\tinput:    \"[1 2 3]\",\n\t\t\twant:     nil,\n\t\t\twantRest: \"2 3]\",\n\t\t\twantErr:  fmt.Errorf(\"missing ',' after array value\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid value\",\n\t\t\tinput:    \"[1,invalid,3]\",\n\t\t\twant:     nil,\n\t\t\twantRest: \"\",\n\t\t\twantErr:  fmt.Errorf(\"cannot parse array value: %s\", \"invalid number\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, rest, err := parseArray(tt.input, c, 0)\n\t\t\tif (err != nil \u0026\u0026 tt.wantErr == nil) || (err == nil \u0026\u0026 tt.wantErr != nil) || (err != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 err.Error() != tt.wantErr.Error()) {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif tt.wantErr == nil \u0026\u0026 !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif rest != tt.wantRest {\n\t\t\t\tt.Errorf(\"parseArray() rest = %v, wantRest %v\", rest, tt.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.t == TypeArray {\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\treturn v1.s == v2.s\n}","51deb49920dfc6e510077a17df92cc0a":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Empty string\n\t\t{\"\", nil, \"\", fmt.Errorf(\"cannot parse empty string\")},\n\t\t// Invalid JSON\n\t\t{\"{\", nil, \"{\", fmt.Errorf(\"cannot parse object: unexpected EOF\")},\n\t\t// Simple object\n\t\t{`{\"key\": \"value\"}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{t: typeRawString, s: \"value\"}}}}}}, \"\", nil},\n\t\t// Simple array\n\t\t{`[1, \"two\", true]`, \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: typeRawString, s: \"two\"}, {t: TypeTrue}}}, \"\", nil},\n\t\t// String\n\t\t{`\"hello, world\"`, \u0026Value{t: typeRawString, s: \"hello, world\"}, \"\", nil},\n\t\t// True\n\t\t{\"true\", valueTrue, \"\", nil},\n\t\t// False\n\t\t{\"false\", valueFalse, \"\", nil},\n\t\t// Null\n\t\t{\"null\", valueNull, \"\", nil},\n\t\t// Number\n\t\t{\"12345\", \u0026Value{t: TypeNumber, s: \"12345\"}, \"\", nil},\n\t\t// NaN\n\t\t{\"NaN\", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"\", nil},\n\t\t// Number with tail\n\t\t{\"12345,\", \u0026Value{t: TypeNumber, s: \"12345\"}, \",\", nil},\n\t\t// Invalid value\n\t\t{\"invalid\", nil, \"invalid\", fmt.Errorf(\"unexpected value found: \\\"invalid\\\"\")},\n\t}\n\n\tc := \u0026cache{}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test #%d: %s\", i, tt.input), func(t *testing.T) {\n\t\t\tgot, tail, err := parseValue(tt.input, c, 0)\n\n\t\t\tif err != nil {\n\t\t\t\tif tt.err == nil {\n\t\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t\t} else if err.Error() != tt.err.Error() {\n\t\t\t\t\tt.Errorf(\"error mismatch: got %q, want %q\", err.Error(), tt.err.Error())\n\t\t\t\t}\n\t\t\t} else if tt.err != nil {\n\t\t\t\tt.Errorf(\"expected error, got nil\")\n\t\t\t}\n\n\t\t\tif got == nil \u0026\u0026 tt.want != nil {\n\t\t\t\tt.Errorf(\"value mismatch: got nil, want %v\", tt.want)\n\t\t\t} else if got != nil \u0026\u0026 tt.want == nil {\n\t\t\t\tt.Errorf(\"value mismatch: got %v, want nil\", got)\n\t\t\t} else if got != nil \u0026\u0026 tt.want != nil {\n\t\t\t\tif got.t != tt.want.t {\n\t\t\t\t\tt.Errorf(\"type mismatch: got %d, want %d\", got.t, tt.want.t)\n\t\t\t\t}\n\t\t\t\tswitch got.t {\n\t\t\t\tcase typeRawString:\n\t\t\t\t\tif got.s != tt.want.s {\n\t\t\t\t\t\tt.Errorf(\"string mismatch: got %q, want %q\", got.s, tt.want.s)\n\t\t\t\t\t}\n\t\t\t\tcase TypeNumber:\n\t\t\t\t\tif got.s != tt.want.s {\n\t\t\t\t\t\tt.Errorf(\"number mismatch: got %q, want %q\", got.s, tt.want.s)\n\t\t\t\t\t}\n\t\t\t\tcase TypeObject:\n\t\t\t\t\tif len(got.o.kvs) != len(tt.want.o.kvs) {\n\t\t\t\t\t\tt.Errorf(\"object length mismatch: got %d, want %d\", len(got.o.kvs), len(tt.want.o.kvs))\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor j := range got.o.kvs {\n\t\t\t\t\t\t\tif got.o.kvs[j].k != tt.want.o.kvs[j].k {\n\t\t\t\t\t\t\t\tt.Errorf(\"object key mismatch: got %q, want %q\", got.o.kvs[j].k, tt.want.o.kvs[j].k)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif got.o.kvs[j].v.t != tt.want.o.kvs[j].v.t {\n\t\t\t\t\t\t\t\tt.Errorf(\"object value type mismatch: got %d, want %d\", got.o.kvs[j].v.t, tt.want.o.kvs[j].v.t)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif got.o.kvs[j].v.s != tt.want.o.kvs[j].v.s {\n\t\t\t\t\t\t\t\tt.Errorf(\"object value mismatch: got %q, want %q\", got.o.kvs[j].v.s, tt.want.o.kvs[j].v.s)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tcase TypeArray:\n\t\t\t\t\tif len(got.a) != len(tt.want.a) {\n\t\t\t\t\t\tt.Errorf(\"array length mismatch: got %d, want %d\", len(got.a), len(tt.want.a))\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor j := range got.a {\n\t\t\t\t\t\t\tif got.a[j].t != tt.want.a[j].t {\n\t\t\t\t\t\t\t\tt.Errorf(\"array value type mismatch: got %d, want %d\", got.a[j].t, tt.want.a[j].t)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif got.a[j].s != tt.want.a[j].s {\n\t\t\t\t\t\t\t\tt.Errorf(\"array value mismatch: got %q, want %q\", got.a[j].s, tt.want.a[j].s)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"tail mismatch: got %q, want %q\", tail, tt.tail)\n\t\t\t}\n\t\t})\n\t}\n}","51eb580ec9a46535500e7d56e243aafa":"package fastjson\n\nimport \"testing\"\n\nfunc Test_unescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello world\",\n\t\t\t},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"simple escape\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello\\\\tworld\",\n\t\t\t},\n\t\t\twant: \"hello\\tworld\",\n\t\t},\n\t\t{\n\t\t\tname: \"unicode escape\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\u0048\\\\u0065\\\\u006c\\\\u006co\",\n\t\t\t},\n\t\t\twant: \"Hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid unicode escape\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\u0048\\\\u006x\\\\u006c\\\\u006co\",\n\t\t\t},\n\t\t\twant: \"H\\\\u006xl\\\\u006co\",\n\t\t},\n\t\t{\n\t\t\tname: \"surrogate pair\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\uD83D\\\\uDE02\",\n\t\t\t},\n\t\t\twant: \"üòÇ\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid surrogate pair\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\uD83D\\\\u006x\",\n\t\t\t},\n\t\t\twant: \"\\\\uD83D\\\\u006x\",\n\t\t},\n\t\t{\n\t\t\tname: \"mixed escape\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello\\\\tworld\\\\n\\\\u0048\\\\u0065\\\\u006c\\\\u006co\",\n\t\t\t},\n\t\t\twant: \"hello\\tworld\\nHello\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","5247ae134bd05d190a83b85d60a407ce":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Empty string\n\t\t{\"\", nil, \"\", fmt.Errorf(\"cannot parse empty string\")},\n\n\t\t// Object\n\t\t{`{\"foo\":\"bar\"}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: typeRawString, s: \"bar\"}}}}}, \"\", nil},\n\n\t\t// Array\n\t\t{`[1,2,3]`, \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}}, \"\", nil},\n\n\t\t// String\n\t\t{`\"hello\"`, \u0026Value{t: typeRawString, s: \"hello\"}, \"\", nil},\n\n\t\t// True\n\t\t{\"true\", valueTrue, \"\", nil},\n\n\t\t// False\n\t\t{\"false\", valueFalse, \"\", nil},\n\n\t\t// Null\n\t\t{\"null\", valueNull, \"\", nil},\n\n\t\t// NaN\n\t\t{\"NaN\", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"\", nil},\n\n\t\t// Number\n\t\t{\"123\", \u0026Value{t: TypeNumber, s: \"123\"}, \"\", nil},\n\n\t\t// Unexpected value\n\t\t{\"xyz\", nil, \"xyz\", fmt.Errorf(\"unexpected value found: %q\", \"xyz\")},\n\t}\n\n\tfor i, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tgot, tail, err := parseValue(test.input, c, 0)\n\n\t\t\tif got != nil \u0026\u0026 test.want != nil {\n\t\t\t\tif got.t != test.want.t {\n\t\t\t\t\tt.Errorf(\"Test-%d: got type %v, want %v\", i, got.t, test.want.t)\n\t\t\t\t}\n\t\t\t\tif got.s != test.want.s {\n\t\t\t\t\tt.Errorf(\"Test-%d: got string %q, want %q\", i, got.s, test.want.s)\n\t\t\t\t}\n\t\t\t} else if got != nil \u0026\u0026 test.want == nil {\n\t\t\t\tt.Errorf(\"Test-%d: got %v, want nil\", i, got)\n\t\t\t} else if got == nil \u0026\u0026 test.want != nil {\n\t\t\t\tt.Errorf(\"Test-%d: got nil, want %v\", i, test.want)\n\t\t\t}\n\n\t\t\tif tail != test.tail {\n\t\t\t\tt.Errorf(\"Test-%d: got tail %q, want %q\", i, tail, test.tail)\n\t\t\t}\n\n\t\t\tif (err != nil \u0026\u0026 test.err == nil) || (err == nil \u0026\u0026 test.err != nil) || (err != nil \u0026\u0026 test.err != nil \u0026\u0026 err.Error() != test.err.Error()) {\n\t\t\t\tt.Errorf(\"Test-%d: got error %v, want %v\", i, err, test.err)\n\t\t\t}\n\t\t})\n\t}\n}","526d23c85d09e89c801d9123b00e9a9b":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic tests\n\t\t{`\"\"`, `\"\"`},\n\t\t{`\"foo\"`, `foo`},\n\t\t{`\"foo\\nbar\"`, `foo\\nbar`},\n\t\t{`\"foo\\\\bar\"`, `foo\\bar`},\n\t\t{`\"foo\\\"bar\"`, `foo\"bar`},\n\t\t{`\"foo\\tbar\"`, `foo\tbar`},\n\n\t\t// Unicode escapes\n\t\t{`\"\\u0020\"`, \" \"},\n\t\t{`\"\\u00A0\"`, \"¬†\"},\n\t\t{`\"\\u20AC\"`, \"‚Ç¨\"},\n\t\t{`\"\\uD83D\\uDE02\"`, \"üòÇ\"}, // Surrogate pair\n\n\t\t// Invalid unicode escapes\n\t\t{`\"\\u\"`, `\\u`},\n\t\t{`\"\\u002\"`, `\\u002`},\n\t\t{`\"\\u002x\"`, `\\u002x`},\n\t\t{`\"\\uD83D\"`, `\\uD83D`},      // Incomplete surrogate pair\n\t\t{`\"\\uD83D\\u\"`, `\\uD83D\\u`},    // Incomplete surrogate pair\n\t\t{`\"\\uD83D\\uD83D\"`, `\\uD83D\\uD83D`}, // Invalid surrogate pair\n\n\t\t// Other escape sequences\n\t\t{`\"\\/test\"`, `/test`},\n\t\t{`\"\\btest\"`, `\\btest`},\n\t\t{`\"\\ftest\"`, `\\ftest`},\n\t\t{`\"\\ntest\"`, `\\ntest`},\n\t\t{`\"\\rtest\"`, `\\rtest`},\n\t\t{`\"\\ttest\"`, `\\ttest`},\n\n\t\t// Mixed escapes\n\t\t{`\"foo\\\\bar\\nbaz\\uD83D\\uDE02qux\"`, `foo\\bar\\nbazüòÇqux`},\n\t}\n\n\tfor i, tt := range tests {\n\t\tactual := unescapeStringBestEffort(tt.input)\n\t\tif actual != tt.expected {\n\t\t\tt.Errorf(\"Test %d: Expected %q, got %q\", i+1, tt.expected, actual)\n\t\t}\n\t}\n}","528a2d825a6aee6a7ac7a372fbecd8b5":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"raw string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"raw string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"12345\",\n\t\t\t},\n\t\t\twant: []byte(\"12345\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"string\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"12345\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"[\\\"string\\\",12345]\"),\n\t\t},\n\t\t// Add more test cases for Object type\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif string(got) != string(tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", string(got), string(tt.want))\n\t\t\t}\n\t\t})\n\t}\n}","52b69c67d9b989e8d08cb882093db87e":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Get(t *testing.T) {\n\tt.Run(\"null\", func(t *testing.T) {\n\t\tv := \u0026Value{t: TypeNull}\n\t\tif v.Get(\"key\") != nil {\n\t\t\tt.Errorf(\"expected nil, got %v\", v.Get(\"key\"))\n\t\t}\n\t})\n\n\tt.Run(\"object\", func(t *testing.T) {\n\t\tv := \u0026Value{\n\t\t\tt: TypeObject,\n\t\t\to: Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\n\t\tt.Run(\"existing key\", func(t *testing.T) {\n\t\t\tif got := v.Get(\"key1\").String(); got != \"value1\" {\n\t\t\t\tt.Errorf(\"expected 'value1', got '%s'\", got)\n\t\t\t}\n\t\t})\n\n\t\tt.Run(\"non-existing key\", func(t *testing.T) {\n\t\t\tif v.Get(\"key3\") != nil {\n\t\t\t\tt.Error(\"expected nil, got non-nil\")\n\t\t\t}\n\t\t})\n\n\t\tt.Run(\"nested key\", func(t *testing.T) {\n\t\t\tv := \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeObject, o: Object{\n\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t{k: \"nestedKey\", v: \u0026Value{t: TypeString, s: \"nestedValue\"}},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}\n\n\t\t\tif got := v.Get(\"key1\", \"nestedKey\").String(); got != \"nestedValue\" {\n\t\t\t\tt.Errorf(\"expected 'nestedValue', got '%s'\", got)\n\t\t\t}\n\t\t})\n\n\t})\n\n\tt.Run(\"array\", func(t *testing.T) {\n\t\tv := \u0026Value{\n\t\t\tt: TypeArray,\n\t\t\ta: []*Value{\n\t\t\t\t{t: TypeString, s: \"value1\"},\n\t\t\t\t{t: TypeNumber, s: \"123\"},\n\t\t\t},\n\t\t}\n\n\t\tt.Run(\"valid index\", func(t *testing.T) {\n\t\t\tif got := v.Get(\"1\").Int(); got != 123 {\n\t\t\t\tt.Errorf(\"expected 123, got %d\", got)\n\t\t\t}\n\t\t})\n\n\t\tt.Run(\"invalid index\", func(t *testing.T) {\n\t\t\tif v.Get(\"2\") != nil {\n\t\t\t\tt.Error(\"expected nil, got non-nil\")\n\t\t\t}\n\t\t})\n\n\t\tt.Run(\"non-numeric index\", func(t *testing.T) {\n\t\t\tif v.Get(\"key\") != nil {\n\t\t\t\tt.Error(\"expected nil, got non-nil\")\n\t\t\t}\n\t\t})\n\n\t\tt.Run(\"nested array\", func(t *testing.T) {\n\t\t\tv := \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeArray, a: []*Value{\n\t\t\t\t\t\t{t: TypeString, s: \"nestedValue\"},\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t}\n\n\t\t\tif got := v.Get(\"0\", \"0\").String(); got != \"nestedValue\" {\n\t\t\t\tt.Errorf(\"expected 'nestedValue', got '%s'\", got)\n\t\t\t}\n\t\t})\n\t})\n}\n","52d2cdb7fd59ff3333585b77492b3dac":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ts     string\n\t\terr   error\n\t}{\n\t\t// Empty object\n\t\t{\n\t\t\tinput: `{}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: nil,\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Single key-value pair\n\t\t{\n\t\t\tinput: `{\"key\": \"value\"}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: \u0026Value{t: TypeString, s: \"value\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Multiple key-value pairs\n\t\t{\n\t\t\tinput: `{\"key1\": \"value1\", \"key2\": 123, \"key3\": true}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t\t{k: \"key3\", v: \u0026Value{t: TypeTrue}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Nested objects\n\t\t{\n\t\t\tinput: `{\"key1\": {\"key2\": \"value2\"}, \"key3\": \"value3\"}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{k: \"key3\", v: \u0026Value{t: TypeString, s: \"value3\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// With whitespace\n\t\t{\n\t\t\tinput: \" {\\n\\t\\\"key\\\" :  \\\"value\\\"\\n} \",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: \u0026Value{t: TypeString, s: \"value\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Invalid JSON\n\t\t{\n\t\t\tinput: `{\"key\": \"value\"`,\n\t\t\twant:  nil,\n\t\t\ts:     `{\"key\": \"value\"`,\n\t\t\terr:   fmt.Errorf(\"cannot find opening '\"\" for object key\"),\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseObject(tt.input, c, 0)\n\t\t\tif (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"parseObject(%s) returned error %v, want %v\", tt.input, err, tt.err)\n\t\t\t}\n\t\t\tif s != tt.s {\n\t\t\t\tt.Errorf(\"parseObject(%s) returned unexpected string: got %s, want %s\", tt.input, s, tt.s)\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject(%s) returned %#v, want %#v\", tt.input, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.t == TypeString \u0026\u0026 v1.s != v2.s {\n\t\treturn false\n\t}\n\tif v1.t == TypeNumber \u0026\u0026 v1.s != v2.s {\n\t\treturn false\n\t}\n\tif v1.t == TypeObject {\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t}\n\treturn true\n}","52f0859c0121dc670dfa3c6394572777":"package fastjson\n\nimport \"testing\"\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tt    Type\n\t\twant string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\tfor i, tt := range tests {\n\t\tif got := tt.t.String(); got != tt.want {\n\t\t\tt.Errorf(\"test %d, Type(%d).String() = %q, want %q\", i, tt.t, got, tt.want)\n\t\t}\n\t}\n}\n","53998db868a67109c659274b129aa427":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tin   string\n\t\twant *Value\n\t\ts    string\n\t\terr  error\n\t}{\n\t\t// Empty input.\n\t\t{in: \"\", want: nil, s: \"\", err: fmt.Errorf(\"missing ']'\")},\n\n\t\t// Invalid JSON.\n\t\t{in: \"invalid\", want: nil, s: \"invalid\", err: fmt.Errorf(\"cannot parse array value: invalid character 'i' looking for beginning of value\")},\n\n\t\t// Empty array.\n\t\t{\n\t\t\tin:   \"]\",\n\t\t\twant: \u0026Value{t: TypeArray, a: []*Value{}},\n\t\t\ts:    \"\",\n\t\t\terr:  nil,\n\t\t},\n\t\t{\n\t\t\tin:   \"[]\",\n\t\t\twant: \u0026Value{t: TypeArray, a: []*Value{}},\n\t\t\ts:    \"\",\n\t\t\terr:  nil,\n\t\t},\n\n\t\t// Array with one element.\n\t\t{\n\t\t\tin:   \"[1]\",\n\t\t\twant: \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}}},\n\t\t\ts:    \"\",\n\t\t\terr:  nil,\n\t\t},\n\n\t\t// Array with multiple elements.\n\t\t{\n\t\t\tin:   \"[1,2,3]\",\n\t\t\twant: \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}},\n\t\t\ts:    \"\",\n\t\t\terr:  nil,\n\t\t},\n\n\t\t// Array with nested arrays.\n\t\t{\n\t\t\tin:   \"[1,[2,3],4]\",\n\t\t\twant: \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeArray, a: []*Value{{t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}}, {t: TypeNumber, s: \"4\"}}},\n\t\t\ts:    \"\",\n\t\t\terr:  nil,\n\t\t},\n\n\t\t// Array with whitespace.\n\t\t{\n\t\t\tin:   \" [ 1 , 2 , 3 ] \",\n\t\t\twant: \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}},\n\t\t\ts:    \" \",\n\t\t\terr:  nil,\n\t\t},\n\n\t\t// Incomplete array.\n\t\t{\n\t\t\tin:   \"[\",\n\t\t\twant: nil,\n\t\t\ts:    \"[\",\n\t\t\terr:  fmt.Errorf(\"missing ']'\"),\n\t\t},\n\t\t{\n\t\t\tin:   \"[1\",\n\t\t\twant: nil,\n\t\t\ts:    \"[1\",\n\t\t\terr:  fmt.Errorf(\"unexpected end of array\"),\n\t\t},\n\t\t{\n\t\t\tin:   \"[1,\",\n\t\t\twant: nil,\n\t\t\ts:    \"[1,\",\n\t\t\terr:  fmt.Errorf(\"unexpected end of array\"),\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test #%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseArray(tt.in, c, 0)\n\n\t\t\tif (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err == nil) {\n\t\t\t\tt.Errorf(\"expected error %v, got %v\", tt.err, err)\n\t\t\t}\n\t\t\tif err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error() {\n\t\t\t\tt.Errorf(\"expected error %v, got %v\", tt.err, err)\n\t\t\t}\n\t\t\tif s != tt.s {\n\t\t\t\tt.Errorf(\"expected remaining string %q, got %q\", tt.s, s)\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"expected value %v, got %v\", tt.want, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.s != v2.s {\n\t\treturn false\n\t}\n\tif len(v1.a) != len(v2.a) {\n\t\treturn false\n\t}\n\tfor i := range v1.a {\n\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","53b23725d802bd896fea42c9c410de4c":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Empty string\n\t\t{\"\", nil, \"\", fmt.Errorf(\"cannot parse empty string\")},\n\t\t// Invalid JSON\n\t\t{\"{\", nil, \"{\", fmt.Errorf(\"cannot parse object: unexpected end of JSON\")},\n\t\t// Object\n\t\t{`{\"foo\": \"bar\"}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: typeRawString, s: \"bar\"}}}}}, \"\", nil},\n\t\t// Array\n\t\t{`[1, \"two\", true]`, \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: typeRawString, s: \"two\"}, {t: TypeTrue}}}, \"\", nil},\n\t\t// String\n\t\t{`\"hello, world\"`, \u0026Value{t: typeRawString, s: \"hello, world\"}, \"\", nil},\n\t\t// True\n\t\t{\"true\", valueTrue, \"\", nil},\n\t\t// False\n\t\t{\"false\", valueFalse, \"\", nil},\n\t\t// Null\n\t\t{\"null\", valueNull, \"\", nil},\n\t\t// Number\n\t\t{\"12345\", \u0026Value{t: TypeNumber, s: \"12345\"}, \"\", nil},\n\t\t// Number with exponent\n\t\t{\"1.23e4\", \u0026Value{t: TypeNumber, s: \"1.23e4\"}, \"\", nil},\n\t\t// NaN\n\t\t{\"NaN\", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"\", nil},\n\t\t// String with escaped characters\n\t\t{`\"escaped\\nstring\"`, \u0026Value{t: typeRawString, s: \"escaped\\nstring\"}, \"\", nil},\n\t\t// String with unicode escape characters\n\t\t{`\"\\u0041\\u0042\\u0043\"`, \u0026Value{t: typeRawString, s: \"ABC\"}, \"\", nil},\n\t\t// Trailing whitespace\n\t\t{\"true  \", valueTrue, \"  \", nil},\n\t}\n\n\tc := \u0026cache{}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tgot, tail, err := parseValue(tt.input, c, 0)\n\n\t\t\tif tt.err != nil {\n\t\t\t\tif err == nil || err.Error() != tt.err.Error() {\n\t\t\t\t\tt.Errorf(\"Expected error %v, got %v\", tt.err, err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"Expected tail %q, got %q\", tt.tail, tail)\n\t\t\t}\n\n\t\t\tif got == nil \u0026\u0026 tt.want != nil {\n\t\t\t\tt.Errorf(\"Expected non-nil value, got nil\")\n\t\t\t\treturn\n\t\t\t} else if got != nil \u0026\u0026 tt.want == nil {\n\t\t\t\tt.Errorf(\"Expected nil value, got %v\", got)\n\t\t\t\treturn\n\t\t\t} else if got == nil \u0026\u0026 tt.want == nil {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif got.t != tt.want.t {\n\t\t\t\tt.Errorf(\"Expected type %v, got %v\", tt.want.t, got.t)\n\t\t\t}\n\n\t\t\tswitch got.t {\n\t\t\tcase TypeObject:\n\t\t\t\tif len(got.o.kvs) != len(tt.want.o.kvs) {\n\t\t\t\t\tt.Errorf(\"Expected %d key-value pairs, got %d\", len(tt.want.o.kvs), len(got.o.kvs))\n\t\t\t\t}\n\t\t\t\tfor j, kv := range got.o.kvs {\n\t\t\t\t\tif kv.k != tt.want.o.kvs[j].k || kv.v.s != tt.want.o.kvs[j].v.s {\n\t\t\t\t\t\tt.Errorf(\"Expected key-value pair {%q: %q}, got {%q: %q}\", tt.want.o.kvs[j].k, tt.want.o.kvs[j].v.s, kv.k, kv.v.s)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tcase TypeArray:\n\t\t\t\tif len(got.a) != len(tt.want.a) {\n\t\t\t\t\tt.Errorf(\"Expected %d array elements, got %d\", len(tt.want.a), len(got.a))\n\t\t\t\t}\n\t\t\t\tfor j, v := range got.a {\n\t\t\t\t\tif v.s != tt.want.a[j].s {\n\t\t\t\t\t\tt.Errorf(\"Expected array element %q at index %d, got %q\", tt.want.a[j].s, j, v.s)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tif got.s != tt.want.s {\n\t\t\t\t\tt.Errorf(\"Expected value %q, got %q\", tt.want.s, got.s)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n","54d21dbd2f396078b3efb6b6942aa1c4":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantStr  string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Basic cases\n\t\t{`\"foo\"bar`, `foo`, `bar`, nil},\n\t\t{`\"fo\\o\"bar`, `fo\\o`, `bar`, nil},\n\t\t{`\"foo\"`, `foo`, ``, nil},\n\t\t{`\"\"bar`, ``, `bar`, nil},\n\n\t\t// Escaped quotes\n\t\t{`\"foo\\\"bar\"baz`, `foo\"bar`, `baz`, nil},\n\t\t{`\"foo\\\\\\\"bar\"baz`, `foo\\\"bar`, `baz`, nil},\n\t\t{`\"foo\\\\\\\\\"bar\"baz`, `foo\\\\`, `bar\"baz`, nil},\n\n\t\t// Missing closing quote\n\t\t{`\"foobar`, ``, ``, fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo\\\"bar`, ``, ``, fmt.Errorf(`missing closing '\"'`)},\n\n\t\t// Empty string\n\t\t{`\"\"`, ``, ``, nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tgotStr, gotTail, gotErr := parseRawString(tt.input)\n\t\t\tif gotStr != tt.wantStr || gotTail != tt.wantTail || (gotErr != nil \u0026\u0026 tt.wantErr == nil) || (gotErr == nil \u0026\u0026 tt.wantErr != nil) || (gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error()) {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = (%q, %q, %v), want (%q, %q, %v)\", tt.input, gotStr, gotTail, gotErr, tt.wantStr, tt.wantTail, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}\n","55ab33cd70885a9d7bec39d7c6952a4f":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Empty string.\n\t\t{\"\", nil, \"\", fmt.Errorf(\"cannot parse empty string\")},\n\n\t\t// Object.\n\t\t{`{\"foo\":\"bar\"}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: typeRawString, s: \"bar\"}}}}}, \"\", nil},\n\n\t\t// Array.\n\t\t{`[1,2,3]`, \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}}, \"\", nil},\n\n\t\t// String.\n\t\t{`\"hello\"`, \u0026Value{t: typeRawString, s: \"hello\"}, \"\", nil},\n\n\t\t// True.\n\t\t{\"true\", valueTrue, \"\", nil},\n\n\t\t// False.\n\t\t{\"false\", valueFalse, \"\", nil},\n\n\t\t// Null.\n\t\t{\"null\", valueNull, \"\", nil},\n\n\t\t// NaN.\n\t\t{\"NaN\", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"\", nil},\n\n\t\t// Number.\n\t\t{\"123\", \u0026Value{t: TypeNumber, s: \"123\"}, \"\", nil},\n\n\t\t// Invalid JSON.\n\t\t{\"{\", nil, \"{\", fmt.Errorf(\"cannot parse object: unexpected end of JSON\")},\n\t}\n\n\tc := \u0026cache{}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test%d\", i+1), func(t *testing.T) {\n\t\t\tgot, tail, err := parseValue(tt.input, c, 0)\n\t\t\tif fmt.Sprintf(\"%v\", err) != fmt.Sprintf(\"%v\", tt.err) {\n\t\t\t\tt.Errorf(\"parseValue(%q) error mismatch: got %v, want %v\", tt.input, err, tt.err)\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"parseValue(%q) tail mismatch: got %q, want %q\", tt.input, tail, tt.tail)\n\t\t\t}\n\n\t\t\tif got == nil \u0026\u0026 tt.want == nil {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif got.t != tt.want.t {\n\t\t\t\tt.Errorf(\"parseValue(%q) type mismatch: got %v, want %v\", tt.input, got.t, tt.want.t)\n\t\t\t}\n\n\t\t\tswitch got.t {\n\t\t\tcase typeRawString:\n\t\t\t\tif got.s != tt.want.s {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) string mismatch: got %q, want %q\", tt.input, got.s, tt.want.s)\n\t\t\t\t}\n\t\t\tcase TypeNumber:\n\t\t\t\tif got.s != tt.want.s {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) number mismatch: got %q, want %q\", tt.input, got.s, tt.want.s)\n\t\t\t\t}\n\t\t\tcase TypeObject:\n\t\t\t\tif len(got.o.kvs) != len(tt.want.o.kvs) {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) object len mismatch: got %d, want %d\", tt.input, len(got.o.kvs), len(tt.want.o.kvs))\n\t\t\t\t}\n\t\t\t\tfor j := range got.o.kvs {\n\t\t\t\t\tif got.o.kvs[j].k != tt.want.o.kvs[j].k {\n\t\t\t\t\t\tt.Errorf(\"parseValue(%q) object key mismatch: got %q, want %q\", tt.input, got.o.kvs[j].k, tt.want.o.kvs[j].k)\n\t\t\t\t\t}\n\t\t\t\t\tif got.o.kvs[j].v.s != tt.want.o.kvs[j].v.s {\n\t\t\t\t\t\tt.Errorf(\"parseValue(%q) object value mismatch: got %q, want %q\", tt.input, got.o.kvs[j].v.s, tt.want.o.kvs[j].v.s)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tcase TypeArray:\n\t\t\t\tif len(got.a) != len(tt.want.a) {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) array len mismatch: got %d, want %d\", tt.input, len(got.a), len(tt.want.a))\n\t\t\t\t}\n\t\t\t\tfor j := range got.a {\n\t\t\t\t\tif got.a[j].s != tt.want.a[j].s {\n\t\t\t\t\t\tt.Errorf(\"parseValue(%q) array element mismatch: got %q, want %q\", tt.input, got.a[j].s, tt.want.a[j].s)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","55ae7eb91da475c49df165ec95632208":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv:    \u0026Value{t: typeRawString, s: \"raw string\"},\n\t\t\twant: []byte(\"\\\"raw string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv:    \u0026Value{t: TypeString, s: \"string\"},\n\t\t\twant: []byte(\"\\\"string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv:    \u0026Value{t: TypeNumber, s: \"1234\"},\n\t\t\twant: []byte(\"1234\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv:    \u0026Value{t: TypeTrue},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv:    \u0026Value{t: TypeFalse},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv:    \u0026Value{t: TypeNull},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t{t: TypeString, s: \"2\"},\n\t\t\t\t{t: TypeNull},\n\t\t\t}},\n\t\t\twant: []byte(\"[1,\\\"2\\\",null]\"),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: \u0026Value{t: TypeObject, o: Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t},\n\t\t\t}},\n\t\t\twant: []byte(\"{\\\"key1\\\":\\\"value1\\\",\\\"key2\\\":123}\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif string(got) != string(tt.want) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %v, want %v\", string(got), string(tt.want))\n\t\t\t}\n\t\t})\n\t}\n}","55c709ffad8143534ddeaf41a1e7bd19":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantNum  string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"123.456\", \"123.456\", \"\", nil},\n\t\t{\"1.2e3\", \"1.2e3\", \"\", nil},\n\t\t{\"1.2E-3\", \"1.2E-3\", \"\", nil},\n\t\t{\"123a\", \"123\", \"a\", nil},\n\t\t{\"123.456a\", \"123.456\", \"a\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"+inf\", \"+inf\", \"\", nil},\n\t\t{\"-INF\", \"-INF\", \"\", nil},\n\t\t{\"INF\", \"INF\", \"\", nil},\n\t\t{\"+INF\", \"+INF\", \"\", nil},\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"NaN\", \"NaN\", \"\", nil},\n\t\t{\"NAN\", \"NAN\", \"\", nil},\n\t\t{\"-in\", \"\", \"\", fmt.Errorf(`unexpected char: \"-\"`)},\n\t\t{\"+i\", \"\", \"\", fmt.Errorf(`unexpected char: \"+\"`)},\n\t\t{\"a123\", \"\", \"a123\", fmt.Errorf(`unexpected char: \"a\"`)},\n\t}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tgotNum, gotTail, gotErr := parseRawNumber(tt.input)\n\t\t\tif gotNum != tt.wantNum {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) gotNum = %v, want %v\", tt.input, gotNum, tt.wantNum)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) gotTail = %v, want %v\", tt.input, gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif gotErr == nil \u0026\u0026 tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) gotErr = nil, want %v\", tt.input, tt.wantErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr == nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) gotErr = %v, want nil\", tt.input, gotErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) gotErr = %v, want %v\", tt.input, gotErr, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","567dc1a07a611eae451a61af6d9ce469":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCache_getValue(t *testing.T) {\n\tt.Run(\"return last element if enough capacity\", func(t *testing.T) {\n\t\tc := \u0026cache{\n\t\t\tvs: make([]Value, 1, 2),\n\t\t}\n\t\tv := c.getValue()\n\n\t\tif v != \u0026c.vs[1] {\n\t\t\tt.Errorf(\"Expected pointer to last element but got different pointer\")\n\t\t}\n\t})\n\n\tt.Run(\"append new element if not enough capacity\", func(t *testing.T) {\n\t\tc := \u0026cache{\n\t\t\tvs: make([]Value, 1, 1),\n\t\t}\n\t\tv := c.getValue()\n\n\t\tif v != \u0026c.vs[1] {\n\t\t\tt.Errorf(\"Expected pointer to last element but got different pointer\")\n\t\t}\n\t\tif len(c.vs) != 2 {\n\t\t\tt.Errorf(\"Expected 2 elements in slice but got %d\", len(c.vs))\n\t\t}\n\t})\n\n\tt.Run(\"truncate slice if larger than needed\", func(t *testing.T) {\n\t\tc := \u0026cache{\n\t\t\tvs: make([]Value, 2, 2),\n\t\t}\n\t\tc.getValue()\n\t\tv := c.getValue()\n\n\t\tif v != \u0026c.vs[0] {\n\t\t\tt.Errorf(\"Expected pointer to last element but got different pointer\")\n\t\t}\n\t\tif len(c.vs) != 1 {\n\t\t\tt.Errorf(\"Expected 1 elements in slice but got %d\", len(c.vs))\n\t\t}\n\t})\n}\n","569adecc916ae3f07b25462da44a89f4":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tv        *Value\n\t\texpected []byte\n\t}{\n\t\t// typeRawString\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\texpected: []byte(`\"hello\"`),\n\t\t},\n\t\t// TypeString\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\texpected: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped characters\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"he\\tl\\nlo\",\n\t\t\t},\n\t\t\texpected: []byte(`\"he\\tl\\nlo\"`),\n\t\t},\n\t\t// TypeNumber\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"1234\",\n\t\t\t},\n\t\t\texpected: []byte(`1234`),\n\t\t},\n\t\t// TypeTrue\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\texpected: []byte(`true`),\n\t\t},\n\t\t// TypeFalse\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\texpected: []byte(`false`),\n\t\t},\n\t\t// TypeNull\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\texpected: []byte(`null`),\n\t\t},\n\t\t// TypeArray\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\texpected: []byte(`[]`),\n\t\t},\n\t\t{\n\t\t\tname: \"array with one element\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: []byte(`[1]`),\n\t\t},\n\t\t{\n\t\t\tname: \"array with multiple elements\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"hello\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: []byte(`[1,\"hello\",true]`),\n\t\t},\n\t\t// TypeObject\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{},\n\t\t\t},\n\t\t\texpected: []byte(`{}`),\n\t\t},\n\t\t{\n\t\t\tname: \"object with one element\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"name\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"John\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: []byte(`{\"name\":\"John\"}`),\n\t\t},\n\t\t{\n\t\t\tname: \"object with multiple elements\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"name\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"John\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"age\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"30\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"active\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: []byte(`{\"name\":\"John\",\"age\":\"30\",\"active\":true}`),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tactual := tt.v.MarshalTo(nil)\n\t\t\tif string(actual) != string(tt.expected) {\n\t\t\t\tt.Errorf(\"expected: %s, actual: %s\", tt.expected, actual)\n\t\t\t}\n\t\t})\n\t}\n}","569ceb1896d923fc26f5c3de368f3449":"package fastjson\n\nimport \"testing\"\n\nfunc Test_skipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    string\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\ts:    \"\",\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with leading whitespace\",\n\t\t\ts:    \"  foo\",\n\t\t\twant: \"foo\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with no leading whitespace\",\n\t\t\ts:    \"foo\",\n\t\t\twant: \"foo\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with all whitespace\",\n\t\t\ts:    \" \\t\\n\\r\",\n\t\t\twant: \"\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","56d6cf5f0d301863de996118db5b3f31":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantStr  string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Basic cases\n\t\t{`\"foo\"bar`, `foo`, `bar`, nil},\n\t\t{`\"foo\" bar`, `foo`, ` bar`, nil},\n\t\t{`\"foo\"  bar`, `foo`, `  bar`, nil},\n\n\t\t// Empty strings\n\t\t{`\"\"bar`, ``, `bar`, nil},\n\t\t{`\"\" bar`, ``, ` bar`, nil},\n\t\t{`\"\"  bar`, ``, `  bar`, nil},\n\n\t\t// Escaped quotes\n\t\t{`\"fo\\\"o\"bar`, `fo\\\"o`, `bar`, nil},\n\t\t{`\"fo\\\\\"o\"bar`, `fo\\\\\"o`, `bar`, nil},\n\t\t{`\"fo\\\\\\\\\"o\"bar`, `fo\\\\\\\\\"o`, `bar`, nil},\n\t\t{`\"fo\\\\\\\"o\"bar`, `fo\\\\\\\"o`, `bar`, nil},\n\n\t\t// Missing closing quote\n\t\t{`\"foo`, ``, ``, fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"fo\\\"o`, ``, ``, fmt.Errorf(`missing closing '\"'`)},\n\n\t\t// Empty input\n\t\t{``, ``, ``, fmt.Errorf(`missing closing '\"'`)},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tgotStr, gotTail, gotErr := parseRawString(tt.input)\n\n\t\t\tif gotStr != tt.wantStr {\n\t\t\t\tt.Errorf(\"parseRawString(%q) got string = %q, want %q\", tt.input, gotStr, tt.wantStr)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseRawString(%q) got tail = %q, want %q\", tt.input, gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif gotErr != nil \u0026\u0026 tt.wantErr == nil {\n\t\t\t\tt.Errorf(\"parseRawString(%q) got error = %v, want nil\", tt.input, gotErr)\n\t\t\t} else if gotErr == nil \u0026\u0026 tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"parseRawString(%q) got error = nil, want %v\", tt.input, tt.wantErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"parseRawString(%q) got error = %v, want %v\", tt.input, gotErr, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","5839b963b0f00d47ba1ea71416983cae":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\ts       string\n\t\twantV   *Value\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tp := \u0026Parser{}\n\t\t\tgotV, err := p.Parse(tt.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Parser.Parse() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotV != tt.wantV {\n\t\t\t\tt.Errorf(\"Parser.Parse() = %v, want %v\", gotV, tt.wantV)\n\t\t\t}\n\t\t})\n\t}\n}","5871d8de5bda10f9c2f0957142902f82":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Empty input.\n\t\t{\"\", nil, \"\", fmt.Errorf(\"cannot parse empty string\")},\n\n\t\t// Invalid JSON.\n\t\t{\"{\", nil, \"\", fmt.Errorf(\"cannot parse object: missing '}'\")},\n\t\t{\"[\", nil, \"\", fmt.Errorf(\"cannot parse array: missing ']'\")},\n\t\t{\"\\\"unterminated string\", nil, \"\", fmt.Errorf(\"cannot parse string: missing '\\\"'\")},\n\t\t{\"tr\", nil, \"tr\", fmt.Errorf(\"unexpected value found: \\\"tr\\\"\")},\n\t\t{\"fa\", nil, \"fa\", fmt.Errorf(\"unexpected value found: \\\"fa\\\"\")},\n\t\t{\"nu\", nil, \"nu\", fmt.Errorf(\"unexpected value found: \\\"nu\\\"\")},\n\n\t\t// Valid JSON values.\n\t\t{\"{}\", \u0026Value{t: TypeObject, o: Object{}}, \"\", nil},\n\t\t{\"[]\", \u0026Value{t: TypeArray, a: []*Value{}}, \"\", nil},\n\t\t{`\"hello\"`, \u0026Value{t: typeRawString, s: \"hello\"}, \"\", nil},\n\t\t{\"true\", valueTrue, \"\", nil},\n\t\t{\"false\", valueFalse, \"\", nil},\n\t\t{\"null\", valueNull, \"\", nil},\n\t\t{\"123\", \u0026Value{t: TypeNumber, s: \"123\"}, \"\", nil},\n\t\t{\"-123.456\", \u0026Value{t: TypeNumber, s: \"-123.456\"}, \"\", nil},\n\t\t{\"1e+10\", \u0026Value{t: TypeNumber, s: \"1e+10\"}, \"\", nil},\n\n\t\t// Trailing whitespace.\n\t\t{\"{} \", \u0026Value{t: TypeObject, o: Object{}}, \" \", nil},\n\t\t{\"[] \", \u0026Value{t: TypeArray, a: []*Value{}}, \" \", nil},\n\t\t{`\"hello\" `, \u0026Value{t: typeRawString, s: \"hello\"}, \" \", nil},\n\t\t{\"true \", valueTrue, \" \", nil},\n\t\t{\"false \", valueFalse, \" \", nil},\n\t\t{\"null \", valueNull, \" \", nil},\n\t\t{\"123 \", \u0026Value{t: TypeNumber, s: \"123\"}, \" \", nil},\n\n\t\t// Leading whitespace.\n\t\t{\" {}\", \u0026Value{t: TypeObject, o: Object{}}, \"\", nil},\n\t\t{\" []\", \u0026Value{t: TypeArray, a: []*Value{}}, \"\", nil},\n\t\t{` \"hello\"`, \u0026Value{t: typeRawString, s: \"hello\"}, \"\", nil},\n\t\t{\" true\", valueTrue, \"\", nil},\n\t\t{\" false\", valueFalse, \"\", nil},\n\t\t{\" null\", valueNull, \"\", nil},\n\t\t{\" 123\", \u0026Value{t: TypeNumber, s: \"123\"}, \"\", nil},\n\n\t\t// NaN handling\n\t\t{\"NaN\", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"\", nil},\n\t\t{\"nan\", \u0026Value{t: TypeNumber, s: \"nan\"}, \"\", nil},\n\t\t{\"NAN\", \u0026Value{t: TypeNumber, s: \"NAN\"}, \"\", nil},\n\t}\n\n\tc := \u0026cache{}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tgot, tail, err := parseValue(tt.input, c, 0)\n\t\t\tif fmt.Sprintf(\"%v\", err) != fmt.Sprintf(\"%v\", tt.err) {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, wantErr %v\", tt.input, err, tt.err)\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"parseValue(%q) tail = %q, wantTail %q\", tt.input, tail, tt.tail)\n\t\t\t}\n\t\t\tif got != nil \u0026\u0026 tt.want != nil \u0026\u0026 got.t != tt.want.t {\n\t\t\t\tt.Errorf(\"parseValue(%q) got type = %v, want type %v\", tt.input, got.t, tt.want.t)\n\t\t\t}\n\t\t\tif got != nil \u0026\u0026 tt.want != nil \u0026\u0026 got.s != tt.want.s {\n\t\t\t\tt.Errorf(\"parseValue(%q) got string = %q, want string %q\", tt.input, got.s, tt.want.s)\n\t\t\t}\n\t\t})\n\t}\n}\n","58c7405e774342bc9822664969457783":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  string\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Simple cases.\n\t\t{`\"foo\"`, `foo`, ``, nil},\n\t\t{`\"bar\"baz`, `bar`, `baz`, nil},\n\t\t{`\"foo`, ``, ``, fmt.Errorf(`missing closing '\"'`)},\n\n\t\t// Escaped quotes.\n\t\t{`\"fo\\\"o\"`, `fo\"o`, ``, nil},\n\t\t{`\"fo\\\\o\"`, `fo\\o`, ``, nil},\n\t\t{`\"fo\\ooo\"`, `fo\\ooo`, ``, nil},\n\t\t{`\"fo\\\\\\\"o\"`, `fo\\\"o`, ``, nil},\n\t\t{`\"fo\\\\\\\\o\"`, `fo\\\\o`, ``, nil},\n\n\t\t// Escaped quotes at the end.\n\t\t{`\"foo\\\\\"`, `foo\\`, ``, nil},\n\t\t{`\"foo\\\\\\\"\"`, `foo\\\"`, ``, nil},\n\t\t{`\"foo\\\\\\\\\"`, `foo\\\\`, ``, nil},\n\n\t\t// Unescaped quotes.\n\t\t{`\"foo\"bar\"`, `foo`, `bar\"`, nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tgot, tail, err := parseRawString(tt.input)\n\t\tif got != tt.want || tail != tt.tail || !equalError(err, tt.err) {\n\t\t\tt.Errorf(\"#%d: parseRawString(%q) got=(%q, %q, %v), want=(%q, %q, %v)\",\n\t\t\t\ti, tt.input, got, tail, err, tt.want, tt.tail, tt.err)\n\t\t}\n\t}\n}\n\nfunc equalError(err1, err2 error) bool {\n\tif err1 == nil {\n\t\treturn err2 == nil\n\t}\n\tif err2 == nil {\n\t\treturn false\n\t}\n\treturn err1.Error() == err2.Error()\n}","58c88278ce1d66a2a2e9a8ffad165b22":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc Test_parseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\ts       string\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, got1, err := parseObject(tt.s, c, 0)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","5918e72973e48fabd54b0b57cef2017c":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc Test_unescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello, world!\",\n\t\t\t},\n\t\t\twant: \"hello, world!\",\n\t\t},\n\t\t{\n\t\t\tname: \"simple escape sequences\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\\\\"\\\\\\\\\\n\\\\t\\\\r\\\\b\\\\f\",\n\t\t\t},\n\t\t\twant: \"\\\"\\\\\\n\\t\\r\\b\\f\",\n\t\t},\n\t\t{\n\t\t\tname: \"unicode escape sequences\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\u0041\\\\u041f\\\\u0440\\\\u0438\\\\u0432\\\\u0435\\\\u0442\",\n\t\t\t},\n\t\t\twant: \"A–ü—Ä–∏–≤–µ—Ç\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid unicode escape sequences\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\u004\\\\u041\\\\u04z\\\\u043\\\\u04\\\\u\",\n\t\t\t},\n\t\t\twant: \"\\\\u004\\\\u041\\\\u04z\\\\u043\\\\u04\\\\u\",\n\t\t},\n\t\t{\n\t\t\tname: \"surrogate pair\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\uD83D\\\\uDE02\",\n\t\t\t},\n\t\t\twant: \"üòÇ\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid surrogate pair\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\uD83D\\\\u0041\",\n\t\t\t},\n\t\t\twant: \"\\\\uD83D\\\\u0041\",\n\t\t},\n\t\t{\n\t\t\tname: \"mixed escape sequences\",\n\t\t\targs: args{\n\t\t\t\ts: \"Hello, \\\\\\\"world\\\\\\\"\\\\nThis is a \\\\uD83D\\\\uDE02 test!\",\n\t\t\t},\n\t\t\twant: \"Hello, \\\"world\\\"\\nThis is a üòÇ test!\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","59947fc5320ff2dac77bc86ecff32065":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantStr  string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Basic cases.\n\t\t{`\"foo\"bar`, `foo`, `bar`, nil},\n\t\t{`\"fo\\o\"bar`, `fo\\o`, `bar`, nil},\n\t\t{`\"foo\\\"bar\"baz`, `foo\"bar`, `baz`, nil},\n\t\t{`\"foo\\\\bar\"baz`, `foo\\bar`, `baz`, nil},\n\n\t\t// Escaped quotes.\n\t\t{`\"foo\\\"\"bar`, `foo\"`, `bar`, nil},\n\t\t{`\"foo\\\\\\\"\"bar`, `foo\\\"`, `bar`, nil},\n\t\t{`\"foo\\\\\\\\\"bar`, `foo\\\\`, `bar`, nil},\n\n\t\t// Missing closing quote.\n\t\t{`\"foobar`, ``, ``, fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo\\\"bar`, ``, ``, fmt.Errorf(`missing closing '\"'`)},\n\t}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tgotStr, gotTail, gotErr := parseRawString(tt.input)\n\t\t\tif gotStr != tt.wantStr || gotTail != tt.wantTail || (gotErr != nil \u0026\u0026 tt.wantErr == nil) || (gotErr == nil \u0026\u0026 tt.wantErr != nil) || (gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error()) {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = %q, %q, %v, want %q, %q, %v\", tt.input, gotStr, gotTail, gotErr, tt.wantStr, tt.wantTail, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}\n","59b8e71ef0b4aca2099db261e7678633":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twant     *Value\n\t\twantRest string\n\t\twantErr  error\n\t}{\n\t\t{\n\t\t\tname:     \"empty object\",\n\t\t\tinput:    \"{}\",\n\t\t\twant:     \u0026Value{t: TypeObject, o: Object{}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"single key-value\",\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\twant:     \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{t: TypeString, s: \"value\"}}}}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple key-values\",\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 123}`,\n\t\t\twant: \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t}}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"nested objects\",\n\t\t\tinput:    `{\"key1\": {\"key2\": \"value2\"}, \"key3\": \"value3\"}`,\n\t\t\twant: \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}}}}}},\n\t\t\t\t{k: \"key3\", v: \u0026Value{t: TypeString, s: \"value3\"}},\n\t\t\t}}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t// Add more test cases for different scenarios like:\n\t\t// - invalid JSON format\n\t\t// - escaped characters in keys and values\n\t\t// - different data types for values\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, rest, err := parseObject(tt.input, c, 0)\n\t\t\tif fmt.Sprintf(\"%v\", err) != fmt.Sprintf(\"%v\", tt.wantErr) {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif rest != tt.wantRest {\n\t\t\t\tt.Errorf(\"parseObject() rest = %v, wantRest %v\", rest, tt.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k || !equalValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeTrue, TypeFalse, TypeNull:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}","5babdb3951265dc321e891198b96edd4":"package fastjson\n\nimport \"testing\"\n\nfunc Test_hasSpecialChars(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"Empty String\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Simple String\",\n\t\t\targs: args{s: \"hello\"},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"String with space\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"String with double quote\",\n\t\t\targs: args{s: \"hello\\\"world\"},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"String with backslash\",\n\t\t\targs: args{s: \"hello\\\\world\"},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"String with control character\",\n\t\t\targs: args{s: \"hello\\x01world\"},\n\t\t\twant: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := hasSpecialChars(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"hasSpecialChars() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","5cd64ad2aa4560244f16feafbdcdc631":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantJSON string\n\t\twantErr  error\n\t}{\n\t\t{\n\t\t\tname:     \"empty object\",\n\t\t\tinput:    \"{}\",\n\t\t\twantJSON: `{}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"simple object\",\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\twantJSON: `{\"key\": \"value\"}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"nested object\",\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": {\"key3\": \"value3\"}}`,\n\t\t\twantJSON: `{\"key1\": \"value1\", \"key2\": {\"key3\": \"value3\"}}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"object with array\",\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": [1,2,3]}`,\n\t\t\twantJSON: `{\"key1\": \"value1\", \"key2\": [1, 2, 3]}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"object with different value types\",\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": true, \"key3\": 123, \"key4\": null}`,\n\t\t\twantJSON: `{\"key1\": \"value1\", \"key2\": true, \"key3\": 123, \"key4\": null}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid object: missing colon\",\n\t\t\tinput:    `{\"key\" \"value\"}`,\n\t\t\twantErr: fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid object: missing closing brace\",\n\t\t\tinput:    `{\"key\": \"value\"`,\n\t\t\twantErr: fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseObject(tt.input, c, 0)\n\t\t\tif tt.wantErr != nil {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"parseObject() error = nil, wantErr %v\", tt.wantErr)\n\t\t\t\t} else if err.Error() != tt.wantErr.Error() {\n\t\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr nil\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif s != \"\" {\n\t\t\t\tt.Errorf(\"parseObject() string = %v, want empty string\", s)\n\t\t\t}\n\t\t\tgotJSON := got.String()\n\t\t\tif gotJSON != tt.wantJSON {\n\t\t\t\tt.Errorf(\"parseObject() got = %s, want %s\", gotJSON, tt.wantJSON)\n\t\t\t}\n\t\t})\n\t}\n}\n","5d423fabd7fd94b752240bfb62492b92":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetArray(t *testing.T) {\n\tvar tests = []struct {\n\t\tname     string\n\t\tjson     string\n\t\targs     []string\n\t\twant     []*Value\n\t\twantFail bool\n\t}{\n\t\t{\n\t\t\tname: \"simple\",\n\t\t\tjson: `{\"a\": [1,2,3]}`,\n\t\t\targs: []string{\"a\"},\n\t\t\twant: []*Value{\n\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"nested\",\n\t\t\tjson: `{\"a\": {\"b\": [1,2,3]}}`,\n\t\t\targs: []string{\"a\", \"b\"},\n\t\t\twant: []*Value{\n\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:     \"non-existing key\",\n\t\t\tjson:     `{\"a\": [1,2,3]}`,\n\t\t\targs:     []string{\"b\"},\n\t\t\twant:     nil,\n\t\t\twantFail: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid value type\",\n\t\t\tjson:     `{\"a\": 123}`,\n\t\t\targs:     []string{\"a\"},\n\t\t\twant:     nil,\n\t\t\twantFail: true,\n\t\t},\n\t\t{\n\t\t\tname: \"array index\",\n\t\t\tjson: `{\"a\": [1,2,[4,5,6]]}`,\n\t\t\targs: []string{\"a\", \"2\"},\n\t\t\twant: []*Value{\n\t\t\t\t{t: TypeNumber, s: \"4\"},\n\t\t\t\t{t: TypeNumber, s: \"5\"},\n\t\t\t\t{t: TypeNumber, s: \"6\"},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"array index out of range\",\n\t\t\tjson: `{\"a\": [1,2,3]}`,\n\t\t\targs: []string{\"a\", \"3\"},\n\t\t\twant:     nil,\n\t\t\twantFail: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid array index\",\n\t\t\tjson: `{\"a\": [1,2,3]}`,\n\t\t\targs: []string{\"a\", \"abc\"},\n\t\t\twant:     nil,\n\t\t\twantFail: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv, err := ParseBytes([]byte(tt.json))\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"fastjson.ParseBytes() error = %v\", err)\n\t\t\t}\n\t\t\tgot := v.GetArray(tt.args...)\n\t\t\tif tt.wantFail {\n\t\t\t\tif got != nil {\n\t\t\t\t\tt.Errorf(\"Value.GetArray() = %v, want nil\", got)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif len(got) != len(tt.want) {\n\t\t\t\tt.Errorf(\"Value.GetArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tfor i, v := range got {\n\t\t\t\tif v.Type() != tt.want[i].Type() {\n\t\t\t\t\tt.Errorf(\"Value.GetArray() got[%d].Type() = %v, want %v\", i, v.Type(), tt.want[i].Type())\n\t\t\t\t}\n\t\t\t\tif v.String() != tt.want[i].String() {\n\t\t\t\t\tt.Errorf(\"Value.GetArray() got[%d].String() = %v, want %v\", i, v.String(), tt.want[i].String())\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","5d50de60db0396b2d0bd0253f72fb162":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput       string\n\t\twantValue   *Value\n\t\twantTail    string\n\t\twantErr     bool\n\t\twantErrType error\n\t}{\n\t\t// Empty string\n\t\t{\"\", nil, \"\", true, fmt.Errorf(\"cannot parse empty string\")},\n\n\t\t// Object\n\t\t{`{\"foo\": \"bar\"}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: typeRawString, s: \"bar\"}}}}}}, \"\", false, nil},\n\n\t\t// Array\n\t\t{`[1, \"two\", true]`, \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: typeRawString, s: \"two\"}, {t: TypeTrue}}}, \"\", false, nil},\n\n\t\t// String\n\t\t{`\"hello, world\"`, \u0026Value{t: typeRawString, s: \"hello, world\"}, \"\", false, nil},\n\n\t\t// True\n\t\t{\"true\", valueTrue, \"\", false, nil},\n\n\t\t// False\n\t\t{\"false\", valueFalse, \"\", false, nil},\n\n\t\t// Null\n\t\t{\"null\", valueNull, \"\", false, nil},\n\n\t\t// Number\n\t\t{\"12345\", \u0026Value{t: TypeNumber, s: \"12345\"}, \"\", false, nil},\n\t\t{\"-12345\", \u0026Value{t: TypeNumber, s: \"-12345\"}, \"\", false, nil},\n\t\t{\"12.345\", \u0026Value{t: TypeNumber, s: \"12.345\"}, \"\", false, nil},\n\t\t{\"-12.345\", \u0026Value{t: TypeNumber, s: \"-12.345\"}, \"\", false, nil},\n\t\t{\"1.2345e5\", \u0026Value{t: TypeNumber, s: \"1.2345e5\"}, \"\", false, nil},\n\t\t{\"-1.2345e-5\", \u0026Value{t: TypeNumber, s: \"-1.2345e-5\"}, \"\", false, nil},\n\n\t\t// NaN\n\t\t{\"NaN\", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"\", false, nil},\n\t\t{\"nan\", \u0026Value{t: TypeNumber, s: \"nan\"}, \"\", false, nil},\n\n\t\t// Invalid\n\t\t{\"invalid\", nil, \"invalid\", true, fmt.Errorf(\"unexpected value found: \\\"invalid\\\"\")},\n\n\t\t// Tail\n\t\t{`\"foo\"tail`, \u0026Value{t: typeRawString, s: \"foo\"}, \"tail\", false, nil},\n\t}\n\n\tc := \u0026cache{}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test %d: %s\", i, tt.input), func(t *testing.T) {\n\t\t\tgotValue, gotTail, gotErr := parseValue(tt.input, c, 0)\n\n\t\t\tif (gotErr != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", gotErr, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif tt.wantErr \u0026\u0026 tt.wantErrType != nil {\n\t\t\t\tif !fmt.Errorf(\"%T\", gotErr).Is(tt.wantErrType) {\n\t\t\t\t\tt.Errorf(\"parseValue() error type = %T, wantErrType %v\", gotErr, tt.wantErrType)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\tif gotValue == nil \u0026\u0026 tt.wantValue == nil {\n\t\t\t\t// Both nil, nothing to compare\n\t\t\t} else if gotValue == nil || tt.wantValue == nil {\n\t\t\t\tt.Errorf(\"parseValue() gotValue = %v, want %v\", gotValue, tt.wantValue)\n\t\t\t} else {\n\t\t\t\tif gotValue.t != tt.wantValue.t {\n\t\t\t\t\tt.Errorf(\"parseValue() gotValue.t = %v, want %v\", gotValue.t, tt.wantValue.t)\n\t\t\t\t}\n\t\t\t\tif gotValue.s != tt.wantValue.s {\n\t\t\t\t\tt.Errorf(\"parseValue() gotValue.s = %v, want %v\", gotValue.s, tt.wantValue.s)\n\t\t\t\t}\n\t\t\t\tif gotValue.t == TypeObject {\n\t\t\t\t\tif len(gotValue.o.kvs) != len(tt.wantValue.o.kvs) {\n\t\t\t\t\t\tt.Errorf(\"parseValue() gotValue.o.kvs length mismatch\")\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor j := range gotValue.o.kvs {\n\t\t\t\t\t\t\tif gotValue.o.kvs[j].k != tt.wantValue.o.kvs[j].k {\n\t\t\t\t\t\t\t\tt.Errorf(\"parseValue() gotValue.o.kvs[%d].k = %v, want %v\", j, gotValue.o.kvs[j].k, tt.wantValue.o.kvs[j].k)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif gotValue.o.kvs[j].v.s != tt.wantValue.o.kvs[j].v.s {\n\t\t\t\t\t\t\t\tt.Errorf(\"parseValue() gotValue.o.kvs[%d].v.s = %v, want %v\", j, gotValue.o.kvs[j].v.s, tt.wantValue.o.kvs[j].v.s)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseValue() gotTail = %v, want %v\", gotTail, tt.wantTail)\n\t\t\t}\n\t\t})\n\t}\n}\n","5d9ba318f485a038f98ce79add0f925e":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput  string\n\t\tns     string\n\t\ttail   string\n\t\thasErr bool\n\t}{\n\t\t{\"123\", \"123\", \"\", false},\n\t\t{\"123a\", \"123\", \"a\", false},\n\t\t{\"123.456\", \"123.456\", \"\", false},\n\t\t{\"-123\", \"-123\", \"\", false},\n\t\t(\"+123\", \"+123\", \"\", false},\n\t\t{\"1e5\", \"1e5\", \"\", false},\n\t\t{\"1E5\", \"1E5\", \"\", false},\n\t\t{\"1.2e5\", \"1.2e5\", \"\", false},\n\t\t{\"1.2e+5\", \"1.2e+5\", \"\", false},\n\t\t{\"1.2e-5\", \"1.2e-5\", \"\", false},\n\t\t{\"inf\", \"inf\", \"\", false},\n\t\t{\"+inf\", \"+inf\", \"\", false},\n\t\t{\"-inf\", \"-inf\", \"\", false},\n\t\t{\"InF\", \"InF\", \"\", false},\n\t\t{\"inF\", \"inF\", \"\", false},\n\t\t{\"inf123\", \"inf\", \"123\", false},\n\t\t{\"+inf123\", \"+inf\", \"123\", false},\n\t\t{\"-inf123\", \"-inf\", \"123\", false},\n\t\t{\"nan\", \"nan\", \"\", false},\n\t\t{\"+nan\", \"+nan\", \"\", false},\n\t\t{\"-nan\", \"-nan\", \"\", false},\n\t\t{\"naN\", \"naN\", \"\", false},\n\t\t{\"nAn\", \"nAn\", \"\", false},\n\t\t{\"nan123\", \"nan\", \"123\", false},\n\t\t{\"+nan123\", \"+nan\", \"123\", false},\n\t\t{\"-nan123\", \"-nan\", \"123\", false},\n\t\t{\"\", \"\", \"\", true},\n\t\t{\"a\", \"\", \"a\", true},\n\t\t{\"+a\", \"\", \"+a\", true},\n\t\t{\"-a\", \"\", \"-a\", true},\n\t\t{\"+in\", \"\", \"+in\", true},\n\t\t{\"-in\", \"\", \"-in\", true},\n\t}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tns, tail, err := parseRawNumber(tt.input)\n\t\t\tif (err != nil) != tt.hasErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tt.input, err, tt.hasErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif ns != tt.ns {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) ns = %q, want %q\", tt.input, ns, tt.ns)\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) tail = %q, want %q\", tt.input, tail, tt.tail)\n\t\t\t}\n\t\t})\n\t}\n}","5da18abcb95e96380f9c8fd275d622fd":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic strings with no escape sequences\n\t\t{\"hello\", \"hello\"},\n\t\t{\"world\", \"world\"},\n\t\t{\"12345\", \"12345\"},\n\n\t\t// Escaped quotes\n\t\t{`\"hello\\\"world\"`, `hello\"world`},\n\t\t{`\"escaped\\\\quotes\"`, `escaped\\quotes`},\n\n\t\t// Simple escape sequences\n\t\t{\"\\\\n\", \"\\n\"},\n\t\t{\"\\\\t\", \"\\t\"},\n\t\t{\"\\\\r\", \"\\r\"},\n\t\t{\"\\\\b\", \"\\b\"},\n\t\t{\"\\\\f\", \"\\f\"},\n\t\t{\"\\\\\\\\\", \"\\\\\"},\n\t\t{\"\\\\/\", \"/\"},\n\n\t\t// Unicode escape sequences\n\t\t{`\\u0041`, \"A\"},\n\t\t{`\\u00e9`, \"√©\"},\n\t\t{`\\u20ac`, \"‚Ç¨\"},\n\n\t\t// Invalid escape sequences\n\t\t{`\\z`, `\\z`},\n\t\t{`\\u004`, `\\u004`},\n\t\t{`\\u004x`, `\\u004x`},\n\n\t\t// Surrogate pairs\n\t\t{`\\ud83d\\ude00`, \"üòÄ\"},\n\t\t{`\\ud83d\\ude01`, \"üòÅ\"},\n\t\t{`\\ud83d\\ude02`, \"üòÇ\"},\n\n\t\t// Mixed strings with valid and invalid escape sequences\n\t\t{`hello\\tworld\\n`, \"hello\\tworld\\n\"},\n\t\t{`\"hello\\\\world\\\"\\u0041\\u00e9\"`, `hello\\world\"A√©`},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}","5ec1cf68f235fec45dbd1b9bba550fd2":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic escapes\n\t\t{`\"`, `\"`},\n\t\t{`\\`, `\\`},\n\t\t{`/`, `/`},\n\t\t{`\\b`, \"\\b\"},\n\t\t{`\\f`, \"\\f\"},\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\r`, \"\\r\"},\n\t\t{`\\t`, \"\\t\"},\n\n\t\t// Unicode escapes\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A0`, \"\\u00A0\"},\n\t\t{`\\uFFFF`, \"\\uFFFF\"},\n\t\t{`\\uD83D\\uDE01`, \"\\U0001F601\"}, // Surrogate pair\n\n\t\t// Invalid escapes\n\t\t{`\\a`, `\\a`},\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\uD800`, `\\uD800`}, // Unpaired surrogate\n\t\t{`\\uDFFF`, `\\uDFFF`}, // Unpaired surrogate\n\n\t\t// Mixed escapes\n\t\t{`Hello\\tworld\\n`, \"Hello\\tworld\\n\"},\n\t\t{`\"Escaped\\tstring\\\\\"`, `\"Escaped\\tstring\\\\\"`},\n\t\t{`\\u0041\\u0020\\uD83D\\uDE01`, \"A \\U0001F601\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.input, func(t *testing.T) {\n\t\t\tactual := unescapeStringBestEffort(test.input)\n\t\t\tif actual != test.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", test.input, actual, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}","5f00dfe65b2cd06b1edd54aff1a38985":"package fastjson\n\nimport \"testing\"\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tinput Type\n\t\twant  string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\tfor i, tt := range tests {\n\t\tgot := tt.input.String()\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"test[%d]: String() = %q, want %q\", i, got, tt.want)\n\t\t}\n\t}\n}","5f2d638daec8a7a43d52ea4a7cee1688":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueType(t *testing.T) {\n\ttests := []struct {\n\t\tinput    *Value\n\t\texpected Type\n\t}{\n\t\t{\u0026Value{t: TypeNull}, TypeNull},\n\t\t{\u0026Value{t: TypeObject}, TypeObject},\n\t\t{\u0026Value{t: TypeArray}, TypeArray},\n\t\t{\u0026Value{t: TypeString}, TypeString},\n\t\t{\u0026Value{t: TypeNumber}, TypeNumber},\n\t\t{\u0026Value{t: TypeTrue}, TypeTrue},\n\t\t{\u0026Value{t: TypeFalse}, TypeFalse},\n\t\t{\u0026Value{t: typeRawString, s: \"raw string\"}, TypeString},\n\t}\n\n\tfor _, test := range tests {\n\t\tif got := test.input.Type(); got != test.expected {\n\t\t\tt.Errorf(\"Type() = %v, want %v\", got, test.expected)\n\t\t}\n\t}\n}","5f7e1b408299a5feceba48dcfcc3c3e6":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc Test_parseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput  string\n\t\texpect string\n\t\tremain string\n\t\terr    error\n\t}{\n\t\t// Basic cases\n\t\t{`\"foo\"bar`, \"foo\", \"bar\", nil},\n\t\t{`\"fo\\\"o\"bar`, `fo\"o`, \"bar\", nil},\n\t\t{`\"foo\"`, \"foo\", \"\", nil},\n\t\t{`\"\"bar`, \"\", \"bar\", nil},\n\n\t\t// Escape sequences\n\t\t{`\"\\\\\"bar`, `\\`, \"bar\", nil},\n\t\t{`\"\\\\\\\"\"bar`, `\\\"`, \"bar\", nil},\n\t\t{`\"\\\\\\\"bar`, `\\\"bar`, \"\", nil},\n\t\t{`\"foo\\\\\"bar`, `foo\\`, \"bar\", nil},\n\n\t\t// Invalid input\n\t\t{`\"foo`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`foo\"`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"fo\"o\"bar`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tresult, remain, err := parseRawString(tt.input)\n\t\t\tif result != tt.expect {\n\t\t\t\tt.Errorf(\"expected result %q, got %q\", tt.expect, result)\n\t\t\t}\n\t\t\tif remain != tt.remain {\n\t\t\t\tt.Errorf(\"expected remain %q, got %q\", tt.remain, remain)\n\t\t\t}\n\t\t\tif (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err == nil) {\n\t\t\t\tt.Errorf(\"expected error %v, got %v\", tt.err, err)\n\t\t\t}\n\t\t\tif err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error() {\n\t\t\t\tt.Errorf(\"expected error %q, got %q\", tt.err, err)\n\t\t\t}\n\t\t})\n\t}\n}","60373dd5eb43b7806c0c2d73a68b5a1f":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Empty string\n\t\t{\"\", nil, \"\", fmt.Errorf(\"cannot parse empty string\")},\n\t\t// Invalid JSON\n\t\t{\"{\", nil, \"{\", nil},\n\t\t// Object\n\t\t{`{\"foo\":\"bar\"}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: typeRawString, s: \"bar\"}}}}}, \"}\", nil},\n\t\t// Array\n\t\t{`[\"foo\",\"bar\"]`, \u0026Value{t: TypeArray, a: []*Value{{t: typeRawString, s: \"foo\"}, {t: typeRawString, s: \"bar\"}}}, \"]\", nil},\n\t\t// String\n\t\t{`\"foo\"`, \u0026Value{t: typeRawString, s: \"foo\"}, \"\", nil},\n\t\t// True\n\t\t{\"true\", valueTrue, \"\", nil},\n\t\t// False\n\t\t{\"false\", valueFalse, \"\", nil},\n\t\t// Null\n\t\t{\"null\", valueNull, \"\", nil},\n\t\t// Number\n\t\t{\"123\", \u0026Value{t: TypeNumber, s: \"123\"}, \"\", nil},\n\t\t// NaN\n\t\t{\"NaN\", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"\", nil},\n\t}\n\n\tc := \u0026cache{}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tgot, tail, err := parseValue(tt.input, c, 0)\n\t\t\tif (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, wantErr %v\", tt.input, err, tt.err)\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"parseValue(%q) tail = %q, want %q\", tt.input, tail, tt.tail)\n\t\t\t}\n\t\t\tif !compareValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", tt.input, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.t == typeRawString \u0026\u0026 v1.s != v2.s {\n\t\treturn false\n\t}\n\tif v1.t == TypeObject {\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !compareValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t}\n\tif v1.t == TypeArray {\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !compareValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t}\n\treturn true\n}","61b554d4a71f6eec4c4a774e11524106":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput       string\n\t\twantValue   string\n\t\twantTail    string\n\t\twantErr     bool\n\t\twantErrText string\n\t}{\n\t\t// Empty input.\n\t\t{\n\t\t\tinput:       \"\",\n\t\t\twantValue:   \"\",\n\t\t\twantTail:    \"\",\n\t\t\twantErr:     true,\n\t\t\twantErrText: \"missing '}'\",\n\t\t},\n\t\t// Missing closing brace.\n\t\t{\n\t\t\tinput:       `{\"key\": \"value\"`,\n\t\t\twantValue:   \"\",\n\t\t\twantTail:    \"\",\n\t\t\twantErr:     true,\n\t\t\twantErrText: \"missing '}'\",\n\t\t},\n\t\t// Invalid key format.\n\t\t{\n\t\t\tinput:       \"{key: \\\"value\\\"}\",\n\t\t\twantValue:   \"\",\n\t\t\twantTail:    \"\",\n\t\t\twantErr:     true,\n\t\t\twantErrText: `cannot find opening '\"\" for object key`,\n\t\t},\n\t\t// Missing colon after key.\n\t\t{\n\t\t\tinput:       `{\"key\" \"value\"}`,\n\t\t\twantValue:   \"\",\n\t\t\twantTail:    \"\",\n\t\t\twantErr:     true,\n\t\t\twantErrText: \"missing ':' after object key\",\n\t\t},\n\t\t// Missing comma between key-value pairs.\n\t\t{\n\t\t\tinput:       `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantValue:   \"\",\n\t\t\twantTail:    \"\",\n\t\t\twantErr:     true,\n\t\t\twantErrText: \"missing ',' after object value\",\n\t\t},\n\t\t// Valid single key-value pair.\n\t\t{\n\t\t\tinput:       `{\"key\": \"value\"}`,\n\t\t\twantValue:   `{\"key\": \"value\"}`,\n\t\t\twantTail:    \"\",\n\t\t\twantErr:     false,\n\t\t},\n\t\t// Valid multiple key-value pairs.\n\t\t{\n\t\t\tinput:       `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantValue:   `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantTail:    \"\",\n\t\t\twantErr:     false,\n\t\t},\n\t\t// Valid nested object.\n\t\t{\n\t\t\tinput:       `{\"key1\": \"value1\", \"key2\": {\"key3\": \"value3\"}}`,\n\t\t\twantValue:   `{\"key1\": \"value1\", \"key2\": {\"key3\": \"value3\"}}`,\n\t\t\twantTail:    \"\",\n\t\t\twantErr:     false,\n\t\t},\n\t\t// Trailing whitespace.\n\t\t{\n\t\t\tinput:       `{\"key\": \"value\"} `,\n\t\t\twantValue:   `{\"key\": \"value\"}`,\n\t\t\twantTail:    \" \",\n\t\t\twantErr:     false,\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgotValue, gotTail, gotErr := parseObject(tt.input, c, 0)\n\n\t\t\tif (gotErr != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", gotErr, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif gotErr != nil \u0026\u0026 gotErr.Error() != tt.wantErrText {\n\t\t\t\tt.Errorf(\"parseObject() error text = %v, wantErrText %v\", gotErr.Error(), tt.wantErrText)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif tt.wantErr {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tgotValueString := gotValue.String()\n\t\t\tif gotValueString != tt.wantValue {\n\t\t\t\tt.Errorf(\"parseObject() gotValue = %s, wantValue %s\", gotValueString, tt.wantValue)\n\t\t\t}\n\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseObject() gotTail = %s, wantTail %s\", gotTail, tt.wantTail)\n\t\t\t}\n\t\t})\n\t}\n}","61c8116723a685d16e3b316f3a1002d9":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc Test_unescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello world\",\n\t\t\t},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"simple escape\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello\\\\tworld\",\n\t\t\t},\n\t\t\twant: \"hello\\tworld\",\n\t\t},\n\t\t{\n\t\t\tname: \"unicode escape\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello\\\\u0020world\",\n\t\t\t},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid unicode escape\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello\\\\u002world\",\n\t\t\t},\n\t\t\twant: \"hello\\\\u002world\",\n\t\t},\n\t\t{\n\t\t\tname: \"surrogate pair\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello\\\\uD83D\\\\uDE01world\",\n\t\t\t},\n\t\t\twant: \"helloüòÅworld\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid surrogate pair\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello\\\\uD83D\\\\u002world\",\n\t\t\t},\n\t\t\twant: \"hello\\\\uD83D\\\\u002world\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","61fabe52f811641e8d99fbb89579e7fe":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantVal  *Value\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\twantVal:  nil,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t// Add more test cases here\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgotVal, gotTail, gotErr := parseValue(tt.input, c, 0)\n\t\t\tif fmt.Sprintf(\"%v\", gotErr) != fmt.Sprintf(\"%v\", tt.wantErr) {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", gotErr, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseValue() gotTail = %v, want %v\", gotTail, tt.wantTail)\n\t\t\t}\n\t\t\t// Compare gotVal and tt.wantVal based on your implementation\n\t\t\t// ...\n\t\t})\n\t}\n}\n","621369ec062ba27fe0667dfb122818cd":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetObject(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tjson     string\n\t\tkeys     []string\n\t\twantJSON string\n\t}{\n\t\t{\n\t\t\tname:     \"simple object\",\n\t\t\tjson:     `{\"a\": 123}`,\n\t\t\tkeys:     []string{\"a\"},\n\t\t\twantJSON: `123`,\n\t\t},\n\t\t{\n\t\t\tname:     \"nested object\",\n\t\t\tjson:     `{\"a\": {\"b\": 123}}`,\n\t\t\tkeys:     []string{\"a\", \"b\"},\n\t\t\twantJSON: `123`,\n\t\t},\n\t\t{\n\t\t\tname:     \"array index\",\n\t\t\tjson:     `{\"a\": [1, 2, 3]}`,\n\t\t\tkeys:     []string{\"a\", \"1\"},\n\t\t\twantJSON: `2`,\n\t\t},\n\t\t{\n\t\t\tname:     \"non-existing key\",\n\t\t\tjson:     `{\"a\": 123}`,\n\t\t\tkeys:     []string{\"b\"},\n\t\t\twantJSON: `null`,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid key type\",\n\t\t\tjson:     `{\"a\": 123}`,\n\t\t\tkeys:     []string{\"a\", \"b\"},\n\t\t\twantJSON: `null`,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty keys\",\n\t\t\tjson:     `{\"a\": 123}`,\n\t\t\tkeys:     []string{},\n\t\t\twantJSON: `{\"a\": 123}`,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv, err := ParseBytes([]byte(tt.json))\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"ParseBytes error: %v\", err)\n\t\t\t}\n\n\t\t\tgot := v.GetObject(tt.keys...)\n\t\t\tif got == nil {\n\t\t\t\tif tt.wantJSON != \"null\" {\n\t\t\t\t\tt.Errorf(\"GetObject() = nil, want %v\", tt.wantJSON)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgotJSON, err := got.MarshalJSON()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"MarshalJSON error: %v\", err)\n\t\t\t}\n\t\t\tif string(gotJSON) != tt.wantJSON {\n\t\t\t\tt.Errorf(\"GetObject() = %v, want %v\", string(gotJSON), tt.wantJSON)\n\t\t\t}\n\t\t})\n\t}\n}","63402e102f86c86928aec807fb0479ab":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput  string\n\t\tns     string\n\t\ttail   string\n\t\thasErr bool\n\t}{\n\t\t{\"123\", \"123\", \"\", false},\n\t\t{\"123.456\", \"123.456\", \"\", false},\n\t\t{\"-123\", \"-123\", \"\", false},\n\t\t{\"123e+456\", \"123e+456\", \"\", false},\n\t\t{\"123E-456\", \"123E-456\", \"\", false},\n\t\t{\"123.456e-456\", \"123.456e-456\", \"\", false},\n\t\t{\"123a\", \"123\", \"a\", false},\n\t\t{\"123\\\"\", \"123\", \"\\\"\", false},\n\t\t{\"123 \", \"123\", \" \", false},\n\t\t{\"inf\", \"inf\", \"\", false},\n\t\t{\"+inf\", \"+inf\", \"\", false},\n\t\t{\"-inf\", \"-inf\", \"\", false},\n\t\t{\"infa\", \"inf\", \"a\", false},\n\t\t{\"Infinf\", \"\", \"Infinf\", true},\n\t\t{\"nan\", \"nan\", \"\", false},\n\t\t{\"+nan\", \"\", \"+nan\", true},\n\t\t{\"-nan\", \"\", \"-nan\", true},\n\t\t{\"nana\", \"nan\", \"a\", false},\n\t\t{\"NaN\", \"\", \"NaN\", true},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test %d\", i), func(t *testing.T) {\n\t\t\tns, tail, err := parseRawNumber(tt.input)\n\t\t\tif tt.hasErr \u0026\u0026 err == nil {\n\t\t\t\tt.Errorf(\"expected error, got nil\")\n\t\t\t}\n\t\t\tif !tt.hasErr \u0026\u0026 err != nil {\n\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t}\n\t\t\tif ns != tt.ns {\n\t\t\t\tt.Errorf(\"expected ns: %q, got %q\", tt.ns, ns)\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"expected tail: %q, got %q\", tt.tail, tail)\n\t\t\t}\n\t\t})\n\t}\n}","638aa3553dd719f069b9f6dffc648994":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_reset(t *testing.T) {\n\to := \u0026Object{\n\t\tkvs: []kv{\n\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t},\n\t\tkeysUnescaped: true,\n\t}\n\n\to.reset()\n\n\tif len(o.kvs) != 0 {\n\t\tt.Errorf(\"Expected kvs to be empty after reset, got %v\", o.kvs)\n\t}\n\n\tif o.keysUnescaped {\n\t\tt.Error(\"Expected keysUnescaped to be false after reset\")\n\t}\n}","63cc792ba38391a1dc1494e0e4f7ffab":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ts     string\n\t\terr   error\n\t}{\n\t\t// empty object\n\t\t{`{}`, \u0026Value{t: TypeObject, o: Object{}}, \"\", nil},\n\t\t// simple object\n\t\t{`{\"key\": \"value\"}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{t: TypeString, s: \"value\"}}}}}}, \"\", nil},\n\t\t// object with multiple key-value pairs\n\t\t{`{\"key1\": \"value1\", \"key2\": 123, \"key3\": true}`,\n\t\t\t\u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t{k: \"key3\", v: \u0026Value{t: TypeTrue}},\n\t\t\t}}}, \"\", nil},\n\t\t// nested object\n\t\t{`{\"key1\": {\"key2\": \"value2\"}}`,\n\t\t\t\u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key1\", v: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}}}}}}}}}}, \"\", nil},\n\t\t// object with escaped characters\n\t\t{`{\"key\\\"with\\\"quotes\": \"value with quotes\"}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\\\"with\\\"quotes\", v: \u0026Value{t: TypeString, s: \"value with quotes\"}}}}}}, \"\", nil},\n\t\t// invalid object: missing closing brace\n\t\t{`{\"key\": \"value\"`, nil, \"\", fmt.Errorf(\"missing '}'\")},\n\t\t// invalid object: missing colon\n\t\t{`{\"key\" \"value\"}`, nil, \"\", fmt.Errorf(\"missing ':' after object key\")},\n\t\t// invalid object: missing comma\n\t\t{`{\"key1\": \"value1\" \"key2\": \"value2\"}`, nil, \"\", fmt.Errorf(\"missing ',' after object value\")},\n\t\t// invalid object: unexpected end of object\n\t\t{`{\"key\": \"value`, nil, \"\", fmt.Errorf(\"unexpected end of object\")},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"Test case %d: %s\", i+1, tc.input), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseObject(tc.input, c, 0)\n\n\t\t\tif tc.err != nil {\n\t\t\t\tif err == nil || err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"Expected error %v, but got %v\", tc.err, err)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t\t\t}\n\t\t\t\tif got.String() != tc.want.String() {\n\t\t\t\t\tt.Errorf(\"Expected value %v, but got %v\", tc.want, got)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif s != tc.s {\n\t\t\t\tt.Errorf(\"Expected remaining string %q, but got %q\", tc.s, s)\n\t\t\t}\n\t\t})\n\t}\n}\n","63d456ce66116ca7c6f98bdfaf7cb763":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc Test_parseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tin   string\n\t\twant1 string\n\t\twant2 string\n\t\terr  error\n\t}{\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"123.456\", \"123.456\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"+123\", \"+123\", \"\", nil},\n\t\t{\"1.23e+10\", \"1.23e+10\", \"\", nil},\n\t\t{\"1.23e-10\", \"1.23e-10\", \"\", nil},\n\t\t{\"123abc\", \"123\", \"abc\", nil},\n\t\t{\"123.abc\", \"123\", \".abc\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"+inf\", \"+inf\", \"\", nil},\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"-in\", \"\", \"-in\", fmt.Errorf(`unexpected char: \"-\"`,)},\n\t\t{\"+in\", \"\", \"+in\", fmt.Errorf(`unexpected char: \"+\"`,)},\n\t}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tgot1, got2, err := parseRawNumber(tt.in)\n\t\t\tif got1 != tt.want1 || got2 != tt.want2 || (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) {\n\t\t\t\tt.Errorf(\"parseRawNumber(%v) = %v, %v, %v, want %v, %v, %v\", tt.in, got1, got2, err, tt.want1, tt.want2, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}\n","6430a06526b6fe0eb984404080988e8a":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput  string\n\t\texpect string\n\t\ttail   string\n\t\terr    error\n\t}{\n\t\t{`\"foo\"bar`, \"foo\", \"bar\", nil},\n\t\t{`\"fo\\o\"bar`, \"fo\\o\", \"bar\", nil},\n\t\t{`\"foo\\\"bar\"baz`, `foo\"bar`, \"baz\", nil},\n\t\t{`\"foo\\\\\\\"bar\"baz`, `foo\\\"bar`, \"baz\", nil},\n\t\t{`\"\\\"\"bar`, `\"`, \"bar\", nil},\n\t\t{`\"\\\\\"bar`, `\\`, \"bar\", nil},\n\t\t{`\"\\\\\\\"\"bar`, `\\\"`, \"bar\", nil},\n\t\t{`\"\\\\\\\\\"bar`, `\\\\`, \"bar\", nil},\n\n\t\t// errors\n\t\t{`\"foo\"`, \"foo\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`foo\"`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t}\n\tfor i, test := range tests {\n\t\ts, tail, err := parseRawString(test.input)\n\t\tif test.err != nil {\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"test[%d]: error expected, but nil\", i)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif test.err.Error() != err.Error() {\n\t\t\t\tt.Errorf(\"test[%d]: error mismatch,\\ngot\\n%q\\nwant\\n%q\", i, err.Error(), test.err.Error())\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tif err != nil {\n\t\t\tt.Errorf(\"test[%d]: unexpected error: %s\", i, err)\n\t\t\treturn\n\t\t}\n\t\tif test.expect != s {\n\t\t\tt.Errorf(\"test[%d]: unexpected string,\\ngot\\n%q\\nwant\\n%q\", i, s, test.expect)\n\t\t}\n\t\tif test.tail != tail {\n\t\t\tt.Errorf(\"test[%d]: unexpected tail,\\ngot\\n%q\\nwant\\n%q\", i, tail, test.tail)\n\t\t}\n\t}\n}","645caff14b02a94bc8655b0b42b8bae0":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey   string\n\t\tvalue string\n\t\terr   error\n\t}{\n\t\t// Basic cases\n\t\t{`\"foo\"`, \"foo\", \"\", nil},\n\t\t{`\"foo bar\"`, \"foo bar\", \"\", nil},\n\t\t{`\"foo\\\"bar\"`, `foo\"bar`, \"\", nil},\n\t\t{`\"foo\\\\bar\"`, `foo\\bar`, \"\", nil},\n\t\t{`\"foo\\nbar\"`, `foo\\nbar`, \"\", nil},\n\n\t\t// Escaped quotes\n\t\t{`\"foo\\\\\"bar\"`, `foo\\\"bar`, \"\", nil},\n\t\t{`\"foo\\\\\\\\\"bar\"`, `foo\\\\bar`, \"\", nil},\n\n\t\t// Empty strings\n\t\t{`\"\"`, \"\", \"\", nil},\n\t\t{`\"\\\\\"\"`, `\"`, \"\", nil},\n\n\t\t// Error cases\n\t\t{`\"foo`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`foo\"`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo\"bar`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t}\n\n\tfor i, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tkey, value, err := parseRawString(test.input)\n\t\t\tif key != test.key || value != test.value || !equalError(err, test.err) {\n\t\t\t\tt.Errorf(\"Input: %s\\nExpected: %s, %s, %v\\nGot: %s, %s, %v\", test.input, test.key, test.value, test.err, key, value, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// equalError compares two errors for equality.\nfunc equalError(err1, err2 error) bool {\n\tif err1 == nil \u0026\u0026 err2 == nil {\n\t\treturn true\n\t}\n\tif err1 == nil || err2 == nil {\n\t\treturn false\n\t}\n\treturn err1.Error() == err2.Error()\n}","649e83338fd51e1621a05feef82da083":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic strings\n\t\t{\"hello\", \"hello\"},\n\t\t{\"world\", \"world\"},\n\n\t\t// Simple escaping\n\t\t{`\\\"hello\\\"`, `\"hello\"`},\n\t\t{`\\\\world\\\\`, `\\world\\`},\n\t\t{`\\bfoo\\tbar\\n`, \"\\bfoo\\tbar\\n\"},\n\n\t\t// Hex escaping\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00a9`, \"¬©\"},\n\t\t{`\\u2603`, \"‚òÉ\"},\n\n\t\t// Surrogate pairs\n\t\t{`\\ud83d\\ude02`, \"üòÇ\"},\n\t\t{`\\ud83d\\ude09`, \"üòâ\"},\n\n\t\t// Invalid escaping\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\ud83d`, `\\ud83d`},\n\t\t{`\\ud83d\\u`, `\\ud83d\\u`},\n\t\t{`\\ud83d\\ud`, `\\ud83d\\ud`},\n\n\t\t// Escaping mixed with regular characters\n\t\t{`hello\\tworld`, \"hello\\tworld\"},\n\t\t{`\\u00a92020`, \"¬©2020\"},\n\t\t{`foo\\ud83d\\ude02bar`, \"fooüòÇbar\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}\n","6548e1529105cef09542af737bec500c":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Empty input.\n\t\t{\"\", nil, \"\", fmt.Errorf(\"cannot parse empty string\")},\n\t\t// Invalid JSON.\n\t\t{\"{\", nil, \"{\", fmt.Errorf(\"cannot parse object: missing '}'\")},\n\t\t// Valid JSON object.\n\t\t{`{\"foo\": \"bar\"}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: typeRawString, s: \"bar\"}}}}}}, \"\", nil},\n\t\t// Valid JSON array.\n\t\t{`[1, \"foo\", true]`, \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: typeRawString, s: \"foo\"}, {t: TypeTrue}}}, \"\", nil},\n\t\t// Valid JSON string.\n\t\t{`\"hello\"`, \u0026Value{t: typeRawString, s: \"hello\"}, \"\", nil},\n\t\t// Valid JSON true.\n\t\t{\"true\", valueTrue, \"\", nil},\n\t\t// Valid JSON false.\n\t\t{\"false\", valueFalse, \"\", nil},\n\t\t// Valid JSON null.\n\t\t{\"null\", valueNull, \"\", nil},\n\t\t// Valid JSON number.\n\t\t{\"123\", \u0026Value{t: TypeNumber, s: \"123\"}, \"\", nil},\n\t\t// Valid JSON number with exponent.\n\t\t{\"1.23e4\", \u0026Value{t: TypeNumber, s: \"1.23e4\"}, \"\", nil},\n\t\t// Valid JSON NaN.\n\t\t{\"NaN\", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"\", nil},\n\t\t// Valid JSON with trailing whitespace.\n\t\t{\"{\\\"foo\\\":\\\"bar\\\"} \", \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: typeRawString, s: \"bar\"}}}}}}, \" \", nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test #%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, tail, err := parseValue(tt.input, c, 0)\n\t\t\tif (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"parseValue(%q) error mismatch: got %v, want %v\", tt.input, err, tt.err)\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"parseValue(%q) tail mismatch: got %q, want %q\", tt.input, tail, tt.tail)\n\t\t\t}\n\n\t\t\tif got == nil \u0026\u0026 tt.want == nil {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif got == nil \u0026\u0026 tt.want != nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) got nil, want non-nil\", tt.input)\n\t\t\t\treturn\n\t\t\t} else if got != nil \u0026\u0026 tt.want == nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) got non-nil, want nil\", tt.input)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif got.t != tt.want.t {\n\t\t\t\tt.Errorf(\"parseValue(%q) type mismatch: got %v, want %v\", tt.input, got.t, tt.want.t)\n\t\t\t}\n\n\t\t\tswitch got.t {\n\t\t\tcase TypeObject:\n\t\t\t\tif len(got.o.kvs) != len(tt.want.o.kvs) {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) object length mismatch: got %d, want %d\", tt.input, len(got.o.kvs), len(tt.want.o.kvs))\n\t\t\t\t}\n\t\t\t\tfor j := range got.o.kvs {\n\t\t\t\t\tif got.o.kvs[j].k != tt.want.o.kvs[j].k {\n\t\t\t\t\t\tt.Errorf(\"parseValue(%q) object key mismatch: got %q, want %q\", tt.input, got.o.kvs[j].k, tt.want.o.kvs[j].k)\n\t\t\t\t\t}\n\t\t\t\t\tif got.o.kvs[j].v.t != tt.want.o.kvs[j].v.t {\n\t\t\t\t\t\tt.Errorf(\"parseValue(%q) object value type mismatch: got %v, want %v\", tt.input, got.o.kvs[j].v.t, tt.want.o.kvs[j].v.t)\n\t\t\t\t\t}\n\t\t\t\t\tif got.o.kvs[j].v.s != tt.want.o.kvs[j].v.s {\n\t\t\t\t\t\tt.Errorf(\"parseValue(%q) object value mismatch: got %q, want %q\", tt.input, got.o.kvs[j].v.s, tt.want.o.kvs[j].v.s)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tcase TypeArray:\n\t\t\t\tif len(got.a) != len(tt.want.a) {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) array length mismatch: got %d, want %d\", tt.input, len(got.a), len(tt.want.a))\n\t\t\t\t}\n\t\t\t\tfor j := range got.a {\n\t\t\t\t\tif got.a[j].t != tt.want.a[j].t {\n\t\t\t\t\t\tt.Errorf(\"parseValue(%q) array value type mismatch: got %v, want %v\", tt.input, got.a[j].t, tt.want.a[j].t)\n\t\t\t\t\t}\n\t\t\t\t\tif got.a[j].s != tt.want.a[j].s {\n\t\t\t\t\t\tt.Errorf(\"parseValue(%q) array value mismatch: got %q, want %q\", tt.input, got.a[j].s, tt.want.a[j].s)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tcase typeRawString:\n\t\t\t\tif got.s != tt.want.s {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) string mismatch: got %q, want %q\", tt.input, got.s, tt.want.s)\n\t\t\t\t}\n\t\t\tcase TypeNumber:\n\t\t\t\tif got.s != tt.want.s {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) number mismatch: got %q, want %q\", tt.input, got.s, tt.want.s)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n","65d4ee93a3ee3af7d8087f02220faf12":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_getKV(t *testing.T) {\n\to := Object{}\n\n\t// Test when the capacity is less than the length\n\tkv1 := o.getKV()\n\tif kv1.k != \"\" || kv1.v != nil {\n\t\tt.Errorf(\"Expected empty kv, got k: %s, v: %v\", kv1.k, kv1.v)\n\t}\n\n\t// Test when the capacity is greater than the length\n\to.kvs = make([]kv, 1, 2)\n\tkv2 := o.getKV()\n\tif kv2.k != \"\" || kv2.v != nil {\n\t\tt.Errorf(\"Expected empty kv, got k: %s, v: %v\", kv2.k, kv2.v)\n\t}\n}\n","65fc2fe3ed6e0aadf459c8a6722c7911":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCache_getValue(t *testing.T) {\n\tt.Run(\"grow cache\", func(t *testing.T) {\n\t\tc := \u0026cache{}\n\t\tval1 := c.getValue()\n\t\tval2 := c.getValue()\n\n\t\tif val1 == val2 {\n\t\t\tt.Errorf(\"Expected different values, got the same\")\n\t\t}\n\n\t\tif len(c.vs) != 2 {\n\t\t\tt.Errorf(\"Expected cache size 2, got %d\", len(c.vs))\n\t\t}\n\t})\n\n\tt.Run(\"reuse cache\", func(t *testing.T) {\n\t\tc := \u0026cache{\n\t\t\tvs: make([]Value, 10),\n\t\t}\n\t\tval1 := c.getValue()\n\t\tval2 := c.getValue()\n\n\t\tif val1 == val2 {\n\t\t\tt.Errorf(\"Expected different values, got the same\")\n\t\t}\n\n\t\tif len(c.vs) != 11 {\n\t\t\tt.Errorf(\"Expected cache size 11, got %d\", len(c.vs))\n\t\t}\n\t})\n}","667c7903ac2f443de1f8b57d78b53346":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Empty string.\n\t\t{\"\", nil, \"\", fmt.Errorf(\"cannot parse empty string\")},\n\n\t\t// Object.\n\t\t{`{\"foo\": \"bar\"}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: typeRawString, s: \"bar\"}}}}}, \"\", nil},\n\n\t\t// Array.\n\t\t{`[1, \"foo\", true]`, \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: typeRawString, s: \"foo\"}, {t: TypeTrue}}}, \"\", nil},\n\n\t\t// String.\n\t\t{`\"foo\"`, \u0026Value{t: typeRawString, s: \"foo\"}, \"\", nil},\n\n\t\t// True.\n\t\t{\"true\", valueTrue, \"\", nil},\n\n\t\t// False.\n\t\t{\"false\", valueFalse, \"\", nil},\n\n\t\t// Null.\n\t\t{\"null\", valueNull, \"\", nil},\n\n\t\t// Number.\n\t\t{\"123\", \u0026Value{t: TypeNumber, s: \"123\"}, \"\", nil},\n\t\t{\"-123\", \u0026Value{t: TypeNumber, s: \"-123\"}, \"\", nil},\n\t\t{\"123.456\", \u0026Value{t: TypeNumber, s: \"123.456\"}, \"\", nil},\n\t\t{\"-123.456\", \u0026Value{t: TypeNumber, s: \"-123.456\"}, \"\", nil},\n\t\t{\"1.234e5\", \u0026Value{t: TypeNumber, s: \"1.234e5\"}, \"\", nil},\n\t\t{\"-1.234e5\", \u0026Value{t: TypeNumber, s: \"-1.234e5\"}, \"\", nil},\n\n\t\t// NaN.\n\t\t{\"NaN\", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"\", nil},\n\t\t{\"nan\", \u0026Value{t: TypeNumber, s: \"nan\"}, \"\", nil},\n\n\t\t// Invalid input.\n\t\t{\"{\", nil, \"{\", fmt.Errorf(\"cannot parse object: missing '}'\")},\n\t\t{\"[\", nil, \"[\", fmt.Errorf(\"cannot parse array: missing ']'\")},\n\t\t{`\"foo`, nil, `\"foo`, fmt.Errorf(\"cannot parse string: missing '\\\"'\")},\n\t\t{\"tr\", nil, \"tr\", fmt.Errorf(\"unexpected value found: %q\", \"tr\")},\n\t\t{\"fa\", nil, \"fa\", fmt.Errorf(\"unexpected value found: %q\", \"fa\")},\n\t\t{\"nu\", nil, \"nu\", fmt.Errorf(\"unexpected value found: %q\", \"nu\")},\n\t\t{\"123a\", nil, \"a\", fmt.Errorf(\"cannot parse number: %s\", \"invalid character 'a' in literal true (expecting 'e')\")},\n\t}\n\n\tc := \u0026cache{}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tgot, tail, err := parseValue(tt.input, c, 0)\n\t\t\tif (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, wantErr %v\", tt.input, err, tt.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"parseValue(%q) tail = %q, wantTail %q\", tt.input, tail, tt.tail)\n\t\t\t}\n\t\t\tif !compareValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", tt.input, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.t == TypeObject {\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !compareValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\tif v1.t == TypeArray {\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !compareValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\treturn v1.s == v2.s\n}\n","668a856045bb7eb8bad1930a3275cef9":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic escapes\n\t\t{`\\a`, `\\a`},\n\t\t{`\\\\`, `\\`},\n\t\t{`\\\"`, `\"`},\n\t\t{`\\/`, `/`},\n\t\t{`\\b`, \"\\b\"},\n\t\t{`\\f`, \"\\f\"},\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\r`, \"\\r\"},\n\t\t{`\\t`, \"\\t\"},\n\n\t\t// Unicode escapes\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A0`, \"\\u00A0\"},\n\t\t{`\\uFFFF`, \"\\uFFFF\"},\n\t\t{`\\uD83D\\uDE02`, \"üòÇ\"}, // Surrogate pair\n\n\t\t// Invalid escapes\n\t\t{`\\u`, `\\u`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\uD800`, `\\uD800`}, // Unpaired surrogate\n\t\t{`\\uDC00`, `\\uDC00`}, // Unpaired surrogate\n\t\t{`\\uD83D`, `\\uD83D`}, // Unpaired surrogate\n\t\t{`\\uDE02`, `\\uDE02`}, // Unpaired surrogate\n\n\t\t// Mixed strings\n\t\t{`Hello\\tworld`, \"Hello\\tworld\"},\n\t\t{`\"Hello, world!\"`, `\"Hello, world!\"`},\n\t\t{`Path: C:\\Windows\\System32`, `Path: C:\\Windows\\System32`},\n\t\t{`JSON: {\"key\": \"value\"}`, `JSON: {\"key\": \"value\"}`},\n\t\t{`Escaped backslash: \\\\\\\\`, `Escaped backslash: \\\\`},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tactual := unescapeStringBestEffort(tt.input)\n\t\t\tif actual != tt.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", tt.input, actual, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n","6731289aaef77b8400d83d46dbc76417":"package fastjson\n\nimport \"testing\"\n\nfunc Test_hasSpecialChars(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"regular string\",\n\t\t\targs: args{\n\t\t\t\ts: \"abcdefg\",\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with quote\",\n\t\t\targs: args{\n\t\t\t\ts: \"abc\\\"defg\",\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with backslash\",\n\t\t\targs: args{\n\t\t\t\ts: \"abc\\\\defg\",\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with control character\",\n\t\t\targs: args{\n\t\t\t\ts: \"abc\\x01defg\",\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := hasSpecialChars(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"hasSpecialChars() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","67b025a3b6f0c6ae2fda197859e96ab1":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Empty string\n\t\t{\"\", nil, \"\", fmt.Errorf(\"cannot parse empty string\")},\n\t\t// Invalid JSON\n\t\t{\"{invalid}\", nil, \"\", fmt.Errorf(\"cannot parse object: invalid character 'i' looking for beginning of value\")},\n\t\t// Simple object\n\t\t{`{\"key\": \"value\"}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{t: typeRawString, s: \"value\"}}}}}}, \"\", nil},\n\t\t// Simple array\n\t\t{`[1, \"two\", true]`, \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: typeRawString, s: \"two\"}, {t: TypeTrue}}}, \"\", nil},\n\t\t// String with escaped characters\n\t\t{`\"hello\\nworld\"`, \u0026Value{t: typeRawString, s: \"hello\\nworld\"}, \"\", nil},\n\t\t// True boolean\n\t\t{\"true\", valueTrue, \"\", nil},\n\t\t// False boolean\n\t\t{\"false\", valueFalse, \"\", nil},\n\t\t// Null value\n\t\t{\"null\", valueNull, \"\", nil},\n\t\t// Number\n\t\t{\"12345\", \u0026Value{t: TypeNumber, s: \"12345\"}, \"\", nil},\n\t\t// Trailing whitespace\n\t\t{`\"value\"  `, \u0026Value{t: typeRawString, s: \"value\"}, \"  \", nil},\n\t\t// NaN value\n\t\t{\"NaN\", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"\", nil},\n\t}\n\n\tc := \u0026cache{}\n\tfor i, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tgot, tail, err := parseValue(test.input, c, 0)\n\t\t\tif fmt.Sprintf(\"%v\", err) != fmt.Sprintf(\"%v\", test.err) {\n\t\t\t\tt.Errorf(\"parseValue(%q) error mismatch: got %v, want %v\", test.input, err, test.err)\n\t\t\t}\n\t\t\tif tail != test.tail {\n\t\t\t\tt.Errorf(\"parseValue(%q) tail mismatch: got %q, want %q\", test.input, tail, test.tail)\n\t\t\t}\n\t\t\tif !equalValues(got, test.want) {\n\t\t\t\tt.Errorf(\"parseValue(%q) mismatch: got %v, want %v\", test.input, got, test.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\treturn v1.s == v2.s\n\t}\n}","6804e2a188450095521d19251089a3cd":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic strings.\n\t\t{\"\", \"\"},\n\t\t{\"hello\", \"hello\"},\n\t\t// Escaped characters.\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\t`, \"\\t\"},\n\t\t{`\\r`, \"\\r\"},\n\t\t{`\\b`, \"\\b\"},\n\t\t{`\\f`, \"\\f\"},\n\t\t{`\\\\`, `\\`},\n\t\t{`\\\"`, `\"`},\n\t\t{`\\/`, `/`},\n\t\t// Unicode escape sequences.\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A0`, \"\\u00A0\"},\n\t\t{`\\uFFFF`, \"\\uFFFF\"},\n\t\t// Invalid escape sequences.\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\u12345`, `\\u12345`},\n\t\t{`\\u12`, `\\u12`},\n\t\t// Mixed strings.\n\t\t{`hello\\tworld`, \"hello\\tworld\"},\n\t\t{`\"hello\\\\world\"`, `\"hello\\world\"`},\n\t\t// Surrogate pairs\n\t\t{`\\uD83D\\uDE01`, \"\\U0001F601\"},\n\t\t{`\\uD83D\\uDE01\\uD83D\\uDE02`, \"\\U0001F601\\U0001F602\"},\n\t\t// Invalid surrogate pairs\n\t\t{`\\uD83D`, `\\uD83D`},\n\t\t{`\\uD83D\\u1234`, `\\uD83D\\u1234`},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}","682443aef2bd906bc6223297b5892cb3":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic escapes\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\t`, \"\\t\"},\n\t\t{`\\\\`, \"\\\\\"},\n\t\t{`\\/`, \"/\"},\n\t\t{`\\\"`, \"\\\"\"},\n\t\t{`\\b`, \"\\b\"},\n\t\t{`\\f`, \"\\f\"},\n\t\t{`\\r`, \"\\r\"},\n\n\t\t// Unicode escapes\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u03c0`, \"œÄ\"},\n\t\t{`\\uFFFF`, \"\\xef\\xbf\\xbf\"}, // Invalid UTF-8, but replaced\n\n\t\t// Surrogate pairs\n\t\t{`\\uD83D\\uDE02`, \"üòÇ\"},\n\n\t\t// Invalid escapes\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u002`, `\\u002`},\n\t\t{`\\uD800`, `\\uD800`}, // Unpaired surrogate\n\n\t\t// Mixed strings\n\t\t{`Hello\\tworld\\n`, \"Hello\\tworld\\n\"},\n\t\t{`\"This is a test string\"`, \"\\\"This is a test string\\\"\"},\n\t}\n\n\tfor i, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Test %d: Expected %q, got %q\", i, test.expected, actual)\n\t\t}\n\t}\n}","687b07e488e0a192515ad3f89d12c2ca":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic strings with no escape sequences\n\t\t{\"hello\", \"hello\"},\n\t\t{\"world\", \"world\"},\n\n\t\t// Simple escape sequences\n\t\t{`\\\"hello\\\"`, `\"hello\"`},\n\t\t{`\\\\world\\\\`, `\\world\\`},\n\t\t{`\\bfoo\\tbar\\nbaz`, \"\\bfoo\\tbar\\nbaz\"},\n\t\t{`\\r\\n`, \"\\r\\n\"},\n\n\t\t// Unicode escape sequences\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u03C0`, \"œÄ\"},\n\t\t{`\\uFFFF`, \"Ôøø\"},\n\n\t\t// Surrogate pairs\n\t\t{`\\uD83D\\uDE02`, \"üòÇ\"},\n\t\t{`\\uD834\\uDD1E`, \"ùÑû\"},\n\n\t\t// Invalid escape sequences\n\t\t{`\\a`, `\\a`},\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\uD800`, `\\uD800`}, // Invalid surrogate pair\n\t\t{`\\uD800\\uDC00`, `\\uD800\\uDC00`}, // Invalid surrogate pair\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.input, func(t *testing.T) {\n\t\t\tactual := unescapeStringBestEffort(test.input)\n\t\t\tif actual != test.expected {\n\t\t\t\tt.Errorf(\"Expected: %q, Actual: %q\", test.expected, actual)\n\t\t\t}\n\t\t})\n\t}\n}","68808cd021a8ac028c0531f9704bfc29":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_getKV(t *testing.T) {\n\to := Object{}\n\t// Test adding a new kv when capacity is available\n\tkv1 := o.getKV()\n\tkv1.k = \"key1\"\n\tkv1.v = \u0026Value{t: TypeNumber, s: \"1\"}\n\n\twantKV1 := \u0026kv{k: \"key1\", v: \u0026Value{t: TypeNumber, s: \"1\"}}\n\tif kv1.k != wantKV1.k || kv1.v.s != wantKV1.v.s {\n\t\tt.Errorf(\"getKV() returned unexpected kv, got: %+v, want: %+v\", kv1, wantKV1)\n\t}\n\n\t// Test adding a new kv when capacity is not available\n\tkv2 := o.getKV()\n\tkv2.k = \"key2\"\n\tkv2.v = \u0026Value{t: TypeString, s: \"value2\"}\n\n\twantKV2 := \u0026kv{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}}\n\tif kv2.k != wantKV2.k || kv2.v.s != wantKV2.v.s {\n\t\tt.Errorf(\"getKV() returned unexpected kv, got: %+v, want: %+v\", kv2, wantKV2)\n\t}\n\n\t// Check if the length and capacity of kvs are as expected\n\tif len(o.kvs) != 2 {\n\t\tt.Errorf(\"Unexpected length of kvs, got: %d, want: %d\", len(o.kvs), 2)\n\t}\n}\n","68fecac4233379e0ee0add4e25802abc":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\twantS string\n\t\terr   error\n\t}{\n\t\t// Empty input.\n\t\t{\"\", nil, \"\", fmt.Errorf(`missing ']'`)},\n\n\t\t// Empty array.\n\t\t{\"]\", \u0026Value{t: TypeArray}, \"\", nil},\n\n\t\t// Simple array.\n\t\t{`[1, \"foo\", true]`, \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t{t: TypeString, s: \"foo\"},\n\t\t\t{t: TypeTrue},\n\t\t}}, \"\", nil},\n\n\t\t// Nested array.\n\t\t{`[[1, 2], [\"foo\", \"bar\"]]`, \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t}},\n\t\t\t{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeString, s: \"foo\"},\n\t\t\t\t{t: TypeString, s: \"bar\"},\n\t\t\t}},\n\t\t}}, \"\", nil},\n\n\t\t// Array with whitespace.\n\t\t{\" [ 1 , 2 ] \", \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t}}, \"\", nil},\n\n\t\t// Invalid array.\n\t\t{\"[1, 2\", nil, \"[1, 2\", fmt.Errorf(\"unexpected end of array\")},\n\n\t\t// Missing comma.\n\t\t{\"[1 2]\", nil, \" 2]\", fmt.Errorf(\"missing ',' after array value\")},\n\n\t\t// Invalid value.\n\t\t{\"[1, foo]\", nil, \", foo]\", fmt.Errorf(\"cannot parse array value: invalid character 'o' in literal true (expecting 'r')\")},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i+1), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, gotS, err := parseArray(tt.input, c, 0)\n\n\t\t\tif fmt.Sprint(err) != fmt.Sprint(tt.err) {\n\t\t\t\tt.Errorf(\"expected error %v, got %v\", tt.err, err)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"expected remaining string %q, got %q\", tt.wantS, gotS)\n\t\t\t}\n\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"test %d failed: input: %s, expected: %v, got: %v\", i+1, tt.input, tt.want, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// Helper function to compare two *Value.\nfunc equalValues(a, b *Value) bool {\n\tif a == nil \u0026\u0026 b == nil {\n\t\treturn true\n\t}\n\tif a == nil || b == nil {\n\t\treturn false\n\t}\n\tif a.t != b.t {\n\t\treturn false\n\t}\n\tswitch a.t {\n\tcase TypeArray:\n\t\tif len(a.a) != len(b.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range a.a {\n\t\t\tif !equalValues(a.a[i], b.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeObject:\n\t\t// Not implemented.\n\t\treturn false\n\tdefault:\n\t\treturn a.s == b.s\n\t}\n}\n","691a36d7ea06c6aa770c81bab56634b6":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc Test_unescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape\",\n\t\t\targs: args{s: \"hello\"},\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"simple escape\",\n\t\t\targs: args{s: \"hel\\\\\\\"lo\"},\n\t\t\twant: \"hel\\\"lo\",\n\t\t},\n\t\t{\n\t\t\tname: \"unicode escape\",\n\t\t\targs: args{s: \"hel\\\\u006co\"},\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid unicode escape\",\n\t\t\targs: args{s: \"hel\\\\u006\"},\n\t\t\twant: \"hel\\\\u006\",\n\t\t},\n\t\t{\n\t\t\tname: \"surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE02\"},\n\t\t\twant: \"üòÇ\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\u006\"},\n\t\t\twant: \"\\\\uD83D\\\\u006\",\n\t\t},\n\t\t{\n\t\t\tname: \"mixed escape\",\n\t\t\targs: args{s: \"h\\\\\\\\\\\\\\\"e\\\\u006c\\\\tlo\\\\n\"},\n\t\t\twant: \"h\\\\\\\"el\\tlo\\n\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","6978245fc46d5f25aaf2c8cac4473f73":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc Test_parseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\ts    string\n\t\twant string\n\t\ttail string\n\t\terr  error\n\t}{\n\t\t// Edge cases\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t\t{\"-\", \"\", \"-\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t\t{\"+\", \"\", \"+\", fmt.Errorf(\"unexpected char: %q\", \"+\")},\n\n\t\t// Valid numbers\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"+123\", \"+123\", \"\", nil},\n\t\t{\"123.456\", \"123.456\", \"\", nil},\n\t\t{\"1.2e3\", \"1.2e3\", \"\", nil},\n\t\t{\"1.2E-3\", \"1.2E-3\", \"\", nil},\n\n\t\t// Valid numbers with trailing characters\n\t\t{\"123a\", \"123\", \"a\", nil},\n\t\t{\"-123b\", \"-123\", \"b\", nil},\n\t\t{\"123.456c\", \"123.456\", \"c\", nil},\n\n\t\t// Invalid numbers\n\t\t{\"123.a\", \"\", \"123.a\", fmt.Errorf(\"unexpected char: %q\", \"123.a\")},\n\t\t{\"abc\", \"\", \"abc\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\n\t\t// Special cases: Inf, NaN\n\t\t{\"Inf\", \"Inf\", \"\", nil},\n\t\t{\"+Inf\", \"+Inf\", \"\", nil},\n\t\t{\"-Inf\", \"-Inf\", \"\", nil},\n\t\t{\"inF\", \"inF\", \"\", nil},\n\t\t{\"+inF\", \"+inF\", \"\", nil},\n\t\t{\"-inF\", \"-inF\", \"\", nil},\n\t\t{\"NaN\", \"NaN\", \"\", nil},\n\t\t{\"+NaN\", \"+NaN\", \"\", nil},\n\t\t{\"-NaN\", \"-NaN\", \"\", nil},\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"+nan\", \"+nan\", \"\", nil},\n\t\t{\"-nan\", \"-nan\", \"\", nil},\n\n\t\t// Special cases with trailing characters\n\t\t{\"Inf,\", \"Inf\", \",\", nil},\n\t\t{\"NaN}\", \"NaN\", \"}\", nil},\n\n\t\t// Special cases with invalid trailing characters\n\t\t{\"Infin\", \"\", \"Infin\", fmt.Errorf(\"unexpected char: %q\", \"Infin\")},\n\t\t{\"NaNa\", \"\", \"NaNa\", fmt.Errorf(\"unexpected char: %q\", \"NaNa\")},\n\t}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tgot, tail, err := parseRawNumber(tt.s)\n\t\t\tif got != tt.want || tail != tt.tail || (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = (%v, %v, %v), want (%v, %v, %v)\", tt.s, got, tail, err, tt.want, tt.tail, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}","69e14af1a1cf177e765068338ea97f04":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestValue_Bool(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tjson    string\n\t\twant    bool\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"true\",\n\t\t\tjson:    `true`,\n\t\t\twant:    true,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"false\",\n\t\t\tjson:    `false`,\n\t\t\twant:    false,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid\",\n\t\t\tjson:    `\"hello\"`,\n\t\t\twant:    false,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv := \u0026Value{}\n\n\t\t\tif err := v.Unmarshal([]byte(tt.json)); err != nil {\n\t\t\t\tt.Fatalf(\"Unmarshal() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t}\n\n\t\t\tgot, err := v.Bool()\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Bool() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Bool() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","6aca4cb03aca002182ddf53b78161961":"package fastjson\n\nimport \"testing\"\n\nfunc Test_hasSpecialChars(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    string\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\ts:    \"\",\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with no special characters\",\n\t\t\ts:    \"hello world\",\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with double quote\",\n\t\t\ts:    \"hello\\\"world\",\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with backslash\",\n\t\t\ts:    \"hello\\\\world\",\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with control character\",\n\t\t\ts:    \"hello\\nworld\",\n\t\t\twant: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := hasSpecialChars(tt.s); got != tt.want {\n\t\t\t\tt.Errorf(\"hasSpecialChars() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","6b4af14a43e831b21c655ba7bacce0d5":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"raw string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"raw string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"1234\",\n\t\t\t},\n\t\t\twant: []byte(\"1234\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"string\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1234\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"[\\\"string\\\",1234]\"),\n\t\t},\n\t\t// Add more test cases for other types and nested objects/arrays\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif string(got) != string(tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", string(got), string(tt.want))\n\t\t\t}\n\t\t})\n\t}\n}\n","6b82b35fcceba03b7e2a861d1ca8a1bc":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Empty string\n\t\t{\"\", nil, \"\", fmt.Errorf(\"cannot parse empty string\")},\n\t\t// Invalid JSON\n\t\t{\"abc\", nil, \"abc\", fmt.Errorf(\"cannot parse object: cannot parse key: unexpected EOF\")},\n\t\t// Simple object\n\t\t{`{\"foo\":\"bar\"}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: typeRawString, s: \"bar\"}}}}}, \"\", nil},\n\t\t// Nested object\n\t\t{`{\"foo\":{\"bar\":\"baz\"}}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"bar\", v: \u0026Value{t: typeRawString, s: \"baz\"}}}}}}}}}, \"\", nil},\n\t\t// Simple array\n\t\t{`[\"foo\",\"bar\"]`, \u0026Value{t: TypeArray, a: []*Value{{t: typeRawString, s: \"foo\"}, {t: typeRawString, s: \"bar\"}}}, \"\", nil},\n\t\t// Nested array\n\t\t{`[\"foo\",[\"bar\",\"baz\"]]`, \u0026Value{t: TypeArray, a: []*Value{{t: typeRawString, s: \"foo\"}, {t: TypeArray, a: []*Value{{t: typeRawString, s: \"bar\"}, {t: typeRawString, s: \"baz\"}}}}}, \"\", nil},\n\t\t// String\n\t\t{`\"foo\"`, \u0026Value{t: typeRawString, s: \"foo\"}, \"\", nil},\n\t\t// True\n\t\t{\"true\", valueTrue, \"\", nil},\n\t\t// False\n\t\t{\"false\", valueFalse, \"\", nil},\n\t\t// Null\n\t\t{\"null\", valueNull, \"\", nil},\n\t\t// Number\n\t\t{\"123\", \u0026Value{t: TypeNumber, s: \"123\"}, \"\", nil},\n\t\t// NaN\n\t\t{\"NaN\", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"\", nil},\n\t\t// Trailing whitespace\n\t\t{`\"foo\" `, \u0026Value{t: typeRawString, s: \"foo\"}, \" \", nil},\n\t}\n\n\tc := \u0026cache{}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tgot, tail, err := parseValue(tt.input, c, 0)\n\t\t\tif fmt.Sprintf(\"%v\", err) != fmt.Sprintf(\"%v\", tt.err) {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, wantErr %v\", tt.input, err, tt.err)\n\t\t\t}\n\t\t\tif got != nil \u0026\u0026 got.String() != tt.want.String() {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", tt.input, got, tt.want)\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"parseValue(%q) tail = %q, want %q\", tt.input, tail, tt.tail)\n\t\t\t}\n\t\t})\n\t}\n}","6d3a5822e00fab03ff2f1d46789bc3de":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput  string\n\t\texpect string\n\t\ttail   string\n\t\terr    error\n\t}{\n\t\t// Basic cases.\n\t\t{`\"foo\"bar`, \"foo\", \"bar\", nil},\n\t\t{`\"foo\" bar`, \"foo\", \" bar\", nil},\n\t\t{`\"foo\"`, \"foo\", \"\", nil},\n\n\t\t// Escaped quotes.\n\t\t{`\"\\\\\"foo`, \"\\\\\", \"foo\", nil},\n\t\t{`\"\\\\\\\"\"foo`, \"\\\\\\\"\", \"foo\", nil},\n\t\t{`\"\\\\\\\"foo\"`, \"\\\\\\\"foo\", \"\", nil},\n\n\t\t// Missing closing quote.\n\t\t{`\"foo`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"fo\\o`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\n\t\t// Empty strings.\n\t\t{`\"\"foo`, \"\", \"foo\", nil},\n\t\t{`\"\"`, \"\", \"\", nil},\n\t}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tresult, tail, err := parseRawString(tt.input)\n\t\t\tif result != tt.expect {\n\t\t\t\tt.Errorf(\"expected result %q, got %q\", tt.expect, result)\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"expected tail %q, got %q\", tt.tail, tail)\n\t\t\t}\n\t\t\tif (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err == nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"expected error %v, got %v\", tt.err, err)\n\t\t\t}\n\t\t})\n\t}\n}","6d42cc491bb7931af5168fb29d450757":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantNum  string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Valid numbers\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"12.34\", \"12.34\", \"\", nil},\n\t\t{\"1.23e+5\", \"1.23e+5\", \"\", nil},\n\t\t{\"1.23e-5\", \"1.23e-5\", \"\", nil},\n\t\t{\"+1.23\", \"+1.23\", \"\", nil},\n\n\t\t// Valid numbers with trailing characters\n\t\t{\"123abc\", \"123\", \"abc\", nil},\n\t\t{\"-123 def\", \"-123\", \" def\", nil},\n\t\t{\"12.34\\t\", \"12.34\", \"\\t\", nil},\n\n\t\t// Invalid numbers\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t\t{\"+\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"+\")},\n\t\t{\"-\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t\t{\"a123\", \"\", \"a123\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\n\t\t// Special cases: inf, nan\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"+inf\", \"+inf\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"InF\", \"InF\", \"\", nil},  // case insensitive\n\t\t{\"inF123\", \"inF\", \"123\", nil},\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"+nan\", \"+nan\", \"\", nil},\n\t\t{\"-nan\", \"-nan\", \"\", nil},\n\t\t{\"naN\", \"naN\", \"\", nil},  // case insensitive\n\t\t{\"NAN123\", \"NAN\", \"123\", nil},\n\t\t{\"+in\", \"\", \"+in\", fmt.Errorf(\"unexpected char: %q\", \"+\")},  // incomplete inf/nan\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d:%s\", i, tt.input), func(t *testing.T) {\n\t\t\tgotNum, gotTail, gotErr := parseRawNumber(tt.input)\n\n\t\t\tif gotNum != tt.wantNum {\n\t\t\t\tt.Errorf(\"input %q: got number %q, want %q\", tt.input, gotNum, tt.wantNum)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"input %q: got tail %q, want %q\", tt.input, gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif (gotErr != nil \u0026\u0026 tt.wantErr == nil) ||\n\t\t\t\t(gotErr == nil \u0026\u0026 tt.wantErr != nil) ||\n\t\t\t\t(gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error()) {\n\t\t\t\tt.Errorf(\"input %q: got error %v, want %v\", tt.input, gotErr, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","6d5a8b1708e96dcfd891f4e6f778b2eb":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantN    string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Valid numbers\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"123.456\", \"123.456\", \"\", nil},\n\t\t{\"1.2e3\", \"1.2e3\", \"\", nil},\n\t\t{\"1.2E-3\", \"1.2E-3\", \"\", nil},\n\t\t{\"+123\", \"+123\", \"\", nil},\n\n\t\t// Valid numbers with trailing characters\n\t\t{\"123a\", \"123\", \"a\", nil},\n\t\t{\"-123 \", \"-123\", \" \", nil},\n\t\t{\"123.456,\", \"123.456\", \",\", nil},\n\n\t\t// Invalid numbers\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t\t{\"a123\", \"\", \"a123\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\"+a123\", \"\", \"+a123\", fmt.Errorf(\"unexpected char: %q\", \"+a\")},\n\t\t{\"-\", \"-\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t\t{\"+\", \"+\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t\t{\"+abc\", \"\", \"+abc\", fmt.Errorf(\"unexpected char: %q\", \"+a\")},\n\t\t{\"-abc\", \"\", \"-abc\", fmt.Errorf(\"unexpected char: %q\", \"-a\")},\n\t\t{\"-INF\", \"\", \"-INF\", fmt.Errorf(\"unexpected char: %q\", \"-I\")},\n\t\t{\"+inf\", \"\", \"+inf\", fmt.Errorf(\"unexpected char: %q\", \"+i\")},\n\n\t\t// Valid INF/NaN cases\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"+Inf\", \"+Inf\", \"\", nil},\n\t\t{\"-infinity\", \"-infinity\", \"\", nil},\n\t\t{\"NaN\", \"NaN\", \"\", nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d:%s\", i, tt.input), func(t *testing.T) {\n\t\t\tgotN, gotTail, gotErr := parseRawNumber(tt.input)\n\t\t\tif gotN != tt.wantN {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got number = %q, want %q\", tt.input, gotN, tt.wantN)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got tail = %q, want %q\", tt.input, gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif gotErr == nil \u0026\u0026 tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got no error, want %v\", tt.input, tt.wantErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr == nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got error = %v, want no error\", tt.input, gotErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got error = %v, want %v\", tt.input, gotErr, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","6da65682ce259312ae9b4cdb1e73416a":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantN    string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Basic cases\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"123.45\", \"123.45\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"+123\", \"+123\", \"\", nil},\n\t\t{\"1.2e3\", \"1.2e3\", \"\", nil},\n\t\t{\"1.2E-3\", \"1.2E-3\", \"\", nil},\n\n\t\t// Trailing characters\n\t\t{\"123abc\", \"123\", \"abc\", nil},\n\t\t{\"123.45xyz\", \"123.45\", \"xyz\", nil},\n\n\t\t// Invalid numbers\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t\t{\"+\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"+\")},\n\t\t(\".123\", \"\", \".123\", fmt.Errorf(\"unexpected char: %q\", \".\")},\n\t\t{\"123..45\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \".\")},\n\n\t\t// Special cases: \"inf\", \"nan\"\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"+inf\", \"+inf\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"in\", \"\", \"in\", fmt.Errorf(\"unexpected char: %q\", \"i\")},\n\t\t{\"na\", \"\", \"na\", fmt.Errorf(\"unexpected char: %q\", \"n\")},\n\t\t{\"123inf\", \"123\", \"inf\", nil},\n\t\t{\"123nan\", \"123\", \"nan\", nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d:%s\", i, tt.input), func(t *testing.T) {\n\t\t\tgotN, gotTail, gotErr := parseRawNumber(tt.input)\n\t\t\tif gotN != tt.wantN || gotTail != tt.wantTail || (gotErr != nil \u0026\u0026 tt.wantErr == nil) || (gotErr == nil \u0026\u0026 tt.wantErr != nil) || (gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error()) {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = (%q, %q, %v), want (%q, %q, %v)\", tt.input, gotN, gotTail, gotErr, tt.wantN, tt.wantTail, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","6db00f06325b618d849dc56822ae75ec":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Empty string.\n\t\t{\"\", nil, \"\", fmt.Errorf(\"cannot parse empty string\")},\n\n\t\t// Object.\n\t\t{`{\"foo\":\"bar\"}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: typeRawString, s: \"bar\"}}}}}, \"\", nil},\n\n\t\t// Array.\n\t\t{\"[1,2,3]\", \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}}, \"\", nil},\n\n\t\t// String.\n\t\t{`\"hello\"`, \u0026Value{t: typeRawString, s: \"hello\"}, \"\", nil},\n\n\t\t// True.\n\t\t{\"true\", valueTrue, \"\", nil},\n\n\t\t// False.\n\t\t{\"false\", valueFalse, \"\", nil},\n\n\t\t// Null.\n\t\t{\"null\", valueNull, \"\", nil},\n\n\t\t// NaN.\n\t\t{\"NaN\", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"\", nil},\n\n\t\t// Number.\n\t\t{\"123\", \u0026Value{t: TypeNumber, s: \"123\"}, \"\", nil},\n\n\t\t// Trailing whitespace.\n\t\t{\"123 \", \u0026Value{t: TypeNumber, s: \"123\"}, \" \", nil},\n\n\t\t// Invalid JSON.\n\t\t{\"{\", nil, \"{\", fmt.Errorf(\"cannot parse object: missing '}'\")},\n\n\t\t// Too deep nesting.\n\t\t{`{\"a\":{\"b\":{\"c\":{\"d\":{\"e\":{\"f\":{\"g\":{\"h\":{\"i\":{\"j\":{\"k\":{\"l\":{\"m\":{\"n\":{\"o\":{\"p\":{\"q\":{\"r\":{\"s\":{\"t\":{\"u\":{\"v\":{\"w\":{\"x\":{\"y\":{\"z\":{}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}`,\n\t\t\tnil, `{\"a\":{\"b\":{\"c\":{\"d\":{\"e\":{\"f\":{\"g\":{\"h\":{\"i\":{\"j\":{\"k\":{\"l\":{\"m\":{\"n\":{\"o\":{\"p\":{\"q\":{\"r\":{\"s\":{\"t\":{\"u\":{\"v\":{\"w\":{\"x\":{\"y\":{\"z\":{}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}`,\n\t\t\tfmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t},\n\t}\n\n\tc := \u0026cache{}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test #%d\", i+1), func(t *testing.T) {\n\t\t\tgot, tail, err := parseValue(tt.input, c, 0)\n\n\t\t\tif got == nil \u0026\u0026 tt.want == nil {\n\t\t\t\t// Both are nil, no need to check further.\n\t\t\t} else if got == nil || tt.want == nil {\n\t\t\t\tt.Errorf(\"test %d failed: got nil != want nil\", i+1)\n\t\t\t} else if got.t != tt.want.t {\n\t\t\t\tt.Errorf(\"test %d failed: got %v, want %v\", i+1, got, tt.want)\n\t\t\t} else if got.s != tt.want.s {\n\t\t\t\tt.Errorf(\"test %d failed: got %v, want %v\", i+1, got, tt.want)\n\t\t\t}\n\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"test %d failed: got tail %q, want %q\", i+1, tail, tt.tail)\n\t\t\t}\n\n\t\t\tif (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err == nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"test %d failed: got error %v, want %v\", i+1, err, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}\n","6df0d4e5d8c2ff606085628a104b67b6":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput  string\n\t\tns     string\n\t\ttail   string\n\t\thasErr bool\n\t}{\n\t\t{\"123\", \"123\", \"\", false},\n\t\t{\"123.456\", \"123.456\", \"\", false},\n\t\t{\"-123\", \"-123\", \"\", false},\n\t\t{\"+123\", \"+123\", \"\", false},\n\t\t{\"1.23e+10\", \"1.23e+10\", \"\", false},\n\t\t{\"1.23e-10\", \"1.23e-10\", \"\", false},\n\t\t{\"123a\", \"123\", \"a\", false},\n\t\t{\"123.456a\", \"123.456\", \"a\", false},\n\t\t{\"-123a\", \"-123\", \"a\", false},\n\t\t{\"+123a\", \"+123\", \"a\", false},\n\t\t{\"1.23e+10a\", \"1.23e+10\", \"a\", false},\n\t\t{\"1.23e-10a\", \"1.23e-10\", \"a\", false},\n\t\t{\"inf\", \"inf\", \"\", false},\n\t\t{\"+inf\", \"+inf\", \"\", false},\n\t\t{\"-inf\", \"-inf\", \"\", false},\n\t\t{\"in\", \"\", \"in\", true},\n\t\t{\"+i\", \"\", \"+i\", true},\n\t\t{\"-i\", \"\", \"-i\", true},\n\t\t{\"nan\", \"nan\", \"\", false},\n\t\t{\"+nan\", \"\", \"+nan\", true},\n\t\t{\"-nan\", \"\", \"-nan\", true},\n\t\t{\"na\", \"\", \"na\", true},\n\t\t{\"+n\", \"\", \"+n\", true},\n\t\t{\"-n\", \"\", \"-n\", true},\n\t}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tns, tail, err := parseRawNumber(tt.input)\n\t\t\tif (err != nil) != tt.hasErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tt.input, err, tt.hasErr)\n\t\t\t}\n\t\t\tif ns != tt.ns {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) ns = %q, want %q\", tt.input, ns, tt.ns)\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) tail = %q, want %q\", tt.input, tail, tt.tail)\n\t\t\t}\n\t\t})\n\t}\n}","6e33d0d62a23a8721caad8b3e9af809d":"package fastjson\n\nimport \"testing\"\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"  foo\", \"foo\"},\n\t\t{\"\\n\\rbar\", \"bar\"},\n\t\t{\" \\t  baz\", \"baz\"},\n\t\t{\"qux\", \"qux\"},\n\t\t{\"\", \"\"},\n\t\t{\"\\n\\t \", \"\"},\n\t}\n\tfor _, test := range tests {\n\t\tactual := skipWSSlow(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"skipWSSlow(%q) = %q, want %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}","6e8502e4888bb33c5d31d62ffdb69b41":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic cases\n\t\t{`\"\"`, `\"\"`},\n\t\t{`\"hello\"`, `hello`},\n\t\t{`\"hel\\tlo\"`, `hel\tlo`},\n\t\t{`\"hel\\nlo\"`, `hel\nlo`},\n\t\t{`\"hel\\\\lo\"`, `hel\\lo`},\n\t\t{`\"hel\\/lo\"`, `hel/lo`},\n\n\t\t// Unicode sequences\n\t\t{`\"\\u0020\"`, \" \"},\n\t\t{`\"\\u00A0\"`, \"\\u00A0\"},\n\t\t{`\"\\u20AC\"`, \"‚Ç¨\"},\n\t\t{`\"a\\u20ACb\"`, \"a‚Ç¨b\"},\n\n\t\t// Surrogate pairs\n\t\t{`\"\\uD83D\\uDE01\"`, \"\\U0001F601\"},\n\n\t\t// Invalid sequences\n\t\t{`\"\\uD800\"`, \"\\uD800\"},              // Lone surrogate\n\t\t{`\"\\uD800\\u0020\"`, \"\\uD800 \"},       // Lone surrogate followed by valid code point\n\t\t{`\"\\u0020\\uD800\"`, \" \\uD800\"},       // Valid code point followed by lone surrogate\n\t\t{`\"\\uD800\\uD800\"`, \"\\uD800\\uD800\"}, // Two lone surrogates\n\t\t{`\"\\u0020\\uD800\\u0020\"`, \" \\uD800 \"}, // Lone surrogate surrounded by valid code points\n\t\t{`\"\\u\"`, `\\u`},                 // Incomplete escape sequence\n\t\t{`\"\\u123\"`, `\\u123`},             // Incomplete escape sequence\n\t\t{`\"\\u123g\"`, `\\u123g`},           // Incomplete escape sequence followed by another character\n\t\t{`\"\\x\"`, `\\x`},                 // Invalid escape character\n\n\t\t// Other edge cases\n\t\t{`\"\\\\\"`, `\\`},\n\t\t{`\"\\\\\\\"\"`, `\\\"`},\n\t\t{`\"\\\\t\"`, `\\t`},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}\n","6f19aa110e6aa422ecee615bd3adb1ca":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic strings without escape sequences.\n\t\t{\"hello\", \"hello\"},\n\t\t{\"world\", \"world\"},\n\t\t{\"12345\", \"12345\"},\n\n\t\t// Strings with standard escape sequences.\n\t\t{`\"hello\\\\world\"`, \"\\\"hello\\\\world\\\"\"},\n\t\t{`\\t\\r\\n`, \"\\t\\r\\n\"},\n\t\t{`\\b\\f`, \"\\b\\f\"},\n\n\t\t// Unicode escape sequences.\n\t\t{`\\u0041\\u0062\\u0063`, \"ABC\"},\n\t\t{`{\"key\": \"\\u041f\\u0440\\u0438\\u0432\\u0435\\u0442\"}`, `{\"key\": \"–ü—Ä–∏–≤–µ—Ç\"}`},\n\n\t\t// Invalid escape sequences.\n\t\t{`\\u004x`, `\\u004x`},\n\t\t{`\\u123`, `\\u123`},\n\n\t\t// Mixed valid and invalid escape sequences.\n\t\t{`hello\\u0020world\\x00`, \"hello world\\x00\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) returned %q, expected %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}\n","6f44ad38d1750d682e4dc5ccc8c22331":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantObj  string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t{\n\t\t\tname:     \"empty object\",\n\t\t\tinput:    \"{}\",\n\t\t\twantObj:  `{\"t\":1}`,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t// Add more test cases here\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, tail, err := parseObject(tt.input, c, 0)\n\t\t\tif fmt.Sprintf(\"%v\", err) != fmt.Sprintf(\"%v\", tt.wantErr) {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got == nil {\n\t\t\t\tif tt.wantObj != \"\" {\n\t\t\t\t\tt.Errorf(\"parseObject() got = nil, want not nil\")\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif tt.wantObj == \"\" {\n\t\t\t\t\tt.Errorf(\"parseObject() got = not nil, want nil\")\n\t\t\t\t} else if fmt.Sprintf(\"%v\", got) != tt.wantObj {\n\t\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.wantObj)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif tail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseObject() gotTail = %v, want %v\", tail, tt.wantTail)\n\t\t\t}\n\t\t})\n\t}\n}","6f51b309595c1399dbabe55956e4e70a":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantStr  string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Basic cases\n\t\t{`\"foo\"bar`, `foo`, `bar`, nil},\n\t\t{`\"fo\\\"o\"bar`, `fo\\\"o`, `bar`, nil},\n\t\t{`\"foo\"`, `foo`, ``, nil},\n\t\t{`\"\"bar`, ``, `bar`, nil},\n\n\t\t// Escaped quotes\n\t\t{`\"foo\\\\\"bar\"baz`, `foo\\\\\"bar`, `baz`, nil},\n\t\t{`\"foo\\\\\\\\\"bar\"baz`, `foo\\\\\\\\`, `bar\"baz`, nil},\n\n\t\t// Missing closing quote\n\t\t{`\"foobar`, ``, ``, fmt.Errorf(`missing closing '\"'`)}\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i+1), func(t *testing.T) {\n\t\t\tgotStr, gotTail, gotErr := parseRawString(tt.input)\n\t\t\tif gotStr != tt.wantStr {\n\t\t\t\tt.Errorf(\"parseRawString(%q) gotStr = %q, want %q\", tt.input, gotStr, tt.wantStr)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseRawString(%q) gotTail = %q, want %q\", tt.input, gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif gotErr != nil \u0026\u0026 tt.wantErr == nil || gotErr == nil \u0026\u0026 tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"parseRawString(%q) gotErr = %v, want %v\", tt.input, gotErr, tt.wantErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"parseRawString(%q) gotErr = %v, want %v\", tt.input, gotErr, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","6fab218b3923aaaeb15f025f2a5a7e40":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\tvar tests = []struct {\n\t\tin   string\n\t\twant string\n\t\ttail string\n\t\terr  error\n\t}{\n\t\t// Unescaped strings.\n\t\t{`\"foo\"bar`, `foo`, `bar`, nil},\n\t\t{`\"foo\"`, `foo`, ``, nil},\n\n\t\t// Escaped strings\n\t\t{`\"fo\\\\o\"bar`, `fo\\o`, `bar`, nil},\n\t\t{`\"fo\\\"o\"bar`, `fo\"o`, `bar`, nil},\n\t\t{`\"fo\\to\"bar`, \"fo\\to\", `bar`, nil},\n\t\t{`\"fo\\no\"bar`, \"fo\\no\", `bar`, nil},\n\t\t{`\"fo\\ro\"bar`, \"fo\\ro\", `bar`, nil},\n\t\t{`\"fo\\bo\"bar`, \"fo\\bo\", `bar`, nil},\n\t\t{`\"fo\\fo\"bar`, \"fo\\fo\", `bar`, nil},\n\n\t\t// Invalid strings.\n\t\t{`\"foo`, ``, ``, fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"fo\\o`, ``, ``, fmt.Errorf(`missing closing '\"'`)},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tgot, tail, err := parseRawString(tt.in)\n\t\t\tif got != tt.want || tail != tt.tail || !equalError(err, tt.err) {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = %q, %q, %v, want %q, %q, %v\", tt.in, got, tail, err, tt.want, tt.tail, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// equalError reports whether errors a and b are considered equal.\n// They're equal if both are nil, or both are not nil and a.Error() == b.Error().\nfunc equalError(a, b error) bool {\n\treturn a == nil \u0026\u0026 b == nil || a != nil \u0026\u0026 b != nil \u0026\u0026 a.Error() == b.Error()\n}\n","6fd24ebeaee11084b0c385bb63aecac6":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twant     *Value\n\t\twantRest string\n\t\twantErr  error\n\t}{\n\t\t{\n\t\t\tname:     \"empty array\",\n\t\t\tinput:    \"[]\",\n\t\t\twant:     \u0026Value{t: TypeArray},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"single element array\",\n\t\t\tinput:    \"[1]\",\n\t\t\twant:     \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"multi-element array\",\n\t\t\tinput:    \"[1,2,3]\",\n\t\t\twant:     \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with whitespace\",\n\t\t\tinput:    \" [ 1 , 2 , 3 ] \",\n\t\t\twant:     \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}},\n\t\t\twantRest: \" \",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"nested array\",\n\t\t\tinput:    \"[[1,2],[3,4]]\",\n\t\t\twant: \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}}},\n\t\t\t\t{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"3\"}, {t: TypeNumber, s: \"4\"}}},\n\t\t\t}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid array: missing closing bracket\",\n\t\t\tinput:    \"[1,2,3\",\n\t\t\twant:     nil,\n\t\t\twantRest: \"1,2,3\",\n\t\t\twantErr:  fmt.Errorf(\"missing ']'\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid array: missing comma\",\n\t\t\tinput:    \"[1 2 3]\",\n\t\t\twant:     nil,\n\t\t\twantRest: \" 2 3]\",\n\t\t\twantErr:  fmt.Errorf(\"missing ',' after array value\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, rest, err := parseArray(tt.input, c, 0)\n\t\t\tif (err != nil \u0026\u0026 tt.wantErr == nil) || (err == nil \u0026\u0026 tt.wantErr != nil) || (err != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 err.Error() != tt.wantErr.Error()) {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif tt.want != nil \u0026\u0026 got != nil \u0026\u0026 !got.equal(tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif rest != tt.wantRest {\n\t\t\t\tt.Errorf(\"parseArray() rest = %v, wantRest %v\", rest, tt.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}","7058efd0c56b597cc2d9223ff1700ad9":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_Visit(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tjson string\n\t\twant map[string]string\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\tjson: `{}`,\n\t\t\twant: map[string]string{},\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\tjson: `{\"a\": \"b\", \"c\": \"d\"}`,\n\t\t\twant: map[string]string{\"a\": \"b\", \"c\": \"d\"},\n\t\t},\n\t\t{\n\t\t\tname: \"nested object\",\n\t\t\tjson: `{\"a\": {\"b\": \"c\"}, \"d\": \"e\"}`,\n\t\t\twant: map[string]string{\"a\": `{\"b\": \"c\"}`, \"d\": \"e\"},\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tjson: `{\"a\": [\"b\", \"c\"], \"d\": \"e\"}`,\n\t\t\twant: map[string]string{\"a\": `[\"b\", \"c\"]`, \"d\": \"e\"},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv, err := Parse(tt.json)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Parse() error = %v, wantErr %v\", err, nil)\n\t\t\t\treturn\n\t\t\t}\n\t\t\to, err := v.Object()\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Object() error = %v, wantErr %v\", err, nil)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgot := make(map[string]string)\n\t\t\to.Visit(func(key []byte, v *Value) {\n\t\t\t\tgot[string(key)] = v.String()\n\t\t\t})\n\t\t\tif len(got) != len(tt.want) {\n\t\t\t\tt.Errorf(\"Visit() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tfor k, v := range tt.want {\n\t\t\t\tif got[k] != v {\n\t\t\t\t\tt.Errorf(\"Visit() got[%s] = %v, want %v\", k, got[k], v)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","706865992798e2e97cf456a24af456c3":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\tvar tests = []struct {\n\t\tin  string\n\t\tout string\n\t}{\n\t\t// Basic strings.\n\t\t{\"\", \"\"},\n\t\t{\"foo\", \"foo\"},\n\t\t{\"foo bar\", \"foo bar\"},\n\n\t\t// Escaped characters.\n\t\t{`\\\"`, `\"`},\n\t\t{`\\\\`, `\\`},\n\t\t{`\\/`, `/`},\n\t\t{`\\b`, \"\\b\"},\n\t\t{`\\f`, \"\\f\"},\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\r`, \"\\r\"},\n\t\t{`\\t`, \"\\t\"},\n\n\t\t// Unicode escape sequences.\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A0`, \"\\u00A0\"},\n\t\t{`\\uFFFF`, \"\\uFFFF\"},\n\t\t{`\\uD83D\\uDE02`, \"\\U0001F602\"},\n\n\t\t// Invalid escape sequences.\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u`, `\\u`},\n\t\t{`\\u002`, `\\u002`},\n\t\t{`\\uD83D`, `\\uD83D`},\n\t\t{`\\uD83D\\u`, `\\uD83D\\u`},\n\t\t{`\\uD83D\\u123`, `\\uD83D\\u123`},\n\t}\n\n\tfor i, tt := range tests {\n\t\tout := unescapeStringBestEffort(tt.in)\n\t\tif out != tt.out {\n\t\t\tt.Errorf(\"#%d: unescapeStringBestEffort(%q) = %q, want %q\", i, tt.in, out, tt.out)\n\t\t}\n\t}\n}","706e5a0147669f36804cbc0a3f095f5e":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic strings\n\t\t{\"hello\", \"hello\"},\n\t\t{\"world\", \"world\"},\n\n\t\t// Escaped characters\n\t\t{`\\\"hello\\\"`, `\"hello\"`},\n\t\t{`\\\\hello\\\\`, `\\hello\\`},\n\t\t{`\\/hello\\/`, `/hello/`},\n\t\t{`\\bhello\\b`, `\\bhello\\b`},\n\t\t{`\\fhello\\f`, \"\\fhello\\f\"},\n\t\t{`\\nhello\\n`, \"\\nhello\\n\"},\n\t\t{`\\rhello\\r`, \"\\rhello\\r\"},\n\t\t{`\\thello\\t`, \"\\thello\\t\"},\n\n\t\t// Unicode escape sequences\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A0`, \"\\u00A0\"},\n\t\t{`\\u20AC`, \"‚Ç¨\"},\n\t\t{`\\uD83D\\uDE01`, \"üòÅ\"},\n\n\t\t// Invalid escape sequences\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\uD800`, `\\uD800`},\n\t\t{`\\uD800\\u`, `\\uD800\\u`},\n\t\t{`\\uD800\\uD800`, `\\uD800\\uD800`},\n\n\t\t// Mixed strings\n\t\t{`hello\\tworld`, \"hello\\tworld\"},\n\t\t{`\"hello world\"`, `\"hello world\"`},\n\t\t{`\\u0041\\u0020\\u0042`, \"A B\"},\n\t\t{`C:\\\\Users\\\\John`, `C:\\Users\\John`},\n\t}\n\n\tfor i, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Test %d: Expected '%s', got '%s'\", i+1, test.expected, actual)\n\t\t}\n\t}\n}","70a38a44496c23ee87fb465becf29b01":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant: []byte(\"123\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"hello\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"[\\\"hello\\\",123]\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif string(got) != string(tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", string(got), string(tt.want))\n\t\t\t}\n\t\t})\n\t}\n}","71635dd415056a10080843df1cfc642f":"package fastjson\n\nimport \"testing\"\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    string\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\ts:    \"\",\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with leading whitespace\",\n\t\t\ts:    \"  foo\",\n\t\t\twant: \"foo\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with no leading whitespace\",\n\t\t\ts:    \"bar\",\n\t\t\twant: \"bar\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with all whitespace\",\n\t\t\ts:    \" \\t\\n\\r\",\n\t\t\twant: \"\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %q, want %q\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","7230092514433d8801df7477caa09618":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantKey  string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Simple keys\n\t\t{\"\\\"key\\\"\", \"key\", \"\", nil},\n\t\t{\"\\\"key\\\":123\", \"key\", \":123\", nil},\n\n\t\t// Empty key\n\t\t{\"\\\"\\\"\", \"\", \"\", nil},\n\n\t\t// Key with escaped characters\n\t\t// These should fall back to the slow path and be handled correctly.\n\t\t{\"\\\"key\\\\\\\"with\\\\tescapes\\\"\", \"key\\\\\\\"with\\\\tescapes\", \"\", nil},\n\n\t\t// Invalid input\n\t\t{\"key\\\"\", \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{\"\\\"key\", \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d_%s\", i, tt.input), func(t *testing.T) {\n\t\t\tgotKey, gotTail, gotErr := parseRawKey(tt.input)\n\n\t\t\tif gotKey != tt.wantKey {\n\t\t\t\tt.Errorf(\"Key mismatch. Want: %q, Got: %q\", tt.wantKey, gotKey)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"Tail mismatch. Want: %q, Got: %q\", tt.wantTail, gotTail)\n\t\t\t}\n\t\t\tif (gotErr != nil \u0026\u0026 tt.wantErr == nil) ||\n\t\t\t\t(gotErr == nil \u0026\u0026 tt.wantErr != nil) ||\n\t\t\t\t(gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error()) {\n\t\t\t\tt.Errorf(\"Error mismatch. Want: %v, Got: %v\", tt.wantErr, gotErr)\n\t\t\t}\n\t\t})\n\t}\n}\n","724994c4227fea1f6874c6180fbf74e8":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ts     string\n\t\terr   error\n\t}{\n\t\t// Add your test cases here\n\t\t{\n\t\t\tinput: `{\"key\": \"value\"}`,\n\t\t\twant: \u0026Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: \u0026Value{t: TypeString, s: \"value\"}},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: true,\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tinput: `{\"key\": \"value\", \"key2\": 123}`,\n\t\t\twant: \u0026Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: \u0026Value{t: TypeString, s: \"value\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: true,\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Add more test cases for different scenarios\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseObject(tt.input, c, 0)\n\n\t\t\tif err != nil {\n\t\t\t\tif tt.err == nil {\n\t\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t\t} else if err.Error() != tt.err.Error() {\n\t\t\t\t\tt.Errorf(\"expected error %v, got %v\", tt.err, err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif s != tt.s {\n\t\t\t\tt.Errorf(\"expected remaining string %q, got %q\", tt.s, s)\n\t\t\t}\n\n\t\t\tif got == nil \u0026\u0026 tt.want == nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got == nil || tt.want == nil {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.want, got)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got.t != tt.want.t {\n\t\t\t\tt.Errorf(\"expected type %v, got %v\", tt.want.t, got.t)\n\t\t\t}\n\t\t\tif got.o.keysUnescaped != tt.want.o.keysUnescaped {\n\t\t\t\tt.Errorf(\"expected keysUnescaped %v, got %v\", tt.want.o.keysUnescaped, got.o.keysUnescaped)\n\t\t\t}\n\t\t\tif len(got.o.kvs) != len(tt.want.o.kvs) {\n\t\t\t\tt.Errorf(\"expected %d kvs, got %d\", len(tt.want.o.kvs), len(got.o.kvs))\n\t\t\t\treturn\n\t\t\t}\n\t\t\tfor j := range got.o.kvs {\n\t\t\t\tif got.o.kvs[j].k != tt.want.o.kvs[j].k {\n\t\t\t\t\tt.Errorf(\"expected key %q, got %q\", tt.want.o.kvs[j].k, got.o.kvs[j].k)\n\t\t\t\t}\n\t\t\t\tif got.o.kvs[j].v.t != tt.want.o.kvs[j].v.t {\n\t\t\t\t\tt.Errorf(\"expected value type %v, got %v\", tt.want.o.kvs[j].v.t, got.o.kvs[j].v.t)\n\t\t\t\t}\n\t\t\t\tif got.o.kvs[j].v.s != tt.want.o.kvs[j].v.s {\n\t\t\t\t\tt.Errorf(\"expected value %q, got %q\", tt.want.o.kvs[j].v.s, got.o.kvs[j].v.s)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n","728d133d01cc468ecfd0317cc4c69179":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\ts       string\n\t\twant    *Value\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tp := \u0026Parser{}\n\t\t\tgot, err := p.Parse(tt.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Parser.Parse() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Parser.Parse() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","73637f7e1e8efbc7668ced1b35bb1c13":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"raw string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"raw string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"1234\",\n\t\t\t},\n\t\t\twant: []byte(\"1234\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"string\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1234\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"[\\\"string\\\",1234]\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif string(got) != string(tt.want) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %v, want %v\", string(got), string(tt.want))\n\t\t\t}\n\t\t})\n\t}\n}","73e81573c1097aa5d3bc8873077efe2d":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic strings without escape sequences.\n\t\t{\"hello\", \"hello\"},\n\t\t{\"world\", \"world\"},\n\t\t{\"12345\", \"12345\"},\n\n\t\t// Simple escape sequences.\n\t\t{`\\\"`, `\"`},\n\t\t{`\\\\`, `\\`},\n\t\t{`\\/`, `/`},\n\t\t{`\\b`, \"\\b\"},\n\t\t{`\\f`, \"\\f\"},\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\r`, \"\\r\"},\n\t\t{`\\t`, \"\\t\"},\n\n\t\t// Unicode escape sequences.\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A9`, \"¬©\"},\n\t\t{`\\u20AC`, \"‚Ç¨\"},\n\t\t{`\\uD83D\\uDE02`, \"üòÇ\"}, // Surrogate pair.\n\n\t\t// Invalid escape sequences.\n\t\t{`\\u`, `\\u`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\u12345`, `\\u12345`},\n\t\t{`\\uD800`, `\\uD800`}, // Invalid surrogate pair.\n\t\t{`\\uD800\\u`, `\\uD800\\u`},\n\n\t\t// Mixed valid and invalid escape sequences.\n\t\t{`hello\\u0020world`, \"hello world\"},\n\t\t{`\\u00A92023\\uD800`, \"¬©2023\\uD800\"},\n\n\t\t// Complex strings with multiple escape sequences.\n\t\t{`\"hello\\\\world\\/\\\"\\b\\f\\n\\r\\t\\u0020\\uD83D\\uDE02\"`, \"\\\"hello\\\\world/\\\"\\b\\f\\n\\r\\t üòÇ\\\"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Input: %q, Expected: %q, Actual: %q\", test.input, test.expected, actual)\n\t\t}\n\t}\n}\n","73e9cfe5e08926c7976321a2a9cd9a45":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Empty input.\n\t\t{\"\", nil, \"\", fmt.Errorf(\"cannot parse empty string\")},\n\t\t// Invalid JSON.\n\t\t{\"{invalid}\", nil, \"\", fmt.Errorf(\"cannot parse object: unexpected EOF\")},\n\t\t// Too deep nesting.\n\t\t{`{\"a\": {\"b\": {\"c\": {\"d\": {\"e\": {\"f\": {\"g\": {\"h\": {\"i\": {\"j\": {\"k\": {\"l\": {\"m\": {\"n\": {\"o\": {\"p\": {\"q\": {\"r\": {\"s\": {\"t\": {\"u\": {\"v\": {\"w\": {\"x\": {\"y\": {\"z\": {}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}`, nil, \"\", fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth)},\n\t\t// Valid JSON object.\n\t\t{`{\"foo\": \"bar\"}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: typeRawString, s: \"bar\"}}}}}}, \"\", nil},\n\t\t// Valid JSON array.\n\t\t{`[1, 2, 3]`, \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}}, \"\", nil},\n\t\t// Valid JSON string.\n\t\t{`\"hello\"`, \u0026Value{t: typeRawString, s: \"hello\"}, \"\", nil},\n\t\t// Valid JSON true.\n\t\t{\"true\", valueTrue, \"\", nil},\n\t\t// Valid JSON false.\n\t\t{\"false\", valueFalse, \"\", nil},\n\t\t// Valid JSON null.\n\t\t{\"null\", valueNull, \"\", nil},\n\t\t// Valid JSON number.\n\t\t{\"12345\", \u0026Value{t: TypeNumber, s: \"12345\"}, \"\", nil},\n\t\t// Valid JSON NaN.\n\t\t{\"NaN\", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"\", nil},\n\t\t// Valid JSON with trailing space.\n\t\t{`\"hello\" `, \u0026Value{t: typeRawString, s: \"hello\"}, \" \", nil},\n\t}\n\n\tc := \u0026cache{}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test%d\", i+1), func(t *testing.T) {\n\t\t\tgot, tail, err := parseValue(tt.input, c, 0)\n\t\t\tif fmt.Sprintf(\"%v\", err) != fmt.Sprintf(\"%v\", tt.err) {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, want %v\", tt.input, err, tt.err)\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"parseValue(%q) tail = %q, want %q\", tt.input, tail, tt.tail)\n\t\t\t}\n\t\t\tif got == nil \u0026\u0026 tt.want == nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got == nil || tt.want == nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) got = %v, want %v\", tt.input, got, tt.want)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got.t != tt.want.t {\n\t\t\t\tt.Errorf(\"parseValue(%q) got type = %v, want %v\", tt.input, got.t, tt.want.t)\n\t\t\t}\n\t\t\tif got.s != tt.want.s {\n\t\t\t\tt.Errorf(\"parseValue(%q) got string = %q, want %q\", tt.input, got.s, tt.want.s)\n\t\t\t}\n\t\t\tif got.t == TypeObject \u0026\u0026 !testObjectsEqual(got.o, tt.want.o) {\n\t\t\t\tt.Errorf(\"parseValue(%q) got object = %v, want %v\", tt.input, got.o, tt.want.o)\n\t\t\t}\n\t\t\tif got.t == TypeArray \u0026\u0026 !testArraysEqual(got.a, tt.want.a) {\n\t\t\t\tt.Errorf(\"parseValue(%q) got array = %v, want %v\", tt.input, got.a, tt.want.a)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc testObjectsEqual(o1, o2 Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i := range o1.kvs {\n\t\tif o1.kvs[i].k != o2.kvs[i].k {\n\t\t\treturn false\n\t\t}\n\t\tif !testValuesEqual(o1.kvs[i].v, o2.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc testArraysEqual(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i := range a1 {\n\t\tif !testValuesEqual(a1[i], a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc testValuesEqual(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.s != v2.s {\n\t\treturn false\n\t}\n\tif v1.t == TypeObject \u0026\u0026 !testObjectsEqual(v1.o, v2.o) {\n\t\treturn false\n\t}\n\tif v1.t == TypeArray \u0026\u0026 !testArraysEqual(v1.a, v2.a) {\n\t\treturn false\n\t}\n\treturn true\n}\n","7401629604b0f70bcbc19d96baaedff5":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic escapes\n\t\t{`\\b`, \"\\b\"},\n\t\t{`\\f`, \"\\f\"},\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\r`, \"\\r\"},\n\t\t{`\\t`, \"\\t\"},\n\t\t{`\\\\`, \"\\\\\"},\n\t\t{`\\/`, \"/\"},\n\t\t{`\\\"`, \"\\\"\"},\n\n\t\t// Unicode escapes\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A0`, \"\\u00A0\"},\n\t\t{`\\u20AC`, \"\\u20AC\"},\n\t\t{`\\uD83D\\uDE01`, \"\\U0001F601\"}, // Surrogate pair\n\n\t\t// Invalid escapes\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\uD800`, `\\uD800`}, // Unpaired surrogate\n\t\t{`\\uDFFF`, `\\uDFFF`}, // Unpaired surrogate\n\t\t{`\\uD83D\\u1234`, \"\\uD83D\\u1234\"}, // Invalid surrogate pair\n\n\t\t// Mixed strings\n\t\t{`Hello\\tworld`, \"Hello\\tworld\"},\n\t\t{`\"This is a \\\\\\\\test\\\\\"\", he said.`, \"\\\"This is a \\\\test\\\", he said.\"},\n\t\t{`C:\\\\Users\\\\John\\\\Documents`, `C:\\Users\\John\\Documents`},\n\t}\n\n\tfor i, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Test %d: Expected '%s', got '%s'\", i+1, test.expected, actual)\n\t\t}\n\t}\n}","74d7cae76125b8d48ca978cf0f627552":"package fastjson\n\nimport \"testing\"\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    string\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\ts:    \"\",\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with no leading whitespace\",\n\t\t\ts:    \"hello\",\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with leading space\",\n\t\t\ts:    \" hello\",\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with leading tab\",\n\t\t\ts:    \"\\thello\",\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with leading newline\",\n\t\t\ts:    \"\\nhello\",\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with leading carriage return\",\n\t\t\ts:    \"\\rhello\",\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with all whitespace characters\",\n\t\t\ts:    \" \\t\\n\\r\",\n\t\t\twant: \"\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %q, want %q\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","753a7a1e99cdb1733921791f2452aeb5":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ts     string\n\t\terr   error\n\t}{\n\t\t// Empty array\n\t\t{\"[]\", \u0026Value{t: TypeArray, a: []*Value{}}, \"\", nil},\n\t\t// Simple array\n\t\t{\"[1,2,3]\", \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t}}, \"\", nil},\n\t\t// Array with different types\n\t\t{`[\"hello\", 123, true]`, \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t{t: TypeString, s: \"hello\"},\n\t\t\t{t: TypeNumber, s: \"123\"},\n\t\t\t{t: TypeTrue},\n\t\t}}, \"\", nil},\n\t\t// Nested array\n\t\t{`[1, [2, 3], 4]`, \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t}},\n\t\t\t{t: TypeNumber, s: \"4\"},\n\t\t}}, \"\", nil},\n\t\t// Array with whitespace\n\t\t{\" [ 1 , 2 , 3 ] \", \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t}}, \"\", nil},\n\t\t// Invalid array - missing closing bracket\n\t\t{\"[1, 2, 3\", nil, \"[1, 2, 3\", fmt.Errorf(\"missing ']'\")},\n\t\t// Invalid array - missing comma\n\t\t{\"[1 2 3]\", nil, \" 2 3]\", fmt.Errorf(\"missing ',' after array value\")},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseArray(tt.input, c, 0)\n\n\t\t\tif got != nil \u0026\u0026 tt.want != nil \u0026\u0026 got.t != tt.want.t {\n\t\t\t\tt.Errorf(\"parseArray() got type = %v, want %v\", got.t, tt.want.t)\n\t\t\t}\n\t\t\tif err != nil \u0026\u0026 tt.err == nil {\n\t\t\t\tt.Errorf(\"parseArray() got error = %v, want %v\", err, tt.err)\n\t\t\t} else if err == nil \u0026\u0026 tt.err != nil {\n\t\t\t\tt.Errorf(\"parseArray() got error = %v, want %v\", err, tt.err)\n\t\t\t} else if err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error() {\n\t\t\t\tt.Errorf(\"parseArray() got error = %v, want %v\", err, tt.err)\n\t\t\t}\n\t\t\tif s != tt.s {\n\t\t\t\tt.Errorf(\"parseArray() got string = %v, want %v\", s, tt.s)\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.t == TypeArray {\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\treturn v1.s == v2.s\n}\n","75777daeca0c7bd8df52b21d1b780eff":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"raw string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"raw string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"12345\",\n\t\t\t},\n\t\t\twant: []byte(\"12345\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"string1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"12345\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"[\\\"string1\\\",12345]\"),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"string1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"12345\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"{\\\"key1\\\":\\\"string1\\\",\\\"key2\\\":12345}\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif string(got) != string(tt.want) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %v, want %v\", string(got), string(tt.want))\n\t\t\t}\n\t\t})\n\t}\n}","7687ecf07cfcfde6c5776872c4fb9d33":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Empty string\n\t\t{\"\", nil, \"\", fmt.Errorf(\"cannot parse empty string\")},\n\t\t// Invalid JSON\n\t\t{\"abc\", nil, \"abc\", fmt.Errorf(\"unexpected value found: \\\"abc\\\"\")},\n\t\t// Object\n\t\t{`{\"foo\":\"bar\"}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: typeRawString, s: \"bar\"}}}}}, \"\", nil},\n\t\t// Array\n\t\t{\"[1,2,3]\", \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}}, \"\", nil},\n\t\t// String\n\t\t{`\"hello\"`, \u0026Value{t: typeRawString, s: \"hello\"}, \"\", nil},\n\t\t// True\n\t\t{\"true\", valueTrue, \"\", nil},\n\t\t// False\n\t\t{\"false\", valueFalse, \"\", nil},\n\t\t// Null\n\t\t{\"null\", valueNull, \"\", nil},\n\t\t// Number\n\t\t{\"123\", \u0026Value{t: TypeNumber, s: \"123\"}, \"\", nil},\n\t\t// NaN\n\t\t{\"NaN\", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"\", nil},\n\t\t// Trailing space\n\t\t{\"true \", valueTrue, \" \", nil},\n\t}\n\tc := \u0026cache{}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tgot, tail, err := parseValue(tt.input, c, 0)\n\t\t\tif err != nil \u0026\u0026 tt.err == nil {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err == nil \u0026\u0026 tt.err != nil {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error() {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got == nil \u0026\u0026 tt.want == nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got == nil \u0026\u0026 tt.want != nil {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != nil \u0026\u0026 tt.want == nil {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"parseValue() tail = %v, want %v\", tail, tt.tail)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == v2 {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\treturn v1.s == v2.s\n\t}\n}\n","76c88dee15d18184fd5aae3fde728d6e":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey   string\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Basic cases\n\t\t{`\"foo\"bar`, \"foo\", \"bar\", nil},\n\t\t{`\"fo\\o\"bar`, \"fo\\\\o\", \"bar\", nil},\n\t\t{`\"foo\"`, \"foo\", \"\", nil},\n\t\t{`\"\"bar`, \"\", \"bar\", nil},\n\n\t\t// Escaped quotes\n\t\t{`\"foo\\\"bar\"baz`, `foo\"bar`, \"baz\", nil},\n\t\t{`\"foo\\\\\\\"\"baz`, `foo\\\"`, \"baz\", nil},\n\t\t{`\"foo\\\\\\\"bar\"baz`, `foo\\\"bar`, \"baz\", nil},\n\n\t\t// Invalid input\n\t\t{`\"foobar`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`foobar\"`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo\"bar\"`, \"foo\", \"bar\\\"\", nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test %d\", i), func(t *testing.T) {\n\t\t\tkey, tail, err := parseRawString(tt.input)\n\t\t\tif key != tt.key || tail != tt.tail || (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = (%q, %q, %v), want (%q, %q, %v)\", tt.input, key, tail, err, tt.key, tt.tail, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}","76f5fd995e906a4073d48604a7268b3e":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput       string\n\t\twantValue   *Value\n\t\twantTail    string\n\t\twantErr     bool\n\t\twantErrText string\n\t}{\n\t\t// Test cases here\n\t\t{\n\t\t\tinput:    \"{\\\"key\\\":\\\"value\\\"}\",\n\t\t\twantTail: \"\",\n\t\t\twantValue: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: typeRawString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: true,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1,2,3]\",\n\t\t\twantTail: \"\",\n\t\t\twantValue: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tinput:       \"\",\n\t\t\twantTail:    \"\",\n\t\t\twantValue:   nil,\n\t\t\twantErr:     true,\n\t\t\twantErrText: \"cannot parse empty string\",\n\t\t},\n\t}\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgotValue, gotTail, gotErr := parseValue(tc.input, c, 0)\n\n\t\t\tif tc.wantErr {\n\t\t\t\tif gotErr == nil {\n\t\t\t\t\tt.Errorf(\"expected error, got nil\")\n\t\t\t\t} else if gotErr.Error() != tc.wantErrText {\n\t\t\t\t\tt.Errorf(\"mismatch error text, want: %s, got: %s\", tc.wantErrText, gotErr.Error())\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif gotErr != nil {\n\t\t\t\t\tt.Errorf(\"unexpected error: %v\", gotErr)\n\t\t\t\t}\n\n\t\t\t\tif gotTail != tc.wantTail {\n\t\t\t\t\tt.Errorf(\"mismatch tail, want: %s, got: %s\", tc.wantTail, gotTail)\n\t\t\t\t}\n\n\t\t\t\tif !equalValues(gotValue, tc.wantValue) {\n\t\t\t\t\tt.Errorf(\"mismatch values, want: %#v, got: %#v\", tc.wantValue, gotValue)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(a, b *Value) bool {\n\tif a == nil \u0026\u0026 b == nil {\n\t\treturn true\n\t}\n\tif a == nil || b == nil {\n\t\treturn false\n\t}\n\tif a.t != b.t {\n\t\treturn false\n\t}\n\tswitch a.t {\n\tcase TypeObject:\n\t\tif a.o.keysUnescaped != b.o.keysUnescaped {\n\t\t\treturn false\n\t\t}\n\t\tif len(a.o.kvs) != len(b.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range a.o.kvs {\n\t\t\tif a.o.kvs[i].k != b.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(a.o.kvs[i].v, b.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeArray:\n\t\tif len(a.a) != len(b.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range a.a {\n\t\t\tif !equalValues(a.a[i], b.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\treturn a.s == b.s\n\t}\n}","77bce0e6590e4b18937b930f84c13ca1":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey string\n\t\ttail string\n\t\terr error\n\t}{\n\t\t// Basic cases\n\t\t{`\"foo\"bar`, \"foo\", \"bar\", nil},\n\t\t{`\"foo\\\"bar\"baz`, \"foo\\\"bar\", \"baz\", nil},\n\t\t{`\"foo\"`, \"foo\", \"\", nil},\n\n\t\t// Escape sequences\n\t\t{`\"\\\\\"bar`, \"\\\\\", \"bar\", nil},\n\t\t{`\"\\\\\\\"\"bar`, \"\\\\\\\"\", \"bar\", nil},\n\t\t{`\"foo\\\\\"bar`, \"foo\\\\\", \"bar\", nil},\n\t\t{`\"foo\\\\\\\\\"bar`, \"foo\\\\\\\\\", \"bar\", nil},\n\n\t\t// Error cases\n\t\t{`\"foo`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`foo\"`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo\\\"`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T){\n\t\t\tkey, tail, err := parseRawString(tt.input)\n\t\t\tif key != tt.key || tail != tt.tail  ||  (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = (%q, %q, %v), want (%q, %q, %v)\", tt.input, key, tail, err, tt.key, tt.tail, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}\n","782108c696836cbdae2916bc481df792":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ts     string\n\t\terr   error\n\t}{\n\t\t// Empty array\n\t\t{\"[]\", \u0026Value{t: TypeArray, a: []*Value{}}, \"\", nil},\n\t\t// Simple array\n\t\t{\"[1,2,3]\", \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}}, \"\", nil},\n\t\t// Array with different types\n\t\t{\"[1,\\\"hello\\\",true]\", \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeString, s: \"hello\"}, {t: TypeTrue}}}, \"\", nil},\n\t\t// Nested array\n\t\t{\"[[1,2],[3,4]]\", \u0026Value{t: TypeArray, a: []*Value{{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}}}, {t: TypeArray, a: []*Value{{t: TypeNumber, s: \"3\"}, {t: TypeNumber, s: \"4\"}}}}}, \"\", nil},\n\t\t// Array with trailing whitespace\n\t\t{\"[1,2,3] \", \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}}, \" \", nil},\n\t\t// Invalid array - missing closing bracket\n\t\t{\"[1,2,3\", nil, \"\", fmt.Errorf(\"unexpected end of array\")},\n\t\t// Invalid array - missing comma\n\t\t{\"[1 2 3]\", nil, \"2 3]\", fmt.Errorf(\"missing ',' after array value\")},\n\t\t// Invalid array - trailing comma\n\t\t{\"[1,2,]\", nil, \"\", fmt.Errorf(\"cannot parse array value: unexpected end of JSON\")},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseArray(tt.input, c, 0)\n\n\t\t\tif got != nil \u0026\u0026 tt.want != nil \u0026\u0026 got.t != tt.want.t {\n\t\t\t\tt.Errorf(\"parseArray() got different type, got: %v, want: %v\", got.t, tt.want.t)\n\t\t\t}\n\n\t\t\tif err != nil \u0026\u0026 tt.err == nil {\n\t\t\t\tt.Errorf(\"parseArray() returned unexpected error: %v\", err)\n\t\t\t} else if err == nil \u0026\u0026 tt.err != nil {\n\t\t\t\tt.Errorf(\"parseArray() did not return expected error: %v\", tt.err)\n\t\t\t} else if err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error() {\n\t\t\t\tt.Errorf(\"parseArray() returned wrong error message, got: %v, want: %v\", err.Error(), tt.err.Error())\n\t\t\t}\n\n\t\t\tif tt.want != nil \u0026\u0026 !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif s != tt.s {\n\t\t\t\tt.Errorf(\"parseArray() remaining string = %q, want %q\", s, tt.s)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeString, TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeTrue, TypeFalse, TypeNull:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n","786947ac52c4718b1416b399695b5978":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\tvar c cache\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantValue *Value\n\t\twantTail string\n\t\twantErr   error\n\t}{\n\t\t{\n\t\t\tname:     \"empty array\",\n\t\t\tinput:    \"[]\",\n\t\t\twantValue: \u0026Value{t: TypeArray},\n\t\t\twantTail:  \"\",\n\t\t\twantErr:   nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"simple array\",\n\t\t\tinput:    \"[1,2,3]\",\n\t\t\twantValue: \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}},\n\t\t\twantTail:  \"\",\n\t\t\twantErr:   nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with spaces\",\n\t\t\tinput:    \" [ 1 , 2 , 3 ] \",\n\t\t\twantValue: \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}},\n\t\t\twantTail:  \" \",\n\t\t\twantErr:   nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"nested array\",\n\t\t\tinput:    \"[[1,2],[3,4]]\",\n\t\t\twantValue: \u0026Value{t: TypeArray, a: []*Value{{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}}}, {t: TypeArray, a: []*Value{{t: TypeNumber, s: \"3\"}, {t: TypeNumber, s: \"4\"}}}}},\n\t\t\twantTail:  \"\",\n\t\t\twantErr:   nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with different types\",\n\t\t\tinput:    \"[1,\\\"hello\\\",true]\",\n\t\t\twantValue: \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeString, s: \"hello\"}, {t: TypeTrue}}},\n\t\t\twantTail:  \"\",\n\t\t\twantErr:   nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing closing bracket\",\n\t\t\tinput:    \"[1,2,3\",\n\t\t\twantValue: nil,\n\t\t\twantTail:  \"\",\n\t\t\twantErr:   fmt.Errorf(\"unexpected end of array\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"missing comma\",\n\t\t\tinput:    \"[1 2,3]\",\n\t\t\twantValue: nil,\n\t\t\twantTail:  \"\",\n\t\t\twantErr:   fmt.Errorf(\"missing ',' after array value\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotValue, gotTail, gotErr := parseArray(tt.input, \u0026c, 0)\n\n\t\t\tif gotErr != nil \u0026\u0026 tt.wantErr == nil {\n\t\t\t\tt.Errorf(\"unexpected error: %v\", gotErr)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif gotErr == nil \u0026\u0026 tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"expected error %v, got nil\", tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"expected error %v, got %v\", tt.wantErr, gotErr)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"expected tail %q, got %q\", tt.wantTail, gotTail)\n\t\t\t}\n\t\t\tif !equalValues(gotValue, tt.wantValue) {\n\t\t\t\tt.Errorf(\"expected value %v, got %v\", tt.wantValue, gotValue)\n\t\t\t}\n\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeString, TypeNumber:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\treturn true\n\t}\n}\n","798be09ae942c932c643af314a791107":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc Test_unescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello world\",\n\t\t\t},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"simple escape\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello\\\\tworld\",\n\t\t\t},\n\t\t\twant: \"hello\\tworld\",\n\t\t},\n\t\t{\n\t\t\tname: \"unicode escape\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello\\\\u0020world\",\n\t\t\t},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid unicode escape\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello\\\\u002world\",\n\t\t\t},\n\t\t\twant: \"hello\\\\u002world\",\n\t\t},\n\t\t{\n\t\t\tname: \"surrogate pair\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello\\\\uD83D\\\\uDE01world\",\n\t\t\t},\n\t\t\twant: \"helloüòÅworld\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid surrogate pair\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello\\\\uD83D\\\\u002world\",\n\t\t\t},\n\t\t\twant: \"hello\\\\uD83D\\\\u002world\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","79d8078e796dcbcc4dd823f358ec52aa":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ts     string\n\t\terr   error\n\t}{\n\t\t// Add test cases here\n\t\t{\n\t\t\tinput: \"[]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tinput: \"[1,2,3]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tinput: \"[1, 2, 3]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tinput: \" [ 1 , 2 , 3 ] \",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \" \",\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tinput: `[{\"a\": 1}]`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t{k: \"a\", v: \u0026Value{t: TypeNumber, s: \"1\"}},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\n\t\t// Error cases\n\t\t{\n\t\t\tinput: \"[\",\n\t\t\twant:  nil,\n\t\t\ts:     \"[\",\n\t\t\terr:   fmt.Errorf(\"missing ']'\"),\n\t\t},\n\t\t{\n\t\t\tinput: \"1\",\n\t\t\twant:  nil,\n\t\t\ts:     \"1\",\n\t\t\terr:   fmt.Errorf(\"cannot parse array value: unexpected token 'number'\"),\n\t\t},\n\t\t{\n\t\t\tinput: \"[1 2]\",\n\t\t\twant:  nil,\n\t\t\ts:     \"2]\",\n\t\t\terr:   fmt.Errorf(\"missing ',' after array value\"),\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseArray(tt.input, c, 0)\n\n\t\t\tif (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err == nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"Test %d failed: error mismatch. Want: %v, Got: %v\", i, tt.err, err)\n\t\t\t}\n\t\t\tif s != tt.s {\n\t\t\t\tt.Errorf(\"Test %d failed: remaining string mismatch. Want: %q, Got: %q\", i, tt.s, s)\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"Test %d failed: output mismatch. Want: %v, Got: %v\", i, tt.want, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.s != v2.s {\n\t\treturn false\n\t}\n\tif len(v1.a) != len(v2.a) {\n\t\treturn false\n\t}\n\tfor i := range v1.a {\n\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\treturn false\n\t}\n\tfor i := range v1.o.kvs {\n\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\treturn false\n\t\t}\n\t\tif !equalValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n","7a92821e0adc82cb85ceea8247358d8a":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc Test_parseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\ts       string\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\ts:     \"{}\",\n\t\t\twant:  \u0026Value{t: TypeObject, o: Object{kvs: nil, keysUnescaped: false}},\n\t\t\twant1: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"simple object\",\n\t\t\ts:     `{\"key\": \"value\"}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: \u0026Value{t: TypeString, s: \"value\"}},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"complex object\",\n\t\t\ts:     `{\"key1\": \"value1\", \"key2\": 123, \"key3\": true, \"key4\": {\"subkey\": \"subvalue\"}}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t\t{k: \"key3\", v: \u0026Value{t: TypeTrue}},\n\t\t\t\t\t\t{k: \"key4\", v: \u0026Value{t: TypeObject, o: Object{\n\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t{k: \"subkey\", v: \u0026Value{t: TypeString, s: \"subvalue\"}},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t}}},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\n\t\t// error cases\n\t\t{\n\t\t\tname:    \"missing closing bracket\",\n\t\t\ts:       `{\"key\": \"value\"`,\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"missing colon\",\n\t\t\ts:       `{\"key\" \"value\"}`,\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid key\",\n\t\t\ts:       `{123: \"value\"}`,\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, got1, err := parseObject(tt.s, c, 0)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif fmt.Sprintf(\"%#v\", got) != fmt.Sprintf(\"%#v\", tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %#v, want %#v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","7ae139e99d6004412db527f5cec86730":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey   string\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t{\"\\\"foo\\\":1\", \"foo\", \":1\", nil},\n\t\t{\"\\\"bar\\\":\\\"baz\\\"\", \"bar\", \":\\\"baz\\\"\", nil},\n\t\t{\"\\\"key with spaces\\\": null\", \"key with spaces\", \": null\", nil},\n\t\t{\"  \\\"key with leading spaces\\\": null\", \"key with leading spaces\", \": null\", nil},\n\t\t{\"\\\"key with trailing spaces\\\"  : null\", \"key with trailing spaces\", \"  : null\", nil},\n\t\t{\"\\\"escaped\\\\\\\"quote\\\": true\", \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{\"\\\"\\\\x\\\": true\", \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{\"invalid\", \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test %d\", i), func(t *testing.T) {\n\t\t\tkey, tail, err := parseRawKey(tt.input)\n\t\t\tif key != tt.key || tail != tt.tail || !errorEqual(err, tt.err) {\n\t\t\t\tt.Errorf(\"parseRawKey(%q) = (%q, %q, %v), want (%q, %q, %v)\", tt.input, key, tail, err, tt.key, tt.tail, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// errorEqual compares two errors for equality.\nfunc errorEqual(e1, e2 error) bool {\n\tif e1 == nil \u0026\u0026 e2 == nil {\n\t\treturn true\n\t}\n\tif e1 == nil || e2 == nil {\n\t\treturn false\n\t}\n\treturn e1.Error() == e2.Error()\n}","7b0eb03b9c3c5c2a59058e32333f3f39":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey   string\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Basic cases.\n\t\t{`\"foo\": \"bar\"`, \"foo\", `: \"bar\"`, nil},\n\t\t{`\"foo\" : \"bar\"`, \"foo\", ` : \"bar\"`, nil},\n\t\t{`\"foo\"  : \"bar\"`, \"foo\", `  : \"bar\"`, nil},\n\t\t{`\"escaped\\\"quote\": \"bar\"`, `escaped\"quote`, `: \"bar\"`, nil},\n\n\t\t// Error cases.\n\t\t{`\"foo`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`foo\": \"bar\"`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo: \"bar\"`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\n\t\t// Cases that should fall back to parseRawString.\n\t\t{`\"foo\\nbar\": \"baz\"`, \"\", \"\", nil},\n\t\t{`\"foo\\\\bar\": \"baz\"`, \"\", \"\", nil},\n\t\t{`\"foo\\tbar\": \"baz\"`, \"\", \"\", nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tkey, tail, err := parseRawKey(tt.input)\n\t\t\tif key != tt.key || tail != tt.tail {\n\t\t\t\tt.Errorf(\"Test %d failed: Expected: key=%q, tail=%q, got: key=%q, tail=%q\", i, tt.key, tt.tail, key, tail)\n\t\t\t}\n\t\t\tif (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err == nil) {\n\t\t\t\tt.Errorf(\"Test %d failed: Error mismatch. Expected: %v, got: %v\", i, tt.err, err)\n\t\t\t} else if err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error() {\n\t\t\t\tt.Errorf(\"Test %d failed: Error message mismatch. Expected: %q, got: %q\", i, tt.err.Error(), err.Error())\n\t\t\t}\n\t\t})\n\t}\n}","7be990ce79cb1a8b124a128d9ab3387a":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant1 string\n\t\twant2 string\n\t\terr   error\n\t}{\n\t\t// Test cases here\n\t\t{\"\\\"hello\\\"\", \"hello\", \"\", nil},\n\t\t{\"\\\"hello\\\"world\", \"hello\", \"world\", nil},\n\t\t{\"\\\"hello\\\\\\\"world\\\"\", \"hello\\\\\\\"world\", \"\", nil},\n\t\t{\"\\\"hello\\\\\\\\\\\\\\\"world\\\"\", \"hello\\\\\\\\\\\\\\\"world\", \"\", nil},\n\t\t{\"\\\"hello\", \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{\"hello\\\"\", \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{\"\\\"hel\\\"lo\\\"\", \"hel\", \"lo\\\"\", nil},\n\t}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test %d\", i), func(t *testing.T) {\n\t\t\tgot1, got2, err := parseRawString(tt.input)\n\t\t\tif got1 != tt.want1 || got2 != tt.want2 || (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"parseRawString(%v) = (%v, %v, %v), want (%v, %v, %v)\", tt.input, got1, got2, err, tt.want1, tt.want2, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}","7c09caf0ea87aa843bac1becd45191fc":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantV    *Value\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t{\n\t\t\tname:     \"empty\",\n\t\t\tinput:    \"\",\n\t\t\twantV:    nil,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t// Add more test cases here\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgotV, gotTail, err := parseValue(tt.input, c, 0)\n\t\t\tif fmt.Sprintf(\"%v\", err) != fmt.Sprintf(\"%v\", tt.wantErr) {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseValue() gotTail = %v, want %v\", gotTail, tt.wantTail)\n\t\t\t}\n\t\t\t// Compare gotV and tt.wantV (need to implement comparison for *Value)\n\t\t})\n\t}\n}","7ca549d288828fbe5328bbd86e0db62a":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey string\n\t\tvalue string\n\t\terr error\n\t}{\n\t\t// Basic cases\n\t\t{`\"foo\"bar`, `foo`, `bar`, nil},\n\t\t{`\"fo\\\\o\"bar`, `fo\\o`, `bar`, nil},\n\t\t{`\"foo\"`, `foo`, ``, nil},\n\t\t{`\"\"bar`, ``, `bar`, nil},\n\n\t\t// Escaped quotes\n\t\t{`\"\\\\\"foo`, `\\`, `foo`, nil},\n\t\t{`\"f\\\\\"oo\"bar`, `f\\\"oo`, `bar`, nil},\n\t\t{`\"foo\\\\\"\"bar`, `foo\\\"`, `bar`, nil},\n\t\t{`\"fo\\\\\"o\"bar`, `fo\\\"o`, `bar`, nil},\n\n\t\t// Invalid cases\n\t\t{`\"foo`, ``, ``, fmt.Errorf(`missing closing '\"'`)},\n\t\t{`foo\"`, ``, ``, fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo\"bar\"`, ``, ``, fmt.Errorf(`missing closing '\"'`)},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tkey, value, err := parseRawString(tt.input)\n\t\t\tif fmt.Sprintf(\"%v\", tt.err) != fmt.Sprintf(\"%v\", err) {\n\t\t\t\tt.Errorf(\"Expected error: %v, got: %v\", tt.err, err)\n\t\t\t}\n\t\t\tif key != tt.key {\n\t\t\t\tt.Errorf(\"Expected key: %v, got: %v\", tt.key, key)\n\t\t\t}\n\t\t\tif value != tt.value {\n\t\t\t\tt.Errorf(\"Expected value: %v, got: %v\", tt.value, value)\n\t\t\t}\n\t\t})\n\t}\n}","7dad3b1c46ec53aac2f667a5953c1862":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic strings\n\t\t{\"hello\", \"hello\"},\n\t\t{\"world\", \"world\"},\n\n\t\t// Escaped characters\n\t\t{`\"hello\\\"world\"`, `\"hello\"world\"`},\n\t\t{`\\b\\f\\n\\r\\t`, \"\\b\\f\\n\\r\\t\"},\n\t\t{`\\\\\\/`, `\\/`},\n\n\t\t// Unicode escapes\n\t\t{`\\u0041`, \"A\"},\n\t\t{`\\u00e9`, \"√©\"},\n\t\t{`\\u20ac`, \"‚Ç¨\"},\n\t\t{`\\uD83D\\uDE01`, \"üòÅ\"}, // Surrogate pair\n\n\t\t// Invalid escape sequences\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u`, `\\u`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\uD800`, `\\uD800`}, // Unpaired surrogate\n\n\t\t// Mixed strings\n\t\t{`hello\\t\"world\"\\n`, \"hello\\t\\\"world\\\"\\n\"},\n\t\t{`\\u0041\\u0020\\u0022test\\u0022`, \"A \\\"test\\\"\"},\n\t}\n\n\tfor i, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Test %d: Expected '%s', but got '%s'\", i, test.expected, actual)\n\t\t}\n\t}\n}","7db1f88e3c96395375451e83de16c5b6":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantN    string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Valid numbers\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"123.456\", \"123.456\", \"\", nil},\n\t\t{\"1.23e4\", \"1.23e4\", \"\", nil},\n\t\t{\"-1.23e-4\", \"-1.23e-4\", \"\", nil},\n\t\t{\"+1.23E+4\", \"+1.23E+4\", \"\", nil},\n\n\t\t// Valid numbers with trailing characters\n\t\t{\"123a\", \"123\", \"a\", nil},\n\t\t{\"-123 \", \"-123\", \" \", nil},\n\t\t{\"123.456,\", \"123.456\", \",\", nil},\n\n\t\t// Invalid numbers\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t\t{\"a123\", \"\", \"a123\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\"+a123\", \"\", \"+a123\", fmt.Errorf(\"unexpected char: %q\", \"+a\")},\n\t\t{\"-a123\", \"\", \"-a123\", fmt.Errorf(\"unexpected char: %q\", \"-a\")},\n\n\t\t// Special cases: \"inf\", \"Inf\", \"in\", \"Infinity\", ...\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"Inf\", \"Inf\", \"\", nil},\n\t\t{\"in\", \"\", \"in\", fmt.Errorf(\"unexpected char: %q\", \"i\")},\n\t\t{\"Infinity\", \"inf\", \"inity\", nil},\n\t\t{\"infinity\", \"inf\", \"inity\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"-Infinity\", \"-inf\", \"inity\", nil},\n\t\t{\"+inf\", \"+inf\", \"\", nil},\n\t\t{\"+Infinity\", \"+inf\", \"inity\", nil},\n\n\t\t// Special cases: \"nan\", \"NaN\", \"na\", ...\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"NaN\", \"NaN\", \"\", nil},\n\t\t{\"na\", \"\", \"na\", fmt.Errorf(\"unexpected char: %q\", \"n\")},\n\t\t{\"NAN\", \"NaN\", \"\", nil},\n\t\t{\"-nan\", \"-nan\", \"\", nil},\n\t\t{\"-NaN\", \"-NaN\", \"\", nil},\n\t\t{\"+nan\", \"+nan\", \"\", nil},\n\t\t{\"+NaN\", \"+NaN\", \"\", nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test %d: %s\", i, tt.input), func(t *testing.T) {\n\t\t\tgotN, gotTail, gotErr := parseRawNumber(tt.input)\n\t\t\tif gotN != tt.wantN {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got number = %q, want %q\", tt.input, gotN, tt.wantN)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got tail = %q, want %q\", tt.input, gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif gotErr == nil \u0026\u0026 tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got no error, want %v\", tt.input, tt.wantErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr == nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got error = %v, want nil\", tt.input, gotErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got error = %v, want %v\", tt.input, gotErr, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}\n","7dcd4b2020590e522e3b8a940cc501f3":"package fastjson\n\nimport \"testing\"\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\ts string\n\t\twant string\n\t}{\n\t\t{\"  foo\", \"foo\"},\n\t\t{\"\\n\\tfoo\", \"foo\"},\n\t\t{\"\\r\\nfoo\", \"foo\"},\n\t\t{\"foo  \", \"foo  \"},\n\t\t{\"foo\", \"foo\"},\n\t\t{\"\", \"\"},\n\t}\n\tfor i, tt := range tests {\n\t\tgot := skipWSSlow(tt.s)\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"test %d: skipWSSlow(%q) = %q, want %q\", i, tt.s, got, tt.want)\n\t\t}\n\t}\n}","7dd7034a21a9529c961f608a308225ae":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantJSON string\n\t\twantErr  error\n\t}{\n\t\t{\n\t\t\tname:     \"empty object\",\n\t\t\tinput:    \"{}\",\n\t\t\twantJSON: `{}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"simple object\",\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\twantJSON: `{\"key\":\"value\"}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"nested object\",\n\t\t\tinput:    `{\"key\": {\"nestedKey\": \"nestedValue\"}}`,\n\t\t\twantJSON: `{\"key\":{\"nestedKey\":\"nestedValue\"}}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple keys\",\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantJSON: `{\"key1\":\"value1\",\"key2\":\"value2\"}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"with spaces\",\n\t\t\tinput:    \" { \\\"key\\\" : \\\"value\\\" } \",\n\t\t\twantJSON: `{\"key\":\"value\"}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid JSON\",\n\t\t\tinput:    `{key\": \"value\"}`,\n\t\t\twantJSON: ``,\n\t\t\twantErr:  fmt.Errorf(`cannot find opening '\"\" for object key`),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseObject(tt.input, c, 0)\n\t\t\tif tt.wantErr != nil {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"expected error, but got nil\")\n\t\t\t\t} else if err.Error() != tt.wantErr.Error() {\n\t\t\t\t\tt.Errorf(\"error mismatch: got %v, want %v\", err, tt.wantErr)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t}\n\t\t\tif s != \"\" {\n\t\t\t\tt.Errorf(\"unexpected remaining string: %v\", s)\n\t\t\t}\n\t\t\tif got == nil {\n\t\t\t\tt.Errorf(\"got nil value, want non-nil\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgotJSON := got.MarshalTo(nil)\n\t\t\tif string(gotJSON) != tt.wantJSON {\n\t\t\t\tt.Errorf(\"JSON mismatch: got %s, want %s\", gotJSON, tt.wantJSON)\n\t\t\t}\n\t\t})\n\t}\n}","7e8e562ef2d27c182d546cf4c9a07086":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetArray(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tjson  string\n\t\tkeys  []string\n\t\twant  []*Value\n\t\twant1 bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tjson:  `{}`,\n\t\t\tkeys:  []string{\"foo\", \"0\"},\n\t\t\twant:  nil,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"empty array\",\n\t\t\tjson:  `[]`,\n\t\t\tkeys:  []string{\"0\"},\n\t\t\twant:  nil,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"simple object\",\n\t\t\tjson:  `{\"foo\": [1,2,3]}`,\n\t\t\tkeys:  []string{\"foo\"},\n\t\t\twant:  []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}},\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"nested array\",\n\t\t\tjson:  `{\"foo\": [[1,2,3], [4,5,6]]}`,\n\t\t\tkeys:  []string{\"foo\", \"1\"},\n\t\t\twant:  []*Value{{t: TypeNumber, s: \"4\"}, {t: TypeNumber, s: \"5\"}, {t: TypeNumber, s: \"6\"}},\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"index out of range\",\n\t\t\tjson:  `{\"foo\": [1,2,3]}`,\n\t\t\tkeys:  []string{\"foo\", \"3\"},\n\t\t\twant:  nil,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"invalid index\",\n\t\t\tjson:  `{\"foo\": [1,2,3]}`,\n\t\t\tkeys:  []string{\"foo\", \"bar\"},\n\t\t\twant:  nil,\n\t\t\twant1: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv, _ := Parse(tt.json)\n\t\t\tgot := v.GetArray(tt.keys...)\n\t\t\tif (got == nil \u0026\u0026 tt.want1) || (got != nil \u0026\u0026 !tt.want1) {\n\t\t\t\tt.Errorf(\"GetArray() got1 = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif len(got) != len(tt.want) {\n\t\t\t\tt.Errorf(\"GetArray() = %v, want %v\", got, tt.want)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tfor i, v := range got {\n\t\t\t\tif v.t != tt.want[i].t || v.s != tt.want[i].s {\n\t\t\t\t\tt.Errorf(\"GetArray() = %v, want %v\", got, tt.want)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n","7f4ba0b171c71cd762dba9c2e617f4ff":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetUint(t *testing.T) {\n\tvar v Value\n\tif u := v.GetUint(); u != 0 {\n\t\tt.Errorf(\"expected 0; got %v\", u)\n\t}\n\n\tv.s = \"123\"\n\tv.t = TypeNumber\n\tif u := v.GetUint(); u != 123 {\n\t\tt.Errorf(\"expected 123; got %v\", u)\n\t}\n\n\tif u := v.GetUint(\"non-existing-key\"); u != 0 {\n\t\tt.Errorf(\"expected 0; got %v\", u)\n\t}\n\n\tv.t = TypeString\n\tif u := v.GetUint(); u != 0 {\n\t\tt.Errorf(\"expected 0; got %v\", u)\n\t}\n\n\t// Test for overflow\n\tv.s = \"18446744073709551616\"\n\tv.t = TypeNumber\n\tif u := v.GetUint(); u != 0 {\n\t\tt.Errorf(\"expected 0; got %v\", u)\n\t}\n\n\t// Test with keys path\n\tv.o = Object{\n\t\tkvs: []kv{\n\t\t\t{k: \"a\", v: \u0026Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"b\", v: \u0026Value{s: \"456\", t: TypeNumber}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t}},\n\t\t},\n\t}\n\tif u := v.GetUint(\"a\", \"b\"); u != 456 {\n\t\tt.Errorf(\"expected 456; got %v\", u)\n\t}\n\n\t// Test with array index\n\tv.o = Object{\n\t\tkvs: []kv{\n\t\t\t{k: \"a\", v: \u0026Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"789\", t: TypeNumber},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t}},\n\t\t},\n\t}\n\tif u := v.GetUint(\"a\", \"0\"); u != 789 {\n\t\tt.Errorf(\"expected 789; got %v\", u)\n\t}\n}","7f60f1b39103ded7daa1b75a4ee76a2d":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Empty string\n\t\t{\"\", nil, \"\", fmt.Errorf(\"cannot parse empty string\")},\n\t\t// Invalid JSON\n\t\t{\"{invalid}\", nil, \"\", fmt.Errorf(\"cannot parse object: invalid character 'i' looking for beginning of value\")},\n\t\t// Simple object\n\t\t{`{\"key\": \"value\"}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{t: typeRawString, s: \"value\"}}}}}}, \"\", nil},\n\t\t// Simple array\n\t\t{`[1, \"two\", true]`, \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: typeRawString, s: \"two\"}, {t: TypeTrue}}}, \"\", nil},\n\t\t// String with escapes\n\t\t{`\"hello\\nworld\"`, \u0026Value{t: typeRawString, s: \"hello\\nworld\"}, \"\", nil},\n\t\t// True boolean\n\t\t{\"true\", valueTrue, \"\", nil},\n\t\t// False boolean\n\t\t{\"false\", valueFalse, \"\", nil},\n\t\t// Null value\n\t\t{\"null\", valueNull, \"\", nil},\n\t\t// Number\n\t\t{\"12345\", \u0026Value{t: TypeNumber, s: \"12345\"}, \"\", nil},\n\t\t// NaN\n\t\t{\"NaN\", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"\", nil},\n\t\t// Trailing whitespace\n\t\t{`\"value\"  `, \u0026Value{t: typeRawString, s: \"value\"}, \"  \", nil},\n\t}\n\n\tc := \u0026cache{}\n\tfor i, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tgot, tail, err := parseValue(test.input, c, 0)\n\t\t\tif fmt.Sprintf(\"%v\", err) != fmt.Sprintf(\"%v\", test.err) {\n\t\t\t\tt.Errorf(\"parseValue(%q) error mismatch: got %v, want %v\", test.input, err, test.err)\n\t\t\t}\n\t\t\tif tail != test.tail {\n\t\t\t\tt.Errorf(\"parseValue(%q) tail mismatch: got %q, want %q\", test.input, tail, test.tail)\n\t\t\t}\n\t\t\tif !equalValues(got, test.want) {\n\t\t\t\tt.Errorf(\"parseValue(%q) mismatch:\\ngot  %+v\\nwant %+v\", test.input, got, test.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(a, b *Value) bool {\n\tif a == nil \u0026\u0026 b == nil {\n\t\treturn true\n\t}\n\tif a == nil || b == nil {\n\t\treturn false\n\t}\n\tif a.t != b.t {\n\t\treturn false\n\t}\n\tswitch a.t {\n\tcase TypeObject:\n\t\tif len(a.o.kvs) != len(b.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range a.o.kvs {\n\t\t\tif a.o.kvs[i].k != b.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(a.o.kvs[i].v, b.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeArray:\n\t\tif len(a.a) != len(b.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range a.a {\n\t\t\tif !equalValues(a.a[i], b.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\treturn a.s == b.s\n\t}\n}","807d013abe86474680c99a8397c44ef9":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Get(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tjson  string\n\t\tkeys  []string\n\t\twant  *Value\n\t\twant1 bool\n\t}{\n\t\t{\n\t\t\tname:  \"object\",\n\t\t\tjson:  `{\"foo\":{\"bar\":\"baz\"}}`,\n\t\t\tkeys:  []string{\"foo\", \"bar\"},\n\t\t\twant:  \u0026Value{t: TypeString, s: \"baz\"},\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array\",\n\t\t\tjson:  `[1,2,3]`,\n\t\t\tkeys:  []string{\"1\"},\n\t\t\twant:  \u0026Value{t: TypeNumber, s: \"2\"},\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object_not_found\",\n\t\t\tjson:  `{\"foo\":{\"bar\":\"baz\"}}`,\n\t\t\tkeys:  []string{\"foo\", \"baz\"},\n\t\t\twant:  nil,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array_not_found\",\n\t\t\tjson:  `[1,2,3]`,\n\t\t\tkeys:  []string{\"10\"},\n\t\t\twant:  nil,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array_invalid_index\",\n\t\t\tjson:  `[1,2,3]`,\n\t\t\tkeys:  []string{\"abc\"},\n\t\t\twant:  nil,\n\t\t\twant1: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv, _ := Parse([]byte(tt.json))\n\t\t\tgot := v.Get(tt.keys...)\n\t\t\tif got == nil \u0026\u0026 tt.want != nil {\n\t\t\t\tt.Errorf(\"Get() = nil, want %v\", tt.want)\n\t\t\t}\n\n\t\t\tif got != nil \u0026\u0026 tt.want == nil {\n\t\t\t\tt.Errorf(\"Get() = %v, want nil\", got)\n\t\t\t}\n\n\t\t\tif got != nil \u0026\u0026 tt.want != nil {\n\t\t\t\tif got.Type() != tt.want.Type() {\n\t\t\t\t\tt.Errorf(\"Get() = %v, want %v\", got, tt.want)\n\t\t\t\t}\n\t\t\t\tif got.Type() == TypeString \u0026\u0026 got.s != tt.want.s {\n\t\t\t\t\tt.Errorf(\"Get() = %v, want %v\", got, tt.want)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n","80eb4c1412d255ee46292aae604c32df":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantNum  string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Valid numbers\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"+123\", \"+123\", \"\", nil},\n\t\t{\"123.456\", \"123.456\", \"\", nil},\n\t\t{\"1.2e3\", \"1.2e3\", \"\", nil},\n\t\t{\"1.2E-3\", \"1.2E-3\", \"\", nil},\n\t\t{\"1.2e+3\", \"1.2e+3\", \"\", nil},\n\n\t\t// Valid numbers with trailing characters\n\t\t{\"123a\", \"123\", \"a\", nil},\n\t\t{\"123.456 \", \"123.456\", \" \", nil},\n\t\t{\"-123\\n\", \"-123\", \"\\n\", nil},\n\n\t\t// Invalid numbers\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t\t{\"+\", \"\", \"+\", fmt.Errorf(\"unexpected char: %q\", \"+\")},\n\t\t(\"-\", \"\", \"-\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t\t{\".123\", \"\", \".123\", fmt.Errorf(\"unexpected char: %q\", \".\")},\n\t\t{\"123a456\", \"123\", \"a456\", nil},\n\n\t\t// Special cases: inf, nan\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"+inf\", \"+inf\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"in\", \"\", \"in\", fmt.Errorf(\"unexpected char: %q\", \"i\")},\n\t\t{\"infx\", \"inf\", \"x\", nil},\n\t\t{\"+InF\", \"+InF\", \"\", nil},\n\t\t{\"-INFINITY\", \"-INFINITY\", \"\", nil},\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"+nan\", \"\", \"+nan\", fmt.Errorf(\"unexpected char: %q\", \"+\")},\n\t\t{\"-nan\", \"\", \"-nan\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t\t{\"na\", \"\", \"na\", fmt.Errorf(\"unexpected char: %q\", \"n\")},\n\t\t{\"nanx\", \"nan\", \"x\", nil},\n\t\t{\"+NaN\", \"\", \"+NaN\", fmt.Errorf(\"unexpected char: %q\", \"+\")},\n\t\t{\"-NAN\", \"\", \"-NAN\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d:%s\", i, tt.input), func(t *testing.T) {\n\t\t\tgotNum, gotTail, gotErr := parseRawNumber(tt.input)\n\t\t\tif gotNum != tt.wantNum {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got number = %q, want %q\", tt.input, gotNum, tt.wantNum)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got tail = %q, want %q\", tt.input, gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif (gotErr == nil \u0026\u0026 tt.wantErr != nil) || (gotErr != nil \u0026\u0026 tt.wantErr == nil) || (gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error()) {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got error = %v, want %v\", tt.input, gotErr, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}\n","813b6cc65bfab253187227574002ee26":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Get(t *testing.T) {\n\tt.Run(\"null\", func(t *testing.T) {\n\t\tv := \u0026Value{t: TypeNull}\n\t\tif v.Get(\"foo\") != nil {\n\t\t\tt.Errorf(\"expected nil, got %v\", v.Get(\"foo\"))\n\t\t}\n\t})\n\n\tt.Run(\"object\", func(t *testing.T) {\n\t\tv := \u0026Value{\n\t\t\tt: TypeObject,\n\t\t\to: Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"foo\", v: \u0026Value{t: TypeString, s: \"bar\"}},\n\t\t\t\t\t{k: \"baz\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\n\t\tt.Run(\"existing key\", func(t *testing.T) {\n\t\t\tif got := v.Get(\"foo\"); got.s != \"bar\" {\n\t\t\t\tt.Errorf(\"expected 'bar', got '%s'\", got.s)\n\t\t\t}\n\t\t})\n\n\t\tt.Run(\"non-existing key\", func(t *testing.T) {\n\t\t\tif got := v.Get(\"nonexisting\"); got != nil {\n\t\t\t\tt.Errorf(\"expected nil, got %v\", got)\n\t\t\t}\n\t\t})\n\n\t\tt.Run(\"nested key\", func(t *testing.T) {\n\t\t\tv := \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"parent\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{k: \"child\", v: \u0026Value{t: TypeString, s: \"value\"}},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}\n\t\t\tif got := v.Get(\"parent\", \"child\"); got.s != \"value\" {\n\t\t\t\tt.Errorf(\"expected 'value', got '%s'\", got)\n\t\t\t}\n\t\t})\n\t})\n\n\tt.Run(\"array\", func(t *testing.T) {\n\t\tv := \u0026Value{\n\t\t\tt: TypeArray,\n\t\t\ta: []*Value{\n\t\t\t\t{t: TypeString, s: \"foo\"},\n\t\t\t\t{t: TypeNumber, s: \"123\"},\n\t\t\t},\n\t\t}\n\n\t\tt.Run(\"valid index\", func(t *testing.T) {\n\t\t\tif got := v.Get(\"1\"); got.s != \"123\" {\n\t\t\t\tt.Errorf(\"expected '123', got '%s'\", got.s)\n\t\t\t}\n\t\t})\n\n\t\tt.Run(\"invalid index\", func(t *testing.T) {\n\t\t\tif got := v.Get(\"2\"); got != nil {\n\t\t\t\tt.Errorf(\"expected nil, got %v\", got)\n\t\t\t}\n\t\t})\n\n\t\tt.Run(\"negative index\", func(t *testing.T) {\n\t\t\tif got := v.Get(\"-1\"); got != nil {\n\t\t\t\tt.Errorf(\"expected nil, got %v\", got)\n\t\t\t}\n\t\t})\n\n\t\tt.Run(\"non-numeric index\", func(t *testing.T) {\n\t\t\tif got := v.Get(\"abc\"); got != nil {\n\t\t\t\tt.Errorf(\"expected nil, got %v\", got)\n\t\t\t}\n\t\t})\n\t})\n\n\tt.Run(\"other types\", func(t *testing.T) {\n\t\tfor _, tt := range []struct {\n\t\t\ttyp Type\n\t\t}{\n\t\t\t{typ: TypeString},\n\t\t\t{typ: TypeNumber},\n\t\t\t{typ: TypeTrue},\n\t\t\t{typ: TypeFalse},\n\t\t} {\n\t\t\tt.Run(tt.typ.String(), func(t *testing.T) {\n\t\t\t\tv := \u0026Value{t: tt.typ}\n\t\t\t\tif got := v.Get(\"foo\"); got != nil {\n\t\t\t\t\tt.Errorf(\"expected nil, got %v\", got)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t})\n}","8177a350d4c4cce2597cc004623711f5":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey   string\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Basic cases\n\t\t{`\"foo\"bar`, \"foo\", \"bar\", nil},\n\t\t{`\"foo\" bar`, \"foo\", \" bar\", nil},\n\t\t{`\"foo\"  bar`, \"foo\", \"  bar\", nil},\n\n\t\t// Escaped quotes\n\t\t{`\"foo\\\"bar\"baz`, `foo\"bar`, \"baz\", nil},\n\t\t{`\"foo\\\\bar\"baz`, `foo\\bar`, \"baz\", nil},\n\t\t{`\"foo\\\\\\bar\"baz`, `foo\\\\bar`, \"baz\", nil},\n\t\t{`\"foo\\\\\\\\bar\"baz`, `foo\\\\bar`, \"baz\", nil},\n\n\t\t// Invalid cases\n\t\t{`\"foo`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo\"bar\"`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo\\\",`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d:%s\", i, tt.input), func(t *testing.T) {\n\t\t\tkey, tail, err := parseRawString(tt.input)\n\t\t\tif key != tt.key || tail != tt.tail || !equalError(err, tt.err) {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = (%q, %q, %v), want (%q, %q, %v)\", tt.input, key, tail, err, tt.key, tt.tail, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// equalError reports whether errors a and b are equal.\n// They're equal if both are nil, or both are not nil and a.Error() == b.Error().\nfunc equalError(a, b error) bool {\n\treturn a == nil \u0026\u0026 b == nil || a != nil \u0026\u0026 b != nil \u0026\u0026 a.Error() == b.Error()\n}\n","829f3bee55cc6c18e8df104328bf5e2b":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput  string\n\t\texpect string\n\t\ttail   string\n\t\terr    error\n\t}{\n\t\t{``, ``, ``, fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"`, ``, ``, fmt.Errorf(`missing closing '\"'`)},\n\t\t{`abc`, `abc`, ``, nil},\n\t\t{`\"abc`, ``, ``, fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"abc\"`, `abc`, ``, nil},\n\t\t{`\"abc\"d`, `abc`, `d`, nil},\n\t\t{`ab\"c\"d`, `ab\"c\"d`, ``, nil},\n\t\t{`\"ab\\\"c\"d`, `ab\"c`, `d`, nil},\n\t\t{`\"ab\\\\\"c\"d`, `ab\\\\`, `c\"d`, nil},\n\t\t{`\"ab\\\\\\\"\"c\"d`, `ab\\\"\"c`, `d`, nil},\n\t\t{`\"\\\\\"`, `\\`, ``, nil},\n\t\t{`\"\\\\\\\"\"`, `\\\"`, ``, nil},\n\t\t{`\"\\\\\\\"`, `\\\\`, `\"`, nil},\n\t}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test_%d\", i), func(t *testing.T) {\n\t\t\ts, tail, err := parseRawString(tt.input)\n\t\t\tif s != tt.expect {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tt.expect, s)\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tt.tail, tail)\n\t\t\t}\n\t\t\tif err != nil \u0026\u0026 tt.err == nil || err == nil \u0026\u0026 tt.err != nil {\n\t\t\t\tt.Errorf(\"expected error '%v', got '%v'\", tt.err, err)\n\t\t\t}\n\t\t})\n\t}\n}\n","8357f5d24e1cdb9aefc22a135c1b9466":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic escapes\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\t`, \"\\t\"},\n\t\t{`\\\\`, \"\\\\\"},\n\t\t{`\\\"`, \"\\\"\"},\n\t\t{`\\/`, \"/\"},\n\t\t{`\\b`, \"\\b\"},\n\t\t{`\\f`, \"\\f\"},\n\t\t{`\\r`, \"\\r\"},\n\n\t\t// Unicode escapes\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A0`, \"\\u00A0\"},\n\t\t{`\\u20AC`, \"\\u20AC\"},\n\t\t{`\\uD83D\\uDE02`, \"\\U0001F602\"}, // Surrogate pair\n\n\t\t// Handling of invalid escapes\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u`, `\\u`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\uD83D`, `\\uD83D`},\n\t\t{`\\uD83D\\u`, `\\uD83D\\u`},\n\t\t{`\\uD83D\\u123`, `\\uD83D\\u123`},\n\n\t\t// Combinations and real-world examples\n\t\t{`Hello\\tworld\\n`, \"Hello\\tworld\\n\"},\n\t\t{`{\"key\": \"value with \\\\ and \\\"\"}`, `{\"key\": \"value with \\\\ and \\\"\"}`},\n\t\t{`Path: \"C:\\\\Program Files\\\\\"}`, `Path: \"C:\\\\Program Files\\\\\"}`},\n\t}\n\n\tfor i, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Test %d: Expected '%s', got '%s'\", i+1, test.expected, actual)\n\t\t}\n\t}\n}","846b5a8936b60cdcefab9152a8a78e08":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantN    string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Empty input.\n\t\t{\"\", \"\", \"\", nil},\n\n\t\t// Valid numbers.\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"123.456\", \"123.456\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"123e4\", \"123e4\", \"\", nil},\n\t\t{\"123E4\", \"123E4\", \"\", nil},\n\t\t{\"123e+4\", \"123e+4\", \"\", nil},\n\t\t{\"123e-4\", \"123e-4\", \"\", nil},\n\t\t{\"+123\", \"+123\", \"\", nil},\n\n\t\t// Valid numbers with trailing characters.\n\t\t{\"123a\", \"123\", \"a\", nil},\n\t\t{\"123.456a\", \"123.456\", \"a\", nil},\n\t\t{\"-123a\", \"-123\", \"a\", nil},\n\n\t\t// Invalid numbers.\n\t\t{\"a123\", \"\", \"a123\", fmt.Errorf(`unexpected char: \"a\"`)},\n\t\t{\".123\", \"\", \".123\", fmt.Errorf(`unexpected char: \".\"`)},\n\n\t\t// Special cases.\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"Inf\", \"Inf\", \"\", nil},\n\t\t{\"iNf\", \"iNf\", \"\", nil},\n\t\t{\"inF\", \"inF\", \"\", nil},\n\t\t{\"INF\", \"INF\", \"\", nil},\n\t\t{\"infinity\", \"inf\", \"inity\", nil},\n\t\t{\"Infinity\", \"Inf\", \"inity\", nil},\n\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"NaN\", \"NaN\", \"\", nil},\n\t\t{\"nAn\", \"nAn\", \"\", nil},\n\t\t{\"naN\", \"naN\", \"\", nil},\n\t\t{\"NAN\", \"NAN\", \"\", nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tgotN, gotTail, gotErr := parseRawNumber(tt.input)\n\t\t\tif gotN != tt.wantN {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got number = %q, want %q\", tt.input, gotN, tt.wantN)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got tail = %q, want %q\", tt.input, gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif gotErr == nil \u0026\u0026 tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got err = nil, want %v\", tt.input, tt.wantErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr == nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got err = %v, want nil\", tt.input, gotErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got err = %v, want %v\", tt.input, gotErr, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","85860e752a54f3e60b619400d8ea0e22":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantN    string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Valid numbers\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"123.456\", \"123.456\", \"\", nil},\n\t\t{\"1.2e3\", \"1.2e3\", \"\", nil},\n\t\t{\"1.2E-3\", \"1.2E-3\", \"\", nil},\n\t\t{\"+123\", \"+123\", \"\", nil},\n\n\t\t// Valid numbers with trailing characters\n\t\t{\"123a\", \"123\", \"a\", nil},\n\t\t{\"-123b\", \"-123\", \"b\", nil},\n\t\t{\"123.456c\", \"123.456\", \"c\", nil},\n\n\t\t// Invalid numbers\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t\t{\"a\", \"\", \"a\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\"-\", \"\", \"-\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t\t{\"+\", \"\", \"+\", fmt.Errorf(\"unexpected char: %q\", \"+\")},\n\t\t{\"1.2e\", \"\", \"1.2e\", nil},\n\n\t\t// Valid inf/nan cases\n\t\t{\"inf\", \"in\", \"f\", nil},\n\t\t{\"+inf\", \"+in\", \"f\", nil},\n\t\t{\"-inf\", \"-in\", \"f\", nil},\n\t\t{\"InF\", \"In\", \"F\", nil},\n\t\t{\"+InF\", \"+In\", \"F\", nil},\n\t\t{\"-InF\", \"-In\", \"F\", nil},\n\t\t{\"nan\", \"na\", \"n\", nil},\n\t\t{\"+nan\", \"+na\", \"n\", nil},\n\t\t{\"-nan\", \"-na\", \"n\", nil},\n\t\t{\"nAn\", \"nA\", \"n\", nil},\n\t\t{\"+nAn\", \"+nA\", \"n\", nil},\n\t\t{\"-nAn\", \"-nA\", \"n\", nil},\n\n\t\t// Invalid inf/nan cases (less than 3 characters after sign)\n\t\t{\"in\", \"\", \"in\", fmt.Errorf(\"unexpected char: %q\", \"i\")},\n\t\t{\"+i\", \"\", \"+i\", fmt.Errorf(\"unexpected char: %q\", \"+i\")},\n\t\t{\"-i\", \"\", \"-i\", fmt.Errorf(\"unexpected char: %q\", \"-i\")},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d:%s\", i, tt.input), func(t *testing.T) {\n\t\t\tgotN, gotTail, gotErr := parseRawNumber(tt.input)\n\t\t\tif gotN != tt.wantN {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got number = %q, want %q\", tt.input, gotN, tt.wantN)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got tail = %q, want %q\", tt.input, gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif gotErr == nil \u0026\u0026 tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got err = nil, want %v\", tt.input, tt.wantErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr == nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got err = %v, want nil\", tt.input, gotErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got err = %v, want %v\", tt.input, gotErr, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}\n","867153df9b6a69ea618b77a3fc27945c":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantN    string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"123.456\", \"123.456\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"+123\", \"+123\", \"\", nil},\n\t\t{\"1.2e+3\", \"1.2e+3\", \"\", nil},\n\t\t{\"1.2E-3\", \"1.2E-3\", \"\", nil},\n\t\t{\"123abc\", \"123\", \"abc\", nil},\n\t\t{\"123.456abc\", \"123.456\", \"abc\", nil},\n\t\t{\"-123abc\", \"-123\", \"abc\", nil},\n\t\t{\"+123abc\", \"+123\", \"abc\", nil},\n\t\t{\"1.2e+3abc\", \"1.2e+3\", \"abc\", nil},\n\t\t{\"1.2E-3abc\", \"1.2E-3\", \"abc\", nil},\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"+inf\", \"+inf\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"InFiNiTy\", \"InFiNiTy\", \"\", nil},\n\t\t{\"infi\", \"\", \"infi\", fmt.Errorf(\"unexpected char: %q\", \"i\")},\n\t\t{\"infin\", \"\", \"infin\", fmt.Errorf(\"unexpected char: %q\", \"i\")},\n\t\t{\"+infin\", \"\", \"+infin\", fmt.Errorf(\"unexpected char: %q\", \"+\")},\n\t\t{\"-infin\", \"\", \"-infin\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"+nan\", \"+nan\", \"\", nil},\n\t\t{\"-nan\", \"-nan\", \"\", nil},\n\t\t{\"NaN\", \"NaN\", \"\", nil},\n\t\t{\"nani\", \"\", \"nani\", fmt.Errorf(\"unexpected char: %q\", \"n\")},\n\t\t{\"nann\", \"\", \"nann\", fmt.Errorf(\"unexpected char: %q\", \"n\")},\n\t\t{\"+nann\", \"\", \"+nann\", fmt.Errorf(\"unexpected char: %q\", \"+\")},\n\t\t{\"-nann\", \"\", \"-nann\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test %d\", i), func(t *testing.T) {\n\t\t\tgotN, gotTail, gotErr := parseRawNumber(tt.input)\n\t\t\tif gotN != tt.wantN {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) gotN = %v, want %v\", tt.input, gotN, tt.wantN)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) gotTail = %v, want %v\", tt.input, gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif gotErr == nil \u0026\u0026 tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) gotErr = nil, want %v\", tt.input, tt.wantErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr == nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) gotErr = %v, want nil\", tt.input, gotErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) gotErr = %v, want %v\", tt.input, gotErr, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","8717eb40e7c5b1502a86c46aec6f0a2f":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic tests\n\t\t{`\"foo\"`, \"foo\"},\n\t\t{`\"fo\\no\"`, \"fo\\no\"},\n\t\t{`\"fo\\\\o\"`, `fo\\o`},\n\t\t{`\"fo\\ro\"`, \"fo\\ro\"},\n\t\t{`\"fo\\to\"`, \"fo\\to\"},\n\n\t\t// Unicode tests\n\t\t{`\"\\u0041\"`, \"A\"},\n\t\t{`\"\\u041f\"`, \"–ü\"},\n\t\t{`\"\\u20AC\"`, \"‚Ç¨\"},\n\t\t{`\"\\uD83D\\uDE02\"`, \"üòÇ\"}, // Surrogate pair\n\n\t\t// Invalid unicode tests\n\t\t{`\"\\u123\"`, `\\u123`},     // Invalid length\n\t\t{`\"\\u123g\"`, `\\u123g`},   // Invalid hex\n\t\t{`\"\\uD800\"`, `\\uD800`},   // Invalid surrogate pair\n\t\t{`\"\\uD800\\u1234\"`, `\\uD800\\u1234`}, // Invalid surrogate pair\n\n\t\t// Mixed tests\n\t\t{`\"foo\\nbar\\\\baz\\t\\u0041\\uD83D\\uDE02\"`, \"foo\\nbar\\\\baz\\tAüòÇ\"},\n\t}\n\n\tfor i, tt := range tests {\n\t\tactual := unescapeStringBestEffort(tt.input)\n\t\tif actual != tt.expected {\n\t\t\tt.Errorf(\"Test %d: Expected %q, got %q\", i, tt.expected, actual)\n\t\t}\n\t}\n}","871e93cc734c52c098de30486d1c84ef":"package fastjson\n\nimport \"testing\"\n\nfunc TestValue_GetFloat64(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tjson  string\n\t\tkeys  []string\n\t\twant  float64\n\t\twant1 bool\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\ts := []byte(tt.json)\n\t\t\tvar p Parser\n\t\t\tv, _ := p.ParseBytes(s)\n\t\t\tgot := v.GetFloat64(tt.keys...)\n\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Value.GetFloat64() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\n\t\t})\n\t}\n}","880ea0b271ad5f9e12e05cf9dcf137a3":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic escapes\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\t`, \"\\t\"},\n\t\t{`\\\\`, \"\\\\\"},\n\t\t{`\\\"`, \"\\\"\"},\n\t\t{`\\/`, \"/\"},\n\n\t\t// Unicode escapes\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A0`, \"\\u00A0\"},\n\t\t{`\\uFFFF`, \"\\uFFFF\"},\n\t\t{`\\uD83D\\uDE02`, \"üòÇ\"}, // Surrogate pair\n\n\t\t// Invalid escapes (should be left as is)\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\uD800`, `\\uD800`}, // Unpaired surrogate\n\n\t\t// Combinations\n\t\t{`Hello\\tworld\\n`, \"Hello\\tworld\\n\"},\n\t\t{`\"This is a string with \\\\backslashes\\\\ and \\u0022quotes\\u0022\"`, \"\\\"This is a string with \\\\backslashes\\\\ and \\\"quotes\\\"\\\"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}","88843da73a4c0686070c97ea98d37280":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ts     string\n\t\terr   error\n\t}{\n\t\t// Empty array\n\t\t{\n\t\t\tinput: \"[]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Simple array\n\t\t{\n\t\t\tinput: \"[1,2,3]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Array with different value types\n\t\t{\n\t\t\tinput: `[1,\"test\",true,null]`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeString, s: \"test\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t\t{t: TypeNull},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\n\t\t// Array with nested array\n\t\t{\n\t\t\tinput: \"[1,[2,3],4]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeArray, a: []*Value{\n\t\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t\t}},\n\t\t\t\t\t{t: TypeNumber, s: \"4\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Invalid array - missing closing bracket\n\t\t{\n\t\t\tinput: \"[1,2,3\",\n\t\t\twant:  nil,\n\t\t\ts:     \"[1,2,3\",\n\t\t\terr:   fmt.Errorf(\"unexpected end of array\"),\n\t\t},\n\t\t// Invalid array - missing comma\n\t\t{\n\t\t\tinput: \"[1 2,3]\",\n\t\t\twant:  nil,\n\t\t\ts:     \" 2,3]\",\n\t\t\terr:   fmt.Errorf(\"missing ',' after array value\"),\n\t\t},\n\t\t// Invalid array - trailing comma\n\t\t{\n\t\t\tinput: \"[1,2,]\",\n\t\t\twant:  nil,\n\t\t\ts:     \",]\",\n\t\t\terr:   fmt.Errorf(\"cannot parse array value: unexpected end of JSON\"),\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tc := \u0026cache{}\n\t\tgot, s, err := parseArray(tt.input, c, 0)\n\t\tif fmt.Sprint(err) != fmt.Sprint(tt.err) {\n\t\t\tt.Errorf(\"Test %d: Expected error '%v', got '%v'\", i, tt.err, err)\n\t\t}\n\t\tif s != tt.s {\n\t\t\tt.Errorf(\"Test %d: Expected remaining string '%s', got '%s'\", i, tt.s, s)\n\t\t}\n\t\tif !equalValues(got, tt.want) {\n\t\t\tt.Errorf(\"Test %d: Expected value '%+v', got '%+v'\", i, tt.want, got)\n\t\t}\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.s != v2.s {\n\t\treturn false\n\t}\n\n\tif v1.t == TypeArray {\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\t// Add other type comparisons if needed\n\treturn true\n}","88b3d88545e7b71fef3f2ddd387f7e6d":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey string\n\t\tvalue string\n\t\terr error\n\t}{\n\t\t// Basic cases\n\t\t{`\"foo\"bar`, \"foo\", \"bar\", nil},\n\t\t{`\"foo\" bar`, \"foo\", \" bar\", nil},\n\t\t{`\"foo\"  bar`, \"foo\", \"  bar\", nil},\n\n\t\t// Escaped quotes\n\t\t{`\"fo\\\"o\"bar`, `fo\"o`, \"bar\", nil},\n\t\t{`\"fo\\\\\"o\"bar`, `fo\\\"o`, \"bar\", nil},\n\t\t{`\"fo\\\\\\\\\"o\"bar`, `fo\\\\\"o`, \"bar\", nil},\n\t\t{`\"fo\\\\\\\"o\"bar`, `fo\\\"o`, \"bar\", nil},\n\n\t\t// Invalid cases\n\t\t{`\"foo`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)} ,\n\t\t{`foo\"`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)} ,\n\t\t{`\"fo\"o\"bar`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)} ,\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tkey, value, err := parseRawString(tt.input)\n\t\t\tif key != tt.key || value != tt.value || (err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"Input: %s\\nExpected: %s, %s, %v\\nGot: %s, %s, %v\", tt.input, tt.key, tt.value, tt.err, key, value, err)\n\t\t\t}\n\t\t})\n\t}\n}","88bc848125f2ad9eae9f374f797cdd6d":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic strings\n\t\t{\"hello\", \"hello\"},\n\t\t{\"world\", \"world\"},\n\n\t\t// Escaped characters\n\t\t{`\\\"hello\\\"`, `\"hello\"`},\n\t\t{`\\\\world\\\\`, `\\world\\`},\n\t\t{`\\bfoo\\tbar\\nbaz`, \"\\bfoo\\tbar\\nbaz\"},\n\t\t{`\\u0020`, \" \"},\n\n\t\t// Invalid escape sequences\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\u12345`, `\\u12345`},\n\n\t\t// Surrogate pairs\n\t\t{`\\uD83D\\uDE02`, \"üòÇ\"},\n\t\t{`\\uD83D\\uDE02\\uD83D\\uDE02`, \"üòÇüòÇ\"},\n\n\t\t// Mixed valid and invalid escape sequences\n\t\t{`hello\\nworld\\x`, \"hello\\nworld\\\\x\"},\n\t\t{`\\uD83D\\uDE02\\u1234`, \"üòÇ\\u1234\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tactual := unescapeStringBestEffort(tt.input)\n\t\t\tif actual != tt.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", tt.input, actual, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}","8a73b2899763b71a1e7be8fdde02f4a4":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput  string\n\t\tns     string\n\t\tremain string\n\t\terr    error\n\t}{\n\t\t// Valid numbers\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"123.456\", \"123.456\", \"\", nil},\n\t\t{\"1.2e3\", \"1.2e3\", \"\", nil},\n\t\t{\"1.2E-3\", \"1.2E-3\", \"\", nil},\n\n\t\t// Valid numbers with trailing characters\n\t\t{\"123a\", \"123\", \"a\", nil},\n\t\t{\"-123b\", \"-123\", \"b\", nil},\n\t\t{\"123.456c\", \"123.456\", \"c\", nil},\n\n\t\t// Valid numbers with \"inf\" and \"nan\"\n\t\t{\"inf\", \"\", \"inf\", nil},\n\t\t{\"+inf\", \"\", \"+inf\", nil},\n\t\t{\"-inf\", \"\", \"-inf\", nil},\n\t\t{\"NaN\", \"\", \"NaN\", nil},\n\t\t{\"123inf\", \"123\", \"inf\", nil},\n\t\t{\"-123+inf\", \"-123\", \"+inf\", nil},\n\n\t\t// Invalid numbers\n\t\t{\"a\", \"\", \"a\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\"+\", \"\", \"+\", fmt.Errorf(\"unexpected char: %q\", \"+\")},\n\t\t{\"-\", \"\", \"-\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t\t{\".\", \"\", \".\", fmt.Errorf(\"unexpected char: %q\", \".\")},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tns, remain, err := parseRawNumber(tt.input)\n\t\t\tif tt.err != nil {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"expected error, got nil\")\n\t\t\t\t} else if err.Error() != tt.err.Error() {\n\t\t\t\t\tt.Errorf(\"expected error %q, got %q\", tt.err, err)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t\t}\n\t\t\t\tif ns != tt.ns {\n\t\t\t\t\tt.Errorf(\"expected ns %q, got %q\", tt.ns, ns)\n\t\t\t\t}\n\t\t\t\tif remain != tt.remain {\n\t\t\t\t\tt.Errorf(\"expected remain %q, got %q\", tt.remain, remain)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","8a92d6cf40fb9967c46b22a97cd7d74c":"package fastjson\n\nimport \"testing\"\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"  \\n\\t\\r foo\", \"foo\"},\n\t\t{\"foo\", \"foo\"},\n\t\t(\"  \\n\\t\\r \", \"\"),\n\t\t(\"\", \"\"),\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := skipWSSlow(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"skipWSSlow(%q) = %q, expected %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}\n","8bd5ac54a8d97cb3498cac05c38ebb21":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantNum  string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Valid numbers\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"+123\", \"+123\", \"\", nil},\n\t\t{\"123.456\", \"123.456\", \"\", nil},\n\t\t{\"1.2e3\", \"1.2e3\", \"\", nil},\n\t\t{\"1.2E-3\", \"1.2E-3\", \"\", nil},\n\n\t\t// Valid numbers with trailing characters\n\t\t{\"123a\", \"123\", \"a\", nil},\n\t\t{\"-123!\", \"-123\", \"!\", nil},\n\t\t{\"123.456 \", \"123.456\", \" \", nil},\n\n\t\t// Valid Infinity and NaN\n\t\t{\"Infinity\", \"Infinity\", \"\", nil},\n\t\t{\"+Infinity\", \"+Infinity\", \"\", nil},\n\t\t{\"-Infinity\", \"-Infinity\", \"\", nil},\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"+inf\", \"+inf\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"NaN\", \"NaN\", \"\", nil},\n\n\t\t// Invalid numbers\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t\t{\"a123\", \"\", \"a123\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\"+a123\", \"\", \"+a123\", fmt.Errorf(\"unexpected char: %q\", \"+a\")},\n\t\t{\"-\", \"-\", \"\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t\t{\"+\", \"+\", \"\", fmt.Errorf(\"unexpected char: %q\", \"+\")},\n\t\t{\"in\", \"\", \"in\", fmt.Errorf(\"unexpected char: %q\", \"i\")},\n\t\t{\"+i\", \"\", \"+i\", fmt.Errorf(\"unexpected char: %q\", \"+i\")},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d:%s\", i, tt.input), func(t *testing.T) {\n\t\t\tgotNum, gotTail, gotErr := parseRawNumber(tt.input)\n\n\t\t\tif gotNum != tt.wantNum {\n\t\t\t\tt.Errorf(\"parseRawNumber(%s) got number = %v, want %v\", tt.input, gotNum, tt.wantNum)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseRawNumber(%s) got tail = %v, want %v\", tt.input, gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif gotErr == nil \u0026\u0026 tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%s) got no error, want %v\", tt.input, tt.wantErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr == nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%s) got error = %v, want no error\", tt.input, gotErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"parseRawNumber(%s) got error = %v, want %v\", tt.input, gotErr, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","8cebbaf56eed54ae7ac1f41dc7bca55a":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey   string\n\t\tvalue string\n\t\terr   error\n\t}{\n\t\t{`\"foo\"bar`, \"foo\", \"bar\", nil},\n\t\t{`\"fo\\o\"bar`, \"fo\\o\", \"bar\", nil},\n\t\t{`\"foo\\\"bar\"baz`, `foo\"bar`, \"baz\", nil},\n\t\t{`\"foo\\\\\"bar`, `foo\\\\`, \"bar\", nil},\n\t\t{`\"foo\"`, \"foo\", \"\", nil},\n\t\t{`foo`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\\\"foo\"`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test %d\", i), func(t *testing.T) {\n\t\t\tkey, value, err := parseRawString(tt.input)\n\t\t\tif key != tt.key || value != tt.value || ((err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err == nil)) {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = (%q, %q, %v), want (%q, %q, %v)\", tt.input, key, value, err, tt.key, tt.value, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}","8e7a2d1d824892a379375c34369f029f":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput    string\n\t\twantObj  string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Empty object\n\t\t{\n\t\t\tinput:    \"{}\",\n\t\t\twantObj:  \"{}\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t// Simple object\n\t\t{\n\t\t\tinput:    `{\"key1\":\"value1\", \"key2\":\"value2\"}`,\n\t\t\twantObj:  `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t// Object with nested object\n\t\t{\n\t\t\tinput:    `{\"key1\":\"value1\", \"key2\":{\"nestedKey\":\"nestedValue\"}}`,\n\t\t\twantObj:  `{\"key1\": \"value1\", \"key2\": {\"nestedKey\": \"nestedValue\"}}`,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t// Object with array\n\t\t{\n\t\t\tinput:    `{\"key1\":\"value1\", \"key2\":[\"item1\", \"item2\"]}`,\n\t\t\twantObj:  `{\"key1\": \"value1\", \"key2\": [\"item1\", \"item2\"]}`,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t// Invalid object: missing closing brace\n\t\t{\n\t\t\tinput:    `{\"key1\":\"value1\"`,\n\t\t\twantObj:  \"\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t\t// Invalid object: missing colon\n\t\t{\n\t\t\tinput:    `{\"key1\" \"value1\"}`,\n\t\t\twantObj:  \"\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t\t// Invalid object: missing comma\n\t\t{\n\t\t\tinput:    `{\"key1\":\"value1\" \"key2\":\"value2\"}`,\n\t\t\twantObj:  \"\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"TestCase_%d\", i+1), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgotObj, gotTail, gotErr := parseObject(tc.input, c, 0)\n\n\t\t\t// Check for error\n\t\t\tif gotErr != nil {\n\t\t\t\tif tc.wantErr == nil {\n\t\t\t\t\tt.Errorf(\"unexpected error: %v, want: %v\", gotErr, tc.wantErr)\n\t\t\t\t} else if gotErr.Error() != tc.wantErr.Error() {\n\t\t\t\t\tt.Errorf(\"got error: %v, want: %v\", gotErr, tc.wantErr)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// If no error, check object and tail\n\t\t\tif gotObj == nil {\n\t\t\t\tt.Errorf(\"got nil object, want: %v\", tc.wantObj)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgotObjStr := gotObj.String()\n\t\t\tif gotObjStr != tc.wantObj {\n\t\t\t\tt.Errorf(\"got object: %q, want: %q\", gotObjStr, tc.wantObj)\n\t\t\t}\n\n\t\t\tif gotTail != tc.wantTail {\n\t\t\t\tt.Errorf(\"got tail: %q, want: %q\", gotTail, tc.wantTail)\n\t\t\t}\n\t\t})\n\t}\n}\n","8eae25ac5e53288751b9137800585cf9":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantVal  *Value\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t//TODO: Add test cases for function ParseValue.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgotVal, gotTail, err := parseValue(tt.input, c, 0)\n\t\t\tif (err != nil) != (tt.wantErr != nil) {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 err.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif fmt.Sprintf(\"%v\", gotVal) != fmt.Sprintf(\"%v\", tt.wantVal) {\n\t\t\t\tt.Errorf(\"parseValue() gotVal = %v, want %v\", gotVal, tt.wantVal)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseValue() gotTail = %v, want %v\", gotTail, tt.wantTail)\n\t\t\t}\n\t\t})\n\t}\n}\n","8f3577abc1e9b4953cc10e31b104475d":"package fastjson\n\nimport \"testing\"\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"  foo\", \"foo\"},\n\t\t{\"\\n\\t bar\", \"bar\"},\n\t\t{\"\\r \\t  baz\", \"baz\"},\n\t\t{\"qux\", \"qux\"},\n\t\t{\"\", \"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := skipWSSlow(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"skipWSSlow(%q) = %q, expected %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}","8f686768662947d3b2eeeb2bfd5865e5":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic escapes\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\t`, \"\\t\"},\n\t\t{`\\\\`, \"\\\\\"},\n\t\t{`\\\"`, \"\\\"\"},\n\t\t{`\\/`, \"/\"},\n\n\t\t// Unicode escapes\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A9`, \"¬©\"},\n\t\t{`\\u20AC`, \"‚Ç¨\"},\n\n\t\t// Surrogate pairs\n\t\t{`\\uD83D\\uDE01`, \"üòÅ\"},\n\n\t\t// Invalid escapes\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\uD800`, `\\uD800`}, // Invalid surrogate pair\n\t\t{`\\uD800\\u1234`, `\\uD800\\u1234`}, // Invalid surrogate pair\n\n\t\t// Mixed escapes\n\t\t{`Hello\\tworld\\n`, \"Hello\\tworld\\n\"},\n\t\t{`This is a \\\"test\\\" string.`, \"This is a \\\"test\\\" string.\"},\n\t\t{`C:\\path\\to\\file.txt`, `C:\\path\\to\\file.txt`},\n\n\t\t// No escapes\n\t\t{`This is a normal string.`, \"This is a normal string.\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}","9077a4076d664e3c106ffc6a35892930":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantN    string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"123.456\", \"123.456\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"+123\", \"+123\", \"\", nil},\n\t\t{\"1.2e3\", \"1.2e3\", \"\", nil},\n\t\t{\"1.2E-3\", \"1.2E-3\", \"\", nil},\n\t\t{\"123a\", \"123\", \"a\", nil},\n\t\t{\"123.456a\", \"123.456\", \"a\", nil},\n\t\t{\"-123a\", \"-123\", \"a\", nil},\n\t\t{\"+123a\", \"+123\", \"a\", nil},\n\t\t{\"1.2e3a\", \"1.2e3\", \"a\", nil},\n\t\t{\"1.2E-3a\", \"1.2E-3\", \"a\", nil},\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"+inf\", \"+inf\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"InF\", \"InF\", \"\", nil},\n\t\t{\"inF\", \"inF\", \"\", nil},\n\t\t{\"+inF\", \"+inF\", \"\", nil},\n\t\t{\"-inF\", \"-inF\", \"\", nil},\n\t\t{\"Infin\", \"Infin\", \"\", nil},\n\t\t{\"infin\", \"infin\", \"\", nil},\n\t\t{\"+Infin\", \"+Infin\", \"\", nil},\n\t\t{\"-Infin\", \"-Infin\", \"\", nil},\n\t\t{\"+infin\", \"+infin\", \"\", nil},\n\t\t{\"-infin\", \"-infin\", \"\", nil},\n\t\t{\"Infinity\", \"Infinity\", \"\", nil},\n\t\t{\"infinity\", \"infinity\", \"\", nil},\n\t\t{\"+Infinity\", \"+Infinity\", \"\", nil},\n\t\t{\"-Infinity\", \"-Infinity\", \"\", nil},\n\t\t{\"+infinity\", \"+infinity\", \"\", nil},\n\t\t{\"-infinity\", \"-infinity\", \"\", nil},\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"+nan\", \"+nan\", \"\", nil},\n\t\t{\"-nan\", \"-nan\", \"\", nil},\n\t\t{\"NaN\", \"NaN\", \"\", nil},\n\t\t{\"nAn\", \"nAn\", \"\", nil},\n\t\t{\"+nAn\", \"+nAn\", \"\", nil},\n\t\t{\"-nAn\", \"-nAn\", \"\", nil},\n\t\t{\"naN\", \"naN\", \"\", nil},\n\t\t{\"nAN\", \"nAN\", \"\", nil},\n\t\t{\"+naN\", \"+naN\", \"\", nil},\n\t\t{\"-naN\", \"-naN\", \"\", nil},\n\t\t{\"+nAN\", \"+nAN\", \"\", nil},\n\t\t{\"-nAN\", \"-nAN\", \"\", nil},\n\t\t{\"NAN\", \"NAN\", \"\", nil},\n\t\t{\"Nan\", \"Nan\", \"\", nil},\n\t\t{\"+NAN\", \"+NAN\", \"\", nil},\n\t\t{\"-NAN\", \"-NAN\", \"\", nil},\n\t\t{\"+Nan\", \"+Nan\", \"\", nil},\n\t\t{\"-Nan\", \"-Nan\", \"\", nil},\n\t\t{\"in\", \"\", \"in\", fmt.Errorf(\"unexpected char: %q\", \"i\")},\n\t\t{\"+i\", \"\", \"+i\", fmt.Errorf(\"unexpected char: %q\", \"+\")},\n\t\t{\"-i\", \"\", \"-i\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d:%s\", i, tt.input), func(t *testing.T) {\n\t\t\tgotN, gotTail, gotErr := parseRawNumber(tt.input)\n\t\t\tif gotN != tt.wantN {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotN = %v, want %v\", gotN, tt.wantN)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotTail = %v, want %v\", gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif gotErr == nil \u0026\u0026 tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotErr = nil, want %v\", tt.wantErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr == nil {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotErr = %v, want nil\", gotErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotErr = %v, want %v\", gotErr, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","90accc99b0223bbeeeeba3f4b5a0306c":"package fastjson\n\nimport \"testing\"\n\nfunc TestObject_reset(t *testing.T) {\n\to := \u0026Object{\n\t\tkvs:           make([]kv, 2),\n\t\tkeysUnescaped: true,\n\t}\n\to.reset()\n\n\tif len(o.kvs) != 1 {\n\t\tt.Errorf(\"Expected kvs length 1 after reset, got %d\", len(o.kvs))\n\t}\n\n\tif o.keysUnescaped != false {\n\t\tt.Errorf(\"Expected keysUnescaped to be false after reset\")\n\t}\n}","927442f535b7e4a37d3a499635756263":"package fastjson\n\nimport \"testing\"\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"  foo\", \"foo\"},\n\t\t{\"\\n\\t bar\", \"bar\"},\n\t\t{\"baz  \", \"baz  \"},\n\t\t{\"\\r\\nqux\", \"qux\"},\n\t\t{\"\", \"\"},\n\t\t{\"  \", \"\"},\n\t}\n\n\tfor _, tc := range tests {\n\t\tactual := skipWSSlow(tc.input)\n\t\tif actual != tc.expected {\n\t\t\tt.Errorf(\"skipWSSlow(%q) = %q, expected %q\", tc.input, actual, tc.expected)\n\t\t}\n\t}\n}","931de4c9bc95fb1424329131cacd818c":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic escapes\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\t`, \"\\t\"},\n\t\t{`\\\\`, `\\`},\n\t\t{`\\\"`, `\"`},\n\t\t{`\\/`, `/`},\n\n\t\t// Unicode escapes\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A0`, \"\\u00A0\"},\n\t\t{`\\u20AC`, \"\\u20AC\"},\n\n\t\t// Surrogate pairs\n\t\t{`\\uD83D\\uDE01`, \"\\U0001F601\"},\n\n\t\t// Invalid escapes\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\uD800`, `\\uD800`},\n\t\t{`\\uD800\\u`, `\\uD800\\u`},\n\n\t\t// Mixed strings\n\t\t{`Hello\\tworld\\n`, \"Hello\\tworld\\n\"},\n\t\t{`\"This is a \\\\test\\\\\"`, `\"This is a \\test\\\"`},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}\n","944cf59ea2ceb697831d45af4347d2e0":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantVal  string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Basic cases\n\t\t{`\"hello\" world`, \"hello\", \" world\", nil},\n\t\t{`\"hello world\"`, \"hello world\", \"\", nil},\n\t\t{`\"\" world`, \"\", \" world\", nil},\n\n\t\t// Escaped quotes\n\t\t{`\"hello \\\"world\\\"\"`, `hello \"world\"`, \"\", nil},\n\t\t{`\"hello\\\\\"world\"`, `hello\\`, `world\"`, nil},\n\t\t{`\"hello\\\\\\\\\"world\"`, `hello\\\\`, `world\"`, nil},\n\n\t\t// Missing closing quote\n\t\t{`\"hello world`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"hello \\\"world`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\n\t\t// Empty string\n\t\t{`\"\"`, \"\", \"\", nil},\n\n\t\t// Only quote\n\t\t{`\"`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tgotVal, gotTail, gotErr := parseRawString(tt.input)\n\n\t\t\tif gotVal != tt.wantVal {\n\t\t\t\tt.Errorf(\"Test %d - Value mismatch. Want: %q, Got: %q\", i, tt.wantVal, gotVal)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"Test %d - Tail mismatch. Want: %q, Got: %q\", i, tt.wantTail, gotTail)\n\t\t\t}\n\t\t\tif gotErr != nil \u0026\u0026 tt.wantErr == nil {\n\t\t\t\tt.Errorf(\"Test %d - Unexpected error: %v\", i, gotErr)\n\t\t\t} else if gotErr == nil \u0026\u0026 tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"Test %d - Expected error but got none\", i)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"Test %d - Error mismatch. Want: %v, Got: %v\", i, tt.wantErr, gotErr)\n\t\t\t}\n\t\t})\n\t}\n}\n","95389a6837d9eb3a84111077fcf4a879":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantN    string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"123.456\", \"123.456\", \"\", nil},\n\t\t{\"1.23e+4\", \"1.23e+4\", \"\", nil},\n\t\t{\"1.23e-4\", \"1.23e-4\", \"\", nil},\n\t\t{\"123a\", \"123\", \"a\", nil},\n\t\t{\"-123a\", \"-123\", \"a\", nil},\n\t\t{\"+123a\", \"+123\", \"a\", nil},\n\t\t{\"123.456a\", \"123.456\", \"a\", nil},\n\t\t{\"1.23e+4a\", \"1.23e+4\", \"a\", nil},\n\t\t{\"1.23e-4a\", \"1.23e-4\", \"a\", nil},\n\t\t{\"NaN\", \"NaN\", \"\", nil},\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"nAn\", \"nAn\", \"\", nil},\n\t\t{\"+123Na\", \"+123\", \"Na\", nil},\n\t\t{\"+123n\", \"+123\", \"n\", nil},\n\t\t{\"+n\", \"\", \"+n\", fmt.Errorf(`unexpected char: \"+\"`)},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tgotN, gotTail, gotErr := parseRawNumber(tt.input)\n\t\t\tif gotN != tt.wantN || gotTail != tt.wantTail || (gotErr != nil \u0026\u0026 tt.wantErr == nil) || (gotErr == nil \u0026\u0026 tt.wantErr != nil) || (gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error()) {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = (%q, %q, %v), want (%q, %q, %v)\", tt.input, gotN, gotTail, gotErr, tt.wantN, tt.wantTail, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","962a6598fdf73728f2ed67799af5edd1":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\tvar p Parser\n\n\ttestCases := []struct {\n\t\tinput string\n\t\twant  string\n\t\terr   bool\n\t}{\n\t\t{\n\t\t\tinput: \"null\",\n\t\t\twant:  \"null\",\n\t\t},\n\t\t{\n\t\t\tinput: \"true\",\n\t\t\twant:  \"true\",\n\t\t},\n\t\t{\n\t\t\tinput: `\"foo\"`,\n\t\t\twant:  `\"foo\"`,\n\t\t},\n\t\t{\n\t\t\tinput: \"123\",\n\t\t\twant:  \"123\",\n\t\t},\n\t\t{\n\t\t\tinput: `{\"foo\": \"bar\"}`,\n\t\t\twant:  `{\"foo\":\"bar\"}`,\n\t\t},\n\t\t{\n\t\t\tinput: `[1, \"foo\", true]`,\n\t\t\twant:  `[1,\"foo\",true]`,\n\t\t},\n\n\t\t// error cases\n\t\t{\n\t\t\tinput: \"invalid json\",\n\t\t\terr:   true,\n\t\t},\n\t\t{\n\t\t\tinput: `\"unterminated string`,\n\t\t\terr:   true,\n\t\t},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tv, err := p.Parse(tc.input)\n\t\tif tc.err {\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"test %d: expected error, got nil\", i)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tif err != nil {\n\t\t\tt.Errorf(\"test %d: unexpected error: %v\", i, err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif got := string(v.MarshalTo(nil)); got != tc.want {\n\t\t\tt.Errorf(\"test %d: want: %s, got: %s\", i, tc.want, got)\n\t\t}\n\t}\n}","973c84c52e171785247ca35616aa1d1f":"package fastjson\n\nimport \"testing\"\n\nfunc TestSkipWS(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"  foo\", \"foo\"},\n\t\t{\"\\n\\tbar\", \"bar\"},\n\t\t{\" \\r\\n baz\", \"baz\"},\n\t\t{\"qux  \", \"qux  \"},\n\t\t{\"quux\", \"quux\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := skipWS(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"skipWS(%q) = %q, want %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}","97f2c7add671ebe3902cf2bb0b7a7f33":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantObj  string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t{\n\t\t\tname:     \"EmptyObject\",\n\t\t\tinput:    \"{}\",\n\t\t\twantObj:  `{\"o\": {}, \"t\": 1}`,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"SimpleObject\",\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\twantObj:  `{\"o\": {\"kvs\": [{\"k\": \"key\", \"v\": {\"s\": \"value\", \"t\": 3}}]}, \"t\": 1}`,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"ComplexObject\",\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 123, \"key3\": true}`,\n\t\t\twantObj:  `{\"o\": {\"kvs\": [{\"k\": \"key1\", \"v\": {\"s\": \"value1\", \"t\": 3}}, {\"k\": \"key2\", \"v\": {\"s\": \"123\", \"t\": 4}}, {\"k\": \"key3\", \"v\": {\"t\": 5}}]}, \"t\": 1}`,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"NestedObject\",\n\t\t\tinput:    `{\"key1\": {\"key2\": \"value2\"}, \"key3\": \"value3\"}`,\n\t\t\twantObj:  `{\"o\": {\"kvs\": [{\"k\": \"key1\", \"v\": {\"o\": {\"kvs\": [{\"k\": \"key2\", \"v\": {\"s\": \"value2\", \"t\": 3}}]}, \"t\": 1}}, {\"k\": \"key3\", \"v\": {\"s\": \"value3\", \"t\": 3}}]}, \"t\": 1}`,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"MissingQuote\",\n\t\t\tinput:    \"{key: \"value\"}\",\n\t\t\twantObj:  \"\",\n\t\t\twantTail: \"{key: \\\"value\\\"}\",\n\t\t\twantErr:  fmt.Errorf(`cannot find opening '\"\" for object key`),\n\t\t},\n\t\t{\n\t\t\tname:     \"MissingColon\",\n\t\t\tinput:    `{\"key\" \"value\"}`,\n\t\t\twantObj:  \"\",\n\t\t\twantTail: `\"value\"}`,\n\t\t\twantErr:  fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"MissingComma\",\n\t\t\tinput:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantObj:  \"\",\n\t\t\twantTail: `\"key2\": \"value2\"}`,\n\t\t\twantErr:  fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgotObj, gotTail, gotErr := parseObject(tt.input, c, 0)\n\t\t\tif fmt.Sprintf(\"%v\", gotErr) != fmt.Sprintf(\"%v\", tt.wantErr) {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", gotErr, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotObj != nil {\n\t\t\t\tif got, want := fmt.Sprintf(\"%v\", *gotObj), tt.wantObj; got != want {\n\t\t\t\t\tt.Errorf(\"parseObject() gotObj = %v, want %v\", got, want)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseObject() gotTail = %v, want %v\", gotTail, tt.wantTail)\n\t\t\t}\n\t\t})\n\t}\n}","988e774d0c9bbf8ebec69401aa6197ef":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic strings.\n\t\t{\"hello\", \"hello\"},\n\t\t{\"world\", \"world\"},\n\n\t\t// Escaped characters.\n\t\t{`\\\"`, `\"`},\n\t\t{`\\\\`, `\\`},\n\t\t{`\\/`, `/`},\n\t\t{`\\b`, \"\\b\"},\n\t\t{`\\f`, \"\\f\"},\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\r`, \"\\r\"},\n\t\t{`\\t`, \"\\t\"},\n\n\t\t// Unicode escape sequences.\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A0`, \"\\u00A0\"},\n\t\t{`\\u20AC`, \"\\u20AC\"},\n\t\t{`\\uD83D\\uDE02`, \"\\U0001F602\"}, // Surrogate pair\n\n\t\t// Invalid escape sequences.\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u002`, `\\u002`},\n\t\t{`\\uD83D`, `\\uD83D`},\n\t\t{`\\uD83D\\uXXXX`, `\\uD83D\\uXXXX`},\n\n\t\t// Mixed strings.\n\t\t{`hello\\tworld`, \"hello\\tworld\"},\n\t\t{`\\u0041\\u0042\\u0043`, \"ABC\"},\n\t\t{`\\u0020\\u20AC\\u0020`, \" ‚Ç¨ \"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}","98c795bf1798c0c906aef3710ac7839f":"package fastjson\n\nimport \"testing\"\n\nfunc Test_hasSpecialChars(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    string\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"EmptyString\",\n\t\t\ts:    \"\",\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"SimpleString\",\n\t\t\ts:    \"hello\",\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"StringWithSpace\",\n\t\t\ts:    \"hello world\",\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"StringWithBackslash\",\n\t\t\ts:    \"hello\\\\world\",\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"StringWithControlCharacter\",\n\t\t\ts:    \"hello\\nworld\",\n\t\t\twant: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := hasSpecialChars(tt.s); got != tt.want {\n\t\t\t\tt.Errorf(\"hasSpecialChars() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","9914998199e4809edead0dd3661441c4":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantStr  string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Basic cases.\n\t\t{`\"foo\"bar`, `foo`, `bar`, nil},\n\t\t{`\"foo\" bar`, `foo`, ` bar`, nil},\n\t\t{`\"foo\"  bar`, `foo`, `  bar`, nil},\n\n\t\t// Escaped quotes.\n\t\t{`\"fo\\\"o\"bar`, `fo\"o`, `bar`, nil},\n\t\t{`\"fo\\\\\"o\"bar`, `fo\\\"o`, `bar`, nil},\n\t\t{`\"fo\\\\\\\\\"o\"bar`, `fo\\\\\"o`, `bar`, nil},\n\t\t{`\"fo\\\\\\\"o\"bar`, `fo\\\"o`, `bar`, nil},\n\n\t\t// Missing closing quote.\n\t\t{`\"foo`, ``, ``, fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"fo\\\"o`, ``, ``, fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"fo\\\\\"o`, ``, ``, fmt.Errorf(`missing closing '\"'`)},\n\t}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tgotStr, gotTail, gotErr := parseRawString(tt.input)\n\t\t\tif gotStr != tt.wantStr || gotTail != tt.wantTail || (gotErr != nil \u0026\u0026 tt.wantErr == nil) || (gotErr == nil \u0026\u0026 tt.wantErr != nil) || (gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error()) {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = (%q, %q, %v), want (%q, %q, %v)\", tt.input, gotStr, gotTail, gotErr, tt.wantStr, tt.wantTail, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}\n","99f957235d301b83e920e28e6e699f3b":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\twantS string\n\t\terr   error\n\t}{\n\t\t// Empty input.\n\t\t{\"\", nil, \"\", fmt.Errorf(\"missing ']'\")},\n\t\t// Empty array.\n\t\t{\"]\", \u0026Value{t: TypeArray}, \"\", nil},\n\t\t// Simple array.\n\t\t{\"[1,2,3]\", \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}}, \"\", nil},\n\t\t// Array with whitespace.\n\t\t{\" [ 1 , 2 , 3 ] \", \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}}, \"\", nil},\n\t\t// Nested array.\n\t\t{\"[[1,2],[3,4]]\", \u0026Value{t: TypeArray, a: []*Value{{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}}}, {t: TypeArray, a: []*Value{{t: TypeNumber, s: \"3\"}, {t: TypeNumber, s: \"4\"}}}}}, \"\", nil},\n\t\t// Array with different types.\n\t\t{\"[1,\\\"foo\\\",true]\", \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeString, s: \"foo\"}, {t: TypeTrue}}}, \"\", nil},\n\t\t// Invalid array: missing comma.\n\t\t{\"[1 2]\", nil, \" 2]\", fmt.Errorf(\"missing ',' after array value\")},\n\t\t// Invalid array: unexpected end.\n\t\t{\"[1\", nil, \"\", fmt.Errorf(\"unexpected end of array\")},\n\t\t// Invalid array: missing closing bracket.\n\t\t{\"[1,\", nil, \"\", fmt.Errorf(\"unexpected end of array\")},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, gotS, err := parseArray(tt.input, c, 0)\n\n\t\t\tif got != nil \u0026\u0026 tt.want != nil \u0026\u0026 got.t != tt.want.t {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", tt.input, got.t, tt.want.t)\n\t\t\t}\n\t\t\tif got != nil \u0026\u0026 tt.want != nil \u0026\u0026 len(got.a) != len(tt.want.a) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %d, want %d\", tt.input, len(got.a), len(tt.want.a))\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %q, want %q\", tt.input, gotS, tt.wantS)\n\t\t\t}\n\t\t\tif (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err == nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", tt.input, err, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}","9a400049bc667439078b6f295edaa514":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\tstrLeft  string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"Empty Array\",\n\t\t\tinput:    \"[]\",\n\t\t\texpected: \u0026Value{t: TypeArray, a: []*Value{}},\n\t\t\tstrLeft:  \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Single Element Array\",\n\t\t\tinput:    \"[1]\",\n\t\t\texpected: \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}}},\n\t\t\tstrLeft:  \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Multiple Element Array\",\n\t\t\tinput:    \"[1, \\\"two\\\", true]\",\n\t\t\texpected: \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeString, s: \"two\"}, {t: TypeTrue}}},\n\t\t\tstrLeft:  \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Nested Array\",\n\t\t\tinput:    \"[1, [2, 3], 4]\",\n\t\t\texpected: \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeArray, a: []*Value{{t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}}, {t: TypeNumber, s: \"4\"}}},\n\t\t\tstrLeft:  \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Missing Closing Bracket\",\n\t\t\tinput:    \"[1, 2, 3\",\n\t\t\texpected: nil,\n\t\t\tstrLeft:  \"\",\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Missing Comma\",\n\t\t\tinput:    \"[1 2]\",\n\t\t\texpected: nil,\n\t\t\tstrLeft:  \"\",\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Trailing Comma\",\n\t\t\tinput:    \"[1, 2,]\",\n\t\t\texpected: nil,\n\t\t\tstrLeft:  \"\",\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Only Whitespace\",\n\t\t\tinput:    \"  \\t  \",\n\t\t\texpected: nil,\n\t\t\tstrLeft:  \"  \\t  \",\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Array with Whitespace\",\n\t\t\tinput:    \"  [ 1 , 2 ]  \",\n\t\t\texpected: \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}}},\n\t\t\tstrLeft:  \"  \",\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, strLeft, err := parseArray(tt.input, c, 0)\n\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif strLeft != tt.strLeft {\n\t\t\t\tt.Errorf(\"parseArray() string left = %v, want %v\", strLeft, tt.strLeft)\n\t\t\t}\n\n\t\t\tif !compareValues(got, tt.expected) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.s != v2.s {\n\t\treturn false\n\t}\n\tif len(v1.a) != len(v2.a) {\n\t\treturn false\n\t}\n\tfor i := range v1.a {\n\t\tif !compareValues(v1.a[i], v2.a[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n","9b380eec8fa2e09aba0eeacd0f8da3ef":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic escapes\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\t`, \"\\t\"},\n\t\t{`\\\\`, `\\ `},\n\t\t{`\\\"`, `\"`},\n\t\t{`\\/`, `/`},\n\t\t{`\\b`, \"\\b\"},\n\t\t{`\\f`, \"\\f\"},\n\t\t{`\\r`, \"\\r\"},\n\n\t\t// Unicode escapes\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A0`, \"\\u00A0\"},\n\t\t{`\\uFFFF`, \"\\uFFFF\"},\n\n\t\t// Surrogate pairs\n\t\t{`\\uD83D\\uDE02`, \"\\U0001F602\"},\n\n\t\t// Invalid escapes\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u00`, `\\u00`},\n\t\t{`\\u002`, `\\u002`},\n\t\t{`\\uD800`, `\\uD800`},  // Missing low surrogate\n\t\t{`\\uDC00`, `\\uDC00`},  // Missing high surrogate\n\t\t{`\\uD83D\\u0020`, \"\\uD83D \"}, // Invalid low surrogate\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Input: %q, Expected: %q, Actual: %q\", test.input, test.expected, actual)\n\t\t}\n\t}\n}\n","9c63bb399dab302f6903eab6bf141443":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCache_getValue(t *testing.T) {\n\tt.Run(\"grow\", func(t *testing.T) {\n\t\tc := \u0026cache{}\n\t\tif got := c.getValue(); got == nil {\n\t\t\tt.Errorf(\"getValue() = nil, want non-nil\")\n\t\t}\n\t\tif got := c.getValue(); got == nil {\n\t\t\tt.Errorf(\"getValue() = nil, want non-nil\")\n\t\t}\n\t})\n\tt.Run(\"reuse\", func(t *testing.T) {\n\t\tc := \u0026cache{\n\t\t\tvs: make([]Value, 10),\n\t\t}\n\t\tv1 := c.getValue()\n\t\tv2 := c.getValue()\n\t\tif v1 != v2 {\n\t\t\tt.Errorf(\"getValue() returned different pointers\")\n\t\t}\n\t})\n}","9d1c733b765c6e5bb2e318b7bf7b1f1d":"package fastjson\n\nimport \"testing\"\n\nfunc TestValue_GetFloat64(t *testing.T) {\n\tvar v Value\n\tstr := `{\"foo\": {\"bar\": [1.23, \"4.56\", true]}, \"baz\": 7.89}`\n\tif err := v.Unmarshal([]byte(str)); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\ttests := []struct {\n\t\tkeys   []string\n\t\twant    float64\n\t\twantErr bool\n\t}{\n\t\t{[]string{\"foo\", \"bar\", \"0\"}, 1.23, false},\n\t\t{[]string{\"foo\", \"bar\", \"1\"}, 4.56, false},\n\t\t{[]string{\"foo\", \"bar\", \"2\"}, 0, false},\n\t\t{[]string{\"foo\", \"baz\"}, 7.89, false},\n\t\t{[]string{\"foo\", \"qux\"}, 0, false},\n\t\t{[]string{\"qux\"}, 0, false},\n\t\t{[]string{\"foo\", \"bar\", \"3\"}, 0, false},    // Out of bounds\n\t\t{[]string{\"foo\", \"bar\", \"-1\"}, 0, false},   // Negative index\n\t\t{[]string{\"foo\", \"bar\", \"1.5\"}, 0, false}, // Decimal index\n\t}\n\tfor i, tt := range tests {\n\t\tgot := v.GetFloat64(tt.keys...)\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"Test %d: GetFloat64(%v) = %v, want %v\", i+1, tt.keys, got, tt.want)\n\t\t}\n\t}\n}","9d722c9775b36fd5ffebc9644db7afd5":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey   string\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t{\"\\\"key\\\":123\", \"key\", \":123\", nil},\n\t\t{\"\\\"key with spaces\\\":123\", \"key with spaces\", \":123\", nil},\n\t\t{\"\\\"key\\\\\\\"with\\\\u0020escaped\\\\\\\"chars\\\":123\", \"\", \"\", nil}, // Slow path\n\t\t{\"key\\\":123\", \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tkey, tail, err := parseRawKey(tt.input)\n\t\t\tif key != tt.key || tail != tt.tail {\n\t\t\t\tt.Errorf(\"Input: %s, Expected: %s/%s %v, Got: %s/%s %v\",\n\t\t\t\t\ttt.input, tt.key, tt.tail, tt.err, key, tail, err)\n\t\t\t}\n\t\t\tif err == nil \u0026\u0026 tt.err != nil {\n\t\t\t\tt.Errorf(\"Input: %s, Expected error: %v, Got no error\", tt.input, tt.err)\n\t\t\t} else if err != nil \u0026\u0026 tt.err == nil {\n\t\t\t\tt.Errorf(\"Input: %s, Expected no error, Got: %v\", tt.input, err)\n\t\t\t} else if err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error() {\n\t\t\t\tt.Errorf(\"Input: %s, Expected error: %v, Got: %v\", tt.input, tt.err, err)\n\t\t\t}\n\t\t})\n\t}\n}","9ded4cbbfb091b99193517a3125351b6":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic strings\n\t\t{\"hello\", \"hello\"},\n\t\t{\"world\", \"world\"},\n\n\t\t// Escaped characters\n\t\t{`\\\"hello\\\"`, `\"hello\"`},\n\t\t{`\\\\world\\\\`, `\\world\\`},\n\t\t{`\\bfoo\\tbar\\nbaz`, \"\\bfoo\\tbar\\nbaz\"},\n\t\t{`\\u0020`, \" \"},\n\n\t\t// Invalid escape sequences\n\t\t{`\\z`, `\\z`},\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u002`, `\\u002`},\n\t\t{`\\u002x`, `\\u002x`},\n\n\t\t// Surrogate pairs\n\t\t{`\\uD83D\\uDE02`, \"üòÇ\"},\n\n\t\t// Mixed strings\n\t\t{`hello\\t\"world\"`, \"hello\\t\\\"world\\\"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}\n","9e07e1684a9175571829fc4b6c2848ae":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Get(t *testing.T) {\n\t// Test cases for Get function\n\ttests := []struct {\n\t\tname           string\n\t\tjson           string\n\t\tkeys           []string\n\t\texpectedValue  string\n\t\texpectedType  Type\n\t\texpectedExists bool\n\t}{\n\t\t// Test case 1: Accessing existing key in a simple object\n\t\t{\n\t\t\tname:           \"TestCase1\",\n\t\t\tjson:           `{\"name\": \"John\", \"age\": 30}`,\n\t\t\tkeys:           []string{\"name\"},\n\t\t\texpectedValue:  \"John\",\n\t\t\texpectedType:  TypeString,\n\t\t\texpectedExists: true,\n\t\t},\n\t\t// Test case 2: Accessing existing key in a nested object\n\t\t{\n\t\t\tname:           \"TestCase2\",\n\t\t\tjson:           `{\"person\": {\"name\": \"John\", \"age\": 30}, \"city\": \"New York\"}`,\n\t\t\tkeys:           []string{\"person\", \"age\"},\n\t\t\texpectedValue:  \"30\",\n\t\t\texpectedType:  TypeNumber,\n\t\t\texpectedExists: true,\n\t\t},\n\t\t// Test case 3: Accessing element in an array\n\t\t{\n\t\t\tname:           \"TestCase3\",\n\t\t\tjson:           `{\"fruits\": [\"apple\", \"banana\", \"orange\"]}`,\n\t\t\tkeys:           []string{\"fruits\", \"1\"},\n\t\t\texpectedValue:  \"banana\",\n\t\t\texpectedType:  TypeString,\n\t\t\texpectedExists: true,\n\t\t},\n\t\t// Test case 4: Accessing non-existing key\n\t\t{\n\t\t\tname:           \"TestCase4\",\n\t\t\tjson:           `{\"name\": \"John\", \"age\": 30}`,\n\t\t\tkeys:           []string{\"gender\"},\n\t\t\texpectedValue:  \"\",\n\t\t\texpectedType:  TypeNull,\n\t\t\texpectedExists: false,\n\t\t},\n\t\t// Test case 5: Accessing key with empty string\n\t\t{\n\t\t\tname:           \"TestCase5\",\n\t\t\tjson:           `{\"name\": \"\"}`,\n\t\t\tkeys:           []string{\"name\"},\n\t\t\texpectedValue:  \"\",\n\t\t\texpectedType:  TypeString,\n\t\t\texpectedExists: true,\n\t\t},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tvar p Parser\n\t\t\tv, err := p.Parse(tc.json)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Error parsing JSON: %v\", err)\n\t\t\t}\n\n\t\t\t// Test Get function\n\t\t\tresult := v.Get(tc.keys...)\n\t\t\tif tc.expectedExists \u0026\u0026 result == nil {\n\t\t\t\tt.Errorf(\"Expected value for key path %v, but got nil\", tc.keys)\n\t\t\t}\n\t\t\tif result != nil {\n\t\t\t\tif result.Type() != tc.expectedType {\n\t\t\t\t\tt.Errorf(\"Expected type %v, but got %v\", tc.expectedType, result.Type())\n\t\t\t\t}\n\n\t\t\t\tswitch result.Type() {\n\t\t\t\tcase TypeString:\n\t\t\t\t\tif string(result.GetStringBytes(nil)) != tc.expectedValue {\n\t\t\t\t\t\tt.Errorf(\"Expected value %v, but got %v\", tc.expectedValue, string(result.GetStringBytes(nil)))\n\t\t\t\t\t}\n\t\t\t\tcase TypeNumber:\n\t\t\t\t\tif string(result.GetStringBytes(nil)) != tc.expectedValue {\n\t\t\t\t\t\tt.Errorf(\"Expected value %v, but got %v\", tc.expectedValue, string(result.GetStringBytes(nil)))\n\t\t\t\t\t}\n\t\t\t\t// Add cases for other types if needed\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","9e0ed56369c9670fc81d5c33642bb3d0":"package fastjson\n\nimport \"testing\"\n\nfunc TestSkipWS(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"  \\t\\n\\r foo\", \"foo\"},\n\t\t{\"bar\", \"bar\"},\n\t\t{\"\", \"\"},\n\t\t{\"\\x00foo\", \"\\x00foo\"},\n\t}\n\tfor _, test := range tests {\n\t\tactual := skipWS(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"skipWS(%q) = %q, want %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}","9e524aa14aefac4ab3ed67beab293c90":"package fastjson\n\nimport \"testing\"\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"  foo\", \"foo\"},\n\t\t{\"\\n\\n\\rbar\", \"bar\"},\n\t\t{\" \\t baz\", \"baz\"},\n\t\t{\"qux   \", \"qux   \"},\n\t\t{\"\\t\\t\\t\", \"\"},\n\t\t{\"\", \"\"},\n\t\t{\"a\", \"a\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := skipWSSlow(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"skipWSSlow(%q): expected %q, got %q\", test.input, test.expected, actual)\n\t\t}\n\t}\n}\n","9ecd12b15090c9fb41c1b44b254548bd":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey   string\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Unescaped strings.\n\t\t{`\"foo\"bar`, `foo`, `bar`, nil},\n\t\t{`\"foo\" bar`, `foo`, ` bar`, nil},\n\t\t{`\"foo\"  bar`, `foo`, `  bar`, nil},\n\t\t{`\"foo\"`, `foo`, ``, nil},\n\n\t\t// Escaped strings.\n\t\t{`\"fo\\o\"bar`, `fo\\o`, `bar`, nil},\n\t\t{`\"foo\\\\\"bar`, `foo\\\\`, `bar`, nil},\n\t\t{`\"foo\\\"bar\"baz`, `foo\"bar`, `baz`, nil},\n\t\t{`\"foo\\\\\\\"\"bar`, `foo\\\"`, `bar`, nil},\n\t\t{`\"foo\\\\\\\\\\\"\"bar`, `foo\\\\\"`, `bar`, nil},\n\n\t\t// Missing closing quote.\n\t\t{`\"foo`, ``, ``, fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"fo\\o`, ``, ``, fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo\\\\`, ``, ``, fmt.Errorf(`missing closing '\"'`)},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tkey, tail, err := parseRawString(tt.input)\n\t\t\tif key != tt.key || tail != tt.tail || !equalError(err, tt.err) {\n\t\t\t\tt.Fatalf(\"input: %q, want (%q, %q, %v), got (%q, %q, %v)\", tt.input, tt.key, tt.tail, tt.err, key, tail, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalError(e1, e2 error) bool {\n\tif e1 == nil {\n\t\treturn e2 == nil\n\t}\n\tif e2 == nil {\n\t\treturn false\n\t}\n\treturn e1.Error() == e2.Error()\n}","9f53176c39cd51e97ea861dcb0f5391f":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Empty string\n\t\t{\"\", nil, \"\", fmt.Errorf(\"cannot parse empty string\")},\n\n\t\t// Object\n\t\t{`{\"key\": \"value\"}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{t: typeRawString, s: \"value\"}}}}}, \"\", nil},\n\n\t\t// Array\n\t\t{`[1, \"test\", true]`, \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: typeRawString, s: \"test\"}, {t: TypeTrue}}}, \"\", nil},\n\n\t\t// String\n\t\t{`\"test\"`, \u0026Value{t: typeRawString, s: \"test\"}, \"\", nil},\n\n\t\t// True\n\t\t{\"true\", valueTrue, \"\", nil},\n\n\t\t// False\n\t\t{\"false\", valueFalse, \"\", nil},\n\n\t\t// Null\n\t\t{\"null\", valueNull, \"\", nil},\n\n\t\t// Number\n\t\t{\"123\", \u0026Value{t: TypeNumber, s: \"123\"}, \"\", nil},\n\n\t\t// NaN\n\t\t{\"NaN\", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"\", nil},\n\n\t\t// Invalid value\n\t\t{\"invalid\", nil, \"invalid\", fmt.Errorf(\"unexpected value found: \\\"invalid\\\"\")},\n\n\t\t// Too deep nesting\n\t\t{`{\"a\": {\"b\": {\"c\": {\"d\": {\"e\": {\"f\": {\"g\": {\"h\": {\"i\": {\"j\": {\"k\": {\"l\": {\"m\": {\"n\": {\"o\": {\"p\": {\"q\": {\"r\": {\"s\": {\"t\": {\"u\": {\"v\": {\"w\": {\"x\": {\"y\": {\"z\": {}}}}}}}}}}}}}}}}}}}}}}}}}}}}`, nil, `{\"a\": {\"b\": {\"c\": {\"d\": {\"e\": {\"f\": {\"g\": {\"h\": {\"i\": {\"j\": {\"k\": {\"l\": {\"m\": {\"n\": {\"o\": {\"p\": {\"q\": {\"r\": {\"s\": {\"t\": {\"u\": {\"v\": {\"w\": {\"x\": {\"y\": {\"z\": {}}}}}}}}}}}}}}}}}}}}}}}}}}}}`, fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth)},\n\t}\n\n\tc := \u0026cache{}\n\tfor i, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i+1), func(t *testing.T) {\n\t\t\tgot, tail, err := parseValue(test.input, c, 0)\n\n\t\t\tif test.err != nil {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"Expected error for input %q but got nil\", test.input)\n\t\t\t\t} else if err.Error() != test.err.Error() {\n\t\t\t\t\tt.Errorf(\"Expected error %v for input %q but got %v\", test.err, test.input, err)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"Unexpected error for input %q: %v\", test.input, err)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif tail != test.tail {\n\t\t\t\tt.Errorf(\"Expected tail %q for input %q but got %q\", test.tail, test.input, tail)\n\t\t\t}\n\n\t\t\tif !equalValues(got, test.want) {\n\t\t\t\tt.Errorf(\"Expected value %v for input %q but got %v\", test.want, test.input, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.t == typeRawString \u0026\u0026 v1.s != v2.s {\n\t\treturn false\n\t}\n\tif v1.t == TypeNumber \u0026\u0026 v1.s != v2.s {\n\t\treturn false\n\t}\n\tif v1.t == TypeObject {\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t}\n\tif v1.t == TypeArray {\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t}\n\treturn true\n}\n","9f91440c10436878372c66e4c407c431":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEscapeString(t *testing.T) {\n\ttests := []struct {\n\t\tin     string\n\t\texpect string\n\t}{\n\t\t{\"\", `\"\"`},\n\t\t{\"hello\", `\"hello\"`},\n\t\t{\"\\t\\n\\\\\\\"\", `\"\\t\\n\\\\\\\"\"`},\n\t}\n\tfor i, tt := range tests {\n\t\tout := escapeString(nil, tt.in)\n\t\tif string(out) != tt.expect {\n\t\t\tt.Errorf(\"#%d: escapeString(%q) = %q, want %q\", i, tt.in, out, tt.expect)\n\t\t}\n\t}\n}\n","9fedd9038220768c2bac39e510f99dc1":"package fastjson\n\nimport \"testing\"\n\nfunc TestCache_getValue(t *testing.T) {\n\tt.Run(\"grow cache when not full\", func(t *testing.T) {\n\t\tc := \u0026cache{\n\t\t\tvs: make([]Value, 0, 2),\n\t\t}\n\t\tval1 := c.getValue()\n\t\tval2 := c.getValue()\n\t\tif len(c.vs) != 2 {\n\t\t\tt.Errorf(\"Expected cache length to be 2, got %d\", len(c.vs))\n\t\t}\n\t\tif val1 == val2 {\n\t\t\tt.Error(\"Expected different value pointers\")\n\t\t}\n\t})\n\tt.Run(\"append to cache when full\", func(t *testing.T) {\n\t\tc := \u0026cache{\n\t\t\tvs: make([]Value, 0, 1),\n\t\t}\n\t\tval1 := c.getValue()\n\t\tval2 := c.getValue()\n\t\tif len(c.vs) != 2 {\n\t\t\tt.Errorf(\"Expected cache length to be 2, got %d\", len(c.vs))\n\t\t}\n\t\tif val1 == val2 {\n\t\t\tt.Error(\"Expected different value pointers\")\n\t\t}\n\t})\n}","a0373d3677e79e645b6cf3ae1430e524":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twant     *Value\n\t\twantErr  bool\n\t\tremain string\n\t}{\n\t\t{\n\t\t\tname:     \"empty array\",\n\t\t\tinput:    \"[]\",\n\t\t\twant:     \u0026Value{t: TypeArray},\n\t\t\twantErr:  false,\n\t\t\tremain: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"simple array\",\n\t\t\tinput:    \"[1,2,3]\",\n\t\t\twant:     \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}},\n\t\t\twantErr:  false,\n\t\t\tremain: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"array with spaces\",\n\t\t\tinput:    \" [ 1 , 2 , 3 ] \",\n\t\t\twant:     \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}},\n\t\t\twantErr:  false,\n\t\t\tremain: \" \",\n\t\t},\n\t\t{\n\t\t\tname:     \"nested array\",\n\t\t\tinput:    \"[[1,2],[3,4]]\",\n\t\t\twant: \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}}},\n\t\t\t\t{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"3\"}, {t: TypeNumber, s: \"4\"}}},\n\t\t\t}},\n\t\t\twantErr:  false,\n\t\t\tremain: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"missing closing bracket\",\n\t\t\tinput:    \"[1,2,3\",\n\t\t\twant:     nil,\n\t\t\twantErr:  true,\n\t\t\tremain: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"missing comma\",\n\t\t\tinput:    \"[1,2 3]\",\n\t\t\twant:     nil,\n\t\t\twantErr:  true,\n\t\t\tremain: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"array with different types\",\n\t\t\tinput:    \"[1, \\\"hello\\\", true, null]\",\n\t\t\twant: \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t{t: TypeString, s: \"hello\"},\n\t\t\t\t{t: TypeTrue},\n\t\t\t\t{t: TypeNull},\n\t\t\t}},\n\t\t\twantErr:  false,\n\t\t\tremain: \"\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, remain, err := parseArray(tt.input, c, 0)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif fmt.Sprintf(\"%v\", got) != fmt.Sprintf(\"%v\", tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif remain != tt.remain {\n\t\t\t\tt.Errorf(\"parseArray() remain = %v, want %v\", remain, tt.remain)\n\t\t\t}\n\t\t})\n\t}\n}","a0be294fe6b017709180cd40c5a0fee5":"package fastjson\n\nimport \"testing\"\n\nfunc TestValue_GetFloat64(t *testing.T) {\n\tvar v Value\n\ttests := []struct {\n\t\tname  string\n\t\tjson  string\n\t\tkeys  []string\n\t\twant  float64\n\t\twant1 bool\n\t}{\n\t\t{\n\t\t\tname:  \"simple\",\n\t\t\tjson:  `{\"foo\": 123.456}`,\n\t\t\tkeys:  []string{\"foo\"},\n\t\t\twant:  123.456,\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"nested\",\n\t\t\tjson:  `{\"bar\":{\"baz\":789.012}}`,\n\t\t\tkeys:  []string{\"bar\", \"baz\"},\n\t\t\twant:  789.012,\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array_index\",\n\t\t\tjson:  `{\"qux\":[11.12, 22.23, 33.34]}`,\n\t\t\tkeys:  []string{\"qux\", \"1\"},\n\t\t\twant:  22.23,\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array_decimal_index\",\n\t\t\tjson:  `{\"qux\":[11.12, 22.23, 33.34]}`,\n\t\t\tkeys:  []string{\"qux\", \"1.0\"},\n\t\t\twant:  22.23,\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"nonexistent_key\",\n\t\t\tjson:  `{\"foo\":123}`,\n\t\t\tkeys:  []string{\"bar\"},\n\t\t\twant:  0,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"invalid_value_type\",\n\t\t\tjson:  `{\"foo\":\"bar\"}`,\n\t\t\tkeys:  []string{\"foo\"},\n\t\t\twant:  0,\n\t\t\twant1: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv.Parse(tt.json)\n\t\t\tgot := v.GetFloat64(tt.keys...)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"GetFloat64() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","a182a5363911766a168f3e7aaec2dfd7":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"raw string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"raw string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"12345\",\n\t\t\t},\n\t\t\twant: []byte(\"12345\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"string\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"12345\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"[\\\"string\\\",12345]\"),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"12345\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"{\\\"key1\\\":\\\"value1\\\",\\\"key2\\\":12345}\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif string(got) != string(tt.want) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %v, want %v\", string(got), string(tt.want))\n\t\t\t}\n\t\t})\n\t}\n}\n","a1999ce8c66e2667b511eb94b5a41394":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput    string\n\t\twantNum  string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Valid numbers\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"+123\", \"+123\", \"\", nil},\n\t\t{\"123.456\", \"123.456\", \"\", nil},\n\t\t{\"1.23e+4\", \"1.23e+4\", \"\", nil},\n\t\t{\"1.23e-4\", \"1.23e-4\", \"\", nil},\n\n\t\t// Valid numbers with trailing characters\n\t\t{\"123a\", \"123\", \"a\", nil},\n\t\t{\"123.456,\", \"123.456\", \",\", nil},\n\t\t{\"-123}\", \"-123\", \"}\", nil},\n\n\t\t// Valid infinity and NaN values\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"+Inf\", \"+Inf\", \"\", nil},\n\t\t{\"-INF\", \"-INF\", \"\", nil},\n\t\t{\"NaN\", \"NaN\", \"\", nil},\n\n\t\t// Invalid numbers\n\t\t{\"\", \"\", \"\", fmt.Errorf(`unexpected char: \"\"`)},\n\t\t{\"a123\", \"\", \"a123\", fmt.Errorf(`unexpected char: \"a\"`)},\n\t\t{\"+a123\", \"\", \"+a123\", fmt.Errorf(`unexpected char: \"+\"`)},\n\t\t{\"123.456.789\", \"\", \"123.456.789\", fmt.Errorf(`unexpected char: \"1\"`)},\n\n\t\t// Invalid infinity and NaN values\n\t\t{\"in\", \"\", \"in\", fmt.Errorf(`unexpected char: \"i\"`)},\n\t\t{\"+In\", \"\", \"+In\", fmt.Errorf(`unexpected char: \"+\"`)},\n\t\t{\"-IN\", \"\", \"-IN\", fmt.Errorf(`unexpected char: \"-\"`)},\n\t\t{\"Na\", \"\", \"Na\", fmt.Errorf(`unexpected char: \"N\"`)},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"TestCase_%d\", i+1), func(t *testing.T) {\n\t\t\tgotNum, gotTail, gotErr := parseRawNumber(tc.input)\n\n\t\t\tif gotNum != tc.wantNum {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got number = %q, want %q\", tc.input, gotNum, tc.wantNum)\n\t\t\t}\n\t\t\tif gotTail != tc.wantTail {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got tail = %q, want %q\", tc.input, gotTail, tc.wantTail)\n\t\t\t}\n\n\t\t\tif gotErr == nil \u0026\u0026 tc.wantErr != nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got err = nil, want %v\", tc.input, tc.wantErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tc.wantErr == nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got err = %v, want nil\", tc.input, gotErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tc.wantErr != nil \u0026\u0026 gotErr.Error() != tc.wantErr.Error() {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got err = %v, want %v\", tc.input, gotErr, tc.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","a1df8c3e567b7b354393345c6fe5b1af":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Get(t *testing.T) {\n\tt.Run(\"object\", func(t *testing.T) {\n\t\tv := MustParse(`{\"foo\": \"bar\", \"baz\": {\"qux\": 123}}`)\n\t\ttests := []struct {\n\t\t\tkeys []string\n\t\t\twant *Value\n\t\t}{\n\t\t\t{[]string{\"foo\"}, v.o.kvs[0].v},\n\t\t\t{[]string{\"baz\"}, v.o.kvs[1].v},\n\t\t\t{[]string{\"baz\", \"qux\"}, v.o.kvs[1].v.o.kvs[0].v},\n\t\t\t{[]string{\"nonexisting\"}, nil},\n\t\t\t{[]string{\"foo\", \"nonexisting\"}, nil},\n\t\t}\n\t\tfor _, tt := range tests {\n\t\t\tif got := v.Get(tt.keys...); got != tt.want {\n\t\t\t\tt.Errorf(\"Get(%v) = %p, want %p\", tt.keys, got, tt.want)\n\t\t\t}\n\t\t}\n\t})\n\tt.Run(\"array\", func(t *testing.T) {\n\t\tv := MustParse(`[1, {\"foo\": \"bar\"}, [1, 2, 3]]`)\n\t\ttests := []struct {\n\t\t\tkeys []string\n\t\t\twant *Value\n\t\t}{\n\t\t\t{[]string{\"0\"}, v.a[0]},\n\t\t\t{[]string{\"1\"}, v.a[1]},\n\t\t\t{[]string{\"1\", \"foo\"}, v.a[1].o.kvs[0].v},\n\t\t\t{[]string{\"2\"}, v.a[2]},\n\t\t\t{[]string{\"2\", \"1\"}, v.a[2].a[1]},\n\t\t\t{[]string{\"3\"}, nil},\n\t\t\t{[]string{\"0\", \"nonexisting\"}, nil},\n\t\t\t{[]string{\"1\", \"foo\", \"nonexisting\"}, nil},\n\t\t}\n\t\tfor _, tt := range tests {\n\t\t\tif got := v.Get(tt.keys...); got != tt.want {\n\t\t\t\tt.Errorf(\"Get(%v) = %p, want %p\", tt.keys, got, tt.want)\n\t\t\t}\n\t\t}\n\t})\n\tt.Run(\"nil\", func(t *testing.T) {\n\t\tvar v *Value\n\t\tif got := v.Get(\"foo\"); got != nil {\n\t\t\tt.Errorf(\"Get() = %p, want nil\", got)\n\t\t}\n\t})\n}","a235cfa8a800f97d978cf0010f204605":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Empty string\n\t\t{\"\", nil, \"\", fmt.Errorf(\"cannot parse empty string\")},\n\n\t\t// Object\n\t\t{`{\"key\": \"value\"}`, \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: typeRawString}}}}, t: TypeObject}, \"\", nil},\n\t\t{`{\"key\": \"value\"}{\"key\": \"value\"}`, \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: typeRawString}}}}, t: TypeObject}, `{\"key\": \"value\"}`, nil},\n\n\t\t// Array\n\t\t{`[1, 2, 3]`, \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"2\", t: TypeNumber}, {s: \"3\", t: TypeNumber}}, t: TypeArray}, \"\", nil},\n\t\t{`[1, 2, 3][1, 2, 3]`, \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"2\", t: TypeNumber}, {s: \"3\", t: TypeNumber}}, t: TypeArray}, `[1, 2, 3]`, nil},\n\n\t\t// String\n\t\t{`\"hello, world\"`, \u0026Value{s: \"hello, world\", t: typeRawString}, \"\", nil},\n\t\t{`\"hello, world\"\"hello, world\"`, \u0026Value{s: \"hello, world\", t: typeRawString}, `\"hello, world\"`, nil},\n\n\t\t// True\n\t\t{\"true\", valueTrue, \"\", nil},\n\t\t{\"true,\", valueTrue, \",\", nil},\n\n\t\t// False\n\t\t{\"false\", valueFalse, \"\", nil},\n\t\t{\"false,\", valueFalse, \",\", nil},\n\n\t\t// Null\n\t\t{\"null\", valueNull, \"\", nil},\n\t\t{\"null,\", valueNull, \",\", nil},\n\n\t\t// NaN\n\t\t{\"NaN\", \u0026Value{s: \"NaN\", t: TypeNumber}, \"\", nil},\n\t\t{\"NaN,\", \u0026Value{s: \"NaN\", t: TypeNumber}, \",\", nil},\n\n\t\t// Number\n\t\t{\"12345\", \u0026Value{s: \"12345\", t: TypeNumber}, \"\", nil},\n\t\t{\"12345,\", \u0026Value{s: \"12345\", t: TypeNumber}, \",\", nil},\n\n\t\t// Invalid value\n\t\t{\"invalid\", nil, \"invalid\", fmt.Errorf(\"unexpected value found: %q\", \"invalid\")},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test %d: %s\", i, tt.input), func(t *testing.T) {\n\t\t\tgot, tail, err := parseValue(tt.input, c, 1)\n\t\t\tif fmt.Sprintf(\"%v\", err) != fmt.Sprintf(\"%v\", tt.err) {\n\t\t\t\tt.Errorf(\"error mismatch: got %v, want %v\", err, tt.err)\n\t\t\t}\n\t\t\tif tt.want != nil \u0026\u0026 got != nil \u0026\u0026 got.t != tt.want.t {\n\t\t\t\tt.Errorf(\"type mismatch: got %v, want %v\", got.t, tt.want.t)\n\t\t\t}\n\t\t\tif tt.want != nil \u0026\u0026 got != nil {\n\t\t\t\tif tt.want.t == typeRawString \u0026\u0026 got.s != tt.want.s {\n\t\t\t\t\tt.Errorf(\"string value mismatch: got %q, want %q\", got.s, tt.want.s)\n\t\t\t\t}\n\t\t\t\tif tt.want.t == TypeNumber \u0026\u0026 got.s != tt.want.s {\n\t\t\t\t\tt.Errorf(\"number value mismatch: got %q, want %q\", got.s, tt.want.s)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"tail mismatch: got %q, want %q\", tail, tt.tail)\n\t\t\t}\n\t\t})\n\t}\n}\n","a25d25f02f8b86580274389aa74aef8f":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tt.Run(\"empty string\", func(t *testing.T) {\n\t\t_, _, err := parseValue(\"\", \u0026cache{}, 0)\n\t\tif err == nil {\n\t\t\tt.Errorf(\"Expected error for empty string\")\n\t\t}\n\t})\n\n\tt.Run(\"object\", func(t *testing.T) {\n\t\tv, tail, err := parseValue(`{\"foo\":\"bar\"}`, \u0026cache{}, 0)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t}\n\t\tif tail != \"\" {\n\t\t\tt.Errorf(\"Unexpected tail: %q\", tail)\n\t\t}\n\t\tif v.Type() != TypeObject {\n\t\t\tt.Errorf(\"Expected object, got %v\", v.Type())\n\t\t}\n\t})\n\n\tt.Run(\"array\", func(t *testing.T) {\n\t\tv, tail, err := parseValue(`[1,2,3]`, \u0026cache{}, 0)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t}\n\t\tif tail != \"\" {\n\t\t\tt.Errorf(\"Unexpected tail: %q\", tail)\n\t\t}\n\t\tif v.Type() != TypeArray {\n\t\t\tt.Errorf(\"Expected array, got %v\", v.Type())\n\t\t}\n\t})\n\n\tt.Run(\"string\", func(t *testing.T) {\n\t\tv, tail, err := parseValue(`\"foobar\"`, \u0026cache{}, 0)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t}\n\t\tif tail != \"\" {\n\t\t\tt.Errorf(\"Unexpected tail: %q\", tail)\n\t\t}\n\t\tif v.Type() != typeRawString {\n\t\t\tt.Errorf(\"Expected string, got %v\", v.Type())\n\t\t}\n\t})\n\n\tt.Run(\"true\", func(t *testing.T) {\n\t\tv, tail, err := parseValue(`true`, \u0026cache{}, 0)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t}\n\t\tif tail != \"\" {\n\t\t\tt.Errorf(\"Unexpected tail: %q\", tail)\n\t\t}\n\t\tif v != valueTrue {\n\t\t\tt.Errorf(\"Expected true, got %v\", v)\n\t\t}\n\t})\n\n\tt.Run(\"false\", func(t *testing.T) {\n\t\tv, tail, err := parseValue(`false`, \u0026cache{}, 0)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t}\n\t\tif tail != \"\" {\n\t\t\tt.Errorf(\"Unexpected tail: %q\", tail)\n\t\t}\n\t\tif v != valueFalse {\n\t\t\tt.Errorf(\"Expected false, got %v\", v)\n\t\t}\n\t})\n\n\tt.Run(\"null\", func(t *testing.T) {\n\t\tv, tail, err := parseValue(`null`, \u0026cache{}, 0)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t}\n\t\tif tail != \"\" {\n\t\t\tt.Errorf(\"Unexpected tail: %q\", tail)\n\t\t}\n\t\tif v != valueNull {\n\t\t\tt.Errorf(\"Expected null, got %v\", v)\n\t\t}\n\t})\n\n\tt.Run(\"NaN\", func(t *testing.T) {\n\t\tv, tail, err := parseValue(`NaN`, \u0026cache{}, 0)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t}\n\t\tif tail != \"\" {\n\t\t\tt.Errorf(\"Unexpected tail: %q\", tail)\n\t\t}\n\t\tif v.Type() != TypeNumber {\n\t\t\tt.Errorf(\"Expected number, got %v\", v.Type())\n\t\t}\n\t})\n\n\tt.Run(\"number\", func(t *testing.T) {\n\t\tv, tail, err := parseValue(`1234.567`, \u0026cache{}, 0)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t}\n\t\tif tail != \"\" {\n\t\t\tt.Errorf(\"Unexpected tail: %q\", tail)\n\t\t}\n\t\tif v.Type() != TypeNumber {\n\t\t\tt.Errorf(\"Expected number, got %v\", v.Type())\n\t\t}\n\t})\n}","a26b80d5cf03fc8984eb5057109c119c":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Empty string\n\t\t{\"\", nil, \"\", fmt.Errorf(\"cannot parse empty string\")},\n\t\t// Invalid JSON\n\t\t{\"{invalid}\", nil, \"\", fmt.Errorf(\"cannot parse object: invalid character 'i' looking for beginning of value\")},\n\t\t// Object\n\t\t{`{\"key\": \"value\"}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{t: typeRawString, s: \"value\"}}}}}, \"\", nil},\n\t\t// Array\n\t\t{`[1, \"two\", true]`, \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: typeRawString, s: \"two\"}, {t: TypeTrue}}}, \"\", nil},\n\t\t// String\n\t\t{`\"hello\"`, \u0026Value{t: typeRawString, s: \"hello\"}, \"\", nil},\n\t\t// True\n\t\t{\"true\", valueTrue, \"\", nil},\n\t\t// False\n\t\t{\"false\", valueFalse, \"\", nil},\n\t\t// Null\n\t\t{\"null\", valueNull, \"\", nil},\n\t\t// Number\n\t\t{\"12345\", \u0026Value{t: TypeNumber, s: \"12345\"}, \"\", nil},\n\t\t// NaN\n\t\t{\"NaN\", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"\", nil},\n\t\t// Trailing whitespace\n\t\t{\"true  \", valueTrue, \"  \", nil},\n\t\t// Number with exponent\n\t\t{\"1e3\", \u0026Value{t: TypeNumber, s: \"1e3\"}, \"\", nil},\n\t\t// Number with negative exponent\n\t\t{\"1e-3\", \u0026Value{t: TypeNumber, s: \"1e-3\"}, \"\", nil},\n\t}\n\n\tfor i, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tgot, tail, err := parseValue(test.input, c, 0)\n\n\t\t\tif test.err != nil {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"Expected error, got nil\")\n\t\t\t\t} else if err.Error() != test.err.Error() {\n\t\t\t\t\tt.Errorf(\"Expected error %v, got %v\", test.err, err)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif got == nil \u0026\u0026 test.want != nil {\n\t\t\t\tt.Errorf(\"Expected non-nil value, got nil\")\n\t\t\t} else if got != nil \u0026\u0026 test.want == nil {\n\t\t\t\tt.Errorf(\"Expected nil value, got %v\", got)\n\t\t\t} else if got != nil \u0026\u0026 test.want != nil {\n\t\t\t\tif got.t != test.want.t {\n\t\t\t\t\tt.Errorf(\"Expected type %v, got %v\", test.want.t, got.t)\n\t\t\t\t}\n\t\t\t\tif got.s != test.want.s {\n\t\t\t\t\tt.Errorf(\"Expected value %q, got %q\", test.want.s, got.s)\n\t\t\t\t}\n\t\t\t\tif got.t == TypeObject {\n\t\t\t\t\tif len(got.o.kvs) != len(test.want.o.kvs) {\n\t\t\t\t\t\tt.Errorf(\"Expected %d kvs, got %d\", len(test.want.o.kvs), len(got.o.kvs))\n\t\t\t\t\t}\n\t\t\t\t\tfor j := range got.o.kvs {\n\t\t\t\t\t\tif got.o.kvs[j].k != test.want.o.kvs[j].k {\n\t\t\t\t\t\t\tt.Errorf(\"Expected key %q, got %q\", test.want.o.kvs[j].k, got.o.kvs[j].k)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif got.o.kvs[j].v.t != test.want.o.kvs[j].v.t {\n\t\t\t\t\t\t\tt.Errorf(\"Expected type %v, got %v\", test.want.o.kvs[j].v.t, got.o.kvs[j].v.t)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif got.o.kvs[j].v.s != test.want.o.kvs[j].v.s {\n\t\t\t\t\t\t\tt.Errorf(\"Expected value %q, got %q\", test.want.o.kvs[j].v.s, got.o.kvs[j].v.s)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif tail != test.tail {\n\t\t\t\tt.Errorf(\"Expected tail %q, got %q\", test.tail, tail)\n\t\t\t}\n\t\t})\n\t}\n}","a26ff4e2909ed2e5edc90ee00447e0ab":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"raw string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"raw string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"12345\",\n\t\t\t},\n\t\t\twant: []byte(\"12345\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"[1,\\\"2\\\"]\"),\n\t\t},\n\t\t// Add more test cases for object\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif string(got) != string(tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", string(got), string(tt.want))\n\t\t\t}\n\t\t})\n\t}\n}","a2c3d304cfd86c61fd58859dae8a49a4":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic tests\n\t\t{\"\", \"\"},\n\t\t{\"hello\", \"hello\"},\n\t\t{\"hello\\\\world\", \"hello\\\\world\"},\n\t\t{\"hello\\\\\\\"world\", \"hello\\\"world\"},\n\t\t{\"hello\\\\\\\\world\", \"hello\\\\world\"},\n\n\t\t// Escape sequences\n\t\t{\"\\\\\\\"\", \"\\\"\"},\n\t\t{\"\\\\\\\\\", \"\\\\\"},\n\t\t{\"\\\\/\", \"/\"},\n\t\t{\"\\\\b\", \"\\b\"},\n\t\t{\"\\\\f\", \"\\f\"},\n\t\t{\"\\\\n\", \"\\n\"},\n\t\t{\"\\\\r\", \"\\r\"},\n\t\t{\"\\\\t\", \"\\t\"},\n\n\t\t// Unicode escape sequences\n\t\t{\"\\\\u0020\", \" \"},\n\t\t{\"\\\\u00A0\", \"\\u00A0\"},\n\t\t{\"\\\\u00E9\", \"√©\"},\n\t\t{\"\\\\uD83D\\\\uDE01\", \"üòÅ\"}, // Surrogate pair\n\n\t\t// Invalid escape sequences\n\t\t{\"\\\\a\", \"\\\\a\"},\n\t\t{\"\\\\x\", \"\\\\x\"},\n\t\t{\"\\\\u002\", \"\\\\u002\"},\n\t\t{\"\\\\uD800\", \"\\\\uD800\"},     // Unpaired surrogate\n\t\t{\"\\\\uD83D\\\\uDE0\", \"\\\\uD83D\\\\uDE0\"}, // Invalid surrogate pair\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}\n","a2f4f8f4570d0c7dbc3af7e259d2ec73":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic cases\n\t\t{`\"foo\"`, \"foo\"},\n\t\t{`\"foo\\\\bar\"`, `foo\\bar`},\n\t\t{`\"foo\\nbar\"`, \"foo\\nbar\"},\n\t\t{`\"foo\\tbar\"`, \"foo\\tbar\"},\n\t\t{`\"foo\\rbar\"`, \"foo\\rbar\"},\n\t\t{`\"foo\\bbar\"`, \"foo\\bbar\"},\n\t\t{`\"foo\\fbar\"`, \"foo\\fbar\"},\n\t\t{`\"foo\\/bar\"`, \"foo/bar\"},\n\t\t{`\"foo\\\\bar\"`, `foo\\bar`},\n\t\t{`\"foo\\\"bar\"`, `foo\"bar`},\n\n\t\t// Unicode cases\n\t\t{`\"\\u0027\"`, \"'\"},\n\t\t{`\"\\u0000\"`, \"\\x00\"},\n\t\t{`\"\\u0001\"`, \"\\x01\"},\n\t\t{`\"\\uFFFF\"`, \"\\uffff\"},\n\t\t{`\"\\uD83D\\uDE01\"`, \"üòÅ\"}, // Emojis are fun!\n\n\t\t// Invalid escape sequences\n\t\t{`\"\\x00\"`, `\\x00`},\n\t\t{`\"\\u123\"`, `\\u123`},\n\t\t{`\"\\uD800\\u1234\"`, `\\uD800\\u1234`},\n\n\t\t// Other cases\n\t\t{\"\\\"\\\"\", \"\"},\n\t\t{\"\\\\\\\"\", \"\\\"\"},\n\t\t{\"\\\\\\\\\", \"\\\\\"},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.input, func(t *testing.T) {\n\t\t\tactual := unescapeStringBestEffort(tc.input)\n\t\t\tif actual != tc.expected {\n\t\t\t\tt.Errorf(\"For input %q: expected %q, got %q\", tc.input, tc.expected, actual)\n\t\t\t}\n\t\t})\n\t}\n}\n","a31ab6e2a85edb4433203a49ee3c665e":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic escapes\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\t`, \"\\t\"},\n\t\t{`\\\\`, `\\`},\n\t\t{`\\\"`, `\"`},\n\t\t{`\\/`, `/`},\n\n\t\t// Unicode escapes\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A0`, \"\\u00A0\"},\n\t\t{`\\uFFFF`, \"\\uFFFF\"},\n\t\t{`\\uD83D\\uDE01`, \"\\U0001F601\"}, // Surrogate pair\n\n\t\t// Invalid escapes\n\t\t{`\\`, `\\`},                // Single backslash\n\t\t{`\\a`, `\\a`},              // Invalid escape sequence\n\t\t{`\\u`, `\\u`},              // Incomplete unicode escape\n\t\t{`\\u123`, `\\u123`},         // Incomplete unicode escape\n\t\t{`\\uD83D`, `\\uD83D`},       // Incomplete surrogate pair\n\t\t{`\\uD83D\\u`, `\\uD83D\\u`},     // Incomplete surrogate pair\n\t\t{`\\uD83D\\u123`, `\\uD83D\\u123`}, // Incomplete surrogate pair\n\n\t\t// Mixed strings\n\t\t{`Hello\\tworld\\n`, \"Hello\\tworld\\n\"},\n\t\t{`\\u0041\\u0020string\\twith\\nescapes`, \"A string\\twith\\nescapes\"},\n\t\t{`Invalid\\uD83D escapes\\u123 are\\tok`, \"Invalid\\uD83D escapes\\u123 are\\tok\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.input, func(t *testing.T) {\n\t\t\tactual := unescapeStringBestEffort(test.input)\n\t\t\tif actual != test.expected {\n\t\t\t\tt.Errorf(\"Expected: %q, Actual: %q\", test.expected, actual)\n\t\t\t}\n\t\t})\n\t}\n}\n","a33528d332979ee2e87754f0c86d20ab":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twant     *Value\n\t\twantRest string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"empty array\",\n\t\t\tinput:    \"[]\",\n\t\t\twant:     \u0026Value{t: TypeArray},\n\t\t\twantRest: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"single element array\",\n\t\t\tinput:    \"[1]\",\n\t\t\twant:     \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}}},\n\t\t\twantRest: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple element array\",\n\t\t\tinput:    \"[1,2,3]\",\n\t\t\twant:     \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}},\n\t\t\twantRest: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"array with whitespace\",\n\t\t\tinput:    \" [ 1 , 2 , 3 ] \",\n\t\t\twant:     \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}},\n\t\t\twantRest: \" \",\n\t\t},\n\t\t{\n\t\t\tname:     \"nested array\",\n\t\t\tinput:    \"[[1,2],[3,4]]\",\n\t\t\twant: \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}}},\n\t\t\t\t{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"3\"}, {t: TypeNumber, s: \"4\"}}},\n\t\t\t}},\n\t\t\twantRest: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"missing ]\",\n\t\t\tinput:    \"[\",\n\t\t\twantErr:  true,\n\t\t\twantRest: \"[\",\n\t\t},\n\t\t{\n\t\t\tname:     \"missing ,\",\n\t\t\tinput:    \"[1 2]\",\n\t\t\twantErr:  true,\n\t\t\twantRest: \" 2]\",\n\t\t},\n\t\t{\n\t\t\tname:     \"unexpected end of array\",\n\t\t\tinput:    \"[1,\",\n\t\t\twantErr:  true,\n\t\t\twantRest: \"[1,\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, rest, err := parseArray(tt.input, c, 0)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif rest != tt.wantRest {\n\t\t\t\tt.Errorf(\"parseArray() rest = %v, wantRest %v\", rest, tt.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeNumber, TypeString:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\treturn false\n\t}\n}","a3df68aeb767bb59890390b17452dac4":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantJSON string\n\t\twantErr  error\n\t}{\n\t\t{\n\t\t\tname:     \"empty object\",\n\t\t\tinput:    \"{}\",\n\t\t\twantJSON: `{}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"simple object\",\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\twantJSON: `{\"key\": \"value\"}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"object with multiple values\",\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\", \"key3\": \"value3\"}`,\n\t\t\twantJSON: `{\"key1\": \"value1\", \"key2\": \"value2\", \"key3\": \"value3\"}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"object with nested object\",\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": {\"nestedKey\": \"nestedValue\"}}`,\n\t\t\twantJSON: `{\"key1\": \"value1\", \"key2\": {\"nestedKey\": \"nestedValue\"}}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"object with nested array\",\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": [\"value2\", \"value3\"]}`,\n\t\t\twantJSON: `{\"key1\": \"value1\", \"key2\": [\"value2\", \"value3\"]}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"object with escaped characters\",\n\t\t\tinput:    `{\"key1\": \"value1\\nwith\\tescaped\\tcharacters\", \"key2\": \"value2\"}`,\n\t\t\twantJSON: `{\"key1\": \"value1\\nwith\\tescaped\\tcharacters\", \"key2\": \"value2\"}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid object: missing closing brace\",\n\t\t\tinput:    `{\"key\": \"value\"`,\n\t\t\twantErr: fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid object: missing colon\",\n\t\t\tinput:    `{\"key\" \"value\"}`,\n\t\t\twantErr: fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid object: missing comma\",\n\t\t\tinput:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid object: missing opening quote for key\",\n\t\t\tinput:    \"{key: \\\"value\\\"}\",\n\t\t\twantErr: fmt.Errorf(`cannot find opening '\"\" for object key`),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, tail, err := parseObject(tt.input, c, 0)\n\t\t\tif fmt.Sprintf(\"%v\", tt.wantErr) != fmt.Sprintf(\"%v\", err) {\n\t\t\t\tt.Errorf(\"ParseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err == nil {\n\t\t\t\tif got == nil {\n\t\t\t\t\tt.Errorf(\"ParseObject() got nil value, want non-nil\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif len(tail) != 0 {\n\t\t\t\t\tt.Errorf(\"ParseObject() unexpected tail: %q\", tail)\n\t\t\t\t}\n\t\t\t\tgotJSON := got.MarshalTo(nil)\n\t\t\t\tif string(gotJSON) != tt.wantJSON {\n\t\t\t\t\tt.Errorf(\"ParseObject() got = %s, want %s\", gotJSON, tt.wantJSON)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n","a3e48b7e8794256346743472b05097d3":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc Test_unescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twant: \"\",\n\t\t}, {\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello world\",\n\t\t\t},\n\t\t\twant: \"hello world\",\n\t\t}, {\n\t\t\tname: \"string with escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello \\\\\\\"world\\\\\\\"\",\n\t\t\t},\n\t\t\twant: \"hello \\\"world\\\"\",\n\t\t}, {\n\t\t\tname: \"string with escaped backslashes\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello \\\\\\\\world\\\\\\\\\",\n\t\t\t},\n\t\t\twant: \"hello \\\\world\\\\\",\n\t\t}, {\n\t\t\tname: \"string with escaped special characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\\\\"\\\\/\\\\\\\\\\\\b\\\\f\\\\n\\\\r\\\\t\",\n\t\t\t},\n\t\t\twant: \"\\\"\\\\/\\b\\f\\n\\r\\t\",\n\t\t}, {\n\t\t\tname: \"string with escaped unicode\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\u0041\\\\u0042\\\\u0043\",\n\t\t\t},\n\t\t\twant: \"ABC\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","a4fba82f647f277618decc132ad6bbbd":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc Test_unescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"simple\",\n\t\t\targs: args{\n\t\t\t\ts: \"foo\\\\tbar\\\\n\",\n\t\t\t},\n\t\t\twant: \"foo\\tbar\\n\",\n\t\t},\n\t\t{\n\t\t\tname: \"quote\",\n\t\t\targs: args{\n\t\t\t\ts: \"foo\\\\\\\"bar\",\n\t\t\t},\n\t\t\twant: \"foo\\\"bar\",\n\t\t},\n\t\t{\n\t\t\tname: \"unicode\",\n\t\t\targs: args{\n\t\t\t\ts: \"foo\\\\u0020bar\",\n\t\t\t},\n\t\t\twant: \"foo bar\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalidUnicode\",\n\t\t\targs: args{\n\t\t\t\ts: \"foo\\\\u002\",\n\t\t\t},\n\t\t\twant: \"foo\\\\u002\",\n\t\t},\n\t\t{\n\t\t\tname: \"surrogate\",\n\t\t\targs: args{\n\t\t\t\ts: \"foo\\\\uD83D\\\\uDE01bar\",\n\t\t\t},\n\t\t\twant: \"fooüòÅbar\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalidSurrogate\",\n\t\t\targs: args{\n\t\t\t\ts: \"foo\\\\uD83D\\\\u0020bar\",\n\t\t\t},\n\t\t\twant: \"foo\\\\uD83D bar\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","a5b8556bdc21d1ed32652816cb936193":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"raw string\",\n\t\t\t},\n\t\t\twant: []byte(\"raw string\"),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"12345\",\n\t\t\t},\n\t\t\twant: []byte(\"12345\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"string\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"12345\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"[\\\"string\\\",12345]\"),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"string\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"string\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"number\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"12345\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"{\\\"string\\\":\\\"string\\\",\\\"number\\\":\\\"12345\\\"}\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif string(got) != string(tt.want) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %v, want %v\", string(got), string(tt.want))\n\t\t\t}\n\t\t})\n\t}\n}","a5e01f7b9aa5ec2f7147d5827f47b853":"package fastjson\n\nimport \"testing\"\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tt        Type\n\t\texpected string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\tfor _, test := range tests {\n\t\tactual := test.t.String()\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected String() to return %q for type %d, got %q\", test.expected, test.t, actual)\n\t\t}\n\t}\n\n\t// Test unknown type\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected String() to panic for unknown type, but it didn't\")\n\t\t}\n\t}()\n\tvar unknownType Type\n\tunknownType = 100\n\tunknownType.String()\n}","a5e6d71fa8c194773dae5aec918f7650":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput       string\n\t\twantValue   *Value\n\t\twantTail    string\n\t\twantErr     bool\n\t\twantErrText string\n\t}{\n\t\t// Test cases here\n\t\t{\n\t\t\tinput:       \"{}\",\n\t\t\twantValue:   \u0026Value{t: TypeObject, o: Object{}},\n\t\t\twantTail:    \"\",\n\t\t\twantErr:     false,\n\t\t\twantErrText: \"\",\n\t\t},\n\t\t{\n\t\t\tinput:       `{\"key\": \"value\"}`,\n\t\t\twantValue: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{t: TypeString, s: \"value\"}}}}}},\n\t\t\twantTail:    \"\",\n\t\t\twantErr:     false,\n\t\t\twantErrText: \"\",\n\t\t},\n\t\t{\n\t\t\tinput:       `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantValue: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}}, {k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}}}}}},\n\t\t\twantTail:    \"\",\n\t\t\twantErr:     false,\n\t\t\twantErrText: \"\",\n\t\t},\n\t\t// Add more test cases for different scenarios\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgotValue, gotTail, gotErr := parseObject(tt.input, c, 0)\n\n\t\t\tif (gotErr != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", gotErr, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotErr != nil \u0026\u0026 gotErr.Error() != tt.wantErrText {\n\t\t\t\tt.Errorf(\"parseObject() error text = %v, wantErrText %v\", gotErr.Error(), tt.wantErrText)\n\t\t\t}\n\t\t\tif !equalValues(gotValue, tt.wantValue) {\n\t\t\t\tt.Errorf(\"parseObject() gotValue = %v, want %v\", gotValue, tt.wantValue)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseObject() gotTail = %v, want %v\", gotTail, tt.wantTail)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// Helper function to compare values\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t// Add more cases for other value types as needed\n\tdefault:\n\t\treturn false\n\t}\n}\n","a68b8acf83004d4b6f250b3f0d6d4899":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantJSON string\n\t\twantErr  error\n\t}{\n\t\t// Test cases here\n\t\t{\n\t\t\tinput:    `{}`,\n\t\t\twantJSON: `{}`,\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\twantJSON: `{\"key\":\"value\"}`,\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantJSON: `{\"key1\":\"value1\",\"key2\":\"value2\"}`,\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tinput:    `{ \"key\" : \"value\" }`,\n\t\t\twantJSON: `{\"key\":\"value\"}`,\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\":\"value\" }`,\n\t\t\twantJSON: `{\"key\":\"value\"}`,\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\", }`,\n\t\t\twantJSON: `{\"key\":\"value\"}`,\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tinput:    `{ \"key\" : \"value\", }`,\n\t\t\twantJSON: `{\"key\":\"value\"}`,\n\t\t\twantErr:  nil,\n\t\t},\n\t\t// Test cases with escaped characters\n\t\t{\n\t\t\tinput:    `{\"key\": \"val\\\"ue\"}`,\n\t\t\twantJSON: `{\"key\":\"val\\\"ue\"}`,\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"k\\\"ey\": \"value\"}`,\n\t\t\twantJSON: `{\"k\\\"ey\":\"value\"}`,\n\t\t\twantErr:  nil,\n\t\t},\n\t\t// Test cases with errors\n\t\t{\n\t\t\tinput:    `{`,\n\t\t\twantJSON: \"\",\n\t\t\twantErr:  fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\"`,\n\t\t\twantJSON: \"\",\n\t\t\twantErr:  fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": value}`,\n\t\t\twantJSON: \"\",\n\t\t\twantErr:  fmt.Errorf(\"cannot parse object value: cannot find opening '\\\"' for string\"),\n\t\t},\n\t\t{\n\t\t\tinput:    `{key: \"value\"}`,\n\t\t\twantJSON: \"\",\n\t\t\twantErr:  fmt.Errorf(`cannot find opening '\"\" for object key`),\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\" \"value\"}`,\n\t\t\twantJSON: \"\",\n\t\t\twantErr:  fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test case %d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, _, err := parseObject(tt.input, c, 0)\n\n\t\t\tif tt.wantErr != nil {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"Expected error %v, but got nil\", tt.wantErr)\n\t\t\t\t} else if err.Error() != tt.wantErr.Error() {\n\t\t\t\t\tt.Errorf(\"Expected error %v, but got %v\", tt.wantErr, err)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t\t\t}\n\n\t\t\t\tgotJSON := got.MarshalTo(nil)\n\t\t\t\tif string(gotJSON) != tt.wantJSON {\n\t\t\t\t\tt.Errorf(\"Test case %d failed: \\ninput: %s\\nexpected: %s\\ngot: %s\", i, tt.input, tt.wantJSON, string(gotJSON))\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","a70e42d00ffb9791be3db5ccdfec5efc":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"raw string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"raw string\"),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"{\\\"key\\\":\\\"value\\\"}\"),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"[\\\"value1\\\",\\\"value2\\\"]\"),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"12345\",\n\t\t\t},\n\t\t\twant: []byte(\"12345\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif string(got) != string(tt.want) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %v, want %v\", string(got), string(tt.want))\n\t\t\t}\n\t\t})\n\t}\n}","a811fb62916e790dd566077bd6a35109":"package fastjson\n\nimport \"testing\"\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tt    Type\n\t\twant string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"\"},\n\t}\n\tfor i, tt := range tests {\n\t\tif got := tt.t.String(); got != tt.want {\n\t\t\tt.Errorf(\"test[%d]: String() = %q, want %q\", i, got, tt.want)\n\t\t}\n\t}\n}\n","a9e232b93b484e6e3469207334efc237":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCache_getValue(t *testing.T) {\n\tt.Run(\"return a value pointer from cache\", func(t *testing.T) {\n\t\tc := \u0026cache{}\n\t\tv := c.getValue()\n\t\tif v == nil {\n\t\t\tt.Errorf(\"getValue() returned nil\")\n\t\t}\n\t})\n\n\tt.Run(\"grow cache when needed\", func(t *testing.T) {\n\t\tc := \u0026cache{}\n\t\tfor i := 0; i \u003c 10; i++ {\n\t\t\tc.getValue()\n\t\t}\n\t\tif cap(c.vs) \u003c 10 {\n\t\t\tt.Errorf(\"cache did not grow as expected\")\n\t\t}\n\t})\n}","aa6b9126a55855fa7d61ff927be5d07b":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_unescapeKeys(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tkvs  []kv\n\t\twant []kv\n\t}{\n\t\t{\n\t\t\tname: \"basic\",\n\t\t\tkvs: []kv{\n\t\t\t\t{k: \"key\\\\u005c\", v: \u0026Value{t: TypeString, s: \"value\"}},\n\t\t\t},\n\t\t\twant: []kv{\n\t\t\t\t{k: \"key\\\\\", v: \u0026Value{t: TypeString, s: \"value\"}},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"multiple keys\",\n\t\t\tkvs: []kv{\n\t\t\t\t{k: \"key1\\\\u005c\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t{k: \"key2\\\\u005c\", v: \u0026Value{t: TypeString, s: \"value2\"}},\n\t\t\t},\n\t\t\twant: []kv{\n\t\t\t\t{k: \"key1\\\\\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t{k: \"key2\\\\\", v: \u0026Value{t: TypeString, s: \"value2\"}},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"no escape\",\n\t\t\tkvs: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}},\n\t\t\t},\n\t\t\twant: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\to := \u0026Object{\n\t\t\t\tkvs:           tt.kvs,\n\t\t\t\tkeysUnescaped: false,\n\t\t\t}\n\t\t\to.unescapeKeys()\n\t\t\tfor i := range o.kvs {\n\t\t\t\tif o.kvs[i].k != tt.want[i].k {\n\t\t\t\t\tt.Errorf(\"unescapeKeys() got = %v, want %v\", o.kvs[i].k, tt.want[i].k)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","aadbb8a32afe4362ea210a5afd1631b3":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Get(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tjson  string\n\t\tkeys  []string\n\t\twant  *Value\n\t\twant1 bool\n\t}{\n\t\t{\n\t\t\tname:  \"object\",\n\t\t\tjson:  `{\"foo\": {\"bar\": \"baz\"}}`,\n\t\t\tkeys:  []string{\"foo\", \"bar\"},\n\t\t\twant:  \u0026Value{t: TypeString, s: \"baz\"},\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array\",\n\t\t\tjson:  `[1, 2, 3]`,\n\t\t\tkeys:  []string{\"1\"},\n\t\t\twant:  \u0026Value{t: TypeNumber, s: \"2\"},\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"nonexisting key\",\n\t\t\tjson:  `{\"foo\": \"bar\"}`,\n\t\t\tkeys:  []string{\"baz\"},\n\t\t\twant:  nil,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array out of bounds\",\n\t\t\tjson:  `[1, 2, 3]`,\n\t\t\tkeys:  []string{\"3\"},\n\t\t\twant:  nil,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"invalid array index\",\n\t\t\tjson:  `[1, 2, 3]`,\n\t\t\tkeys:  []string{\"foo\"},\n\t\t\twant:  nil,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"empty keys\",\n\t\t\tjson:  `{\"foo\": \"bar\"}`,\n\t\t\tkeys:  []string{},\n\t\t\twant:  \u0026Value{t: TypeObject, o: \u0026Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: TypeString, s: \"bar\"}}}}},\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"nil value\",\n\t\t\tjson:  `null`,\n\t\t\tkeys:  []string{\"foo\"},\n\t\t\twant:  nil,\n\t\t\twant1: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv, _ := ParseBytes([]byte(tt.json))\n\t\t\tgot := v.Get(tt.keys...)\n\t\t\tif got == nil \u0026\u0026 tt.want != nil {\n\t\t\t\tt.Errorf(\"Get() = nil, want %v\", tt.want)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != nil \u0026\u0026 tt.want == nil {\n\t\t\t\tt.Errorf(\"Get() = %v, want nil\", got)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != nil \u0026\u0026 tt.want != nil {\n\t\t\t\tif got.Type() != tt.want.Type() {\n\t\t\t\t\tt.Errorf(\"Get() = %v, want %v\", got.Type(), tt.want.Type())\n\t\t\t\t}\n\t\t\t\tif got.String() != tt.want.String() {\n\t\t\t\t\tt.Errorf(\"Get() = %v, want %v\", got, tt.want)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n","ab7254c63d697a2098f1843de7716d02":"package fastjson\n\nimport \"testing\"\n\nfunc TestValue_GetFloat64(t *testing.T) {\n\tvar tests = []struct {\n\t\tjson     string\n\t\targs     []string\n\t\texpected float64\n\t}{\n\t\t{`{\"foo\": 123.456}`, []string{\"foo\"}, 123.456},\n\t\t{`{\"bar\": {\"baz\": 789.012}}`, []string{\"bar\", \"baz\"}, 789.012},\n\t\t{`{\"qux\": [1, 2, 3.14, 4]}`, []string{\"qux\", \"2\"}, 3.14},\n\t\t{`{\"qux\": [1, 2, 3.14, 4]}`, []string{\"qux\", \"3.0\"}, 4},\n\t\t{`{\"foo\": \"123.456\"}`, []string{\"foo\"}, 0}, // Invalid type\n\t\t{`{\"bar\": {\"baz\": \"789.012\"}}`, []string{\"bar\", \"baz\"}, 0}, // Invalid type\n\t\t{`{\"foo\": 123.456}`, []string{\"bar\"}, 0}, // Non-existing key\n\t\t{`{\"bar\": {\"baz\": 789.012}}`, []string{\"foo\", \"bar\"}, 0}, // Non-existing key\n\t}\n\n\tfor _, test := range tests {\n\t\tv, _ := Parse(test.json)\n\t\tresult := v.GetFloat64(test.args...)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"GetFloat64(%v) = %v, expected %v\", test.args, result, test.expected)\n\t\t}\n\t}\n}","abaa0a9b4a1101f0ffe6fbdd0d47f13e":"package fastjson\n\nimport \"testing\"\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"\", \"\"},\n\t\t{\"   abc\", \"abc\"},\n\t\t{\"\\t\\nabc\", \"abc\"},\n\t\t{\"\\r\\n abc\", \"abc\"},\n\t\t{\"abc\", \"abc\"},\n\t\t{\"\\u0000abc\", \"\\u0000abc\"},\n\t}\n\n\tfor i, test := range tests {\n\t\tactual := skipWSSlow(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Test %d: Expected '%s', but got '%s'\", i+1, test.expected, actual)\n\t\t}\n\t}\n}","abc7cd4d914a92eeb50b3ac0d0168973":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantN    string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Empty input.\n\t\t{\"\", \"\", \"\", nil},\n\n\t\t// Valid numbers.\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"123.45\", \"123.45\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"+123\", \"+123\", \"\", nil},\n\t\t{\"1.2e3\", \"1.2e3\", \"\", nil},\n\t\t{\"1.2E-3\", \"1.2E-3\", \"\", nil},\n\n\t\t// Valid numbers with trailing characters.\n\t\t{\"123 \", \"123\", \" \", nil},\n\t\t{\"123a\", \"123\", \"a\", nil},\n\t\t{\"123\\\"\", \"123\", \"\\\"\", nil},\n\n\t\t// Invalid numbers.\n\t\t{\"a123\", \"\", \"a123\", fmt.Errorf(`unexpected char: \"a\"`)},\n\t\t{\"+a123\", \"\", \"+a123\", fmt.Errorf(`unexpected char: \"+\"`)},\n\t\t{\"-a123\", \"\", \"-a123\", fmt.Errorf(`unexpected char: \"-\"`)},\n\n\t\t// Special cases: \"inf\", \"nan\".\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"+inf\", \"+inf\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"+nan\", \"\", \"+nan\", fmt.Errorf(`unexpected char: \"+\"`)},\n\t\t{\"-nan\", \"\", \"-nan\", fmt.Errorf(`unexpected char: \"-\"`)},\n\t\t{\"inf123\", \"inf\", \"123\", nil},\n\t\t{\"nan123\", \"nan\", \"123\", nil},\n\n\t\t// Special cases with trailing characters.\n\t\t{\"inf \", \"inf\", \" \", nil},\n\t\t{\"nan \", \"nan\", \" \", nil},\n\t\t{\"inf,\", \"inf\", \",\", nil},\n\t\t{\"nan,\", \"nan\", \",\", nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test%d\", i), func(t *testing.T) {\n\t\t\tgotN, gotTail, gotErr := parseRawNumber(tt.input)\n\t\t\tif gotN != tt.wantN {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q): gotN = %q, want %q\", tt.input, gotN, tt.wantN)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q): gotTail = %q, want %q\", tt.input, gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif gotErr == nil \u0026\u0026 tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q): gotErr = nil, want error %v\", tt.input, tt.wantErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr == nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q): got error = %v, want nil\", tt.input, gotErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q): got error = %v, want %v\", tt.input, gotErr, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","abf55f53ceb89bc55eca47b43f24c5c4":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantObj  string\n\t\twantRest string\n\t\twantErr  error\n\t}{\n\t\t{\n\t\t\tname:     \"empty object\",\n\t\t\tinput:    \"{}\",\n\t\t\twantObj:  `{\"t\":1}`,\n\t\t\twantRest: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"simple object\",\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\twantObj:  `{\"t\":1,\"o\":{\"kvs\":[{\"k\":\"key\",\"v\":{\"t\":3,\"s\":\"value\"}}]}}`,\n\t\t\twantRest: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple key-values\",\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantObj:  `{\"t\":1,\"o\":{\"kvs\":[{\"k\":\"key1\",\"v\":{\"t\":3,\"s\":\"value1\"}},{\"k\":\"key2\",\"v\":{\"t\":3,\"s\":\"value2\"}}]}}`,\n\t\t\twantRest: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"nested object\",\n\t\t\tinput:    `{\"key1\": {\"key2\": \"value2\"}}`,\n\t\t\twantObj:  `{\"t\":1,\"o\":{\"kvs\":[{\"k\":\"key1\",\"v\":{\"t\":1,\"o\":{\"kvs\":[{\"k\":\"key2\",\"v\":{\"t\":3,\"s\":\"value2\"}}]}}}]}}`,\n\t\t\twantRest: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing '}'\",\n\t\t\tinput:    `{\"key\": \"value\"`,\n\t\t\twantObj:  \"\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  fmt.Errorf(`missing '}'`),\n\t\t},\n\t\t{\n\t\t\tname:     \"missing ':' after object key\",\n\t\t\tinput:    `{\"key\" \"value\"}`,\n\t\t\twantObj:  \"\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"missing ',' after object value\",\n\t\t\tinput:    `{\"key\": \"value\" \"key2\": \"value2\"}`,\n\t\t\twantObj:  \"\",\n\t\t\twantRest: \"\",\n\t\t\twantErr:  fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, rest, err := parseObject(tt.input, c, 0)\n\t\t\tif err != nil \u0026\u0026 err.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != nil {\n\t\t\t\tgotStr := got.MarshalTo(nil)\n\t\t\t\tif string(gotStr) != tt.wantObj {\n\t\t\t\t\tt.Errorf(\"parseObject() got = %s, want %s\", gotStr, tt.wantObj)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif rest != tt.wantRest {\n\t\t\t\tt.Errorf(\"parseObject() rest = %s, wantRest %s\", rest, tt.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}\n","ac3e7c0295a352264e9924a302df5bfd":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey   string\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Basic cases.\n\t\t{`\"foo\"`, \"foo\", `\"`, nil},\n\t\t{`\"bar\"baz`, \"bar\", `\"baz`, nil},\n\t\t{`\"key with spaces\"`, \"key with spaces\", `\"`, nil},\n\n\t\t// Empty key.\n\t\t{`\"\"`, \"\", `\"`, nil},\n\n\t\t// Escape sequences.\n\t\t{`\"\\\"\"`, `\"`, `\"`, nil},\n\t\t{`\"\\\\\\\"\"`, `\\\"`, `\"`, nil},\n\t\t{`\"\\\\\"`, `\\`, `\"`, nil},\n\n\t\t// Missing closing quote.\n\t\t{`\"foo`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo\\`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i+1), func(t *testing.T) {\n\t\t\tkey, tail, err := parseRawKey(tt.input)\n\t\t\tif key != tt.key || tail != tt.tail || !errorEqual(err, tt.err) {\n\t\t\t\tt.Errorf(\"parseRawKey(%q) = (%q, %q, %v), want (%q, %q, %v)\", tt.input, key, tail, err, tt.key, tt.tail, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc errorEqual(e1, e2 error) bool {\n\tif e1 == nil \u0026\u0026 e2 == nil {\n\t\treturn true\n\t}\n\tif e1 == nil || e2 == nil {\n\t\treturn false\n\t}\n\treturn e1.Error() == e2.Error()\n}","ac7b78a14ebcaa3e2da32258ce951a82":"package fastjson\n\nimport \"testing\"\n\nfunc Test_parseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with whitespace\",\n\t\t\targs: args{\n\t\t\t\ts: \"456 \",\n\t\t\t},\n\t\t\twantNs:  \"456\",\n\t\t\twantS:   \" \",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with exponent\",\n\t\t\targs: args{\n\t\t\t\ts: \"789e+10\",\n\t\t\t},\n\t\t\twantNs:  \"789e+10\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with decimal\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.234\",\n\t\t\t},\n\t\t\twantNs:  \"1.234\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative number\",\n\t\t\targs: args{\n\t\t\t\ts: \"-567\",\n\t\t\t},\n\t\t\twantNs:  \"-567\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"123abc\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"abc\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number\",\n\t\t\targs: args{\n\t\t\t\ts: \"abc123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"abc123\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}","adf277bf36616eaa81aa73858644bb63":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tt        Type\n\t\texpected string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\tfor _, test := range tests {\n\t\tactual := test.t.String()\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected String() to return %q for type %d, got %q\", test.expected, test.t, actual)\n\t\t}\n\t}\n}","ae0b572cc88c22817952f3cafbbcef57":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantVal  *Value\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\twantVal:  nil,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"object\",\n\t\t\tinput:    `{\"foo\":\"bar\"}`,\n\t\t\twantVal:  \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: typeRawString, s: \"bar\"}}}}}},\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\twantVal:  \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}},\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\twantVal:  \u0026Value{t: typeRawString, s: \"hello\"},\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"true\",\n\t\t\tinput:    `true`,\n\t\t\twantVal:  valueTrue,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"false\",\n\t\t\tinput:    `false`,\n\t\t\twantVal:  valueFalse,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"null\",\n\t\t\tinput:    `null`,\n\t\t\twantVal:  valueNull,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN\",\n\t\t\tinput:    `NaN`,\n\t\t\twantVal:  \u0026Value{t: TypeNumber, s: \"NaN\"},\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"number\",\n\t\t\tinput:    `123`,\n\t\t\twantVal:  \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid json\",\n\t\t\tinput:    `invalid`,\n\t\t\twantVal:  nil,\n\t\t\twantTail: `invalid`,\n\t\t\twantErr:  fmt.Errorf(\"cannot parse object: cannot parse key: invalid\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgotVal, gotTail, gotErr := parseValue(tt.input, c, 0)\n\t\t\tif gotErr != nil \u0026\u0026 tt.wantErr == nil {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", gotErr, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotErr == nil \u0026\u0026 tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", gotErr, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !equalValues(gotVal, tt.wantVal) {\n\t\t\t\tt.Errorf(\"parseValue() gotVal = %v, want %v\", gotVal, tt.wantVal)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseValue() gotTail = %v, want %v\", gotTail, tt.wantTail)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\treturn v1.s == v2.s\n\t}\n}","ae4d8039b488babc11d0ff7d99cdce09":"package fastjson\n\nimport \"testing\"\n\nfunc TestObject_getKV(t *testing.T) {\n\to := Object{}\n\t// Test adding the first kv\n\tkv1 := o.getKV()\n\tif kv1 == nil {\n\t\tt.Errorf(\"Expected non-nil kv, got nil\")\n\t}\n\tif len(o.kvs) != 1 {\n\t\tt.Errorf(\"Expected kvs length 1, got %d\", len(o.kvs))\n\t}\n\n\t// Test adding another kv\n\tkv2 := o.getKV()\n\tif kv2 == nil {\n\t\tt.Errorf(\"Expected non-nil kv, got nil\")\n\t}\n\tif len(o.kvs) != 2 {\n\t\tt.Errorf(\"Expected kvs length 2, got %d\", len(o.kvs))\n\t}\n\n\t// Test that different kvs are returned\n\tif kv1 == kv2 {\n\t\tt.Errorf(\"Expected different kv pointers, got the same\")\n\t}\n}","ae9123f503428ba5692e3ea27ac17461":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey   string\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Basic cases\n\t\t{`\"foo\"bar`, \"foo\", \"bar\", nil},\n\t\t{`\"fo\\\"o\"bar`, `fo\"o`, \"bar\", nil},\n\t\t{`\"foo\" bar`, \"foo\", \" bar\", nil},\n\n\t\t// Escaped quotes\n\t\t{`\"foo\\\"bar\"baz`, `foo\"bar`, \"baz\", nil},\n\t\t{`\"foo\\\\\\\"bar\"baz`, `foo\\\"bar`, \"baz\", nil},\n\t\t{`\"foo\\\\\\\\\"bar\"baz`, `foo\\\\`, \"bar\\\"baz\", nil},\n\n\t\t// Empty strings\n\t\t{`\"\"bar`, \"\", \"bar\", nil},\n\t\t{`\"foo\"\"\"bar`, \"foo\\\"\", \"bar\", nil},\n\n\t\t// Error cases\n\t\t{`\"foo`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo\"bar\"`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo\\\"bar`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tkey, tail, err := parseRawString(tt.input)\n\t\t\tif key != tt.key || tail != tt.tail || (err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"Input: %s\\nExpected: %s, %s, %v\\nGot: %s, %s, %v\", tt.input, tt.key, tt.tail, tt.err, key, tail, err)\n\t\t\t}\n\t\t})\n\t}\n}","ae9693e983789f3217631b97120308a1":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc Test_parseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\ts   string\n\t\tns  string\n\t\ts2  string\n\t\terr error\n\t}{\n\t\t{s: \"123\", ns: \"123\", s2: \"\"},\n\t\t{s: \"123a\", ns: \"123\", s2: \"a\"},\n\t\t{s: \"-123\", ns: \"-123\", s2: \"\"},\n\t\t{s: \"-123a\", ns: \"-123\", s2: \"a\"},\n\t\t{s: \"123e+10\", ns: \"123\", s2: \"e+10\"},\n\t\t{s: \"123E+10\", ns: \"123\", s2: \"E+10\"},\n\t\t{s: \"123e-10\", ns: \"123\", s2: \"e-10\"},\n\t\t{s: \"123E-10\", ns: \"123\", s2: \"E-10\"},\n\t\t{s: \"123e10\", ns: \"123\", s2: \"e10\"},\n\t\t{s: \"123E10\", ns: \"123\", s2: \"E10\"},\n\t\t{s: \"123.456\", ns: \"123.456\", s2: \"\"},\n\t\t{s: \"123.456a\", ns: \"123.456\", s2: \"a\"},\n\t\t{s: \"-123.456\", ns: \"-123.456\", s2: \"\"},\n\t\t{s: \"-123.456a\", ns: \"-123.456\", s2: \"a\"},\n\t\t{s: \"+123.456\", ns: \"+123.456\", s2: \"\"},\n\t\t{s: \"+123.456a\", ns: \"+123.456\", s2: \"a\"},\n\t\t{s: \"inf\", ns: \"inf\", s2: \"\"},\n\t\t{s: \"InF\", ns: \"InF\", s2: \"\"},\n\t\t{s: \"inF\", ns: \"inF\", s2: \"\"},\n\t\t{s: \"INF\", ns: \"INF\", s2: \"\"},\n\t\t{s: \"+inf\", ns: \"+inf\", s2: \"\"},\n\t\t{s: \"+InF\", ns: \"+InF\", s2: \"\"},\n\t\t{s: \"+inF\", ns: \"+inF\", s2: \"\"},\n\t\t{s: \"+INF\", ns: \"+INF\", s2: \"\"},\n\t\t{s: \"-inf\", ns: \"-inf\", s2: \"\"},\n\t\t{s: \"-InF\", ns: \"-InF\", s2: \"\"},\n\t\t{s: \"-inF\", ns: \"-inF\", s2: \"\"},\n\t\t{s: \"-INF\", ns: \"-INF\", s2: \"\"},\n\t\t{s: \"nan\", ns: \"nan\", s2: \"\"},\n\t\t{s: \"NaN\", ns: \"NaN\", s2: \"\"},\n\t\t{s: \"nAn\", ns: \"nAn\", s2: \"\"},\n\t\t{s: \"NAN\", ns: \"NAN\", s2: \"\"},\n\t\t{s: \"+nan\", ns: \"+nan\", s2: \"\"},\n\t\t{s: \"+NaN\", ns: \"+NaN\", s2: \"\"},\n\t\t{s: \"+nAn\", ns: \"+nAn\", s2: \"\"},\n\t\t{s: \"+NAN\", ns: \"+NAN\", s2: \"\"},\n\t\t{s: \"-nan\", ns: \"-nan\", s2: \"\"},\n\t\t{s: \"-NaN\", ns: \"-NaN\", s2: \"\"},\n\t\t{s: \"-nAn\", ns: \"-nAn\", s2: \"\"},\n\t\t{s: \"-NAN\", ns: \"-NAN\", s2: \"\"},\n\t\t{s: \"infa\", ns: \"inf\", s2: \"a\"},\n\t\t{s: \"nana\", ns: \"nan\", s2: \"a\"},\n\t\t{s: \"1e\", ns: \"\", s2: \"1e\", err: fmt.Errorf(`unexpected char: \"1\"`)},\n\t\t{s: \"1e+\", ns: \"\", s2: \"1e+\", err: fmt.Errorf(`unexpected char: \"1\"`)},\n\t\t{s: \"1e-\", ns: \"\", s2: \"1e-\", err: fmt.Errorf(`unexpected char: \"1\"`)},\n\t\t{s: \"1+\", ns: \"\", s2: \"1+\", err: fmt.Errorf(`unexpected char: \"1\"`)},\n\t\t{s: \"1-\", ns: \"\", s2: \"1-\", err: fmt.Errorf(`unexpected char: \"1\"`)},\n\t}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tns, s2, err := parseRawNumber(tt.s)\n\t\t\tif ns != tt.ns || s2 != tt.s2 || err != nil \u0026\u0026 tt.err == nil || err == nil \u0026\u0026 tt.err != nil {\n\t\t\t\tt.Fatalf(\"s: %q, ns: %q, s2: %q, err: %v, want ns: %q, s2: %q, err: %v\", tt.s, ns, s2, err, tt.ns, tt.s2, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}","af10a7f04b7057fbe477a26022125bc6":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantStr  string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Test cases here\n\t\t{\"\\\"hello\\\"\", \"hello\", \"\", nil},\n\t\t{`\"he\\\"llo\"`, `he\\\"llo`, \"\", nil},\n\t\t{\"\\\"hello world\\\"\", \"hello world\", \"\", nil},\n\t\t{`\"hello\\nworld\"`, \"hello\\nworld\", \"\", nil},\n\t\t{`\"hello\\\\world\"`, `hello\\\\world`, \"\", nil},\n\t\t{`\"hello\\\"world\"`, `hello\\\"world`, \"\", nil},\n\t\t{\"\", \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{\"\\\"\", \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{\"\\\\\\\"\", \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{\"hello\", \"hello\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{\"\\\"hello\", \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{\"\\\"he\\\\\\\"llo\", \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tgotStr, gotTail, gotErr := parseRawString(tt.input)\n\t\t\tif gotStr != tt.wantStr {\n\t\t\t\tt.Errorf(\"parseRawString(%v) gotStr = %v, want %v\", tt.input, gotStr, tt.wantStr)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseRawString(%v) gotTail = %v, want %v\", tt.input, gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif gotErr != nil \u0026\u0026 tt.wantErr == nil || gotErr == nil \u0026\u0026 tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"parseRawString(%v) gotErr = %v, want %v\", tt.input, gotErr, tt.wantErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"parseRawString(%v) gotErr = %v, want %v\", tt.input, gotErr, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","afef6c05b46268a259be59a5a9fca661":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tv        *Value\n\t\texpected []byte\n\t}{\n\t\t// Test cases for typeRawString\n\t\t{\n\t\t\tname: \"typeRawString empty\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\texpected: []byte(\"\\\"\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"typeRawString non-empty\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\texpected: []byte(\"\\\"hello\\\"\"),\n\t\t},\n\n\t\t// Test cases for TypeString\n\t\t{\n\t\t\tname: \"TypeString empty\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\texpected: []byte(\"\\\"\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"TypeString non-empty\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\texpected: []byte(\"\\\"hello\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"TypeString with escaped characters\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\\tworld\\n\",\n\t\t\t},\n\t\t\texpected: []byte(\"\\\"hello\\\\tworld\\\\n\\\"\"),\n\t\t},\n\n\t\t// Test cases for TypeNumber\n\t\t{\n\t\t\tname: \"TypeNumber zero\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"0\",\n\t\t\t},\n\t\t\texpected: []byte(\"0\"),\n\t\t},\n\t\t{\n\t\t\tname: \"TypeNumber positive integer\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\texpected: []byte(\"123\"),\n\t\t},\n\t\t{\n\t\t\tname: \"TypeNumber negative integer\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-456\",\n\t\t\t},\n\t\t\texpected: []byte(\"-456\"),\n\t\t},\n\t\t{\n\t\t\tname: \"TypeNumber float\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"1.23\",\n\t\t\t},\n\t\t\texpected: []byte(\"1.23\"),\n\t\t},\n\n\t\t// Test cases for TypeTrue\n\t\t{\n\t\t\tname: \"TypeTrue\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\texpected: []byte(\"true\"),\n\t\t},\n\n\t\t// Test cases for TypeFalse\n\t\t{\n\t\t\tname: \"TypeFalse\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\texpected: []byte(\"false\"),\n\t\t},\n\n\t\t// Test cases for TypeNull\n\t\t{\n\t\t\tname: \"TypeNull\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\texpected: []byte(\"null\"),\n\t\t},\n\n\t\t// Test cases for TypeArray\n\t\t{\n\t\t\tname: \"TypeArray empty\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\texpected: []byte(\"[]\"),\n\t\t},\n\t\t{\n\t\t\tname: \"TypeArray with one element\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: []byte(\"[1]\"),\n\t\t},\n\t\t{\n\t\t\tname: \"TypeArray with multiple elements\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"hello\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: []byte(\"[1,\\\"hello\\\",true]\"),\n\t\t},\n\n\t\t// Test cases for TypeObject\n\t\t{\n\t\t\tname: \"TypeObject empty\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: []byte(\"{}\"),\n\t\t},\n\t\t{\n\t\t\tname: \"TypeObject with one element\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"name\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"John\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: []byte(\"{\\\"name\\\":\\\"John\\\"}\"),\n\t\t},\n\t\t{\n\t\t\tname: \"TypeObject with multiple elements\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"name\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"John\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"age\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"30\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"city\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"New York\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: []byte(\"{\\\"name\\\":\\\"John\\\",\\\"age\\\":\\\"30\\\",\\\"city\\\":\\\"New York\\\"}\"),\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tdst := make([]byte, 0, 1024)\n\t\t\tactual := test.v.MarshalTo(dst)\n\t\t\tif !equalBytes(actual, test.expected) {\n\t\t\t\tt.Errorf(\"Expected %v, but got %v\", test.expected, actual)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalBytes(a, b []byte) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n","b04b74319d940f0635ec6c3ab0c4f8db":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput       string\n\t\texpected    *Value\n\t\texpectedPos int\n\t\twantErr     bool\n\t}{\n\t\t// Empty array\n\t\t{\"[]\", \u0026Value{t: TypeArray, a: []*Value{}}, 2, false},\n\n\t\t// Simple array of numbers\n\t\t{\"[1,2,3]\", \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t}}, 5, false},\n\n\t\t// Array with different data types\n\t\t{`[1,\"hello\",true,null]`, \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t{t: TypeString, s: \"hello\"},\n\t\t\t{t: TypeTrue},\n\t\t\t{t: TypeNull},\n\t\t}}, 19, false},\n\n\t\t// Nested arrays\n\t\t{`[[1,2],[3,4]]`, \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t}},\n\t\t\t{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t{t: TypeNumber, s: \"4\"},\n\t\t\t}},\n\t\t}}, 10, false},\n\n\t\t// Array with whitespace\n\t\t{\" [ 1 , 2 , 3 ] \", \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t}}, 14, false},\n\n\t\t// Invalid array - missing closing bracket\n\t\t{\"[1,2,3\", nil, 0, true},\n\n\t\t// Invalid array - missing comma\n\t\t{\"[1 2 3]\", nil, 0, true},\n\n\t\t// Invalid array - trailing comma\n\t\t{\"[1,2,3,]\", nil, 0, true},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i+1), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tv, pos, err := parseArray(tt.input, c, 0)\n\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif tt.expectedPos != pos {\n\t\t\t\tt.Errorf(\"parseArray() pos = %d, want %d\", pos, tt.expectedPos)\n\t\t\t}\n\n\t\t\tif !equalValues(v, tt.expected) {\n\t\t\t\tt.Errorf(\"parseArray() value = %v, want %v\", v, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.s != v2.s {\n\t\treturn false\n\t}\n\tif len(v1.a) != len(v2.a) {\n\t\treturn false\n\t}\n\tfor i := range v1.a {\n\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n","b0b5fd686ad16fef8e8d59f74a9f67c4":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Get(t *testing.T) {\n\tt.Run(\"object\", func(t *testing.T) {\n\t\tv := MustParse(`{\"foo\": {\"bar\": \"baz\"}}`)\n\t\tassert(t, v.Get(\"foo\", \"bar\").String() == \"baz\", \"unexpected value\")\n\t\tassert(t, v.Get(\"foo\", \"bar\", \"baz\") == nil, \"unexpected value\")\n\t\tassert(t, v.Get(\"foo\", \"\").String() == `{\"bar\": \"baz\"}`, \"unexpected value\")\n\t})\n\n\tt.Run(\"array\", func(t *testing.T) {\n\t\tv := MustParse(`{\"foo\": [1, 2, 3]}`)\n\t\tassert(t, v.Get(\"foo\", \"0\").Int() == 1, \"unexpected value\")\n\t\tassert(t, v.Get(\"foo\", \"1\").Int() == 2, \"unexpected value\")\n\t\tassert(t, v.Get(\"foo\", \"2\").Int() == 3, \"unexpected value\")\n\t\tassert(t, v.Get(\"foo\", \"3\") == nil, \"unexpected value\")\n\t\tassert(t, v.Get(\"foo\", \"-1\") == nil, \"unexpected value\")\n\t\tassert(t, v.Get(\"foo\", \"invalid\") == nil, \"unexpected value\")\n\t})\n\n\tt.Run(\"missing key\", func(t *testing.T) {\n\t\tv := MustParse(`{\"foo\": \"bar\"}`)\n\t\tassert(t, v.Get(\"baz\") == nil, \"unexpected value\")\n\t\tassert(t, v.Get(\"foo\", \"baz\") == nil, \"unexpected value\")\n\t})\n\n\tt.Run(\"null\", func(t *testing.T) {\n\t\tv := MustParse(`null`)\n\t\tassert(t, v.Get(\"foo\") == nil, \"unexpected value\")\n\t})\n}","b19489aa7c40cead98db30a214543112":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tns    string\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Valid numbers\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"123.456\", \"123.456\", \"\", nil},\n\t\t{\"1.2e3\", \"1.2e3\", \"\", nil},\n\t\t{\"1.2E-3\", \"1.2E-3\", \"\", nil},\n\t\t{\"+123\", \"+123\", \"\", nil},\n\n\t\t// Valid numbers with trailing characters\n\t\t{\"123a\", \"123\", \"a\", nil},\n\t\t{\"-123 \", \"-123\", \" \", nil},\n\t\t{\"123.456,\", \"123.456\", \",\", nil},\n\n\t\t// Invalid numbers\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t\t{\"a123\", \"\", \"a123\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\"+a123\", \"\", \"+a123\", fmt.Errorf(\"unexpected char: %q\", \"+a\")},\n\t\t{\"-a123\", \"\", \"-a123\", fmt.Errorf(\"unexpected char: %q\", \"-a\")},\n\n\t\t// Special cases: \"inf\", \"nan\"\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"+inf\", \"+inf\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"inan\", \"\", \"inan\", fmt.Errorf(\"unexpected char: %q\", \"i\")},\n\t\t{\"+nan\", \"\", \"+nan\", fmt.Errorf(\"unexpected char: %q\", \"+n\")},\n\t\t{\"-nan\", \"\", \"-nan\", fmt.Errorf(\"unexpected char: %q\", \"-n\")},\n\t\t{\"infin\", \"inf\", \"in\", nil},\n\t\t{\"+infin\", \"+inf\", \"in\", nil},\n\t\t{\"-infin\", \"-inf\", \"in\", nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tns, tail, err := parseRawNumber(tt.input)\n\t\t\tif ns != tt.ns || tail != tt.tail || (err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = (%q, %q, %v), want (%q, %q, %v)\", tt.input, ns, tail, err, tt.ns, tt.tail, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}","b23f165790dec92592a71e74e8fd8fd3":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\twantS string\n\t\terr   error\n\t}{\n\t\t// Empty array\n\t\t{\"[]\", \u0026Value{t: TypeArray}, \"\", nil},\n\n\t\t// Simple array\n\t\t{\"[1,2,3]\", \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}}, \"\", nil},\n\n\t\t// Array with whitespace\n\t\t{\" [ 1 , 2 , 3 ] \", \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}}, \"\", nil},\n\n\t\t// Nested array\n\t\t{\"[[1,2],[3,4]]\", \u0026Value{t: TypeArray, a: []*Value{{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}}}, {t: TypeArray, a: []*Value{{t: TypeNumber, s: \"3\"}, {t: TypeNumber, s: \"4\"}}}}}, \"\", nil},\n\n\t\t// Missing ']'\n\t\t{\"[1,2,3\", nil, \"\", fmt.Errorf(\"missing ']'\")},\n\n\t\t// Unexpected end of array\n\t\t{\"[1,2,\", nil, \"\", fmt.Errorf(\"unexpected end of array\")},\n\n\t\t// Missing ',' after array value\n\t\t{\"[1 2]\", nil, \" 2]\", fmt.Errorf(\"missing ',' after array value\")},\n\n\t\t// Invalid value\n\t\t{\"[1,invalid,3]\", nil, \",invalid,3]\", fmt.Errorf(\"cannot parse array value: invalid number\")},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, gotS, err := parseArray(tt.input, c, 0)\n\n\t\t\tif tt.err != nil {\n\t\t\t\tif err == nil || err.Error() != tt.err.Error() {\n\t\t\t\t\tt.Errorf(\"Expected error %v, got %v\", tt.err, err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"Expected remaining string %q, got %q\", tt.wantS, gotS)\n\t\t\t}\n\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"Test %d failed: input %q, got %v, want %v\", i, tt.input, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.t == TypeArray {\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\tif v1.t == TypeString {\n\t\treturn v1.s == v2.s\n\t}\n\tif v1.t == TypeNumber {\n\t\treturn v1.s == v2.s\n\t}\n\treturn false\n}","b274ce25e34f5619bedd4d1f51c52eb9":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twant     *Value\n\t\twantRest string\n\t\twantErr  bool\n\t}{\n\t\t// TODO: Add test cases.\n\t\t{\n\t\t\tname:     \"Empty Array\",\n\t\t\tinput:    \"[]\",\n\t\t\twant:     \u0026Value{t: TypeArray, a: []*Value{}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Simple Array\",\n\t\t\tinput:    \"[1,2,3]\",\n\t\t\twant:     \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Array with Whitespace\",\n\t\t\tinput:    \" [ 1 , 2 , 3 ] \",\n\t\t\twant:     \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Nested Array\",\n\t\t\tinput:    \"[[1,2],[3,4]]\",\n\t\t\twant: \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}}},\n\t\t\t\t{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"3\"}, {t: TypeNumber, s: \"4\"}}},\n\t\t\t}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Array with Strings\",\n\t\t\tinput:    `[\"hello\", \"world\"]`,\n\t\t\twant:     \u0026Value{t: TypeArray, a: []*Value{{t: TypeString, s: \"hello\"}, {t: TypeString, s: \"world\"}}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid Array - Missing Comma\",\n\t\t\tinput:    \"[1 2]\",\n\t\t\twant:     nil,\n\t\t\twantRest: \"\",\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid Array - Unexpected End\",\n\t\t\tinput:    \"[1,2\",\n\t\t\twant:     nil,\n\t\t\twantRest: \"\",\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, rest, err := parseArray(tt.input, c, 0)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif rest != tt.wantRest {\n\t\t\t\tt.Errorf(\"parseArray() rest = %v, wantRest %v\", rest, tt.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// Helper function to compare values\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeString, TypeNumber:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\treturn false\n\t}\n}","b2c1c16f19f788e01adcb94f55cad0b0":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ts     string\n\t\terr   error\n\t}{\n\t\t// Add your test cases here\n\t\t{\n\t\t\tinput: `{\"foo\": \"bar\"}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"foo\", v: \u0026Value{t: TypeString, s: \"bar\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tinput: `{\"foo\": \"bar\", \"baz\": 123}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"foo\", v: \u0026Value{t: TypeString, s: \"bar\"}},\n\t\t\t\t\t\t{k: \"baz\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tinput: `{}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Add more test cases for various scenarios\n\t\t// such as invalid input, empty object, nested objects, etc.\n\t}\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i+1), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseObject(tc.input, c, 0)\n\n\t\t\tif tc.err != nil {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"Expected error, got nil\")\n\t\t\t\t} else if err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"Expected error %q, got %q\", tc.err.Error(), err.Error())\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t\t\t}\n\n\t\t\t\tif s != tc.s {\n\t\t\t\t\tt.Errorf(\"Expected remaining string %q, got %q\", tc.s, s)\n\t\t\t\t}\n\n\t\t\t\tif got.t != tc.want.t {\n\t\t\t\t\tt.Errorf(\"Expected Value type %v, got %v\", tc.want.t, got.t)\n\t\t\t\t}\n\n\t\t\t\tif got.o.Len() != tc.want.o.Len() {\n\t\t\t\t\tt.Errorf(\"Expected object length %d, got %d\", tc.want.o.Len(), got.o.Len())\n\t\t\t\t}\n\n\t\t\t\tfor j := 0; j \u003c got.o.Len(); j++ {\n\t\t\t\t\tif got.o.kvs[j].k != tc.want.o.kvs[j].k {\n\t\t\t\t\t\tt.Errorf(\"Expected key %q, got %q\", tc.want.o.kvs[j].k, got.o.kvs[j].k)\n\t\t\t\t\t}\n\t\t\t\t\tif got.o.kvs[j].v.t != tc.want.o.kvs[j].v.t {\n\t\t\t\t\t\tt.Errorf(\"Expected value type %v, got %v\", tc.want.o.kvs[j].v.t, got.o.kvs[j].v.t)\n\t\t\t\t\t}\n\t\t\t\t\tif got.o.kvs[j].v.s != tc.want.o.kvs[j].v.s {\n\t\t\t\t\t\tt.Errorf(\"Expected value %q, got %q\", tc.want.o.kvs[j].v.s, got.o.kvs[j].v.s)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","b2cf84a6aeb0b423ad46a2a92b4babdf":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"raw string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"raw string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"1234\",\n\t\t\t},\n\t\t\twant: []byte(\"1234\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"string\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1234\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"[\\\"string\\\",1234]\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif string(got) != string(tt.want) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %v, want %v\", string(got), string(tt.want))\n\t\t\t}\n\t\t})\n\t}\n}","b450486b468a9852733fdb3976569a3c":"package fastjson\n\nimport \"testing\"\n\nfunc TestValue_GetFloat64(t *testing.T) {\n\tvar tests = []struct {\n\t\tname string\n\t\tjson string\n\t\targs []string\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"simple\",\n\t\t\tjson: `{\"a\":123.456}`,\n\t\t\targs: []string{\"a\"},\n\t\t\twant: 123.456,\n\t\t},\n\t\t{\n\t\t\tname: \"nested\",\n\t\t\tjson: `{\"a\":{\"b\":123.456}}`,\n\t\t\targs: []string{\"a\", \"b\"},\n\t\t\twant: 123.456,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tjson: `{\"a\":[1, 123.456, 3]}`,\n\t\t\targs: []string{\"a\", \"1\"},\n\t\t\twant: 123.456,\n\t\t},\n\t\t{\n\t\t\tname: \"array decimal index\",\n\t\t\tjson: `{\"a\":[1, 123.456, 3]}`,\n\t\t\targs: []string{\"a\", \"1.0\"},\n\t\t\twant: 123.456,\n\t\t},\n\t\t{\n\t\t\tname: \"non-existing key\",\n\t\t\tjson: `{\"a\":123.456}`,\n\t\t\targs: []string{\"b\"},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid value type\",\n\t\t\tjson: `{\"a\":\"123.456\"}`,\n\t\t\targs: []string{\"a\"},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tjson: `null`,\n\t\t\targs: []string{\"a\"},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv, err := Parse([]byte(tt.json))\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Parse error: %v\", err)\n\t\t\t}\n\t\t\tif got := v.GetFloat64(tt.args...); got != tt.want {\n\t\t\t\tt.Errorf(\"GetFloat64() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","b514df76d6af14fc4f444c942cde5ac8":"package fastjson\n\nimport \"testing\"\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"  \\n\\t  foo\", \"foo\"},\n\t\t{\"\\n\\r\\tbar\", \"bar\"},\n\t\t{\"baz\", \"baz\"},\n\t\t{\"\", \"\"},\n\t\t{\"   \", \"\"},\n\t}\n\tfor i, test := range tests {\n\t\toutput := skipWSSlow(test.input)\n\t\tif output != test.expected {\n\t\t\tt.Errorf(\"Test %d failed: expected '%s', got '%s'\", i+1, test.expected, output)\n\t\t}\n\t}\n}\n","b5ba9e305ed271a13086bb75c92eeb74":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Empty string\n\t\t{\"\", nil, \"\", fmt.Errorf(\"cannot parse empty string\")},\n\t\t// Object\n\t\t{`{\"key\": \"value\"}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{t: typeRawString, s: \"value\"}}}}}, \"\", nil},\n\t\t// Array\n\t\t{`[1, \"two\", true]`, \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: typeRawString, s: \"two\"}, {t: TypeTrue}}}, \"\", nil},\n\t\t// String\n\t\t{`\"hello, world\"`, \u0026Value{t: typeRawString, s: \"hello, world\"}, \"\", nil},\n\t\t// True\n\t\t{\"true\", valueTrue, \"\", nil},\n\t\t// False\n\t\t{\"false\", valueFalse, \"\", nil},\n\t\t// Null\n\t\t{\"null\", valueNull, \"\", nil},\n\t\t// Number\n\t\t{\"12345\", \u0026Value{t: TypeNumber, s: \"12345\"}, \"\", nil},\n\t\t// NaN\n\t\t{\"NaN\", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"\", nil},\n\t\t// Invalid value\n\t\t{\"invalid\", nil, \"invalid\", fmt.Errorf(\"unexpected value found: %q\", \"invalid\")},\n\t\t// Number with tail\n\t\t{\"12345,\", \u0026Value{t: TypeNumber, s: \"12345\"}, \",\", nil},\n\t\t// String with tail\n\t\t{`\"hello, world\",`, \u0026Value{t: typeRawString, s: \"hello, world\"}, \",\", nil},\n\t\t// True with tail\n\t\t{\"true,\", valueTrue, \",\", nil},\n\t\t// False with tail\n\t\t{\"false,\", valueFalse, \",\", nil},\n\t\t// Null with tail\n\t\t{\"null,\", valueNull, \",\", nil},\n\t}\n\n\tc := \u0026cache{}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tgot, tail, err := parseValue(tt.input, c, 0)\n\t\t\tif (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"parseValue(%q) error mismatch: got %v, want %v\", tt.input, err, tt.err)\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"parseValue(%q) tail mismatch: got %q, want %q\", tt.input, tail, tt.tail)\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue(%q) value mismatch: got %v, want %v\", tt.input, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.t == TypeObject {\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\tif v1.t == TypeArray {\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\treturn v1.s == v2.s\n}\n","b649516c92ed84646401f9a0c8be1b42":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Get(t *testing.T) {\n\tt.Run(\"null\", func(t *testing.T) {\n\t\tv := \u0026Value{t: TypeNull}\n\t\tif got := v.Get(\"key\"); got != nil {\n\t\t\tt.Errorf(\"Get() = %v, want nil\", got)\n\t\t}\n\t})\n\tt.Run(\"object\", func(t *testing.T) {\n\t\tv := \u0026Value{\n\t\t\tt: TypeObject,\n\t\t\to: Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t\ttests := []struct {\n\t\t\tname string\n\t\t\tkeys []string\n\t\t\twant *Value\n\t\t}{\n\t\t\t{\n\t\t\t\tname: \"exist\",\n\t\t\t\tkeys: []string{\"key1\"},\n\t\t\t\twant: \u0026Value{t: TypeString, s: \"value1\"},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"nested\",\n\t\t\t\tkeys: []string{\"key2\", \"key3\"},\n\t\t\t\twant: nil,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"not exist\",\n\t\t\t\tkeys: []string{\"key3\"},\n\t\t\t\twant: nil,\n\t\t\t},\n\t\t}\n\t\tfor _, tt := range tests {\n\t\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t\tif got := v.Get(tt.keys...); got != tt.want {\n\t\t\t\t\tt.Errorf(\"Get() = %v, want %v\", got, tt.want)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t})\n\tt.Run(\"array\", func(t *testing.T) {\n\t\tv := \u0026Value{\n\t\t\tt: TypeArray,\n\t\t\ta: []*Value{\n\t\t\t\t{t: TypeString, s: \"value1\"},\n\t\t\t\t{t: TypeNumber, s: \"123\"},\n\t\t\t},\n\t\t}\n\t\ttests := []struct {\n\t\t\tname string\n\t\t\tkeys []string\n\t\t\twant *Value\n\t\t}{\n\t\t\t{\n\t\t\t\tname: \"exist\",\n\t\t\t\tkeys: []string{\"0\"},\n\t\t\t\twant: \u0026Value{t: TypeString, s: \"value1\"},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"out of range\",\n\t\t\t\tkeys: []string{\"2\"},\n\t\t\t\twant: nil,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"invalid index\",\n\t\t\t\tkeys: []string{\"abc\"},\n\t\t\t\twant: nil,\n\t\t\t},\n\t\t}\n\t\tfor _, tt := range tests {\n\t\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t\tif got := v.Get(tt.keys...); got != tt.want {\n\t\t\t\t\tt.Errorf(\"Get() = %v, want %v\", got, tt.want)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t})\n}\n","b677050dbcec629c8d29f82e2c3f2fd6":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Type(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  Type\n\t}{\n\t\t{`\"string\"`, TypeString},\n\t\t{`123`, TypeNumber},\n\t\t{`true`, TypeTrue},\n\t\t{`false`, TypeFalse},\n\t\t{`null`, TypeNull},\n\t\t{`{}`, TypeObject},\n\t\t{`[]`, TypeArray},\n\t\t{`\"{\\\"key\\\":\\\"value\\\"}\"`, TypeString}, // Test for unescapeStringBestEffort\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tv := strToValue(t, tt.input)\n\t\t\tif got := v.Type(); got != tt.want {\n\t\t\t\tt.Errorf(\"Type() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc strToValue(tb testing.TB, s string) *Value {\n\ttb.Helper()\n\tp := Parser{}\n\tv, err := p.Parse(s)\n\tif err != nil {\n\t\ttb.Fatal(err)\n\t}\n\treturn v\n}","b702b7f64b16cbf5e64694750a7a6b86":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey   string\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Basic cases.\n\t\t{`\"foo\": \"bar\"`, \"foo\", `: \"bar\"`, nil},\n\t\t{`\"foo\":`, \"foo\", `:`, nil},\n\t\t{`\"foo\"`, \"foo\", \"\", nil},\n\n\t\t// Empty key.\n\t\t{`\"\": \"bar\"`, \"\", `: \"bar\"`, nil},\n\n\t\t// No closing quote.\n\t\t{`\"foo: \"bar\"`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\n\t\t// Escape sequence triggers slow path.\n\t\t{`\"foo\\\": \"bar\"`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test_%d\", i), func(t *testing.T) {\n\t\t\tkey, tail, err := parseRawKey(tt.input)\n\t\t\tif key != tt.key || tail != tt.tail || !equalError(err, tt.err) {\n\t\t\t\tt.Errorf(\"parseRawKey(%q) = (%q, %q, %v), want (%q, %q, %v)\", tt.input, key, tail, err, tt.key, tt.tail, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// equalError reports whether errors a and b are considered equal.\n// They're equal if both are nil, or both are not nil and a.Error() == b.Error().\nfunc equalError(a, b error) bool {\n\treturn a == nil \u0026\u0026 b == nil || a != nil \u0026\u0026 b != nil \u0026\u0026 a.Error() == b.Error()\n}\n","b77435e569aff9b55cf6558a968f476c":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput  string\n\t\twant1  string\n\t\twant2  string\n\t\twantErr error\n\t}{\n\t\t// Test cases here\n\t\t{\"\\\"hello\\\"\", \"hello\", \"\", nil},\n\t\t{`\"hel\\\"lo\\\"\", `\"`, \"lo\\\"\", nil},\n\t\t{`\"hello\\\\\"\", \"hello\\\\\", \"\", nil},\n\t\t{`\"hello\", \"world\"`, \"hello\", \", \\\"world\\\"\", nil},\n\t\t{`\"hello`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test_%d\", i), func(t *testing.T) {\n\t\t\tgot1, got2, gotErr := parseRawString(tt.input)\n\t\t\tif got1 != tt.want1 || got2 != tt.want2 || (gotErr != nil \u0026\u0026 tt.wantErr == nil) || (gotErr == nil \u0026\u0026 tt.wantErr != nil) || (gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error()) {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = (%v, %v, %v), want (%v, %v, %v)\", tt.input, got1, got2, gotErr, tt.want1, tt.want2, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","b7a19dad9f8dc44de63625c70135f9cb":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantN    string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Valid numbers\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"123.456\", \"123.456\", \"\", nil},\n\t\t{\"1.2e3\", \"1.2e3\", \"\", nil},\n\t\t{\"1.2E-3\", \"1.2E-3\", \"\", nil},\n\t\t{\"+123\", \"+123\", \"\", nil},\n\n\t\t// Valid numbers with trailing characters\n\t\t{\"123a\", \"123\", \"a\", nil},\n\t\t{\"-123)\", \"-123\", \")\", nil},\n\t\t{\"123.456 \", \"123.456\", \" \", nil},\n\n\t\t// Invalid numbers\n\t\t{\"a123\", \"\", \"a123\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\".123\", \"\", \".123\", fmt.Errorf(\"unexpected char: %q\", \".\")},\n\t\t{\"-a123\", \"\", \"-a123\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\n\t\t// Special cases\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"+inf\", \"+inf\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"InF\", \"InF\", \"\", nil},\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"+nan\", \"+nan\", \"\", nil},\n\t\t{\"-nan\", \"-nan\", \"\", nil},\n\t\t{\"123inf\", \"123\", \"inf\", nil},\n\t\t{\"123InF\", \"123\", \"InF\", nil},\n\t\t{\"123nan\", \"123\", \"nan\", nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d:%s\", i, tt.input), func(t *testing.T) {\n\t\t\tgotN, gotTail, gotErr := parseRawNumber(tt.input)\n\n\t\t\tif gotN != tt.wantN {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got number = %q, want %q\", tt.input, gotN, tt.wantN)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got tail = %q, want %q\", tt.input, gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif gotErr == nil \u0026\u0026 tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got no error, want %v\", tt.input, tt.wantErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr == nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got error = %v, want no error\", tt.input, gotErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got error = %v, want %v\", tt.input, gotErr, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}\n","b820683300c14c36357582b48bac4df3":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey   string\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Simple cases\n\t\t{`\"foo\"bar`, \"foo\", \"bar\", nil},\n\t\t{`\"foo\" bar`, \"foo\", \" bar\", nil},\n\t\t{`\"foo\"  bar`, \"foo\", \"  bar\", nil},\n\n\t\t// Escaped quotes\n\t\t{`\"fo\\\"o\"bar`, `fo\"o`, \"bar\", nil},\n\t\t{`\"fo\\\\\"o\"bar`, `fo\\\\`, `o\"bar`, nil},\n\t\t{`\"fo\\\\\\\\\"o\"bar`, `fo\\\\\\\\\"o`, \"bar\", nil},\n\n\t\t// Missing closing quote\n\t\t{`\"foo`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"fo\\\"o`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d:%s\", i, tt.input), func(t *testing.T) {\n\t\t\tkey, tail, err := parseRawString(tt.input)\n\t\t\tif key != tt.key || tail != tt.tail || !errorEqual(err, tt.err) {\n\t\t\t\tt.Errorf(\"Input: %s, Expected: %s,%s,%v, Got: %s,%s,%v\", tt.input, tt.key, tt.tail, tt.err, key, tail, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc errorEqual(e1, e2 error) bool {\n\tif e1 == nil \u0026\u0026 e2 == nil {\n\t\treturn true\n\t}\n\tif e1 != nil \u0026\u0026 e2 != nil {\n\t\treturn e1.Error() == e2.Error()\n\t}\n\treturn false\n}","b9027e608afcd64bdeefc42196d68462":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"raw string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"raw string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"12345\",\n\t\t\t},\n\t\t\twant: []byte(\"12345\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"string\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"12345\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"[\\\"string\\\",12345]\"),\n\t\t},\n\t\t// Add more test cases for other types and nested objects/arrays as needed\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif string(got) != string(tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", string(got), string(tt.want))\n\t\t\t}\n\t\t})\n\t}\n}","b94c8a675ca01c0e5705f4898a327a1f":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ts     string\n\t\terr   error\n\t}{\n\t\t// Empty array\n\t\t{\n\t\t\tinput: \"[]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Simple array\n\t\t{\n\t\t\tinput: \"[1,2,3]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Array with different types\n\t\t{\n\t\t\tinput: `[1,\"test\",true,null]`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeString, s: \"test\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t\t{t: TypeNull},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Array with nested array\n\t\t{\n\t\t\tinput: \"[1,[2,3],4]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{t: TypeNumber, s: \"4\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Invalid array: missing closing bracket\n\t\t{\n\t\t\tinput: \"[1,2,3\",\n\t\t\twant:  nil,\n\t\t\ts:     \"[1,2,3\",\n\t\t\terr:   fmt.Errorf(\"unexpected end of array\"),\n\t\t},\n\t\t// Invalid array: missing comma\n\t\t{\n\t\t\tinput: \"[1 2 3]\",\n\t\t\twant:  nil,\n\t\t\ts:     \" 2 3]\",\n\t\t\terr:   fmt.Errorf(\"missing ',' after array value\"),\n\t\t},\n\t\t// Whitespace handling\n\t\t{\n\t\t\tinput: \" [ 1 , 2 , 3 ] \",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \" \",\n\t\t\terr: nil,\n\t\t},\n\t}\n\n\tfor i, test := range tests {\n\t\tc := \u0026cache{}\n\t\tgot, s, err := parseArray(test.input, c, 0)\n\n\t\tif got != nil \u0026\u0026 test.want != nil \u0026\u0026 got.Type() != test.want.Type() {\n\t\t\tt.Errorf(\"Test %d: got type %v, want %v\", i, got.Type(), test.want.Type())\n\t\t}\n\t\tif got != nil \u0026\u0026 test.want != nil \u0026\u0026 len(got.a) != len(test.want.a) {\n\t\t\tt.Errorf(\"Test %d: got array length %d, want %d\", i, len(got.a), len(test.want.a))\n\t\t}\n\t\tif s != test.s {\n\t\t\tt.Errorf(\"Test %d: got string remainder %q, want %q\", i, s, test.s)\n\t\t}\n\t\tif (err != nil \u0026\u0026 test.err == nil) || (err == nil \u0026\u0026 test.err != nil) || (err != nil \u0026\u0026 test.err != nil \u0026\u0026 err.Error() != test.err.Error()) {\n\t\t\tt.Errorf(\"Test %d: got error %v, want %v\", i, err, test.err)\n\t\t}\n\t}\n}\n","b986d4c589f56a16c52eb378505a2e52":"package fastjson\n\nimport \"testing\"\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tt    Type\n\t\twant string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\tfor i, tt := range tests {\n\t\tif got := tt.t.String(); got != tt.want {\n\t\t\tt.Errorf(\"test[%d] - String() = %v, want %v\", i, got, tt.want)\n\t\t}\n\t}\n}","bae59786f5c861d477ca897b14a101e7":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"raw string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"raw string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"string\",\n\t\t\t},\n\t\t\twant: []byte(\"string\"),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"12345\",\n\t\t\t},\n\t\t\twant: []byte(\"12345\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"string\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"12345\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"[\\\"string\\\",12345]\"),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"string\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"number\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"12345\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"{\\\"string\\\":\\\"value\\\",\\\"number\\\":\\\"12345\\\"}\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif string(got) != string(tt.want) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %v, want %v\", string(got), string(tt.want))\n\t\t\t}\n\t\t})\n\t}\n}","bae6aaeb6d2dde466a9d225e8b25689e":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv:    \u0026Value{t: typeRawString, s: \"raw string\"},\n\t\t\twant: []byte(\"\\\"raw string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv:    \u0026Value{t: TypeString, s: \"string\"},\n\t\t\twant: []byte(\"\\\"string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv:    \u0026Value{t: TypeNumber, s: \"1234\"},\n\t\t\twant: []byte(\"1234\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv:    \u0026Value{t: TypeTrue},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv:    \u0026Value{t: TypeFalse},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv:    \u0026Value{t: TypeNull},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeString, s: \"2\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"[1,\\\"2\\\",true]\"),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"{\\\"key1\\\":\\\"value1\\\",\\\"key2\\\":123}\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif string(got) != string(tt.want) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %v, want %v\", string(got), string(tt.want))\n\t\t\t}\n\t\t})\n\t}\n}\n","bba33bd45299023ca8b7a83a78d12329":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ts     string\n\t\terr   error\n\t}{\n\t\t// Empty array\n\t\t{\"[]\", \u0026Value{t: TypeArray, a: []*Value{}}, \"\", nil},\n\t\t// Simple array\n\t\t{\"[1,2,3]\", \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}}, \"\", nil},\n\t\t// Array with spaces\n\t\t{\" [ 1 , 2 , 3 ] \", \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}}, \"\", nil},\n\t\t// Array with different types\n\t\t{\"[1,\\\"hello\\\",true]\", \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeString, s: \"hello\"}, {t: TypeTrue}}}, \"\", nil},\n\t\t// Nested array\n\t\t{\"[[1,2],[3,4]]\", \u0026Value{t: TypeArray, a: []*Value{{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}}}, {t: TypeArray, a: []*Value{{t: TypeNumber, s: \"3\"}, {t: TypeNumber, s: \"4\"}}}}}, \"\", nil},\n\t\t// Missing ']'\n\t\t{\"[1,2,3\", nil, \"\", fmt.Errorf(\"missing ']'\")},\n\t\t// Unexpected end of array\n\t\t{\"[1,2,\", nil, \"\", fmt.Errorf(\"unexpected end of array\")},\n\t\t// Missing ',' after array value\n\t\t{\"[1 2]\", nil, \"\", fmt.Errorf(\"missing ',' after array value\")},\n\t}\n\n\tc := \u0026cache{}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d:%v\", i, tt.input), func(t *testing.T) {\n\t\t\tgot, s, err := parseArray(tt.input, c, 0)\n\n\t\t\tif err != nil {\n\t\t\t\tif tt.err == nil {\n\t\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif err.Error() != tt.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif tt.err != nil {\n\t\t\t\tt.Errorf(\"parseArray() error = nil, wantErr %v\", tt.err)\n\t\t\t}\n\n\t\t\tif s != tt.s {\n\t\t\t\tt.Errorf(\"parseArray() s = %v, want %v\", s, tt.s)\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(a, b *Value) bool {\n\tif a == nil \u0026\u0026 b == nil {\n\t\treturn true\n\t}\n\tif a == nil || b == nil {\n\t\treturn false\n\t}\n\tif a.t != b.t {\n\t\treturn false\n\t}\n\tswitch a.t {\n\tcase TypeArray:\n\t\tif len(a.a) != len(b.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range a.a {\n\t\t\tif !equalValues(a.a[i], b.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeString, TypeNumber:\n\t\treturn a.s == b.s\n\tdefault:\n\t\treturn a.t == b.t\n\t}\n}","bbd4aacd501b5510c301e28e2c99a7a2":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetStringBytes(t *testing.T) {\n\tt.Parallel()\n\n\tvar tests = []struct {\n\t\tname              string\n\t\tjson              string\n\t\tkeys              []string\n\t\texpected          []byte\n\t\texpectedFound bool\n\t}{\n\t\t{\n\t\t\tname:              \"simple\",\n\t\t\tjson:              `{\"foo\": \"bar\"}`,\n\t\t\tkeys:              []string{\"foo\"},\n\t\t\texpected:          []byte(\"bar\"),\n\t\t\texpectedFound: true,\n\t\t},\n\t\t{\n\t\t\tname:              \"nested\",\n\t\t\tjson:              `{\"foo\": {\"bar\": \"baz\"}}`,\n\t\t\tkeys:              []string{\"foo\", \"bar\"},\n\t\t\texpected:          []byte(\"baz\"),\n\t\t\texpectedFound: true,\n\t\t},\n\t\t{\n\t\t\tname:              \"array\",\n\t\t\tjson:              `{\"foo\": [\"bar\", \"baz\"]}`,\n\t\t\tkeys:              []string{\"foo\", \"1\"},\n\t\t\texpected:          []byte(\"baz\"),\n\t\t\texpectedFound: true,\n\t\t},\n\t\t{\n\t\t\tname:              \"array decimal\",\n\t\t\tjson:              `{\"foo\": [\"bar\", \"baz\"]}`,\n\t\t\tkeys:              []string{\"foo\", \"1.0\"},\n\t\t\texpected:          []byte(\"baz\"),\n\t\t\texpectedFound: true,\n\t\t},\n\t\t{\n\t\t\tname:              \"non-existent key\",\n\t\t\tjson:              `{\"foo\": \"bar\"}`,\n\t\t\tkeys:              []string{\"baz\"},\n\t\t\texpectedFound: false,\n\t\t},\n\t\t{\n\t\t\tname:              \"non-string value\",\n\t\t\tjson:              `{\"foo\": 123}`,\n\t\t\tkeys:              []string{\"foo\"},\n\t\t\texpectedFound: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv, err := ParseBytes([]byte(tt.json))\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t\t\t}\n\n\t\t\tgot := v.GetStringBytes(tt.keys...)\n\t\t\tif tt.expectedFound \u0026\u0026 string(got) != string(tt.expected) {\n\t\t\t\tt.Errorf(\"expected %q, got %q\", tt.expected, got)\n\t\t\t}\n\t\t\tif !tt.expectedFound \u0026\u0026 got != nil {\n\t\t\t\tt.Errorf(\"expected nil, got %q\", got)\n\t\t\t}\n\t\t})\n\t}\n}","bbe3e673670e6d1a8100b95f3f3b6604":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Empty object.\n\t\t{\n\t\t\tinput: `{}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{},\n\t\t\t},\n\t\t\ttail: \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t// Simple object.\n\t\t{\n\t\t\tinput: `{\"key\": \"value\"}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: \u0026Value{t: TypeString, s: \"value\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttail: \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t// Object with multiple key-value pairs.\n\t\t{\n\t\t\tinput: `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttail: \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t// Object with nested object.\n\t\t{\n\t\t\tinput: `{\"key1\": \"value1\", \"key2\": {\"nestedKey\": \"nestedValue\"}}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{k: \"nestedKey\", v: \u0026Value{t: TypeString, s: \"nestedValue\"}},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttail: \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t// Object with array.\n\t\t{\n\t\t\tinput: `{\"key1\": \"value1\", \"key2\": [\"item1\", \"item2\"]}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t\t\t{t: TypeString, s: \"item1\"},\n\t\t\t\t\t\t\t\t\t{t: TypeString, s: \"item2\"},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttail: \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t// Invalid JSON: Missing closing brace.\n\t\t{\n\t\t\tinput: `{\"key\": \"value\"`,\n\t\t\twant:  nil,\n\t\t\ttail:  `{\"key\": \"value\"`,\n\t\t\terr:   fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t\t// Invalid JSON: Missing colon.\n\t\t{\n\t\t\tinput: `{\"key\" \"value\"}`,\n\t\t\twant:  nil,\n\t\t\ttail:  `\"value\"}`,\n\t\t\terr:   fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t\t// Invalid JSON: Missing comma.\n\t\t{\n\t\t\tinput: `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twant:  nil,\n\t\t\ttail:  `\"key2\": \"value2\"}`,\n\t\t\terr:   fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\t}\n\n\tfor i, test := range tests {\n\t\tc := \u0026cache{}\n\t\tgot, tail, err := parseObject(test.input, c, 0)\n\n\t\tif test.err != nil {\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"Test %d: Expected error, got nil\", i)\n\t\t\t} else if err.Error() != test.err.Error() {\n\t\t\t\tt.Errorf(\"Test %d: Error mismatch.\\nExpected: %s\\nGot: %s\", i, test.err, err)\n\t\t\t}\n\t\t} else {\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Test %d: Unexpected error: %s\", i, err)\n\t\t\t}\n\t\t}\n\n\t\tif tail != test.tail {\n\t\t\tt.Errorf(\"Test %d: Tail mismatch.\\nExpected: %s\\nGot: %s\", i, test.tail, tail)\n\t\t}\n\n\t\tif !compareValues(got, test.want) {\n\t\t\tt.Errorf(\"Test %d: Value mismatch.\\nExpected: %+v\\nGot: %+v\", i, test.want, got)\n\t\t}\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k || !compareValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !compareValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}","bc32bb4bd7cd7c280d27c80f1da62f5b":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput  string\n\t\tns     string\n\t\ttail   string\n\t\thasErr bool\n\t}{\n\t\t{\"123\", \"123\", \"\", false},\n\t\t{\"123a\", \"123\", \"a\", false},\n\t\t{\"123.456\", \"123.456\", \"\", false},\n\t\t{\"-123\", \"-123\", \"\", false},\n\t\t{\"+123\", \"+123\", \"\", false},\n\t\t{\"1e5\", \"1e5\", \"\", false},\n\t\t{\"1E5\", \"1E5\", \"\", false},\n\t\t{\"1e+5\", \"1e+5\", \"\", false},\n\t\t{\"1e-5\", \"1e-5\", \"\", false},\n\t\t{\"inf\", \"inf\", \"\", false},\n\t\t{\"+inf\", \"+inf\", \"\", false},\n\t\t{\"-inf\", \"-inf\", \"\", false},\n\t\t{\"nan\", \"nan\", \"\", false},\n\t\t{\"+nan\", \"\", \"+nan\", true},\n\t\t{\"-nan\", \"\", \"-nan\", true},\n\t\t{\"123inf\", \"123\", \"inf\", false},\n\t\t{\"123nan\", \"123\", \"nan\", false},\n\t\t{\"123.456inf\", \"123.456\", \"inf\", false},\n\t\t{\"123.456nan\", \"123.456\", \"nan\", false},\n\t\t{\"-123inf\", \"-123\", \"inf\", false},\n\t\t{\"-123nan\", \"-123\", \"nan\", false},\n\t\t{\"+123inf\", \"+123\", \"inf\", false},\n\t\t{\"+123nan\", \"+123\", \"nan\", false},\n\t}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test %d\", i), func(t *testing.T) {\n\t\t\tns, tail, err := parseRawNumber(tt.input)\n\t\t\tif tt.hasErr \u0026\u0026 err == nil {\n\t\t\t\tt.Errorf(\"expecting error, but got nil\")\n\t\t\t} else if !tt.hasErr \u0026\u0026 err != nil {\n\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t}\n\t\t\tif ns != tt.ns {\n\t\t\t\tt.Errorf(\"expecting ns: %q, but got: %q\", tt.ns, ns)\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"expecting tail: %q, but got: %q\", tt.tail, tail)\n\t\t\t}\n\t\t})\n\t}\n}","bc5d285469a1c0d8fc4ef44b5183d6ea":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ts     string\n\t\terr   error\n\t}{\n\t\t// Empty array\n\t\t{\n\t\t\tinput: \"[]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Simple array\n\t\t{\n\t\t\tinput: \"[1,2,3]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Array with whitespace\n\t\t{\n\t\t\tinput: \" [ 1 , 2 , 3 ] \",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Array with nested arrays\n\t\t{\n\t\t\tinput: \"[[1,2],[3,4]]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t\t\t\t{t: TypeNumber, s: \"4\"},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Invalid array - missing closing bracket\n\t\t{\n\t\t\tinput: \"[1,2,3\",\n\t\t\twant:  nil,\n\t\t\ts:     \"[1,2,3\",\n\t\t\terr:   fmt.Errorf(\"missing ']'\"),\n\t\t},\n\t\t// Invalid array - missing comma\n\t\t{\n\t\t\tinput: \"[1,2 3]\",\n\t\t\twant:  nil,\n\t\t\ts:     \" 3]\",\n\t\t\terr:   fmt.Errorf(\"missing ',' after array value\"),\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test %d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseArray(tt.input, c, 0)\n\t\t\tif fmt.Sprintf(\"%v\", err) != fmt.Sprintf(\"%v\", tt.err) {\n\t\t\t\tt.Errorf(\"parseArray(%q) error mismatch: got %v, want %v\", tt.input, err, tt.err)\n\t\t\t}\n\t\t\tif s != tt.s {\n\t\t\t\tt.Errorf(\"parseArray(%q) remaining string mismatch: got %q, want %q\", tt.input, s, tt.s)\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray(%q) value mismatch: got %v, want %v\", tt.input, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.t == TypeArray {\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\treturn v1.s == v2.s\n}","bd08cdc2e23161062627047e003b8850":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic escapes\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\t`, \"\\t\"},\n\t\t{`\\\\`, `\\`},\n\t\t{`\\\"`, `\"`},\n\t\t{`\\/`, `/`},\n\n\t\t// Unicode escapes\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A0`, \"\\u00A0\"},\n\t\t{`\\u20AC`, \"\\u20AC\"},\n\n\t\t// Surrogate pairs\n\t\t{`\\uD83D\\uDE02`, \"\\U0001F602\"},\n\n\t\t// Invalid escapes\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\uD800`, `\\uD800`},\n\t\t{`\\uD800\\u`, `\\uD800\\u`},\n\n\t\t// Combinations\n\t\t{`hello\\tworld\\n`, \"hello\\tworld\\n\"},\n\t\t{`\\u0041\\u0042\\u0043`, \"ABC\"},\n\t\t{`\\uD83D\\uDE02\\uD83D\\uDE02`, \"\\U0001F602\\U0001F602\"},\n\n\t\t// Real-world examples\n\t\t{`{\"key\": \"value with \\\\\\\"quotes\\\\\\\" and \\\\\\\\backslashes\\\\\\\\\"}`, `{\"key\": \"value with \\\"quotes\\\" and \\\\backslashes\\\\\"}`},\n\t}\n\n\tfor i, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Test %d failed: expected '%s', got '%s'\", i+1, test.expected, actual)\n\t\t}\n\t}\n}","bd43f4fafcaeeba798c3f402040ffc31":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic tests\n\t\t{`\"hello, world\"`, `hello, world`},\n\t\t{`\"escaped \\\\\\\" string\"`, `escaped \\\" string`},\n\t\t{`\"escaped \\\\/ string\"`, `escaped / string`},\n\t\t{`\"escaped \\\\\\\\ string\"`, `escaped \\\\ string`},\n\t\t{`\"escaped \\\\b string\"`, `escaped \\b string`},\n\t\t{`\"escaped \\\\f string\"`, `escaped \\f string`},\n\t\t{`\"escaped \\\\n string\"`, `escaped \\n string`},\n\t\t{`\"escaped \\\\r string\"`, `escaped \\r string`},\n\t\t{`\"escaped \\\\t string\"`, `escaped \\t string`},\n\n\t\t// Unicode escape sequences\n\t\t{`\"\\u0041\\u0042\\u0043\"`, \"ABC\"},\n\t\t{`\"\\u041f\\u0440\\u0438\\u0432\\u0435\\u0442 \\\\\\\"\\\\\\\"\"`, \"–ü—Ä–∏–≤–µ—Ç \\\\\\\"\\\\\\\"\"},\n\t\t{`\"invalid \\\\u123 escape sequence\"`, \"invalid \\\\u123 escape sequence\"},\n\t\t{`\"invalid \\\\u12345 escape sequence\"`, \"invalid \\\\u12345 escape sequence\"},\n\n\t\t// Surrogate pairs\n\t\t{`\"\\uD83D\\uDE02\"`, \"üòÇ\"}, // FACE WITH TEARS OF JOY\n\t\t{`\"invalid surrogate \\\\uD83D\\\\u1234\"`, \"invalid surrogate \\\\uD83D\\\\u1234\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}","be3fef38b753fb00b2dd27df1c22fb9f":"package fastjson\n\nimport \"testing\"\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tt    Type\n\t\twant string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\tfor i, tt := range tests {\n\t\tgot := tt.t.String()\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"test[%d]: String() = %q, want %q\", i, got, tt.want)\n\t\t}\n\t}\n}\n","bfd9bf47990529b6e2f1fe69b5593909":"package fastjson\n\nimport \"testing\"\n\nfunc Test_hasSpecialChars(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    string\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\ts:    \"\",\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with no special characters\",\n\t\t\ts:    \"hello world\",\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with double quotes\",\n\t\t\ts:    \"hello \\\"world\\\"\",\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with backslash\",\n\t\t\ts:    \"hello\\\\world\",\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with control character\",\n\t\t\ts:    \"hello\\x00world\",\n\t\t\twant: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := hasSpecialChars(tt.s); got != tt.want {\n\t\t\t\tt.Errorf(\"hasSpecialChars() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","bfff9a81256b0c60aeeaa312fc7ea322":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twant     *Value\n\t\twantRest string\n\t\twantErr  error\n\t}{\n\t\t{\n\t\t\tname:     \"empty array\",\n\t\t\tinput:    \"[]\",\n\t\t\twant:     \u0026Value{t: TypeArray},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"single element array\",\n\t\t\tinput:    \"[1]\",\n\t\t\twant:     \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple element array\",\n\t\t\tinput:    \"[1,2,3]\",\n\t\t\twant:     \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with whitespace\",\n\t\t\tinput:    \" [ 1 , 2 , 3 ] \",\n\t\t\twant:     \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}},\n\t\t\twantRest: \" \",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"nested array\",\n\t\t\tinput:    \"[[1,2],[3,4]]\",\n\t\t\twant: \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}}},\n\t\t\t\t{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"3\"}, {t: TypeNumber, s: \"4\"}}},\n\t\t\t}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing ]\",\n\t\t\tinput:    \"[1,2\",\n\t\t\twant:     nil,\n\t\t\twantRest: \"\",\n\t\t\twantErr:  fmt.Errorf(\"unexpected end of array\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"missing ,\",\n\t\t\tinput:    \"[1 2]\",\n\t\t\twant:     nil,\n\t\t\twantRest: \"\",\n\t\t\twantErr:  fmt.Errorf(\"missing ',' after array value\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, rest, err := parseArray(tt.input, c, 0)\n\t\t\tif fmt.Sprintf(\"%v\", err) != fmt.Sprintf(\"%v\", tt.wantErr) {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got == nil \u0026\u0026 tt.want == nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got.t != tt.want.t {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got.t, tt.want.t)\n\t\t\t}\n\t\t\tif len(got.a) != len(tt.want.a) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", len(got.a), len(tt.want.a))\n\t\t\t}\n\t\t\tfor i, v := range got.a {\n\t\t\t\tif v.s != tt.want.a[i].s {\n\t\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", v.s, tt.want.a[i].s)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif rest != tt.wantRest {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", rest, tt.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}","c0874c7164c921c92d5c73b5e96f2adc":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc Test_parseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\ts    string\n\t\twant string\n\t\ttail string\n\t\terr  error\n\t}{\n\t\t// Edge cases\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t\t{\"-\", \"\", \"-\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t\t{\"+\", \"\", \"+\", fmt.Errorf(\"unexpected char: %q\", \"+\")},\n\n\t\t// Valid numbers\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"+123\", \"+123\", \"\", nil},\n\t\t{\"12.34\", \"12.34\", \"\", nil},\n\t\t{\"12e5\", \"12e5\", \"\", nil},\n\t\t{\"12E5\", \"12E5\", \"\", nil},\n\t\t{\"12e+5\", \"12e+5\", \"\", nil},\n\t\t{\"12e-5\", \"12e-5\", \"\", nil},\n\n\t\t// Valid numbers with trailing characters\n\t\t{\"123a\", \"123\", \"a\", nil},\n\t\t{\"-123a\", \"-123\", \"a\", nil},\n\t\t{\"12.34a\", \"12.34\", \"a\", nil},\n\n\t\t// Invalid numbers\n\t\t{\"a123\", \"\", \"a123\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\"123.a\", \"123\", \".a\", nil},\n\n\t\t// Inf and NaN\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"+Inf\", \"+Inf\", \"\", nil},\n\t\t{\"-INF\", \"-INF\", \"\", nil},\n\t\t{\"NaN\", \"NaN\", \"\", nil},\n\n\t\t// Inf and NaN with trailing characters\n\t\t{\"infx\", \"inf\", \"x\", nil},\n\t\t{\"+Infy\", \"+Inf\", \"y\", nil},\n\t\t{\"-INFz\", \"-INF\", \"z\", nil},\n\t\t{\"NaNw\", \"NaN\", \"w\", nil},\n\t}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tgot, tail, err := parseRawNumber(tt.s)\n\t\t\tif got != tt.want || tail != tt.tail || !equalError(err, tt.err) {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = (%v, %v, %v), want (%v, %v, %v)\", tt.s, got, tail, err, tt.want, tt.tail, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// equalError reports whether errors a and b are equal.\n// They're equal if both are nil, or both are not nil and a.Error() == b.Error().\nfunc equalError(a, b error) bool {\n\treturn a == nil \u0026\u0026 b == nil || a != nil \u0026\u0026 b != nil \u0026\u0026 a.Error() == b.Error()\n}\n","c139b8b840fd95c233cf58a5b0b8e307":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput  string\n\t\texpect string\n\t\tremain string\n\t\terr    error\n\t}{\n\t\t// basic\n\t\t{`\"foo\"bar`, `foo`, `bar`, nil},\n\t\t{`\"fo\\to\"bar`, \"fo\\to\", `bar`, nil},\n\t\t{`\"foo\"`, `foo`, ``, nil},\n\n\t\t// escaped quote\n\t\t{`\"foo\\\"bar\"baz`, `foo\"bar`, `baz`, nil},\n\t\t{`\"foo\\\\\\\"bar\"baz`, `foo\\\"bar`, `baz`, nil},\n\t\t{`\"foo\\\\\\\\\"bar\"baz`, `foo\\\\`, `bar\"baz`, nil},\n\n\t\t// invalid\n\t\t{`\"foo\"bar\"`, `foo`, `bar\"`, nil},\n\t\t{`\"foo`, ``, ``, fmt.Errorf(`missing closing '\"'`)},\n\t\t{`foo`, `foo`, ``, fmt.Errorf(`missing closing '\"'`)},\n\t}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tactual, remain, err := parseRawString(tt.input)\n\t\t\tif actual != tt.expect || remain != tt.remain || (err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"input: %s, expect: %s,%s,%v, actual: %s,%s,%v\", tt.input, tt.expect, tt.remain, tt.err, actual, remain, err)\n\t\t\t}\n\t\t})\n\t}\n}","c2da5751cd2c5398838167b28b6919cf":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t// TODO: Add test cases.\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv:    \u0026Value{t: typeRawString, s: \"raw string\"},\n\t\t\twant: []byte(\"\\\"raw string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv:    \u0026Value{t: TypeString, s: \"string\"},\n\t\t\twant: []byte(\"\\\"string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv:    \u0026Value{t: TypeNumber, s: \"1234\"},\n\t\t\twant: []byte(\"1234\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv:    \u0026Value{t: TypeTrue},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv:    \u0026Value{t: TypeFalse},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv:    \u0026Value{t: TypeNull},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1234\"},\n\t\t\t\t\t{t: TypeString, s: \"string\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"[1234,\\\"string\\\"]\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := make([]byte, 0, len(tt.want))\n\t\t\tgot := tt.v.MarshalTo(dst)\n\n\t\t\tif string(got) != string(tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","c32a429bd8165819c0e2efc39c6b825a":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey   string\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Basic cases\n\t\t{`\"foo\"bar`, \"foo\", \"bar\", nil},\n\t\t{`\"fo\\\"o\"bar`, `fo\"o`, \"bar\", nil},\n\t\t{`\"foo\" bar`, \"foo\", \" bar\", nil},\n\t\t{`\"foo\"`, \"foo\", \"\", nil},\n\n\t\t// Escaped quotes\n\t\t{`\"foo\\\"bar\"baz`, `foo\"bar`, \"baz\", nil},\n\t\t{`\"foo\\\\\\\"bar\"baz`, `foo\\\"bar`, \"baz\", nil},\n\t\t{`\"foo\\\\\\\\\"bar\"baz`, `foo\\\\`, `bar\"baz`, nil},\n\n\t\t// Missing closing quote\n\t\t{`\"foo`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo\"bar\"`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\n\t\t// Empty strings\n\t\t{`\"\"bar`, \"\", \"bar\", nil},\n\t\t{`\"\"`, \"\", \"\", nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tkey, tail, err := parseRawString(tt.input)\n\t\t\tif key != tt.key || tail != tt.tail || (err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = (%q, %q, %v), want (%q, %q, %v)\", tt.input, key, tail, err, tt.key, tt.tail, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}\n","c3af1e47e08002ea2a66ba4555dc8b2c":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetStringBytes(t *testing.T) {\n\tvar tests = []struct {\n\t\tname     string\n\t\tjson     string\n\t\targs     []string\n\t\twant     []byte\n\t\twantFail bool\n\t}{\n\t\t{\n\t\t\tname: \"simple\",\n\t\t\tjson: `{\"foo\":\"bar\"}`,\n\t\t\targs: []string{\"foo\"},\n\t\t\twant: []byte(\"bar\"),\n\t\t},\n\t\t{\n\t\t\tname: \"nested\",\n\t\t\tjson: `{\"foo\":{\"bar\":\"baz\"}}`,\n\t\t\targs: []string{\"foo\", \"bar\"},\n\t\t\twant: []byte(\"baz\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"nonexisting\",\n\t\t\tjson:     `{\"foo\":\"bar\"}`,\n\t\t\targs:     []string{\"baz\"},\n\t\t\twantFail: true,\n\t\t},\n\t\t{\n\t\t\tname: \"arrayIndex\",\n\t\t\tjson: `{\"foo\":[\"bar\", \"baz\"]}`,\n\t\t\targs: []string{\"foo\", \"1\"},\n\t\t\twant: []byte(\"baz\"),\n\t\t},\n\t\t{\n\t\t\tname: \"arrayIndexDecimal\",\n\t\t\tjson: `{\"foo\":[\"bar\", \"baz\"]}`,\n\t\t\targs: []string{\"foo\", \"1.0\"},\n\t\t\twant: []byte(\"baz\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"arrayIndexOutOfBounds\",\n\t\t\tjson:     `{\"foo\":[\"bar\"]}`,\n\t\t\targs:     []string{\"foo\", \"1\"},\n\t\t\twantFail: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"arrayIndexInvalid\",\n\t\t\tjson:     `{\"foo\":[\"bar\"]}`,\n\t\t\targs:     []string{\"foo\", \"a\"},\n\t\t\twantFail: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalidValueType\",\n\t\t\tjson:     `{\"foo\":123}`,\n\t\t\targs:     []string{\"foo\"},\n\t\t\twantFail: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv, err := ParseBytes([]byte(tt.json))\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"Error parsing JSON: %s\", err)\n\t\t\t}\n\n\t\t\tgot := v.GetStringBytes(tt.args...)\n\t\t\tif tt.wantFail {\n\t\t\t\tif got != nil {\n\t\t\t\t\tt.Errorf(\"Expected nil, got %v\", got)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif string(got) != string(tt.want) {\n\t\t\t\tt.Errorf(\"GetStringBytes() = %v, want %v\", string(got), string(tt.want))\n\t\t\t}\n\t\t})\n\t}\n}","c3ca300ea3ef3c2d58924dcfd3e7b4d8":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\tvar tests = []struct {\n\t\ts string\n\t\twant string\n\t}{\n\t\t// Empty strings\n\t\t{\"\", \"\"},\n\n\t\t// Simple strings without escape characters\n\t\t{\"hello\", \"hello\"},\n\t\t{\"world\", \"world\"},\n\t\t{\"foobar\", \"foobar\"},\n\n\t\t// Valid escape sequences\n\t\t{`\\\"`, `\"`},\n\t\t{`\\\\`, `\\`},\n\t\t{`\\/`, `/`},\n\t\t{`\\b`, \"\\b\"},\n\t\t{`\\f`, \"\\f\"},\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\r`, \"\\r\"},\n\t\t{`\\t`, \"\\t\"},\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A9`, \"¬©\"},\n\t\t{`\\u20AC`, \"‚Ç¨\"},\n\t\t{\"\\\\uD83D\\\\uDE01\", \"üòÅ\"}, // Surrogate pair\n\n\t\t// Invalid escape sequences\n\t\t{`\\a`, `\\a`},\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u`, `\\u`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\uD800`, `\\uD800`}, // Isolated surrogate\n\t\t{`\\uDFFF`, `\\uDFFF`}, // Isolated surrogate\n\t\t{`\\\\uD83D`, `\\\\uD83D`}, // Incomplete surrogate pair\n\t\t{`\\uD83D\\\\u`, `\\uD83D\\u`}, // Incomplete surrogate pair\n\n\t\t// Mixed valid and invalid escape sequences\n\t\t{`hello\\nworld`, \"hello\\nworld\"},\n\t\t{`foo\\xbar`, \"foo\\xbar\"},\n\t\t{`\\u0041\\u0042\\u0043`, \"ABC\"},\n\t\t{`\\uD83D\\uDE02\\uD83D\\uDE09`, \"üòÇüòâ\"},\n\t}\n\tfor i, tt := range tests {\n\t\tgot := unescapeStringBestEffort(tt.s)\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"test %d: unescapeStringBestEffort(%q) = %q, want %q\", i, tt.s, got, tt.want)\n\t\t}\n\t}\n}","c3d3743fdc801655ec63135d7bb59672":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc Test_cache_getValue(t *testing.T) {\n\tt.Run(\"grow and get\", func(t *testing.T) {\n\t\tc := \u0026cache{}\n\t\tval1 := c.getValue()\n\t\tif val1 == nil {\n\t\t\tt.Fatal(\"expected non-nil value\")\n\t\t}\n\t\tval2 := c.getValue()\n\t\tif val2 == nil {\n\t\t\tt.Fatal(\"expected non-nil value\")\n\t\t}\n\t\tif val1 == val2 {\n\t\t\tt.Fatal(\"got same value for different calls\")\n\t\t}\n\t\tif len(c.vs) != 2 {\n\t\t\tt.Errorf(\"expected length 2, got %d\", len(c.vs))\n\t\t}\n\t})\n\n\tt.Run(\"reuse and get\", func(t *testing.T) {\n\t\tc := \u0026cache{\n\t\t\tvs: make([]Value, 1),\n\t\t}\n\t\tval1 := c.getValue()\n\t\tif val1 == nil {\n\t\t\tt.Fatal(\"expected non-nil value\")\n\t\t}\n\t\tval2 := c.getValue()\n\t\tif val2 == nil {\n\t\t\tt.Fatal(\"expected non-nil value\")\n\t\t}\n\t\tif val1 == val2 {\n\t\t\tt.Fatal(\"got same value for different calls\")\n\t\t}\n\t\tif len(c.vs) != 2 {\n\t\t\tt.Errorf(\"expected length 2, got %d\", len(c.vs))\n\t\t}\n\t})\n}","c3f9de78bc4ab5f2c224c68fe6a512d2":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetObject(t *testing.T) {\n\tt.Run(\"empty json\", func(t *testing.T) {\n\t\tv := MustParseString(``)\n\t\tif got := v.GetObject(); got != nil {\n\t\t\tt.Errorf(\"GetObject() = %v, want nil\", got)\n\t\t}\n\t})\n\n\tt.Run(\"root object\", func(t *testing.T) {\n\t\tv := MustParseString(`{\"foo\": {\"bar\": \"baz\"}}`)\n\t\tgot := v.GetObject(\"foo\")\n\t\twant, _ := v.Get(\"foo\").Object()\n\t\tif got != want {\n\t\t\tt.Errorf(\"GetObject() = %p, want %p\", got, want)\n\t\t}\n\t})\n\n\tt.Run(\"nested object\", func(t *testing.T) {\n\t\tv := MustParseString(`{\"foo\": {\"bar\": {\"baz\": \"qux\"}}}`)\n\t\tgot := v.GetObject(\"foo\", \"bar\")\n\t\twant, _ := v.Get(\"foo\", \"bar\").Object()\n\t\tif got != want {\n\t\t\tt.Errorf(\"GetObject() = %p, want %p\", got, want)\n\t\t}\n\t})\n\n\tt.Run(\"array index\", func(t *testing.T) {\n\t\tv := MustParseString(`{\"foo\": [{\"bar\": \"baz\"}]}`)\n\t\tgot := v.GetObject(\"foo\", \"0\")\n\t\twant, _ := v.Get(\"foo\", \"0\").Object()\n\t\tif got != want {\n\t\t\tt.Errorf(\"GetObject() = %p, want %p\", got, want)\n\t\t}\n\t})\n\n\tt.Run(\"non-existing key\", func(t *testing.T) {\n\t\tv := MustParseString(`{\"foo\": {\"bar\": \"baz\"}}`)\n\t\tif got := v.GetObject(\"qux\"); got != nil {\n\t\t\tt.Errorf(\"GetObject() = %v, want nil\", got)\n\t\t}\n\t})\n\n\tt.Run(\"invalid value type\", func(t *testing.T) {\n\t\tv := MustParseString(`{\"foo\": \"bar\"}`)\n\t\tif got := v.GetObject(\"foo\", \"baz\"); got != nil {\n\t\t\tt.Errorf(\"GetObject() = %v, want nil\", got)\n\t\t}\n\t})\n}","c41fada46f28a36a945f14b1dabf43f8":"package fastjson\n\nimport \"testing\"\n\nfunc Test_skipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    string\n\t\twant string\n\t}{\n\t\t// TODO: Add test cases.\n\t\t{\n\t\t\tname: \"EmptyString\",\n\t\t\ts:    \"\",\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"StringWithLeadingWhitespace\",\n\t\t\ts:    \"  foo\",\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"StringWithTrailingWhitespace\",\n\t\t\ts:    \"foo  \",\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"StringWithWhitespaceBetweenCharacters\",\n\t\t\ts:    \"f o o\",\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"StringWithoutWhitespace\",\n\t\t\ts:    \"foo\",\n\t\t\twant: \"\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","c4ca0fa3d11b72162681fabfbab58d61":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCache_getValue(t *testing.T) {\n\tt.Run(\"grow cache\", func(t *testing.T) {\n\t\tc := \u0026cache{}\n\t\tif got := c.getValue(); got == nil {\n\t\t\tt.Errorf(\"getValue() = nil, want non-nil\")\n\t\t}\n\t\tif got := c.getValue(); got == nil {\n\t\t\tt.Errorf(\"getValue() = nil, want non-nil\")\n\t\t}\n\t\tif len(c.vs) != 2 {\n\t\t\tt.Errorf(\"unexpected cache size: %d\", len(c.vs))\n\t\t}\n\t})\n\n\tt.Run(\"reuse cache\", func(t *testing.T) {\n\t\tc := \u0026cache{\n\t\t\tvs: make([]Value, 10),\n\t\t}\n\t\twant := c.getValue()\n\t\tif got := c.getValue(); got != want {\n\t\t\tt.Errorf(\"getValue() = %p, want %p\", got, want)\n\t\t}\n\t\tif len(c.vs) != 10 {\n\t\t\tt.Errorf(\"unexpected cache size: %d\", len(c.vs))\n\t\t}\n\t})\n}","c5586c4ceae5d3f167bcc3ee23c33dbe":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantNum  string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Basic cases.\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"123.45\", \"123.45\", \"\", nil},\n\t\t{\"1.23e45\", \"1.23e45\", \"\", nil},\n\t\t{\"1.23e+45\", \"1.23e+45\", \"\", nil},\n\t\t{\"1.23e-45\", \"1.23e-45\", \"\", nil},\n\n\t\t// Trailing garbage.\n\t\t{\"123a\", \"123\", \"a\", nil},\n\t\t{\"-123a\", \"-123\", \"a\", nil},\n\t\t{\"123.45a\", \"123.45\", \"a\", nil},\n\n\t\t// Leading garbage.\n\t\t{\"a123\", \"\", \"a123\", fmt.Errorf(`unexpected char: \"a\"`)},\n\n\t\t// Special cases.\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"+inf\", \"+inf\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"Infin\", \"Inf\", \"in\", nil}, // Case-insensitive.\n\t\t{\"+Infin\", \"+Inf\", \"in\", nil},\n\t\t{\"-Infin\", \"-Inf\", \"in\", nil},\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"+nan\", \"+nan\", \"\", nil}, // Allowed by JSON spec.\n\t\t{\"-nan\", \"-nan\", \"\", nil}, // Allowed by JSON spec.\n\t\t{\"NaN\", \"NaN\", \"\", nil},\n\t\t{\"+NaN\", \"+NaN\", \"\", nil},\n\t\t{\"-NaN\", \"-NaN\", \"\", nil},\n\n\t\t// Invalid cases.\n\t\t{\"\", \"\", \"\", fmt.Errorf(`unexpected char: \"\"`)},\n\t\t{\"-\", \"\", \"-\", fmt.Errorf(`unexpected char: \"-\"`)},\n\t\t{\"+\", \"\", \"+\", fmt.Errorf(`unexpected char: \"+\"`)},\n\t\t{\"in\", \"\", \"in\", fmt.Errorf(`unexpected char: \"i\"`)},\n\t\t{\"+i\", \"\", \"+i\", fmt.Errorf(`unexpected char: \"+\"`)},\n\t\t{\"-i\", \"\", \"-i\", fmt.Errorf(`unexpected char: \"-\"`)},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tgotNum, gotTail, gotErr := parseRawNumber(tt.input)\n\t\t\tif gotNum != tt.wantNum {\n\t\t\t\tt.Errorf(\"input: %q, gotNum: %q, want: %q\", tt.input, gotNum, tt.wantNum)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"input: %q, gotTail: %q, want: %q\", tt.input, gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif gotErr != nil \u0026\u0026 tt.wantErr == nil {\n\t\t\t\tt.Errorf(\"input: %q, unexpected error: %v\", tt.input, gotErr)\n\t\t\t} else if gotErr == nil \u0026\u0026 tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"input: %q, expected error: %v, but got nil\", tt.input, tt.wantErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"input: %q, got error: %v, want: %v\", tt.input, gotErr, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","c55ae409893aa760b6837960ae6d3139":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic escapes\n\t\t{`\\b`, \"\\b\"},\n\t\t{`\\f`, \"\\f\"},\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\r`, \"\\r\"},\n\t\t{`\\t`, \"\\t\"},\n\t\t{`\\\\`, `\\`},\n\t\t{`\\/`, `/`},\n\t\t{`\\\"`, `\"`},\n\n\t\t// Unicode escapes\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A0`, \"\\u00A0\"},\n\t\t{`\\uFFFF`, \"\\uFFFF\"},\n\n\t\t// Surrogate pairs\n\t\t{`\\uD83D\\uDE02`, \"\\U0001F602\"},\n\n\t\t// Invalid escapes\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\uD800`, `\\uD800`},\n\t\t{`\\uD800\\u`, `\\uD800\\u`},\n\n\t\t// Mixed strings\n\t\t{`Hello\\tworld\\n`, \"Hello\\tworld\\n\"},\n\t\t{`\"This is a test\\\\string.\"`, \"\\\"This is a test\\\\string.\\\"\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\tactual := unescapeStringBestEffort(tt.input)\n\t\tif actual != tt.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", tt.input, actual, tt.expected)\n\t\t}\n\t}\n}","c5cb7d728cb8fdc34f85c406b961cc9e":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic strings without escape sequences.\n\t\t{\"hello\", \"hello\"},\n\t\t{\"world\", \"world\"},\n\t\t{\"12345\", \"12345\"},\n\n\t\t// Escaped quotes.\n\t\t{`\"hello\\\"\", \"hello\\\"\"`, `hello\"`},\n\t\t{`\"world\\\"\", \"world\\\"\"`, `world\"`},\n\n\t\t// Simple escape sequences.\n\t\t{`\\b`, \"\\b\"},\n\t\t{`\\f`, \"\\f\"},\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\r`, \"\\r\"},\n\t\t{`\\t`, \"\\t\"},\n\t\t{`\\\\`, `\\`},\n\t\t{`\\/`, `/`},\n\n\t\t// Unicode escape sequences.\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A0`, \"\\u00A0\"},\n\t\t{`\\u00A9`, \"¬©\"},\n\t\t{`\\u20AC`, \"‚Ç¨\"},\n\n\t\t// Surrogate pairs.\n\t\t{`\\uD83D\\uDE01`, \"üòÅ\"},\n\t\t{`\\uD83D\\uDC4D`, \"üëç\"},\n\n\t\t// Invalid escape sequences.\n\t\t{`\\z`, `\\z`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\uD800`, `\\uD800`},\n\t\t{`\\uD800\\u1234`, `\\uD800\\u1234`},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}","c5cdd5f26f85c8b4f71fd4ad327b5a2e":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_reset(t *testing.T) {\n\to := Object{\n\t\tkvs: []kv{\n\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t},\n\t\tkeysUnescaped: true,\n\t}\n\n\to.reset()\n\n\tif len(o.kvs) != 0 {\n\t\tt.Errorf(\"Expected o.kvs to be empty after reset, got %v\", o.kvs)\n\t}\n\n\tif o.keysUnescaped != false {\n\t\tt.Errorf(\"Expected o.keysUnescaped to be false after reset, got %v\", o.keysUnescaped)\n\t}\n}","c6faba2bbfc994b9485296bddc91361b":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantObj  string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t{\n\t\t\tname:     \"EmptyObject\",\n\t\t\tinput:    \"{}\",\n\t\t\twantObj:  \"{}\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"SimpleObject\",\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\twantObj:  `{\"key\": \"value\"}`,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"ComplexObject\",\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 123, \"key3\": true}`,\n\t\t\twantObj:  `{\"key1\": \"value1\", \"key2\": 123, \"key3\": true}`,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"NestedObject\",\n\t\t\tinput:    `{\"key1\": {\"key2\": \"value2\"}, \"key3\": \"value3\"}`,\n\t\t\twantObj:  `{\"key1\": {\"key2\": \"value2\"}, \"key3\": \"value3\"}`,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"MissingClosingBrace\",\n\t\t\tinput:    `{\"key\": \"value\"`,\n\t\t\twantObj:  \"\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"InvalidKey\",\n\t\t\tinput:    `{key: \"value\"}`,\n\t\t\twantObj:  \"\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  fmt.Errorf(\"cannot parse object key: cannot find opening '\\\"' for object key\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"MissingColon\",\n\t\t\tinput:    `{\"key\" \"value\"}`,\n\t\t\twantObj:  \"\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"InvalidValue\",\n\t\t\tinput:    `{\"key\": value}`,\n\t\t\twantObj:  \"\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  fmt.Errorf(\"cannot parse object value: invalid character 'v' looking for beginning of value\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"MissingComma\",\n\t\t\tinput:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantObj:  \"\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgotObj, gotTail, gotErr := parseObject(tt.input, c, 0)\n\n\t\t\tif gotErr != nil {\n\t\t\t\tif tt.wantErr == nil {\n\t\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", gotErr, tt.wantErr)\n\t\t\t\t} else if gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", gotErr, tt.wantErr)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif tt.wantErr != nil {\n\t\t\t\tif gotErr == nil {\n\t\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", gotErr, tt.wantErr)\n\t\t\t\t} else if gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", gotErr, tt.wantErr)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif gotObj.String() != tt.wantObj {\n\t\t\t\tt.Errorf(\"parseObject() gotObj = %s, want %s\", gotObj.String(), tt.wantObj)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseObject() gotTail = %s, want %s\", gotTail, tt.wantTail)\n\t\t\t}\n\t\t})\n\t}\n}","c764ce35ca14ae6a72207278122d0d5b":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"raw string\",\n\t\t\t},\n\t\t\twant: []byte(`\"raw string\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"string\",\n\t\t\t},\n\t\t\twant: []byte(`\"string\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"12345\",\n\t\t\t},\n\t\t\twant: []byte(\"12345\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"string\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"12345\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`[\"string\",12345]`),\n\t\t},\n\t\t// Add more test cases for other types and nested structures\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif string(got) != string(tt.want) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","c7df6ab3486acf816f4a9b764f6a03d8":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t\ttail     string\n\t\terr      error\n\t}{\n\t\t// Basic cases\n\t\t{`\"foo\"bar`, `foo`, `bar`, nil},\n\t\t{`\"fo\\\"o\"bar`, `fo\"o`, `bar`, nil},\n\t\t{`\"foo\"`, `foo`, ``, nil},\n\t\t{`\"foo`, ``, ``, fmt.Errorf(`missing closing '\"'`)},\n\n\t\t// Escaped quotes\n\t\t{`\"fo\\\\o\"bar`, `fo\\o`, `bar`, nil},\n\t\t{`\"fo\\\\\\\\o\"bar`, `fo\\\\o`, `bar`, nil},\n\t\t{`\"fo\\\\\\\"o\"bar`, `fo\\\"o`, `bar`, nil},\n\t\t{`\"fo\\\\\\o\"bar`, `fo\\o`, `bar`, nil},\n\n\t\t// Empty strings\n\t\t{`\"\"bar`, ``, `bar`, nil},\n\t\t{`\"\\\\\"bar`, `\\`, `bar`, nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d:%s\", i, tt.input), func(t *testing.T) {\n\t\t\tactual, tail, err := parseRawString(tt.input)\n\t\t\tif actual != tt.expected || tail != tt.tail {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"Test '%s' failed: expected=[%s,%s,nil], actual=[%s,%s,%v]\", tt.input, tt.expected, tt.tail, actual, tail, err)\n\t\t\t\t} else {\n\t\t\t\t\tt.Errorf(\"Test '%s' failed: expected=[%s,%s,%v], actual=[%s,%s,%v]\", tt.input, tt.expected, tt.tail, tt.err, actual, tail, err)\n\t\t\t\t}\n\t\t\t} else if tt.err != nil \u0026\u0026 err == nil {\n\t\t\t\tt.Errorf(\"Test '%s' failed: expected=[%s,%s,%v], actual=[%s,%s,%v]\", tt.input, tt.expected, tt.tail, tt.err, actual, tail, err)\n\t\t\t}\n\t\t})\n\t}\n}\n","c8009aa53c1b79da028713d43677a10e":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\twantS string\n\t\terr   error\n\t}{\n\t\t// Empty array\n\t\t{\"[]\", \u0026Value{t: TypeArray}, \"\", nil},\n\t\t// Simple array\n\t\t{\"[1,2,3]\", \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}}, \"\", nil},\n\t\t// Array with whitespace\n\t\t{\" [ 1 , 2 , 3 ] \", \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}}, \"\", nil},\n\t\t// Nested array\n\t\t{\"[[1,2],[3,4]]\", \u0026Value{t: TypeArray, a: []*Value{{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}}}, {t: TypeArray, a: []*Value{{t: TypeNumber, s: \"3\"}, {t: TypeNumber, s: \"4\"}}}}}, \"\", nil},\n\t\t// Array with different types\n\t\t{\"[1,\\\"hello\\\",true]\", \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeString, s: \"hello\"}, {t: TypeTrue}}}, \"\", nil},\n\t\t// Invalid array: missing closing bracket\n\t\t{\"[1,2,3\", nil, \"[1,2,3\", fmt.Errorf(\"missing ']'\")},\n\t\t// Invalid array: missing comma\n\t\t{\"[1 2 3]\", nil, \"2 3]\", fmt.Errorf(\"missing ',' after array value\")},\n\t\t// Invalid array: unexpected end\n\t\t{\"[1,\", nil, \"\", fmt.Errorf(\"unexpected end of array\")},\n\t}\n\n\tfor i, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, gotS, err := parseArray(test.input, c, 0)\n\n\t\t\tif test.err != nil {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"Expected error, got nil\")\n\t\t\t\t} else if err.Error() != test.err.Error() {\n\t\t\t\t\tt.Errorf(\"Expected error %v, got %v\", test.err, err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t\t}\n\n\t\t\tif gotS != test.wantS {\n\t\t\t\tt.Errorf(\"Expected remaining string %q, got %q\", test.wantS, gotS)\n\t\t\t}\n\n\t\t\tif !equalValues(got, test.want) {\n\t\t\t\tt.Errorf(\"Test %d failed: input %q, got %v, want %v\", i, test.input, got, test.want)\n\t\t\t}\n\n\t\t})\n\t}\n}\n\nfunc equalValues(a, b *Value) bool {\n\tif a == nil \u0026\u0026 b == nil {\n\t\treturn true\n\t}\n\tif a == nil || b == nil {\n\t\treturn false\n\t}\n\tif a.t != b.t {\n\t\treturn false\n\t}\n\tswitch a.t {\n\tcase TypeArray:\n\t\tif len(a.a) != len(b.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range a.a {\n\t\t\tif !equalValues(a.a[i], b.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeString, TypeNumber:\n\t\treturn a.s == b.s\n\tcase TypeTrue, TypeFalse, TypeNull:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}","c80f450b5ed4b0fa2ce024b7f69bb8fc":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twant     *Value\n\t\twantRest string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"empty object\",\n\t\t\tinput:    \"{}\",\n\t\t\twant:     \u0026Value{t: TypeObject, o: Object{}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"simple object\",\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\twant:     \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{t: TypeString, s: \"value\"}}}}}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, rest, err := parseObject(tt.input, c, 0)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif rest != tt.wantRest {\n\t\t\t\tt.Errorf(\"parseObject() rest = %v, wantRest %v\", rest, tt.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn equalObjects(\u0026v1.o, \u0026v2.o)\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\t// Add other type comparisons as needed\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc equalObjects(o1, o2 *Object) bool {\n\tif o1.Len() != o2.Len() {\n\t\treturn false\n\t}\n\tfor i := 0; i \u003c o1.Len(); i++ {\n\t\tkv1 := o1.kvs[i]\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !equalValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n","c862c57bfd6664eb3772ddfd9cc5ec8c":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic strings\n\t\t{\"hello\", \"hello\"},\n\t\t{\"world\", \"world\"},\n\n\t\t// Escaped characters\n\t\t{`\\\"hello\\\"`, `\"hello\"`},\n\t\t{`\\\\world\\\\`, `\\world\\`},\n\t\t{`\\bfoo\\tbar\\nbaz`, \"\\bfoo\\tbar\\nbaz\"},\n\t\t{`\\r\\n`, \"\\r\\n\"},\n\n\t\t// Unicode escape sequences\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A0`, \"\\u00A0\"}, // Non-breaking space\n\t\t{`\\uFFFF`, \"\\uFFFF\"},\n\t\t{`\\uD83D\\uDE01`, \"\\U0001F601\"}, // Smiling face with sunglasses emoji\n\n\t\t// Invalid escape sequences\n\t\t{`\\z`, `\\z`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\uD800`, `\\uD800`}, // Invalid surrogate pair\n\t\t{`\\uD800\\uDC00x`, `\\uD800\\uDC00x`}, // Invalid surrogate pair\n\n\t\t// Mixed valid and invalid escape sequences\n\t\t{`hello\\u0020world`, \"hello world\"},\n\t\t{`\\u0020hello\\uD800world`, \" hello\\uD800world\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}\n","c89109383f77829fd96d34eb2ecc83ef":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"raw string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"raw string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"12345\",\n\t\t\t},\n\t\t\twant: []byte(\"12345\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"string\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"12345\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"[\\\"string\\\",12345]\"),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"string\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"string\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"number\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"12345\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"{\\\"string\\\":\\\"string\\\",\\\"number\\\":\\\"12345\\\"}\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif string(got) != string(tt.want) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %v, want %v\", string(got), string(tt.want))\n\t\t\t}\n\t\t})\n\t}\n}\n","c9f4acd3cb04b2ed994e2e7099cc5b41":"package fastjson\n\nimport \"testing\"\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tt    Type\n\t\twant string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\tfor i, tt := range tests {\n\t\tif got := tt.t.String(); got != tt.want {\n\t\t\tt.Errorf(\"test %d: String() = %q, want %q\", i, got, tt.want)\n\t\t}\n\t}\n}","cac4f04680835dd843013cfc1b730880":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEscapeString(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tdst      []byte\n\t\ts        string\n\t\texpected []byte\n\t}{\n\t\t{\n\t\t\tname:     \"Empty\",\n\t\t\tdst:      []byte{},\n\t\t\ts:        \"\",\n\t\t\texpected: []byte(`\"\"`),\n\t\t},\n\t\t{\n\t\t\tname:     \"Simple\",\n\t\t\tdst:      []byte{},\n\t\t\ts:        \"hello\",\n\t\t\texpected: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname:     \"WithQuotes\",\n\t\t\tdst:      []byte{},\n\t\t\ts:        `{\"foo\":\"bar\"}`,\n\t\t\texpected: []byte(`\"{\\\"foo\\\":\\\"bar\\\"}\"`),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tactual := escapeString(tt.dst, tt.s)\n\t\t\tif string(actual) != string(tt.expected) {\n\t\t\t\tt.Errorf(\"escapeString() = %v, want %v\", string(actual), string(tt.expected))\n\t\t\t}\n\t\t})\n\t}\n}\n","cb85710523cfb04cdcdf04451f7449d2":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  string\n\t\twant1 string\n\t\terr   error\n\t}{\n\t\t// Test cases here\n\t\t{\n\t\t\tinput: `\"foo\"bar`,\n\t\t\twant:  \"foo\",\n\t\t\twant1: \"bar\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `\"fo\\o\"bar`,\n\t\t\twant:  `fo\\o`,\n\t\t\twant1: \"bar\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `\"foo\\\"bar\"baz`,\n\t\t\twant:  `foo\"bar`,\n\t\t\twant1: \"baz\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `\"foo\", \"bar\"`,\n\t\t\twant:  \"foo\",\n\t\t\twant1: `, \"bar\"`,\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `\"\\\"\"bar`,\n\t\t\twant:  `\"`,\n\t\t\twant1: \"bar\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `\"foo`,\n\t\t\twant:  \"\",\n\t\t\twant1: \"\",\n\t\t\terr:   fmt.Errorf(`missing closing '\"'`),\n\t\t},\n\t\t{\n\t\t\tinput: `foo\"`,\n\t\t\twant:  \"foo\",\n\t\t\twant1: \"\",\n\t\t\terr:   fmt.Errorf(`missing closing '\"'`),\n\t\t},\n\t}\n\tfor i, tt := range tests {\n\t\tgot, got1, err := parseRawString(tt.input)\n\t\tif got != tt.want || got1 != tt.want1 || (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) {\n\t\t\tt.Errorf(\"%d. parseRawString(%q) = %q, %q, %v, want %q, %q, %v\", i, tt.input, got, got1, err, tt.want, tt.want1, tt.err)\n\t\t}\n\t}\n}","cb8b337a5da945f53db16b6db1e7cef5":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  string\n\t\terr   error\n\t}{\n\t\t// Basic cases.\n\t\t{`\"key\"`, `key`, nil},\n\t\t{`\"key with space\"`, `key with space`, nil},\n\t\t{`\"key with \\t tab\"`, `key with \\t tab`, nil},\n\t\t{`\"key with escaped \\\\ backslash\"`, `key with escaped \\\\ backslash`, nil},\n\t\t{`\"key with escaped \\\" quote\"`, `key with escaped \\\" quote`, nil},\n\n\t\t// Empty key.\n\t\t{`\"\"`, ``, nil},\n\n\t\t// Invalid cases.\n\t\t{`\"key without closing quote`, ``, fmt.Errorf(`missing closing '\"'`)},\n\t\t{`key without quotes`, ``, fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"key with unescaped \\ quote\"`, ``, fmt.Errorf(`missing closing '\"'`)},\n\n\t\t// Escaped characters.\n\t\t{`\"\\u0020\"`, \" \", nil},\n\n\t\t// Slow path cases.\n\t\t{`\"key with \\\\x escaping\"`, \"\", fmt.Errorf(`missing closing '\"'`)},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test %d\", i), func(t *testing.T) {\n\t\t\tgot, _, err := parseRawKey(tt.input)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawKey(%q) got %q, want %q\", tt.input, got, tt.want)\n\t\t\t}\n\t\t\tif (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err == nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"parseRawKey(%q) got error %v, want %v\", tt.input, err, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}","cbef8bb22fee92b10afa87f54f0a53b0":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Empty input.\n\t\t{\"\", nil, \"\", fmt.Errorf(\"cannot parse empty string\")},\n\n\t\t// Invalid JSON.\n\t\t{\"{invalid}\", nil, \"\", fmt.Errorf(\"cannot parse object: invalid character 'i' looking for beginning of object key string\")},\n\n\t\t// Object.\n\t\t{`{\"foo\": \"bar\"}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: typeRawString, s: \"bar\"}}}}}, \"\", nil},\n\n\t\t// Array.\n\t\t{`[1, \"foo\", true]`, \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: typeRawString, s: \"foo\"}, {t: TypeTrue}}}, \"\", nil},\n\n\t\t// String.\n\t\t{`\"foo\"`, \u0026Value{t: typeRawString, s: \"foo\"}, \"\", nil},\n\n\t\t// True.\n\t\t{\"true\", valueTrue, \"\", nil},\n\n\t\t// False.\n\t\t{\"false\", valueFalse, \"\", nil},\n\n\t\t// Null.\n\t\t{\"null\", valueNull, \"\", nil},\n\n\t\t// Number.\n\t\t{\"123\", \u0026Value{t: TypeNumber, s: \"123\"}, \"\", nil},\n\t\t{\"-123.456\", \u0026Value{t: TypeNumber, s: \"-123.456\"}, \"\", nil},\n\n\t\t// Trailing whitespace.\n\t\t{`\"foo\" `, \u0026Value{t: typeRawString, s: \"foo\"}, \" \", nil},\n\n\t\t// Nested values.\n\t\t{`{\"foo\": [1, 2, {\"bar\": \"baz\"}]}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeObject, o: Object{kvs: []kv{{k: \"bar\", v: \u0026Value{t: typeRawString, s: \"baz\"}}}}}}}}}}}, \"\", nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, tail, err := parseValue(tt.input, c, 0)\n\n\t\t\tif got != nil \u0026\u0026 tt.want != nil \u0026\u0026 got.t != tt.want.t {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", tt.input, got, tt.want)\n\t\t\t}\n\t\t\tif tt.err != nil \u0026\u0026 err == nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = nil, want %v\", tt.input, tt.err)\n\t\t\t} else if tt.err == nil \u0026\u0026 err != nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, want nil\", tt.input, err)\n\t\t\t} else if tt.err != nil \u0026\u0026 err != nil \u0026\u0026 tt.err.Error() != err.Error() {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, want %v\", tt.input, err, tt.err)\n\t\t\t} else if tail != tt.tail {\n\t\t\t\tt.Errorf(\"parseValue(%q) tail = %q, want %q\", tt.input, tail, tt.tail)\n\t\t\t}\n\t\t})\n\t}\n}\n","cc2ca3ffb95a189c0927b89f2ea28794":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey   string\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Basic cases\n\t\t{`\"foo\"bar`, \"foo\", \"bar\", nil},\n\t\t{`\"fo\\\"o\"bar`, `fo\"o`, \"bar\", nil},\n\t\t{`\"foo\" bar`, \"foo\", \" bar\", nil},\n\n\t\t// Escaped quotes\n\t\t{`\"fo\\\\o\"bar`, `fo\\o`, \"bar\", nil},\n\t\t{`\"fo\\\\\\\\o\"bar`, `fo\\\\o`, \"bar\", nil},\n\t\t{`\"fo\\\\\\\"o\"bar`, `fo\\\"o`, \"bar\", nil},\n\n\t\t// Empty strings\n\t\t{`\"\"bar`, \"\", \"bar\", nil},\n\t\t{`\"foo\"\"\"bar`, \"foo\", `\"bar`, nil},\n\n\t\t// Error cases\n\t\t{`\"foo`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"fo\"o\"bar`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo\\nbar`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tkey, tail, err := parseRawString(tt.input)\n\t\t\tif key != tt.key || tail != tt.tail || !errorEqual(err, tt.err) {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = (%q, %q, %v), want (%q, %q, %v)\", tt.input, key, tail, err, tt.key, tt.tail, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc errorEqual(e1, e2 error) bool {\n\tif e1 == nil \u0026\u0026 e2 == nil {\n\t\treturn true\n\t}\n\tif e1 == nil || e2 == nil {\n\t\treturn false\n\t}\n\treturn e1.Error() == e2.Error()\n}","cc89c1bed9800d39da5e4dc1a0fd47ba":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantN    string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t{\n\t\t\tinput:    \"123\",\n\t\t\twantN:    \"123\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"123.456\",\n\t\t\twantN:    \"123.456\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"-123\",\n\t\t\twantN:    \"-123\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"123a\",\n\t\t\twantN:    \"123\",\n\t\t\twantTail: \"a\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"123.456a\",\n\t\t\twantN:    \"123.456\",\n\t\t\twantTail: \"a\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"123e+10\",\n\t\t\twantN:    \"123e+10\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"123E-10\",\n\t\t\twantN:    \"123E-10\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"+123\",\n\t\t\twantN:    \"+123\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"inf\",\n\t\t\twantN:    \"inf\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"InF\",\n\t\t\twantN:    \"InF\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"123inf\",\n\t\t\twantN:    \"123\",\n\t\t\twantTail: \"inf\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"nan\",\n\t\t\twantN:    \"nan\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"NaN\",\n\t\t\twantN:    \"NaN\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"123nan\",\n\t\t\twantN:    \"123\",\n\t\t\twantTail: \"nan\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"x\",\n\t\t\twantN:    \"\",\n\t\t\twantTail: \"x\",\n\t\t\twantErr:  fmt.Errorf(\"unexpected char: %q\", \"x\"),\n\t\t},\n\t\t{\n\t\t\tinput:    \"-x\",\n\t\t\twantN:    \"\",\n\t\t\twantTail: \"-x\",\n\t\t\twantErr:  fmt.Errorf(\"unexpected char: %q\", \"-\"),\n\t\t},\n\t\t{\n\t\t\tinput:    \"+x\",\n\t\t\twantN:    \"\",\n\t\t\twantTail: \"+x\",\n\t\t\twantErr:  fmt.Errorf(\"unexpected char: %q\", \"+\"),\n\t\t},\n\t}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tgotN, gotTail, gotErr := parseRawNumber(tt.input)\n\t\t\tif gotN != tt.wantN {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) gotN = %q, want %q\", tt.input, gotN, tt.wantN)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) gotTail = %q, want %q\", tt.input, gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif gotErr == nil \u0026\u0026 tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) gotErr = nil, want %v\", tt.input, tt.wantErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr == nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) gotErr = %v, want nil\", tt.input, gotErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) gotErr = %v, want %v\", tt.input, gotErr, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","cd096a26bec96244813fa324ca0118d3":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Empty string\n\t\t{\"\", nil, \"\", fmt.Errorf(\"cannot parse empty string\")},\n\n\t\t// Object\n\t\t{`{\"foo\":\"bar\"}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: typeRawString, s: \"bar\"}}}}}, \"\", nil},\n\n\t\t// Array\n\t\t{`[1,2,3]`, \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}}, \"\", nil},\n\n\t\t// String\n\t\t{`\"hello, world\"`, \u0026Value{t: typeRawString, s: \"hello, world\"}, \"\", nil},\n\n\t\t// True\n\t\t{\"true\", valueTrue, \"\", nil},\n\n\t\t// False\n\t\t{\"false\", valueFalse, \"\", nil},\n\n\t\t// Null\n\t\t{\"null\", valueNull, \"\", nil},\n\n\t\t// Number\n\t\t{\"12345\", \u0026Value{t: TypeNumber, s: \"12345\"}, \"\", nil},\n\n\t\t// NaN\n\t\t{\"NaN\", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"\", nil},\n\n\t\t// Invalid value\n\t\t{\"invalid\", nil, \"invalid\", fmt.Errorf(\"unexpected value found: \\\"invalid\\\"\")},\n\n\t\t// Too deep nesting\n\t\t{`{\"a\":` + `{\"a\":` + `{\"a\":` + `{\"a\":` + `{\"a\":` + `{\"a\":` + `{\"a\":` + `{\"a\":` + `{\"a\":` + `{\"a\":` + `{\"a\":` + `{\"a\":` + `{\"a\":` + `{\"a\":` + `{\"a\":` + `{\"a\":` + `{\"a\":` + `{\"a\":` + `{\"a\":` + `{\"a\":` + `{\"a\":` + `{\"a\":` + `{\"a\":` + `{\"a\":` + `{\"a\":\"foo\"}}` + `}` + `}` + `}` + `}` + `}` + `}` + `}` + `}` + `}` + `}` + `}` + `}` + `}` + `}` + `}` + `}` + `}` + `}` + `}` + `}` + `}` + `}` + `}` + `}`, nil, `{\"a\":\"foo\"}}` + `}` + `}` + `}` + `}` + `}` + `}` + `}` + `}` + `}` + `}` + `}` + `}` + `}` + `}` + `}` + `}` + `}` + `}` + `}` + `}` + `}` + `}` + `}` + `}`, fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth)},\n\t}\n\n\tc := \u0026cache{}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tgot, tail, err := parseValue(tt.input, c, 0)\n\t\t\tif fmt.Sprintf(\"%v\", err) != fmt.Sprintf(\"%v\", tt.err) {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, wantErr %v\", tt.input, err, tt.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != nil \u0026\u0026 tt.want != nil \u0026\u0026 got.t != tt.want.t {\n\t\t\t\tt.Errorf(\"parseValue(%q) type = %v, want %v\", tt.input, got.t, tt.want.t)\n\t\t\t}\n\t\t\tif got != nil \u0026\u0026 tt.want != nil \u0026\u0026 got.s != tt.want.s {\n\t\t\t\tt.Errorf(\"parseValue(%q) value = %v, want %v\", tt.input, got.s, tt.want.s)\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"parseValue(%q) tail = %q, want %q\", tt.input, tail, tt.tail)\n\t\t\t}\n\t\t})\n\t}\n}\n","cd09872ff98ed51df9fc60253203ac1c":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  string\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t{\"\", \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo`, `\"foo`, \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo\"`, \"foo\", \"\", nil},\n\t\t{`\"foo\"bar`, \"foo\", \"bar\", nil},\n\t\t{`\"fo\\o\"bar`, \"fo\\\\o\", \"bar\", nil},\n\t\t{`\"fo\\\"o\"bar`, `fo\"o`, \"bar\", nil},\n\t\t{`\"fo\\\\\\\"o\"bar`, `fo\\\"o`, \"bar\", nil},\n\t\t{`\"fo\\ooo\"bar`, `fo\\ooo`, \"bar\", nil},\n\t}\n\tfor i, tt := range tests {\n\t\tgot, tail, err := parseRawString(tt.input)\n\t\tif got != tt.want || tail != tt.tail || fmt.Sprintf(\"%v\", err) != fmt.Sprintf(\"%v\", tt.err) {\n\t\t\tt.Errorf(\"%d. parseRawString(%q) = %q, %q, %v; want %q, %q, %v\", i, tt.input, got, tail, err, tt.want, tt.tail, tt.err)\n\t\t}\n\t}\n}\n","cd6cb6e8218d1f8c8539694471a3eebe":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\tvar tests = []struct {\n\t\tin  string\n\t\tout string\n\t}{\n\t\t{`\"foo\"`, `foo`},\n\t\t{`\"fo\\no\"`, `fo\\no`},\n\t\t{`\"fo\\\\o\"`, `fo\\o`},\n\t\t{`\"fo\\ro\"`, \"fo\\ro\"},\n\t\t{`\"fo\\to\"`, \"fo\\to\"},\n\t\t{`\"fo\\u1234o\"`, \"fo\\u1234o\"},\n\t\t{`\"\\u1234foo\"`, \"\\u1234foo\"},\n\t\t{`\"foo\\u1234\"`, \"foo\\u1234\"},\n\t\t{`\"\\uda02\\udc02foo\"`, \"\\uda02\\udc02foo\"},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.in, func(t *testing.T) {\n\t\t\tout := unescapeStringBestEffort(tt.in)\n\t\t\tif out != tt.out {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", tt.in, out, tt.out)\n\t\t\t}\n\t\t})\n\t}\n}\n","ce19768ad4ca3977d0976120357c68d6":"package fastjson\n\nimport \"testing\"\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    string\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty\",\n\t\t\ts:    \"\",\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"allWhitespace\",\n\t\t\ts:    \" \\t\\r\\n\",\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"leadingWhitespace\",\n\t\t\ts:    \" \\t\\r\\nfoo\",\n\t\t\twant: \"foo\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailingWhitespace\",\n\t\t\ts:    \"foo \\t\\r\\n\",\n\t\t\twant: \"foo \\t\\r\\n\",\n\t\t},\n\t\t{\n\t\t\tname: \"internalWhitespace\",\n\t\t\ts:    \"foo \\t\\r\\nbar\",\n\t\t\twant: \"foo \\t\\r\\nbar\",\n\t\t},\n\t\t{\n\t\t\tname: \"noWhitespace\",\n\t\t\ts:    \"foobar\",\n\t\t\twant: \"foobar\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %q, want %q\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","ce393aeae9568082d69d7a6c00ded17e":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Empty string.\n\t\t{\n\t\t\tinput: \"\",\n\t\t\twant:  nil,\n\t\t\ttail:  \"\",\n\t\t\terr:   fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t// Null.\n\t\t{\n\t\t\tinput: \"null\",\n\t\t\twant:  valueNull,\n\t\t\ttail:  \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: \"nullx\",\n\t\t\twant:  valueNull,\n\t\t\ttail:  \"x\",\n\t\t\terr:   nil,\n\t\t},\n\t\t// True.\n\t\t{\n\t\t\tinput: \"true\",\n\t\t\twant:  valueTrue,\n\t\t\ttail:  \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: \"truex\",\n\t\t\twant:  valueTrue,\n\t\t\ttail:  \"x\",\n\t\t\terr:   nil,\n\t\t},\n\t\t// False.\n\t\t{\n\t\t\tinput: \"false\",\n\t\t\twant:  valueFalse,\n\t\t\ttail:  \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: \"falsex\",\n\t\t\twant:  valueFalse,\n\t\t\ttail:  \"x\",\n\t\t\terr:   nil,\n\t\t},\n\t\t// Number.\n\t\t{\n\t\t\tinput: \"123\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\ttail: \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: \"123x\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\ttail: \"x\",\n\t\t\terr:   nil,\n\t\t},\n\t\t// String.\n\t\t{\n\t\t\tinput: `\"foobar\"`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"foobar\",\n\t\t\t},\n\t\t\ttail: \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `\"foobar\"x`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"foobar\",\n\t\t\t},\n\t\t\ttail: \"x\",\n\t\t\terr:   nil,\n\t\t},\n\t\t// Object.\n\t\t{\n\t\t\tinput: `{\"foo\":\"bar\"}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"foo\", v: \u0026Value{t: typeRawString, s: \"bar\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttail: \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t// Array.\n\t\t{\n\t\t\tinput: `[123,\"foobar\"]`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"123\"},\n\t\t\t\t\t{t: typeRawString, s: \"foobar\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttail: \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t// NaN.\n\t\t{\n\t\t\tinput: \"NaN\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\ttail: \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: \"NaNx\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\ttail: \"x\",\n\t\t\terr:   nil,\n\t\t},\n\t}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test %d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, tail, err := parseValue(tt.input, c, 0)\n\t\t\tif fmt.Sprintf(\"%v\", err) != fmt.Sprintf(\"%v\", tt.err) {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got == nil \u0026\u0026 tt.want == nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (got == nil \u0026\u0026 tt.want != nil) || (got != nil \u0026\u0026 tt.want == nil) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got.t != tt.want.t {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got.s != tt.want.s {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"parseValue() tail = %v, want %v\", tail, tt.tail)\n\t\t\t\treturn\n\t\t\t}\n\t\t})\n\t}\n}\n","cee6ab93546cb62c80fb31265cc0b0c3":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantNum  string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Valid numbers\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"123.456\", \"123.456\", \"\", nil},\n\t\t{\"1.23e4\", \"1.23e4\", \"\", nil},\n\t\t{\"-1.23e-4\", \"-1.23e-4\", \"\", nil},\n\t\t{\"+123\", \"+123\", \"\", nil},\n\t\t{\"123abc\", \"123\", \"abc\", nil},\n\t\t{\"123.456xyz\", \"123.456\", \"xyz\", nil},\n\t\t{\"-Inf\", \"-Inf\", \"\", nil},\n\t\t{\"+inf\", \"+inf\", \"\", nil},\n\t\t{\"InFiNiTy\", \"InFiNiTy\", \"\", nil},\n\t\t{\"-infinity\", \"-infinity\", \"\", nil},\n\t\t{\"NaN\", \"NaN\", \"\", nil},\n\t\t{\"nan123\", \"nan\", \"123\", nil},\n\n\t\t// Invalid numbers\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t\t{\"+\", \"\", \"+\", fmt.Errorf(\"unexpected char: %q\", \"+\")},\n\t\t{\"-\", \"\", \"-\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t\t{\"a123\", \"\", \"a123\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\"123a\", \"123\", \"a\", nil},\n\t\t{\"inf\", \"\", \"inf\", fmt.Errorf(\"unexpected char: %q\", \"i\")},\n\t\t{\"-in\", \"\", \"-in\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t\t(\"+na\", \"\", \"+na\", fmt.Errorf(\"unexpected char: %q\", \"+\")},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d:%s\", i, tt.input), func(t *testing.T) {\n\t\t\tgotNum, gotTail, gotErr := parseRawNumber(tt.input)\n\n\t\t\tif gotNum != tt.wantNum {\n\t\t\t\tt.Errorf(\"Num mismatch. Want: %s, Got: %s\", tt.wantNum, gotNum)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"Tail mismatch. Want: %s, Got: %s\", tt.wantTail, gotTail)\n\t\t\t}\n\t\t\tif gotErr == nil \u0026\u0026 tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"Expected error but got nil\")\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr == nil {\n\t\t\t\tt.Errorf(\"Got unexpected error: %v\", gotErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"Error mismatch. Want: %v, Got: %v\", tt.wantErr, gotErr)\n\t\t\t}\n\t\t})\n\t}\n}\n","cf569eccca807a583e3e1abb4542ed42":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey string\n\t\tvalue string\n\t\terr error\n\t}{\n\t\t// Basic cases\n\t\t{`\"foo\"bar`, \"foo\", \"bar\", nil},\n\t\t{`\"fo\\\"o\"bar`, `fo\"o`, \"bar\", nil},\n\t\t{`\"foo\"`, \"foo\", \"\", nil},\n\t\t{`\"\"bar`, \"\", \"bar\", nil},\n\n\t\t// Escaped quotes\n\t\t{`\"fo\\\\o\"bar`, `fo\\o`, \"bar\", nil},\n\t\t{`\"fo\\\\\\\\o\"bar`, `fo\\\\o`, \"bar\", nil},\n\t\t{`\"fo\\\"o\"bar`, `fo\"o`, \"bar\", nil},\n\t\t{`\"fo\\\\\\\"o\"bar`, `fo\\\"o`, \"bar\", nil},\n\t\t{`\"fo\\\\\\\"\"bar`, `fo\\\"`, \"bar\", nil},\n\n\t\t// Errors\n\t\t{`\"foo`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"fo\\\\\"o\"bar`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d:%s\", i, tt.input), func(t *testing.T) {\n\t\t\tkey, value, err := parseRawString(tt.input)\n\t\t\tif fmt.Sprintf(\"%v\", err) != fmt.Sprintf(\"%v\", tt.err) {\n\t\t\t\tt.Errorf(\"expected error: %v, got: %v\", tt.err, err)\n\t\t\t}\n\t\t\tif key != tt.key {\n\t\t\t\tt.Errorf(\"expected key: '%s', got: '%s'\", tt.key, key)\n\t\t\t}\n\t\t\tif value != tt.value {\n\t\t\t\tt.Errorf(\"expected value: '%s', got: '%s'\", tt.value, value)\n\t\t\t}\n\t\t})\n\t}\n}","cfc916037e0bc9ef8c3ad68cd5ccc315":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Get(t *testing.T) {\n\tt.Run(\"object\", func(t *testing.T) {\n\t\tv := MustParse(`{\"foo\": {\"bar\": \"baz\"}}`)\n\t\tassert(t, v.Get(\"foo\", \"bar\").String() == \"baz\", \"unexpected value %q\", v.Get(\"foo\", \"bar\"))\n\t\tassert(t, v.Get(\"foo\").Get(\"bar\").String() == \"baz\", \"unexpected value %q\", v.Get(\"foo\", \"bar\"))\n\n\t\tassert(t, v.Get(\"foo2\") == nil, \"expected nil value, got %v\", v.Get(\"foo2\"))\n\t\tassert(t, v.Get(\"foo\", \"bar2\") == nil, \"expected nil value, got %v\", v.Get(\"foo2\"))\n\t})\n\n\tt.Run(\"array\", func(t *testing.T) {\n\t\tv := MustParse(`{\"foo\": [{\"bar\": \"baz\"}]}`)\n\t\tassert(t, v.Get(\"foo\", \"0\", \"bar\").String() == \"baz\", \"unexpected value %q\", v.Get(\"foo\", \"0\", \"bar\"))\n\t\tassert(t, v.Get(\"foo\").Get(\"0\", \"bar\").String() == \"baz\", \"unexpected value %q\", v.Get(\"foo\", \"0\", \"bar\"))\n\n\t\tassert(t, v.Get(\"foo\", \"1\") == nil, \"expected nil value, got %v\", v.Get(\"foo\", \"1\"))\n\t\tassert(t, v.Get(\"foo\", \"0\", \"bar2\") == nil, \"expected nil value, got %v\", v.Get(\"foo\", \"0\", \"bar2\"))\n\t})\n\n\tt.Run(\"nil\", func(t *testing.T) {\n\t\tvar v *Value\n\t\tassert(t, v.Get(\"foo\", \"bar\") == nil, \"expected nil value, got %v\", v.Get(\"foo\", \"bar\"))\n\t})\n}","d022cd027712a505cb7c482afa838bb6":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Test cases here\n\t\t{\n\t\t\tinput: `{}`,\n\t\t\twant:  \u0026Value{t: TypeObject},\n\t\t\ttail:  \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `[]`,\n\t\t\twant:  \u0026Value{t: TypeArray},\n\t\t\ttail:  \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `\"test\"`,\n\t\t\twant:  \u0026Value{t: typeRawString, s: \"test\"},\n\t\t\ttail:  \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `true`,\n\t\t\twant:  valueTrue,\n\t\t\ttail:  \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `false`,\n\t\t\twant:  valueFalse,\n\t\t\ttail:  \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `null`,\n\t\t\twant:  valueNull,\n\t\t\ttail:  \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `123`,\n\t\t\twant:  \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\ttail:  \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `-123`,\n\t\t\twant:  \u0026Value{t: TypeNumber, s: \"-123\"},\n\t\t\ttail:  \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `1.23`,\n\t\t\twant:  \u0026Value{t: TypeNumber, s: \"1.23\"},\n\t\t\ttail:  \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `-1.23`,\n\t\t\twant:  \u0026Value{t: TypeNumber, s: \"-1.23\"},\n\t\t\ttail:  \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `NaN`,\n\t\t\twant:  \u0026Value{t: TypeNumber, s: \"NaN\"},\n\t\t\ttail:  \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `{\"key\": \"value\"}`,\n\t\t\twant: \u0026Value{t: TypeObject, o: Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"key\", v: \u0026Value{t: typeRawString, s: \"value\"}},\n\t\t\t\t},\n\t\t\t}},\n\t\t\ttail: \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t// Error cases\n\t\t{\n\t\t\tinput: ``,\n\t\t\twant:  nil,\n\t\t\ttail:  \"\",\n\t\t\terr:   fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tinput: `{`,\n\t\t\twant:  nil,\n\t\t\ttail:  \"{\",\n\t\t\terr:   fmt.Errorf(\"cannot parse object: unexpected end of JSON\"),\n\t\t},\n\t\t{\n\t\t\tinput: `[`,\n\t\t\twant:  nil,\n\t\t\ttail:  \"[\",\n\t\t\terr:   fmt.Errorf(\"cannot parse array: unexpected end of JSON\"),\n\t\t},\n\t\t{\n\t\t\tinput: `\"test`,\n\t\t\twant:  nil,\n\t\t\ttail:  `\"test`,\n\t\t\terr:   fmt.Errorf(\"cannot parse string: unexpected end of JSON\"),\n\t\t},\n\t\t{\n\t\t\tinput: `tru`,\n\t\t\twant:  nil,\n\t\t\ttail:  `tru`,\n\t\t\terr:   fmt.Errorf(\"unexpected value found: %q\", \"tru\"),\n\t\t},\n\t\t{\n\t\t\tinput: `fals`,\n\t\t\twant:  nil,\n\t\t\ttail:  `fals`,\n\t\t\terr:   fmt.Errorf(\"unexpected value found: %q\", \"fals\"),\n\t\t},\n\t\t{\n\t\t\tinput: `nul`,\n\t\t\twant:  nil,\n\t\t\ttail:  `nul`,\n\t\t\terr:   fmt.Errorf(\"unexpected value found: %q\", \"nul\"),\n\t\t},\n\t\t{\n\t\t\tinput: `123a`,\n\t\t\twant:  nil,\n\t\t\ttail:  `a`,\n\t\t\terr:   fmt.Errorf(\"cannot parse number: unexpected char 'a'\"),\n\t\t},\n\t\t{\n\t\t\tinput: `-`,\n\t\t\twant:  nil,\n\t\t\ttail:  `-`,\n\t\t\terr:   fmt.Errorf(\"cannot parse number: unexpected end of JSON\"),\n\t\t},\n\t}\n\n\tc := \u0026cache{}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i+1), func(t *testing.T) {\n\t\t\tgot, tail, err := parseValue(tt.input, c, 0)\n\t\t\tif fmt.Sprintf(\"%v\", err) != fmt.Sprintf(\"%v\", tt.err) {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, wantErr %v\", tt.input, err, tt.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"parseValue(%q) tail = %q, wantTail %q\", tt.input, tail, tt.tail)\n\t\t\t}\n\t\t\tif got == nil \u0026\u0026 tt.want == nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got == nil \u0026\u0026 tt.want != nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) got nil, want not nil\", tt.input)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != nil \u0026\u0026 tt.want == nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) got not nil, want nil\", tt.input)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got.t != tt.want.t {\n\t\t\t\tt.Errorf(\"parseValue(%q) type = %v, wantType %v\", tt.input, got.t, tt.want.t)\n\t\t\t}\n\t\t\tif got.s != tt.want.s {\n\t\t\t\tt.Errorf(\"parseValue(%q) string = %q, wantString %q\", tt.input, got.s, tt.want.s)\n\t\t\t}\n\t\t\tif got.t == TypeObject {\n\t\t\t\tif len(got.o.kvs) != len(tt.want.o.kvs) {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) object len = %d, wantLen %d\", tt.input, len(got.o.kvs), len(tt.want.o.kvs))\n\t\t\t\t} else {\n\t\t\t\t\tfor j := range got.o.kvs {\n\t\t\t\t\t\tif got.o.kvs[j].k != tt.want.o.kvs[j].k {\n\t\t\t\t\t\t\tt.Errorf(\"parseValue(%q) object key = %q, wantKey %q\", tt.input, got.o.kvs[j].k, tt.want.o.kvs[j].k)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif got.o.kvs[j].v.t != tt.want.o.kvs[j].v.t {\n\t\t\t\t\t\t\tt.Errorf(\"parseValue(%q) object value type = %v, wantType %v\", tt.input, got.o.kvs[j].v.t, tt.want.o.kvs[j].v.t)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif got.o.kvs[j].v.s != tt.want.o.kvs[j].v.s {\n\t\t\t\t\t\t\tt.Errorf(\"parseValue(%q) object value string = %q, wantString %q\", tt.input, got.o.kvs[j].v.s, tt.want.o.kvs[j].v.s)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","d08a0b4bda078a33a560fef033579209":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc Test_unescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello world\",\n\t\t\t},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"simple escape\",\n\t\t\targs: args{\n\t\t\t\ts: `hello \\\"world\\\"`,\n\t\t\t},\n\t\t\twant: `hello \"world\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"unicode escape\",\n\t\t\targs: args{\n\t\t\t\ts: `\\u0048\\u0065\\u006c\\u006c\\u006f`,\n\t\t\t},\n\t\t\twant: \"Hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid unicode escape\",\n\t\t\targs: args{\n\t\t\t\ts: `\\u004\\u0065\\u006c\\u006c\\u006f`,\n\t\t\t},\n\t\t\twant: `\\u004\\u0065\\u006c\\u006c\\u006f`,\n\t\t},\n\t\t{\n\t\t\tname: \"mixed escape\",\n\t\t\targs: args{\n\t\t\t\ts: `hello \\u002c \\\"world\\\" \\t \\n`,\n\t\t\t},\n\t\t\twant: \"hello , \\\"world\\\" \\t \\n\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","d17936696f61395fe3f9b52667ef3ece":"package fastjson\n\nimport \"testing\"\n\nfunc Test_skipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    string\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\ts:    \"\",\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with no whitespace\",\n\t\t\ts:    \"hello\",\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with leading whitespace\",\n\t\t\ts:    \"  hello\",\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with trailing whitespace\",\n\t\t\ts:    \"hello  \",\n\t\t\twant: \"hello  \",\n\t\t},\n\t\t{\n\t\t\tname: \"string with leading and trailing whitespace\",\n\t\t\ts:    \"  hello  \",\n\t\t\twant: \"hello  \",\n\t\t},\n\t\t{\n\t\t\tname: \"string with only whitespace\",\n\t\t\ts:    \" \\t\\n\\r\",\n\t\t\twant: \"\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","d19552cb4a85b8bdc7ee59d416f1defb":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"raw string\",\n\t\t\t},\n\t\t\twant: []byte(`\"raw string\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello world\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello world\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"12345\",\n\t\t\t},\n\t\t\twant: []byte(`12345`),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(`true`),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(`false`),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(`null`),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"hello\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`[\"hello\",123]`),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"message\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"hello world\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"code\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"200\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`{\"message\":\"hello world\",\"code\":\"200\"}`),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif string(got) != string(tt.want) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %v, want %v\", string(got), string(tt.want))\n\t\t\t}\n\t\t})\n\t}\n}","d1c42aa0ff9a668dfcf23c9f797c946e":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantJSON string\n\t\twantErr  error\n\t}{\n\t\t{\n\t\t\tname:     \"empty object\",\n\t\t\tinput:    \"{}\",\n\t\t\twantJSON: `{}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"simple object\",\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantJSON: `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"nested object\",\n\t\t\tinput:    `{\"key1\": {\"key2\": \"value2\"}, \"key3\": \"value3\"}`,\n\t\t\twantJSON: `{\"key1\": {\"key2\": \"value2\"}, \"key3\": \"value3\"}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"object with array\",\n\t\t\tinput:    `{\"key1\": [\"value1\", \"value2\"], \"key2\": \"value3\"}`,\n\t\t\twantJSON: `{\"key1\": [\"value1\", \"value2\"], \"key2\": \"value3\"}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"object with different value types\",\n\t\t\tinput:    `{\"key1\": true, \"key2\": 123, \"key3\": \"value3\"}`,\n\t\t\twantJSON: `{\"key1\": true, \"key2\": 123, \"key3\": \"value3\"}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"object with escaped characters\",\n\t\t\tinput:    `{\"key1\": \"value with \\n newline and \\t tab\"}`,\n\t\t\twantJSON: `{\"key1\": \"value with \\n newline and \\t tab\"}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid object: missing closing brace\",\n\t\t\tinput:    `{\"key1\": \"value1\"`,\n\t\t\twantErr:  fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid object: missing colon\",\n\t\t\tinput:    `{\"key1\" \"value1\"}`,\n\t\t\twantErr:  fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid object: missing comma\",\n\t\t\tinput:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr:  fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, _, err := parseObject(tt.input, c, 0)\n\n\t\t\tif tt.wantErr != nil {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"parseObject() error = nil, wantErr %v\", tt.wantErr)\n\t\t\t\t} else if err.Error() != tt.wantErr.Error() {\n\t\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr nil\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tgotJSON := got.String()\n\t\t\tif gotJSON != tt.wantJSON {\n\t\t\t\tt.Errorf(\"parseObject() got = %s, want %s\", gotJSON, tt.wantJSON)\n\t\t\t}\n\t\t})\n\t}\n}","d2756c18d2278ae148d9b3426eb9553b":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tinput    string\n\t\twant    *Value\n\t\twantErr error\n\t\tremain string\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: \"{}\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{},\n\t\t\t},\n\t\t\twantErr: nil,\n\t\t\tremain: \"\",\n\t\t},\n\t\t{\n\t\t\tname:  \"single key-value pair\",\n\t\t\tinput: `{\"key\": \"value\"}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: \u0026Value{t: TypeString, s: \"value\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: nil,\n\t\t\tremain: \"\",\n\t\t},\n\t\t{\n\t\t\tname:  \"multiple key-value pairs\",\n\t\t\tinput: `{\"key1\": \"value1\", \"key2\": 123, \"key3\": true}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t\t{k: \"key3\", v: \u0026Value{t: TypeTrue}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: nil,\n\t\t\tremain: \"\",\n\t\t},\n\t\t{\n\t\t\tname:  \"nested objects\",\n\t\t\tinput: `{\"key1\": {\"key2\": \"value2\"}, \"key3\": \"value3\"}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{k: \"key3\", v: \u0026Value{t: TypeString, s: \"value3\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: nil,\n\t\t\tremain: \"\",\n\t\t},\n\t\t{\n\t\t\tname:  \"missing closing brace\",\n\t\t\tinput: `{\"key\": \"value\"`,\n\t\t\twant:    nil,\n\t\t\twantErr: fmt.Errorf(\"unexpected end of object\"),\n\t\t\tremain:  `{\"key\": \"value\"`,\n\t\t},\n\t\t{\n\t\t\tname:  \"missing colon after key\",\n\t\t\tinput: `{\"key\" \"value\"}`,\n\t\t\twant:    nil,\n\t\t\twantErr: fmt.Errorf(\"missing ':' after object key\"),\n\t\t\tremain:  `\"value\"}`,\n\t\t},\n\t\t{\n\t\t\tname:  \"missing comma between key-value pairs\",\n\t\t\tinput: `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twant:    nil,\n\t\t\twantErr: fmt.Errorf(\"missing ',' after object value\"),\n\t\t\tremain:  `\"key2\": \"value2\"}`,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid json\",\n\t\t\tinput:    `{key: \"value\"}`,\n\t\t\twant:    nil,\n\t\t\twantErr: fmt.Errorf(`cannot find opening '\"\" for object key`),\n\t\t\tremain:  `{key: \"value\"}`,\n\t\t},\n\t\t{\n\t\t\tname:  \"input with remain data\",\n\t\t\tinput: `{\"key\": \"value\"} remaining`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: \u0026Value{t: TypeString, s: \"value\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: nil,\n\t\t\tremain: \" remaining\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, remain, err := parseObject(tt.input, c, 0)\n\t\t\tif fmt.Sprintf(\"%v\", err) != fmt.Sprintf(\"%v\", tt.wantErr) {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != nil \u0026\u0026 tt.want != nil \u0026\u0026 got.Type() != tt.want.Type() {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got != nil \u0026\u0026 tt.want != nil \u0026\u0026 len(got.o.kvs) != len(tt.want.o.kvs) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif tt.remain != remain {\n\t\t\t\tt.Errorf(\"parseObject() remain = %v, want %v\", remain, tt.remain)\n\t\t\t}\n\t\t})\n\t}\n}","d37f73f2514549345a227ae9b96d41ee":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey   string\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Valid keys\n\t\t{`\"key\":1`, \"key\", `:1`, nil},\n\t\t{`\"key\":\"value\"`, \"key\", `:\"value\"`, nil},\n\t\t{`\"key with spaces\": 123`, \"key with spaces\", `: 123`, nil},\n\n\t\t// Invalid keys\n\t\t{`\"key`, \"\", \"\", fmt.Errorf(`missing closing '\"')},\n\t\t{`\"key\"trailing`, \"key\", `trailing`, nil}, // This is valid JSON, but the trailing part is unexpected\n\t\t{`key\":\"value\"`, \"\", \"\", fmt.Errorf(`missing closing '\"')},\n\n\t\t// Keys with escape sequences should call parseRawString\n\t\t{`\"\\u006bey\":1`, `\\u006bey`, `:1`, nil}, // Will be handled by parseRawString\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tkey, tail, err := parseRawKey(tt.input)\n\n\t\t\tif key != tt.key {\n\t\t\t\tt.Errorf(\"expected key '%s', got '%s'\", tt.key, key)\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"expected tail '%s', got '%s'\", tt.tail, tail)\n\t\t\t}\n\t\t\tif (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"expected error '%v', got '%v'\", tt.err, err)\n\t\t\t}\n\t\t})\n\t}\n}","d384e78a0455b8094e0cc981c2bfffd0":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_unescapeKeys(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tkvs  []kv\n\t\twant []kv\n\t}{\n\t\t{\n\t\t\tname: \"basic\",\n\t\t\tkvs: []kv{\n\t\t\t\t{k: \"\\\\u0061\", v: \u0026Value{t: TypeString, s: \"foo\"}},\n\t\t\t\t{k: \"b\", v: \u0026Value{t: TypeString, s: \"bar\"}},\n\t\t\t},\n\t\t\twant: []kv{\n\t\t\t\t{k: \"a\", v: \u0026Value{t: TypeString, s: \"foo\"}},\n\t\t\t\t{k: \"b\", v: \u0026Value{t: TypeString, s: \"bar\"}},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"no escape\",\n\t\t\tkvs: []kv{\n\t\t\t\t{k: \"a\", v: \u0026Value{t: TypeString, s: \"foo\"}},\n\t\t\t\t{k: \"b\", v: \u0026Value{t: TypeString, s: \"bar\"}},\n\t\t\t},\n\t\t\twant: []kv{\n\t\t\t\t{k: \"a\", v: \u0026Value{t: TypeString, s: \"foo\"}},\n\t\t\t\t{k: \"b\", v: \u0026Value{t: TypeString, s: \"bar\"}},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\to := \u0026Object{\n\t\t\t\tkvs: tt.kvs,\n\t\t\t}\n\t\t\to.unescapeKeys()\n\t\t\tfor i := range o.kvs {\n\t\t\t\tif o.kvs[i].k != tt.want[i].k {\n\t\t\t\t\tt.Errorf(\"unescapeKeys() got %v, want %v\", o.kvs[i].k, tt.want[i].k)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","d4399876666ac672c67f3ad25ddf2cf4":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Test cases here\n\t\t{\n\t\t\tinput: \"null\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\ttail: \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: \"true\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\ttail: \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: \"false\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\ttail: \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `\"hello\"`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\ttail: \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: \"123\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\ttail: \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: \"123.456\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\ttail: \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: \"nullx\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\ttail: \"x\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: \"123a\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\ttail: \"a\",\n\t\t\terr:   nil,\n\t\t},\n\t\t// Add more test cases for other branches\n\t}\n\n\tfor i, test := range tests {\n\t\tc := \u0026cache{}\n\t\tgot, tail, err := parseValue(test.input, c, 0)\n\n\t\tif test.err != nil {\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"Test %d failed: expected error, got nil\", i)\n\t\t\t} else if err.Error() != test.err.Error() {\n\t\t\t\tt.Errorf(\"Test %d failed: error mismatch, got %v, want %v\", i, err, test.err)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Test %d failed: unexpected error: %v\", i, err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif tail != test.tail {\n\t\t\tt.Errorf(\"Test %d failed: tail mismatch, got %q, want %q\", i, tail, test.tail)\n\t\t}\n\t\tif got.t != test.want.t {\n\t\t\tt.Errorf(\"Test %d failed: type mismatch, got %v, want %v\", i, got.t, test.want.t)\n\t\t}\n\t\tif got.s != test.want.s {\n\t\t\tt.Errorf(\"Test %d failed: value mismatch, got %q, want %q\", i, got.s, test.want.s)\n\t\t}\n\t}\n}","d4b604f7b013fd7cbb085e5d0f4c170d":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantN    string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Empty input.\n\t\t{\"\", \"\", \"\", nil},\n\n\t\t// Valid numbers.\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"123.456\", \"123.456\", \"\", nil},\n\t\t{\"-123.456\", \"-123.456\", \"\", nil},\n\t\t{\"1.2e3\", \"1.2e3\", \"\", nil},\n\t\t{\"-1.2e-3\", \"-1.2e-3\", \"\", nil},\n\n\t\t// Valid numbers with trailing characters.\n\t\t{\"123 \", \"123\", \" \", nil},\n\t\t{\"123x\", \"123\", \"x\", nil},\n\n\t\t// Invalid numbers.\n\t\t{\"+\", \"\", \"\", fmt.Errorf(`unexpected char: \"+\"`)},\n\t\t{\"-\", \"\", \"\", fmt.Errorf(`unexpected char: \"-\"`)},\n\t\t{\"123e\", \"123\", \"e\", nil},\n\t\t{\"123E\", \"123\", \"E\", nil},\n\t\t{\"123+\", \"123\", \"+\", nil},\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"+inf\", \"+inf\", \"\", nil},\n\t\t{\"NAN\", \"NAN\", \"\", nil},\n\n\t\t// Special cases for \"inf\" and \"nan\".\n\t\t{\"infin\", \"inf\", \"in\", nil},\n\t\t{\"nanx\", \"nan\", \"x\", nil},\n\t\t{\"123inf\", \"123\", \"inf\", nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test %d\", i), func(t *testing.T) {\n\t\t\tgotN, gotTail, gotErr := parseRawNumber(tt.input)\n\t\t\tif gotN != tt.wantN {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, want %q\", tt.input, gotN, tt.wantN)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, want %q\", tt.input, gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif gotErr == nil \u0026\u0026 tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got no error, want %v\", tt.input, tt.wantErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr == nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got error %v, want no error\", tt.input, gotErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got error %v, want %v\", tt.input, gotErr, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","d5afcbd21334131754f319a21296c8e1":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantData *Value\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t{\n\t\t\tname:     \"empty array\",\n\t\t\tinput:    \"[]\",\n\t\t\twantData: \u0026Value{t: TypeArray},\n\t\t\twantTail: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"simple array\",\n\t\t\tinput:    \"[1,2,3]\",\n\t\t\twantData: \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}},\n\t\t\twantTail: \"\",\n\t\t},\n\t\t{\n\t\t\tname:  \"unterminated array\",\n\t\t\tinput: \"[1,2,3\",\n\t\t\twantErr: fmt.Errorf(\"unexpected end of array\"),\n\t\t},\n\t\t{\n\t\t\tname:  \"missing comma\",\n\t\t\tinput: \"[1 2 3]\",\n\t\t\twantErr: fmt.Errorf(\"missing ',' after array value\"),\n\t\t},\n\t\t{\n\t\t\tname:  \"invalid value\",\n\t\t\tinput: \"[1,+,3]\",\n\t\t\twantErr: fmt.Errorf(\"cannot parse array value: unknown value\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"nested array\",\n\t\t\tinput:    \"[1,[2,3],4]\",\n\t\t\twantData: \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeArray, a: []*Value{{t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}}, {t: TypeNumber, s: \"4\"}}},\n\t\t\twantTail: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"array with trailing whitespace\",\n\t\t\tinput:    \"[1,2,3] \",\n\t\t\twantData: \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}},\n\t\t\twantTail: \" \",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgotData, gotTail, gotErr := parseArray(tt.input, c, 0)\n\n\t\t\tif gotData != nil \u0026\u0026 tt.wantData != nil \u0026\u0026 gotData.t == tt.wantData.t {\n\t\t\t\tif gotData.t == TypeArray {\n\t\t\t\t\tif len(gotData.a) != len(tt.wantData.a) {\n\t\t\t\t\t\tt.Errorf(\"parseArray() = %v, want %v\", gotData, tt.wantData)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tfor i := range gotData.a {\n\t\t\t\t\t\tif gotData.a[i].s != tt.wantData.a[i].s {\n\t\t\t\t\t\t\tt.Errorf(\"parseArray() = %v, want %v\", gotData, tt.wantData)\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif gotData.s != tt.wantData.s {\n\t\t\t\t\t\tt.Errorf(\"parseArray() = %v, want %v\", gotData, tt.wantData)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseArray() gotTail = %v, want %v\", gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif gotErr == nil \u0026\u0026 tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"parseArray() gotErr = nil, want %v\", tt.wantErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr == nil {\n\t\t\t\tt.Errorf(\"parseArray() gotErr = %v, want nil\", gotErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"parseArray() gotErr = %v, want %v\", gotErr, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","d6b58a3300f6f0aa3be4fdc50d3224d9":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_StringBytes(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tv       *Value\n\t\twant    []byte\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant:    []byte(\"hello\"),\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := tt.v.StringBytes()\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"StringBytes() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif string(got) != string(tt.want) {\n\t\t\t\tt.Errorf(\"StringBytes() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","d82823f69afa030b585520cf90bdf567":"package fastjson\n\nimport \"testing\"\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tinput Type\n\t\twant  string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\tfor i, tt := range tests {\n\t\tgot := tt.input.String()\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"test[%d]: String() = %q; want %q\", i, got, tt.want)\n\t\t}\n\t}\n}","db61f8c8bafafa3f785b8278370ea805":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey   string\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Unescaped strings.\n\t\t{`\"foo\"bar`, \"foo\", \"bar\", nil},\n\t\t{`\"foo\" bar`, \"foo\", \" bar\", nil},\n\t\t{`\"foo\"  bar`, \"foo\", \"  bar\", nil},\n\n\t\t// Escaped strings.\n\t\t{`\"fo\\\"o\"bar`, `fo\"o`, \"bar\", nil},\n\t\t{`\"fo\\\\o\"bar`, `fo\\o`, \"bar\", nil},\n\t\t{`\"fo\\to\"bar`, \"fo\\to\", \"bar\", nil},\n\t\t{`\"fo\\ro\"bar`, \"fo\\ro\", \"bar\", nil},\n\t\t{`\"fo\\no\"bar`, \"fo\\no\", \"bar\", nil},\n\t\t{`\"\\u1234foo\"bar`, \"\\u1234foo\", \"bar\", nil},\n\t\t{`\"\\\"\"bar`, `\"`, \"bar\", nil},\n\n\t\t// Missing closing quote.\n\t\t{`\"foo`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"fo\\\"o`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\n\t\t// Empty strings.\n\t\t{`\"\"bar`, \"\", \"bar\", nil},\n\t\t{`\"\" bar`, \"\", \" bar\", nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tkey, tail, err := parseRawString(tt.input)\n\t\t\tif key != tt.key || tail != tt.tail || !equalError(err, tt.err) {\n\t\t\t\tt.Errorf(\"input: %q, want (%q, %q, %v), got (%q, %q, %v)\", tt.input, tt.key, tt.tail, tt.err, key, tail, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// equalError reports whether errors a and b are equal.\n// They're equal if both are nil, or both are not nil and a.Error() == b.Error().\nfunc equalError(a, b error) bool {\n\treturn a == nil \u0026\u0026 b == nil || a != nil \u0026\u0026 b != nil \u0026\u0026 a.Error() == b.Error()\n}\n","dc8534c514a95ac790249388b3fb0c86":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantN    string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Basic cases.\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"123.456\", \"123.456\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"+123\", \"+123\", \"\", nil},\n\t\t{\"1.2e3\", \"1.2e3\", \"\", nil},\n\t\t{\"1.2E-3\", \"1.2E-3\", \"\", nil},\n\n\t\t// Trailing garbage.\n\t\t{\"123x\", \"123\", \"x\", nil},\n\t\t{\"123.456x\", \"123.456\", \"x\", nil},\n\t\t{\"-123x\", \"-123\", \"x\", nil},\n\t\t{\"+123x\", \"+123\", \"x\", nil},\n\n\t\t// Leading garbage.\n\t\t{\"x123\", \"\", \"x123\", fmt.Errorf(`unexpected char: \"x\"`)},\n\t\t{\"x123.456\", \"\", \"x123.456\", fmt.Errorf(`unexpected char: \"x\"`)},\n\n\t\t// Invalid numbers.\n\t\t{\"--123\", \"\", \"--123\", fmt.Errorf(`unexpected char: \"-\"`)},\n\t\t{\".123\", \"\", \".123\", fmt.Errorf(`unexpected char: \".\"`)},\n\t\t{\"123.\", \"\", \"123.\", fmt.Errorf(`unexpected char: \".\"`)},\n\n\t\t// Special values.\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"+inf\", \"+inf\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"InF\", \"InF\", \"\", nil},\n\t\t{\"inF\", \"inF\", \"\", nil},\n\t\t{\"Infi\", \"Infi\", \"\", fmt.Errorf(`unexpected char: \"I\"`)},\n\t\t{\"Infin\", \"Infin\", \"\", fmt.Errorf(`unexpected char: \"I\"`)},\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"+nan\", \"+nan\", \"\", nil},\n\t\t{\"-nan\", \"-nan\", \"\", nil},\n\t\t{\"NaN\", \"NaN\", \"\", nil},\n\t\t{\"naN\", \"naN\", \"\", nil},\n\t\t{\"Nani\", \"Nani\", \"\", fmt.Errorf(`unexpected char: \"N\"`)},\n\t\t{\"Nanx\", \"Nanx\", \"\", fmt.Errorf(`unexpected char: \"N\"`)},\n\t}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tgotN, gotTail, gotErr := parseRawNumber(tt.input)\n\t\t\tif gotN != tt.wantN || gotTail != tt.wantTail || (gotErr != nil \u0026\u0026 tt.wantErr == nil) || (gotErr == nil \u0026\u0026 tt.wantErr != nil) || (gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error()) {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = (%q, %q, %v), want (%q, %q, %v)\", tt.input, gotN, gotTail, gotErr, tt.wantN, tt.wantTail, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","dc8ba8ea3d6e15a7873c4367652b2c60":"package fastjson\n\nimport \"testing\"\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"  foo\", \"foo\"},\n\t\t{\"\\n\\n\\t bar\", \"bar\"},\n\t\t{\"\\r\\n \\t  baz\", \"baz\"},\n\t\t{\"qux\", \"qux\"},\n\t\t{\"\", \"\"},\n\t\t{\"\\t\", \"\"},\n\t\t{\"  \\r\\n \", \"\"},\n\t}\n\n\tfor _, tc := range tests {\n\t\tactual := skipWSSlow(tc.input)\n\t\tif actual != tc.expected {\n\t\t\tt.Errorf(\"skipWSSlow(%q) = %q; want %q\", tc.input, actual, tc.expected)\n\t\t}\n\t}\n}","dca2d006634fa60407c962b9f0af8fda":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantObj  string\n\t\twantTail string\n\t\twantErr  string\n\t}{\n\t\t{\n\t\t\tname:     \"empty object\",\n\t\t\tinput:    \"{}\",\n\t\t\twantObj:  `{\"t\":1}`,\n\t\t\twantTail: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"simple object\",\n\t\t\tinput:    `{\"foo\":\"bar\"}`,\n\t\t\twantObj:  `{\"t\":1,\"o\":{\"kvs\":[{\"k\":\"foo\",\"v\":{\"t\":3,\"s\":\"bar\"}}]}}`,\n\t\t\twantTail: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"nested object\",\n\t\t\tinput:    `{\"foo\":{\"bar\":\"baz\"}}`,\n\t\t\twantObj:  `{\"t\":1,\"o\":{\"kvs\":[{\"k\":\"foo\",\"v\":{\"t\":1,\"o\":{\"kvs\":[{\"k\":\"bar\",\"v\":{\"t\":3,\"s\":\"baz\"}}]}}}]}}`,\n\t\t\twantTail: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple keys\",\n\t\t\tinput:    `{\"foo\":\"bar\",\"baz\":123}`,\n\t\t\twantObj:  `{\"t\":1,\"o\":{\"kvs\":[{\"k\":\"foo\",\"v\":{\"t\":3,\"s\":\"bar\"}},{\"k\":\"baz\",\"v\":{\"t\":4,\"s\":\"123\"}}]}}`,\n\t\t\twantTail: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"missing closing brace\",\n\t\t\tinput:    `{\"foo\":\"bar\"`,\n\t\t\twantErr:  \"missing '}'\",\n\t\t\twantTail: `{\"foo\":\"bar\"`,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing opening quote for key\",\n\t\t\tinput:    \"{foo:\\\"bar\\\"}\",\n\t\t\twantErr:  `cannot find opening '\"\" for object key`,\n\t\t\twantTail: \"foo:\\\"bar\\\"}\",\n\t\t},\n\t\t{\n\t\t\tname:     \"missing closing quote for key\",\n\t\t\tinput:    `{\"foo:\"bar\"}`,\n\t\t\twantErr:  \"cannot parse object key: missing '\\\"'\",\n\t\t\twantTail: `\"bar\"}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing colon after key\",\n\t\t\tinput:    `{\"foo\"\"bar\"}`,\n\t\t\twantErr:  \"missing ':' after object key\",\n\t\t\twantTail: `\"bar\"}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing comma between key-value pairs\",\n\t\t\tinput:    `{\"foo\":\"bar\"\"baz\":\"qux\"}`,\n\t\t\twantErr:  \"missing ',' after object value\",\n\t\t\twantTail: `\"baz\":\"qux\"}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid value\",\n\t\t\tinput:    `{\"foo\":invalid}`,\n\t\t\twantErr:  \"cannot parse object value: unknown token 'i'\",\n\t\t\twantTail: \"invalid}\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgotObj, gotTail, gotErr := parseObject(tt.input, c, 0)\n\n\t\t\tif tt.wantErr != \"\" {\n\t\t\t\tif gotErr == nil {\n\t\t\t\t\tt.Errorf(\"expected error %q, got nil\", tt.wantErr)\n\t\t\t\t} else if gotErr.Error() != tt.wantErr {\n\t\t\t\t\tt.Errorf(\"expected error %q, got %q\", tt.wantErr, gotErr.Error())\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotErr != nil {\n\t\t\t\tt.Errorf(\"unexpected error: %v\", gotErr)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"expected tail %q, got %q\", tt.wantTail, gotTail)\n\t\t\t}\n\n\t\t\tgotObjStr := fmt.Sprintf(\"%#v\", gotObj)\n\t\t\tif gotObjStr != tt.wantObj {\n\t\t\t\tt.Errorf(\"expected object %q, got %q\", tt.wantObj, gotObjStr)\n\t\t\t}\n\t\t})\n\t}\n}\n","dd219a2aa44bcb66c6744f5b2ba36ce9":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic escapes\n\t\t{`\\t\\b\\n\\f\\r\\\\\\/\\\"`, \"\\t\\b\\n\\f\\r\\\\/\\\"\"},\n\t\t// Unicode escapes\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A0`, \"\\u00A0\"},\n\t\t{`\\uFFFF`, \"\\uFFFF\"},\n\t\t// Surrogate pairs\n\t\t{`\\uD83D\\uDE02`, \"üòÇ\"},\n\t\t{`\\uD834\\uDD1E`, \"\\U0001D11E\"},\n\t\t// Invalid escapes\n\t\t{`\\a\\v\\`, `\\a\\v\\`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\uD800`, `\\uD800`},\n\t\t{`\\uD800\\u`, `\\uD800\\u`},\n\t\t// Mixed\n\t\t{`Hello\\tworld\\n`, \"Hello\\tworld\\n\"},\n\t\t{`\\u0041\\u0020string\\twith\\tsome\\tescapes\\\\`, \"A string\\twith\\tsome\\tescapes\\\\\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}","dde25cf643e56e97e53ca4ead8c2e7f0":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantN    string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Basic cases.\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"123.456\", \"123.456\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"+123\", \"+123\", \"\", nil},\n\t\t{\"1.2e3\", \"1.2e3\", \"\", nil},\n\t\t{\"1.2E-3\", \"1.2E-3\", \"\", nil},\n\n\t\t// Trailing garbage.\n\t\t{\"123x\", \"123\", \"x\", nil},\n\t\t{\"123.456x\", \"123.456\", \"x\", nil},\n\n\t\t// Leading garbage.\n\t\t{\"x123\", \"\", \"x123\", fmt.Errorf(`unexpected char: \"x\"`)},\n\n\t\t// Invalid numbers.\n\t\t{\"\", \"\", \"\", fmt.Errorf(`unexpected char: \"\"`)},\n\t\t{\"-\", \"\", \"-\", fmt.Errorf(`unexpected char: \"-\"`)},\n\t\t{\"+\", \"\", \"+\", fmt.Errorf(`unexpected char: \"+\"`)},\n\t\t(\".123\", \"\", \".123\", fmt.Errorf(`unexpected char: \".\"`)},\n\t\t{\"1e\", \"\", \"1e\", fmt.Errorf(`unexpected char: \"1\"`)},\n\n\t\t// Special cases: \"inf\", \"nan\".\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"+inf\", \"+inf\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"+nan\", \"\", \"+nan\", fmt.Errorf(`unexpected char: \"+\"`)},\n\t\t{\"-nan\", \"\", \"-nan\", fmt.Errorf(`unexpected char: \"-\"`)},\n\t\t{\"in\", \"\", \"in\", fmt.Errorf(`unexpected char: \"i\"`)},\n\t\t{\"+i\", \"\", \"+i\", fmt.Errorf(`unexpected char: \"+\"`)},\n\t\t{\"infx\", \"inf\", \"x\", nil},\n\t\t{\"+infx\", \"+inf\", \"x\", nil},\n\t\t{\"-infx\", \"-inf\", \"x\", nil},\n\t\t{\"nanx\", \"nan\", \"x\", nil},\n\t}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tgotN, gotTail, gotErr := parseRawNumber(tt.input)\n\t\t\tif gotN != tt.wantN {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, want %q\", tt.input, gotN, tt.wantN)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, want %q\", tt.input, gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif gotErr == nil \u0026\u0026 tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = nil, want %v\", tt.input, tt.wantErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr == nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, want nil\", tt.input, gotErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, want %v\", tt.input, gotErr, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}\n","de1d09d9d4effb17d78a1263560aee71":"package fastjson\n\nimport \"testing\"\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"  foo\", \"foo\"},\n\t\t{\"\\n\\n  bar\", \"bar\"},\n\t\t{\"\\t\\r\\n  baz\", \"baz\"},\n\t\t{\"qux\", \"qux\"},\n\t\t{\"  \", \"\"},\n\t\t{\"\", \"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := skipWSSlow(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"skipWSSlow(%q) = %q, expected %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}\n","df4c44fc41f3659b59dbb32405ad0613":"package fastjson\n\nimport \"testing\"\n\nfunc TestValue_GetBool(t *testing.T) {\n\tvar v Value\n\ttests := []struct {\n\t\tname  string\n\t\tinput string\n\t\tkeys  []string\n\t\twant  bool\n\t}{\n\t\t{\n\t\t\tname:  \"true\",\n\t\t\tinput: `true`,\n\t\t\tkeys:  nil,\n\t\t\twant:  true,\n\t\t},\n\t\t{\n\t\t\tname:  \"false\",\n\t\t\tinput: `false`,\n\t\t\tkeys:  nil,\n\t\t\twant:  false,\n\t\t},\n\t\t{\n\t\t\tname:  \"null\",\n\t\t\tinput: `null`,\n\t\t\tkeys:  nil,\n\t\t\twant:  false,\n\t\t},\n\t\t{\n\t\t\tname:  \"string\",\n\t\t\tinput: `\"true\"`,\n\t\t\tkeys:  nil,\n\t\t\twant:  false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object\",\n\t\t\tinput: `{\"key\":true}`,\n\t\t\tkeys:  []string{\"key\"},\n\t\t\twant:  true,\n\t\t},\n\t\t{\n\t\t\tname:  \"object_false\",\n\t\t\tinput: `{\"key\":false}`,\n\t\t\tkeys:  []string{\"key\"},\n\t\t\twant:  false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object_missing_key\",\n\t\t\tinput: `{\"key\":true}`,\n\t\t\tkeys:  []string{\"missing\"},\n\t\t\twant:  false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array\",\n\t\t\tinput: `[true,false]`,\n\t\t\tkeys:  []string{\"0\"},\n\t\t\twant:  true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array_false\",\n\t\t\tinput: `[true,false]`,\n\t\t\tkeys:  []string{\"1\"},\n\t\t\twant:  false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array_out_of_bounds\",\n\t\t\tinput: `[true,false]`,\n\t\t\tkeys:  []string{\"2\"},\n\t\t\twant:  false,\n\t\t},\n\t\t{\n\t\t\tname:  \"nested_object\",\n\t\t\tinput: `{\"outer\":{\"inner\":true}}`,\n\t\t\tkeys:  []string{\"outer\", \"inner\"},\n\t\t\twant:  true,\n\t\t},\n\t\t{\n\t\t\tname:  \"nested_array\",\n\t\t\tinput: `{\"outer\":[true,false]}`,\n\t\t\tkeys:  []string{\"outer\", \"0\"},\n\t\t\twant:  true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif err := v.Parse(tt.input); err != nil {\n\t\t\t\tt.Errorf(\"Parse() error = %v, input = %v\", err, tt.input)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got := v.GetBool(tt.keys...); got != tt.want {\n\t\t\t\tt.Errorf(\"GetBool() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","e08540605cae6ed9a666d3cee7b412f7":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic escapes\n\t\t{`\\b`, \"\\b\"},\n\t\t{`\\f`, \"\\f\"},\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\r`, \"\\r\"},\n\t\t{`\\t`, \"\\t\"},\n\t\t{`\\\\`, \"\\\\\"},\n\t\t{`\\/`, \"/\"},\n\t\t{`\\\"`, \"\\\"\"},\n\n\t\t// Unicode escapes\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A0`, \"\\u00A0\"},\n\t\t{`\\uFFFF`, \"\\uFFFF\"},\n\t\t{`\\uD83D\\uDE01`, \"\\U0001F601\"}, // Smiley face\n\n\t\t// Invalid escapes\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\uD800`, `\\uD800`},\n\t\t{`\\uD83D\\uXXXX`, `\\uD83D\\uXXXX`},\n\n\t\t// Combinations and real-world examples\n\t\t{`Hello, world!`, `Hello, world!`},\n\t\t{`\\tindented\\ntext`, \"\\tindented\\ntext\"},\n\t\t{`{\\\"key\\\": \\\"value\\\"}`, `{\"key\": \"value\"}`},\n\t\t{`Path: \"C:\\\\Windows\\\\System32\\\\\"`, `Path: \"C:\\Windows\\System32\\\"`},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tactual := unescapeStringBestEffort(tt.input)\n\t\t\tif actual != tt.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", tt.input, actual, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n","e0c44423b42e12e4986c689637048fc2":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic strings with no escape sequences.\n\t\t{\"hello\", \"hello\"},\n\t\t{\"world\", \"world\"},\n\n\t\t// Empty string.\n\t\t{\"\", \"\"},\n\n\t\t// Simple escape sequences.\n\t\t{`\\\"`, `\"`},\n\t\t{`\\\\`, `\\`},\n\t\t{`\\/`, `/`},\n\t\t{`\\b`, \"\\b\"},\n\t\t{`\\f`, \"\\f\"},\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\r`, \"\\r\"},\n\t\t{`\\t`, \"\\t\"},\n\n\t\t// Unicode escape sequences.\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A9`, \"¬©\"},\n\t\t{`\\u20AC`, \"‚Ç¨\"},\n\n\t\t// Handling of invalid escape sequences.\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\u123G`, `\\u123G`},\n\n\t\t// Handling of surrogate pairs.\n\t\t{`\\uD83D\\uDE00`, \"üòÄ\"}, // Grinning Face emoji\n\t\t{`\\uD83D\\uDC4D\\uD83C\\uDFFB`, \"üëçüèº\"}, // Thumbs Up: Medium Skin Tone emoji\n\n\t\t// Mixture of valid and invalid escape sequences.\n\t\t{`Hello\\tworld\\nThis is a \\u0022test\\u0022 string.\\r\\n`,\n\t\t\t\"Hello\\tworld\\nThis is a \\\"test\\\" string.\\r\\n\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.input, func(t *testing.T) {\n\t\t\tactual := unescapeStringBestEffort(test.input)\n\t\t\tif actual != test.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\",\n\t\t\t\t\ttest.input, actual, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n","e21671345d404e178d58a9be757c585b":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ts     string\n\t\terr   error\n\t}{\n\t\t// Empty array\n\t\t{\"[]\", \u0026Value{t: TypeArray, a: []*Value{}}, \"\", nil},\n\t\t// Simple array\n\t\t{\"[1,2,3]\", \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t}}, \"\", nil},\n\t\t// Array with spaces\n\t\t{\" [ 1 , 2 , 3 ] \", \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t}}, \"\", nil},\n\t\t// Nested array\n\t\t{\"[[1,2],[3,4]]\", \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t}},\n\t\t\t{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t{t: TypeNumber, s: \"4\"},\n\t\t\t}},\n\t\t}}, \"\", nil},\n\t\t// Array with different types\n\t\t{\"[1,\\\"hello\\\",true]\", \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t{t: TypeString, s: \"hello\"},\n\t\t\t{t: TypeTrue},\n\t\t}}, \"\", nil},\n\t\t// Error cases\n\t\t{\"[\", nil, \"[\", fmt.Errorf(\"missing ']'\")},\n\t\t{\"[1,2\", nil, \"[1,2\", fmt.Errorf(\"unexpected end of array\")},\n\t\t{\"[1,2,\", nil, \"[1,2,\", fmt.Errorf(\"unexpected end of array\")},\n\t\t{\"[1 2]\", nil, \"[1 2]\", fmt.Errorf(\"missing ',' after array value\")},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d:%s\", i, tt.input), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseArray(tt.input, c, 0)\n\t\t\tif (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"parseArray(%s) error = %v, wantErr %v\", tt.input, err, tt.err)\n\t\t\t}\n\t\t\tif s != tt.s {\n\t\t\t\tt.Errorf(\"parseArray(%s) remaining string = %s, want %s\", tt.input, s, tt.s)\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray(%s) = %v, want %v\", tt.input, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\treturn v1.s == v2.s\n\t}\n}","e23f2363915a7f8671a8500fbf19be5d":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant: []byte(\"123\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"hello\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"[\\\"hello\\\",123]\"),\n\t\t},\n\t\t// Add more test cases for other types and nested structures.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif string(got) != string(tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", string(got), string(tt.want))\n\t\t\t}\n\t\t})\n\t}\n}","e29ea33cab5b9f9fb4523fdea62a7bfd":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc Test_parseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\ts    string\n\t\twant string\n\t\tsTail string\n\t\terr error\n\t}{\n\t\t//TODO: Add test cases.\n\t\t{s: \"123\", want: \"123\", sTail: \"\", err: nil},\n\t\t{s: \"123abc\", want: \"123\", sTail: \"abc\", err: nil},\n\t\t{s: \"-123\", want: \"-123\", sTail: \"\", err: nil},\n\t\t{s: \"+123\", want: \"+123\", sTail: \"\", err: nil},\n\t\t{s: \"123.456\", want: \"123.456\", sTail: \"\", err: nil},\n\t\t{s: \"123e+10\", want: \"123e+10\", sTail: \"\", err: nil},\n\t\t{s: \"123E-10\", want: \"123E-10\", sTail: \"\", err: nil},\n\t\t{s: \"inf\", want: \"inf\", sTail: \"\", err: nil},\n\t\t{s: \"INF\", want: \"INF\", sTail: \"\", err: nil},\n\t\t{s: \"+inf\", want: \"+inf\", sTail: \"\", err: nil},\n\t\t{s: \"+INF\", want: \"+INF\", sTail: \"\", err: nil},\n\t\t{s: \"-inf\", want: \"-inf\", sTail: \"\", err: nil},\n\t\t{s: \"-INF\", want: \"-INF\", sTail: \"\", err: nil},\n\t\t{s: \"nan\", want: \"nan\", sTail: \"\", err: nil},\n\t\t{s: \"NaN\", want: \"NaN\", sTail: \"\", err: nil},\n\t\t{s: \"123inf\", want: \"123\", sTail: \"inf\", err: nil},\n\t\t{s: \"123x\", want: \"123\", sTail: \"x\", err: nil},\n\t\t{s: \"x123\", want: \"\", sTail: \"x123\", err: fmt.Errorf(`unexpected char: \"x\"`)},\n\t}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawNumber(tt.s)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawNumber() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.sTail {\n\t\t\t\tt.Errorf(\"parseRawNumber() got1 = %v, want %v\", got1, tt.sTail)\n\t\t\t}\n\t\t\tif (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"parseRawNumber() err = %v, want %v\", err, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}","e2f1c5765c1a8aba24c0ebf5d434d945":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ts     string\n\t\terr   error\n\t}{\n\t\t// Empty object\n\t\t{\n\t\t\tinput: \"{}\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Single key-value pair\n\t\t{\n\t\t\tinput: `{\"key\": \"value\"}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: \u0026Value{t: TypeString, s: \"value\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Multiple key-value pairs\n\t\t{\n\t\t\tinput: `{\"key1\": \"value1\", \"key2\": 123, \"key3\": true}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t\t{k: \"key3\", v: \u0026Value{t: TypeTrue}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Nested object\n\t\t{\n\t\t\tinput: `{\"key1\": {\"key2\": \"value2\"}}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Missing closing brace\n\t\t{\n\t\t\tinput: `{\"key\": \"value\"`,\n\t\t\twant:  nil,\n\t\t\ts:     `{\"key\": \"value\"`,\n\t\t\terr:   fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t\t// Invalid key\n\t\t{\n\t\t\tinput: `{key: \"value\"}`,\n\t\t\twant:  nil,\n\t\t\ts:     `{key: \"value\"}`,\n\t\t\terr:   fmt.Errorf(`cannot find opening '\"\" for object key`),\n\t\t},\n\t\t// Missing colon\n\t\t{\n\t\t\tinput: `{\"key\" \"value\"}`,\n\t\t\twant:  nil,\n\t\t\ts:     `\"value\"}`,\n\t\t\terr:   fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t\t// Invalid value\n\t\t{\n\t\t\tinput: `{\"key\": invalid}`,\n\t\t\twant:  nil,\n\t\t\ts:     `invalid}`,\n\t\t\terr:   fmt.Errorf(\"cannot parse object value: invalid character 'i' looking for beginning of value\"),\n\t\t},\n\t\t// Missing comma\n\t\t{\n\t\t\tinput: `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twant:  nil,\n\t\t\ts:     `\"key2\": \"value2\"}`,\n\t\t\terr:   fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseObject(tt.input, c, 0)\n\t\t\tif fmt.Sprintf(\"%v\", err) != fmt.Sprintf(\"%v\", tt.err) {\n\t\t\t\tt.Errorf(\"parseObject(%q) error mismatch: got %v, want %v\", tt.input, err, tt.err)\n\t\t\t}\n\t\t\tif s != tt.s {\n\t\t\t\tt.Errorf(\"parseObject(%q) remaining string mismatch: got %q, want %q\", tt.input, s, tt.s)\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject(%q) result mismatch:\\ngot  %+v\\nwant %+v\", tt.input, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// Helper function to compare *Value instances\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\treturn true\n\t}\n}\n","e310404b1d11354d4286fbf82a7a9788":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ts     string\n\t\terr   error\n\t}{\n\t\t// Empty object\n\t\t{\n\t\t\tinput: `{}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Single key-value pair\n\t\t{\n\t\t\tinput: `{\"key\": \"value\"}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: \u0026Value{t: TypeString, s: \"value\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Multiple key-value pairs\n\t\t{\n\t\t\tinput: `{\"key1\": \"value1\", \"key2\": 123, \"key3\": true}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t\t{k: \"key3\", v: \u0026Value{t: TypeTrue}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Nested object\n\t\t{\n\t\t\tinput: `{\"key1\": {\"key2\": \"value2\"}, \"key3\": \"value3\"}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{k: \"key3\", v: \u0026Value{t: TypeString, s: \"value3\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Missing closing brace\n\t\t{\n\t\t\tinput: `{\"key\": \"value\"`,\n\t\t\twant:  nil,\n\t\t\ts:     `{\"key\": \"value\"`,\n\t\t\terr:   fmt.Errorf(`missing '}'`),\n\t\t},\n\t\t// Missing opening quote for key\n\t\t{\n\t\t\tinput: `{key\": \"value\"}`,\n\t\t\twant:  nil,\n\t\t\ts:     `key\": \"value\"}`,\n\t\t\terr:   fmt.Errorf(`cannot find opening '\"\" for object key`),\n\t\t},\n\t\t// Missing colon after key\n\t\t{\n\t\t\tinput: `{\"key\" \"value\"}`,\n\t\t\twant:  nil,\n\t\t\ts:     `\"value\"}`,\n\t\t\terr:   fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t\t// Missing comma between key-value pairs\n\t\t{\n\t\t\tinput: `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twant:  nil,\n\t\t\ts:     `\"key2\": \"value2\"}`,\n\t\t\terr:   fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\t\t// Invalid value\n\t\t{\n\t\t\tinput: `{\"key\": invalid}`,\n\t\t\twant:  nil,\n\t\t\ts:     `invalid}`,\n\t\t\terr:   fmt.Errorf(\"cannot parse object value: invalid character 'i' looking for beginning of value\"),\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i+1), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseObject(tt.input, c, 0)\n\t\t\tif fmt.Sprintf(\"%v\", err) != fmt.Sprintf(\"%v\", tt.err) {\n\t\t\t\tt.Errorf(\"parseObject(%q) error mismatch: got %v, want %v\", tt.input, err, tt.err)\n\t\t\t}\n\t\t\tif s != tt.s {\n\t\t\t\tt.Errorf(\"parseObject(%q) remaining string mismatch: got %q, want %q\", tt.input, s, tt.s)\n\t\t\t}\n\t\t\tif !compareValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject(%q) value mismatch:\\ngot  %+v\\nwant %+v\", tt.input, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !compareValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\treturn true\n\t}\n}\n","e32f3799b5fb1bcda0719fd195661530":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc Test_unescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"simple\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped_quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\\\"hello\\\"`,\n\t\t\t},\n\t\t\twant: `\"hello\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped_unicode\",\n\t\t\targs: args{\n\t\t\t\ts: `\\u0022hello\\u0022`,\n\t\t\t},\n\t\t\twant: `\"hello\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid_escape_sequence\",\n\t\t\targs: args{\n\t\t\t\ts: `\\z`,\n\t\t\t},\n\t\t\twant: `\\z`,\n\t\t},\n\t\t{\n\t\t\tname: \"truncated_unicode_escape_sequence\",\n\t\t\targs: args{\n\t\t\t\ts: `\\u002`,\n\t\t\t},\n\t\t\twant: `\\u002`,\n\t\t},\n\t\t{\n\t\t\tname: \"surrogate_pair\",\n\t\t\targs: args{\n\t\t\t\ts: `\\uD83D\\uDE01`,\n\t\t\t},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"truncated_surrogate_pair\",\n\t\t\targs: args{\n\t\t\t\ts: `\\uD83D\\uDE`,\n\t\t\t},\n\t\t\twant: `\\uD83D\\uDE`,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","e367c07855bfa56e25589782286ec8b7":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey string\n\t\tvalue string\n\t\terr error\n\t}{\n\t\t// Simple cases\n\t\t{`\"key\": \"value\"`, `\"key\"`, `value`, nil},\n\t\t{`\"key\":\"value\"`, `\"key\"`, `value`, nil},\n\t\t{`\"key\": \"value\"  `, `\"key\"`, `value`, nil},\n\t\t{`\"key\" : \"value\"`, `\"key\"`, `value`, nil},\n\n\t\t// Escaped quotes\n\t\t{`\"key\": \"with\\\\\"quote\"`, `\"key\"`, `with\\\"quote`, nil},\n\t\t{`\"key\": \"with\\\\\\\\\"quote\"`, `\"key\"`, `with\\\\\"quote`, nil},\n\t\t{`\"key\": \"multiple\\\\\"esc\\\\\"apes\"`, `\"key\"`, `multiple\\\"esc\\\"apes`, nil},\n\n\t\t// Missing closing quote\n\t\t{`\"key: \"value\"`, ``, ``, fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"key: \"value`, ``, ``, fmt.Errorf(`missing closing '\"'`)},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T){\n\t\t\tkey, value, err := parseRawString(tt.input)\n\n\t\t\tif err != nil {\n\t\t\t\tif tt.err == nil {\n\t\t\t\t\tt.Errorf(\"Expected no error, got %v\", err)\n\t\t\t\t} else if err.Error() != tt.err.Error() {\n\t\t\t\t\tt.Errorf(\"Expected error %q, got %q\", tt.err, err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif tt.err != nil {\n\t\t\t\tt.Errorf(\"Expected error %q, got nil\", tt.err)\n\t\t\t}\n\t\t\tif key != tt.key {\n\t\t\t\tt.Errorf(\"Expected key %q, got %q\", tt.key, key)\n\t\t\t}\n\t\t\tif value != tt.value {\n\t\t\t\tt.Errorf(\"Expected value %q, got %q\", tt.value, value)\n\t\t\t}\n\t\t})\n\t\t\n\t}\n}","e3b625c10b9083a177ee75bf2554ab5a":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput       string\n\t\twantValue   *Value\n\t\twantTail    string\n\t\twantErr     bool\n\t\twantErrText string\n\t}{\n\t\t// Empty array\n\t\t{\n\t\t\tinput:       \"[]\",\n\t\t\twantValue:   \u0026Value{t: TypeArray, a: []*Value{}},\n\t\t\twantTail:    \"\",\n\t\t\twantErr:     false,\n\t\t\twantErrText: \"\",\n\t\t},\n\t\t// Simple array\n\t\t{\n\t\t\tinput:     \"[1,2,3]\",\n\t\t\twantValue: \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}},\n\t\t\twantTail:  \"\",\n\t\t\twantErr:   false,\n\t\t},\n\t\t// Array with different types\n\t\t{\n\t\t\tinput:     \"[1, \\\"hello\\\", true, null]\",\n\t\t\twantValue: \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeString, s: \"hello\"}, {t: TypeTrue}, {t: TypeNull}}},\n\t\t\twantTail:  \"\",\n\t\t\twantErr:   false,\n\t\t},\n\t\t// Array with nested array\n\t\t{\n\t\t\tinput:     \"[1, [2, 3], 4]\",\n\t\t\twantValue: \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeArray, a: []*Value{{t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}}, {t: TypeNumber, s: \"4\"}}},\n\t\t\twantTail:  \"\",\n\t\t\twantErr:   false,\n\t\t},\n\t\t// Array with whitespace\n\t\t{\n\t\t\tinput:     \" [ 1 , 2 , 3 ] \",\n\t\t\twantValue: \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}},\n\t\t\twantTail:  \" \",\n\t\t\twantErr:   false,\n\t\t},\n\t\t// Invalid array: missing closing bracket\n\t\t{\n\t\t\tinput:       \"[1, 2, 3\",\n\t\t\twantValue:   nil,\n\t\t\twantTail:    \"\",\n\t\t\twantErr:     true,\n\t\t\twantErrText: \"unexpected end of array\",\n\t\t},\n\t\t// Invalid array: missing comma\n\t\t{\n\t\t\tinput:       \"[1 2 3]\",\n\t\t\twantValue:   nil,\n\t\t\twantTail:    \"2 3]\",\n\t\t\twantErr:     true,\n\t\t\twantErrText: \"missing ',' after array value\",\n\t\t},\n\t\t// Invalid array: trailing comma\n\t\t{\n\t\t\tinput:       \"[1, 2, 3,]\",\n\t\t\twantValue:   nil,\n\t\t\twantTail:    \"\",\n\t\t\twantErr:     true,\n\t\t\twantErrText: \"cannot parse array value: unexpected end of JSON\",\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgotValue, gotTail, gotErr := parseArray(tt.input, c, 0)\n\n\t\t\tif (gotErr != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", gotErr, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotErr != nil \u0026\u0026 tt.wantErrText != \"\" \u0026\u0026 gotErr.Error() != tt.wantErrText {\n\t\t\t\tt.Errorf(\"parseArray() error text = %v, want error text %v\", gotErr.Error(), tt.wantErrText)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseArray() gotTail = %v, want %v\", gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif !equalValues(gotValue, tt.wantValue) {\n\t\t\t\tt.Errorf(\"parseArray() gotValue = %v, want %v\", gotValue, tt.wantValue)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.s != v2.s {\n\t\treturn false\n\t}\n\tif len(v1.a) != len(v2.a) {\n\t\treturn false\n\t}\n\tfor i := range v1.a {\n\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","e3eb0620aefa4f7a91429e17a5df1d87":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic strings\n\t\t{\"hello\", \"hello\"},\n\t\t{\"world\", \"world\"},\n\n\t\t// Escaped characters\n\t\t{`\\\"`, `\"`},\n\t\t{`\\\\`, `\\`},\n\t\t{`\\/`, `/`},\n\t\t{`\\b`, \"\\b\"},\n\t\t{`\\f`, \"\\f\"},\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\r`, \"\\r\"},\n\t\t{`\\t`, \"\\t\"},\n\n\t\t// Unicode escape sequences\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A9`, \"¬©\"},\n\t\t{`\\u20AC`, \"‚Ç¨\"},\n\t\t{`\\uD83D\\uDE02`, \"üòÇ\"}, // Surrogate pair\n\n\t\t// Invalid escape sequences\n\t\t{`\\u`, `\\u`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\uxyz`, `\\uxyz`},\n\t\t{`\\uD800`, `\\uD800`}, // Invalid surrogate pair\n\t\t{`\\uD800\\u`, `\\uD800\\u`},\n\n\t\t// Mixed strings\n\t\t{`hello\\world`, `hello\\world`},\n\t\t{`\"quoted string\"`, `\"quoted string\"`},\n\t\t{`\\u0041\\u0020\\u0073\\u0074\\u0072\\u0069\\u006e\\u0067`, \"A string\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}","e3f590dbf2ba58be97e9c05ed05fbb1a":"package fastjson\n\nimport \"testing\"\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tt    Type\n\t\twant string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.want, func(t *testing.T) {\n\t\t\tif got := tt.t.String(); got != tt.want {\n\t\t\t\tt.Errorf(\"Type.String() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","e51e94608dd11bf35b4e80233aad4416":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tv        *Value\n\t\texpected []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\texpected: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"name\", v: \u0026Value{t: TypeString, s: \"Alice\"}},\n\t\t\t\t\t\t{k: \"age\", v: \u0026Value{t: TypeNumber, s: \"30\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: []byte(`{\"name\":\"Alice\",\"age\":30}`),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"apple\"},\n\t\t\t\t\t{t: TypeNumber, s: \"10\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: []byte(`[\"apple\",10,true]`),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"world\",\n\t\t\t},\n\t\t\texpected: []byte(`\"world\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"12345\",\n\t\t\t},\n\t\t\texpected: []byte(`12345`),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\texpected: []byte(`true`),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\texpected: []byte(`false`),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\texpected: []byte(`null`),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tactual := tt.v.MarshalTo(nil)\n\t\t\tif string(actual) != string(tt.expected) {\n\t\t\t\tt.Errorf(\"Expected %s, but got %s\", tt.expected, actual)\n\t\t\t}\n\t\t})\n\t}\n}","e5485be886fbf998b404fd9392355eb6":"package fastjson\n\nimport \"testing\"\n\nfunc TestValue_GetFloat64(t *testing.T) {\n\tvar v Value\n\ttests := []struct {\n\t\tname  string\n\t\tjson  string\n\t\tkeys  []string\n\t\twant  float64\n\t\twant1 bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty\",\n\t\t\tjson:  `{}`,\n\t\t\tkeys:  []string{\"nonexisting\"},\n\t\t\twant:  0,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"number\",\n\t\t\tjson:  `{\"key\":123.456}`,\n\t\t\tkeys:  []string{\"key\"},\n\t\t\twant:  123.456,\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"string\",\n\t\t\tjson:  `{\"key\":\"123.456\"}`,\n\t\t\tkeys:  []string{\"key\"},\n\t\t\twant:  123.456,\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array\",\n\t\t\tjson:  `{\"key\":[1, 123.456, 3]}`,\n\t\t\tkeys:  []string{\"key\", \"1\"},\n\t\t\twant:  123.456,\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array decimal key\",\n\t\t\tjson:  `{\"key\":[1, 123.456, 3]}`,\n\t\t\tkeys:  []string{\"key\", \"1.0\"},\n\t\t\twant:  123.456,\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"nested\",\n\t\t\tjson:  `{\"key1\":{\"key2\":[1, 123.456, 3]}}`,\n\t\t\tkeys:  []string{\"key1\", \"key2\", \"1\"},\n\t\t\twant:  123.456,\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"invalid\",\n\t\t\tjson:  `{\"key\":\"foobar\"}`,\n\t\t\tkeys:  []string{\"key\"},\n\t\t\twant:  0,\n\t\t\twant1: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv.Parse(tt.json)\n\t\t\tgot := v.GetFloat64(tt.keys...)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"GetFloat64() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","e5859f88ecff2e15e312b6c54fde32c3":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t// TODO: Add test cases.\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"1234\",\n\t\t\t},\n\t\t\twant: []byte(\"1234\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif string(got) != string(tt.want) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %v, want %v\", string(got), string(tt.want))\n\t\t\t}\n\t\t})\n\t}\n}","e59539ec2cf73eea40662f8b045e72c5":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_Visit(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\to    *Object\n\t\twant map[string]string\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\to:    \u0026Object{},\n\t\t\twant: map[string]string{},\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\to: \u0026Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: map[string]string{\n\t\t\t\t\"key1\": \"value1\",\n\t\t\t\t\"key2\": \"value2\",\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := make(map[string]string)\n\t\t\ttt.o.Visit(func(key []byte, v *Value) {\n\t\t\t\tif v.Type() == TypeString {\n\t\t\t\t\tgot[string(key)] = v.s\n\t\t\t\t}\n\t\t\t})\n\t\t\tif len(got) != len(tt.want) {\n\t\t\t\tt.Errorf(\"Visit() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tfor k, v := range tt.want {\n\t\t\t\tif got[k] != v {\n\t\t\t\t\tt.Errorf(\"Visit() got = %v, want %v\", got, tt.want)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n","e68dfded8d2b26a44da71ff5e78c83dd":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantNum  string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Valid numbers\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"123.456\", \"123.456\", \"\", nil},\n\t\t{\"1.2e3\", \"1.2e3\", \"\", nil},\n\t\t{\"1.2E-3\", \"1.2E-3\", \"\", nil},\n\t\t{\"+123\", \"+123\", \"\", nil},\n\n\t\t// Valid numbers with trailing characters\n\t\t{\"123a\", \"123\", \"a\", nil},\n\t\t{\"-123!\", \"-123\", \"!\", nil},\n\t\t{\"123.456,\", \"123.456\", \",\", nil},\n\n\t\t// Invalid numbers\n\t\t{\"a123\", \"\", \"a123\", fmt.Errorf(\"unexpected char: %q\", \"a1\")},\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t\t{\"-\", \"\", \"-\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t\t{\"+\", \"\", \"+\", fmt.Errorf(\"unexpected char: %q\", \"+\")},\n\n\t\t// Special cases: inf, nan\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"+inf\", \"+inf\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"InF\", \"InF\", \"\", nil}, // Case-insensitive\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"+nan\", \"+nan\", \"\", nil},\n\t\t{\"-nan\", \"-nan\", \"\", nil},\n\t\t{\"nAn\", \"nAn\", \"\", nil}, // Case-insensitive\n\n\t\t// Special cases with trailing characters\n\t\t{\"inf,\", \"inf\", \",\", nil},\n\t\t{\"nan}\", \"nan\", \"}\", nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tgotNum, gotTail, gotErr := parseRawNumber(tt.input)\n\t\t\tif gotNum != tt.wantNum {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got number = %q, want %q\", tt.input, gotNum, tt.wantNum)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got tail = %q, want %q\", tt.input, gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif gotErr == nil \u0026\u0026 tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got no error, want error %v\", tt.input, tt.wantErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr == nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got error = %v, want no error\", tt.input, gotErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got error = %v, want error %v\", tt.input, gotErr, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","e6b2976f720156be6211fd77b2f75c07":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"raw string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"raw string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"1234\",\n\t\t\t},\n\t\t\twant: []byte(\"1234\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"string\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1234\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"[\\\"string\\\",1234]\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo([]byte{})\n\t\t\tif string(got) != string(tt.want) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","e6cb490bb2c0d83ed347c3d9f08ba14a":"package fastjson\n\nimport \"testing\"\n\nfunc TestSkipWS(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"  foo\", \"foo\"},\n\t\t{\"\\n\\tbar\", \"bar\"},\n\t\t{\"baz  \", \"baz  \"},\n\t\t{\"\", \"\"},\n\t\t{\"\\x00qux\", \"\\x00qux\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := skipWS(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"skipWS(%q) = %q, want %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}","e7400b10fb6d7115b93dba7c2dfd9129":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc Test_unescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello world\",\n\t\t\t},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"simple escape\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello\\\\tworld\",\n\t\t\t},\n\t\t\twant: \"hello\\tworld\",\n\t\t},\n\t\t{\n\t\t\tname: \"unicode escape\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello\\\\u0020world\",\n\t\t\t},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid unicode escape\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello\\\\u002 world\",\n\t\t\t},\n\t\t\twant: \"hello\\\\u002 world\",\n\t\t},\n\t\t{\n\t\t\tname: \"truncated unicode escape\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello\\\\u002\",\n\t\t\t},\n\t\t\twant: \"hello\\\\u002\",\n\t\t},\n\t\t{\n\t\t\tname: \"surrogate pair escape\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello\\\\uD83D\\\\uDE02world\",\n\t\t\t},\n\t\t\twant: \"helloüòÇworld\",\n\t\t},\n\t\t{\n\t\t\tname: \"truncated surrogate pair escape\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello\\\\uD83D\\\\uDE0\",\n\t\t\t},\n\t\t\twant: \"hello\\\\uD83D\\\\uDE0\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","e74702fd6fc7d1ac731ed0c5591cd278":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantJSON string\n\t\twantErr  error\n\t}{\n\t\t{\n\t\t\tname:     \"empty object\",\n\t\t\tinput:    \"{}\",\n\t\t\twantJSON: `{}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"simple object\",\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 123}`,\n\t\t\twantJSON: `{\"key1\": \"value1\", \"key2\": 123}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"nested object\",\n\t\t\tinput:    `{\"key1\": {\"key2\": \"value2\"}, \"key3\": [1,2,3]}`,\n\t\t\twantJSON: `{\"key1\": {\"key2\": \"value2\"}, \"key3\": [1, 2, 3]}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"escaped characters\",\n\t\t\tinput:    `{\"key1\": \"value with \\n newline and \\t tab\", \"key2\": \"value with \\\\ backslash\"}`,\n\t\t\twantJSON: `{\"key1\": \"value with \\n newline and \\t tab\", \"key2\": \"value with \\\\ backslash\"}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing closing brace\",\n\t\t\tinput:    `{\"key1\": \"value1\"`,\n\t\t\twantErr: fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"missing colon\",\n\t\t\tinput:    `{\"key1\" \"value1\"}`,\n\t\t\twantErr: fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"missing comma\",\n\t\t\tinput:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid key\",\n\t\t\tinput:    `{123: \"value1\"}`,\n\t\t\twantErr: fmt.Errorf(\"cannot parse object key: cannot find opening '\\\"' for object key\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseObject(tt.input, c, 0)\n\t\t\tif tt.wantErr != nil {\n\t\t\t\tif err == nil || err.Error() != tt.wantErr.Error() {\n\t\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr nil\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif s != \"\" {\n\t\t\t\tt.Errorf(\"parseObject() remaining string = %v, want empty string\", s)\n\t\t\t}\n\t\t\tgotJSON := got.MarshalTo(nil)\n\t\t\tif string(gotJSON) != tt.wantJSON {\n\t\t\t\tt.Errorf(\"parseObject() = %s, want %s\", gotJSON, tt.wantJSON)\n\t\t\t}\n\t\t})\n\t}\n}\n","e7490200a8c15ff50bab2c7d5fde9cac":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t\tremain   string\n\t\twantErr  error\n\t}{\n\t\t// Basic strings\n\t\t{`\"hello\"`, `hello`, ``, nil},\n\t\t{`\"hello world\"`, `hello world`, ``, nil},\n\n\t\t// Empty string\n\t\t{`\"\"`, ``, ``, nil},\n\n\t\t// Strings with escaped quotes\n\t\t{`\"hello \\\"world\\\"\"`, `hello \"world\"`, ``, nil},\n\t\t{`\"hello\\\\\"world\"`, `hello\\`, `world\"`, nil},\n\t\t{`\"hello\\\\\\\\\"world\"`, `hello\\\\world`, ``, nil},\n\n\t\t// Invalid strings\n\t\t{`\"hello`, ``, ``, fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"hello\"world\"`, `hello`, `world\"`, nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test %d\", i), func(t *testing.T) {\n\t\t\tactual, remain, err := parseRawString(tt.input)\n\t\t\tif tt.wantErr != nil {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"Expected error %v, but got nil\", tt.wantErr)\n\t\t\t\t} else if err.Error() != tt.wantErr.Error() {\n\t\t\t\t\tt.Errorf(\"Expected error %v, but got %v\", tt.wantErr, err)\n\t\t\t\t}\n\t\t\t} else if err != nil {\n\t\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t\t} else {\n\t\t\t\tif actual != tt.expected {\n\t\t\t\t\tt.Errorf(\"Expected %q, but got %q\", tt.expected, actual)\n\t\t\t\t}\n\t\t\t\tif remain != tt.remain {\n\t\t\t\t\tt.Errorf(\"Expected remaining %q, but got %q\", tt.remain, remain)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","e783a3e5d0076d408007be0cbdc07566":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_reset(t *testing.T) {\n\to := Object{\n\t\tkvs: []kv{\n\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t},\n\t\tkeysUnescaped: true,\n\t}\n\n\to.reset()\n\n\tif len(o.kvs) != 0 {\n\t\tt.Errorf(\"Expected kvs to be empty after reset, got %v\", o.kvs)\n\t}\n\n\tif o.keysUnescaped != false {\n\t\tt.Errorf(\"Expected keysUnescaped to be false after reset, got %v\", o.keysUnescaped)\n\t}\n}\n","e7853b1995be2a7e0f2c932045cca477":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    string\n\t\twant *Value\n\t\twantTail string\n\t\twantErr error\n\t}{\n\t\t// Empty string\n\t\t{\n\t\t\tname: \"EmptyString\",\n\t\t\ts:    \"\",\n\t\t\twant: nil,\n\t\t\twantTail: \"\",\n\t\t\twantErr: fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t// Object\n\t\t{\n\t\t\tname: \"Object\",\n\t\t\ts:    `{\"key\": \"value\"}`,\n\t\t\twant: \u0026Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: \u0026Value{t: typeRawString, s: \"value\"}},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\twantTail: \"\",\n\t\t\twantErr: nil,\n\t\t},\n\t\t// Array\n\t\t{\n\t\t\tname: \"Array\",\n\t\t\ts:    `[1, \"test\"]`,\n\t\t\twant: \u0026Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: typeRawString, s: \"test\"},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\twantTail: \"\",\n\t\t\twantErr: nil,\n\t\t},\n\t\t// String\n\t\t{\n\t\t\tname: \"String\",\n\t\t\ts:    `\"test\"`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"test\",\n\t\t\t},\n\t\t\twantTail: \"\",\n\t\t\twantErr: nil,\n\t\t},\n\t\t// True\n\t\t{\n\t\t\tname: \"True\",\n\t\t\ts:    \"true\",\n\t\t\twant: valueTrue,\n\t\t\twantTail: \"\",\n\t\t\twantErr: nil,\n\t\t},\n\t\t// False\n\t\t{\n\t\t\tname: \"False\",\n\t\t\ts:    \"false\",\n\t\t\twant: valueFalse,\n\t\t\twantTail: \"\",\n\t\t\twantErr: nil,\n\t\t},\n\t\t// Null\n\t\t{\n\t\t\tname: \"Null\",\n\t\t\ts:    \"null\",\n\t\t\twant: valueNull,\n\t\t\twantTail: \"\",\n\t\t\twantErr: nil,\n\t\t},\n\t\t// NaN\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\ts:    \"NaN\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twantTail: \"\",\n\t\t\twantErr: nil,\n\t\t},\n\t\t// Number\n\t\t{\n\t\t\tname: \"Number\",\n\t\t\ts:    \"123.45\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123.45\",\n\t\t\t},\n\t\t\twantTail: \"\",\n\t\t\twantErr: nil,\n\t\t},\n\t\t// Trailing space\n\t\t{\n\t\t\tname: \"TrailingSpace\",\n\t\t\ts:    `\"test\" `,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"test\",\n\t\t\t},\n\t\t\twantTail: \" \",\n\t\t\twantErr: nil,\n\t\t},\n\t\t// Invalid JSON\n\t\t{\n\t\t\tname: \"InvalidJSON\",\n\t\t\ts:    \"invalid\",\n\t\t\twant: nil,\n\t\t\twantTail: \"invalid\",\n\t\t\twantErr: fmt.Errorf(\"cannot parse object: cannot parse empty string\"),\n\t\t},\n\t}\n\n\tc := \u0026cache{}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, tail, err := parseValue(tt.s, c, 0)\n\t\t\tif fmt.Sprintf(\"%v\", err) != fmt.Sprintf(\"%v\", tt.wantErr) {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif tail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseValue() tail = %v, wantTail %v\", tail, tt.wantTail)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif got == nil \u0026\u0026 tt.want == nil {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif got.t != tt.want.t {\n\t\t\t\tt.Errorf(\"parseValue() got type = %v, want %v\", got.t, tt.want.t)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif got.s != tt.want.s {\n\t\t\t\tt.Errorf(\"parseValue() got string = %v, want %v\", got.s, tt.want.s)\n\t\t\t}\n\t\t})\n\t}\n}\n","e83bb0b3a53e8c49660f6e11d35138f1":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ts     string\n\t\terr   error\n\t}{\n\t\t// Empty object\n\t\t{\n\t\t\tinput: `{}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Single key-value pair\n\t\t{\n\t\t\tinput: `{\"key\": \"value\"}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: \u0026Value{t: TypeString, s: \"value\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Multiple key-value pairs\n\t\t{\n\t\t\tinput: `{\"key1\": \"value1\", \"key2\": 123, \"key3\": true}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t\t{k: \"key3\", v: \u0026Value{t: TypeTrue}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Nested object\n\t\t{\n\t\t\tinput: `{\"key1\": {\"key2\": \"value2\"}, \"key3\": \"value3\"}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{k: \"key3\", v: \u0026Value{t: TypeString, s: \"value3\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Missing closing brace\n\t\t{\n\t\t\tinput: `{\"key\": \"value\"`,\n\t\t\twant:  nil,\n\t\t\ts:     `{\"key\": \"value\"`,\n\t\t\terr:   fmt.Errorf(`missing '}'`),\n\t\t},\n\t\t// Missing colon\n\t\t{\n\t\t\tinput: `{\"key\" \"value\"}`,\n\t\t\twant:  nil,\n\t\t\ts:     `\"value\"}`,\n\t\t\terr:   fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t\t// Missing comma\n\t\t{\n\t\t\tinput: `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twant:  nil,\n\t\t\ts:     `\"key2\": \"value2\"}`,\n\t\t\terr:   fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\t\t// Invalid key\n\t\t{\n\t\t\tinput: `{123: \"value\"}`,\n\t\t\twant:  nil,\n\t\t\ts:     `123: \"value\"}`,\n\t\t\terr:   fmt.Errorf(`cannot find opening '\"\" for object key`),\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseObject(tt.input, c, 0)\n\t\t\tif fmt.Sprintf(\"%v\", err) != fmt.Sprintf(\"%v\", tt.err) {\n\t\t\t\tt.Errorf(\"expected error %v, got %v\", tt.err, err)\n\t\t\t}\n\t\t\tif s != tt.s {\n\t\t\t\tt.Errorf(\"expected remaining string %q, got %q\", tt.s, s)\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"expected value %v, got %v\", tt.want, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\treturn true\n\t}\n}\n","e897c35ec322a812216cfd3f5ff03ffd":"package fastjson\n\nimport \"testing\"\n\nfunc TestValue_GetInt(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tjson  string\n\t\tkeys  []string\n\t\twant  int\n\t\twant1 bool\n\t}{\n\t\t{\n\t\t\tname:  \"simple\",\n\t\t\tjson:  `{\"foo\":123}`,\n\t\t\tkeys:  []string{\"foo\"},\n\t\t\twant:  123,\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"nested\",\n\t\t\tjson:  `{\"foo\":{\"bar\":123}}`,\n\t\t\tkeys:  []string{\"foo\", \"bar\"},\n\t\t\twant:  123,\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array\",\n\t\t\tjson:  `{\"foo\":[123,456]}`,\n\t\t\tkeys:  []string{\"foo\", \"1\"},\n\t\t\twant:  456,\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array decimal\",\n\t\t\tjson:  `{\"foo\":[123,456]}`,\n\t\t\tkeys:  []string{\"foo\", \"1.0\"},\n\t\t\twant:  456,\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"non-existing key\",\n\t\t\tjson:  `{\"foo\":123}`,\n\t\t\tkeys:  []string{\"bar\"},\n\t\t\twant:  0,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"invalid value type\",\n\t\t\tjson:  `{\"foo\":\"bar\"}`,\n\t\t\tkeys:  []string{\"foo\"},\n\t\t\twant:  0,\n\t\t\twant1: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tvar p Parser\n\t\t\tv, err := p.Parse(tt.json)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Parse() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgot := v.GetInt(tt.keys...)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"GetInt() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","ea1af124e3f14fce95ff74dac77cb87e":"package fastjson\n\nimport \"testing\"\n\nfunc TestObject_getKV(t *testing.T) {\n\to := Object{}\n\t// Test adding a kv to an empty object\n\tkv1 := o.getKV()\n\tif kv1 == nil {\n\t\tt.Errorf(\"Expected a non-nil kv, got nil\")\n\t}\n\tif len(o.kvs) != 1 {\n\t\tt.Errorf(\"Expected object to have 1 kv, got %d\", len(o.kvs))\n\t}\n\n\t// Test adding another kv\n\tkv2 := o.getKV()\n\tif kv2 == nil {\n\t\tt.Errorf(\"Expected a non-nil kv, got nil\")\n\t}\n\tif len(o.kvs) != 2 {\n\t\tt.Errorf(\"Expected object to have 2 kvs, got %d\", len(o.kvs))\n\t}\n\n\t// Test reusing existing capacity\n\to.kvs = o.kvs[:1]\n\tkv3 := o.getKV()\n\tif kv3 == nil {\n\t\tt.Errorf(\"Expected a non-nil kv, got nil\")\n\t}\n\tif len(o.kvs) != 2 {\n\t\tt.Errorf(\"Expected object to have 2 kvs, got %d\", len(o.kvs))\n\t}\n}\n","eb071f816583aa7cfc1e96a4582d81f2":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantN    string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"123.45\", \"123.45\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"-123.45\", \"-123.45\", \"\", nil},\n\t\t{\"123e4\", \"123e4\", \"\", nil},\n\t\t{\"123e-4\", \"123e-4\", \"\", nil},\n\t\t{\"123E4\", \"123E4\", \"\", nil},\n\t\t{\"123E-4\", \"123E-4\", \"\", nil},\n\t\t{\"+123\", \"+123\", \"\", nil},\n\t\t{\"+123.45\", \"+123.45\", \"\", nil},\n\t\t{\"+123e4\", \"+123e4\", \"\", nil},\n\t\t{\"+123e-4\", \"+123e-4\", \"\", nil},\n\t\t{\"+123E4\", \"+123E4\", \"\", nil},\n\t\t{\"+123E-4\", \"+123E-4\", \"\", nil},\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"+inf\", \"+inf\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"Inf\", \"Inf\", \"\", nil},\n\t\t{\"+Inf\", \"+Inf\", \"\", nil},\n\t\t{\"-Inf\", \"-Inf\", \"\", nil},\n\t\t{\"in\", \"\", \"in\", fmt.Errorf(`unexpected char: \"i\"`)},\n\t\t{\"+i\", \"\", \"+i\", fmt.Errorf(`unexpected char: \"+\"`)},\n\t\t{\"-i\", \"\", \"-i\", fmt.Errorf(`unexpected char: \"-\"`)},\n\t\t{\"123a\", \"123\", \"a\", nil},\n\t\t{\"123.45a\", \"123.45\", \"a\", nil},\n\t\t{\"-123a\", \"-123\", \"a\", nil},\n\t\t{\"-123.45a\", \"-123.45\", \"a\", nil},\n\t\t{\"infnity\", \"inf\", \"nity\", nil},\n\t\t{\"+infnity\", \"+inf\", \"nity\", nil},\n\t\t{\"-infnity\", \"-inf\", \"nity\", nil},\n\t\t{\"Infinity\", \"Inf\", \"inity\", nil},\n\t\t{\"+Infinity\", \"+Inf\", \"inity\", nil},\n\t\t{\"-Infinity\", \"-Inf\", \"inity\", nil},\n\t\t{\"NaN\", \"NaN\", \"\", nil},\n\t\t{\"+NaN\", \"+NaN\", \"\", nil},\n\t\t{\"-NaN\", \"-NaN\", \"\", nil},\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"+nan\", \"+nan\", \"\", nil},\n\t\t{\"-nan\", \"-nan\", \"\", nil},\n\t}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test %d\", i), func(t *testing.T) {\n\t\t\tgotN, gotTail, gotErr := parseRawNumber(tt.input)\n\t\t\tif gotN != tt.wantN {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) n = %q, want %q\", tt.input, gotN, tt.wantN)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) tail = %q, want %q\", tt.input, gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif gotErr == nil \u0026\u0026 tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = nil, want %v\", tt.input, tt.wantErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr == nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, want nil\", tt.input, gotErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, want %v\", tt.input, gotErr, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","eb0bed6b248796ac2aa5e59b1e4f4066":"package fastjson\n\nimport \"testing\"\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tt    Type\n\t\twant string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\tfor i, tt := range tests {\n\t\tgot := tt.t.String()\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"test[%d]: String() = %q, want %q\", i, got, tt.want)\n\t\t}\n\t}\n}\n","eb2f7a09786ed520e3c0026730fb8e56":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"RawString\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"raw string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"raw string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"String\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"Number\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"12345\",\n\t\t\t},\n\t\t\twant: []byte(\"12345\"),\n\t\t},\n\t\t{\n\t\t\tname: \"True\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"False\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"Null\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif string(got) != string(tt.want) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","eb885289b7d2fd99a584dd8528e7a597":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantKey  string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Empty string.\n\t\t{\"\", \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\n\t\t// Non-empty string without quotes.\n\t\t{\"hello\", \"hello\", \"\", nil},\n\n\t\t// Simple string with quotes.\n\t\t{`\"hello\"world`, \"hello\", \"world\", nil},\n\n\t\t// String with escaped quotes.\n\t\t{`\"he\\\"llo\"world`, `he\"llo`, \"world\", nil},\n\n\t\t// String with multiple escaped quotes.\n\t\t{`\"he\\\"ll\\\"o\"world`, `he\"ll\"o`, \"world\", nil},\n\n\t\t// String with escaped backslashes and quotes.\n\t\t{`\"he\\\\\\\\\\\\\\\"llo\"world`, `he\\\\\\llo`, \"world\", nil},\n\n\t\t// String with closing quote in the middle.\n\t\t{`\"hello\"world\"`, `hello`, `world\"`, nil},\n\n\t\t// String with missing closing quote.\n\t\t{`\"hello`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\n\t\t// String with escaped closing quote at the end.\n\t\t{`\"hello\\\"`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test #%d: %s\", i, tt.input)), func(t *testing.T) {\n\t\t\tgotKey, gotTail, gotErr := parseRawString(tt.input)\n\n\t\t\tif gotKey != tt.wantKey {\n\t\t\t\tt.Errorf(\"Key mismatch.\\nInput: %s\\nWant: %s\\nGot: %s\", tt.input, tt.wantKey, gotKey)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"Tail mismatch.\\nInput: %s\\nWant: %s\\nGot: %s\", tt.input, tt.wantTail, gotTail)\n\t\t\t}\n\t\t\tif gotErr != nil \u0026\u0026 tt.wantErr == nil || gotErr == nil \u0026\u0026 tt.wantErr != nil || gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"Error mismatch.\\nInput: %s\\nWant: %v\\nGot: %v\", tt.input, tt.wantErr, gotErr)\n\t\t\t}\n\t\t}\n\t}\n}\n","ebf2cbcce69e6375a3f5bae521ef8b70":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantNum  string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"123.456\", \"123.456\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"123e+456\", \"123e+456\", \"\", nil},\n\t\t{\"123E-456\", \"123E-456\", \"\", nil},\n\t\t{\"123.456e+789\", \"123.456e+789\", \"\", nil},\n\t\t{\"123abc\", \"123\", \"abc\", nil},\n\t\t{\"+123\", \"+123\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"+123abc\", \"+123\", \"abc\", nil},\n\t\t{\"-123abc\", \"-123\", \"abc\", nil},\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"+inf\", \"+inf\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"infin\", \"inf\", \"in\", nil},\n\t\t{\"+infin\", \"+inf\", \"in\", nil},\n\t\t{\"-infin\", \"-inf\", \"in\", nil},\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"+nan\", \"\", \"+nan\", fmt.Errorf(\"unexpected char: %q\", \"+\")},\n\t\t{\"-nan\", \"\", \"-nan\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t\t{\"nana\", \"nan\", \"a\", nil},\n\t\t{\"\", \"\", \"\", nil},\n\t}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tgotNum, gotTail, gotErr := parseRawNumber(tt.input)\n\t\t\tif gotNum != tt.wantNum {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) gotNum = %q, want %q\", tt.input, gotNum, tt.wantNum)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) gotTail = %q, want %q\", tt.input, gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif gotErr == nil \u0026\u0026 tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) gotErr = nil, want error %v\", tt.input, tt.wantErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr == nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) gotErr = %v, want nil\", tt.input, gotErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) gotErr = %v, want error %v\", tt.input, gotErr, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","ebf877e63e90ebbf0504c5ddb8afea58":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\ttests := []struct {\n\t\tinput    string\n\t\twantVal  *Value\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Empty string\n\t\t{\"\", nil, \"\", fmt.Errorf(\"cannot parse empty string\")},\n\t\t// Object\n\t\t{`{\"foo\":\"bar\"}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: typeRawString, s: \"bar\"}}}}}}, \"\", nil},\n\t\t// Array\n\t\t{`[1,2,3]`, \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}}, \"\", nil},\n\t\t// String\n\t\t{`\"hello\"`, \u0026Value{t: typeRawString, s: \"hello\"}, \"\", nil},\n\t\t// True\n\t\t{\"true\", valueTrue, \"\", nil},\n\t\t// False\n\t\t{\"false\", valueFalse, \"\", nil},\n\t\t// Null\n\t\t{\"null\", valueNull, \"\", nil},\n\t\t// NaN\n\t\t{\"NaN\", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"\", nil},\n\t\t// Number\n\t\t{\"123\", \u0026Value{t: TypeNumber, s: \"123\"}, \"\", nil},\n\t\t// Number with exponent\n\t\t{\"1.23e4\", \u0026Value{t: TypeNumber, s: \"1.23e4\"}, \"\", nil},\n\t\t// Negative number\n\t\t{\"-123\", \u0026Value{t: TypeNumber, s: \"-123\"}, \"\", nil},\n\t\t// Number with whitespace\n\t\t{\" 123 \", \u0026Value{t: TypeNumber, s: \"123\"}, \" \", nil},\n\t\t// Invalid value\n\t\t{\"invalid\", nil, \"invalid\", fmt.Errorf(\"unexpected value found: \\\"invalid\\\"\")},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tgotVal, gotTail, gotErr := parseValue(tt.input, c, 0)\n\t\t\tif gotErr != nil \u0026\u0026 tt.wantErr == nil {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", gotErr, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotErr == nil \u0026\u0026 tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", gotErr, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", gotErr, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseValue() tail = %v, want %v\", gotTail, tt.wantTail)\n\t\t\t}\n\n\t\t\tif !equalValues(gotVal, tt.wantVal) {\n\t\t\t\tt.Errorf(\"parseValue() value = %v, want %v\", gotVal, tt.wantVal)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.s != v2.s {\n\t\treturn false\n\t}\n\tif v1.t == TypeArray {\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t} else if v1.t == TypeObject {\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t}\n\treturn true\n}\n","ec026c231b0d836d21a262081a7a59a0":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetObject(t *testing.T) {\n\tt.Run(\"simple object\", func(t *testing.T) {\n\t\tv, _ := Parse(`{\"foo\": {\"bar\": 123}}`)\n\t\to := v.GetObject(\"foo\")\n\t\tif o == nil {\n\t\t\tt.Fatalf(\"GetObject() returned nil for existing object\")\n\t\t}\n\t\tif o.Len() != 1 {\n\t\t\tt.Fatalf(\"Unexpected object length: %d. Expecting 1\", o.Len())\n\t\t}\n\t\tv = o.Get(\"bar\")\n\t\tif v == nil {\n\t\t\tt.Fatalf(\"Get() returned nil for existing value\")\n\t\t}\n\t\tif v.GetInt() != 123 {\n\t\t\tt.Fatalf(\"Unexpected value: %d. Expecting 123\", v.GetInt())\n\t\t}\n\t})\n\n\tt.Run(\"nested object\", func(t *testing.T) {\n\t\tv, _ := Parse(`{\"foo\": {\"bar\": {\"baz\": [1, 2, 3]}}}`)\n\t\to := v.GetObject(\"foo\", \"bar\")\n\t\tif o == nil {\n\t\t\tt.Fatalf(\"GetObject() returned nil for existing nested object\")\n\t\t}\n\t\tif o.Len() != 1 {\n\t\t\tt.Fatalf(\"Unexpected object length: %d. Expecting 1\", o.Len())\n\t\t}\n\t\tv = o.Get(\"baz\")\n\t\tif v == nil {\n\t\t\tt.Fatalf(\"Get() returned nil for existing value\")\n\t\t}\n\t\tif v.Type() != TypeArray {\n\t\t\tt.Fatalf(\"Unexpected value type: %s. Expecting TypeArray\", v.Type())\n\t\t}\n\t})\n\n\tt.Run(\"non-existing key\", func(t *testing.T) {\n\t\tv, _ := Parse(`{\"foo\": \"bar\"}`)\n\t\to := v.GetObject(\"baz\")\n\t\tif o != nil {\n\t\t\tt.Fatalf(\"GetObject() returned non-nil for non-existing key\")\n\t\t}\n\t})\n\n\tt.Run(\"invalid value type\", func(t *testing.T) {\n\t\tv, _ := Parse(`{\"foo\": 123}`)\n\t\to := v.GetObject(\"foo\")\n\t\tif o != nil {\n\t\t\tt.Fatalf(\"GetObject() returned non-nil for invalid value type\")\n\t\t}\n\t})\n\n\tt.Run(\"array index as key\", func(t *testing.T) {\n\t\tv, _ := Parse(`{\"foo\": [{\"bar\": 1}, {\"baz\": 2}]}`)\n\t\to := v.GetObject(\"foo\", \"1\")\n\t\tif o == nil {\n\t\t\tt.Fatalf(\"GetObject() returned nil for existing object at array index\")\n\t\t}\n\t\tif o.Len() != 1 {\n\t\t\tt.Fatalf(\"Unexpected object length: %d. Expecting 1\", o.Len())\n\t\t}\n\t\tv = o.Get(\"baz\")\n\t\tif v == nil {\n\t\t\tt.Fatalf(\"Get() returned nil for existing value\")\n\t\t}\n\t\tif v.GetInt() != 2 {\n\t\t\tt.Fatalf(\"Unexpected value: %d. Expecting 2\", v.GetInt())\n\t\t}\n\t})\n}","ecb9681ec50f26f5fdb26414aabd3121":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic escapes\n\t\t{`\\\\`, `\\`},\n\t\t{`\\/`, `/`},\n\t\t{`\\b`, \"\\b\"},\n\t\t{`\\f`, \"\\f\"},\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\r`, \"\\r\"},\n\t\t{`\\t`, \"\\t\"},\n\n\t\t// Unicode escapes\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A0`, \"\\u00A0\"},\n\t\t{`\\uFFFF`, \"\\uFFFF\"},\n\n\t\t// Surrogate pairs\n\t\t{`\\uD83D\\uDE01`, \"\\U0001F601\"},\n\n\t\t// Invalid escapes\n\t\t{`\\z`, `\\z`},\n\t\t{`\\u002`, `\\u002`},\n\t\t{`\\uD800`, `\\uD800`},\n\t\t{`\\uD83D\\uXXXX`, `\\uD83D\\uXXXX`},\n\n\t\t// Mixed content\n\t\t{`Hello\\tworld\\n`, \"Hello\\tworld\\n\"},\n\t\t{`\"This is a string with \\\\ escapes\"`, `\"This is a string with \\ escapes\"`},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tactual := unescapeStringBestEffort(tt.input)\n\t\t\tif actual != tt.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", tt.input, actual, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}","ed2bbe5d8b0addacee0007eb6c33fdd0":"package fastjson\n\nimport \"testing\"\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tt        Type\n\t\texpected string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\tfor i, tt := range tests {\n\t\tif got := tt.t.String(); got != tt.expected {\n\t\t\tt.Errorf(\"test %d: incorrect string representation - got: %q, want: %q\", i, got, tt.expected)\n\t\t}\n\t}\n}","ed60335579948b7d973b557c9487f30f":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestValue_Uint64(t *testing.T) {\n\tt.Parallel()\n\tvar v Value\n\tstr := \"1234567890123456789\"\n\tv.s = str\n\tv.t = TypeNumber\n\tu, err := v.Uint64()\n\trequire.NoError(t, err)\n\trequire.Equal(t, uint64(1234567890123456789), u)\n\n\tv.t = TypeString\n\t_, err = v.Uint64()\n\trequire.Error(t, err)\n\trequire.EqualError(t, err, fmt.Sprintf(\"value doesn't contain number; it contains %s\", v.Type()))\n}\n","ed7f1f9db9ebf8c730e6dec6ab9e2901":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\ts       string\n\t\twant    *Value\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tp := \u0026Parser{}\n\t\t\tgot, err := p.Parse(tt.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Parser.Parse() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\t// TODO: Compare got and tt.want\n\t\t\t\tt.Errorf(\"Parser.Parse() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","edc73e729f5fb16c77ddb02f2d62c7f4":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"raw string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"raw string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"12345\",\n\t\t\t},\n\t\t\twant: []byte(\"12345\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"string1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"12345\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"[\\\"string1\\\",12345]\"),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"string1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"12345\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"{\\\"key1\\\":\\\"string1\\\",\\\"key2\\\":12345}\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif string(got) != string(tt.want) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %v, want %v\", string(got), string(tt.want))\n\t\t\t}\n\t\t})\n\t}\n}\n","ee281fd673e0e5921d985e16d66274ec":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic escapes\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\t`, \"\\t\"},\n\t\t{`\\\\`, \"\\\\\"},\n\t\t{`\\\"`, \"\\\"\"},\n\t\t{`\\/`, \"/\"},\n\t\t{`\\b`, \"\\b\"},\n\t\t{`\\f`, \"\\f\"},\n\t\t{`\\r`, \"\\r\"},\n\n\t\t// Unicode escapes\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A9`, \"¬©\"},\n\t\t{`\\u20AC`, \"‚Ç¨\"},\n\t\t{`\\uD83D\\uDE02`, \"üòÇ\"}, // Surrogate pair\n\n\t\t// Invalid escapes\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u00A`, `\\u00A`},\n\t\t{`\\uD800`, `\\uD800`}, // Unpaired surrogate\n\t\t{`\\uD800\\u`, `\\uD800\\u`},\n\t\t{`\\uD800\\uD800`, `\\uD800\\uD800`}, // Two high surrogates\n\n\t\t// Mixed\n\t\t{`Hello\\tworld\\n`, \"Hello\\tworld\\n\"},\n\t\t{`\"This is a \\\\\\\"quoted\\\\\\\" string\"`, \"\\\"This is a \\\\\\\"quoted\\\\\\\" string\\\"\"},\n\t\t{`\\u0041\\u0020\\u0073\\u0074\\u0072\\u0069\\u006e\\u0067`, \"A string\"},\n\t}\n\n\tfor i, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Test %d: Expected %q, got %q\", i, test.expected, actual)\n\t\t}\n\t}\n}","efa4903c7248777618b60131d2acc577":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic strings\n\t\t{\"hello\", \"hello\"},\n\t\t{\"world\", \"world\"},\n\n\t\t// Escaped characters\n\t\t{`\\\"`, `\"`},\n\t\t{`\\\\`, `\\`},\n\t\t{`\\/`, `/`},\n\t\t{`\\b`, \"\\b\"},\n\t\t{`\\f`, \"\\f\"},\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\r`, \"\\r\"},\n\t\t{`\\t`, \"\\t\"},\n\n\t\t// Unicode escape sequences\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A9`, \"¬©\"},\n\t\t{`\\u20AC`, \"‚Ç¨\"},\n\t\t{`\\uD83D\\uDE02`, \"üòÇ\"}, // Surrogate pair\n\n\t\t// Invalid escape sequences\n\t\t{`\\u`, `\\u`},\n\t\t{`\\u002`, `\\u002`},\n\t\t{`\\uD83D`, `\\uD83D`},\n\t\t{`\\uD83D\\u`, `\\uD83D\\u`},\n\n\t\t// Mixed strings\n\t\t{`hello\\tworld`, \"hello\\tworld\"},\n\t\t{`\"quoted string\"`, `\"quoted string\"`},\n\t\t{`with\\\\backslashes`, `with\\\\backslashes`},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}\n","f05845715af1ed66ea29327c8a4a23ec":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc Test_cache_getValue(t *testing.T) {\n\tt.Run(\"empty cache\", func(t *testing.T) {\n\t\tc := \u0026cache{}\n\t\tv := c.getValue()\n\n\t\tif v == nil {\n\t\t\tt.Errorf(\"Expected non-nil value, got nil\")\n\t\t}\n\n\t\tif len(c.vs) != 1 {\n\t\t\tt.Errorf(\"Expected cache length 1, got %d\", len(c.vs))\n\t\t}\n\t})\n\n\tt.Run(\"cache with existing values\", func(t *testing.T) {\n\t\tc := \u0026cache{\n\t\t\tvs: make([]Value, 5),\n\t\t}\n\t\tv := c.getValue()\n\n\t\tif v == nil {\n\t\t\tt.Errorf(\"Expected non-nil value, got nil\")\n\t\t}\n\n\t\tif len(c.vs) != 6 {\n\t\t\tt.Errorf(\"Expected cache length 6, got %d\", len(c.vs))\n\t\t}\n\t})\n\n\tt.Run(\"cache with extra capacity\", func(t *testing.T) {\n\t\tc := \u0026cache{\n\t\t\tvs: make([]Value, 0, 10),\n\t\t}\n\t\tv := c.getValue()\n\n\t\tif v == nil {\n\t\t\tt.Errorf(\"Expected non-nil value, got nil\")\n\t\t}\n\n\t\tif len(c.vs) != 1 {\n\t\t\tt.Errorf(\"Expected cache length 1, got %d\", len(c.vs))\n\t\t}\n\n\t\tif cap(c.vs) != 10 {\n\t\t\tt.Errorf(\"Expected cache capacity 10, got %d\", cap(c.vs))\n\t\t}\n\t})\n}","f0667afc84cf5da4eedaac8df46a195b":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantJSON string\n\t\twantErr  error\n\t}{\n\t\t{\n\t\t\tname:     \"empty object\",\n\t\t\tinput:    \"{}\",\n\t\t\twantJSON: `{}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"simple object\",\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\twantJSON: `{\"key\": \"value\"}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"object with multiple key-value pairs\",\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\", \"key3\": \"value3\"}`,\n\t\t\twantJSON: `{\"key1\": \"value1\", \"key2\": \"value2\", \"key3\": \"value3\"}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"object with nested object\",\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": {\"key21\": \"value21\", \"key22\": \"value22\"}, \"key3\": \"value3\"}`,\n\t\t\twantJSON: `{\"key1\": \"value1\", \"key2\": {\"key21\": \"value21\", \"key22\": \"value22\"}, \"key3\": \"value3\"}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"object with array\",\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": [\"value21\", \"value22\", \"value23\"], \"key3\": \"value3\"}`,\n\t\t\twantJSON: `{\"key1\": \"value1\", \"key2\": [\"value21\", \"value22\", \"value23\"], \"key3\": \"value3\"}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"object with escaped characters\",\n\t\t\tinput:    `{\"key1\": \"value1\\n\", \"key2\": \"value2\\t\", \"key3\": \"value3\\r\"}`,\n\t\t\twantJSON: `{\"key1\": \"value1\\n\", \"key2\": \"value2\\t\", \"key3\": \"value3\\r\"}`,\n\t\t},\n\t\t{\n\t\t\tname:    \"missing '}'\",\n\t\t\tinput:   `{\"key\": \"value\"`,\n\t\t\twantErr: fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t\t{\n\t\t\tname:    \"missing ':' after object key\",\n\t\t\tinput:   `{\"key\" \"value\"}`,\n\t\t\twantErr: fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t\t{\n\t\t\tname:    \"missing ',' after object value\",\n\t\t\tinput:   `{\"key\": \"value\" \"key2\": \"value2\"}`,\n\t\t\twantErr: fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\t\t{\n\t\t\tname:    \"cannot find opening '\\\"' for object key\",\n\t\t\tinput:   `{key: \"value\"}`,\n\t\t\twantErr: fmt.Errorf(`cannot find opening '\"\" for object key`),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, _, err := parseObject(tt.input, c, 0)\n\t\t\tif (err != nil) != (tt.wantErr != nil) {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err != nil \u0026\u0026 err.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif tt.wantErr == nil {\n\t\t\t\tgotJSON := got.String()\n\t\t\t\tif gotJSON != tt.wantJSON {\n\t\t\t\t\tt.Errorf(\"parseObject() = %v, want %v\", gotJSON, tt.wantJSON)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","f090bde8d09c3c16eb0203495d317a50":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ts     string\n\t\terr   error\n\t}{\n\t\t// Test cases here\n\t\t{\n\t\t\tinput: `{\"key\": \"value\"}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tinput: `{\"key1\": \"value1\", \"key2\": 123}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Add more test cases for different scenarios\n\t}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseObject(tt.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tt.err == nil {\n\t\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.err)\n\t\t\t\t} else if err.Error() != tt.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif s != tt.s {\n\t\t\t\tt.Errorf(\"parseObject() s = %s, want %s\", s, tt.s)\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t// Add cases for other types as needed\n\tdefault:\n\t\treturn false\n\t}\n}\n","f131920ae34d0848f01ae4cda57a1695":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_getKV(t *testing.T) {\n\to := Object{}\n\n\t// Test getting kv when o.kvs is empty\n\tkv1 := o.getKV()\n\tif len(o.kvs) != 1 {\n\t\tt.Errorf(\"Expected o.kvs length to be 1, got %d\", len(o.kvs))\n\t}\n\tif kv1 != \u0026o.kvs[0] {\n\t\tt.Errorf(\"Expected kv1 to be a reference to o.kvs[0]\")\n\t}\n\n\t// Test getting kv when o.kvs has enough capacity\n\tkv2 := o.getKV()\n\tif len(o.kvs) != 2 {\n\t\tt.Errorf(\"Expected o.kvs length to be 2, got %d\", len(o.kvs))\n\t}\n\tif kv2 != \u0026o.kvs[1] {\n\t\tt.Errorf(\"Expected kv2 to be a reference to o.kvs[1]\")\n\t}\n\n\t// Test getting kv when o.kvs needs to grow\n\to.kvs = o.kvs[:len(o.kvs)-1]\n\tkv3 := o.getKV()\n\tif len(o.kvs) != 2 {\n\t\tt.Errorf(\"Expected o.kvs length to be 2, got %d\", len(o.kvs))\n\t}\n\tif kv3 != \u0026o.kvs[1] {\n\t\tt.Errorf(\"Expected kv3 to be a reference to o.kvs[1]\")\n\t}\n}\n","f1d4a580fbdf8c143281df8713dc7b06":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Empty string.\n\t\t{\"\", nil, \"\", fmt.Errorf(\"cannot parse empty string\")},\n\t\t// Invalid JSON.\n\t\t{\"{\", nil, \"{\", fmt.Errorf(\"cannot parse object: missing '}'\")},\n\t\t// Exceed MaxDepth\n\t\t{`{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":null}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}`, nil, \"\", fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth)},\n\t\t// Valid JSON string.\n\t\t{`\"foo\"`, \u0026Value{t: typeRawString, s: \"foo\"}, \"\", nil},\n\t\t// Valid JSON true.\n\t\t{\"true\", valueTrue, \"\", nil},\n\t\t// Valid JSON false.\n\t\t{\"false\", valueFalse, \"\", nil},\n\t\t// Valid JSON null.\n\t\t{\"null\", valueNull, \"\", nil},\n\t\t// Valid JSON number.\n\t\t{\"123\", \u0026Value{t: TypeNumber, s: \"123\"}, \"\", nil},\n\t\t// Valid JSON NaN\n\t\t{\"NaN\", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"\", nil},\n\t\t// Invalid JSON value.\n\t\t{\"bar\", nil, \"bar\", fmt.Errorf(\"unexpected value found: %q\", \"bar\")},\n\t\t// Valid JSON object.\n\t\t{`{\"foo\":\"bar\"}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: typeRawString, s: \"bar\"}}}}}}, \"\", nil},\n\t\t// Valid JSON array.\n\t\t{`[\"foo\",\"bar\"]`, \u0026Value{t: TypeArray, a: []*Value{{t: typeRawString, s: \"foo\"}, {t: typeRawString, s: \"bar\"}}}, \"\", nil},\n\t\t// Valid JSON with tail.\n\t\t{`\"foo\" \"bar\"`, \u0026Value{t: typeRawString, s: \"foo\"}, \" \\\"bar\\\"\", nil},\n\t}\n\tc := \u0026cache{}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tgot, tail, err := parseValue(tt.input, c, 0)\n\t\t\tif (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != nil \u0026\u0026 tt.want != nil \u0026\u0026 got.String() != tt.want.String() {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"parseValue() tail = %v, want %v\", tail, tt.tail)\n\t\t\t}\n\t\t})\n\t}\n}\n","f1fe434c7c5c4eee4f1b5f499d63ef52":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Empty string\n\t\t{\"\", nil, \"\", fmt.Errorf(\"cannot parse empty string\")},\n\n\t\t// Object\n\t\t{`{\"foo\":\"bar\"}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: typeRawString, s: \"bar\"}}}}}, \"\", nil},\n\n\t\t// Array\n\t\t{`[1,2,3]`, \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}}, \"\", nil},\n\n\t\t// String\n\t\t{`\"hello\"`, \u0026Value{t: typeRawString, s: \"hello\"}, \"\", nil},\n\n\t\t// True\n\t\t{\"true\", valueTrue, \"\", nil},\n\n\t\t// False\n\t\t{\"false\", valueFalse, \"\", nil},\n\n\t\t// Null\n\t\t{\"null\", valueNull, \"\", nil},\n\n\t\t// Number\n\t\t{\"123\", \u0026Value{t: TypeNumber, s: \"123\"}, \"\", nil},\n\t\t{\"-123.456\", \u0026Value{t: TypeNumber, s: \"-123.456\"}, \"\", nil},\n\n\t\t// NaN\n\t\t{\"NaN\", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"\", nil},\n\n\t\t// Invalid JSON\n\t\t{\"{\", nil, \"{\", fmt.Errorf(\"cannot parse object: unexpected EOF\")},\n\t\t{\"[\", nil, \"[\", fmt.Errorf(\"cannot parse array: unexpected EOF\")},\n\t\t{`\"hello`, nil, `\"hello`, fmt.Errorf(\"cannot parse string: unexpected EOF\")},\n\t\t{\"tru\", nil, \"tru\", fmt.Errorf(\"unexpected value found: \\\"tru\\\"\")},\n\t\t{\"fals\", nil, \"fals\", fmt.Errorf(\"unexpected value found: \\\"fals\\\"\")},\n\t\t{\"nul\", nil, \"nul\", fmt.Errorf(\"unexpected value found: \\\"nul\\\"\")},\n\t\t{\"123a\", nil, \"123a\", fmt.Errorf(\"cannot parse number: invalid character 'a' after integer\")},\n\n\t\t// Too big depth\n\t\t{`{\"a\":` + `{\"a\":` + `{\"a\":` + `{\"a\":` + `{\"a\":` + `{\"a\":` + `{\"a\":` + `{\"a\":` + `{\"a\":` + `{\"a\":` + `{\"a\":` + `{\"a\":` + `{\"a\":` + `{\"a\":` + `{\"a\":` + `{\"a\":` + `{\"a\":` + `{\"a\":` + `{\"a\":` + `{\"a\":` + `{\"a\":` + `{\"a\":\"foo\"}}` + `}` + `}` + `}` + `}` + `}` + `}` + `}` + `}` + `}` + `}` + `}` + `}` + `}` + `}` + `}` + `}` + `}` + `}` + `}` + `}` + `}` + `}`, nil, `{\"a\":` + `{\"a\":` + `{\"a\":` + `{\"a\":` + `{\"a\":` + `{\"a\":` + `{\"a\":` + `{\"a\":` + `{\"a\":` + `{\"a\":` + `{\"a\":` + `{\"a\":` + `{\"a\":` + `{\"a\":` + `{\"a\":` + `{\"a\":` + `{\"a\":` + `{\"a\":` + `{\"a\":` + `{\"a\":` + `{\"a\":` + `{\"a\":\"foo\"}}` + `}` + `}` + `}` + `}` + `}` + `}` + `}` + `}` + `}` + `}` + `}` + `}` + `}` + `}` + `}` + `}` + `}` + `}` + `}` + `}` + `}` + `}`, fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth)},\n\t}\n\n\tfor i, test := range tests {\n\t\tc := \u0026cache{}\n\t\tgot, tail, err := parseValue(test.input, c, 0)\n\n\t\tif test.err != nil {\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"Test %d: Expected error, got nil\", i)\n\t\t\t} else if err.Error() != test.err.Error() {\n\t\t\t\tt.Errorf(\"Test %d: Error mismatch\\nExpected: %v\\nGot: %v\", i, test.err, err)\n\t\t\t}\n\t\t} else {\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Test %d: Unexpected error: %v\", i, err)\n\t\t\t}\n\t\t\tif tail != test.tail {\n\t\t\t\tt.Errorf(\"Test %d: Tail mismatch\\nExpected: %q\\nGot: %q\", i, test.tail, tail)\n\t\t\t}\n\t\t\tif !equalValues(got, test.want) {\n\t\t\t\tt.Errorf(\"Test %d: Value mismatch\\nExpected: %+v\\nGot: %+v\\nInput: %s\", i, test.want, got, test.input)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\treturn v1.s == v2.s\n\t}\n}\n","f23543cc8a2f20450756636e16c7ac84":"package fastjson\n\nimport \"testing\"\n\nfunc TestObject_getKV(t *testing.T) {\n\to := \u0026Object{}\n\t// Test adding the first kv\n\tkv1 := o.getKV()\n\tif kv1 == nil {\n\t\tt.Fatal(\"Expected kv1 to be non-nil\")\n\t}\n\tif len(o.kvs) != 1 {\n\t\tt.Fatalf(\"Expected o.kvs length to be 1, got %d\", len(o.kvs))\n\t}\n\tif o.kvs[0] != *kv1 {\n\t\tt.Errorf(\"Expected o.kvs[0] to be equal to kv1\")\n\t}\n\n\t// Test adding another kv\n\tkv2 := o.getKV()\n\tif kv2 == nil {\n\t\tt.Fatal(\"Expected kv2 to be non-nil\")\n\t}\n\tif len(o.kvs) != 2 {\n\t\tt.Fatalf(\"Expected o.kvs length to be 2, got %d\", len(o.kvs))\n\t}\n\tif o.kvs[1] != *kv2 {\n\t\tt.Errorf(\"Expected o.kvs[1] to be equal to kv2\")\n\t}\n\n\t// Test adding more than the initial capacity\n\tfor i := 0; i \u003c 5; i++ {\n\t\to.getKV()\n\t}\n\tif len(o.kvs) != 7 {\n\t\tt.Fatalf(\"Expected o.kvs length to be 7, got %d\", len(o.kvs))\n\t}\n}\n","f42b808694ac056f3434ca48d3a97f42":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantJSON string\n\t\twantErr  error\n\t}{\n\t\t{\n\t\t\tname:     \"empty object\",\n\t\t\tinput:    \"{}\",\n\t\t\twantJSON: `{}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"simple object\",\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\twantJSON: `{\"key\":\"value\"}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"object with multiple values\",\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantJSON: `{\"key1\":\"value1\",\"key2\":\"value2\"}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"object with nested object\",\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": {\"nestedKey\": \"nestedValue\"}}`,\n\t\t\twantJSON: `{\"key1\":\"value1\",\"key2\":{\"nestedKey\":\"nestedValue\"}}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"object with nested array\",\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": [\"nestedValue1\", \"nestedValue2\"]}`,\n\t\t\twantJSON: `{\"key1\":\"value1\",\"key2\":[\"nestedValue1\",\"nestedValue2\"]}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"object with escaped characters\",\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"escaped\\tvalue\\n\"}`,\n\t\t\twantJSON: `{\"key1\":\"value1\",\"key2\":\"escaped\\tvalue\\n\"}`,\n\t\t},\n\t\t{\n\t\t\tname:    \"missing closing brace\",\n\t\t\tinput:   `{\"key\": \"value\"`,\n\t\t\twantErr: fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t\t{\n\t\t\tname:    \"missing colon\",\n\t\t\tinput:   `{\"key\" \"value\"}`,\n\t\t\twantErr: fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t\t{\n\t\t\tname:    \"missing comma\",\n\t\t\tinput:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid key\",\n\t\t\tinput:   `{key: \"value\"}`,\n\t\t\twantErr: fmt.Errorf(\"cannot find opening '\\\"' for object key\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, tail, err := parseObject(tt.input, c, 0)\n\n\t\t\tif tt.wantErr != nil {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"parseObject() error = nil, wantErr %v\", tt.wantErr)\n\t\t\t\t} else if err.Error() != tt.wantErr.Error() {\n\t\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr nil\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif len(tail) != 0 {\n\t\t\t\tt.Errorf(\"parseObject() unexpected tail: %q\", tail)\n\t\t\t}\n\n\t\t\twantV := \u0026Value{}\n\t\t\t_, err = wantV.Unmarshal([]byte(tt.wantJSON))\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"Unmarshal() error = %v, wantErr nil\", err)\n\t\t\t}\n\t\t\tif !equalValues(got, wantV) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, wantV)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(a, b *Value) bool {\n\tif a == nil \u0026\u0026 b == nil {\n\t\treturn true\n\t}\n\tif a == nil || b == nil {\n\t\treturn false\n\t}\n\tif a.Type() != b.Type() {\n\t\treturn false\n\t}\n\tswitch a.Type() {\n\tcase TypeObject:\n\t\tao, _ := a.Object()\n\t\tbo, _ := b.Object()\n\t\tif ao.Len() != bo.Len() {\n\t\t\treturn false\n\t\t}\n\t\tfor i := 0; i \u003c ao.Len(); i++ {\n\t\t\takv := ao.kvs[i]\n\t\t\tbkv := bo.kvs[i]\n\t\t\tif akv.k != bkv.k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(akv.v, bkv.v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeArray:\n\t\taa, _ := a.Array()\n\t\tba, _ := b.Array()\n\t\tif len(aa) != len(ba) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := 0; i \u003c len(aa); i++ {\n\t\t\tif !equalValues(aa[i], ba[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\treturn a.String() == b.String()\n\t}\n}\n","f43be1abf4b1b32657a9009cca3aa5f7":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantStr  string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Basic cases\n\t\t{`\"foo\"bar`, \"foo\", \"bar\", nil},\n\t\t{`\"fo\\\"o\"bar`, `fo\"o`, \"bar\", nil},\n\t\t{`\"foo\"`, \"foo\", \"\", nil},\n\t\t{`\"\"bar`, \"\", \"bar\", nil},\n\n\t\t// Escaped quotes\n\t\t{`\"fo\\\\o\"bar`, `fo\\o`, \"bar\", nil},\n\t\t{`\"fo\\\\\\\\\"bar`, `fo\\\\`, \"bar\", nil},\n\t\t{`\"fo\\\\\\\"o\"bar`, `fo\\\"o`, \"bar\", nil},\n\n\t\t// Errors\n\t\t{`\"foo`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"fo\\\"o`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`foo\"`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tgotStr, gotTail, gotErr := parseRawString(tt.input)\n\t\t\tif gotStr != tt.wantStr {\n\t\t\t\tt.Errorf(\"parseRawString(%q) gotStr = %q, want %q\", tt.input, gotStr, tt.wantStr)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseRawString(%q) gotTail = %q, want %q\", tt.input, gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif gotErr != nil \u0026\u0026 tt.wantErr == nil || gotErr == nil \u0026\u0026 tt.wantErr != nil || gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"parseRawString(%q) gotErr = %v, want %v\", tt.input, gotErr, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","f4bcb92947eb553e92ce8b89aba331e3":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic cases\n\t\t{`\"hello, world\"`, \"hello, world\"},\n\t\t{`\"escaped \\\\ backslash\"`, \"escaped \\\\ backslash\"},\n\t\t{`\"escaped \\\" quote\"`, \"escaped \\\" quote\"},\n\t\t{`\"escaped \\/ slash\"`, \"escaped / slash\"},\n\n\t\t// Unicode escapes\n\t\t{`\"\\u0041\\u0042\\u0043\"`, \"ABC\"},\n\t\t{`\"\\u041f\\u0440\\u0438\\u0432\\u0435\\u0442\"`, \"–ü—Ä–∏–≤–µ—Ç\"},\n\t\t{`\"\\uD83D\\uDE02\"`, \"üòÇ\"}, // Surrogate pair\n\n\t\t// Invalid escape sequences\n\t\t{`\"\\x00\"`, \"\\\\x00\"},\n\t\t{`\"\\u123\"`, \"\\\\u123\"},\n\t\t{`\"\\uD83D\"`, \"\\\\uD83D\"},\n\t\t{`\"\\uD83D\\u1234\"`, \"\\\\uD83D\\\\u1234\"},\n\n\t\t// Other edge cases\n\t\t{`\"\"`, \"\"},\n\t\t{`\"\\\\\"`, \"\\\\\"},\n\t\t{`\"\\\\\\\\\"`, \"\\\\\\\\\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}\n","f4ec22d1a5a18bc89b39a41074f20a98":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantN    string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Basic cases.\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"123.456\", \"123.456\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"123e+456\", \"123e+456\", \"\", nil},\n\n\t\t// Trailing garbage.\n\t\t{\"123x\", \"123\", \"x\", nil},\n\t\t{\"123.456x\", \"123.456\", \"x\", nil},\n\t\t{\"-123x\", \"-123\", \"x\", nil},\n\t\t{\"123e+456x\", \"123e+456\", \"x\", nil},\n\n\t\t// Leading garbage.\n\t\t{\"x123\", \"\", \"x123\", fmt.Errorf(\"unexpected char: %q\", \"x\")},\n\n\t\t// Invalid numbers.\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t\t{\"-\", \"\", \"-\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t\t{\"+\", \"\", \"+\", fmt.Errorf(\"unexpected char: %q\", \"+\")},\n\t\t{\"e\", \"\", \"e\", fmt.Errorf(\"unexpected char: %q\", \"e\")},\n\t\t{\".\", \"\", \".\", fmt.Errorf(\"unexpected char: %q\", \".\")},\n\t\t{\"123e\", \"\", \"123e\", fmt.Errorf(\"unexpected char: %q\", \"e\")},\n\t\t{\"123e+\", \"\", \"123e+\", fmt.Errorf(\"unexpected char: %q\", \"+\")},\n\n\t\t// Special cases.\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"+inf\", \"+inf\", \"\", nil},\n\t\t{\"in\", \"\", \"in\", fmt.Errorf(\"unexpected char: %q\", \"i\")},\n\t\t{\"infx\", \"inf\", \"x\", nil},\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"-nan\", \"-nan\", \"\", nil},\n\t\t{\"+nan\", \"+nan\", \"\", nil},\n\t\t{\"na\", \"\", \"na\", fmt.Errorf(\"unexpected char: %q\", \"n\")},\n\t\t{\"nanx\", \"nan\", \"x\", nil},\n\t}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tgotN, gotTail, gotErr := parseRawNumber(tt.input)\n\t\t\tif gotN != tt.wantN || gotTail != tt.wantTail || (gotErr != nil \u0026\u0026 tt.wantErr == nil) || (gotErr == nil \u0026\u0026 tt.wantErr != nil) || (gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error()) {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, %q, %v, want %q, %q %v\", tt.input, gotN, gotTail, gotErr, tt.wantN, tt.wantTail, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","f507afd9a2e710907103163f30938768":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc Test_unescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello world\",\n\t\t\t},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"simple escape\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello\\\\tworld\",\n\t\t\t},\n\t\t\twant: \"hello\\tworld\",\n\t\t},\n\t\t{\n\t\t\tname: \"unicode escape\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello\\\\u0020world\",\n\t\t\t},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid unicode escape\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello\\\\u002world\",\n\t\t\t},\n\t\t\twant: \"hello\\\\u002world\",\n\t\t},\n\t\t{\n\t\t\tname: \"surrogate pair escape\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello\\\\ud83d\\\\ude01world\",\n\t\t\t},\n\t\t\twant: \"helloüòÅworld\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid surrogate pair escape\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello\\\\ud83dworld\",\n\t\t\t},\n\t\t\twant: \"hello\\\\ud83dworld\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","f52a9ba437685c8435afc8b5272bb656":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetInt(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tjson  string\n\t\tkeys  []string\n\t\twant  int\n\t\twant1 bool\n\t}{\n\t\t{\n\t\t\tname:  \"simple\",\n\t\t\tjson:  `{\"foo\": 123}`,\n\t\t\tkeys:  []string{\"foo\"},\n\t\t\twant:  123,\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"nested\",\n\t\t\tjson:  `{\"foo\": {\"bar\": {\"baz\": 456}}}`,\n\t\t\tkeys:  []string{\"foo\", \"bar\", \"baz\"},\n\t\t\twant:  456,\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array index\",\n\t\t\tjson:  `{\"foo\": [10, 20, 30]}`,\n\t\t\tkeys:  []string{\"foo\", \"1\"},\n\t\t\twant:  20,\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array index float\",\n\t\t\tjson:  `{\"foo\": [10, 20, 30]}`,\n\t\t\tkeys:  []string{\"foo\", \"1.0\"},\n\t\t\twant:  20,\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"non existing key\",\n\t\t\tjson:  `{\"foo\": 123}`,\n\t\t\tkeys:  []string{\"bar\"},\n\t\t\twant:  0,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"invalid value type\",\n\t\t\tjson:  `{\"foo\": \"bar\"}`,\n\t\t\tkeys:  []string{\"foo\"},\n\t\t\twant:  0,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"number from string\",\n\t\t\tjson:  `{\"foo\": \"123\"}`,\n\t\t\tkeys:  []string{\"foo\"},\n\t\t\twant:  0,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"large number\",\n\t\t\tjson:  `{\"foo\": 9223372036854775807}`,\n\t\t\tkeys:  []string{\"foo\"},\n\t\t\twant:  0,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"number with fraction\",\n\t\t\tjson:  `{\"foo\": 123.456}`,\n\t\t\tkeys:  []string{\"foo\"},\n\t\t\twant:  123,\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"scientific notation\",\n\t\t\tjson:  `{\"foo\": 1.23e+4}`,\n\t\t\tkeys:  []string{\"foo\"},\n\t\t\twant:  12300,\n\t\t\twant1: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tvar p Parser\n\t\t\tv, err := p.Parse(tt.json)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Parse() error = %v, wantErr %v\", err, nil)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgot := v.GetInt(tt.keys...)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"GetInt() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","f583068e21b7ee06f424a489cd2eb93d":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Empty string.\n\t\t{\"\", nil, \"\", fmt.Errorf(\"cannot parse empty string\")},\n\n\t\t// Invalid JSON.\n\t\t{\"abc\", nil, \"abc\", fmt.Errorf(\"cannot parse object: cannot parse key: unexpected EOF\")},\n\n\t\t// Null.\n\t\t{\"null\", valueNull, \"\", nil},\n\t\t{\"   null\", valueNull, \"\", nil},\n\t\t{\"null   \", valueNull, \"   \", nil},\n\t\t{\"nullxxx\", valueNull, \"xxx\", nil},\n\n\t\t// True.\n\t\t{\"true\", valueTrue, \"\", nil},\n\t\t{\"  true\", valueTrue, \"\", nil},\n\t\t{\"true  \", valueTrue, \"  \", nil},\n\n\t\t// False.\n\t\t{\"false\", valueFalse, \"\", nil},\n\t\t{\"  false\", valueFalse, \"\", nil},\n\t\t{\"false  \", valueFalse, \"  \", nil},\n\n\t\t// Number.\n\t\t{\"123\", \u0026Value{t: TypeNumber, s: \"123\"}, \"\", nil},\n\t\t{\"  123\", \u0026Value{t: TypeNumber, s: \"123\"}, \"\", nil},\n\t\t{\"123  \", \u0026Value{t: TypeNumber, s: \"123\"}, \"  \", nil},\n\t\t{\"-123.456e7\", \u0026Value{t: TypeNumber, s: \"-123.456e7\"}, \"\", nil},\n\n\t\t// String.\n\t\t{`\"foo\"`, \u0026Value{t: TypeString, s: \"foo\"}, \"\", nil},\n\t\t{`  \"foo\"`, \u0026Value{t: TypeString, s: \"foo\"}, \"\", nil},\n\t\t{`\"foo\"  `, \u0026Value{t: TypeString, s: \"foo\"}, \"  \", nil},\n\t\t{`\"foo\\nbar\"`, \u0026Value{t: TypeString, s: \"foo\\nbar\"}, \"\", nil},\n\n\t\t// Object.\n\t\t{`{}`, \u0026Value{t: TypeObject, o: Object{}}, \"\", nil},\n\t\t{`{\"foo\": \"bar\"}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: TypeString, s: \"bar\"}}}}}, \"\", nil},\n\n\t\t// Array.\n\t\t{`[]`, \u0026Value{t: TypeArray, a: []*Value{}}, \"\", nil},\n\t\t{`[1, \"foo\"]`, \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeString, s: \"foo\"}}}, \"\", nil},\n\n\t\t// NaN.\n\t\t{\"NaN\", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"\", nil},\n\t\t{\"  NaN\", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"\", nil},\n\t\t{\"NaN  \", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"  \", nil},\n\t\t{\"NaNxxx\", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"xxx\", nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test #%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, tail, err := parseValue(tt.input, c, 0)\n\t\t\tif got != nil \u0026\u0026 tt.want != nil \u0026\u0026 got.t != tt.want.t {\n\t\t\t\tt.Errorf(\"got type = %v, want %v\", got.t, tt.want.t)\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\tif tt.err == nil {\n\t\t\t\t\tt.Errorf(\"got error %v, want nil\", err)\n\t\t\t\t} else if err.Error() != tt.err.Error() {\n\t\t\t\t\tt.Errorf(\"got error %v, want %v\", err, tt.err)\n\t\t\t\t}\n\t\t\t} else if tt.err != nil {\n\t\t\t\tt.Errorf(\"got nil error, want %v\", tt.err)\n\t\t\t}\n\t\t\tif got != nil \u0026\u0026 got.t == TypeString \u0026\u0026 got.s != tt.want.s {\n\t\t\t\tt.Errorf(\"got string = %q, want %q\", got.s, tt.want.s)\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"got tail = %q, want %q\", tail, tt.tail)\n\t\t\t}\n\t\t})\n\t}\n}\n","f59ee05c8531a20d9be7e8f6127935d7":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic tests\n\t\t{`\"foo\"`, \"foo\"},\n\t\t{`\"foo\\\\bar\"`, `foo\\bar`},\n\t\t{`\"foo\\\"bar\"`, `foo\"bar`},\n\t\t{`\"foo\\tbar\"`, \"foo\\tbar\"},\n\t\t{`\"foo\\nbar\"`, \"foo\\nbar\"},\n\t\t{`\"foo\\rbar\"`, \"foo\\rbar\"},\n\t\t{`\"foo\\fbar\"`, \"foo\\fbar\"},\n\t\t{`\"foo\\bbar\"`, \"foo\\bbar\"},\n\t\t{`\"\\\\/foo\\/bar\\\\/\"`, `/foo/bar/`},\n\n\t\t// Unicode tests\n\t\t{`\"\\u0041\"`, \"A\"},\n\t\t{`\"\\u041f\\u0440\\u0438\\u0432\\u0435\\u0442\"`, \"–ü—Ä–∏–≤–µ—Ç\"},\n\t\t// Invalid unicode tests\n\t\t{`\"\\u004x\"`, `\\u004x`},\n\t\t{`\"\\u004\"`, `\\u004`},\n\t\t{`\"\\u\"`, `\\u`},\n\t\t{`\"\\u1234\\u567x\"`, \"\\u1234\\u567x\"},\n\t\t// Surrogate pairs\n\t\t{`\"\\uD83D\\uDE00\"`, \"üòÄ\"},\n\t\t{`\"\\uD83D\\uDE01\"`, \"üòÅ\"},\n\t\t// Invalid surrogate pairs\n\t\t{`\"\\uD83D\"`, `\\uD83D`},\n\t\t{`\"\\uD83D\\u1234\"`, `\\uD83D\\u1234`},\n\n\t\t// Mixed tests\n\t\t{`\"foo\\\\bar\\nbaz\\uD83D\\uDE00\"`, `foo\\bar\\nbazüòÄ`},\n\t}\n\n\tfor i, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Test %d: Expected %q, got %q\", i+1, test.expected, actual)\n\t\t}\n\t}\n}","f5e0639406a7ac149ef59ce46b9fd877":"package fastjson\n\nimport \"testing\"\n\nfunc TestObject_getKV(t *testing.T) {\n\to := Object{}\n\t// Test adding the first kv\n\tkv1 := o.getKV()\n\tif kv1 == nil {\n\t\tt.Errorf(\"Expected non-nil kv, got nil\")\n\t}\n\n\t// Test adding another kv\n\tkv2 := o.getKV()\n\tif kv2 == nil {\n\t\tt.Errorf(\"Expected non-nil kv, got nil\")\n\t}\n\n\t// Check if the kvs are different\n\tif kv1 == kv2 {\n\t\tt.Errorf(\"Expected different kv addresses, got the same\")\n\t}\n}\n","f61bfa80baef78dd9ee3035bba841ed5":"package fastjson\n\nimport \"testing\"\n\nfunc Test_skipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    string\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\ts:    \"\",\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with leading whitespace\",\n\t\t\ts:    \"  \\n\\t\\r foo\",\n\t\t\twant: \"foo\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with no leading whitespace\",\n\t\t\ts:    \"bar\",\n\t\t\twant: \"bar\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with all whitespace\",\n\t\t\ts:    \" \\t\\n\\r\",\n\t\t\twant: \"\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","f625b903fe1f87df3db897c6edb4f6ae":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"raw string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"raw string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"string\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"[\\\"string\\\",123]\"),\n\t\t},\n\t\t// TODO: Add test cases for TypeObject.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif string(got) != string(tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", string(got), string(tt.want))\n\t\t\t}\n\t\t})\n\t}\n}","f6f799d652f95548df1454b0da524481":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantStr  string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Test cases here\n\t\t{\"\\\"hello\\\"\", \"hello\", \"\", nil},\n\t\t{\"\\\"hello\\\\\\\"\", \"hello\\\\\\\"\", \"\", nil},\n\t\t{\"\\\"hello\\\\\\\"world\\\"\", \"hello\\\\\\\"world\", \"\", nil},\n\t\t{\"\\\"hello\\\\\\\\\\\"\", \"hello\\\\\\\\\", \"\", nil},\n\t\t{\"\\\"hello\\\\\\\"world\\\\\\\"\", \"hello\\\\\\\"world\\\\\\\"\", \"\", nil},\n\t\t{\"\\\"hello\\\\\\\"world\\\\\\\"tail\", \"hello\\\\\\\"world\\\\\\\"\", \"tail\", nil},\n\t\t{\"\\\"hello\", \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{\"hello\\\"\", \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tgotStr, gotTail, gotErr := parseRawString(tt.input)\n\t\t\tif gotStr != tt.wantStr {\n\t\t\t\tt.Errorf(\"parseRawString(%q) gotStr = %q, want %q\", tt.input, gotStr, tt.wantStr)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseRawString(%q) gotTail = %q, want %q\", tt.input, gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif gotErr == nil \u0026\u0026 tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"parseRawString(%q) got no error, want %v\", tt.input, tt.wantErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr == nil {\n\t\t\t\tt.Errorf(\"parseRawString(%q) got error = %v, want nil\", tt.input, gotErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"parseRawString(%q) got error = %v, want %v\", tt.input, gotErr, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","f7174365718278f6c246af3c02df800c":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\t// Add your test cases for the Parse function here.\n\t// Example test case:\n\t/*\n\t\ts := `{\"key\": \"value\"}`\n\t\tp := Parser{}\n\t\tv, err := p.Parse(s)\n\n\t\t// Add assertions to check the expected values of v and err\n\t*/\n}\n","f7c57cc5d4987c63433126e4c45ef159":"package fastjson\n\nimport \"testing\"\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"  \\n\\t  foo\", \"foo\"},\n\t\t{\"foo  \\n\\t  \", \"foo  \\n\\t  \"},\n\t\t{\"  \\n\\t  \", \"\"},\n\t\t{\"\", \"\"},\n\t\t{\"\\x00foo\", \"\\x00foo\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := skipWSSlow(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"skipWSSlow(%q) = %q, want %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}\n","f8928951972e02af89edabbec7377750":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestValue_Int(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantInt  int\n\t\twantError bool\n\t}{\n\t\t{\n\t\t\tinput:    `123`,\n\t\t\twantInt:  123,\n\t\t\twantError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `-123`,\n\t\t\twantInt:  -123,\n\t\t\twantError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `9223372036854775807`,\n\t\t\twantInt:  0,\n\t\t\twantError: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"123\"`,\n\t\t\twantInt:  0,\n\t\t\twantError: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `1.23`,\n\t\t\twantInt:  0,\n\t\t\twantError: true,\n\t\t},\n\t}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test_%d\", i), func(t *testing.T) {\n\t\t\tv := ParseBytes([]byte(tt.input))\n\t\t\tgot, err := v.Int()\n\t\t\tif (err != nil) != tt.wantError {\n\t\t\t\tt.Errorf(\"Int() error = %v, wantErr %v\", err, tt.wantError)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.wantInt {\n\t\t\t\tt.Errorf(\"Int() got = %v, want %v\", got, tt.wantInt)\n\t\t\t}\n\t\t})\n\t}\n\n}","f8da9bdf20008c2b106a9e69d349e4ba":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant1 string\n\t\twant2 string\n\t\terr error\n\t}{\n\t\t{`\"foo\"bar`, \"foo\", \"bar\", nil},\n\t\t{`\"fo\\o\"bar`, \"fo\\o\", \"bar\", nil},\n\t\t{`\"foo\\\"bar\"baz`, `foo\"bar`, \"baz\", nil},\n\t\t{`\"foo\"bar`, \"foo\", \"bar\", nil},\n\t\t{`\"fo\\o\"bar`, \"fo\\o\", \"bar\", nil},\n\t\t{`\"foo\\\\\"bar`, `foo\\`, \"bar\", nil},\n\t\t{`\"foo\\\"bar\"baz`, `foo\"bar`, \"baz\", nil},\n\t\t{`\"foo\\\\\\\"\"bar\"baz`, `foo\\\"\"bar`, \"baz\", nil},\n\t\t{`\"foo`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo\"ba\"r`, `foo`, `ba\"r`, nil},\n\t}\n\tfor i, tt := range tests {\n\t\tgot1, got2, err := parseRawString(tt.input)\n\t\tif got1 != tt.want1 || got2 != tt.want2 || !equalError(err, tt.err) {\n\t\t\tt.Errorf(\"#%d. parseRawString(%q) = %q, %q, %v want %q, %q, %v\", i, tt.input, got1, got2, err, tt.want1, tt.want2, tt.err)\n\t\t}\n\t}\n}\n\n// equalError reports whether errors a and b are equal.\n// They're equal if both are nil, or both are not nil and a.Error() == b.Error().\nfunc equalError(a, b error) bool {\n\treturn a == nil \u0026\u0026 b == nil || a != nil \u0026\u0026 b != nil \u0026\u0026 a.Error() == b.Error()\n}","f95819b73bedc0740878a7252e4ef62b":"package fastjson\n\nimport \"testing\"\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tt    Type\n\t\twant string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\tfor i, tt := range tests {\n\t\tgot := tt.t.String()\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"%d. String() = %q; want %q\", i, got, tt.want)\n\t\t}\n\t}\n}","f9747230c68e23c0a3a3fc2165b2b8a6":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv:    \u0026Value{t: typeRawString, s: \"raw string\"},\n\t\t\twant: []byte(\"\\\"raw string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv:    \u0026Value{t: TypeString, s: \"string\"},\n\t\t\twant: []byte(\"\\\"string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv:    \u0026Value{t: TypeNumber, s: \"1234\"},\n\t\t\twant: []byte(\"1234\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv:    \u0026Value{t: TypeTrue},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv:    \u0026Value{t: TypeFalse},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv:    \u0026Value{t: TypeNull},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t{t: TypeString, s: \"2\"},\n\t\t\t\t{t: TypeTrue},\n\t\t\t}},\n\t\t\twant: []byte(\"[1,\\\"2\\\",true]\"),\n\t\t},\n\t\t// TODO: add test case for TypeObject\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif string(got) != string(tt.want) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","f981bfe9171513de09c0681357443d27":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  string\n\t\twant1 string\n\t\terr   error\n\t}{\n\t\t// Test cases here\n\t\t{\n\t\t\tinput: `\"hello\"world`,\n\t\t\twant:  \"hello\",\n\t\t\twant1: \"world\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `\"\\\\\"hello\"world`,\n\t\t\twant:  `\\\"hello`,\n\t\t\twant1: \"world\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `\"he\\\\\"llo\"world`,\n\t\t\twant:  `he\\\"llo`,\n\t\t\twant1: \"world\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `\"hello\\\\\"world`,\n\t\t\twant:  `hello\\`,\n\t\t\twant1: `world`,\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `\"hello`,\n\t\t\twant:  \"\",\n\t\t\twant1: \"\",\n\t\t\terr:   fmt.Errorf(`missing closing '\"'`),\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tgot, got1, err := parseRawString(tt.input)\n\t\tif got != tt.want || got1 != tt.want1 || (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) {\n\t\t\tt.Errorf(\"test[%d]: parseRawString(%q) = (%q, %q, %v), want (%q, %q, %v)\", i, tt.input, got, got1, err, tt.want, tt.want1, tt.err)\n\t\t}\n\t}\n}","fa1f625cfa6f647e389ef8b2e4a2b0f7":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantObj  string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t{\n\t\t\tname:     \"EmptyObject\",\n\t\t\tinput:    \"{}\",\n\t\t\twantObj:  `{\"t\":1}`,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"SimpleObject\",\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\twantObj:  `{\"t\":1,\"o\":{\"kvs\":[{\"k\":\"key\",\"v\":{\"t\":3,\"s\":\"value\"}}]}}`,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"ObjectWithMultipleKeys\",\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantObj:  `{\"t\":1,\"o\":{\"kvs\":[{\"k\":\"key1\",\"v\":{\"t\":3,\"s\":\"value1\"}},{\"k\":\"key2\",\"v\":{\"t\":3,\"s\":\"value2\"}}]}}`,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"ObjectWithNestedObject\",\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": {\"nestedKey\": \"nestedValue\"}}`,\n\t\t\twantObj:  `{\"t\":1,\"o\":{\"kvs\":[{\"k\":\"key1\",\"v\":{\"t\":3,\"s\":\"value1\"}},{\"k\":\"key2\",\"v\":{\"t\":1,\"o\":{\"kvs\":[{\"k\":\"nestedKey\",\"v\":{\"t\":3,\"s\":\"nestedValue\"}}]}}}]}}`,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"MissingClosingBrace\",\n\t\t\tinput:    `{\"key\": \"value\"`,\n\t\t\twantObj:  \"\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"MissingColon\",\n\t\t\tinput:    `{\"key\" \"value\"}`,\n\t\t\twantObj:  \"\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"MissingComma\",\n\t\t\tinput:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantObj:  \"\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"InvalidKey\",\n\t\t\tinput:    `{key: \"value\"}`,\n\t\t\twantObj:  \"\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  fmt.Errorf(\"cannot parse object key: cannot find opening '\\\"' for object key\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgotObj, gotTail, gotErr := parseObject(tt.input, c, 0)\n\n\t\t\tif fmt.Sprintf(\"%v\", gotErr) != fmt.Sprintf(\"%v\", tt.wantErr) {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", gotErr, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif gotObj != nil {\n\t\t\t\tgotObjStr := gotObj.String()\n\t\t\t\tif gotObjStr != tt.wantObj {\n\t\t\t\t\tt.Errorf(\"parseObject() gotObj = %s, want %s\", gotObjStr, tt.wantObj)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseObject() gotTail = %s, want %s\", gotTail, tt.wantTail)\n\t\t\t}\n\t\t})\n\t}\n}\n","fa43a2f1438e1f409b9dcf9d2fc25dc6":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantObj  string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t{\n\t\t\tname:     \"empty object\",\n\t\t\tinput:    \"{}\",\n\t\t\twantObj:  `{\"t\":1}`,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"single key-value\",\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\twantObj:  `{\"t\":1,\"o\":{\"kvs\":[{\"k\":\"key\",\"v\":{\"t\":3,\"s\":\"value\"}}]}}`,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple key-values\",\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 123, \"key3\": true}`,\n\t\t\twantObj:  `{\"t\":1,\"o\":{\"kvs\":[{\"k\":\"key1\",\"v\":{\"t\":3,\"s\":\"value1\"}},{\"k\":\"key2\",\"v\":{\"t\":4,\"i\":123}},{\"k\":\"key3\",\"v\":{\"t\":5}}]}}`,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"nested object\",\n\t\t\tinput:    `{\"key1\": {\"key2\": \"value2\"}, \"key3\": \"value3\"}`,\n\t\t\twantObj:  `{\"t\":1,\"o\":{\"kvs\":[{\"k\":\"key1\",\"v\":{\"t\":1,\"o\":{\"kvs\":[{\"k\":\"key2\",\"v\":{\"t\":3,\"s\":\"value2\"}}]}}},{\"k\":\"key3\",\"v\":{\"t\":3,\"s\":\"value3\"}}]}}`,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing closing brace\",\n\t\t\tinput:    `{\"key\": \"value\"`,\n\t\t\twantObj:  \"\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  fmt.Errorf(`missing '}'`),\n\t\t},\n\t\t{\n\t\t\tname:     \"missing opening quote for key\",\n\t\t\tinput:    \"{key: \\\"value\\\"}\",\n\t\t\twantObj:  \"\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  fmt.Errorf(`cannot find opening '\"\" for object key`),\n\t\t},\n\t\t{\n\t\t\tname:     \"missing colon after key\",\n\t\t\tinput:    `{\"key\" \"value\"}`,\n\t\t\twantObj:  \"\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"missing comma between key-values\",\n\t\t\tinput:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantObj:  \"\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{vs: make([]Value, 10)}\n\t\t\tgot, tail, err := parseObject(tt.input, c, 0)\n\t\t\tif (err != nil \u0026\u0026 tt.wantErr == nil) || (err == nil \u0026\u0026 tt.wantErr != nil) || (err != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 err.Error() != tt.wantErr.Error()) {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif tt.wantErr == nil {\n\t\t\t\tgotStr := got.String()\n\t\t\t\tif gotStr != tt.wantObj {\n\t\t\t\t\tt.Errorf(\"parseObject() got = %s, want %s\", gotStr, tt.wantObj)\n\t\t\t\t}\n\t\t\t\tif tail != tt.wantTail {\n\t\t\t\t\tt.Errorf(\"parseObject() tail = %s, want %s\", tail, tt.wantTail)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n","fad2cd55a1437b3ce0da7feb21a2c28c":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"raw string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"raw string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"1234\",\n\t\t\t},\n\t\t\twant: []byte(\"1234\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"string\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1234\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"[\\\"string\\\",1234]\"),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"1234\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"{\\\"key1\\\":\\\"value1\\\",\\\"key2\\\":1234}\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif string(got) != string(tt.want) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %v, want %v\", string(got), string(tt.want))\n\t\t\t}\n\t\t})\n\t}\n}","fafe949e40ef0e679a1dce9f0ab14244":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ts     string\n\t\terr   error\n\t}{\n\t\t// Empty object\n\t\t{\n\t\t\tinput: \"{}\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Single key-value pair\n\t\t{\n\t\t\tinput: `{\"key\": \"value\"}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Multiple key-value pairs\n\t\t{\n\t\t\tinput: `{\"key1\": \"value1\", \"key2\": 123, \"key3\": true}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// With whitespace\n\t\t{\n\t\t\tinput: \" { \\\"key\\\" : \\\"value\\\" } \",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \" \",\n\t\t\terr: nil,\n\t\t},\n\t\t// With escaped characters\n\t\t{\n\t\t\tinput: `{\"key\": \"value\\nwith\\tescaped\\tcharacters\"}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\\nwith\\tescaped\\tcharacters\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Invalid JSON\n\t\t{\n\t\t\tinput: `{\"key\": \"value\"`,\n\t\t\twant:  nil,\n\t\t\ts:     `{\"key\": \"value\"`,\n\t\t\terr:   fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseObject(tt.input, c, 0)\n\t\t\tif fmt.Sprintf(\"%v\", err) != fmt.Sprintf(\"%v\", tt.err) {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif s != tt.s {\n\t\t\t\tt.Errorf(\"parseObject() remaining string = %v, want %v\", s, tt.s)\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeTrue, TypeFalse, TypeNull:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}","fb729c9e664590824f43d00dd4575e18":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey   string\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t{`\"foo\"bar`, \"foo\", \"bar\", nil},\n\t\t{`\"fo\\o\"bar`, \"fo\\o\", \"bar\", nil},\n\t\t{`\"foo\\\"\"bar`, `foo\"`, \"bar\", nil},\n\t\t{`\"foo\\\\\"bar`, `foo\\`, \"bar\", nil},\n\t\t{`\"\\\"\"bar`, `\"`, \"bar\", nil},\n\t\t{`\"\\\\\"bar`, `\\`, \"bar\", nil},\n\t\t{`\"foo\"`, \"foo\", \"\", nil},\n\t\t{`\"foo`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`foo`, \"foo\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tkey, tail, err := parseRawString(tt.input)\n\t\t\tif fmt.Sprintf(\"%v\", tt.err) != fmt.Sprintf(\"%v\", err) {\n\t\t\t\tt.Fatalf(\"mismatched error, want %v, got %v\", tt.err, err)\n\t\t\t}\n\t\t\tif tt.key != key {\n\t\t\t\tt.Fatalf(\"mismatched key, want %q, got %q\", tt.key, key)\n\t\t\t}\n\t\t\tif tt.tail != tail {\n\t\t\t\tt.Fatalf(\"mismatched tail, want %q, got %q\", tt.tail, tail)\n\t\t\t}\n\t\t})\n\t}\n}","fb7e9ab90d925bed85b64d15b8032d26":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantValue *Value\n\t\twantTail string\n\t\twantErr   error\n\t}{\n\t\t{\n\t\t\tname:     \"empty array\",\n\t\t\tinput:    \"[]\",\n\t\t\twantValue: \u0026Value{t: TypeArray, a: []*Value{}},\n\t\t\twantTail: \"\",\n\t\t\twantErr:   nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"single element array\",\n\t\t\tinput:    \"[1]\",\n\t\t\twantValue: \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}}},\n\t\t\twantTail: \"\",\n\t\t\twantErr:   nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple element array\",\n\t\t\tinput:    \"[1,2,3]\",\n\t\t\twantValue: \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}},\n\t\t\twantTail: \"\",\n\t\t\twantErr:   nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with whitespace\",\n\t\t\tinput:    \" [ 1 , 2 , 3 ] \",\n\t\t\twantValue: \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}},\n\t\t\twantTail: \" \",\n\t\t\twantErr:   nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"nested array\",\n\t\t\tinput:    \"[[1,2],[3,4]]\",\n\t\t\twantValue: \u0026Value{t: TypeArray, a: []*Value{{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}}}, {t: TypeArray, a: []*Value{{t: TypeNumber, s: \"3\"}, {t: TypeNumber, s: \"4\"}}}}},\n\t\t\twantTail: \"\",\n\t\t\twantErr:   nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing ]\",\n\t\t\tinput:    \"[1,2,3\",\n\t\t\twantValue: nil,\n\t\t\twantTail: \"\",\n\t\t\twantErr:   fmt.Errorf(\"unexpected end of array\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"missing ,\",\n\t\t\tinput:    \"[1 2 3]\",\n\t\t\twantValue: nil,\n\t\t\twantTail: \"\",\n\t\t\twantErr:   fmt.Errorf(\"missing ',' after array value\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgotValue, gotTail, gotErr := parseArray(tt.input, c, 0)\n\n\t\t\tif gotErr != nil {\n\t\t\t\tif tt.wantErr == nil {\n\t\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", gotErr, tt.wantErr)\n\t\t\t\t} else if gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", gotErr, tt.wantErr)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif tt.wantErr != nil {\n\t\t\t\t\tt.Errorf(\"parseArray() error = nil, wantErr %v\", tt.wantErr)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseArray() gotTail = %v, want %v\", gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif !equalValues(gotValue, tt.wantValue) {\n\t\t\t\tt.Errorf(\"parseArray() gotValue = %v, want %v\", gotValue, tt.wantValue)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.s != v2.s {\n\t\treturn false\n\t}\n\tif len(v1.a) != len(v2.a) {\n\t\treturn false\n\t}\n\tfor i := range v1.a {\n\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n","fce70cc9e40ba2c400ed89f3e0ba423b":"package fastjson\n\nimport \"testing\"\n\nfunc TestValue_GetInt(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tjson  string\n\t\tkeys  []string\n\t\twant  int\n\t\twant1 bool\n\t}{\n\t\t{\n\t\t\tname:  \"simple\",\n\t\t\tjson:  `{\"foo\":123}`,\n\t\t\tkeys:  []string{\"foo\"},\n\t\t\twant:  123,\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"nested\",\n\t\t\tjson:  `{\"foo\":{\"bar\":123}}`,\n\t\t\tkeys:  []string{\"foo\", \"bar\"},\n\t\t\twant:  123,\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array\",\n\t\t\tjson:  `{\"foo\":[123,456]}`,\n\t\t\tkeys:  []string{\"foo\", \"1\"},\n\t\t\twant:  456,\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array decimal\",\n\t\t\tjson:  `{\"foo\":[123,456]}`,\n\t\t\tkeys:  []string{\"foo\", \"1.0\"},\n\t\t\twant:  456,\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"non-existing key\",\n\t\t\tjson:  `{\"foo\":123}`,\n\t\t\tkeys:  []string{\"bar\"},\n\t\t\twant:  0,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"invalid value type\",\n\t\t\tjson:  `{\"foo\":\"bar\"}`,\n\t\t\tkeys:  []string{\"foo\"},\n\t\t\twant:  0,\n\t\t\twant1: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tvar v Value\n\t\t\tif err := v.Unmarshal([]byte(tt.json)); err != nil {\n\t\t\t\tt.Errorf(\"Unmarshal() error = %v, json = %v\", err, tt.json)\n\t\t\t}\n\t\t\tgot := v.GetInt(tt.keys...)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"GetInt() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","feacaa5e88202caacf33cb33a02608a6":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Empty string.\n\t\t{\"\", nil, \"\", fmt.Errorf(\"cannot parse empty string\")},\n\n\t\t// Invalid JSON.\n\t\t{\"{\", nil, \"{\", fmt.Errorf(\"cannot parse object: missing '}'\")},\n\t\t{\"[\", nil, \"[\", fmt.Errorf(\"cannot parse array: missing ']'\")},\n\t\t{\"\\\"unterminated string\", nil, \"\\\"unterminated string\", fmt.Errorf(\"cannot parse string: missing '\\\"'\")},\n\n\t\t// Valid JSON values.\n\t\t{\"null\", valueNull, \"\", nil},\n\t\t{\"true\", valueTrue, \"\", nil},\n\t\t{\"false\", valueFalse, \"\", nil},\n\t\t{\"123\", \u0026Value{t: TypeNumber, s: \"123\"}, \"\", nil},\n\t\t{\"-123.456\", \u0026Value{t: TypeNumber, s: \"-123.456\"}, \"\", nil},\n\t\t{\"\\\"hello\\\"\", \u0026Value{t: typeRawString, s: \"hello\"}, \"\", nil},\n\t\t{\"{\\\"foo\\\":\\\"bar\\\"}\", \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: typeRawString, s: \"bar\"}}}}}, \"\", nil},\n\t\t{\"[1,2,3]\", \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}}, \"\", nil},\n\n\t\t// Valid JSON values with trailing data.\n\t\t{\"nullx\", valueNull, \"x\", nil},\n\t\t{\"truex\", valueTrue, \"x\", nil},\n\t\t{\"falsex\", valueFalse, \"x\", nil},\n\t\t{\"123x\", \u0026Value{t: TypeNumber, s: \"123\"}, \"x\", nil},\n\t\t{\"-123.456x\", \u0026Value{t: TypeNumber, s: \"-123.456\"}, \"x\", nil},\n\t\t{\"\\\"hello\\\"x\", \u0026Value{t: typeRawString, s: \"hello\"}, \"x\", nil},\n\t\t{\"{\\\"foo\\\":\\\"bar\\\"}x\", \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: typeRawString, s: \"bar\"}}}}}, \"x\", nil},\n\t\t{\"[1,2,3]x\", \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}}, \"x\", nil},\n\n\t\t// NaN value.\n\t\t{\"NaN\", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"\", nil},\n\t\t{\"nan\", \u0026Value{t: TypeNumber, s: \"nan\"}, \"\", nil},\n\t\t{\"NAN\", \u0026Value{t: TypeNumber, s: \"NAN\"}, \"\", nil},\n\n\t\t// Unexpected values.\n\t\t{\"t\", nil, \"t\", fmt.Errorf(\"unexpected value found: \\\"t\\\"\")},\n\t\t{\"f\", nil, \"f\", fmt.Errorf(\"unexpected value found: \\\"f\\\"\")},\n\t\t{\"n\", nil, \"n\", fmt.Errorf(\"unexpected value found: \\\"n\\\"\")},\n\t}\n\n\tc := \u0026cache{}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tgot, tail, err := parseValue(tt.input, c, 0)\n\t\t\tif fmt.Sprintf(\"%v\", err) != fmt.Sprintf(\"%v\", tt.err) {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, want %v\", tt.input, err, tt.err)\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"parseValue(%q) tail = %q, want %q\", tt.input, tail, tt.tail)\n\t\t\t}\n\t\t\tif got == nil \u0026\u0026 tt.want == nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got == nil || tt.want == nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) got = %v, want %v\", tt.input, got, tt.want)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got.t != tt.want.t {\n\t\t\t\tt.Errorf(\"parseValue(%q) got type = %v, want %v\", tt.input, got.t, tt.want.t)\n\t\t\t}\n\t\t\tif got.s != tt.want.s {\n\t\t\t\tt.Errorf(\"parseValue(%q) got string = %q, want %q\", tt.input, got.s, tt.want.s)\n\t\t\t}\n\t\t\tif len(got.a) != len(tt.want.a) {\n\t\t\t\tt.Errorf(\"parseValue(%q) got array len = %d, want %d\", tt.input, len(got.a), len(tt.want.a))\n\t\t\t}\n\t\t\tif len(got.o.kvs) != len(tt.want.o.kvs) {\n\t\t\t\tt.Errorf(\"parseValue(%q) got object len = %d, want %d\", tt.input, len(got.o.kvs), len(tt.want.o.kvs))\n\t\t\t}\n\t\t})\n\t}\n}\n","ff29818ed9c5eb2e04b751c3ad5a474c":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Empty string\n\t\t{\"\", nil, \"\", fmt.Errorf(\"cannot parse empty string\")},\n\n\t\t// Invalid JSON\n\t\t{\"abc\", nil, \"abc\", fmt.Errorf(\"cannot parse number: cannot parse number: abc\")},\n\n\t\t// True\n\t\t{\"true\", valueTrue, \"\", nil},\n\t\t{\"truexxx\", valueTrue, \"xxx\", nil},\n\n\t\t// False\n\t\t{\"false\", valueFalse, \"\", nil},\n\t\t{\"falsexxx\", valueFalse, \"xxx\", nil},\n\n\t\t// Null\n\t\t{\"null\", valueNull, \"\", nil},\n\t\t{\"nullxxx\", valueNull, \"xxx\", nil},\n\n\t\t// NaN\n\t\t{\"NaN\", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"\", nil},\n\t\t{\"NaNxxx\", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"xxx\", nil},\n\n\t\t// String\n\t\t{`\"abc\"`, \u0026Value{t: typeRawString, s: \"abc\"}, \"\", nil},\n\t\t{`\"abc\"xxx`, \u0026Value{t: typeRawString, s: \"abc\"}, \"xxx\", nil},\n\n\t\t// Number\n\t\t{\"123\", \u0026Value{t: TypeNumber, s: \"123\"}, \"\", nil},\n\t\t{\"123xxx\", \u0026Value{t: TypeNumber, s: \"123\"}, \"xxx\", nil},\n\n\t\t// Array\n\t\t{\"[123]\", \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"123\"}}}, \"\", nil},\n\t\t{\"[123]xxx\", \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"123\"}}}, \"xxx\", nil},\n\n\t\t// Object\n\t\t// Note that parseValue itself doesn't parse objects, it delegates to parseObject.\n\t\t// So we're only testing that it correctly identifies the object start and delegates.\n\t\t{`{\"foo\":\"bar\"}`, nil, \"\", nil},\n\t\t{`{\"foo\":\"bar\"}xxx`, nil, \"\", nil},\n\t}\n\n\tc := \u0026cache{}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tgot, tail, err := parseValue(tt.input, c, 0)\n\n\t\t\tif tt.err != nil {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"Expected error, got nil\")\n\t\t\t\t} else if err.Error() != tt.err.Error() {\n\t\t\t\t\tt.Errorf(\"Expected error %q, got %q\", tt.err, err)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"Expected tail %q, got %q\", tt.tail, tail)\n\t\t\t}\n\n\t\t\tif got == nil \u0026\u0026 tt.want == nil {\n\t\t\t\treturn // Both nil, nothing more to check\n\t\t\t} else if got == nil || tt.want == nil {\n\t\t\t\tt.Errorf(\"One of the values is nil: got %v, want %v\", got, tt.want)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Compare types and values\n\t\t\tif got.t != tt.want.t {\n\t\t\t\tt.Errorf(\"Expected type %v, got %v\", tt.want.t, got.t)\n\t\t\t}\n\n\t\t\tswitch got.t {\n\t\t\tcase typeRawString, TypeNumber:\n\t\t\t\tif got.s != tt.want.s {\n\t\t\t\t\tt.Errorf(\"Expected value %q, got %q\", tt.want.s, got.s)\n\t\t\t\t}\n\t\t\t// Add more cases for other types as needed\n\t\t\t}\n\t\t})\n\t}\n}","ff2e64941735c4b5b5fb0f73d2564232":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetUint(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tjson  string\n\t\tkeys  []string\n\t\twant  uint\n\t\twant1 bool\n\t}{\n\t\t{\n\t\t\tname:  \"simple\",\n\t\t\tjson:  `{\"foo\": 123}`,\n\t\t\tkeys:  []string{\"foo\"},\n\t\t\twant:  123,\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"nested\",\n\t\t\tjson:  `{\"foo\": {\"bar\": {\"baz\": 123}}}`,\n\t\t\tkeys:  []string{\"foo\", \"bar\", \"baz\"},\n\t\t\twant:  123,\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array\",\n\t\t\tjson:  `{\"foo\": [123, 456]}`,\n\t\t\tkeys:  []string{\"foo\", \"1\"},\n\t\t\twant:  456,\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"non-existing key\",\n\t\t\tjson:  `{\"foo\": 123}`,\n\t\t\tkeys:  []string{\"bar\"},\n\t\t\twant:  0,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"invalid value type\",\n\t\t\tjson:  `{\"foo\": \"bar\"}`,\n\t\t\tkeys:  []string{\"foo\"},\n\t\t\twant:  0,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"decimal array index\",\n\t\t\tjson:  `{\"foo\": [123, 456]}`,\n\t\t\tkeys:  []string{\"foo\", \"1.0\"},\n\t\t\twant:  456,\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"out of range array index\",\n\t\t\tjson:  `{\"foo\": [123, 456]}`,\n\t\t\tkeys:  []string{\"foo\", \"2\"},\n\t\t\twant:  0,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"negative array index\",\n\t\t\tjson:  `{\"foo\": [123, 456]}`,\n\t\t\tkeys:  []string{\"foo\", \"-1\"},\n\t\t\twant:  0,\n\t\t\twant1: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tvar p Parser\n\t\t\tv, err := p.Parse(tt.json)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Parse() error = %v, wantErr %v\", err, nil)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tgot := v.GetUint(tt.keys...)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"GetUint() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","ff75975ea5cedab01a573834e62bf964":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantN    string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Basic cases.\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"123.456\", \"123.456\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"123e45\", \"123e45\", \"\", nil},\n\t\t{\"123E45\", \"123E45\", \"\", nil},\n\t\t{\"123.456e78\", \"123.456e78\", \"\", nil},\n\t\t{\"123.456E78\", \"123.456E78\", \"\", nil},\n\t\t{\"+123\", \"+123\", \"\", nil},\n\t\t{\"+123.456\", \"+123.456\", \"\", nil},\n\n\t\t// Trailing garbage.\n\t\t{\"123x\", \"123\", \"x\", nil},\n\t\t{\"123.456x\", \"123.456\", \"x\", nil},\n\n\t\t// Leading garbage.\n\t\t{\"x123\", \"\", \"x123\", fmt.Errorf(`unexpected char: \"x\"`)},\n\t\t{\"x123.456\", \"\", \"x123.456\", fmt.Errorf(`unexpected char: \"x\"`)},\n\n\t\t// Invalid numbers.\n\t\t{\"\", \"\", \"\", fmt.Errorf(`unexpected char: \"\"`)},\n\t\t{\"+\", \"\", \"+\", fmt.Errorf(`unexpected char: \"+\"`)},\n\t\t{\"-\", \"\", \"-\", fmt.Errorf(`unexpected char: \"-\"`)},\n\t\t{\".\", \"\", \".\", fmt.Errorf(`unexpected char: \".\"`)},\n\t\t{\"e\", \"\", \"e\", fmt.Errorf(`unexpected char: \"e\"`)},\n\t\t{\"E\", \"\", \"E\", fmt.Errorf(`unexpected char: \"E\"`)},\n\n\t\t// Special cases: \"inf\", \"Inf\", \"inF\", \"INf\", etc.\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"Inf\", \"Inf\", \"\", nil},\n\t\t{\"inF\", \"inF\", \"\", nil},\n\t\t{\"INf\", \"INf\", \"\", nil},\n\t\t{\"infx\", \"inf\", \"x\", nil},\n\t\t{\"Infx\", \"Inf\", \"x\", nil},\n\t\t{\"inFx\", \"inF\", \"x\", nil},\n\t\t{\"INfx\", \"INf\", \"x\", nil},\n\n\t\t// Special cases: \"nan\", \"NaN\", etc.\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"NaN\", \"NaN\", \"\", nil},\n\t\t{\"naN\", \"naN\", \"\", nil},\n\t\t{\"NAN\", \"NAN\", \"\", nil},\n\t\t{\"nanx\", \"nan\", \"x\", nil},\n\t\t{\"NaNx\", \"NaN\", \"x\", nil},\n\t\t{\"naNx\", \"naN\", \"x\", nil},\n\t\t{\"NANx\", \"NAN\", \"x\", nil},\n\t}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tgotN, gotTail, gotErr := parseRawNumber(tt.input)\n\t\t\tif gotN != tt.wantN {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got number = %q, want %q\", tt.input, gotN, tt.wantN)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got tail = %q, want %q\", tt.input, gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif gotErr == nil \u0026\u0026 tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got err = nil, want %q\", tt.input, tt.wantErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr == nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got err = %q, want nil\", tt.input, gotErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got err = %q, want %q\", tt.input, gotErr, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}\n"}