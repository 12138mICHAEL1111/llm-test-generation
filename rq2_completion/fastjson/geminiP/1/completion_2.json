{"00278ae3692fa09d9f958ad63beba116":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Exists(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tjson  string\n\t\tkeys  []string\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname:  \"simple_object_existing_key\",\n\t\t\tjson:  `{\"foo\": \"bar\"}`,\n\t\t\tkeys:  []string{\"foo\"},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"simple_object_nonexisting_key\",\n\t\t\tjson:  `{\"foo\": \"bar\"}`,\n\t\t\tkeys:  []string{\"baz\"},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"nested_object_existing_key\",\n\t\t\tjson:  `{\"foo\": {\"bar\": \"baz\"}}`,\n\t\t\tkeys:  []string{\"foo\", \"bar\"},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"nested_object_nonexisting_key\",\n\t\t\tjson:  `{\"foo\": {\"bar\": \"baz\"}}`,\n\t\t\tkeys:  []string{\"foo\", \"qux\"},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array_existing_index\",\n\t\t\tjson:  `[\"foo\", \"bar\"]`,\n\t\t\tkeys:  []string{\"1\"},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array_nonexisting_index\",\n\t\t\tjson:  `[\"foo\", \"bar\"]`,\n\t\t\tkeys:  []string{\"2\"},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array_out_of_bounds_index\",\n\t\t\tjson:  `[\"foo\", \"bar\"]`,\n\t\t\tkeys:  []string{\"10\"},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"nested_array_existing_index\",\n\t\t\tjson:  `{\"foo\": [\"bar\", \"baz\"]}`,\n\t\t\tkeys:  []string{\"foo\", \"1\"},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"nested_array_nonexisting_index\",\n\t\t\tjson:  `{\"foo\": [\"bar\", \"baz\"]}`,\n\t\t\tkeys:  []string{\"foo\", \"2\"},\n\t\t\twant: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv, _ := ParseBytes([]byte(tt.json))\n\t\t\tif got := v.Exists(tt.keys...); got != tt.want {\n\t\t\t\tt.Errorf(\"Exists() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","0144670a849d18faf8a4f3ce07fa7a09":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_Visit(t *testing.T) {\n\ttype args struct {\n\t\tf func(key []byte, v *Value)\n\t}\n\ttests := []struct {\n\t\tname string\n\t\to    *Object\n\t\targs args\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\to:    \u0026Object{},\n\t\t\targs: args{\n\t\t\t\tf: func(key []byte, v *Value) {\n\t\t\t\t\tt.Errorf(\"f() should not be called for empty object\")\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"one element object\",\n\t\t\to: \u0026Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t},\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tf: func(key []byte, v *Value) {\n\t\t\t\t\tif string(key) != \"key1\" {\n\t\t\t\t\t\tt.Errorf(\"unexpected key: %s, expected: %s\", string(key), \"key1\")\n\t\t\t\t\t}\n\t\t\t\t\tif v.Type() != TypeString {\n\t\t\t\t\t\tt.Errorf(\"unexpected value type: %v, expected: %v\", v.Type(), TypeString)\n\t\t\t\t\t}\n\t\t\t\t\tif v.s != \"value1\" {\n\t\t\t\t\t\tt.Errorf(\"unexpected value: %s, expected: %s\", v.s, \"value1\")\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements object\",\n\t\t\to: \u0026Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t{k: \"key3\", v: \u0026Value{t: TypeObject}},\n\t\t\t\t},\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tf: func(key []byte, v *Value) {\n\t\t\t\t\tswitch string(key) {\n\t\t\t\t\tcase \"key1\":\n\t\t\t\t\t\tif v.Type() != TypeString {\n\t\t\t\t\t\t\tt.Errorf(\"unexpected value type: %v, expected: %v\", v.Type(), TypeString)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif v.s != \"value1\" {\n\t\t\t\t\t\t\tt.Errorf(\"unexpected value: %s, expected: %s\", v.s, \"value1\")\n\t\t\t\t\t\t}\n\t\t\t\t\tcase \"key2\":\n\t\t\t\t\t\tif v.Type() != TypeNumber {\n\t\t\t\t\t\t\tt.Errorf(\"unexpected value type: %v, expected: %v\", v.Type(), TypeNumber)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif v.s != \"123\" {\n\t\t\t\t\t\t\tt.Errorf(\"unexpected value: %s, expected: %s\", v.s, \"123\")\n\t\t\t\t\t\t}\n\t\t\t\t\tcase \"key3\":\n\t\t\t\t\t\tif v.Type() != TypeObject {\n\t\t\t\t\t\t\tt.Errorf(\"unexpected value type: %v, expected: %v\", v.Type(), TypeObject)\n\t\t\t\t\t\t}\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tt.Errorf(\"unexpected key: %s\", string(key))\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\ttt.o.Visit(tt.args.f)\n\t\t})\n\t}\n}","02a8269c4ee18a4fbb8c09411ab1841f":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestValue_Uint(t *testing.T) {\n\ttests := []struct {\n\t\tinput       string\n\t\twantUint    uint\n\t\twantErr     bool\n\t\twantErrStr string\n\t}{\n\t\t{\n\t\t\tinput:    \"123\",\n\t\t\twantUint: 123,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"123\"`,\n\t\t\twantErr:     true,\n\t\t\twantErrStr: \"value doesn't contain number; it contains string\",\n\t\t},\n\t\t{\n\t\t\tinput:    \"123.456\",\n\t\t\twantErr:     true,\n\t\t\twantErrStr: \"number \\\"123.456\\\" doesn't fit uint\",\n\t\t},\n\t\t{\n\t\t\tinput:    \"-123\",\n\t\t\twantErr:     true,\n\t\t\twantErrStr: \"number \\\"-123\\\" doesn't fit uint\",\n\t\t},\n\t\t{\n\t\t\tinput:    \"9223372036854775808\", // Exceeds max uint64\n\t\t\twantErr:     true,\n\t\t\twantErrStr: \"number \\\"9223372036854775808\\\" doesn't fit uint\",\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tv := ParseString(tt.input)\n\t\t\tgot, err := v.Uint()\n\n\t\t\tif tt.wantErr {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"expected error, got nil\")\n\t\t\t\t} else if err.Error() != tt.wantErrStr {\n\t\t\t\t\tt.Errorf(\"want error %q; got %q\", tt.wantErrStr, err.Error())\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t}\n\n\t\t\tif got != tt.wantUint {\n\t\t\t\tt.Errorf(\"wantUint %v; got %v\", tt.wantUint, got)\n\t\t\t}\n\t\t})\n\t}\n}","030050b2471e57cd0d6c0d511578aae8":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWS(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"  foo\", \"foo\"},\n\t\t{\"\\n\\tbar\", \"bar\"},\n\t\t{\" \\r\\n baz\", \"baz\"},\n\t\t{\"qux  \", \"qux  \"},\n\t\t{\"\", \"\"},\n\t\t{\"0x20\", \"0x20\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := skipWS(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"skipWS(%q) = %q, expected %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}","030088fada765edfb609350d13c2384f":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tns    string\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Valid numbers\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"123.456\", \"123.456\", \"\", nil},\n\t\t{\"1.23e4\", \"1.23e4\", \"\", nil},\n\t\t{\"1.23E-4\", \"1.23E-4\", \"\", nil},\n\n\t\t// Valid numbers with trailing characters\n\t\t{\"123a\", \"123\", \"a\", nil},\n\t\t{\"-123b\", \"-123\", \"b\", nil},\n\t\t{\"123.456c\", \"123.456\", \"c\", nil},\n\n\t\t// Invalid numbers\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t\t{\"a\", \"\", \"a\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\".\", \"\", \".\", fmt.Errorf(\"unexpected char: %q\", \".\")},\n\t\t{\"-\", \"\", \"-\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t\t{\"e\", \"\", \"e\", fmt.Errorf(\"unexpected char: %q\", \"e\")},\n\t\t{\"E\", \"\", \"E\", fmt.Errorf(\"unexpected char: %q\", \"E\")},\n\n\t\t// Special cases: inf, nan\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"+inf\", \"+inf\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"InF\", \"InF\", \"\", nil},\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"+nan\", \"\", \"+nan\", fmt.Errorf(\"unexpected char: %q\", \"+\")},\n\t\t{\"-nan\", \"\", \"-nan\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t\t{\"NAN\", \"NAN\", \"\", nil},\n\n\t\t// Special cases with trailing characters\n\t\t{\"infx\", \"inf\", \"x\", nil},\n\t\t{\"nanx\", \"nan\", \"x\", nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tns, tail, err := parseRawNumber(tt.input)\n\t\t\tif ns != tt.ns || tail != tt.tail || (err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = (%q, %q, %v), want (%q, %q, %v)\", tt.input, ns, tail, err, tt.ns, tt.tail, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}","033289b6ad4a2cc3c8f2036ab17e5a0b":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twant     *Value\n\t\twantRest string\n\t\twantErr  string\n\t}{\n\t\t{\n\t\t\tname:     \"empty array\",\n\t\t\tinput:    \"[]\",\n\t\t\twant:     \u0026Value{t: TypeArray, a: []*Value{}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"single element array\",\n\t\t\tinput:    \"[1]\",\n\t\t\twant:     \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple elements array\",\n\t\t\tinput:    \"[1,2,3]\",\n\t\t\twant:     \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"array with whitespace\",\n\t\t\tinput:    \" [ 1 , 2 , 3 ] \",\n\t\t\twant:     \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}},\n\t\t\twantRest: \" \",\n\t\t\twantErr:  \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"nested array\",\n\t\t\tinput:    \"[[1,2],[3,4]]\",\n\t\t\twant: \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}}},\n\t\t\t\t{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"3\"}, {t: TypeNumber, s: \"4\"}}},\n\t\t\t}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"missing closing bracket\",\n\t\t\tinput:    \"[1,2\",\n\t\t\twant:     nil,\n\t\t\twantRest: \"\",\n\t\t\twantErr:  \"unexpected end of array\",\n\t\t},\n\t\t{\n\t\t\tname:     \"missing comma\",\n\t\t\tinput:    \"[1 2]\",\n\t\t\twant:     nil,\n\t\t\twantRest: \"\",\n\t\t\twantErr:  \"missing ',' after array value\",\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid value\",\n\t\t\tinput:    \"[1,abc]\",\n\t\t\twant:     nil,\n\t\t\twantRest: \"\",\n\t\t\twantErr:  \"cannot parse array value: invalid number 'abc'\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, rest, err := parseArray(tt.input, c, 0)\n\n\t\t\tif tt.wantErr != \"\" {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"expected error, got nil\")\n\t\t\t\t} else if err.Error() != tt.wantErr {\n\t\t\t\t\tt.Errorf(\"got error %q, want %q\", err.Error(), tt.wantErr)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif rest != tt.wantRest {\n\t\t\t\tt.Errorf(\"got rest %q, want %q\", rest, tt.wantRest)\n\t\t\t}\n\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"got %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(a, b *Value) bool {\n\tif a == nil \u0026\u0026 b == nil {\n\t\treturn true\n\t}\n\tif a == nil || b == nil {\n\t\treturn false\n\t}\n\tif a.t != b.t {\n\t\treturn false\n\t}\n\tif a.t == TypeArray {\n\t\tif len(a.a) != len(b.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range a.a {\n\t\t\tif !equalValues(a.a[i], b.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\treturn a.s == b.s\n}\n","033e68fd7e13f2d9c2f9e28af7b159b4":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput  string\n\t\texpect string\n\t}{\n\t\t// Empty string.\n\t\t{\"\", \"\"},\n\n\t\t// String without escape sequences.\n\t\t{\"foobar\", \"foobar\"},\n\t\t{\"–±–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö\", \"–±–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö\"},\n\n\t\t// Escaped quotes.\n\t\t{`\"`, `\"`},\n\t\t{`\"\"`, `\"\"`},\n\t\t{`\"foo\"`, `\"foo\"`},\n\t\t{`\"foo\\\"bar\"`, `\"foo\\\"bar\"`},\n\t\t{`\"foo\\\\bar\"`, `\"foo\\\\bar\"`},\n\t\t{`\"foo\\bar\"`, `\"foo\\bar\"`},\n\t\t{`\"\\\"\"`, `\"\\\"\"`},\n\t\t{`\"\\\\\"`  , `\"\\\\\"`},\n\n\t\t// Escaped slash.\n\t\t{`\\/`, `\\/`},\n\t\t{`foo\\/bar`, `foo\\/bar`},\n\n\t\t// Escaped control chars.\n\t\t{`\\b`, \"\\b\"},\n\t\t{`\\f`, \"\\f\"},\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\r`, \"\\r\"},\n\t\t{`\\t`, \"\\t\"},\n\n\t\t// Valid hex escape sequences.\n\t\t{`\\x20`, \" \"},\n\t\t{`\\x20\\x21`, \" !\"},\n\n\t\t// Invalid hex escape sequences.\n\t\t{`\\x`, `\\x`},\n\t\t{`\\xx`, `\\xx`},\n\t\t{`\\x2`, `\\x2`},\n\t\t{`\\x2G`, `\\x2G`},\n\n\t\t// Valid unicode escape sequences.\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u0020\\u0021`, \" !\"},\n\t\t{`\\u03c0`, \"œÄ\"},\n\t\t{`\\u03c0\\u03c0`, \"œÄœÄ\"},\n\t\t// Surrogate pair.\n\t\t{`\\uD83D\\uDE01`, \"üòÅ\"},\n\n\t\t// Invalid unicode escape sequences.\n\t\t{`\\u`, `\\u`},\n\t\t{`\\uu`, `\\uu`},\n\t\t{`\\u00`, `\\u00`},\n\t\t{`\\u002`, `\\u002`},\n\t\t{`\\u002G`, `\\u002G`},\n\t\t{`\\uD83`, `\\uD83`},\n\t\t{`\\uD83D`, `\\uD83D`},\n\t\t{`\\uD83D\\u`, `\\uD83D\\u`},\n\t\t{`\\uD83D\\uDE`, `\\uD83D\\uDE`},\n\t\t{`\\uD83D\\uDE0`, `\\uD83D\\uDE0`},\n\t\t{`\\uD83D\\uDE0G`, `\\uD83D\\uDE0G`},\n\t\t// Broken surrogate pair.\n\t\t{`\\uD83D\\u0020`, `\\uD83D `},\n\t}\n\n\tfor i, test := range tests {\n\t\toutput := unescapeStringBestEffort(test.input)\n\t\tif test.expect != output {\n\t\t\tt.Errorf(\"Test %d failed - input: '%s', expect: '%s', got: '%s'\",\n\t\t\t\ti, test.input, test.expect, output)\n\t\t}\n\t}\n}","038822c39cb85eb822913d7b1c215e0d":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Empty string\n\t\t{\"\", nil, \"\", fmt.Errorf(\"cannot parse empty string\")},\n\t\t// Invalid JSON\n\t\t{\"{\", nil, \"{\", fmt.Errorf(\"cannot parse object: missing '}'\")},\n\t\t// Object\n\t\t{`{\"foo\":\"bar\"}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: typeRawString, s: \"bar\"}}}}}, \"\", nil},\n\t\t// Array\n\t\t{`[1,2,3]`, \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}}, \"\", nil},\n\t\t// String\n\t\t{`\"hello\"`, \u0026Value{t: typeRawString, s: \"hello\"}, \"\", nil},\n\t\t// True\n\t\t{\"true\", valueTrue, \"\", nil},\n\t\t// False\n\t\t{\"false\", valueFalse, \"\", nil},\n\t\t// Null\n\t\t{\"null\", valueNull, \"\", nil},\n\t\t// Number\n\t\t{\"123\", \u0026Value{t: TypeNumber, s: \"123\"}, \"\", nil},\n\t\t// NaN\n\t\t{\"NaN\", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"\", nil},\n\t\t// Trailing whitespace\n\t\t{\"true \", valueTrue, \" \", nil},\n\t\t// Nested structures\n\t\t{`{\"foo\":[1,{\"bar\":\"baz\"}]}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeObject, o: Object{kvs: []kv{{k: \"bar\", v: \u0026Value{t: typeRawString, s: \"baz\"}}}}}}}}}}}, \"\", nil},\n\t}\n\n\tc := \u0026cache{}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tgot, tail, err := parseValue(tt.input, c, 0)\n\t\t\tif (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"parseValue(%q) error mismatch: got %v, want %v\", tt.input, err, tt.err)\n\t\t\t}\n\t\t\tif got != nil \u0026\u0026 tt.want != nil \u0026\u0026 got.String() != tt.want.String() {\n\t\t\t\tt.Errorf(\"parseValue(%q) got = %v, want %v\", tt.input, got, tt.want)\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"parseValue(%q) tail mismatch: got %q, want %q\", tt.input, tail, tt.tail)\n\t\t\t}\n\t\t})\n\t}\n}","04d0d806717ea36eb17f2b72144f32a0":"package fastjson\n\nimport \"testing\"\n\nfunc TestValue_GetBool(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tjson  string\n\t\tkeys  []string\n\t\twant  bool\n\t\twant1 bool\n\t}{\n\t\t{\n\t\t\tname:  \"simple true\",\n\t\t\tjson:  `{\"foo\":true}`,\n\t\t\tkeys:  []string{\"foo\"},\n\t\t\twant:  true,\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"simple false\",\n\t\t\tjson:  `{\"foo\":false}`,\n\t\t\tkeys:  []string{\"foo\"},\n\t\t\twant:  false,\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"number true\",\n\t\t\tjson:  `{\"foo\":123}`,\n\t\t\tkeys:  []string{\"foo\"},\n\t\t\twant:  false,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"string true\",\n\t\t\tjson:  `{\"foo\":\"true\"}`,\n\t\t\tkeys:  []string{\"foo\"},\n\t\t\twant:  false,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"nested true\",\n\t\t\tjson:  `{\"foo\":{\"bar\":true}}`,\n\t\t\tkeys:  []string{\"foo\", \"bar\"},\n\t\t\twant:  true,\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"nested false\",\n\t\t\tjson:  `{\"foo\":{\"bar\":false}}`,\n\t\t\tkeys:  []string{\"foo\", \"bar\"},\n\t\t\twant:  false,\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array true\",\n\t\t\tjson:  `{\"foo\":[true]}`,\n\t\t\tkeys:  []string{\"foo\", \"0\"},\n\t\t\twant:  true,\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array false\",\n\t\t\tjson:  `{\"foo\":[false]}`,\n\t\t\tkeys:  []string{\"foo\", \"0\"},\n\t\t\twant:  false,\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"missing key\",\n\t\t\tjson:  `{\"foo\":true}`,\n\t\t\tkeys:  []string{\"bar\"},\n\t\t\twant:  false,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"null\",\n\t\t\tjson:  `null`,\n\t\t\tkeys:  []string{\"foo\"},\n\t\t\twant:  false,\n\t\t\twant1: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tvar p Parser\n\t\t\tv, err := p.Parse(tt.json)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Parse() error = %v, wantErr %v\", err, nil)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got := v.GetBool(tt.keys...); got != tt.want {\n\t\t\t\tt.Errorf(\"GetBool() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","04d6e97909589953719868a25b6e57cd":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey string\n\t\ttail string\n\t\terr error\n\t}{\n\t\t// Basic cases\n\t\t{`\"foo\": \"bar\"`, \"foo\", `: \"bar\"`, nil},\n\t\t{`\"key\": 123`, \"key\", `: 123`, nil},\n\t\t{`\"a\\tb\": true`, \"a\\tb\", `: true`, nil},\n\n\t\t// Empty key\n\t\t{`\"\": \"value\"`, \"\", `: \"value\"`, nil},\n\n\t\t// No closing quote\n\t\t{`\"foo: \"bar\"`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\n\t\t// Escaped quotes within the key\n\t\t// Note: parseRawKey doesn't handle escaped quotes, it should delegate to the slow path\n\t\t// {`\"\\\\\"foo\\\\\"\": \"bar\"`, `\"foo\"`, `: \"bar\"`, nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test #%d\", i+1), func(t *testing.T) {\n\t\t\tkey, tail, err := parseRawKey(tt.input)\n\n\t\t\tif key != tt.key {\n\t\t\t\tt.Errorf(\"expected key %q, got %q\", tt.key, key)\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"expected tail %q, got %q\", tt.tail, tail)\n\t\t\t}\n\t\t\tif err == nil \u0026\u0026 tt.err != nil {\n\t\t\t\tt.Errorf(\"expected error %v, got nil\", tt.err)\n\t\t\t} else if err != nil \u0026\u0026 tt.err == nil {\n\t\t\t\tt.Errorf(\"expected no error, got %v\", err)\n\t\t\t} else if err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error() {\n\t\t\t\tt.Errorf(\"expected error %v, got %v\", tt.err, err)\n\t\t\t}\n\t\t})\n\t}\n}","04dc8272468e903ebae88b5145747003":"package fastjson\n\nimport \"testing\"\n\nfunc TestObject_reset(t *testing.T) {\n\to := \u0026Object{\n\t\tkvs: []kv{\n\t\t\t{\"key1\", \u0026Value{s: \"value1\"}},\n\t\t\t{\"key2\", \u0026Value{s: \"value2\"}},\n\t\t},\n\t\tkeysUnescaped: true,\n\t}\n\n\to.reset()\n\n\tif len(o.kvs) != 0 {\n\t\tt.Errorf(\"Expected o.kvs to be empty after reset, got length %d\", len(o.kvs))\n\t}\n\tif o.keysUnescaped {\n\t\tt.Error(\"Expected o.keysUnescaped to be false after reset\")\n\t}\n}\n","0579ad30148187ef9637d5bc4d216b67":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"raw string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"raw string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"12345\",\n\t\t\t},\n\t\t\twant: []byte(\"12345\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"element1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"[\\\"element1\\\",123]\"),\n\t\t},\n\t}\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := test.v.MarshalTo(nil)\n\t\t\tif string(got) != string(test.want) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %v, want %v\", string(got), string(test.want))\n\t\t\t}\n\t\t})\n\t}\n}","05d5d41f64663ccd061a86a2c50439e7":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantStr  string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Basic cases\n\t\t{`\"foo\"bar`, `foo`, `bar`, nil},\n\t\t{`\"foo\" bar`, `foo`, ` bar`, nil},\n\t\t{`\"foo\"  bar`, `foo`, `  bar`, nil},\n\t\t{`\"foo\"`, `foo`, ``, nil},\n\t\t{`\"foo`, ``, ``, fmt.Errorf(`missing closing '\"'`)},\n\n\t\t// Escaped quotes\n\t\t{`\"fo\\o\"bar`, `fo\\o`, `bar`, nil},\n\t\t{`\"fo\\\\o\"bar`, `fo\\\\o`, `bar`, nil},\n\t\t{`\"fo\\\"o\"bar`, `fo\"o`, `bar`, nil},\n\t\t{`\"fo\\\\\\\"o\"bar`, `fo\\\"o`, `bar`, nil},\n\t\t{`\"fo\\\\\\\\\"o\"bar`, `fo\\\\\"o`, `bar`, nil},\n\n\t\t// Empty strings\n\t\t{`\"\"bar`, ``, `bar`, nil},\n\t\t{`\"\" bar`, ``, ` bar`, nil},\n\t\t{`\"\"`, ``, ``, nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tgotStr, gotTail, gotErr := parseRawString(tt.input)\n\t\t\tif gotStr != tt.wantStr || gotTail != tt.wantTail || (gotErr != nil \u0026\u0026 tt.wantErr == nil) || (gotErr == nil \u0026\u0026 tt.wantErr != nil) || (gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error()) {\n\t\t\t\tt.Errorf(\"input: %s\\ngot:    (%s, %s, %v)\\nwant:   (%s, %s, %v)\",\n\t\t\t\t\ttt.input, gotStr, gotTail, gotErr, tt.wantStr, tt.wantTail, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","05f386d6426b2ba51ab1618802020780":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic escapes\n\t\t{`\\t\\b\\n\\f\\r\\\\\\/\\`, \"\\t\\b\\n\\f\\r\\\\/\\\"\"},\n\t\t{`\\`, `\\`},\n\t\t{`\\\\`, `\\\\`},\n\n\t\t// Unicode escapes\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A0`, \"\\u00A0\"},\n\t\t{`\\uFFFF`, \"\\uFFFF\"},\n\t\t{`\\uD83D\\uDE02`, \"üòÇ\"}, // Surrogate pair\n\n\t\t// Invalid escapes\n\t\t{`\\u`, `\\u`},\n\t\t{`\\u002`, `\\u002`},\n\t\t{`\\uD83D`, `\\uD83D`},\n\t\t{`\\uD83D\\u`, `\\uD83D\\u`},\n\t\t{`\\uD83D\\uDE0`, `\\uD83D\\uDE0`},\n\n\t\t// Mixed content\n\t\t{`Hello\\tworld\\n`, \"Hello\\tworld\\n\"},\n\t\t{`\\u00A92023`, \"¬©2023\"},\n\t\t{`Path\\u0020with\\u0020spaces`, \"Path with spaces\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Input: %q, Expected: %q, Actual: %q\", test.input, test.expected, actual)\n\t\t}\n\t}\n}","07b09c2d02a2a43bf3bdfe6d215f6090":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestValue_Int(t *testing.T) {\n\ttests := []struct {\n\t\tinput       string\n\t\twant        int\n\t\twantErr     bool\n\t\terrorString string\n\t}{\n\t\t{\n\t\t\tinput:       `123`,\n\t\t\twant:        123,\n\t\t\twantErr:     false,\n\t\t\terrorString: \"\",\n\t\t},\n\t\t{\n\t\t\tinput:       `-123`,\n\t\t\twant:        -123,\n\t\t\twantErr:     false,\n\t\t\terrorString: \"\",\n\t\t},\n\t\t{\n\t\t\tinput:       `9223372036854775807`,\n\t\t\twant:        0,\n\t\t\twantErr:     true,\n\t\t\terrorString: \"number \\\"9223372036854775807\\\" doesn't fit int\",\n\t\t},\n\t\t{\n\t\t\tinput:       `-9223372036854775808`,\n\t\t\twant:        0,\n\t\t\twantErr:     true,\n\t\t\terrorString: \"number \\\"-9223372036854775808\\\" doesn't fit int\",\n\t\t},\n\t\t{\n\t\t\tinput:       `\"123\"`,\n\t\t\twant:        0,\n\t\t\twantErr:     true,\n\t\t\terrorString: \"value doesn't contain number; it contains string\",\n\t\t},\n\t\t{\n\t\t\tinput:       `null`,\n\t\t\twant:        0,\n\t\t\twantErr:     true,\n\t\t\terrorString: \"value doesn't contain number; it contains null\",\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tv := \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: tt.input,\n\t\t\t}\n\n\t\t\tgot, err := v.Int()\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Int() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Int() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif tt.wantErr \u0026\u0026 err.Error() != tt.errorString {\n\t\t\t\tt.Errorf(\"Int() error string = %v, want %v\", err.Error(), tt.errorString)\n\t\t\t}\n\t\t})\n\t}\n}","0939d19a198a44e82a69f74a6213352e":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey   string\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Basic cases\n\t\t{`\"foo\"bar`, \"foo\", \"bar\", nil},\n\t\t{`\"fo\\\"o\"bar`, `fo\"o`, \"bar\", nil},\n\t\t{`\"foo\"`, \"foo\", \"\", nil},\n\t\t{`\"\"bar`, \"\", \"bar\", nil},\n\n\t\t// Escaped quotes\n\t\t{`\"foo\\\\\"bar\"baz`, `foo\\bar`, \"baz\", nil},\n\t\t{`\"foo\\\\\\\\\"bar\"baz`, `foo\\\\`, `bar\"baz`, nil},\n\n\t\t// Missing closing quote\n\t\t{`\"foobar`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo\\\"bar`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\n\t\t// Empty strings\n\t\t{`\"\"`, \"\", \"\", nil},\n\t\t{`\"`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d:%s\", i, tt.input), func(t *testing.T) {\n\t\t\tkey, tail, err := parseRawString(tt.input)\n\t\t\tif key != tt.key || tail != tt.tail || !errorEqual(err, tt.err) {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = (%q, %q, %v), want (%q, %q, %v)\", tt.input, key, tail, err, tt.key, tt.tail, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc errorEqual(e1, e2 error) bool {\n\tif e1 == nil \u0026\u0026 e2 == nil {\n\t\treturn true\n\t}\n\tif e1 == nil || e2 == nil {\n\t\treturn false\n\t}\n\treturn e1.Error() == e2.Error()\n}\n","09ab002c025559c976b4c2b3658e55f7":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\tvar p Parser\n\n\ttestCases := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\terr   error\n\t}{\n\t\t// Test cases for various valid JSON inputs\n\t\t{\"{}\", \u0026Value{t: TypeObject, o: Object{}}, nil},\n\t\t{\"[]\", \u0026Value{t: TypeArray, a: []*Value{}}, nil},\n\t\t{`\"hello\"`, \u0026Value{t: TypeString, s: \"hello\"}, nil},\n\t\t{\"123\", \u0026Value{t: TypeNumber, s: \"123\"}, nil},\n\t\t{\"true\", \u0026Value{t: TypeTrue}, nil},\n\t\t{\"false\", \u0026Value{t: TypeFalse}, nil},\n\t\t{\"null\", \u0026Value{t: TypeNull}, nil},\n\t\t// Test cases for invalid JSON inputs\n\t\t{\"{\", nil, nil},\n\t\t{\"[\", nil, nil},\n\t\t{`\"hello`, nil, nil},\n\t\t{\"123a\", nil, nil},\n\t\t// Test cases for unexpected tail\n\t\t{`\"hello\"  `, nil, nil},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tgot, err := p.Parse(tc.input)\n\n\t\tif tc.err != nil {\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"Test case %d: Expected error for input %q, but got nil\", i, tc.input)\n\t\t\t}\n\t\t\t// Further error message comparison can be added if needed\n\t\t\tcontinue\n\t\t}\n\n\t\tif err != tc.err {\n\t\t\tt.Errorf(\"Test case %d: Expected error %v for input %q, but got %v\", i, tc.err, tc.input, err)\n\t\t}\n\n\t\tif got == nil \u0026\u0026 tc.want == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tif got.Type() != tc.want.Type() {\n\t\t\tt.Errorf(\"Test case %d: Type mismatch for input %q. Got %v, want %v\", i, tc.input, got.Type(), tc.want.Type())\n\t\t}\n\n\t\tswitch got.Type() {\n\t\tcase TypeObject:\n\t\t\tif len(got.o.kvs) != len(tc.want.o.kvs) {\n\t\t\t\tt.Errorf(\"Test case %d: Object length mismatch for input %q. Got %d, want %d\", i, tc.input, len(got.o.kvs), len(tc.want.o.kvs))\n\t\t\t}\n\t\tcase TypeArray:\n\t\t\tif len(got.a) != len(tc.want.a) {\n\t\t\t\tt.Errorf(\"Test case %d: Array length mismatch for input %q. Got %d, want %d\", i, tc.input, len(got.a), len(tc.want.a))\n\t\t\t}\n\t\tcase TypeString:\n\t\t\tif got.s != tc.want.s {\n\t\t\t\tt.Errorf(\"Test case %d: String value mismatch for input %q. Got %q, want %q\", i, tc.input, got.s, tc.want.s)\n\t\t\t}\n\t\tcase TypeNumber:\n\t\t\tif got.s != tc.want.s {\n\t\t\t\tt.Errorf(\"Test case %d: Number value mismatch for input %q. Got %q, want %q\", i, tc.input, got.s, tc.want.s)\n\t\t\t}\n\t\t}\n\t}\n}","0a78ec200670858320d02e398f83adb6":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Empty string\n\t\t{\"\", nil, \"\", fmt.Errorf(\"cannot parse empty string\")},\n\t\t// Invalid JSON\n\t\t{\"{\", nil, \"{\", fmt.Errorf(\"cannot parse object: missing '}'\")},\n\t\t// Simple object\n\t\t{`{\"foo\":\"bar\"}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: typeRawString, s: \"bar\"}}}}}}, \"\", nil},\n\t\t// Simple array\n\t\t{`[1,2,3]`, \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}}, \"\", nil},\n\t\t// String\n\t\t{`\"hello\"`, \u0026Value{t: typeRawString, s: \"hello\"}, \"\", nil},\n\t\t// True\n\t\t{\"true\", valueTrue, \"\", nil},\n\t\t// False\n\t\t{\"false\", valueFalse, \"\", nil},\n\t\t// Null\n\t\t{\"null\", valueNull, \"\", nil},\n\t\t// Number\n\t\t{\"123\", \u0026Value{t: TypeNumber, s: \"123\"}, \"\", nil},\n\t\t// NaN\n\t\t{\"NaN\", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"\", nil},\n\t\t// Trailing whitespace\n\t\t{`\"hello\" `, \u0026Value{t: typeRawString, s: \"hello\"}, \" \", nil},\n\t\t// Nested object\n\t\t{`{\"foo\":{\"bar\":\"baz\"}}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"bar\", v: \u0026Value{t: typeRawString, s: \"baz\"}}}}}}}}}}, \"\", nil},\n\t}\n\n\tc := \u0026cache{}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tgot, tail, err := parseValue(tt.input, c, 0)\n\t\t\tif (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, wantErr %v\", tt.input, err, tt.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"parseValue(%q) tail = %q, wantTail %q\", tt.input, tail, tt.tail)\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", tt.input, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.t == typeRawString {\n\t\treturn v1.s == v2.s\n\t}\n\tif v1.t == TypeNumber {\n\t\treturn v1.s == v2.s\n\t}\n\tif v1.t == TypeObject {\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\tif v1.t == TypeArray {\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\treturn false\n}","0ac5d665a06f3aea0c44fc787c1e6312":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\tvar c cache\n\ttests := []struct {\n\t\tin         string\n\t\tout        *Value\n\t\toutStr    string\n\t\twantErrStr string\n\t}{\n\t\t{\n\t\t\tin:         `{}`,\n\t\t\tout:        \u0026Value{t: TypeObject, o: Object{}},\n\t\t\toutStr:    ``,\n\t\t\twantErrStr: ``,\n\t\t},\n\t\t{\n\t\t\tin:         `{ \"foo\" : 123 }`,\n\t\t\tout:        \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: TypeNumber, s: \"123\"}}}}},\n\t\t\toutStr:    ``,\n\t\t\twantErrStr: ``,\n\t\t},\n\t\t{\n\t\t\tin:         `{ \"foo\" : \"bar\" }`,\n\t\t\tout:        \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: TypeString, s: \"bar\"}}}}},\n\t\t\toutStr:    ``,\n\t\t\twantErrStr: ``,\n\t\t},\n\t\t// ... more test cases\n\t}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tout, outStr, err := parseObject(tt.in, \u0026c, 0)\n\t\t\tif tt.wantErrStr != \"\" {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"want error %q; got nil\", tt.wantErrStr)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif got := err.Error(); got != tt.wantErrStr {\n\t\t\t\t\tt.Errorf(\"want error %q; got %q\", tt.wantErrStr, got)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"unexpected error: %s\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif outStr != tt.outStr {\n\t\t\t\tt.Errorf(\"want outStr %q; got %q\", tt.outStr, outStr)\n\t\t\t}\n\t\t\tif !equalValues(out, tt.out) {\n\t\t\t\tt.Errorf(\"want result:\\n%v\\ngot:\\n%v\", tt.out, out)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(a, b *Value) bool {\n\tif a == nil \u0026\u0026 b == nil {\n\t\treturn true\n\t}\n\tif a == nil || b == nil {\n\t\treturn false\n\t}\n\tif a.t != b.t {\n\t\treturn false\n\t}\n\tswitch a.t {\n\tcase TypeObject:\n\t\tif len(a.o.kvs) != len(b.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range a.o.kvs {\n\t\t\tif a.o.kvs[i].k != b.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(a.o.kvs[i].v, b.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeString:\n\t\treturn a.s == b.s\n\tcase TypeNumber:\n\t\treturn a.s == b.s\n\t// ... other types\n\tdefault:\n\t\tpanic(fmt.Sprintf(\"unknown type: %v\", a.t))\n\t}\n}","0b937229edec31861deb151c4b2bde02":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\twantS string\n\t\terr   error\n\t}{\n\t\t// Empty array\n\t\t{\n\t\t\tinput: \"[]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\twantS: \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t// Array with one element\n\t\t{\n\t\t\tinput: \"[1]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantS: \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t// Array with multiple elements\n\t\t{\n\t\t\tinput: `[1, \"hello\", true]`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"hello\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantS: \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t// Array with nested arrays\n\t\t{\n\t\t\tinput: \"[[1, 2], [3, 4]]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"4\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantS: \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t// Invalid array: missing closing bracket\n\t\t{\n\t\t\tinput: \"[1, 2\",\n\t\t\twant:  nil,\n\t\t\twantS: \"\",\n\t\t\terr:   fmt.Errorf(\"unexpected end of array\"),\n\t\t},\n\t\t// Invalid array: missing comma\n\t\t{\n\t\t\tinput: \"[1 2]\",\n\t\t\twant:  nil,\n\t\t\twantS: \"\",\n\t\t\terr:   fmt.Errorf(\"missing ',' after array value\"),\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, gotS, err := parseArray(tt.input, c, 0)\n\n\t\t\tif fmt.Sprintf(\"%v\", err) != fmt.Sprintf(\"%v\", tt.err) {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseArray() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.s != v2.s {\n\t\treturn false\n\t}\n\tif len(v1.a) != len(v2.a) {\n\t\treturn false\n\t}\n\tfor i := range v1.a {\n\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","0caf733fa5305edee132705c431f4cb5":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestValue_Uint(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  uint\n\t\terr   error\n\t}{\n\t\t{\n\t\t\tinput: `123`,\n\t\t\twant:  123,\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `123.456`,\n\t\t\twant:  0,\n\t\t\terr:   fmt.Errorf(\"number \\\"123.456\\\" doesn't fit uint\"),\n\t\t},\n\t\t{\n\t\t\tinput: `\"123\"`,\n\t\t\twant:  0,\n\t\t\terr:   fmt.Errorf(\"value doesn't contain number; it contains string\"),\n\t\t},\n\t\t{\n\t\t\tinput: `null`,\n\t\t\twant:  0,\n\t\t\terr:   fmt.Errorf(\"value doesn't contain number; it contains null\"),\n\t\t},\n\t\t{\n\t\t\tinput: `9223372036854775808`,\n\t\t\twant:  0,\n\t\t\terr:   fmt.Errorf(\"number \\\"9223372036854775808\\\" doesn't fit uint\"),\n\t\t},\n\t\t{\n\t\t\tinput: `-1`,\n\t\t\twant:  0,\n\t\t\terr:   fmt.Errorf(\"number \\\"-1\\\" doesn't fit uint\"),\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tv := \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: tt.input,\n\t\t\t}\n\t\t\tgot, err := v.Uint()\n\t\t\tif tt.err != nil {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"expected error, got nil\")\n\t\t\t\t} else if err.Error() != tt.err.Error() {\n\t\t\t\t\tt.Errorf(\"error mismatch: expected %v, got %v\", tt.err, err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"value mismatch: expected %v, got %v\", tt.want, got)\n\t\t\t}\n\t\t})\n\t}\n}","0cd53799171f8eab7a7786371d5f8f6a":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantNum  string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Basic cases\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"123.456\", \"123.456\", \"\", nil},\n\t\t{\"1.2e3\", \"1.2e3\", \"\", nil},\n\t\t{\"1.2E-3\", \"1.2E-3\", \"\", nil},\n\n\t\t// Trailing characters\n\t\t{\"123a\", \"123\", \"a\", nil},\n\t\t{\"123.456 \", \"123.456\", \" \", nil},\n\n\t\t// Invalid numbers\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t\t{\"+\", \"\", \"+\", fmt.Errorf(\"unexpected char: %q\", \"+\")},\n\t\t{\"-\", \"\", \"-\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t\t{\"a123\", \"\", \"a123\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\n\t\t// Special values\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"+inf\", \"+inf\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"InF\", \"InF\", \"\", nil}, // Case insensitive\n\t\t{\"Infin\", \"Infin\", \"\", fmt.Errorf(\"unexpected char: %q\", \"I\")},\n\t\t{\"infx\", \"inf\", \"x\", nil},\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"+nan\", \"+nan\", \"\", nil},\n\t\t{\"-nan\", \"-nan\", \"\", nil},\n\t\t{\"NaN\", \"NaN\", \"\", nil}, // Case insensitive\n\t\t{\"NAN\", \"NAN\", \"\", nil},\n\t\t{\"nanx\", \"nan\", \"x\", nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tgotNum, gotTail, gotErr := parseRawNumber(tt.input)\n\n\t\t\tif gotNum != tt.wantNum {\n\t\t\t\tt.Errorf(\"input %q: got number %q, want %q\", tt.input, gotNum, tt.wantNum)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"input %q: got tail %q, want %q\", tt.input, gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif gotErr == nil \u0026\u0026 tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"input %q: got no error, want %v\", tt.input, tt.wantErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr == nil {\n\t\t\t\tt.Errorf(\"input %q: got error %v, want no error\", tt.input, gotErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"input %q: got error %v, want %v\", tt.input, gotErr, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","0d8972029cfd570b7b6fadd35e2a9a42":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueType(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected Type\n\t}{\n\t\t{`null`, TypeNull},\n\t\t{`{}`, TypeObject},\n\t\t{`[]`, TypeArray},\n\t\t{`\"hello\"`, TypeString},\n\t\t{`123`, TypeNumber},\n\t\t{`true`, TypeTrue},\n\t\t{`false`, TypeFalse},\n\t}\n\n\tfor _, test := range tests {\n\t\tv := \u0026Value{t: typeRawString, s: test.input}\n\t\tactual := v.Type()\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected type %v, but got %v for input %q\", test.expected, actual, test.input)\n\t\t}\n\t}\n}\n","0dd52c43968564e6763558b0b79bfa78":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantValue  *Value\n\t\twantTail string\n\t\twantErr   error\n\t}{\n\t\t// TODO: Add test cases for parseValue function\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\twantValue:  nil,\n\t\t\twantTail: \"\",\n\t\t\twantErr:   fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid JSON\",\n\t\t\tinput:    \"abc\",\n\t\t\twantValue:  nil,\n\t\t\twantTail: \"abc\",\n\t\t\twantErr:   fmt.Errorf(\"cannot parse number: abc\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"null\",\n\t\t\tinput:    \"null\",\n\t\t\twantValue:  valueNull,\n\t\t\twantTail: \"\",\n\t\t\twantErr:   nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"true\",\n\t\t\tinput:    \"true\",\n\t\t\twantValue:  valueTrue,\n\t\t\twantTail: \"\",\n\t\t\twantErr:   nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"false\",\n\t\t\tinput:    \"false\",\n\t\t\twantValue:  valueFalse,\n\t\t\twantTail: \"\",\n\t\t\twantErr:   nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"number\",\n\t\t\tinput:    \"123\",\n\t\t\twantValue:  \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\twantTail: \"\",\n\t\t\twantErr:   nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"string\",\n\t\t\tinput:    `\"abc\"`,\n\t\t\twantValue:  \u0026Value{t: TypeString, s: \"abc\"},\n\t\t\twantTail: \"\",\n\t\t\twantErr:   nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"object\",\n\t\t\tinput:    `{\"a\":123}`,\n\t\t\twantValue:  \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"a\", v: \u0026Value{t: TypeNumber, s: \"123\"}}}}},\n\t\t\twantTail: \"\",\n\t\t\twantErr:   nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"array\",\n\t\t\tinput:    `[123]`,\n\t\t\twantValue:  \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"123\"}}},\n\t\t\twantTail: \"\",\n\t\t\twantErr:   nil,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgotValue, gotTail, gotErr := parseValue(tt.input, c, 0)\n\t\t\tif gotValue != nil \u0026\u0026 gotValue.t != tt.wantValue.t {\n\t\t\t\tt.Errorf(\"parseValue() gotValue = %v, want %v\", gotValue, tt.wantValue)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseValue() gotTail = %v, want %v\", gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif gotErr == nil \u0026\u0026 tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"parseValue() gotErr = nil, want %v\", tt.wantErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr == nil {\n\t\t\t\tt.Errorf(\"parseValue() gotErr = %v, want nil\", gotErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"parseValue() gotErr = %v, want %v\", gotErr, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","0e137cd85ee0d22389c92c89df6ce95f":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ts     string\n\t\terr   error\n\t}{\n\t\t// Empty object\n\t\t{\n\t\t\tinput: \"{}\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Simple object\n\t\t{\n\t\t\tinput: `{\"key\": \"value\"}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: \u0026Value{t: TypeString, s: \"value\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Object with multiple key-value pairs\n\t\t{\n\t\t\tinput: `{\"key1\": \"value1\", \"key2\": 123, \"key3\": true}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t\t{k: \"key3\", v: \u0026Value{t: TypeTrue}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Nested object\n\t\t{\n\t\t\tinput: `{\"key1\": {\"key2\": \"value2\"}, \"key3\": \"value3\"}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{k: \"key3\", v: \u0026Value{t: TypeString, s: \"value3\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Missing closing brace\n\t\t{\n\t\t\tinput: `{\"key\": \"value\"`,\n\t\t\twant:  nil,\n\t\t\ts:     `{\"key\": \"value\"`,\n\t\t\terr:   fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t\t// Invalid key\n\t\t{\n\t\t\tinput: `{key: \"value\"}`,\n\t\t\twant:  nil,\n\t\t\ts:     `{key: \"value\"}`,\n\t\t\terr:   fmt.Errorf(`cannot find opening '\"\" for object key`),\n\t\t},\n\t\t// Missing colon\n\t\t{\n\t\t\tinput: `{\"key\" \"value\"}`,\n\t\t\twant:  nil,\n\t\t\ts:     `\"value\"}`,\n\t\t\terr:   fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t\t// Invalid value\n\t\t{\n\t\t\tinput: `{\"key\": invalid}`,\n\t\t\twant:  nil,\n\t\t\ts:     `invalid}`,\n\t\t\terr:   fmt.Errorf(\"cannot parse object value: invalid character 'i' looking for beginning of value\"),\n\t\t},\n\t\t// Missing comma\n\t\t{\n\t\t\tinput: `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twant:  nil,\n\t\t\ts:     `\"key2\": \"value2\"}`,\n\t\t\terr:   fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseObject(tt.input, c, 0)\n\n\t\t\tif tt.err != nil {\n\t\t\t\tif err == nil || err.Error() != tt.err.Error() {\n\t\t\t\t\tt.Errorf(\"Expected error %v, but got %v\", tt.err, err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t\t}\n\t\t\tif s != tt.s {\n\t\t\t\tt.Errorf(\"Expected remaining string %q, but got %q\", tt.s, s)\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"Test-%d: Expected\\n\\t%+v\\nGot\\n\\t%+v\", i, tt.want, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\treturn true\n\t}\n}\n","0e2fc36867a75303a40fd010715ca652":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tinput   string\n\t\twant    *Value\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tp := \u0026Parser{}\n\t\t\tgot, err := p.Parse(tt.input)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Parse() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Parse() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","0e9eb289cd868b9e3366eb39a10000e2":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ts     string\n\t\terr   error\n\t}{\n\t\t// Empty array\n\t\t{\n\t\t\tinput: \"[]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Simple array\n\t\t{\n\t\t\tinput: \"[1,2,3]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Array with different types\n\t\t{\n\t\t\tinput: `[1,\"hello\",true,null]`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeString, s: \"hello\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t\t{t: TypeNull},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Nested array\n\t\t{\n\t\t\tinput: \"[1,[2,3],4]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{t: TypeNumber, s: \"4\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Array with trailing whitespace\n\t\t{\n\t\t\tinput: \"[1,2,3] \",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \" \",\n\t\t\terr: nil,\n\t\t},\n\t\t// Invalid array - missing closing bracket\n\t\t{\n\t\t\tinput: \"[1,2,3\",\n\t\t\twant:  nil,\n\t\t\ts:     \"[1,2,3\",\n\t\t\terr:   fmt.Errorf(\"unexpected end of array\"),\n\t\t},\n\t\t// Invalid array - missing comma\n\t\t{\n\t\t\tinput: \"[1 2 3]\",\n\t\t\twant:  nil,\n\t\t\ts:     \"2 3]\",\n\t\t\terr:   fmt.Errorf(\"missing ',' after array value\"),\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i+1), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseArray(tt.input, c, 0)\n\n\t\t\tif (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"parseArray(%s) error mismatch: got %v, want %v\", tt.input, err, tt.err)\n\t\t\t}\n\n\t\t\tif s != tt.s {\n\t\t\t\tt.Errorf(\"parseArray(%s) remaining string mismatch: got %q, want %q\", tt.input, s, tt.s)\n\t\t\t}\n\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray(%s) value mismatch:\\ngot  %+v\\nwant %+v\", tt.input, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.s != v2.s {\n\t\treturn false\n\t}\n\tif len(v1.a) != len(v2.a) {\n\t\treturn false\n\t}\n\tfor i := range v1.a {\n\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","0f26a105e8a6525daf65d26615bb027c":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic strings\n\t\t{\"hello\", \"hello\"},\n\t\t{\"world\", \"world\"},\n\n\t\t// Escaped characters\n\t\t{`\\\"hello\\\"`, `\"hello\"`},\n\t\t{`\\\\hello\\\\`, `\\hello\\`},\n\t\t{`\\bhello\\b`, \"\\bhello\\b\"},\n\t\t{`\\fhello\\f`, \"\\fhello\\f\"},\n\t\t{`\\nhello\\n`, \"\\nhello\\n\"},\n\t\t{`\\rhello\\r`, \"\\rhello\\r\"},\n\t\t{`\\thello\\t`, \"\\thello\\t\"},\n\n\t\t// Unicode escape sequences\n\t\t{`\\u0041`, \"A\"},\n\t\t{`\\u00e9`, \"√©\"},\n\t\t{`\\u20ac`, \"‚Ç¨\"},\n\t\t{`\\uD83D\\uDE02`, \"üòÇ\"}, // Surrogate pair\n\n\t\t// Invalid escape sequences\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\uD800`, `\\uD800`}, // Unpaired surrogate\n\n\t\t// Mixed strings\n\t\t{`hello\\tworld`, \"hello\\tworld\"},\n\t\t{`\"hello\\tworld\"`, `\"hello\\tworld\"`},\n\t\t{`\\u0041\\u0020\\u0042`, \"A B\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}","0f616e71d39628a3904565c42de8b8bc":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCache_getValue(t *testing.T) {\n\tt.Run(\"empty cache\", func(t *testing.T) {\n\t\tc := \u0026cache{}\n\t\tv := c.getValue()\n\n\t\tif v == nil {\n\t\t\tt.Fatal(\"Expected a non-nil value\")\n\t\t}\n\n\t\tif len(c.vs) != 1 {\n\t\t\tt.Errorf(\"Expected cache length to be 1, got %d\", len(c.vs))\n\t\t}\n\t})\n\n\tt.Run(\"cache with capacity\", func(t *testing.T) {\n\t\tc := \u0026cache{\n\t\t\tvs: make([]Value, 0, 2),\n\t\t}\n\t\tv1 := c.getValue()\n\t\tv2 := c.getValue()\n\n\t\tif v1 == nil || v2 == nil {\n\t\t\tt.Fatal(\"Expected non-nil values\")\n\t\t}\n\n\t\tif len(c.vs) != 2 {\n\t\t\tt.Errorf(\"Expected cache length to be 2, got %d\", len(c.vs))\n\t\t}\n\t})\n\n\tt.Run(\"cache exceeding capacity\", func(t *testing.T) {\n\t\tc := \u0026cache{\n\t\t\tvs: make([]Value, 0, 2),\n\t\t}\n\t\t_ = c.getValue()\n\t\t_ = c.getValue()\n\t\tv3 := c.getValue()\n\n\t\tif v3 == nil {\n\t\t\tt.Fatal(\"Expected a non-nil value\")\n\t\t}\n\n\t\tif len(c.vs) != 3 {\n\t\t\tt.Errorf(\"Expected cache length to be 3, got %d\", len(c.vs))\n\t\t}\n\t})\n}\n","102240021d6c63d042cc29f0cf5c3c80":"package fastjson\n\nimport \"testing\"\n\nfunc TestObject_getKV(t *testing.T) {\n\to := \u0026Object{}\n\t// Test adding to empty o.kvs\n\tkv1 := o.getKV()\n\tif kv1 == nil {\n\t\tt.Errorf(\"Expected non-nil kv, got nil\")\n\t}\n\tif len(o.kvs) != 1 {\n\t\tt.Errorf(\"Expected o.kvs length 1, got %d\", len(o.kvs))\n\t}\n\n\t// Test adding when capacity is available\n\tkv2 := o.getKV()\n\tif kv2 == nil {\n\t\tt.Errorf(\"Expected non-nil kv, got nil\")\n\t}\n\tif len(o.kvs) != 2 {\n\t\tt.Errorf(\"Expected o.kvs length 2, got %d\", len(o.kvs))\n\t}\n\n\t// Test adding when capacity needs to be extended\n\to.kvs = o.kvs[:1] // Reset length to 1, capacity remains 2\n\tkv3 := o.getKV()\n\tif kv3 == nil {\n\t\tt.Errorf(\"Expected non-nil kv, got nil\")\n\t}\n\tif len(o.kvs) != 2 {\n\t\tt.Errorf(\"Expected o.kvs length 2, got %d\", len(o.kvs))\n\t}\n}","10bbc6828a6fc03332fc16f5cfb25807":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tin       string\n\t\tnum      string\n\t\ttail     string\n\t\thasError bool\n\t}{\n\t\t{\"123\", \"123\", \"\", false},\n\t\t{\"123a\", \"123\", \"a\", false},\n\t\t{\"123.456\", \"123.456\", \"\", false},\n\t\t{\"123.456a\", \"123.456\", \"a\", false},\n\t\t{\"-123\", \"-123\", \"\", false},\n\t\t{\"-123a\", \"-123\", \"a\", false},\n\t\t{\"+123\", \"+123\", \"\", false},\n\t\t{\"+123a\", \"+123\", \"a\", false},\n\t\t{\"1e3\", \"1e3\", \"\", false},\n\t\t{\"1e+3\", \"1e+3\", \"\", false},\n\t\t{\"1e-3\", \"1e-3\", \"\", false},\n\t\t{\"1.2e3\", \"1.2e3\", \"\", false},\n\t\t{\"1.2e+3\", \"1.2e+3\", \"\", false},\n\t\t{\"1.2e-3\", \"1.2e-3\", \"\", false},\n\t\t{\"-1.2e3\", \"-1.2e3\", \"\", false},\n\t\t{\"-1.2e+3\", \"-1.2e+3\", \"\", false},\n\t\t{\"-1.2e-3\", \"-1.2e-3\", \"\", false},\n\t\t{\"inf\", \"inf\", \"\", false},\n\t\t{\"+inf\", \"+inf\", \"\", false},\n\t\t{\"-inf\", \"-inf\", \"\", false},\n\t\t{\"in\", \"\", \"\", true},\n\t\t{\"+in\", \"\", \"\", true},\n\t\t{\"-in\", \"\", \"\", true},\n\t\t{\"INF\", \"INF\", \"\", false},\n\t\t{\"+INF\", \"+INF\", \"\", false},\n\t\t{\"-INF\", \"-INF\", \"\", false},\n\t\t{\"Infin\", \"Infin\", \"\", false}, // this is ok\n\t\t{\"+Infin\", \"+Infin\", \"\", false},\n\t\t{\"-Infin\", \"-Infin\", \"\", false},\n\t\t{\"infinity\", \"infinity\", \"\", false}, // this is ok\n\t\t{\"+infinity\", \"+infinity\", \"\", false},\n\t\t{\"-infinity\", \"-infinity\", \"\", false},\n\t\t{\"nan\", \"nan\", \"\", false},\n\t\t{\"+nan\", \"+nan\", \"\", false},\n\t\t{\"-nan\", \"-nan\", \"\", false},\n\t\t{\"NaN\", \"NaN\", \"\", false},\n\t\t{\"+NaN\", \"+NaN\", \"\", false},\n\t\t{\"-NaN\", \"-NaN\", \"\", false},\n\t\t{\"na\", \"\", \"\", true},\n\t\t{\"+na\", \"\", \"\", true},\n\t\t{\"-na\", \"\", \"\", true},\n\t}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tnum, tail, err := parseRawNumber(tt.in)\n\t\t\tif tt.hasError {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Fatalf(\"expecting error, but got nil\")\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t\t\t}\n\t\t\tif num != tt.num {\n\t\t\t\tt.Fatalf(\"num mismatch: expect %q, got %q\", tt.num, num)\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Fatalf(\"tail mismatch: expect %q, got %q\", tt.tail, tail)\n\t\t\t}\n\t\t})\n\t}\n}","127578a71a6a36cc5701f713d549647a":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ts     string\n\t\terr   error\n\t}{\n\t\t// Empty object\n\t\t{\n\t\t\tinput: \"{}\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Single key-value pair\n\t\t{\n\t\t\tinput: `{\"key\": \"value\"}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: \u0026Value{t: TypeString, s: \"value\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Multiple key-value pairs\n\t\t{\n\t\t\tinput: `{\"key1\": \"value1\", \"key2\": \"value2\", \"key3\": \"value3\"}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}},\n\t\t\t\t\t\t{k: \"key3\", v: \u0026Value{t: TypeString, s: \"value3\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// With whitespace\n\t\t{\n\t\t\tinput: \" { \\\"key1\\\" : \\\"value1\\\" , \\\"key2\\\" : \\\"value2\\\" } \",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \" \",\n\t\t\terr: nil,\n\t\t},\n\t\t// With escaped characters in keys and values\n\t\t{\n\t\t\tinput: `{\"key\\twith\\nescapes\": \"value\\twith\\nescapes\"}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\\twith\\nescapes\", v: \u0026Value{t: TypeString, s: \"value\\twith\\nescapes\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// With nested objects\n\t\t{\n\t\t\tinput: `{\"key1\": {\"key2\": \"value2\"}, \"key3\": \"value3\"}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{k: \"key3\", v: \u0026Value{t: TypeString, s: \"value3\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Invalid JSON: Missing closing brace\n\t\t{\n\t\t\tinput: `{\"key\": \"value\"`,\n\t\t\twant:  nil,\n\t\t\ts:     `{\"key\": \"value\"`,\n\t\t\terr:   fmt.Errorf(`missing '}'`),\n\t\t},\n\t\t// Invalid JSON: Missing opening quote for key\n\t\t{\n\t\t\tinput: `{key\": \"value\"}`,\n\t\t\twant:  nil,\n\t\t\ts:     `key\": \"value\"}`,\n\t\t\terr:   fmt.Errorf(`cannot find opening '\"\" for object key`),\n\t\t},\n\t\t// Invalid JSON: Missing colon after key\n\t\t{\n\t\t\tinput: `{\"key\" \"value\"}`,\n\t\t\twant:  nil,\n\t\t\ts:     `\"value\"}`,\n\t\t\terr:   fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t\t// Invalid JSON: Missing comma between key-value pairs\n\t\t{\n\t\t\tinput: `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twant:  nil,\n\t\t\ts:     ` \"key2\": \"value2\"}`,\n\t\t\terr:   fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test %d\", i+1), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseObject(tt.input, c, 0)\n\n\t\t\tif (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"Expected error: %v, got: %v\", tt.err, err)\n\t\t\t}\n\t\t\tif s != tt.s {\n\t\t\t\tt.Errorf(\"Expected remaining string: %q, got: %q\", tt.s, s)\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"Expected value: %v, got: %v\", tt.want, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k || !equalValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t// Add cases for other value types as needed\n\tdefault:\n\t\treturn false\n\t}\n}\n","131c5e909188ccddbdbc641839726007":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ts     string\n\t\terr   error\n\t}{\n\t\t// Empty array\n\t\t{\n\t\t\tinput: \"[]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Simple array\n\t\t{\n\t\t\tinput: \"[1,2,3]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Array with different types\n\t\t{\n\t\t\tinput: `[1,\"hello\",true,null]`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeString, s: \"hello\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t\t{t: TypeNull},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Array with nested array\n\t\t{\n\t\t\tinput: \"[1,[2,3],4]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{t: TypeNumber, s: \"4\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Array with whitespace\n\t\t{\n\t\t\tinput: \" [ 1 , 2 , 3 ] \",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \" \",\n\t\t\terr: nil,\n\t\t},\n\t\t// Invalid array - missing closing bracket\n\t\t{\n\t\t\tinput: \"[1,2,3\",\n\t\t\twant:  nil,\n\t\t\ts:     \"[1,2,3\",\n\t\t\terr:   fmt.Errorf(\"unexpected end of array\"),\n\t\t},\n\t\t// Invalid array - missing comma\n\t\t{\n\t\t\tinput: \"[1 2 3]\",\n\t\t\twant:  nil,\n\t\t\ts:     \"2 3]\",\n\t\t\terr:   fmt.Errorf(\"missing ',' after array value\"),\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i+1), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseArray(tt.input, c, 0)\n\t\t\tif (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"parseArray(%s) error mismatch: got %v, want %v\", tt.input, err, tt.err)\n\t\t\t}\n\t\t\tif s != tt.s {\n\t\t\t\tt.Errorf(\"parseArray(%s) remaining string mismatch: got %q, want %q\", tt.input, s, tt.s)\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray(%s) value mismatch:\\ngot  %+v\\nwant %+v\", tt.input, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.t == TypeArray {\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\treturn v1.s == v2.s\n}","13ac2e84e94bb35e0a1906d0f00aa5aa":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic escapes\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\t`, \"\\t\"},\n\t\t{`\\\\`, \"\\\\\"},\n\t\t{`\\\"`, \"\\\"\"},\n\t\t{`\\/`, \"/\"},\n\n\t\t// Unicode escapes\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A0`, \"\\u00A0\"},\n\t\t{`\\uFFFF`, \"\\uFFFF\"},\n\n\t\t// Surrogate pairs\n\t\t{`\\uD83D\\uDE02`, \"\\U0001F602\"}, // üòÇ\n\n\t\t// Invalid escapes\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\uD800`, `\\uD800`}, // Invalid surrogate pair\n\n\t\t// Mixed escapes\n\t\t{`Hello\\tworld\\n`, \"Hello\\tworld\\n\"},\n\t\t{`\"This is a \\\\test\\\\\"`, \"\\\"This is a \\\\test\\\\\\\"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}\n","148ad80a180eea71a492d6b0b24097d2":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetStringBytes(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tjson  string\n\t\tkeys  []string\n\t\twant  []byte\n\t\twant2 bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty\",\n\t\t\tjson:  `{}`,\n\t\t\tkeys:  []string{\"nonexisting\"},\n\t\t\twant:  nil,\n\t\t\twant2: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"simple\",\n\t\t\tjson:  `{\"foo\":\"bar\"}`,\n\t\t\tkeys:  []string{\"foo\"},\n\t\t\twant:  []byte(\"bar\"),\n\t\t\twant2: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"number\",\n\t\t\tjson:  `{\"foo\":123}`,\n\t\t\tkeys:  []string{\"foo\"},\n\t\t\twant:  nil,\n\t\t\twant2: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"null\",\n\t\t\tjson:  `{\"foo\":null}`,\n\t\t\tkeys:  []string{\"foo\"},\n\t\t\twant:  nil,\n\t\t\twant2: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array\",\n\t\t\tjson:  `{\"foo\":[\"bar\", \"baz\"]}`,\n\t\t\tkeys:  []string{\"foo\", \"1\"},\n\t\t\twant:  []byte(\"baz\"),\n\t\t\twant2: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array decimal\",\n\t\t\tjson:  `{\"foo\":[\"bar\", \"baz\"]}`,\n\t\t\tkeys:  []string{\"foo\", \"1.0\"},\n\t\t\twant:  []byte(\"baz\"),\n\t\t\twant2: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"nested\",\n\t\t\tjson:  `{\"foo\":{\"bar\":\"baz\"}}`,\n\t\t\tkeys:  []string{\"foo\", \"bar\"},\n\t\t\twant:  []byte(\"baz\"),\n\t\t\twant2: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv, err := ParseBytes([]byte(tt.json))\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"cannot parse json: %s\", err)\n\t\t\t}\n\t\t\tgot := v.GetStringBytes(tt.keys...)\n\t\t\tif string(got) != string(tt.want) {\n\t\t\t\tt.Errorf(\"GetStringBytes() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","1490d6cb217dd451490dc28ee87e21f0":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput    string\n\t\twantN    string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Basic cases\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"123.456\", \"123.456\", \"\", nil},\n\t\t{\"1.2e3\", \"1.2e3\", \"\", nil},\n\t\t{\"1.2E-3\", \"1.2E-3\", \"\", nil},\n\n\t\t// Trailing characters\n\t\t{\"123a\", \"123\", \"a\", nil},\n\t\t{\"123.456 \", \"123.456\", \" \", nil},\n\n\t\t// Invalid numbers\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t\t{\"+\", \"\", \"+\", fmt.Errorf(\"unexpected char: %q\", \"+\")},\n\t\t(\"-\", \"\", \"-\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t\t(\".123\", \"\", \".123\", fmt.Errorf(\"unexpected char: %q\", \".\")},\n\n\t\t// Special cases: inf, nan\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"+inf\", \"+inf\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"InF\", \"InF\", \"\", nil}, // Case insensitive\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"+nan\", \"\", \"+nan\", fmt.Errorf(\"unexpected char: %q\", \"+\")}, // NaN cannot have a sign\n\t\t{\"-nan\", \"\", \"-nan\", fmt.Errorf(\"unexpected char: %q\", \"-\")}, // NaN cannot have a sign\n\n\t\t// Trailing characters after inf/nan\n\t\t{\"infx\", \"inf\", \"x\", nil},\n\t\t{\"nan \", \"nan\", \" \", nil},\n\n\t\t// Incomplete inf/nan\n\t\t{\"in\", \"\", \"in\", fmt.Errorf(\"unexpected char: %q\", \"i\")},\n\t\t{\"na\", \"\", \"na\", fmt.Errorf(\"unexpected char: %q\", \"n\")},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"Case_%d_%s\", i, tc.input), func(t *testing.T) {\n\t\t\tgotN, gotTail, gotErr := parseRawNumber(tc.input)\n\n\t\t\tif gotN != tc.wantN {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got number = %q, want %q\", tc.input, gotN, tc.wantN)\n\t\t\t}\n\t\t\tif gotTail != tc.wantTail {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got tail = %q, want %q\", tc.input, gotTail, tc.wantTail)\n\t\t\t}\n\n\t\t\tif gotErr == nil \u0026\u0026 tc.wantErr != nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got err = nil, want error %v\", tc.input, tc.wantErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tc.wantErr == nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got err = %v, want nil\", tc.input, gotErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tc.wantErr != nil \u0026\u0026 gotErr.Error() != tc.wantErr.Error() {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got err = %v, want error %v\", tc.input, gotErr, tc.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}\n","14c58917c9d82fa6db5387dd24350ac4":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Empty string\n\t\t{\"\", nil, \"\", fmt.Errorf(\"cannot parse empty string\")},\n\t\t// Invalid JSON\n\t\t{\"{\", nil, \"{\", fmt.Errorf(\"cannot parse object: missing '}'\")},\n\t\t// Object\n\t\t{`{\"foo\":\"bar\"}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: typeRawString, s: \"bar\"}}}}}, \"\", nil},\n\t\t// Array\n\t\t{`[1,2,3]`, \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}}, \"\", nil},\n\t\t// String\n\t\t{`\"hello\"`, \u0026Value{t: typeRawString, s: \"hello\"}, \"\", nil},\n\t\t// True\n\t\t{\"true\", valueTrue, \"\", nil},\n\t\t// False\n\t\t{\"false\", valueFalse, \"\", nil},\n\t\t// Null\n\t\t{\"null\", valueNull, \"\", nil},\n\t\t// Number\n\t\t{\"123\", \u0026Value{t: TypeNumber, s: \"123\"}, \"\", nil},\n\t\t// Number with trailing space\n\t\t{\"456 \", \u0026Value{t: TypeNumber, s: \"456\"}, \" \", nil},\n\t\t// Number with exponent\n\t\t{\"1e3\", \u0026Value{t: TypeNumber, s: \"1e3\"}, \"\", nil},\n\t\t// Number with negative exponent\n\t\t{\"1e-3\", \u0026Value{t: TypeNumber, s: \"1e-3\"}, \"\", nil},\n\t\t// Number with decimal\n\t\t{\"1.23\", \u0026Value{t: TypeNumber, s: \"1.23\"}, \"\", nil},\n\t\t// Negative number\n\t\t{\"-123\", \u0026Value{t: TypeNumber, s: \"-123\"}, \"\", nil},\n\t\t// String with escaped characters\n\t\t{`\"hello\\nworld\"`, \u0026Value{t: typeRawString, s: \"hello\\nworld\"}, \"\", nil},\n\t\t// String with unicode escape characters\n\t\t{`\"\\u003c\\u003e\"`, \u0026Value{t: typeRawString, s: \"\u003c\u003e\"}, \"\", nil},\n\t\t// Object with nested values\n\t\t{`{\"foo\":{\"bar\":\"baz\"}}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"bar\", v: \u0026Value{t: typeRawString, s: \"baz\"}}}}}}}}}, \"\", nil},\n\t\t// Array with nested values\n\t\t{`[1,{\"foo\":\"bar\"},true]`, \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: typeRawString, s: \"bar\"}}}}}, valueTrue}}, \"\", nil},\n\t}\n\n\tc := \u0026cache{}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tgot, tail, err := parseValue(tt.input, c, 0)\n\t\t\tif fmt.Sprintf(\"%v\", err) != fmt.Sprintf(\"%v\", tt.err) {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, wantErr %v\", tt.input, err, tt.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got == nil \u0026\u0026 tt.want == nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got.Type() != tt.want.Type() {\n\t\t\t\tt.Errorf(\"parseValue(%q) got type = %v, want %v\", tt.input, got.Type(), tt.want.Type())\n\t\t\t}\n\t\t\tif got.String() != tt.want.String() {\n\t\t\t\tt.Errorf(\"parseValue(%q) got = %v, want %v\", tt.input, got, tt.want)\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"parseValue(%q) tail = %q, want %q\", tt.input, tail, tt.tail)\n\t\t\t}\n\t\t})\n\t}\n}","14fbe10b0680f4221116e7b1870b9a89":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput       string\n\t\twantValue   string\n\t\twantTail    string\n\t\twantErr     bool\n\t\twantErrText string\n\t}{\n\t\t{\n\t\t\tinput:       \"[]\",\n\t\t\twantValue:   \"[]\",\n\t\t\twantTail:    \"\",\n\t\t\twantErr:     false,\n\t\t\twantErrText: \"\",\n\t\t},\n\t\t{\n\t\t\tinput:       \"[ ]\",\n\t\t\twantValue:   \"[]\",\n\t\t\twantTail:    \"\",\n\t\t\twantErr:     false,\n\t\t\twantErrText: \"\",\n\t\t},\n\t\t{\n\t\t\tinput:       \"[1]\",\n\t\t\twantValue:   \"[1]\",\n\t\t\twantTail:    \"\",\n\t\t\twantErr:     false,\n\t\t\twantErrText: \"\",\n\t\t},\n\t\t{\n\t\t\tinput:       \"[ 1]\",\n\t\t\twantValue:   \"[1]\",\n\t\t\twantTail:    \"\",\n\t\t\twantErr:     false,\n\t\t\twantErrText: \"\",\n\t\t},\n\t\t{\n\t\t\tinput:       \"[1 ]\",\n\t\t\twantValue:   \"[1]\",\n\t\t\twantTail:    \"\",\n\t\t\twantErr:     false,\n\t\t\twantErrText: \"\",\n\t\t},\n\t\t{\n\t\t\tinput:       \"[1,2]\",\n\t\t\twantValue:   \"[1,2]\",\n\t\t\twantTail:    \"\",\n\t\t\twantErr:     false,\n\t\t\twantErrText: \"\",\n\t\t},\n\t\t{\n\t\t\tinput:       \"[ 1 , 2 ]\",\n\t\t\twantValue:   \"[1,2]\",\n\t\t\twantTail:    \"\",\n\t\t\twantErr:     false,\n\t\t\twantErrText: \"\",\n\t\t},\n\t\t{\n\t\t\tinput:       \"[1,2,3]\",\n\t\t\twantValue:   \"[1,2,3]\",\n\t\t\twantTail:    \"\",\n\t\t\twantErr:     false,\n\t\t\twantErrText: \"\",\n\t\t},\n\t\t{\n\t\t\tinput:       \"[1,2,]\",\n\t\t\twantValue:   \"\",\n\t\t\twantTail:    \",]\",\n\t\t\twantErr:     true,\n\t\t\twantErrText: \"cannot parse array value: unexpected end of number\",\n\t\t},\n\t\t{\n\t\t\tinput:       \"[1 2]\",\n\t\t\twantValue:   \"\",\n\t\t\twantTail:    \"2]\",\n\t\t\twantErr:     true,\n\t\t\twantErrText: \"missing ',' after array value\",\n\t\t},\n\t\t{\n\t\t\tinput:       \"[1,\",\n\t\t\twantValue:   \"\",\n\t\t\twantTail:    \",\",\n\t\t\twantErr:     true,\n\t\t\twantErrText: \"cannot parse array value: unexpected end of number\",\n\t\t},\n\t\t{\n\t\t\tinput:       \"[\",\n\t\t\twantValue:   \"\",\n\t\t\twantTail:    \"\",\n\t\t\twantErr:     true,\n\t\t\twantErrText: \"missing ']' at the end of array\",\n\t\t},\n\t\t{\n\t\t\tinput:       \" [1]\",\n\t\t\twantValue:   \"[1]\",\n\t\t\twantTail:    \"\",\n\t\t\twantErr:     false,\n\t\t\twantErrText: \"\",\n\t\t},\n\t\t{\n\t\t\tinput:       \"[1] \",\n\t\t\twantValue:   \"[1]\",\n\t\t\twantTail:    \" \",\n\t\t\twantErr:     false,\n\t\t\twantErrText: \"\",\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i+1), func(t *testing.T) {\n\t\t\tc := \u0026cache{\n\t\t\t\tvs: make([]Value, 1024),\n\t\t\t}\n\t\t\tgotValue, gotTail, gotErr := parseArray(tt.input, c, 0)\n\n\t\t\tif (gotErr != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", gotErr, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif gotErr != nil \u0026\u0026 gotErr.Error() != tt.wantErrText {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErrText %v\", gotErr, tt.wantErrText)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseArray() gotTail = %v, want %v\", gotTail, tt.wantTail)\n\t\t\t}\n\n\t\t\tif gotValue == nil \u0026\u0026 tt.wantValue == \"\" {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif gotValue == nil \u0026\u0026 tt.wantValue != \"\" {\n\t\t\t\tt.Errorf(\"parseArray() gotValue = nil, want %v\", tt.wantValue)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif gotValue != nil \u0026\u0026 tt.wantValue == \"\" {\n\t\t\t\tt.Errorf(\"parseArray() gotValue = %v, want nil\", gotValue)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif gotValue.String() != tt.wantValue {\n\t\t\t\tt.Errorf(\"parseArray() gotValue = %v, want %v\", gotValue, tt.wantValue)\n\t\t\t}\n\t\t})\n\t}\n}\n","15857d05467c9fab2c5649930ceed954":"package fastjson\n\nimport \"testing\"\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"\", \"\"},\n\t\t{\"   \", \"\"},\n\t\t{\"\\t\\t\\t\", \"\"},\n\t\t{\"\\n\\n\\n\", \"\"},\n\t\t{\" \\t\\n\\r\", \"\"},\n\t\t{\"a\", \"a\"},\n\t\t{\" a\", \"a\"},\n\t\t{\"  a\", \"a\"},\n\t\t{\"\\ta\", \"a\"},\n\t\t{\"\\na\", \"a\"},\n\t\t{\"\\ra\", \"a\"},\n\t\t{\"\\t \\na\", \"a\"},\n\t\t{\"a \", \"a \"},\n\t\t{\"a  \", \"a  \"},\n\t\t{\"a\\t\", \"a\\t\"},\n\t\t{\"a\\n\", \"a\\n\"},\n\t\t{\"a\\r\", \"a\\r\"},\n\t\t{\"a\\t \\n\", \"a\\t \\n\"},\n\t\t{\"hello world\", \"hello world\"},\n\t\t{\" hello world\", \"hello world\"},\n\t\t{\"  hello world\", \"hello world\"},\n\t\t{\"\\thello world\", \"hello world\"},\n\t\t{\"\\nhello world\", \"hello world\"},\n\t\t{\"\\rhello world\", \"hello world\"},\n\t\t{\"\\t \\nhello world\", \"hello world\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := skipWSSlow(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"skipWSSlow(%q) = %q, want %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}","15a1bd9c4cb7d2c8250487d176211055":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic strings\n\t\t{\"hello\", \"hello\"},\n\t\t{\"world\", \"world\"},\n\n\t\t// Escaped characters\n\t\t{`\\\"hello\\\"`, `\"hello\"`},\n\t\t{`\\\\world\\\\`, `\\world\\`},\n\t\t{`\\bfoo\\tbar\\nbaz`, \"\\bfoo\\tbar\\nbaz\"},\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A0`, \"\\u00A0\"}, // Non-ASCII character\n\n\t\t// Invalid escape sequences\n\t\t{`\\z`, `\\z`},\n\t\t{`\\u002`, `\\u002`},\n\t\t{`\\u002x`, `\\u002x`},\n\n\t\t// Surrogate pairs\n\t\t{`\\uD83D\\uDE02`, \"\\U0001F602\"}, // FACE WITH TEARS OF JOY\n\t\t{`\\uD834\\uDD1E`, \"\\U0001D11E\"}, // MUSICAL SYMBOL G CLEF\n\n\t\t// Mixed valid and invalid escape sequences\n\t\t{`hello\\nworld\\z`, \"hello\\nworld\\z\"},\n\t\t{`\\u0020\\uD83D\\uDE02\\x`, \" \\U0001F602\\x\"},\n\t}\n\n\tfor i, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Test %d: Expected '%s', got '%s'\", i, test.expected, actual)\n\t\t}\n\t}\n}","15d7ed731d71f30fb541c89324e4ba82":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantValue *Value\n\t\twantTail string\n\t\twantErr   error\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\twantValue: nil,\n\t\t\twantTail:  \"\",\n\t\t\twantErr:   fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"object\",\n\t\t\tinput:    `{\"foo\": \"bar\"}`,\n\t\t\twantValue: \u0026Value{t: TypeObject},\n\t\t\twantTail:  \"\",\n\t\t\twantErr:   nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\twantValue: \u0026Value{t: TypeArray},\n\t\t\twantTail:  \"\",\n\t\t\twantErr:   nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\twantValue: \u0026Value{t: typeRawString, s: \"hello\"},\n\t\t\twantTail:  \"\",\n\t\t\twantErr:   nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"true\",\n\t\t\tinput:    \"true\",\n\t\t\twantValue: valueTrue,\n\t\t\twantTail:  \"\",\n\t\t\twantErr:   nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"false\",\n\t\t\tinput:    \"false\",\n\t\t\twantValue: valueFalse,\n\t\t\twantTail:  \"\",\n\t\t\twantErr:   nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"null\",\n\t\t\tinput:    \"null\",\n\t\t\twantValue: valueNull,\n\t\t\twantTail:  \"\",\n\t\t\twantErr:   nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN\",\n\t\t\tinput:    \"NaN\",\n\t\t\twantValue: \u0026Value{t: TypeNumber, s: \"NaN\"},\n\t\t\twantTail:  \"\",\n\t\t\twantErr:   nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"number\",\n\t\t\tinput:    \"12345\",\n\t\t\twantValue: \u0026Value{t: TypeNumber, s: \"12345\"},\n\t\t\twantTail:  \"\",\n\t\t\twantErr:   nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"unexpected value\",\n\t\t\tinput:    \"xyz\",\n\t\t\twantValue: nil,\n\t\t\twantTail:  \"xyz\",\n\t\t\twantErr:   fmt.Errorf(\"unexpected value found: %q\", \"xyz\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotValue, gotTail, gotErr := parseValue(tt.input, c, 0)\n\t\t\tif gotValue != nil \u0026\u0026 tt.wantValue != nil \u0026\u0026 gotValue.t != tt.wantValue.t {\n\t\t\t\tt.Errorf(\"parseValue() gotValue = %v, want %v\", gotValue, tt.wantValue)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseValue() gotTail = %v, want %v\", gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"parseValue() gotErr = %v, want %v\", gotErr, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}\n","164ccc2a2be2f8e88436d7a4daedb07f":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Test cases here\n\t\t{\n\t\t\tinput: `{}`,\n\t\t\twant: \u0026Value{\n\t\t\t\to: Object{},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\ttail: \"\",\n\t\t\terr:  nil,\n\t\t},\n\t\t{\n\t\t\tinput: `[]`,\n\t\t\twant: \u0026Value{\n\t\t\t\ta: []*Value{},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\ttail: \"\",\n\t\t\terr:  nil,\n\t\t},\n\t\t{\n\t\t\tinput: `\"test\"`,\n\t\t\twant: \u0026Value{\n\t\t\t\ts: \"test\",\n\t\t\t\tt: typeRawString,\n\t\t\t},\n\t\t\ttail: \"\",\n\t\t\terr:  nil,\n\t\t},\n\t\t{\n\t\t\tinput: `true`,\n\t\t\twant:  valueTrue,\n\t\t\ttail:  \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `false`,\n\t\t\twant:  valueFalse,\n\t\t\ttail:  \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `null`,\n\t\t\twant:  valueNull,\n\t\t\ttail:  \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `123`,\n\t\t\twant: \u0026Value{\n\t\t\t\ts: \"123\",\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\ttail: \"\",\n\t\t\terr:  nil,\n\t\t},\n\t\t{\n\t\t\tinput: `-123`,\n\t\t\twant: \u0026Value{\n\t\t\t\ts: \"-123\",\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\ttail: \"\",\n\t\t\terr:  nil,\n\t\t},\n\t\t{\n\t\t\tinput: `123.456`,\n\t\t\twant: \u0026Value{\n\t\t\t\ts: \"123.456\",\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\ttail: \"\",\n\t\t\terr:  nil,\n\t\t},\n\t\t{\n\t\t\tinput: `-123.456`,\n\t\t\twant: \u0026Value{\n\t\t\t\ts: \"-123.456\",\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\ttail: \"\",\n\t\t\terr:  nil,\n\t\t},\n\t\t{\n\t\t\tinput: `1.23e4`,\n\t\t\twant: \u0026Value{\n\t\t\t\ts: \"1.23e4\",\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\ttail: \"\",\n\t\t\terr:  nil,\n\t\t},\n\t\t{\n\t\t\tinput: `-1.23e4`,\n\t\t\twant: \u0026Value{\n\t\t\t\ts: \"-1.23e4\",\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\ttail: \"\",\n\t\t\terr:  nil,\n\t\t},\n\t\t{\n\t\t\tinput: `\"hello\" world`,\n\t\t\twant: \u0026Value{\n\t\t\t\ts: \"hello\",\n\t\t\t\tt: typeRawString,\n\t\t\t},\n\t\t\ttail: \" world\",\n\t\t\terr:  nil,\n\t\t},\n\t\t{\n\t\t\tinput: `NaN`,\n\t\t\twant: \u0026Value{\n\t\t\t\ts: \"NaN\",\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\ttail: \"\",\n\t\t\terr:  nil,\n\t\t},\n\t\t{\n\t\t\tinput: `{\"key\": \"value\"}`,\n\t\t\twant: \u0026Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: \u0026Value{s: \"value\", t: typeRawString}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\ttail: \"\",\n\t\t\terr:  nil,\n\t\t},\n\t\t{\n\t\t\tinput: `[1, \"test\"]`,\n\t\t\twant: \u0026Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{s: \"1\", t: TypeNumber},\n\t\t\t\t\t{s: \"test\", t: typeRawString},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\ttail: \"\",\n\t\t\terr:  nil,\n\t\t},\n\t}\n\n\tc := \u0026cache{}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tgot, tail, err := parseValue(tt.input, c, 0)\n\t\t\tif tt.err != nil {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"Expected error, got nil\")\n\t\t\t\t} else if err.Error() != tt.err.Error() {\n\t\t\t\t\tt.Errorf(\"Expected error %v, got %v\", tt.err, err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"Expected tail %q, got %q\", tt.tail, tail)\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"Test %d failed: input: %s, expected: %+v, got: %+v\", i, tt.input, tt.want, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\treturn v1.s == v2.s\n\t}\n}","16723f2ffc32b29d413163cff8fbb420":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey   string\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Basic cases\n\t\t{`\"foo\"bar`, \"foo\", \"bar\", nil},\n\t\t{`\"fo\\o\"bar`, \"fo\\o\", \"bar\", nil},\n\t\t{`\"foo\"`, \"foo\", \"\", nil},\n\t\t{`\"\"bar`, \"\", \"bar\", nil},\n\n\t\t// Escaped quotes\n\t\t{`\"foo\\\"bar\"baz`, `foo\"bar`, \"baz\", nil},\n\t\t{`\"foo\\\\\\\"bar\"baz`, `foo\\\"bar`, \"baz\", nil},\n\t\t{`\"foo\\\\\\\\\"bar\"baz`, `foo\\\\`, `bar\"baz`, nil},\n\n\t\t// Missing closing quote\n\t\t{`\"foobar`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo\\\"bar`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\n\t\t// Empty string\n\t\t{`\"\"`, \"\", \"\", nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d:%s\", i, tt.input), func(t *testing.T) {\n\t\t\tkey, tail, err := parseRawString(tt.input)\n\t\t\tif key != tt.key || tail != tt.tail || (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = (%q, %q, %v), want (%q, %q, %v)\", tt.input, key, tail, err, tt.key, tt.tail, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}","1776fcb07dc4d492159b07148dfcd15c":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Get(t *testing.T) {\n\tt.Run(\"null\", func(t *testing.T) {\n\t\tv := \u0026Value{t: TypeNull}\n\t\tif v.Get(\"key\") != nil {\n\t\t\tt.Errorf(\"expected nil, got %v\", v.Get(\"key\"))\n\t\t}\n\t})\n\n\tt.Run(\"object\", func(t *testing.T) {\n\t\tv := \u0026Value{\n\t\t\tt: TypeObject,\n\t\t\to: Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\n\t\tt.Run(\"existing key\", func(t *testing.T) {\n\t\t\tif got := v.Get(\"key1\"); got.s != \"value1\" {\n\t\t\t\tt.Errorf(\"expected 'value1', got %q\", got)\n\t\t\t}\n\t\t})\n\n\t\tt.Run(\"non-existing key\", func(t *testing.T) {\n\t\t\tif got := v.Get(\"key3\"); got != nil {\n\t\t\t\tt.Errorf(\"expected nil, got %v\", got)\n\t\t\t}\n\t\t})\n\n\t\tt.Run(\"nested key\", func(t *testing.T) {\n\t\t\tif got := v.Get(\"key2\"); got.s != \"123\" {\n\t\t\t\tt.Errorf(\"expected '123', got %q\", got)\n\t\t\t}\n\t\t})\n\t})\n\n\tt.Run(\"array\", func(t *testing.T) {\n\t\tv := \u0026Value{\n\t\t\tt: TypeArray,\n\t\t\ta: []*Value{\n\t\t\t\t{t: TypeString, s: \"value1\"},\n\t\t\t\t{t: TypeNumber, s: \"123\"},\n\t\t\t},\n\t\t}\n\n\t\tt.Run(\"valid index\", func(t *testing.T) {\n\t\t\tif got := v.Get(\"1\"); got.s != \"123\" {\n\t\t\t\tt.Errorf(\"expected '123', got %q\", got)\n\t\t\t}\n\t\t})\n\n\t\tt.Run(\"invalid index\", func(t *testing.T) {\n\t\t\tif got := v.Get(\"2\"); got != nil {\n\t\t\t\tt.Errorf(\"expected nil, got %v\", got)\n\t\t\t}\n\t\t})\n\n\t\tt.Run(\"negative index\", func(t *testing.T) {\n\t\t\tif got := v.Get(\"-1\"); got != nil {\n\t\t\t\tt.Errorf(\"expected nil, got %v\", got)\n\t\t\t}\n\t\t})\n\n\t\tt.Run(\"non-numeric index\", func(t *testing.T) {\n\t\t\tif got := v.Get(\"abc\"); got != nil {\n\t\t\t\tt.Errorf(\"expected nil, got %v\", got)\n\t\t\t}\n\t\t})\n\t})\n}","17b32a79b708d7306585f51b4a70cf38":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey   string\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Basic cases\n\t\t{`\"foo\"bar`, \"foo\", \"bar\", nil},\n\t\t{`\"fo\\\"o\"bar`, `fo\"o`, \"bar\", nil},\n\t\t{`\"foo\" bar`, \"foo\", \" bar\", nil},\n\n\t\t// Escaped quotes\n\t\t{`\"foo\\\\\"bar\"baz`, `foo\\bar`, \"baz\", nil},\n\t\t{`\"foo\\\\\\\\\"bar\"baz`, `foo\\\\`, `bar\"baz`, nil},\n\n\t\t// Missing closing quote\n\t\t{`\"foo`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo\"bar\"`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\n\t\t// Empty strings\n\t\t{`\"\"bar`, \"\", \"bar\", nil},\n\t\t{`\"foo\"\"\"`, \"foo\", `\"`, nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d:%s\", i, tt.input), func(t *testing.T) {\n\t\t\tkey, tail, err := parseRawString(tt.input)\n\t\t\tif key != tt.key || tail != tt.tail || !errorEqual(err, tt.err) {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = (%q, %q, %v), want (%q, %q, %v)\", tt.input, key, tail, err, tt.key, tt.tail, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc errorEqual(e1, e2 error) bool {\n\tif e1 == nil \u0026\u0026 e2 == nil {\n\t\treturn true\n\t}\n\tif e1 != nil \u0026\u0026 e2 != nil {\n\t\treturn e1.Error() == e2.Error()\n\t}\n\treturn false\n}\n","19b178d5d315f1ee4a910530c85798c5":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic escapes\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\t`, \"\\t\"},\n\t\t{`\\\\`, \"\\\\\"},\n\t\t{`\\\"`, \"\\\"\"},\n\t\t{`\\/`, \"/\"},\n\n\t\t// Unicode escapes\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A0`, \"\\u00A0\"},\n\t\t{`\\uFFFF`, \"\\uFFFF\"},\n\n\t\t// Surrogate pairs\n\t\t{`\\uD83D\\uDE01`, \"\\U0001F601\"},\n\n\t\t// Invalid escapes\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\uD800`, `\\uD800`},\n\t\t{`\\uD800\\u`, `\\uD800\\u`},\n\n\t\t// Mixed strings\n\t\t{`Hello\\tworld\\n`, \"Hello\\tworld\\n\"},\n\t\t{`\\u0041\\u0020string\\twith\\tsome\\tescapes`, \"A string\\twith\\tsome\\tescapes\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}","19b3a5701e18b77f98195cf754c31c57":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey   string\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Basic cases\n\t\t{`\"foo\"bar`, \"foo\", \"bar\", nil},\n\t\t{`\"fo\\\"o\"bar`, \"fo\\\"o\", \"bar\", nil},\n\t\t{`\"foo\"`, \"foo\", \"\", nil},\n\t\t{`\"\"bar`, \"\", \"bar\", nil},\n\n\t\t// Escaped quotes\n\t\t{`\"foo\\\\\"bar\"baz`, `foo\\\"bar`, \"baz\", nil},\n\t\t{`\"foo\\\\\\\\\"bar\"baz`, `foo\\\\`, `bar\"baz`, nil},\n\n\t\t// Missing closing quote\n\t\t{`\"foobar`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo\\\"bar`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\n\t\t// Empty strings\n\t\t{`\"\"`, \"\", \"\", nil},\n\t\t{`\"\"foo`, \"\", \"foo\", nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d:%s\", i, tt.input), func(t *testing.T) {\n\t\t\tkey, tail, err := parseRawString(tt.input)\n\t\t\tif key != tt.key || tail != tt.tail || !errorEqual(err, tt.err) {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = (%q, %q, %v), want (%q, %q, %v)\", tt.input, key, tail, err, tt.key, tt.tail, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// errorEqual compares two errors for equality.\nfunc errorEqual(e1, e2 error) bool {\n\tif e1 == nil \u0026\u0026 e2 == nil {\n\t\treturn true\n\t}\n\tif e1 == nil || e2 == nil {\n\t\treturn false\n\t}\n\treturn e1.Error() == e2.Error()\n}","19cc1c015d27484dc43e312ff7b721be":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ts     string\n\t\terr   error\n\t}{\n\t\t// Empty array\n\t\t{\"[]\", \u0026Value{t: TypeArray, a: []*Value{}}, \"\", nil},\n\t\t// Simple array\n\t\t{\"[1,2,3]\", \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t}}, \"\", nil},\n\t\t// Array with whitespace\n\t\t{\" [ 1 , 2 , 3 ] \", \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t}}, \"\", nil},\n\t\t// Nested array\n\t\t{\"[[1,2],[3,4]]\", \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t}},\n\t\t\t{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t{t: TypeNumber, s: \"4\"},\n\t\t\t}},\n\t\t}}, \"\", nil},\n\t\t// Array with different value types\n\t\t{`[\"a\",1,true,null]`, \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t{t: TypeString, s: \"a\"},\n\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t{t: TypeTrue},\n\t\t\t{t: TypeNull},\n\t\t}}, \"\", nil},\n\t\t// Invalid array: missing closing bracket\n\t\t{\"[1,2,3\", nil, \"\", fmt.Errorf(\"unexpected end of array\")},\n\t\t// Invalid array: missing comma\n\t\t{\"[1 2 3]\", nil, \"2 3]\", fmt.Errorf(\"missing ',' after array value\")},\n\t\t// Invalid array: trailing comma\n\t\t{\"[1,2,]\", nil, \"\", fmt.Errorf(\"cannot parse array value: unexpected end of JSON\")},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d:%s\", i, tt.input), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseArray(tt.input, c, 0)\n\t\t\tif (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"parseArray(%q) error = %v, wantErr %v\", tt.input, err, tt.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", tt.input, got, tt.want)\n\t\t\t}\n\t\t\tif s != tt.s {\n\t\t\t\tt.Errorf(\"parseArray(%q) s = %q, want %q\", tt.input, s, tt.s)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeString, TypeNumber:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\treturn true\n\t}\n}","1aa906ed44c98caf0327578912d5774d":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic escapes\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\t`, \"\\t\"},\n\t\t{`\\\\`, \"\\\\\"},\n\t\t{`\\\"`, \"\\\"\"},\n\t\t{`\\/`, \"/\"},\n\t\t{`\\b`, \"\\b\"},\n\t\t{`\\f`, \"\\f\"},\n\t\t{`\\r`, \"\\r\"},\n\n\t\t// Unicode escapes\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A0`, \"\\u00A0\"},\n\t\t{`\\u20AC`, \"\\u20AC\"},\n\t\t{`\\uD83D\\uDE02`, \"\\U0001F602\"}, // Surrogate pair\n\n\t\t// Invalid escapes\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\uD800`, `\\uD800`}, // Unpaired surrogate\n\t\t{`\\uDFFF`, `\\uDFFF`}, // Unpaired surrogate\n\n\t\t// Mixed content\n\t\t{`Hello\\tworld\\n`, \"Hello\\tworld\\n\"},\n\t\t{`\"This is a \\\\\"test\\\\\" string\"`, \"\\\"This is a \\\\\\\"test\\\\\\\" string\\\"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}","1b0cb5367fdb39bc465b2887e82894b3":"package fastjson\n\nimport \"testing\"\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tt    Type\n\t\twant string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.want, func(t *testing.T) {\n\t\t\tif got := tt.t.String(); got != tt.want {\n\t\t\t\tt.Errorf(\"Type.String() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","1bca194f17562f1a6b2bfbc4f35dc226":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCache_getValue(t *testing.T) {\n\tt.Run(\"empty cache\", func(t *testing.T) {\n\t\tc := \u0026cache{}\n\t\tv := c.getValue()\n\n\t\tif v == nil {\n\t\t\tt.Fatal(\"Expected a non-nil value, got nil\")\n\t\t}\n\n\t\tif len(c.vs) != 1 {\n\t\t\tt.Errorf(\"Expected cache length to be 1, got %d\", len(c.vs))\n\t\t}\n\t})\n\n\tt.Run(\"cache with values\", func(t *testing.T) {\n\t\tc := \u0026cache{\n\t\t\tvs: make([]Value, 5),\n\t\t}\n\t\tv := c.getValue()\n\n\t\tif v == nil {\n\t\t\tt.Fatal(\"Expected a non-nil value, got nil\")\n\t\t}\n\n\t\tif len(c.vs) != 7 {\n\t\t\tt.Errorf(\"Expected cache length to be 7, got %d\", len(c.vs))\n\t\t}\n\t})\n}","1c00ead46802235ac5eed2c1d0ca0b65":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetStringBytes(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tjson  string\n\t\tkeys  []string\n\t\twant  []byte\n\t\twant1 bool\n\t}{\n\t\t{\n\t\t\tname:  \"simple\",\n\t\t\tjson:  `{\"foo\":\"bar\"}`,\n\t\t\tkeys:  []string{\"foo\"},\n\t\t\twant:  []byte(\"bar\"),\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"nested\",\n\t\t\tjson:  `{\"foo\":{\"bar\":\"baz\"}}`,\n\t\t\tkeys:  []string{\"foo\", \"bar\"},\n\t\t\twant:  []byte(\"baz\"),\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array\",\n\t\t\tjson:  `{\"foo\":[\"bar\",\"baz\"]}`,\n\t\t\tkeys:  []string{\"foo\", \"1\"},\n\t\t\twant:  []byte(\"baz\"),\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array decimal index\",\n\t\t\tjson:  `{\"foo\":[\"bar\",\"baz\"]}`,\n\t\t\tkeys:  []string{\"foo\", \"1.0\"},\n\t\t\twant:  []byte(\"baz\"),\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"non-existing key\",\n\t\t\tjson:  `{\"foo\":\"bar\"}`,\n\t\t\tkeys:  []string{\"baz\"},\n\t\t\twant:  nil,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"invalid value type\",\n\t\t\tjson:  `{\"foo\":123}`,\n\t\t\tkeys:  []string{\"foo\"},\n\t\t\twant:  nil,\n\t\t\twant1: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv, err := ParseBytes([]byte(tt.json))\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"ParseBytes() error = %v, wantErr %v\", err, nil)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgot := v.GetStringBytes(tt.keys...)\n\t\t\tif !bytesEquals(got, tt.want) {\n\t\t\t\tt.Errorf(\"GetStringBytes() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc bytesEquals(a, b []byte) bool {\n\tif (a == nil \u0026\u0026 b != nil) || (a != nil \u0026\u0026 b == nil) {\n\t\treturn false\n\t}\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","1c610a9276eeb78e756f2c509ddd525f":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc Test_unescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello world\",\n\t\t\t},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"simple escape\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello\\\\tworld\",\n\t\t\t},\n\t\t\twant: \"hello\\tworld\",\n\t\t},\n\t\t{\n\t\t\tname: \"unicode escape\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello\\\\u0020world\",\n\t\t\t},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"surrogate escape\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello\\\\ud83d\\\\ude01world\",\n\t\t\t},\n\t\t\twant: \"helloüòÅworld\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid unicode escape\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello\\\\u123gworld\",\n\t\t\t},\n\t\t\twant: \"hello\\\\u123gworld\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid surrogate escape\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello\\\\ud83d\\\\u123gworld\",\n\t\t\t},\n\t\t\twant: \"hello\\\\ud83d\\\\u123gworld\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","1ce43c5fa81158f58acaadeba7b8f216":"package fastjson\n\nimport \"testing\"\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tinput Type\n\t\twant  string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\tfor i, tt := range tests {\n\t\tgot := tt.input.String()\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"test[%d]: String() = %q, want %q\", i, got, tt.want)\n\t\t}\n\t}\n}","1d6102038107577e8f368fb5065b7559":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantN    string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Basic cases\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"123.456\", \"123.456\", \"\", nil},\n\t\t{\"1.2e3\", \"1.2e3\", \"\", nil},\n\t\t{\"1.2E-3\", \"1.2E-3\", \"\", nil},\n\n\t\t// Trailing characters\n\t\t{\"123a\", \"123\", \"a\", nil},\n\t\t{\"123.456xyz\", \"123.456\", \"xyz\", nil},\n\n\t\t// Invalid numbers\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t\t{\"+\", \"\", \"+\", fmt.Errorf(\"unexpected char: %q\", \"+\")},\n\t\t(\"-\", \"\", \"-\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t\t(\".123\", \"\", \".123\", fmt.Errorf(\"unexpected char: %q\", \".\")},\n\t\t{\"1.2.3\", \"1.2\", \".3\", nil},\n\n\t\t// \"inf\" handling\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"+inf\", \"+inf\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"InF\", \"InF\", \"\", nil},\n\t\t{\"inF123\", \"inF\", \"123\", nil},\n\t\t{\"infin\", \"inf\", \"in\", nil},\n\t\t{\"123inf\", \"123\", \"inf\", nil},\n\t\t{\"+123inf\", \"+123\", \"inf\", nil},\n\t\t{\"-123inf\", \"-123\", \"inf\", nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d:%s\", i, tt.input), func(t *testing.T) {\n\t\t\tgotN, gotTail, gotErr := parseRawNumber(tt.input)\n\t\t\tif gotN != tt.wantN || gotTail != tt.wantTail || (gotErr != nil \u0026\u0026 tt.wantErr == nil) || (gotErr == nil \u0026\u0026 tt.wantErr != nil) || (gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error()) {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = (%q, %q, %v), want (%q, %q, %v)\", tt.input, gotN, gotTail, gotErr, tt.wantN, tt.wantTail, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","1dca8b16fd1f12843f54c38e028842d2":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetUint(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tjson  string\n\t\tkeys  []string\n\t\twant  uint\n\t\twant1 bool\n\t}{\n\t\t{\n\t\t\tname:  \"simple\",\n\t\t\tjson:  `{\"foo\":123}`,\n\t\t\tkeys:  []string{\"foo\"},\n\t\t\twant:  123,\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"nested\",\n\t\t\tjson:  `{\"foo\":{\"bar\":123}}`,\n\t\t\tkeys:  []string{\"foo\", \"bar\"},\n\t\t\twant:  123,\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array\",\n\t\t\tjson:  `{\"foo\":[123,456]}`,\n\t\t\tkeys:  []string{\"foo\", \"1\"},\n\t\t\twant:  456,\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array decimal\",\n\t\t\tjson:  `{\"foo\":[123,456]}`,\n\t\t\tkeys:  []string{\"foo\", \"1.0\"},\n\t\t\twant:  456,\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"non-existing key\",\n\t\t\tjson:  `{\"foo\":123}`,\n\t\t\tkeys:  []string{\"bar\"},\n\t\t\twant:  0,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"invalid value type\",\n\t\t\tjson:  `{\"foo\":\"bar\"}`,\n\t\t\tkeys:  []string{\"foo\"},\n\t\t\twant:  0,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"number from string\",\n\t\t\tjson:  `{\"foo\":\"123\"}`,\n\t\t\tkeys:  []string{\"foo\"},\n\t\t\twant:  0,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"overflow\",\n\t\t\tjson:  `{\"foo\":18446744073709551616}`,\n\t\t\tkeys:  []string{\"foo\"},\n\t\t\twant:  0,\n\t\t\twant1: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv := ParseBytes([]byte(tt.json))\n\t\t\tgot := v.GetUint(tt.keys...)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Value.GetUint() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","1ea4de15947de5848d3c8cf899c4801a":"package fastjson\n\nimport \"testing\"\n\nfunc TestTypeString(t *testing.T) {\n\t// Define test cases\n\ttests := []struct {\n\t\tinput Type\n\t\twant  string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\n\t// Iterate over test cases\n\tfor _, tc := range tests {\n\t\t// Call the String() method\n\t\tgot := tc.input.String()\n\n\t\t// Check if the result matches the expected value\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Type(%d).String() = %q; want %q\", tc.input, got, tc.want)\n\t\t}\n\t}\n}","1ef5dafc5651aab64d7c67dcd23d202e":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Get(t *testing.T) {\n\tt.Run(\"null\", func(t *testing.T) {\n\t\tvar v *Value\n\t\tgot := v.Get(\"key\")\n\t\tif got != nil {\n\t\t\tt.Errorf(\"Get() = %v, want nil\", got)\n\t\t}\n\t})\n\n\tt.Run(\"object\", func(t *testing.T) {\n\t\tv := \u0026Value{\n\t\t\tt: TypeObject,\n\t\t\to: Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\n\t\ttests := []struct {\n\t\t\tname string\n\t\t\tkeys []string\n\t\t\twant *Value\n\t\t}{\n\t\t\t{\n\t\t\t\tname: \"existing key\",\n\t\t\t\tkeys: []string{\"key1\"},\n\t\t\t\twant: \u0026Value{t: TypeString, s: \"value1\"},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"non-existing key\",\n\t\t\t\tkeys: []string{\"key3\"},\n\t\t\t\twant: nil,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"nested key\",\n\t\t\t\tkeys: []string{\"key2\"},\n\t\t\t\twant: \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t},\n\t\t}\n\n\t\tfor _, tt := range tests {\n\t\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t\tgot := v.Get(tt.keys...)\n\t\t\t\tif got != tt.want {\n\t\t\t\t\tt.Errorf(\"Get() = %v, want %v\", got, tt.want)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"array\", func(t *testing.T) {\n\t\tv := \u0026Value{\n\t\t\tt: TypeArray,\n\t\t\ta: []*Value{\n\t\t\t\t{t: TypeString, s: \"value1\"},\n\t\t\t\t{t: TypeNumber, s: \"123\"},\n\t\t\t},\n\t\t}\n\n\t\ttests := []struct {\n\t\t\tname string\n\t\t\tkeys []string\n\t\t\twant *Value\n\t\t}{\n\t\t\t{\n\t\t\t\tname: \"existing index\",\n\t\t\t\tkeys: []string{\"0\"},\n\t\t\t\twant: \u0026Value{t: TypeString, s: \"value1\"},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"non-existing index\",\n\t\t\t\tkeys: []string{\"2\"},\n\t\t\t\twant: nil,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"invalid index\",\n\t\t\t\tkeys: []string{\"abc\"},\n\t\t\t\twant: nil,\n\t\t\t},\n\t\t}\n\n\t\tfor _, tt := range tests {\n\t\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t\tgot := v.Get(tt.keys...)\n\t\t\t\tif got != tt.want {\n\t\t\t\t\tt.Errorf(\"Get() = %v, want %v\", got, tt.want)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t})\n}","2013af45e79fe47fbf01b0eaa4ee45fa":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twant     *Value\n\t\twantRest string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"empty array\",\n\t\t\tinput:    \"[]\",\n\t\t\twant:     \u0026Value{t: TypeArray},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"simple array\",\n\t\t\tinput:    \"[1,2,3]\",\n\t\t\twant:     \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with spaces\",\n\t\t\tinput:    \" [ 1 , 2 , 3 ] \",\n\t\t\twant:     \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"nested array\",\n\t\t\tinput:    \"[[1,2],[3,4]]\",\n\t\t\twant: \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}}},\n\t\t\t\t{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"3\"}, {t: TypeNumber, s: \"4\"}}},\n\t\t\t}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing closing bracket\",\n\t\t\tinput:    \"[1,2,3\",\n\t\t\twant:     nil,\n\t\t\twantRest: \"\",\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing comma\",\n\t\t\tinput:    \"[1,2 3]\",\n\t\t\twant:     nil,\n\t\t\twantRest: \"\",\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, rest, err := parseArray(tt.input, c, 0)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif rest != tt.wantRest {\n\t\t\t\tt.Errorf(\"parseArray() rest = %v, wantRest %v\", rest, tt.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.t == TypeArray {\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\treturn v1.s == v2.s\n}","20b5c1c1a4dfaafd124f9ff342248bef":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantN    string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Basic cases\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"123.456\", \"123.456\", \"\", nil},\n\t\t{\"-123.456\", \"-123.456\", \"\", nil},\n\t\t{\"1.2e3\", \"1.2e3\", \"\", nil},\n\t\t{\"1.2E3\", \"1.2E3\", \"\", nil},\n\t\t{\"-1.2e-3\", \"-1.2e-3\", \"\", nil},\n\n\t\t// Trailing characters\n\t\t{\"123a\", \"123\", \"a\", nil},\n\t\t{\"123.456a\", \"123.456\", \"a\", nil},\n\t\t{\"-123a\", \"-123\", \"a\", nil},\n\n\t\t// Invalid numbers\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t\t{\"a\", \"\", \"a\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\"-a\", \"\", \"-a\", fmt.Errorf(\"unexpected char: %q\", \"-a\")},\n\t\t{\"+a\", \"\", \"+a\", fmt.Errorf(\"unexpected char: %q\", \"+a\")},\n\t\t{\"1.2e\", \"1.2\", \"e\", nil},\n\n\t\t// Special values\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"+inf\", \"+inf\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"InF\", \"InF\", \"\", nil},\n\t\t{\"+InF\", \"+InF\", \"\", nil},\n\t\t{\"-InF\", \"-InF\", \"\", nil},\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"+nan\", \"+nan\", \"\", nil},\n\t\t{\"-nan\", \"-nan\", \"\", nil},\n\t\t{\"nAn\", \"nAn\", \"\", nil},\n\t\t{\"+nAn\", \"+nAn\", \"\", nil},\n\t\t{\"-nAn\", \"-nAn\", \"\", nil},\n\t\t{\"in\", \"\", \"in\", fmt.Errorf(\"unexpected char: %q\", \"i\")},\n\t\t{\"na\", \"\", \"na\", fmt.Errorf(\"unexpected char: %q\", \"n\")},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test %d: %s\", i, tt.input), func(t *testing.T) {\n\t\t\tgotN, gotTail, gotErr := parseRawNumber(tt.input)\n\t\t\tif gotN != tt.wantN {\n\t\t\t\tt.Errorf(\"parseRawNumber(%s) got number = %v, want %v\", tt.input, gotN, tt.wantN)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseRawNumber(%s) got tail = %v, want %v\", tt.input, gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif gotErr == nil \u0026\u0026 tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%s) got err = nil, want %v\", tt.input, tt.wantErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr == nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%s) got err = %v, want nil\", tt.input, gotErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"parseRawNumber(%s) got err = %v, want %v\", tt.input, gotErr, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","20bdc202f514624e2445ff26eb23a8bf":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_unescapeKeys(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tkvs  []kv\n\t\twant []kv\n\t}{\n\t\t{\n\t\t\tname: \"basic\",\n\t\t\tkvs: []kv{\n\t\t\t\t{k: \"key\\\\u0031\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}},\n\t\t\t},\n\t\t\twant: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"no escape\",\n\t\t\tkvs: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}},\n\t\t\t},\n\t\t\twant: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\to := \u0026Object{\n\t\t\t\tkvs: tt.kvs,\n\t\t\t}\n\t\t\to.unescapeKeys()\n\t\t\tfor i := range o.kvs {\n\t\t\t\tif o.kvs[i].k != tt.want[i].k {\n\t\t\t\t\tt.Errorf(\"unescapeKeys() got key = %v, want %v\", o.kvs[i].k, tt.want[i].k)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","20c0b47d55f6f1274b8c35f08b22d4a0":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  string\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Unescaped strings.\n\t\t{`\"foo\"bar`, `foo`, `bar`, nil},\n\t\t{`\"foo\\\"bar\"baz`, `foo\\\"bar`, `baz`, nil},\n\n\t\t// Escaped strings.\n\t\t{`\"\\\\\"foo`, `\\`, `foo`, nil},\n\t\t{`\"\\\\\\\"\"foo`, `\\\"`, `foo`, nil},\n\t\t{`\"\\\\\\\"foo`, `\\\"foo`, ``, nil},\n\n\t\t// Invalid strings.\n\t\t{`\"foo`, ``, ``, fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\\\"foo`, ``, ``, fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo\\\", \"bar\"`, ``, ``, fmt.Errorf(`missing closing '\"'`)},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tgot, tail, err := parseRawString(tt.input)\n\t\t\tif got != tt.want || tail != tt.tail || (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = %q, %q, %v, want %q, %q, %v\", tt.input, got, tail, err, tt.want, tt.tail, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}\n","20c410e6014f42776532d2abe3f935ad":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantStr  string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Simple cases\n\t\t{`\"hello\"`, \"hello\", \"\", nil},\n\t\t{`\"world\"tail`, \"world\", \"tail\", nil},\n\t\t{`\"\"`, \"\", \"\", nil},\n\n\t\t// Escaped quotes\n\t\t{`\"\\\\\"\"`, `\\\"`, \"\", nil},\n\t\t{`\"\\\\\\\"\"`, `\\\\\"`, \"\", nil},\n\t\t{`\"hello\\\\\"\"`, \"hello\\\\\\\"\", \"\", nil},\n\t\t{`\"hello\\\\\"world\"`, \"hello\\\\\\\"\", \"world\", nil},\n\t\t{`\"hello\\\\\\\\\"world\"`, \"hello\\\\\\\\\", \"world\", nil},\n\n\t\t// Invalid input\n\t\t{`\"missing quote`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"missing quote\\\\`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\\\\\"missing quote`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tgotStr, gotTail, gotErr := parseRawString(tt.input)\n\n\t\t\tif gotStr != tt.wantStr {\n\t\t\t\tt.Errorf(\"parseRawString(%q) got string = %q, want %q\", tt.input, gotStr, tt.wantStr)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseRawString(%q) got tail = %q, want %q\", tt.input, gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif gotErr == nil \u0026\u0026 tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"parseRawString(%q) got err = nil, want %v\", tt.input, tt.wantErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr == nil {\n\t\t\t\tt.Errorf(\"parseRawString(%q) got err = %v, want nil\", tt.input, gotErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"parseRawString(%q) got err = %v, want %v\", tt.input, gotErr, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","20f4fca86896e8b2a8b5f24aff6e129d":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic strings\n\t\t{\"hello\", \"hello\"},\n\t\t{\"world\", \"world\"},\n\n\t\t// Escaped characters\n\t\t{`\\\"`, `\"`},\n\t\t{`\\\\`, `\\`},\n\t\t{`\\/`, `/`},\n\t\t{`\\b`, \"\\b\"},\n\t\t{`\\f`, \"\\f\"},\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\r`, \"\\r\"},\n\t\t{`\\t`, \"\\t\"},\n\n\t\t// Unicode escape sequences\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u0041`, \"A\"},\n\t\t{`\\u00e9`, \"√©\"},\n\t\t{`\\u20ac`, \"‚Ç¨\"},\n\t\t{`\\uD83D\\uDE02`, \"üòÇ\"}, // Surrogate pair\n\n\t\t// Invalid escape sequences\n\t\t{`\\u`, `\\u`},\n\t\t{`\\u00`, `\\u00`},\n\t\t{`\\u002`, `\\u002`},\n\t\t{`\\u002x`, `\\u002x`},\n\t\t{`\\uD83D`, `\\uD83D`},\n\t\t{`\\uD83D\\u`, `\\uD83D\\u`},\n\t\t{`\\uD83D\\uDE`, `\\uD83D\\uDE`},\n\t\t{`\\uD83D\\uDE0`, `\\uD83D\\uDE0`},\n\t\t{`\\uD83D\\uDE0x`, `\\uD83D\\uDE0x`},\n\n\t\t// Mixed strings\n\t\t{`hello\\tworld`, \"hello\\tworld\"},\n\t\t{`\\u0041\\u0020string`, \"A string\"},\n\t\t{`Invalid\\u escape sequence`, `Invalid\\u escape sequence`},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Input: %q, Expected: %q, Actual: %q\", test.input, test.expected, actual)\n\t\t}\n\t}\n}","2100dd028b870c5605e39b71dc4b7a32":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantVal  *Value\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\twantVal:  nil,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t// Add more test cases here\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgotVal, gotTail, err := parseValue(tt.input, c, 0)\n\t\t\tif fmt.Sprintf(\"%v\", err) != fmt.Sprintf(\"%v\", tt.wantErr) {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseValue() gotTail = %v, want %v\", gotTail, tt.wantTail)\n\t\t\t}\n\t\t\t// Compare Value objects\n\t\t\tif !compareValues(gotVal, tt.wantVal) {\n\t\t\t\tt.Errorf(\"parseValue() gotVal = %v, want %v\", gotVal, tt.wantVal)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.s != v2.s {\n\t\treturn false\n\t}\n\t// Add comparisons for other fields as needed\n\treturn true\n}","21563450aa831ddb46cebdbf589fe705":"package fastjson\n\nimport \"testing\"\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tt    Type\n\t\twant string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\tfor i, tt := range tests {\n\t\tgot := tt.t.String()\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"test[%d]: String() = %q, want %q\", i, got, tt.want)\n\t\t}\n\t}\n}","219d017f87ef89c0155d62b9adcf69a1":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ts     string\n\t\terr   error\n\t}{\n\t\t// Empty object\n\t\t{\n\t\t\tinput: \"{}\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Single key-value pair\n\t\t{\n\t\t\tinput: `{\"key\": \"value\"}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: \u0026Value{t: TypeString, s: \"value\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Multiple key-value pairs\n\t\t{\n\t\t\tinput: `{\"key1\": \"value1\", \"key2\": 123, \"key3\": true}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t\t{k: \"key3\", v: \u0026Value{t: TypeTrue}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Nested object\n\t\t{\n\t\t\tinput: `{\"key1\": {\"key2\": \"value2\"}, \"key3\": \"value3\"}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{k: \"key3\", v: \u0026Value{t: TypeString, s: \"value3\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// With whitespace\n\t\t{\n\t\t\tinput: \" { \\\"key\\\" : \\\"value\\\" } \",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: \u0026Value{t: TypeString, s: \"value\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \" \",\n\t\t\terr: nil,\n\t\t},\n\t\t// Invalid JSON\n\t\t{\n\t\t\tinput: `{\"key\": \"value\"`,\n\t\t\twant:  nil,\n\t\t\ts:     `{\"key\": \"value\"`,\n\t\t\terr:   fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t\t{\n\t\t\tinput: `{key\": \"value\"}`,\n\t\t\twant:  nil,\n\t\t\ts:     `{key\": \"value\"}`,\n\t\t\terr:   fmt.Errorf(`cannot find opening '\"\" for object key`),\n\t\t},\n\t\t{\n\t\t\tinput: `{\"key\" \"value\"}`,\n\t\t\twant:  nil,\n\t\t\ts:     ` \"value\"}`,\n\t\t\terr:   fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseObject(tt.input, c, 0)\n\t\t\tif fmt.Sprintf(\"%v\", err) != fmt.Sprintf(\"%v\", tt.err) {\n\t\t\t\tt.Errorf(\"parseObject(%q) error = %v, want %v\", tt.input, err, tt.err)\n\t\t\t}\n\t\t\tif s != tt.s {\n\t\t\t\tt.Errorf(\"parseObject(%q) s = %q, want %q\", tt.input, s, tt.s)\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", tt.input, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\treturn true\n\t}\n}","21c8b9ab6e61b74c9c277e147ee024f4":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ts     string\n\t\terr   error\n\t}{\n\t\t// Test cases here\n\t\t{\n\t\t\tinput: `{\"key\": \"value\"}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: \u0026Value{t: TypeString, s: \"value\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tinput: `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tinput: `{\"key\": \"value\"`,\n\t\t\twant:  nil,\n\t\t\ts:     `{\"key\": \"value\"`,\n\t\t\terr:   fmt.Errorf(`missing '}'`),\n\t\t},\n\t\t{\n\t\t\tinput: `{key\": \"value\"}`,\n\t\t\twant:  nil,\n\t\t\ts:     `key\": \"value\"}`,\n\t\t\terr:   fmt.Errorf(`cannot find opening '\"\" for object key`),\n\t\t},\n\t\t{\n\t\t\tinput: `{\"key\" \"value\"}`,\n\t\t\twant:  nil,\n\t\t\ts:     `\"value\"}`,\n\t\t\terr:   fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t\t{\n\t\t\tinput: `{\"key\": \"value\",}`,\n\t\t\twant:  nil,\n\t\t\ts:     `}`,\n\t\t\terr:   fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseObject(tt.input, c, 0)\n\n\t\t\tif tt.err != nil {\n\t\t\t\tif err == nil || err.Error() != tt.err.Error() {\n\t\t\t\t\tt.Errorf(\"Expected error %v, but got %v\", tt.err, err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif err != tt.err {\n\t\t\t\tt.Errorf(\"Expected no error, but got %v\", err)\n\t\t\t}\n\t\t\tif s != tt.s {\n\t\t\t\tt.Errorf(\"Expected remaining string %q, but got %q\", tt.s, s)\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"Test %d failed: Expected\\n\\t%v\\nbut got\\n\\t%v\", i, tt.want, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t// Add cases for other types as needed\n\tdefault:\n\t\treturn false\n\t}\n}\n","21fe26a1eb0ca3f4d414e14beec4b95b":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"raw string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"raw string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"12345\",\n\t\t\t},\n\t\t\twant: []byte(\"12345\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"string\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"12345\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"[\\\"string\\\",12345]\"),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"string\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"string\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"number\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"12345\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"{\\\"string\\\":\\\"string\\\",\\\"number\\\":12345}\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif string(got) != string(tt.want) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %v, want %v\", string(got), string(tt.want))\n\t\t\t}\n\t\t})\n\t}\n}","240bda3681d592206cdcef8ff7978b96":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantObj  string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t{\n\t\t\tname:     \"empty object\",\n\t\t\tinput:    \"{}\",\n\t\t\twantObj:  `{\"t\":1}`,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"single key-value\",\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\twantObj:  `{\"t\":1,\"o\":{\"kvs\":[{\"k\":\"key\",\"v\":{\"t\":3,\"s\":\"value\"}}]}}`,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple key-values\",\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 123, \"key3\": true}`,\n\t\t\twantObj:  `{\"t\":1,\"o\":{\"kvs\":[{\"k\":\"key1\",\"v\":{\"t\":3,\"s\":\"value1\"}},{\"k\":\"key2\",\"v\":{\"t\":4,\"s\":\"123\"}},{\"k\":\"key3\",\"v\":{\"t\":5}}]}}`,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"nested object\",\n\t\t\tinput:    `{\"key1\": {\"key2\": \"value2\"}, \"key3\": \"value3\"}`,\n\t\t\twantObj:  `{\"t\":1,\"o\":{\"kvs\":[{\"k\":\"key1\",\"v\":{\"t\":1,\"o\":{\"kvs\":[{\"k\":\"key2\",\"v\":{\"t\":3,\"s\":\"value2\"}}]}}},{\"k\":\"key3\",\"v\":{\"t\":3,\"s\":\"value3\"}}]}}`,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing closing brace\",\n\t\t\tinput:    `{\"key\": \"value\"`,\n\t\t\twantObj:  \"\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"missing colon\",\n\t\t\tinput:    `{\"key\" \"value\"}`,\n\t\t\twantObj:  \"\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"missing comma\",\n\t\t\tinput:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantObj:  \"\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid key\",\n\t\t\tinput:    `{key: \"value\"}`,\n\t\t\twantObj:  \"\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  fmt.Errorf(\"cannot parse object key: cannot find opening '\\\"' for object key\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgotObj, gotTail, gotErr := parseObject(tt.input, c, 0)\n\n\t\t\tif gotErr != nil {\n\t\t\t\tif gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", gotErr, tt.wantErr)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif fmt.Sprintf(\"%#v\", gotObj) != tt.wantObj {\n\t\t\t\tt.Errorf(\"parseObject() gotObj = %v, want %v\", fmt.Sprintf(\"%#v\", gotObj), tt.wantObj)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseObject() gotTail = %v, want %v\", gotTail, tt.wantTail)\n\t\t\t}\n\t\t})\n\t}\n}\n","2442be74b57fe2079b5eff0a2bc0c33a":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Test cases here\n\t\t{\n\t\t\tinput: `{}`,\n\t\t\twant:  \u0026Value{t: TypeObject},\n\t\t\ttail:  \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `[]`,\n\t\t\twant:  \u0026Value{t: TypeArray},\n\t\t\ttail:  \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `\"foo\"`,\n\t\t\twant:  \u0026Value{t: typeRawString, s: \"foo\"},\n\t\t\ttail:  \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `true`,\n\t\t\twant:  valueTrue,\n\t\t\ttail:  \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `false`,\n\t\t\twant:  valueFalse,\n\t\t\ttail:  \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `null`,\n\t\t\twant:  valueNull,\n\t\t\ttail:  \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `123`,\n\t\t\twant:  \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\ttail:  \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `-123`,\n\t\t\twant:  \u0026Value{t: TypeNumber, s: \"-123\"},\n\t\t\ttail:  \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `1.23`,\n\t\t\twant:  \u0026Value{t: TypeNumber, s: \"1.23\"},\n\t\t\ttail:  \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `-1.23`,\n\t\t\twant:  \u0026Value{t: TypeNumber, s: \"-1.23\"},\n\t\t\ttail:  \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `1.23e4`,\n\t\t\twant:  \u0026Value{t: TypeNumber, s: \"1.23e4\"},\n\t\t\ttail:  \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `1.23e-4`,\n\t\t\twant:  \u0026Value{t: TypeNumber, s: \"1.23e-4\"},\n\t\t\ttail:  \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `NaN`,\n\t\t\twant:  \u0026Value{t: TypeNumber, s: \"NaN\"},\n\t\t\ttail:  \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `{\"foo\":\"bar\"}`,\n\t\t\twant: \u0026Value{t: TypeObject, o: Object{\n\t\t\t\tkvs: []kv{{k: \"foo\", v: \u0026Value{t: typeRawString, s: \"bar\"}}},\n\t\t\t}},\n\t\t\ttail: \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `[1,2,3]`,\n\t\t\twant: \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t}},\n\t\t\ttail: \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `\"foo\"bar`,\n\t\t\twant:  \u0026Value{t: typeRawString, s: \"foo\"},\n\t\t\ttail:  \"bar\",\n\t\t\terr:   nil,\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, tail, err := parseValue(tt.input, c, 0)\n\t\t\tif fmt.Sprintf(\"%v\", err) != fmt.Sprintf(\"%v\", tt.err) {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, wantErr %v\", tt.input, err, tt.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got == nil \u0026\u0026 tt.want == nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (got == nil \u0026\u0026 tt.want != nil) || (got != nil \u0026\u0026 tt.want == nil) {\n\t\t\t\tt.Errorf(\"parseValue(%q) got = %v, want %v\", tt.input, got, tt.want)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got.t != tt.want.t {\n\t\t\t\tt.Errorf(\"parseValue(%q) got type = %v, want %v\", tt.input, got.t, tt.want.t)\n\t\t\t}\n\t\t\tif got.s != tt.want.s {\n\t\t\t\tt.Errorf(\"parseValue(%q) got string = %v, want %v\", tt.input, got.s, tt.want.s)\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"parseValue(%q) got tail = %v, want %v\", tt.input, tail, tt.tail)\n\t\t\t}\n\t\t})\n\t}\n}\n","2450389b1bc6ad67b7ef7b1235a62386":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey   string\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Basic cases\n\t\t{`\"foo\"bar`, \"foo\", \"bar\", nil},\n\t\t{`\"foo\" bar`, \"foo\", \" bar\", nil},\n\t\t{`\"foo\"  bar`, \"foo\", \"  bar\", nil},\n\t\t{`\"foo\"`, \"foo\", \"\", nil},\n\t\t{`\"\"bar`, \"\", \"bar\", nil},\n\t\t{`\"\" bar`, \"\", \" bar\", nil},\n\t\t{`\"\"`, \"\", \"\", nil},\n\n\t\t// Escaped quotes\n\t\t{`\"\\\\\"bar`, `\\\"`, \"bar\", nil},\n\t\t{`\"\\\\\\\"\"bar`, `\\\"`, \"bar\", nil},\n\t\t{`\"\\\\\\\\\"bar`, `\\\\`, \"bar\", nil},\n\t\t{`\"\\\\\\\\\\\"\"bar`, `\\\\\\\"`, \"bar\", nil},\n\t\t{`\"foo\\\\\"bar\"baz`, `foo\\\"bar`, \"baz\", nil},\n\t\t{`\"foo\\\\\\\\\"bar\"baz`, `foo\\\\`, \"bar\\\"baz\", nil},\n\n\t\t// Invalid cases\n\t\t{`\"foo`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo\\\"`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo\\\\\\\"`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo\\\\\"bar`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d:%s\", i, tt.input), func(t *testing.T) {\n\t\t\tkey, tail, err := parseRawString(tt.input)\n\t\t\tif key != tt.key || tail != tt.tail || !errorEqual(err, tt.err) {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = (%q, %q, %v), want (%q, %q, %v)\", tt.input, key, tail, err, tt.key, tt.tail, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc errorEqual(e1, e2 error) bool {\n\tif e1 == nil \u0026\u0026 e2 == nil {\n\t\treturn true\n\t}\n\tif e1 == nil || e2 == nil {\n\t\treturn false\n\t}\n\treturn e1.Error() == e2.Error()\n}","2476caea5205f813f94d185bcf37165b":"package fastjson\n\nimport \"testing\"\n\nfunc TestValue_GetUint64(t *testing.T) {\n\tvar v Value\n\ttests := []struct {\n\t\tname  string\n\t\tjson  string\n\t\tkeys  []string\n\t\twant  uint64\n\t\twant1 bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tjson:  `{}`,\n\t\t\tkeys:  []string{\"foo\", \"bar\"},\n\t\t\twant:  0,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"uint64\",\n\t\t\tjson:  `{\"foo\": {\"bar\": 123}}`,\n\t\t\tkeys:  []string{\"foo\", \"bar\"},\n\t\t\twant:  123,\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"string\",\n\t\t\tjson:  `{\"foo\": {\"bar\": \"123\"}}`,\n\t\t\tkeys:  []string{\"foo\", \"bar\"},\n\t\t\twant:  0,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array index\",\n\t\t\tjson:  `{\"foo\": {\"bar\": [1, 123, 3]}}`,\n\t\t\tkeys:  []string{\"foo\", \"bar\", \"1\"},\n\t\t\twant:  123,\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array index out of bounds\",\n\t\t\tjson:  `{\"foo\": {\"bar\": [1, 2, 3]}}`,\n\t\t\tkeys:  []string{\"foo\", \"bar\", \"10\"},\n\t\t\twant:  0,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array invalid index\",\n\t\t\tjson:  `{\"foo\": {\"bar\": [1, 2, 3]}}`,\n\t\t\tkeys:  []string{\"foo\", \"bar\", \"xxx\"},\n\t\t\twant:  0,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array index float64\",\n\t\t\tjson:  `{\"foo\": {\"bar\": [1, 123, 3]}}`,\n\t\t\tkeys:  []string{\"foo\", \"bar\", \"1.0\"},\n\t\t\twant:  123,\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array index float64 invalid\",\n\t\t\tjson:  `{\"foo\": {\"bar\": [1, 123, 3]}}`,\n\t\t\tkeys:  []string{\"foo\", \"bar\", \"1.1\"},\n\t\t\twant:  0,\n\t\t\twant1: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv.Parse(tt.json)\n\t\t\tgot := v.GetUint64(tt.keys...)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"GetUint64() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","24aa5034a511785e1541e0d1a6b12b78":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestValue_Uint(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  uint\n\t\terr   error\n\t}{\n\t\t{\n\t\t\tinput: `123`,\n\t\t\twant:  123,\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `\"123\"`,\n\t\t\twant:  0,\n\t\t\terr:   fmt.Errorf(\"value doesn't contain number; it contains string\"),\n\t\t},\n\t\t{\n\t\t\tinput: `123.456`,\n\t\t\twant:  0,\n\t\t\terr:   fmt.Errorf(\"number \\\"123.456\\\" doesn't fit uint\"),\n\t\t},\n\t\t{\n\t\t\tinput: `9223372036854775808`,\n\t\t\twant:  0,\n\t\t\terr:   fmt.Errorf(\"number \\\"9223372036854775808\\\" doesn't fit uint\"),\n\t\t},\n\t\t{\n\t\t\tinput: `-1`,\n\t\t\twant:  0,\n\t\t\terr:   fmt.Errorf(\"number \\\"-1\\\" doesn't fit uint\"),\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tv := ParseString(tt.input)\n\t\t\tgot, err := v.Uint()\n\t\t\tif tt.err != nil {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"expected error, got nil\")\n\t\t\t\t} else if err.Error() != tt.err.Error() {\n\t\t\t\t\tt.Errorf(\"error mismatch: want %v, got %v\", tt.err, err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"output mismatch: want %v, got %v\", tt.want, got)\n\t\t\t}\n\t\t})\n\t}\n}","24e116bdb8eb228efbb3cb4d39692562":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Empty string\n\t\t{\"\", nil, \"\", fmt.Errorf(\"cannot parse empty string\")},\n\t\t// Invalid JSON\n\t\t{\"{invalid}\", nil, \"\", fmt.Errorf(\"cannot parse object: cannot parse key: invalid character 'i' in literal true (expecting 'r')\")},\n\t\t// Object\n\t\t{`{\"key\": \"value\"}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{t: typeRawString, s: \"value\"}}}}}}, \"\", nil},\n\t\t// Array\n\t\t{`[1, \"two\", true]`, \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: typeRawString, s: \"two\"}, {t: TypeTrue}}}, \"\", nil},\n\t\t// String\n\t\t{`\"hello\"`, \u0026Value{t: typeRawString, s: \"hello\"}, \"\", nil},\n\t\t// True\n\t\t{\"true\", valueTrue, \"\", nil},\n\t\t// False\n\t\t{\"false\", valueFalse, \"\", nil},\n\t\t// Null\n\t\t{\"null\", valueNull, \"\", nil},\n\t\t// Number\n\t\t{\"12345\", \u0026Value{t: TypeNumber, s: \"12345\"}, \"\", nil},\n\t\t// NaN\n\t\t{\"NaN\", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"\", nil},\n\t\t// Trailing whitespace\n\t\t{\"true  \", valueTrue, \"  \", nil},\n\t\t// Nested structures\n\t\t{`{\"array\": [1,2,3], \"object\": {\"key\": \"value\"}}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"array\", v: \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}}}, {k: \"object\", v: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{t: typeRawString, s: \"value\"}}}}}}}}}}, \"\", nil},\n\t}\n\n\tc := \u0026cache{}\n\tfor i, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tgot, tail, err := parseValue(test.input, c, 0)\n\n\t\t\tif (err != nil \u0026\u0026 test.err == nil) || (err == nil \u0026\u0026 test.err != nil) || (err != nil \u0026\u0026 test.err != nil \u0026\u0026 err.Error() != test.err.Error()) {\n\t\t\t\tt.Errorf(\"Test %d failed: got error %v, want %v\", i, err, test.err)\n\t\t\t}\n\n\t\t\tif got != nil \u0026\u0026 test.want != nil \u0026\u0026 got.t != test.want.t {\n\t\t\t\tt.Errorf(\"Test %d failed: got type %v, want %v\", i, got.t, test.want.t)\n\t\t\t}\n\n\t\t\tif tail != test.tail {\n\t\t\t\tt.Errorf(\"Test %d failed: got tail %q, want %q\", i, tail, test.tail)\n\t\t\t}\n\n\t\t\t// Compare values based on their types\n\t\t\tswitch got.t {\n\t\t\tcase TypeObject:\n\t\t\t\tif len(got.o.kvs) != len(test.want.o.kvs) {\n\t\t\t\t\tt.Errorf(\"Test %d failed: got object with %d keys, want %d keys\", i, len(got.o.kvs), len(test.want.o.kvs))\n\t\t\t\t}\n\t\t\t\t// Add more detailed object comparison if needed\n\t\t\tcase TypeArray:\n\t\t\t\tif len(got.a) != len(test.want.a) {\n\t\t\t\t\tt.Errorf(\"Test %d failed: got array with %d elements, want %d elements\", i, len(got.a), len(test.want.a))\n\t\t\t\t}\n\t\t\t\t// Add more detailed array comparison if needed\n\t\t\tdefault:\n\t\t\t\tif got.s != test.want.s {\n\t\t\t\t\tt.Errorf(\"Test %d failed: got value %q, want %q\", i, got.s, test.want.s)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n","24f6ab7fa227301c86006c63fd2bf228":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Get(t *testing.T) {\n\tt.Run(\"null\", func(t *testing.T) {\n\t\tv := \u0026Value{t: TypeNull}\n\t\tif got := v.Get(\"key\"); got != nil {\n\t\t\tt.Errorf(\"Get() = %v, want nil\", got)\n\t\t}\n\t})\n\n\tt.Run(\"object\", func(t *testing.T) {\n\t\tv := \u0026Value{\n\t\t\tt: TypeObject,\n\t\t\to: Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\n\t\ttests := []struct {\n\t\t\tname string\n\t\t\tkeys []string\n\t\t\twant *Value\n\t\t}{\n\t\t\t{\n\t\t\t\tname: \"existing key\",\n\t\t\t\tkeys: []string{\"key1\"},\n\t\t\t\twant: \u0026Value{t: TypeString, s: \"value1\"},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"non-existing key\",\n\t\t\t\tkeys: []string{\"key3\"},\n\t\t\t\twant: nil,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"nested key\",\n\t\t\t\tkeys: []string{\"key2\"},\n\t\t\t\twant: \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t},\n\t\t}\n\n\t\tfor _, tt := range tests {\n\t\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t\tif got := v.Get(tt.keys...); got != tt.want {\n\t\t\t\t\tt.Errorf(\"Get() = %v, want %v\", got, tt.want)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"array\", func(t *testing.T) {\n\t\tv := \u0026Value{\n\t\t\tt: TypeArray,\n\t\t\ta: []*Value{\n\t\t\t\t{t: TypeString, s: \"value1\"},\n\t\t\t\t{t: TypeNumber, s: \"123\"},\n\t\t\t},\n\t\t}\n\n\t\ttests := []struct {\n\t\t\tname string\n\t\t\tkeys []string\n\t\t\twant *Value\n\t\t}{\n\t\t\t{\n\t\t\t\tname: \"existing index\",\n\t\t\t\tkeys: []string{\"0\"},\n\t\t\t\twant: \u0026Value{t: TypeString, s: \"value1\"},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"non-existing index\",\n\t\t\t\tkeys: []string{\"2\"},\n\t\t\t\twant: nil,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"invalid index\",\n\t\t\t\tkeys: []string{\"abc\"},\n\t\t\t\twant: nil,\n\t\t\t},\n\t\t}\n\n\t\tfor _, tt := range tests {\n\t\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t\tif got := v.Get(tt.keys...); got != tt.want {\n\t\t\t\t\tt.Errorf(\"Get() = %v, want %v\", got, tt.want)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t})\n}","2571a7638b76ad2d74e4411f384573ac":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tinput   string\n\t\twant    *Value\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tp := \u0026Parser{}\n\t\t\tgot, err := p.Parse(tt.input)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Parse() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Parse() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","2598149e38f0e0fe920438f700e84475":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ts     string\n\t\terr   error\n\t}{\n\t\t// Empty object\n\t\t{\n\t\t\tinput: \"{}\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Simple object\n\t\t{\n\t\t\tinput: `{\"key1\": \"value1\", \"key2\": 123}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Nested object\n\t\t{\n\t\t\tinput: `{\"key1\": {\"key2\": \"value2\"}, \"key3\": true}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{k: \"key3\", v: \u0026Value{t: TypeTrue}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Missing closing brace\n\t\t{\n\t\t\tinput: `{\"key1\": \"value1\"`,\n\t\t\twant:  nil,\n\t\t\ts:     `{\"key1\": \"value1\"`,\n\t\t\terr:   fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t\t// Invalid key\n\t\t{\n\t\t\tinput: `{key1: \"value1\"}`,\n\t\t\twant:  nil,\n\t\t\ts:     `{key1: \"value1\"}`,\n\t\t\terr:   fmt.Errorf(`cannot find opening '\"\" for object key`),\n\t\t},\n\t\t// Missing colon\n\t\t{\n\t\t\tinput: `{\"key1\" \"value1\"}`,\n\t\t\twant:  nil,\n\t\t\ts:     `{\"key1\" \"value1\"}`,\n\t\t\terr:   fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t\t// Missing comma\n\t\t{\n\t\t\tinput: `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twant:  nil,\n\t\t\ts:     `\"key2\": \"value2\"}`,\n\t\t\terr:   fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tc := \u0026cache{}\n\t\tgot, s, err := parseObject(tt.input, c, 0)\n\t\tif fmt.Sprintf(\"%v\", err) != fmt.Sprintf(\"%v\", tt.err) {\n\t\t\tt.Errorf(\"Test %d: Expected error '%v', got '%v'\", i+1, tt.err, err)\n\t\t}\n\t\tif s != tt.s {\n\t\t\tt.Errorf(\"Test %d: Expected remaining string '%s', got '%s'\", i+1, tt.s, s)\n\t\t}\n\t\tif !equalValues(got, tt.want) {\n\t\t\tt.Errorf(\"Test %d: Expected value\\n%+v\\ngot\\n%+v\", i+1, tt.want, got)\n\t\t}\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\treturn true\n\t}\n}","25f24fcc36cc60aec68c7ede89d509c3":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantNum  string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Valid numbers\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"+123\", \"+123\", \"\", nil},\n\t\t{\"12.34\", \"12.34\", \"\", nil},\n\t\t{\"12e5\", \"12e5\", \"\", nil},\n\t\t{\"12E5\", \"12E5\", \"\", nil},\n\t\t{\"12e+5\", \"12e+5\", \"\", nil},\n\t\t{\"12e-5\", \"12e-5\", \"\", nil},\n\n\t\t// Valid numbers with trailing characters\n\t\t{\"123abc\", \"123\", \"abc\", nil},\n\t\t{\"-123xyz\", \"-123\", \"xyz\", nil},\n\t\t{\"12.34  \", \"12.34\", \"  \", nil},\n\n\t\t// Valid Infinity and NaN\n\t\t{\"Infinity\", \"Infinity\", \"\", nil},\n\t\t{\"+Infinity\", \"+Infinity\", \"\", nil},\n\t\t{\"-Infinity\", \"-Infinity\", \"\", nil},\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"+inf\", \"+inf\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"NaN\", \"NaN\", \"\", nil},\n\t\t{\"+NaN\", \"+NaN\", \"\", nil},\n\t\t{\"-NaN\", \"-NaN\", \"\", nil},\n\t\t{\"Infinityabc\", \"Infinity\", \"abc\", nil},\n\t\t{\"infi\", \"infi\", \"\", nil},\n\n\t\t// Invalid numbers\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t\t{\"a123\", \"\", \"a123\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\"+abc\", \"\", \"+abc\", fmt.Errorf(\"unexpected char: %q\", \"+\")},\n\t\t{\"12.34.56\", \"\", \"12.34.56\", nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d:%s\", i, tt.input), func(t *testing.T) {\n\t\t\tgotNum, gotTail, gotErr := parseRawNumber(tt.input)\n\n\t\t\tif gotNum != tt.wantNum {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got number = %q, want %q\", tt.input, gotNum, tt.wantNum)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got tail = %q, want %q\", tt.input, gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got error = %v, want %v\", tt.input, gotErr, tt.wantErr)\n\t\t\t} else if (gotErr != nil \u0026\u0026 tt.wantErr == nil) || (gotErr == nil \u0026\u0026 tt.wantErr != nil) {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got error = %v, want %v\", tt.input, gotErr, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","2611c8b38fe13525416c8e88ca98ba23":"package fastjson\n\nimport \"testing\"\n\nfunc TestSkipWS(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"  foo\", \"foo\"},\n\t\t{\"\\n\\tbar\", \"bar\"},\n\t\t{\"baz\", \"baz\"},\n\t\t{\"\", \"\"},\n\t\t{\"\\x00foo\", \"\\x00foo\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := skipWS(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"skipWS(%q) = %q, want %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}","26212585ff2cf80f2aa004def4351ae6":"package fastjson\n\nimport \"testing\"\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tt    Type\n\t\twant string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\n\tfor i, tt := range tests {\n\t\tgot := tt.t.String()\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"test[%d]. String() = %q, want %q\", i, got, tt.want)\n\t\t}\n\t}\n}","264992c214c752cc47b58bbf20058423":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ts     string\n\t\terr   error\n\t}{\n\t\t// Empty object.\n\t\t{\n\t\t\tinput: \"{}\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: nil,\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Single key-value.\n\t\t{\n\t\t\tinput: `{\"foo\":\"bar\"}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"foo\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"bar\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Multiple key-values.\n\t\t{\n\t\t\tinput: `{\"foo\":\"bar\", \"baz\": 123, \"qux\": true}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"foo\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"bar\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"baz\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"qux\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// With whitespace.\n\t\t{\n\t\t\tinput: \" { \\\"foo\\\" : \\\"bar\\\" } \",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"foo\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"bar\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \" \",\n\t\t\terr: nil,\n\t\t},\n\t\t// Invalid JSON.\n\t\t{\n\t\t\tinput: `{\"foo\":\"bar`,\n\t\t\twant:  nil,\n\t\t\ts:     `{\"foo\":\"bar`,\n\t\t\terr:   fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t\t{\n\t\t\tinput: `{\"foo\": \"bar\"`,\n\t\t\twant:  nil,\n\t\t\ts:     `{\"foo\": \"bar\"`,\n\t\t\terr:   fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i+1), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseObject(tt.input, c, 0)\n\t\t\tif fmt.Sprintf(\"%v\", err) != fmt.Sprintf(\"%v\", tt.err) {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif s != tt.s {\n\t\t\t\tt.Errorf(\"parseObject() s = %s, want %s\", s, tt.s)\n\t\t\t}\n\t\t\tif !compareValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(got, want *Value) bool {\n\tif got == nil \u0026\u0026 want == nil {\n\t\treturn true\n\t}\n\tif got == nil || want == nil {\n\t\treturn false\n\t}\n\tif got.t != want.t {\n\t\treturn false\n\t}\n\tif got.t == TypeObject {\n\t\tif len(got.o.kvs) != len(want.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range got.o.kvs {\n\t\t\tif got.o.kvs[i].k != want.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !compareValues(got.o.kvs[i].v, want.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\treturn got.s == want.s\n}\n","26e7b14d9c8c2b77c7f3fa7a3edd517c":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twant     *Value\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\twant:     nil,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"object\",\n\t\t\tinput:    `{\"foo\":\"bar\"}`,\n\t\t\twant:     \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: typeRawString, s: \"bar\"}}}}}},\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\twant:     \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}},\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"string\",\n\t\t\tinput:    `\"foo\"`,\n\t\t\twant:     \u0026Value{t: typeRawString, s: \"foo\"},\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"true\",\n\t\t\tinput:    \"true\",\n\t\t\twant:     valueTrue,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"false\",\n\t\t\tinput:    \"false\",\n\t\t\twant:     valueFalse,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"null\",\n\t\t\tinput:    \"null\",\n\t\t\twant:     valueNull,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"number\",\n\t\t\tinput:    \"123\",\n\t\t\twant:     \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN\",\n\t\t\tinput:    \"NaN\",\n\t\t\twant:     \u0026Value{t: typeRawString, s: \"NaN\"},\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, tail, err := parseValue(tt.input, c, 0)\n\t\t\tif (err != nil) != (tt.wantErr != nil) {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err != nil \u0026\u0026 err.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != nil \u0026\u0026 tt.want != nil \u0026\u0026 got.t != tt.want.t {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif tail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseValue() tail = %v, wantTail %v\", tail, tt.wantTail)\n\t\t\t}\n\t\t})\n\t}\n}\n","272c0c6a1e68be2b97a6035d445c2919":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic strings\n\t\t{\"hello\", \"hello\"},\n\t\t{\"world\", \"world\"},\n\n\t\t// Escaped characters\n\t\t{`\\\"hello\\\"`, `\"hello\"`},\n\t\t{`\\\\world\\\\`, `\\world\\`},\n\t\t{`\\bfoo\\tbar\\n`, \"\\bfoo\\tbar\\n\"},\n\n\t\t// Unicode escape sequences\n\t\t{`\\u0041`, \"A\"},\n\t\t{`\\u00e9`, \"√©\"},\n\t\t{`\\u20ac`, \"‚Ç¨\"},\n\n\t\t// Surrogate pairs\n\t\t{`\\uD83D\\uDE02`, \"üòÇ\"},\n\n\t\t// Invalid escape sequences\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\uD800`, `\\uD800`},\n\t\t{`\\uD800\\uDC00x`, `\\uD800\\uDC00x`},\n\n\t\t// Mixed strings\n\t\t{`hello\\t\"world\"`, \"hello\\t\\\"world\\\"\"},\n\t\t{`\\u0041\\u0020\\u0042\\u0021`, \"A B!\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}","27cd5aa55d8e553f006c9edbd010abf8":"package fastjson\n\nimport \"testing\"\n\nfunc Test_hasSpecialChars(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"Test with empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Test with regular string\",\n\t\t\targs: args{s: \"Hello, world!\"},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Test with string containing double quote\",\n\t\t\targs: args{s: \"Hello, \\\"world\\\"!\"},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Test with string containing backslash\",\n\t\t\targs: args{s: \"Hello, \\\\world\\\\!\"},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Test with string containing control character\",\n\t\t\targs: args{s: \"Hello, \\tworld!\"},\n\t\t\twant: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := hasSpecialChars(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"hasSpecialChars() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","2806f695f214a4e8dff15db27c43a129":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc Test_parseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tinput    string\n\t\twant    *Value\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseObject(tt.input, c, 1)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() err = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif fmt.Sprintf(\"%v\", got) != fmt.Sprintf(\"%v\", tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v, got string %v\", got, tt.want, s)\n\t\t\t}\n\t\t})\n\t}\n}","297412639b832349e7f5ce6fcb4c4db4":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey   string\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Basic cases\n\t\t{`\"foo\"bar`, \"foo\", \"bar\", nil},\n\t\t{`\"foo\" bar`, \"foo\", \" bar\", nil},\n\t\t{`\"foo\"  bar`, \"foo\", \"  bar\", nil},\n\t\t{`\"foo\"`, \"foo\", \"\", nil},\n\n\t\t// Escaped quotes\n\t\t{`\"fo\\\"o\"bar`, `fo\"o`, \"bar\", nil},\n\t\t{`\"fo\\\\\"o\"bar`, `fo\\\"o`, \"bar\", nil},\n\t\t{`\"fo\\\\\\\\\"o\"bar`, `fo\\\\\"o`, \"bar\", nil},\n\t\t{`\"fo\\\\\\\"o\"bar`, `fo\\\"o`, \"bar\", nil},\n\n\t\t// Missing closing quote\n\t\t{`\"foo`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"fo\\\"o`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\n\t\t// Empty strings\n\t\t{`\"\"bar`, \"\", \"bar\", nil},\n\t\t{`\"\" bar`, \"\", \" bar\", nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tkey, tail, err := parseRawString(tt.input)\n\t\t\tif err != nil \u0026\u0026 tt.err == nil {\n\t\t\t\tt.Errorf(\"expected nil error, got %v\", err)\n\t\t\t} else if err == nil \u0026\u0026 tt.err != nil {\n\t\t\t\tt.Errorf(\"expected error %v, got nil\", tt.err)\n\t\t\t} else if err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error() {\n\t\t\t\tt.Errorf(\"expected error %v, got %v\", tt.err, err)\n\t\t\t} else if key != tt.key {\n\t\t\t\tt.Errorf(\"expected key %q, got %q\", tt.key, key)\n\t\t\t} else if tail != tt.tail {\n\t\t\t\tt.Errorf(\"expected tail %q, got %q\", tt.tail, tail)\n\t\t\t}\n\t\t})\n\t}\n}","297a10288aca5d542180707ce840f7cb":"package fastjson\n\nimport \"testing\"\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"  foo\", \"foo\"},\n\t\t{\"\\n\\n\\tbar\", \"bar\"},\n\t\t{\"\\r\\n \\n  baz\", \"baz\"},\n\t\t{\"qux\", \"qux\"},\n\t\t{\"\", \"\"},\n\t\t{\"\\t\", \"\"},\n\t\t{\"\\n\\r\", \"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := skipWSSlow(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"skipWSSlow(%q) = %q, want %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}","2ac68ec39b10b3df95bc31cb624004c3":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ts     string\n\t\terr   error\n\t}{\n\t\t// Empty input.\n\t\t{\"\", nil, \"\", fmt.Errorf(\"missing ']'\")},\n\t\t// Empty array.\n\t\t{\"[]\", \u0026Value{t: TypeArray}, \"\", nil},\n\t\t// Simple array.\n\t\t{\"[1,2,3]\", \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}}, \"\", nil},\n\t\t// Array with different types.\n\t\t{\"[1,\\\"foo\\\",true]\", \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeString, s: \"foo\"}, {t: TypeTrue}}}, \"\", nil},\n\t\t// Array with nested array.\n\t\t{\"[[1,2],[3,4]]\", \u0026Value{t: TypeArray, a: []*Value{{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}}}, {t: TypeArray, a: []*Value{{t: TypeNumber, s: \"3\"}, {t: TypeNumber, s: \"4\"}}}}}, \"\", nil},\n\t\t// Array with whitespace.\n\t\t{\" [ 1 , 2 , 3 ] \", \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}}, \" \", nil},\n\t\t// Invalid array: missing ']'.\n\t\t{\"[1,2,3\", nil, \"[1,2,3\", fmt.Errorf(\"unexpected end of array\")},\n\t\t// Invalid array: missing ','.\n\t\t{\"[1 2,3]\", nil, \" 2,3]\", fmt.Errorf(\"missing ',' after array value\")},\n\t\t// Invalid array: trailing comma.\n\t\t{\"[1,2,3,] \", nil, \",] \", fmt.Errorf(\"cannot parse array value: unexpected end of JSON\")},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseArray(tt.input, c, 0)\n\t\t\tif fmt.Sprintf(\"%v\", err) != fmt.Sprintf(\"%v\", tt.err) {\n\t\t\t\tt.Errorf(\"parseArray(%q) error = %v, want %v\", tt.input, err, tt.err)\n\t\t\t}\n\t\t\tif s != tt.s {\n\t\t\t\tt.Errorf(\"parseArray(%q) s = %q, want %q\", tt.input, s, tt.s)\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", tt.input, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.s != v2.s {\n\t\treturn false\n\t}\n\tif len(v1.a) != len(v2.a) {\n\t\treturn false\n\t}\n\tfor i := range v1.a {\n\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n","2ad93eb098464d4bf66381bf823da026":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Get(t *testing.T) {\n\tt.Run(\"object\", func(t *testing.T) {\n\t\tv := MustParse(`{\"foo\": \"bar\", \"baz\": {\"qux\": 123}}`)\n\n\t\ttests := []struct {\n\t\t\tkeys []string\n\t\t\twant *Value\n\t\t}{\n\t\t\t{[]string{\"foo\"}, v.o.kvs[0].v},\n\t\t\t{[]string{\"baz\"}, v.o.kvs[1].v},\n\t\t\t{[]string{\"baz\", \"qux\"}, v.o.kvs[1].v.o.kvs[0].v},\n\t\t\t{[]string{\"nonexisting\"}, nil},\n\t\t\t{[]string{\"foo\", \"nonexisting\"}, nil},\n\t\t}\n\t\tfor _, tt := range tests {\n\t\t\tif got := v.Get(tt.keys...); got != tt.want {\n\t\t\t\tt.Errorf(\"Get() = %p, want %p\", got, tt.want)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"array\", func(t *testing.T) {\n\t\tv := MustParse(`[1, \"foo\", {\"bar\": \"baz\"}]`)\n\n\t\ttests := []struct {\n\t\t\tkeys []string\n\t\t\twant *Value\n\t\t}{\n\t\t\t{[]string{\"0\"}, v.a[0]},\n\t\t\t{[]string{\"1\"}, v.a[1]},\n\t\t\t{[]string{\"2\", \"bar\"}, v.a[2].o.kvs[0].v},\n\t\t\t{[]string{\"3\"}, nil},\n\t\t\t{[]string{\"0\", \"nonexisting\"}, nil},\n\t\t}\n\t\tfor _, tt := range tests {\n\t\t\tif got := v.Get(tt.keys...); got != tt.want {\n\t\t\t\tt.Errorf(\"Get() = %p, want %p\", got, tt.want)\n\t\t\t}\n\t\t}\n\t})\n}","2ae0ecdcd56d387cccfbe4e2f5863e58":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc Test_unescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello world\",\n\t\t\t},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"simple escape\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello\\\\tworld\",\n\t\t\t},\n\t\t\twant: \"hello\\tworld\",\n\t\t},\n\t\t{\n\t\t\tname: \"unicode escape\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello\\\\u0020world\",\n\t\t\t},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid unicode escape\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello\\\\u002world\",\n\t\t\t},\n\t\t\twant: \"hello\\\\u002world\",\n\t\t},\n\t\t{\n\t\t\tname: \"surrogate pair\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello\\\\uD83D\\\\uDE02world\",\n\t\t\t},\n\t\t\twant: \"helloüòÇworld\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid surrogate pair\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello\\\\uD83Dworld\",\n\t\t\t},\n\t\t\twant: \"hello\\\\uD83Dworld\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","2cb611f73ab55538a6a679daf9e960b9":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic escapes\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\t`, \"\\t\"},\n\t\t{`\\\\`, \"\\\\\"},\n\t\t{`\\\"`, \"\\\"\"},\n\t\t{`\\/`, \"/\"},\n\n\t\t// Unicode escapes\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A0`, \"\\u00A0\"},\n\t\t{`\\u20AC`, \"\\u20AC\"},\n\n\t\t// Surrogate pairs\n\t\t{`\\uD83D\\uDE02`, \"\\U0001F602\"},\n\n\t\t// Invalid escapes\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\uD800`, `\\uD800`}, // Invalid surrogate pair\n\t\t{`\\uD800\\u1234`, `\\uD800\\u1234`}, // Invalid surrogate pair\n\n\t\t// Mixed content\n\t\t{`Hello\\tworld\\n`, \"Hello\\tworld\\n\"},\n\t\t{`\"This is a \\\\\\\"quoted\\\\\\\" string\"`, \"\\\"This is a \\\\\\\"quoted\\\\\\\" string\\\"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.input, func(t *testing.T) {\n\t\t\tactual := unescapeStringBestEffort(test.input)\n\t\t\tif actual != test.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", test.input, actual, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n","2cbc97769b8869a07f477d36c29e51d9":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput       string\n\t\twantValue   *Value\n\t\twantTail    string\n\t\twantErr     bool\n\t\twantErrText string\n\t}{\n\t\t// Empty string\n\t\t{\n\t\t\tinput:       \"\",\n\t\t\twantValue:   nil,\n\t\t\twantTail:    \"\",\n\t\t\twantErr:     true,\n\t\t\twantErrText: \"cannot parse empty string\",\n\t\t},\n\t\t// Object\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\twantValue: \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: typeRawString}}}}},\n\t\t\twantTail:    \"\",\n\t\t\twantErr:     false,\n\t\t},\n\t\t// Array\n\t\t{\n\t\t\tinput:    `[1, \"two\", true]`,\n\t\t\twantValue: \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"two\", t: typeRawString}, {t: TypeTrue}}},\n\t\t\twantTail:    \"\",\n\t\t\twantErr:     false,\n\t\t},\n\t\t// String\n\t\t{\n\t\t\tinput:    `\"hello\"`,\n\t\t\twantValue: \u0026Value{s: \"hello\", t: typeRawString},\n\t\t\twantTail:    \"\",\n\t\t\twantErr:     false,\n\t\t},\n\t\t// True\n\t\t{\n\t\t\tinput:       \"true\",\n\t\t\twantValue:   valueTrue,\n\t\t\twantTail:    \"\",\n\t\t\twantErr:     false,\n\t\t},\n\t\t// False\n\t\t{\n\t\t\tinput:       \"false\",\n\t\t\twantValue:   valueFalse,\n\t\t\twantTail:    \"\",\n\t\t\twantErr:     false,\n\t\t},\n\t\t// Null\n\t\t{\n\t\t\tinput:       \"null\",\n\t\t\twantValue:   valueNull,\n\t\t\twantTail:    \"\",\n\t\t\twantErr:     false,\n\t\t},\n\t\t// NaN\n\t\t{\n\t\t\tinput:       \"NaN\",\n\t\t\twantValue:   \u0026Value{s: \"NaN\", t: TypeNumber},\n\t\t\twantTail:    \"\",\n\t\t\twantErr:     false,\n\t\t},\n\t\t// Number\n\t\t{\n\t\t\tinput:    \"123.456\",\n\t\t\twantValue: \u0026Value{s: \"123.456\", t: TypeNumber},\n\t\t\twantTail:    \"\",\n\t\t\twantErr:     false,\n\t\t},\n\t\t// Invalid value\n\t\t{\n\t\t\tinput:       \"invalid\",\n\t\t\twantValue:   nil,\n\t\t\twantTail:    \"invalid\",\n\t\t\twantErr:     true,\n\t\t\twantErrText: \"unexpected value found: \\\"invalid\\\"\",\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgotValue, gotTail, gotErr := parseValue(tt.input, c, 0)\n\n\t\t\tif (gotErr != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", gotErr, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotErr != nil \u0026\u0026 tt.wantErrText != \"\" \u0026\u0026 gotErr.Error() != tt.wantErrText {\n\t\t\t\tt.Errorf(\"parseValue() error text = %v, want error text %v\", gotErr.Error(), tt.wantErrText)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseValue() gotTail = %v, want %v\", gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif !equalValues(gotValue, tt.wantValue) {\n\t\t\t\tt.Errorf(\"parseValue() gotValue = %v, want %v\", gotValue, tt.wantValue)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.s != v2.s {\n\t\treturn false\n\t}\n\tif len(v1.a) != len(v2.a) {\n\t\treturn false\n\t}\n\tfor i := range v1.a {\n\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\treturn false\n\t}\n\tfor i := range v1.o.kvs {\n\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\treturn false\n\t\t}\n\t\tif !equalValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","2cc3b709604c5951ce3e82ebc9f8d8ad":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ts     string\n\t\terr   error\n\t}{\n\t\t// Empty object\n\t\t{\n\t\t\tinput: \"{}\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Simple object\n\t\t{\n\t\t\tinput: `{\"key1\": \"value1\", \"key2\": 123}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Nested object\n\t\t{\n\t\t\tinput: `{\"key1\": {\"key2\": \"value2\"}, \"key3\": true}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{k: \"key3\", v: \u0026Value{t: TypeTrue}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Missing closing brace\n\t\t{\n\t\t\tinput: `{\"key1\": \"value1\"`,\n\t\t\twant:  nil,\n\t\t\ts:     `{\"key1\": \"value1\"`,\n\t\t\terr:   fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t\t// Invalid key\n\t\t{\n\t\t\tinput: `{key1: \"value1\"}`,\n\t\t\twant:  nil,\n\t\t\ts:     `key1: \"value1\"}`,\n\t\t\terr:   fmt.Errorf(`cannot find opening '\"\" for object key`),\n\t\t},\n\t\t// Missing colon\n\t\t{\n\t\t\tinput: `{\"key1\" \"value1\"}`,\n\t\t\twant:  nil,\n\t\t\ts:     `\"value1\"}`,\n\t\t\terr:   fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t\t// Invalid value\n\t\t{\n\t\t\tinput: `{\"key1\": invalid}`,\n\t\t\twant:  nil,\n\t\t\ts:     `invalid}`,\n\t\t\terr:   fmt.Errorf(\"cannot parse object value: invalid character 'i' looking for beginning of value\"),\n\t\t},\n\t\t// Missing comma\n\t\t{\n\t\t\tinput: `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twant:  nil,\n\t\t\ts:     `\"key2\": \"value2\"}`,\n\t\t\terr:   fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseObject(tt.input, c, 0)\n\n\t\t\tif fmt.Sprintf(\"%v\", err) != fmt.Sprintf(\"%v\", tt.err) {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif s != tt.s {\n\t\t\t\tt.Errorf(\"parseObject() s = %s, want %s\", s, tt.s)\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeTrue, TypeFalse, TypeNull:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n","2ceadea7d3d22fb61a883ee6a8978095":"package fastjson\n\nimport \"testing\"\n\nfunc Test_parseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\ts      string\n\t\twantNs string\n\t\twantS  string\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}","2d5f2487d64d711a19307d18f38dabf3":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput    string\n\t\twantNum  string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Simple cases\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"123.456\", \"123.456\", \"\", nil},\n\t\t{\"-123.456\", \"-123.456\", \"\", nil},\n\t\t{\"1.23e+4\", \"1.23e+4\", \"\", nil},\n\t\t{\"1.23e-4\", \"1.23e-4\", \"\", nil},\n\n\t\t// Trailing characters\n\t\t{\"123a\", \"123\", \"a\", nil},\n\t\t{\"123.456a\", \"123.456\", \"a\", nil},\n\t\t{\"-123a\", \"-123\", \"a\", nil},\n\n\t\t// Invalid numbers\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t\t{\"a\", \"\", \"a\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\"-a\", \"\", \"-a\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t\t{\"+a\", \"\", \"+a\", fmt.Errorf(\"unexpected char: %q\", \"+\")},\n\n\t\t// Special values\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"+inf\", \"+inf\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"InF\", \"InF\", \"\", nil},\n\t\t{\"inF\", \"inF\", \"\", nil},\n\t\t{\"123inf\", \"123\", \"inf\", nil},\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"+nan\", \"+nan\", \"\", nil},\n\t\t{\"-nan\", \"-nan\", \"\", nil},\n\t\t{\"NaN\", \"NaN\", \"\", nil},\n\t\t{\"nAn\", \"nAn\", \"\", nil},\n\t\t{\"123nan\", \"123\", \"nan\", nil},\n\n\t\t// Invalid special values\n\t\t{\"in\", \"\", \"in\", fmt.Errorf(\"unexpected char: %q\", \"i\")},\n\t\t{\"na\", \"\", \"na\", fmt.Errorf(\"unexpected char: %q\", \"n\")},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"case_%d\", i), func(t *testing.T) {\n\t\t\tgotNum, gotTail, gotErr := parseRawNumber(tc.input)\n\n\t\t\tif gotNum != tc.wantNum {\n\t\t\t\tt.Errorf(\"Number mismatch. Want: %q, Got: %q\", tc.wantNum, gotNum)\n\t\t\t}\n\n\t\t\tif gotTail != tc.wantTail {\n\t\t\t\tt.Errorf(\"Tail mismatch. Want: %q, Got: %q\", tc.wantTail, gotTail)\n\t\t\t}\n\n\t\t\tif gotErr == nil \u0026\u0026 tc.wantErr != nil {\n\t\t\t\tt.Errorf(\"Error mismatch. Want: %v, Got: nil\", tc.wantErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tc.wantErr == nil {\n\t\t\t\tt.Errorf(\"Error mismatch. Want: nil, Got: %v\", gotErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tc.wantErr != nil \u0026\u0026 gotErr.Error() != tc.wantErr.Error() {\n\t\t\t\tt.Errorf(\"Error mismatch. Want: %v, Got: %v\", tc.wantErr, gotErr)\n\t\t\t}\n\t\t})\n\t}\n}","2d6e38d353e304097ec83f3d45819f1d":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantObj  string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t{\n\t\t\tname:     \"empty object\",\n\t\t\tinput:    \"{}\",\n\t\t\twantObj:  \"{}\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"simple object\",\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\twantObj:  `{\"key\": \"value\"}`,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"object with multiple values\",\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantObj:  `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"object with nested object\",\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": {\"nestedKey\": \"nestedValue\"}}`,\n\t\t\twantObj:  `{\"key1\": \"value1\", \"key2\": {\"nestedKey\": \"nestedValue\"}}`,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"object with array\",\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": [\"item1\", \"item2\"]}`,\n\t\t\twantObj:  `{\"key1\": \"value1\", \"key2\": [\"item1\", \"item2\"]}`,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"object with escaped characters\",\n\t\t\tinput:    `{\"key1\": \"value with \\\"escaped\\\" characters\"}`,\n\t\t\twantObj:  `{\"key1\": \"value with \\\"escaped\\\" characters\"}`,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid object: missing closing brace\",\n\t\t\tinput:    `{\"key\": \"value\"`,\n\t\t\twantObj:  \"\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid object: missing colon\",\n\t\t\tinput:    `{\"key\" \"value\"}`,\n\t\t\twantObj:  \"\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid object: missing comma\",\n\t\t\tinput:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantObj:  \"\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgotObj, gotTail, gotErr := parseObject(tt.input, c, 0)\n\n\t\t\tif gotErr != nil {\n\t\t\t\tif gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", gotErr, tt.wantErr)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"parseObject() error = nil, wantErr %v\", tt.wantErr)\n\t\t\t}\n\n\t\t\tgotObjStr := gotObj.String()\n\t\t\tif gotObjStr != tt.wantObj {\n\t\t\t\tt.Errorf(\"parseObject() gotObj = %s, wantObj %s\", gotObjStr, tt.wantObj)\n\t\t\t}\n\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseObject() gotTail = %s, wantTail %s\", gotTail, tt.wantTail)\n\t\t\t}\n\t\t})\n\t}\n}\n","2df992bd75b18193a3fe156e4b85d482":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantN    string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Basic cases.\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"123.456\", \"123.456\", \"\", nil},\n\t\t{\"1.2e3\", \"1.2e3\", \"\", nil},\n\t\t{\"1.2E-3\", \"1.2E-3\", \"\", nil},\n\n\t\t// Trailing garbage.\n\t\t{\"123a\", \"123\", \"a\", nil},\n\t\t{\"123.456xyz\", \"123.456\", \"xyz\", nil},\n\n\t\t// Leading garbage.\n\t\t{\"a123\", \"\", \"a123\", fmt.Errorf(`unexpected char: \"a\"`)},\n\n\t\t// Special values.\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"+inf\", \"+inf\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"infx\", \"inf\", \"x\", nil},\n\t\t{\"+Inf\", \"+Inf\", \"\", nil},\n\t\t{\"-inF\", \"-inF\", \"\", nil},\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"+nan\", \"+nan\", \"\", nil},\n\t\t{\"-nan\", \"-nan\", \"\", nil},\n\t\t{\"NaN\", \"NaN\", \"\", nil},\n\n\t\t// Invalid special values.\n\t\t{\"in\", \"\", \"in\", fmt.Errorf(`unexpected char: \"i\"`)},\n\t\t{\"+i\", \"\", \"+i\", fmt.Errorf(`unexpected char: \"+\"`)},\n\t\t{\"-n\", \"\", \"-n\", fmt.Errorf(`unexpected char: \"-\"`)},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tgotN, gotTail, gotErr := parseRawNumber(tt.input)\n\t\t\tif gotN != tt.wantN || gotTail != tt.wantTail || !equalError(gotErr, tt.wantErr) {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = (%q, %q, %v), want (%q, %q, %v)\", tt.input, gotN, gotTail, gotErr, tt.wantN, tt.wantTail, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// equalError reports whether errors a and b are considered equal.\n// They're equal if both are nil, or both are not nil and a.Error() == b.Error().\nfunc equalError(a, b error) bool {\n\treturn a == nil \u0026\u0026 b == nil || a != nil \u0026\u0026 b != nil \u0026\u0026 a.Error() == b.Error()\n}","2e1e87a1802ab10a8d0fff9413ec247c":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic strings\n\t\t{\"hello\", \"hello\"},\n\t\t{\"world\", \"world\"},\n\n\t\t// Escaped characters\n\t\t{`\\\"hello\\\"`, `\"hello\"`},\n\t\t{`\\\\world\\\\`, `\\world\\`},\n\t\t{`\\bfoo\\tbar\\nbaz`, \"\\bfoo\\tbar\\nbaz\"},\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A0`, \"\\u00A0\"},\n\n\t\t// Invalid escape sequences\n\t\t{`\\z`, `\\z`},\n\t\t{`\\u002`, `\\u002`},\n\t\t{`\\u002x`, `\\u002x`},\n\n\t\t// Surrogate pairs\n\t\t{`\\uD83D\\uDE02`, \"\\U0001F602\"},\n\t\t{`\\uD83D\\uDE02\\uD83D\\uDE02`, \"\\U0001F602\\U0001F602\"},\n\n\t\t// Mixed valid and invalid escape sequences\n\t\t{`hello\\nworld\\z`, \"hello\\nworld\\z\"},\n\t\t{`\\uD83D\\uDE02\\u0020\\u002x`, \"\\U0001F602 \\u002x\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}\n","2e2c86f97ac7952a6d612a1dfbcc2116":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Test cases here\n\t\t{\n\t\t\tinput: \"123\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\ttail: \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `\"abc\"`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"abc\",\n\t\t\t},\n\t\t\ttail: \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: \"true\",\n\t\t\twant:  valueTrue,\n\t\t\ttail:  \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: \"false\",\n\t\t\twant:  valueFalse,\n\t\t\ttail:  \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: \"null\",\n\t\t\twant:  valueNull,\n\t\t\ttail:  \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: \"nullx\",\n\t\t\twant:  nil,\n\t\t\ttail:  \"nullx\",\n\t\t\terr:   fmt.Errorf(\"unexpected value found: %q\", \"nullx\"),\n\t\t},\n\t}\n\n\tc := \u0026cache{}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tgot, tail, err := parseValue(tt.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tt.err == nil {\n\t\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif err.Error() != tt.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif got.t != tt.want.t {\n\t\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got.t, tt.want.t)\n\t\t\t\t}\n\t\t\t\tif got.s != tt.want.s {\n\t\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got.s, tt.want.s)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"parseValue() tail = %v, want %v\", tail, tt.tail)\n\t\t\t}\n\t\t})\n\t}\n}\n","2f909e3670e0008a815b20c6f7e8a3a7":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey   string\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Basic cases\n\t\t{`\"foo\"bar`, \"foo\", \"bar\", nil},\n\t\t{`\"fo\\\"o\"bar`, `fo\"o`, \"bar\", nil},\n\t\t{`\"foo\"`, \"foo\", \"\", nil},\n\t\t{`\"\"bar`, \"\", \"bar\", nil},\n\n\t\t// Escaped quotes\n\t\t{`\"foo\\\\\"bar`, `foo\\`, `bar`, nil},\n\t\t{`\"foo\\\\\\\\\"bar`, `foo\\\\`, \"bar\", nil},\n\t\t{`\"foo\\\"bar`, `\"foo\\\"bar`, \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo\\\\bar`, `\"foo\\\\bar`, \"\", fmt.Errorf(`missing closing '\"'`)},\n\n\t\t// Empty strings\n\t\t{`\"\"`, \"\", \"\", nil},\n\t\t{`\"`, `\"`, \"\", fmt.Errorf(`missing closing '\"'`)},\n\n\t\t// Invalid input\n\t\t{`foo\"bar`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo`, `\"foo`, \"\", fmt.Errorf(`missing closing '\"'`)},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d:%s\", i, tt.input), func(t *testing.T) {\n\t\t\tkey, tail, err := parseRawString(tt.input)\n\t\t\tif key != tt.key || tail != tt.tail || (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = (%q, %q, %v), want (%q, %q, %v)\", tt.input, key, tail, err, tt.key, tt.tail, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}\n","2fa92d72de8793804a62897e8d2d73f2":"package fastjson\n\nimport \"testing\"\n\nfunc TestTypeString(t *testing.T) {\n\t// Define test cases\n\ttests := []struct {\n\t\tinput Type\n\t\twant  string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\n\t// Iterate over the test cases\n\tfor _, tc := range tests {\n\t\t// Run the function and compare the result with the expected value\n\t\tif got := tc.input.String(); got != tc.want {\n\t\t\tt.Errorf(\"String() = %q, want %q\", got, tc.want)\n\t\t}\n\t}\n}","2fb0fc2eb32e058ac2dd842299b25569":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Get(t *testing.T) {\n\tt.Run(\"null\", func(t *testing.T) {\n\t\tvar v *Value\n\t\tgot := v.Get(\"key\")\n\t\tif got != nil {\n\t\t\tt.Errorf(\"Get() = %v, want nil\", got)\n\t\t}\n\t})\n\n\tt.Run(\"object\", func(t *testing.T) {\n\t\tv := \u0026Value{\n\t\t\tt: TypeObject,\n\t\t\to: Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\n\t\ttests := []struct {\n\t\t\tname string\n\t\t\tkeys []string\n\t\t\twant *Value\n\t\t}{\n\t\t\t{\n\t\t\t\tname: \"existing key\",\n\t\t\t\tkeys: []string{\"key1\"},\n\t\t\t\twant: \u0026Value{t: TypeString, s: \"value1\"},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"non-existing key\",\n\t\t\t\tkeys: []string{\"key3\"},\n\t\t\t\twant: nil,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"nested key\",\n\t\t\t\tkeys: []string{\"key2\"},\n\t\t\t\twant: \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t},\n\t\t}\n\n\t\tfor _, tt := range tests {\n\t\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t\tgot := v.Get(tt.keys...)\n\t\t\t\tif got != tt.want {\n\t\t\t\t\tt.Errorf(\"Get() = %v, want %v\", got, tt.want)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"array\", func(t *testing.T) {\n\t\tv := \u0026Value{\n\t\t\tt: TypeArray,\n\t\t\ta: []*Value{\n\t\t\t\t{t: TypeString, s: \"value1\"},\n\t\t\t\t{t: TypeNumber, s: \"123\"},\n\t\t\t},\n\t\t}\n\n\t\ttests := []struct {\n\t\t\tname string\n\t\t\tkeys []string\n\t\t\twant *Value\n\t\t}{\n\t\t\t{\n\t\t\t\tname: \"existing index\",\n\t\t\t\tkeys: []string{\"0\"},\n\t\t\t\twant: \u0026Value{t: TypeString, s: \"value1\"},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"non-existing index\",\n\t\t\t\tkeys: []string{\"2\"},\n\t\t\t\twant: nil,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"invalid index\",\n\t\t\t\tkeys: []string{\"abc\"},\n\t\t\t\twant: nil,\n\t\t\t},\n\t\t}\n\n\t\tfor _, tt := range tests {\n\t\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t\tgot := v.Get(tt.keys...)\n\t\t\t\tif got != tt.want {\n\t\t\t\t\tt.Errorf(\"Get() = %v, want %v\", got, tt.want)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t})\n}","2fe3ae84a715a014fd4df63781c671e4":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Empty string\n\t\t{\"\", nil, \"\", fmt.Errorf(\"cannot parse empty string\")},\n\t\t// Invalid JSON\n\t\t{\"{\", nil, \"{\", fmt.Errorf(\"cannot parse object: missing '}'\")},\n\t\t// Valid JSON - Object\n\t\t{`{\"foo\": \"bar\"}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: typeRawString, s: \"bar\"}}}}}, \"\", nil},\n\t\t// Valid JSON - Array\n\t\t{`[1, \"two\", true]`, \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: typeRawString, s: \"two\"}, {t: TypeTrue}}}, \"\", nil},\n\t\t// Valid JSON - String\n\t\t{`\"hello, world\"`, \u0026Value{t: typeRawString, s: \"hello, world\"}, \"\", nil},\n\t\t// Valid JSON - True\n\t\t{\"true\", valueTrue, \"\", nil},\n\t\t// Valid JSON - False\n\t\t{\"false\", valueFalse, \"\", nil},\n\t\t// Valid JSON - Null\n\t\t{\"null\", valueNull, \"\", nil},\n\t\t// Valid JSON - Number\n\t\t{\"12345\", \u0026Value{t: TypeNumber, s: \"12345\"}, \"\", nil},\n\t\t// Valid JSON - NaN\n\t\t{\"NaN\", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"\", nil},\n\t\t// Trailing whitespace\n\t\t{`\"hello\"  `, \u0026Value{t: typeRawString, s: \"hello\"}, \"  \", nil},\n\t\t// Invalid JSON - Unexpected value\n\t\t{\"invalid\", nil, \"invalid\", fmt.Errorf(\"unexpected value found: \\\"invalid\\\"\")},\n\t}\n\n\tc := \u0026cache{}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tgot, tail, err := parseValue(tt.input, c, 0)\n\t\t\tif (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, wantErr %v\", tt.input, err, tt.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != nil \u0026\u0026 tt.want != nil \u0026\u0026 got.t != tt.want.t {\n\t\t\t\tt.Errorf(\"parseValue(%q) type = %v, want %v\", tt.input, got.t, tt.want.t)\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"parseValue(%q) tail = %q, want %q\", tt.input, tail, tt.tail)\n\t\t\t}\n\t\t\t// Add more assertions based on the type of value\n\t\t\tswitch got.t {\n\t\t\tcase TypeObject:\n\t\t\t\tif len(got.o.kvs) != len(tt.want.o.kvs) {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) object len = %d, want %d\", tt.input, len(got.o.kvs), len(tt.want.o.kvs))\n\t\t\t\t}\n\t\t\tcase TypeArray:\n\t\t\t\tif len(got.a) != len(tt.want.a) {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) array len = %d, want %d\", tt.input, len(got.a), len(tt.want.a))\n\t\t\t\t}\n\t\t\tcase typeRawString:\n\t\t\t\tif got.s != tt.want.s {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) string = %q, want %q\", tt.input, got.s, tt.want.s)\n\t\t\t\t}\n\t\t\tcase TypeNumber:\n\t\t\t\tif got.s != tt.want.s {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) number = %q, want %q\", tt.input, got.s, tt.want.s)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n","2ff1850ae86de1ccc21484979242f638":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey string\n\t\tvalue string\n\t\terr error\n\t}{\n\t\t// Basic cases\n\t\t{`\"foo\"bar`, `foo`, `bar`, nil},\n\t\t{`\"foo\" bar`, `foo`, ` bar`, nil},\n\t\t{`\"foo\"  bar`, `foo`, `  bar`, nil},\n\t\t{`\"foo\"`, `foo`, ``, nil},\n\t\t{`\"\"bar`, ``, `bar`, nil},\n\n\t\t// Escaped quotes\n\t\t{`\"fo\\\"o\"bar`, `fo\"o`, `bar`, nil},\n\t\t{`\"fo\\\\\"o\"bar`, `fo\\\"o`, `bar`, nil},\n\t\t{`\"fo\\\\\\\\\"o\"bar`, `fo\\\\\"o`, `bar`, nil},\n\t\t{`\"fo\\\\\\\"o\"bar`, `fo\\\\\"o`, `bar`, nil},\n\n\t\t// Missing closing quote\n\t\t{`\"foo`, ``, ``, fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"fo\\\"o`, ``, ``, fmt.Errorf(`missing closing '\"'`)},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tkey, value, err := parseRawString(tt.input)\n\t\t\tif fmt.Sprintf(\"%v\", err) != fmt.Sprintf(\"%v\", tt.err) {\n\t\t\t\tt.Errorf(\"Test %d - Error mismatch. Expected %v, got %v\", i, tt.err, err)\n\t\t\t}\n\t\t\tif key != tt.key {\n\t\t\t\tt.Errorf(\"Test %d - Key mismatch. Expected '%s', got '%s'\", i, tt.key, key)\n\t\t\t}\n\t\t\tif value != tt.value {\n\t\t\t\tt.Errorf(\"Test %d - Value mismatch. Expected '%s', got '%s'\", i, tt.value, value)\n\t\t\t}\n\t\t})\n\t}\n}","2ff24b4095c848855256487499af5870":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Get(t *testing.T) {\n\tt.Run(\"object\", func(t *testing.T) {\n\t\tv := MustParse(`{\"foo\": {\"bar\": \"baz\"}}`)\n\t\tassert(t, v.Get(\"foo\", \"bar\").String() == \"baz\", \"Get failed\")\n\t\tassert(t, v.Get(\"foo\").Get(\"bar\").String() == \"baz\", \"Get failed\")\n\t})\n\n\tt.Run(\"array\", func(t *testing.T) {\n\t\tv := MustParse(`{\"foo\": [{\"bar\": \"baz\"}]}`)\n\t\tassert(t, v.Get(\"foo\", \"0\", \"bar\").String() == \"baz\", \"Get failed\")\n\t\tassert(t, v.Get(\"foo\").Get(\"0\").Get(\"bar\").String() == \"baz\", \"Get failed\")\n\t})\n\n\tt.Run(\"non-existing key\", func(t *testing.T) {\n\t\tv := MustParse(`{\"foo\": \"bar\"}`)\n\t\tassert(t, v.Get(\"baz\") == nil, \"Get returned non-nil for non-existing key\")\n\t})\n\n\tt.Run(\"nil value\", func(t *testing.T) {\n\t\tvar v *Value\n\t\tassert(t, v.Get(\"foo\") == nil, \"Get returned non-nil for nil value\")\n\t})\n}","2ff422ba8ebbc2fbda9512c1f666199b":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Get(t *testing.T) {\n\t// Test cases for Get function\n\ttests := []struct {\n\t\tname   string\n\t\tjson   string\n\t\tkeys   []string\n\t\texpect *Value\n\t}{\n\t\t{\n\t\t\t\"simple_object_existing_key\",\n\t\t\t`{\"name\": \"John\", \"age\": 30}`,\n\t\t\t[]string{\"name\"},\n\t\t\t\u0026Value{t: TypeString, s: \"John\"},\n\t\t},\n\t\t{\n\t\t\t\"simple_object_nonexisting_key\",\n\t\t\t`{\"name\": \"John\", \"age\": 30}`,\n\t\t\t[]string{\"gender\"},\n\t\t\tnil,\n\t\t},\n\t\t{\n\t\t\t\"nested_object_existing_key\",\n\t\t\t`{\"person\": {\"name\": \"John\", \"age\": 30}, \"city\": \"New York\"}`,\n\t\t\t[]string{\"person\", \"age\"},\n\t\t\t\u0026Value{t: TypeNumber, s: \"30\"},\n\t\t},\n\t\t{\n\t\t\t\"nested_object_nonexisting_key\",\n\t\t\t`{\"person\": {\"name\": \"John\", \"age\": 30}, \"city\": \"New York\"}`,\n\t\t\t[]string{\"person\", \"gender\"},\n\t\t\tnil,\n\t\t},\n\t\t{\n\t\t\t\"simple_array_existing_index\",\n\t\t\t`[10, 20, 30]`,\n\t\t\t[]string{\"1\"},\n\t\t\t\u0026Value{t: TypeNumber, s: \"20\"},\n\t\t},\n\t\t{\n\t\t\t\"simple_array_nonexisting_index\",\n\t\t\t`[10, 20, 30]`,\n\t\t\t[]string{\"3\"},\n\t\t\tnil,\n\t\t},\n\t\t{\n\t\t\t\"mixed_object_array_existing_key\",\n\t\t\t`{\"people\": [{\"name\": \"John\", \"age\": 30}, {\"name\": \"Jane\", \"age\": 25}], \"city\": \"New York\"}`,\n\t\t\t[]string{\"people\", \"1\", \"name\"},\n\t\t\t\u0026Value{t: TypeString, s: \"Jane\"},\n\t\t},\n\t\t{\n\t\t\t\"mixed_object_array_nonexisting_key\",\n\t\t\t`{\"people\": [{\"name\": \"John\", \"age\": 30}, {\"name\": \"Jane\", \"age\": 25}], \"city\": \"New York\"}`,\n\t\t\t[]string{\"people\", \"2\", \"name\"},\n\t\t\tnil,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tp := Parser{}\n\t\t\tv, err := p.Parse(tt.json)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Error parsing JSON: %v\", err)\n\t\t\t}\n\n\t\t\tgot := v.Get(tt.keys...)\n\t\t\tif (got == nil \u0026\u0026 tt.expect != nil) || (got != nil \u0026\u0026 tt.expect == nil) {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", tt.expect, got)\n\t\t\t} else if got != nil \u0026\u0026 tt.expect != nil {\n\t\t\t\tif got.Type() != tt.expect.Type() || got.String() != tt.expect.String() {\n\t\t\t\t\tt.Errorf(\"Expected %v, got %v\", tt.expect, got)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n","303ad9d4dc410347d2cbd3bf7c648fec":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_getKV(t *testing.T) {\n\to := Object{}\n\t// Test adding the first kv\n\tkv1 := o.getKV()\n\tkv1.k = \"key1\"\n\tif len(o.kvs) != 1 || o.kvs[0].k != \"key1\" {\n\t\tt.Errorf(\"Failed to add the first kv\")\n\t}\n\n\t// Test adding another kv\n\tkv2 := o.getKV()\n\tkv2.k = \"key2\"\n\tif len(o.kvs) != 2 || o.kvs[1].k != \"key2\" {\n\t\tt.Errorf(\"Failed to add the second kv\")\n\t}\n\n\t// Test reusing existing capacity\n\tkv3 := o.getKV()\n\tkv3.k = \"key3\"\n\tif len(o.kvs) != 3 || o.kvs[2].k != \"key3\" {\n\t\tt.Errorf(\"Failed to reuse existing capacity\")\n\t}\n}\n","303b207c74ac5ea4ce5afbb436c3bd7f":"package fastjson\n\nimport \"testing\"\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tt        Type\n\t\texpected string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\tfor _, test := range tests {\n\t\toutput := test.t.String()\n\t\tif output != test.expected {\n\t\t\tt.Errorf(\"Expected %q but got %q\", test.expected, output)\n\t\t}\n\t}\n}","3054603d186f99fd6bc0c1c19a1e5682":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic cases\n\t\t{\"\", \"\"},\n\t\t{\"hello\", \"hello\"},\n\t\t{\"world\\\\\\\"\", \"world\\\"\"},\n\t\t{\"\\\\\\\"\", \"\\\"\"},\n\t\t{\"\\\\\\\\\", \"\\\\\\\\\"},\n\n\t\t// Escape sequences\n\t\t{\"\\\\/\\\\b\\\\f\\\\n\\\\r\\\\t\", \"/\\b\\f\\n\\r\\t\"},\n\t\t{\"\\\\u0000\", \"\\x00\"},\n\t\t{\"\\\\u001A\", \"\\x1A\"},\n\t\t{\"\\\\u00FF\", \"\\xFF\"},\n\t\t{\"\\\\u0022\", \"\\\"\"},\n\t\t{\"\\\\u005C\", \"\\\\\"},\n\t\t{\"\\\\u002F\", \"/\"},\n\n\t\t// Invalid escape sequences\n\t\t{\"\\\\a\", \"\\\\a\"},\n\t\t{\"\\\\x\", \"\\\\x\"},\n\t\t{\"\\\\u\", \"\\\\u\"},\n\t\t{\"\\\\u00\", \"\\\\u00\"},\n\t\t{\"\\\\u000\", \"\\\\u000\"},\n\t\t{\"\\\\u000G\", \"\\\\u000G\"},\n\t\t{\"\\\\u123\", \"\\\\u123\"},\n\n\t\t// Surrogate pairs\n\t\t{\"\\\\uD83D\\\\uDE01\", \"\\U0001F601\"},\n\t\t{\"\\\\uD83D\\\\uDC68\\\\u200D\\\\uD83D\\\\uDC69\\\\u200D\\\\uD83D\\\\uDC67\\\\u200D\\\\uD83D\\\\uDC66\", \"\\U0001F468\\u200D\\U0001F469\\u200D\\U0001F467\\u200D\\U0001F466\"},\n\n\t\t// Mixed cases\n\t\t{\"hello\\\\tworld\\\\n\", \"hello\\tworld\\n\"},\n\t\t{\"\\\\\\\"hello\\\\\\\"\\\\t\\\\n\", \"\\\"hello\\\"\\t\\n\"},\n\t\t{\"\\\\/\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0000\\\\u001A\\\\u00FF\", \"/\\b\\f\\n\\r\\t\\x00\\x1A\\xFF\"},\n\t}\n\n\tfor i, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Test %d: Expected %q, got %q\", i, test.expected, actual)\n\t\t}\n\t}\n}","3081f2b7867988b78d42025b66c8cccd":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput  string\n\t\tns     string\n\t\ttail   string\n\t\thasErr bool\n\t}{\n\t\t{\"123\", \"123\", \"\", false},\n\t\t{\"123a\", \"123\", \"a\", false},\n\t\t{\"123.456\", \"123.456\", \"\", false},\n\t\t{\"-123\", \"-123\", \"\", false},\n\t\t{\"+123\", \"+123\", \"\", false},\n\t\t{\"1e5\", \"1e5\", \"\", false},\n\t\t{\"1E5\", \"1E5\", \"\", false},\n\t\t{\"1e+5\", \"1e+5\", \"\", false},\n\t\t{\"1e-5\", \"1e-5\", \"\", false},\n\t\t{\"a123\", \"\", \"a123\", true},\n\t\t{\"\", \"\", \"\", true},\n\t\t{\"-\", \"-\", \"\", true},\n\t\t{\"+\", \"+\", \"\", true},\n\t\t{\"-a\", \"\", \"-a\", true},\n\t\t{\"+a\", \"\", \"+a\", true},\n\t}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tns, tail, err := parseRawNumber(tt.input)\n\t\t\tif tt.hasErr \u0026\u0026 err == nil {\n\t\t\t\tt.Errorf(\"expected error, got nil\")\n\t\t\t}\n\t\t\tif !tt.hasErr \u0026\u0026 err != nil {\n\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t}\n\t\t\tif ns != tt.ns {\n\t\t\t\tt.Errorf(\"expected ns: %q, got %q\", tt.ns, ns)\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"expected tail: %q, got %q\", tt.tail, tail)\n\t\t\t}\n\t\t})\n\t}\n}","30a6bbea29b047461f96d6422567f1ed":"package fastjson\n\nimport \"testing\"\n\nfunc TestValue_GetInt(t *testing.T) {\n\tvar v Value\n\ttests := []struct {\n\t\tname string\n\t\tjson string\n\t\targs []string\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"simple\",\n\t\t\tjson: `{\"test\":1}`,\n\t\t\targs: []string{\"test\"},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"nested\",\n\t\t\tjson: `{\"test\":{\"nested\":2}}`,\n\t\t\targs: []string{\"test\", \"nested\"},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"array index\",\n\t\t\tjson: `{\"test\":[3, 4]}`,\n\t\t\targs: []string{\"test\", \"1\"},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"array index float\",\n\t\t\tjson: `{\"test\":[3, 4]}`,\n\t\t\targs: []string{\"test\", \"1.0\"},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"nonexistent key\",\n\t\t\tjson: `{\"test\":1}`,\n\t\t\targs: []string{\"nonexistent\"},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid value type\",\n\t\t\tjson: `{\"test\":\"string\"}`,\n\t\t\targs: []string{\"test\"},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"number out of int range\",\n\t\t\tjson: `{\"test\":9223372036854775808}`,\n\t\t\targs: []string{\"test\"},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv.Parse(tt.json)\n\t\t\tif got := v.GetInt(tt.args...); got != tt.want {\n\t\t\t\tt.Errorf(\"Value.GetInt() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","31708e9592fc730726c6da06f0a4e763":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetObject(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tjson  string\n\t\tkeys  []string\n\t\twant  *Object\n\t\twant1 bool\n\t}{\n\t\t{\n\t\t\tname:  \"simple\",\n\t\t\tjson:  `{\"a\":123}`,\n\t\t\tkeys:  []string{\"a\"},\n\t\t\twant:  nil,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"object\",\n\t\t\tjson:  `{\"a\":{\"b\":123}}`,\n\t\t\tkeys:  []string{\"a\"},\n\t\t\twant:  \u0026Object{kvs: []kv{{k: \"b\", v: \u0026Value{t: TypeNumber, s: \"123\"}}}},\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array\",\n\t\t\tjson:  `{\"a\":[1,2,3]}`,\n\t\t\tkeys:  []string{\"a\"},\n\t\t\twant:  nil,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"nested\",\n\t\t\tjson:  `{\"a\":{\"b\":{\"c\":123}}}`,\n\t\t\tkeys:  []string{\"a\", \"b\"},\n\t\t\twant:  \u0026Object{kvs: []kv{{k: \"c\", v: \u0026Value{t: TypeNumber, s: \"123\"}}}},\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array index\",\n\t\t\tjson:  `{\"a\":[1,{\"b\":2},3]}`,\n\t\t\tkeys:  []string{\"a\", \"1\"},\n\t\t\twant:  \u0026Object{kvs: []kv{{k: \"b\", v: \u0026Value{t: TypeNumber, s: \"2\"}}}},\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"non-existing key\",\n\t\t\tjson:  `{\"a\":123}`,\n\t\t\tkeys:  []string{\"b\"},\n\t\t\twant:  nil,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"invalid key type\",\n\t\t\tjson:  `{\"a\":123}`,\n\t\t\tkeys:  []string{\"\"},\n\t\t\twant:  nil,\n\t\t\twant1: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv, _ := ParseBytes([]byte(tt.json))\n\t\t\tgot, got1 := v.GetObject(tt.keys...)\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"Value.GetObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t\tif (got == nil \u0026\u0026 tt.want != nil) || (got != nil \u0026\u0026 tt.want == nil) {\n\t\t\t\tt.Errorf(\"Value.GetObject() got = %v, want %v\", got, tt.want)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != nil \u0026\u0026 tt.want != nil {\n\t\t\t\tfor i, kv := range got.kvs {\n\t\t\t\t\tif kv.k != tt.want.kvs[i].k {\n\t\t\t\t\t\tt.Errorf(\"Value.GetObject() key = %v, want %v\", kv.k, tt.want.kvs[i].k)\n\t\t\t\t\t}\n\t\t\t\t\tif kv.v.t != tt.want.kvs[i].v.t {\n\t\t\t\t\t\tt.Errorf(\"Value.GetObject() value type = %v, want %v\", kv.v.t, tt.want.kvs[i].v.t)\n\t\t\t\t\t}\n\t\t\t\t\tif kv.v.s != tt.want.kvs[i].v.s {\n\t\t\t\t\t\tt.Errorf(\"Value.GetObject() value = %v, want %v\", kv.v.s, tt.want.kvs[i].v.s)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","333e884dc25e2d7b7f3d4f1c2e529dc0":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantStr  string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Empty string.\n\t\t{\"\", \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\n\t\t// Non-empty string without '\"'.\n\t\t{\"abc\", \"abc\", \"\", nil},\n\n\t\t// String with single '\"'.\n\t\t{`\"abc\"def`, \"abc\", \"def\", nil},\n\n\t\t// String with escaped '\"' and then unescaped '\"'.\n\t\t{`\\\"abc\"def`, `\"abc`, \"def\", nil},\n\n\t\t// String with '\\\\'.\n\t\t{`\\\\\"abc\"def`, `\\\\`, `\"abc\"def`, nil},\n\n\t\t// String with escaped '\\'.\n\t\t{`\\\\\\abc\"def`, `\\\\abc`, `def`, nil},\n\n\t\t// String with '\"', '\\\\' and escaped '\"'.\n\t\t{`\\\"\\abc\\\"def`, `\\\"abc\"`, \"def\", nil},\n\n\t\t// String with multiple escaped '\"'.\n\t\t{`\"abc\\\\\\\"def\\\\\\\"\"ghi`, `abc\\\"def\\\"`, \"ghi\", nil},\n\n\t\t// String with uneven number of backslashes before a quote.\n\t\t{`\"abc\\\\\\\"\"def`, `abc\\`, `\"def`, nil},\n\n\t\t// String missing closing '\"'.\n\t\t{`\"abc`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\n\t\t// String with escaped '\"' at the end.\n\t\t{`abc\\\"`, `abc\\`, \"\", nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tgotStr, gotTail, gotErr := parseRawString(tt.input)\n\t\t\tif gotStr != tt.wantStr || gotTail != tt.wantTail || (gotErr != nil \u0026\u0026 tt.wantErr == nil) || (gotErr == nil \u0026\u0026 tt.wantErr != nil) || (gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error()) {\n\t\t\t\tt.Errorf(\"test[%d] - mismatch for input %q\\ngot:  %q, %q, %v\\nwant: %q, %q, %v\", i, tt.input, gotStr, gotTail, gotErr, tt.wantStr, tt.wantTail, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","33bbc286c9451caee7ebaaf46dcc21c3":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_reset(t *testing.T) {\n\to := \u0026Object{\n\t\tkvs: []kv{\n\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t},\n\t}\n\n\to.reset()\n\n\t// Check that the last element was removed\n\tif len(o.kvs) != 1 {\n\t\tt.Errorf(\"Expected length of kvs to be 1, got %d\", len(o.kvs))\n\t}\n\n\t// Check that the remaining element is the first one\n\tif o.kvs[0].k != \"key1\" || o.kvs[0].v.s != \"value1\" {\n\t\tt.Errorf(\"Expected first element to be {key1: value1}, got {%s: %s}\", o.kvs[0].k, o.kvs[0].v.s)\n\t}\n}","34b7165e20b8f325f1cd12eb03dfd9f7":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestValue_Int(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  int\n\t\terr   error\n\t}{\n\t\t{\n\t\t\tinput: `123`,\n\t\t\twant:  123,\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `-123`,\n\t\t\twant:  -123,\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `123.456`,\n\t\t\twant:  0,\n\t\t\terr:   fmt.Errorf(\"number \\\"123.456\\\" doesn't fit int\"),\n\t\t},\n\t\t{\n\t\t\tinput: `\"123\"`,\n\t\t\twant:  0,\n\t\t\terr:   fmt.Errorf(\"value doesn't contain number; it contains string\"),\n\t\t},\n\t\t{\n\t\t\tinput: `null`,\n\t\t\twant:  0,\n\t\t\terr:   fmt.Errorf(\"value doesn't contain number; it contains null\"),\n\t\t},\n\t\t{\n\t\t\tinput: `9223372036854775807`,\n\t\t\twant:  0,\n\t\t\terr:   fmt.Errorf(\"number \\\"9223372036854775807\\\" doesn't fit int\"),\n\t\t},\n\t\t{\n\t\t\tinput: `-9223372036854775808`,\n\t\t\twant:  0,\n\t\t\terr:   fmt.Errorf(\"number \\\"-9223372036854775808\\\" doesn't fit int\"),\n\t\t},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.input, func(t *testing.T) {\n\t\t\tv := \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: tc.input,\n\t\t\t}\n\t\t\tgot, err := v.Int()\n\t\t\tif tc.err != nil {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"expected error %v, got nil\", tc.err)\n\t\t\t\t} else if err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"expected error %v, got %v\", tc.err, err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t}\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tc.want, got)\n\t\t\t}\n\t\t})\n\t}\n}","34e720be16f6ed3adf8118013d3b1dfe":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantObj  string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t{\n\t\t\tname:     \"empty object\",\n\t\t\tinput:    \"{}\",\n\t\t\twantObj:  `{\"t\":1}`,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"simple object\",\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\twantObj:  `{\"t\":1,\"o\":{\"kvs\":[{\"k\":\"key\",\"v\":{\"t\":3,\"s\":\"value\"}}]}}`,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple key-value pairs\",\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 123, \"key3\": true}`,\n\t\t\twantObj:  `{\"t\":1,\"o\":{\"kvs\":[{\"k\":\"key1\",\"v\":{\"t\":3,\"s\":\"value1\"}},{\"k\":\"key2\",\"v\":{\"t\":4,\"s\":\"123\"}},{\"k\":\"key3\",\"v\":{\"t\":5}}]}}`,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"nested object\",\n\t\t\tinput:    `{\"key1\": {\"key2\": \"value2\"}, \"key3\": \"value3\"}`,\n\t\t\twantObj:  `{\"t\":1,\"o\":{\"kvs\":[{\"k\":\"key1\",\"v\":{\"t\":1,\"o\":{\"kvs\":[{\"k\":\"key2\",\"v\":{\"t\":3,\"s\":\"value2\"}}]}}},{\"k\":\"key3\",\"v\":{\"t\":3,\"s\":\"value3\"}}]}}`,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing closing brace\",\n\t\t\tinput:    `{\"key\": \"value\"`,\n\t\t\twantObj:  \"\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"missing colon\",\n\t\t\tinput:    `{\"key\" \"value\"}`,\n\t\t\twantObj:  \"\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"missing comma\",\n\t\t\tinput:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantObj:  \"\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgotObj, gotTail, gotErr := parseObject(tt.input, c, 0)\n\n\t\t\tif gotObj != nil {\n\t\t\t\tgotObjStr := gotObj.String()\n\t\t\t\tif gotObjStr != tt.wantObj {\n\t\t\t\t\tt.Errorf(\"parseObject() gotObj = %v, want %v\", gotObjStr, tt.wantObj)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif tt.wantObj != \"\" {\n\t\t\t\t\tt.Errorf(\"parseObject() gotObj = nil, want %v\", tt.wantObj)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseObject() gotTail = %v, want %v\", gotTail, tt.wantTail)\n\t\t\t}\n\n\t\t\tif gotErr == nil \u0026\u0026 tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"parseObject() gotErr = nil, want %v\", tt.wantErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr == nil {\n\t\t\t\tt.Errorf(\"parseObject() gotErr = %v, want nil\", gotErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 !gotErr.(*error).Error() == tt.wantErr.(*error).Error() {\n\t\t\t\tt.Errorf(\"parseObject() gotErr = %v, want %v\", gotErr, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","352054701a05c0ea76f056039ee028d9":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic strings.\n\t\t{\"hello\", \"hello\"},\n\t\t{\"world\", \"world\"},\n\n\t\t// Simple escape sequences.\n\t\t{`\\\"hello\\\"`, `\"hello\"`},\n\t\t{`\\\\world\\\\`, `\\world\\`},\n\t\t{`\\bfoo\\tbar\\n`, \"\\bfoo\\tbar\\n\"},\n\n\t\t// Unicode escape sequences.\n\t\t{`\\u0041`, \"A\"},\n\t\t{`\\u00e9`, \"√©\"},\n\t\t{`\\u20ac`, \"‚Ç¨\"},\n\n\t\t// Surrogate pairs.\n\t\t{`\\ud83d\\ude02`, \"üòÇ\"},\n\t\t{`\\ud83d\\udc4d`, \"üëç\"},\n\n\t\t// Invalid escape sequences.\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\ud83d`, `\\ud83d`},\n\t\t{`\\ud83d\\ud`, `\\ud83d\\ud`},\n\t\t{`\\ud83d\\udxxx`, `\\ud83d\\udxxx`},\n\n\t\t// Mixed valid and invalid escape sequences.\n\t\t{`hello\\xworld`, \"hello\\xworld\"},\n\t\t{`\\ud83dhello\\ude02world`, \"\\ud83dhelloüòÇworld\"},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.input, func(t *testing.T) {\n\t\t\tactual := unescapeStringBestEffort(tc.input)\n\t\t\tif actual != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n","36b8bc01cb6a97aac3ef6a838c4f1a2d":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  string\n\t}{\n\t\t// Basic cases\n\t\t{`\"hello, world\"`, \"hello, world\"},\n\t\t{`\"\\\\\"`, `\\`},\n\t\t{`\"\\\"\"`, `\"`},\n\t\t{`\"\\/\"`, `/`},\n\t\t{`\"\\b\"`, \"\\b\"},\n\t\t{`\"\\f\"`, \"\\f\"},\n\t\t{`\"\\n\"`, \"\\n\"},\n\t\t{`\"\\r\"`, \"\\r\"},\n\t\t{`\"\\t\"`, \"\\t\"},\n\n\t\t// Unicode escapes\n\t\t{`\"\\u0041\"`, \"A\"},\n\t\t{`\"\\u0061\"`, \"a\"},\n\t\t{`\"\\u041f\"`, \"–ü\"},\n\t\t{`\"\\u4e16\"`, \"‰∏ñ\"},\n\t\t{`\"\\u1f42a\"`, \"üê®\"},\n\n\t\t// Surrogate pairs\n\t\t{`\"\\uD83D\\uDC31\"`, \"üê±\"},\n\t\t{`\"\\uD83D\\uDE01\"`, \"üòÅ\"},\n\n\t\t// Invalid escape sequences\n\t\t{`\"\\x\"`, `\\x`},\n\t\t{`\"\\u123\"`, `\\u123`},\n\t\t{`\"\\uD800\"`, `\\uD800`},\n\t\t{`\"\\uD800\\u\"`, `\\uD800\\u`},\n\t\t{`\"\\uD800\\uD800\"`, `\\uD800\\uD800`},\n\n\t\t// Mixed cases\n\t\t{`\"hello\\tworld\"`, \"hello\\tworld\"},\n\t\t{`\"This is a \\\\\\\"test\\\\\\\"\"`, `This is a \"test\"`},\n\t\t{`\"\\\\u0041\\\\u0062\\\\u0063\\\\\"`, `Abc\\`},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tgot := unescapeStringBestEffort(tt.input)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", tt.input, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","387bddf6b1481bddeded9525ddd43a5d":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic strings without escape sequences.\n\t\t{\"hello\", \"hello\"},\n\t\t{\"world\", \"world\"},\n\t\t{\"12345\", \"12345\"},\n\n\t\t// Simple escape sequences.\n\t\t{`\\\"`, `\"`},\n\t\t{`\\\\`, `\\`},\n\t\t{`\\/`, `/`},\n\t\t{`\\b`, \"\\b\"},\n\t\t{`\\f`, \"\\f\"},\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\r`, \"\\r\"},\n\t\t{`\\t`, \"\\t\"},\n\n\t\t// Unicode escape sequences.\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A0`, \"\\u00A0\"},\n\t\t{`\\uFFFF`, \"\\uFFFF\"},\n\n\t\t// Surrogate pairs.\n\t\t{`\\uD83D\\uDE01`, \"\\U0001F601\"},\n\n\t\t// Invalid escape sequences.\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\uD800`, `\\uD800`},\n\t\t{`\\uD800\\u`, `\\uD800\\u`},\n\n\t\t// Mixed strings with valid and invalid escape sequences.\n\t\t{`hello\\tworld`, \"hello\\tworld\"},\n\t\t{`\\u0041\\x\\u0042\\u0043`, \"A\\xBC\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}","39322df48baace138a017c3d3bc1d3b5":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetArray(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tinput string\n\t\tkeys  []string\n\t\twant  []*Value\n\t}{\n\t\t// Test cases here\n\t\t{\n\t\t\tname:  \"EmptyArray\",\n\t\t\tinput: \"[]\",\n\t\t\tkeys:  []string{},\n\t\t\twant:  []*Value{},\n\t\t},\n\t\t{\n\t\t\tname:  \"SimpleArray\",\n\t\t\tinput: `[1, \"two\", true]`,\n\t\t\tkeys:  []string{},\n\t\t\twant: []*Value{\n\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t{t: TypeString, s: \"two\"},\n\t\t\t\t{t: TypeTrue},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"NestedArray\",\n\t\t\tinput: `[[1, 2], [3, 4]]`,\n\t\t\tkeys:  []string{\"1\"},\n\t\t\twant: []*Value{\n\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t{t: TypeNumber, s: \"4\"},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"NonExistingKey\",\n\t\t\tinput: `{\"key\": \"value\"}`,\n\t\t\tkeys:  []string{\"nonexisting\"},\n\t\t\twant:  nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"InvalidValueType\",\n\t\t\tinput: `\"string\"`,\n\t\t\tkeys:  []string{},\n\t\t\twant:  nil,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv, err := Parse([]byte(tt.input))\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Parse error: %v\", err)\n\t\t\t}\n\t\t\tgot := v.GetArray(tt.keys...)\n\t\t\tif (got == nil \u0026\u0026 tt.want != nil) || (got != nil \u0026\u0026 tt.want == nil) {\n\t\t\t\tt.Errorf(\"GetArray() = %v, want %v\", got, tt.want)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif len(got) != len(tt.want) {\n\t\t\t\tt.Errorf(\"GetArray() = %v, want %v\", got, tt.want)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tfor i := range got {\n\t\t\t\tif got[i].Type() != tt.want[i].Type() || got[i].String() != tt.want[i].String() {\n\t\t\t\t\tt.Errorf(\"GetArray() = %v, want %v\", got, tt.want)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","3a0ad62efe4f25d6536920f0034c4190":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic cases\n\t\t{`\"hello\"`, `hello`},\n\t\t{`\"hello\\\\world\"`, `hello\\world`},\n\t\t{`\"hello\\\\\\\"world\"`, `hello\\\"world`},\n\n\t\t// Escape sequences\n\t\t{`\"\\\\b\\\\f\\\\n\\\\r\\\\t\"`, \"\\b\\f\\n\\r\\t\"},\n\t\t{`\"\\\\u0228\"`, \"ƒÉ\"},\n\t\t{`\"\\\\uD83D\\\\uDE0A\"`, \"üòä\"},\n\n\t\t// Invalid escape sequences\n\t\t{`\"\\\\x\"`, \"\\\\x\"},\n\t\t{`\"\\\\u123\"`, \"\\\\u123\"},\n\t\t{`\"\\\\uD800\"`, \"\\\\uD800\"},\n\t\t{`\"\\\\uD800\\\\u1234\"`, \"\\\\uD800\\\\u1234\"},\n\n\t\t// Mixed cases\n\t\t{`\"hello\\\\tworld\\\\n\"`, \"hello\\tworld\\n\"},\n\t\t{`\"{\\\"key\\\":\\\\\\\"value\\\\\\\"}\"`, `{\"key\":\"value\"}`},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Input: %s, Expected: %s, Actual: %s\", test.input, test.expected, actual)\n\t\t}\n\t}\n}","3a398eada6bb87a5c52c84d718887602":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Object(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tv       *Value\n\t\twant    *Object\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{},\n\t\t\t},\n\t\t\twant:    \u0026Object{},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"not object\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"test\",\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := tt.v.Object()\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Object() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Object() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","3aaf7a1aae8189f0ac66ba79a7f3d3ae":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"raw string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"raw string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"12345\",\n\t\t\t},\n\t\t\twant: []byte(\"12345\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"string\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"12345\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"[\\\"string\\\",12345]\"),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"string\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"12345\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"{\\\"key1\\\":\\\"string\\\",\\\"key2\\\":12345}\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif string(got) != string(tt.want) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %v, want %v\", string(got), string(tt.want))\n\t\t\t}\n\t\t})\n\t}\n}\n","3b184aa717383a10e0642287c3ad0201":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ts     string\n\t\terr   error\n\t}{\n\t\t// Empty array\n\t\t{\n\t\t\tinput: \"[]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Simple array\n\t\t{\n\t\t\tinput: \"[1,2,3]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Array with whitespace\n\t\t{\n\t\t\tinput: \" [ 1 , 2 , 3 ] \",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Nested array\n\t\t{\n\t\t\tinput: \"[[1,2],[3,4]]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t\t\t\t{t: TypeNumber, s: \"4\"},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Error: missing ']'\n\t\t{\n\t\t\tinput: \"[1,2,3\",\n\t\t\twant:  nil,\n\t\t\ts:     \"[1,2,3\",\n\t\t\terr:   fmt.Errorf(\"missing ']'\"),\n\t\t},\n\t\t// Error: unexpected end of array\n\t\t{\n\t\t\tinput: \"[1,2,\",\n\t\t\twant:  nil,\n\t\t\ts:     \"[1,2,\",\n\t\t\terr:   fmt.Errorf(\"unexpected end of array\"),\n\t\t},\n\t\t// Error: missing ',' after array value\n\t\t{\n\t\t\tinput: \"[1 2]\",\n\t\t\twant:  nil,\n\t\t\ts:     \"2]\",\n\t\t\terr:   fmt.Errorf(\"missing ',' after array value\"),\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseArray(tt.input, c, 0)\n\n\t\t\tif (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"Test %d: error mismatch, got: %v, want: %v\", i, err, tt.err)\n\t\t\t}\n\t\t\tif s != tt.s {\n\t\t\t\tt.Errorf(\"Test %d: remaining string mismatch, got: %q, want: %q\", i, s, tt.s)\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"Test %d: value mismatch, got: %v, want: %v\", i, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.t == TypeArray {\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\treturn v1.s == v2.s\n}","3c43fd358c0d29f9399e5e3093638908":"package fastjson\n\nimport \"testing\"\n\nfunc TestSkipWS(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"  \\t\\n foo\", \"foo\"},\n\t\t{\"bar\", \"bar\"},\n\t\t{\"\", \"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := skipWS(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"skipWS(%q) = %q, expected %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}","3c5d58b5438759a28be54d5c21c2f82c":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Array(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tv       *Value\n\t\twant    []*Value\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := tt.v.Array()\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Value.Array() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.Array() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","3c85e974218694a7de9cb13fa4be2f63":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Test cases here\n\t\t{\n\t\t\tinput: \"null\",\n\t\t\twant:  valueNull,\n\t\t\ttail:  \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: \"true\",\n\t\t\twant:  valueTrue,\n\t\t\ttail:  \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: \"false\",\n\t\t\twant:  valueFalse,\n\t\t\ttail:  \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `\"hello\"`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\ttail: \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: \"123\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\ttail: \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: \"123.456\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\ttail: \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: \"{}\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{},\n\t\t\t},\n\t\t\ttail: \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: \"[]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\ttail: \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: \"NaN\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"Na\",\n\t\t\t},\n\t\t\ttail: \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t// Add more test cases for different scenarios\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d-%s\", i, tt.input), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, tail, err := parseValue(tt.input, c, 0)\n\t\t\tif tt.err != nil {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"Expected error, got nil\")\n\t\t\t\t} else if err.Error() != tt.err.Error() {\n\t\t\t\t\tt.Errorf(\"Expected error %v, got %v\", tt.err, err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"Expected tail %q, got %q\", tt.tail, tail)\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"Expected value %v, got %v\", tt.want, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeNull, TypeTrue, TypeFalse:\n\t\treturn true\n\tcase TypeNumber, typeRawString:\n\t\treturn v1.s == v2.s\n\tcase TypeObject:\n\t\tif v1.o.keysUnescaped != v2.o.keysUnescaped {\n\t\t\treturn false\n\t\t}\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n","3d1a0785dcf3d2378895c989662c217c":"package fastjson\n\nimport \"testing\"\n\nfunc TestValue_GetInt(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tjson string\n\t\targs []string\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"simple\",\n\t\t\tjson: `{\"test\":123}`,\n\t\t\targs: []string{\"test\"},\n\t\t\twant: 123,\n\t\t},\n\t\t{\n\t\t\tname: \"nested\",\n\t\t\tjson: `{\"test\":{\"nested\":456}}`,\n\t\t\targs: []string{\"test\", \"nested\"},\n\t\t\twant: 456,\n\t\t},\n\t\t{\n\t\t\tname: \"array index\",\n\t\t\tjson: `{\"test\":[123, 456]}`,\n\t\t\targs: []string{\"test\", \"1\"},\n\t\t\twant: 456,\n\t\t},\n\t\t{\n\t\t\tname: \"array index decimal\",\n\t\t\tjson: `{\"test\":[123, 456]}`,\n\t\t\targs: []string{\"test\", \"1.0\"},\n\t\t\twant: 456,\n\t\t},\n\t\t{\n\t\t\tname: \"nonexistent key\",\n\t\t\tjson: `{\"test\":123}`,\n\t\t\targs: []string{\"nonexistent\"},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid value type\",\n\t\t\tjson: `{\"test\":\"string\"}`,\n\t\t\targs: []string{\"test\"},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv, _ := Parse(tt.json)\n\t\t\tif got := v.GetInt(tt.args...); got != tt.want {\n\t\t\t\tt.Errorf(\"Value.GetInt() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","3d2d4a89f500c5677c5352bea33edf13":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantJSON string\n\t\twantErr  error\n\t}{\n\t\t{\n\t\t\tname:     \"empty object\",\n\t\t\tinput:    \"{}\",\n\t\t\twantJSON: `{}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"simple object\",\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 123}`,\n\t\t\twantJSON: `{\"key1\": \"value1\", \"key2\": 123}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"nested object\",\n\t\t\tinput:    `{\"key1\": {\"key2\": \"value2\"}, \"key3\": [1,2,3]}`,\n\t\t\twantJSON: `{\"key1\": {\"key2\": \"value2\"}, \"key3\": [1, 2, 3]}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"object with escaped characters\",\n\t\t\tinput:    `{\"key1\": \"value with \\\"escaped\\\" characters\"}`,\n\t\t\twantJSON: `{\"key1\": \"value with \\\"escaped\\\" characters\"}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid object: missing closing brace\",\n\t\t\tinput:    `{\"key1\": \"value1\"`,\n\t\t\twantErr: fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid object: missing colon\",\n\t\t\tinput:    `{\"key1\" \"value1\"}`,\n\t\t\twantErr: fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid object: missing comma\",\n\t\t\tinput:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, tail, err := parseObject(tt.input, c, 0)\n\n\t\t\tif tt.wantErr != nil {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"parseObject() error = nil, wantErr %v\", tt.wantErr)\n\t\t\t\t} else if err.Error() != tt.wantErr.Error() {\n\t\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr nil\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif len(tail) != 0 {\n\t\t\t\tt.Errorf(\"parseObject() tail = %q, want empty\", tail)\n\t\t\t}\n\n\t\t\tgotJSON := got.MarshalTo(nil)\n\t\t\tif string(gotJSON) != tt.wantJSON {\n\t\t\t\tt.Errorf(\"parseObject() = %s, want %s\", gotJSON, tt.wantJSON)\n\t\t\t}\n\t\t})\n\t}\n}\n","3d6e3f3ce2b90894ed5585626a6d5265":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEscapeString(t *testing.T) {\n\ttests := []struct {\n\t\tin  string\n\t\tout string\n\t}{\n\t\t{\"\", `\"\"`},\n\t\t{\"hello\", `\"hello\"`},\n\t\t{\"\\t\\n\\r\", `\"\\t\\n\\r\"`},\n\t\t{\"\\x00\\x01\\x02\", `\"\\u0000\\u0001\\u0002\"`},\n\t\t{\"\\u0000\\u0001\\u0002\", `\"\\u0000\\u0001\\u0002\"`},\n\t\t{\"Êó•Êú¨Ë™û\", `\"Êó•Êú¨Ë™û\"`},\n\t\t{\"\\\"\\\\/\\b\\f\\n\\r\\t\", `\"\\\"\\\\/\\b\\f\\n\\r\\t\"`},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.in, func(t *testing.T) {\n\t\t\tout := escapeString(nil, tt.in)\n\t\t\tif string(out) != tt.out {\n\t\t\t\tt.Errorf(\"escapeString(%q) = %q, want %q\", tt.in, out, tt.out)\n\t\t\t}\n\t\t})\n\t}\n}","3d8f6ad0ab0bfb926e53c4a95ced9ccd":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput       string\n\t\texpected    *Value\n\t\texpectedStr string\n\t\texpectedErr error\n\t}{\n\t\t// Empty array\n\t\t{\"[]\", \u0026Value{t: TypeArray, a: []*Value{}}, \"\", nil},\n\t\t// Simple array\n\t\t{\"[1,2,3]\", \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t}}, \"\", nil},\n\t\t// Array with different types\n\t\t{\"[1,\\\"hello\\\",true]\", \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t{t: TypeString, s: \"hello\"},\n\t\t\t{t: TypeTrue},\n\t\t}}, \"\", nil},\n\t\t// Nested array\n\t\t{\"[[1,2],[3,4]]\", \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t}},\n\t\t\t{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t{t: TypeNumber, s: \"4\"},\n\t\t\t}},\n\t\t}}, \"\", nil},\n\t\t// Array with whitespace\n\t\t{\" [ 1 , 2 , 3 ] \", \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t}}, \"\", nil},\n\t\t// Invalid array: missing ']'\n\t\t{\"[1,2,3\", nil, \"\", fmt.Errorf(\"missing ']'\")},\n\t\t// Invalid array: unexpected end\n\t\t{\"[1,2,\", nil, \"\", fmt.Errorf(\"unexpected end of array\")},\n\t\t// Invalid array: missing ','\n\t\t{\"[1 2 3]\", nil, \"2 3]\", fmt.Errorf(\"missing ',' after array value\")},\n\t}\n\n\tfor i, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tactual, str, err := parseArray(test.input, c, 0)\n\n\t\t\tif test.expectedErr != nil {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"Expected error %v, got nil\", test.expectedErr)\n\t\t\t\t} else if err.Error() != test.expectedErr.Error() {\n\t\t\t\t\tt.Errorf(\"Expected error %v, got %v\", test.expectedErr, err)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t\t\t} else if !equalValues(actual, test.expected) {\n\t\t\t\t\tt.Errorf(\"Test %d failed. Expected %v, got %v\", i, test.expected, actual)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif str != test.expectedStr {\n\t\t\t\tt.Errorf(\"Expected remaining string '%s', got '%s'\", test.expectedStr, str)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.t == TypeArray {\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\treturn v1.s == v2.s\n}","3f31a54f585efbbec2a16c87a8cbe8e0":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ts     string\n\t\terr   error\n\t}{\n\t\t// Empty array\n\t\t{\n\t\t\tinput: \"[]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Simple array\n\t\t{\n\t\t\tinput: \"[1,2,3]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Array with different types\n\t\t{\n\t\t\tinput: `[1,\"test\",true,null]`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeString, s: \"test\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t\t{t: TypeNull},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Nested array\n\t\t{\n\t\t\tinput: \"[1,[2,3],4]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeArray, a: []*Value{\n\t\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t\t}},\n\t\t\t\t\t{t: TypeNumber, s: \"4\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Array with whitespace\n\t\t{\n\t\t\tinput: \" [ 1 , 2 , 3 ] \",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \" \",\n\t\t\terr: nil,\n\t\t},\n\t\t// Invalid array - missing closing bracket\n\t\t{\n\t\t\tinput: \"[1,2,3\",\n\t\t\twant:  nil,\n\t\t\ts:     \"[1,2,3\",\n\t\t\terr:   fmt.Errorf(\"missing ']'\"),\n\t\t},\n\t\t// Invalid array - missing comma\n\t\t{\n\t\t\tinput: \"[1 2 3]\",\n\t\t\twant:  nil,\n\t\t\ts:     \"2 3]\",\n\t\t\terr:   fmt.Errorf(\"missing ',' after array value\"),\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i+1), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseArray(tt.input, c, 0)\n\n\t\t\tif (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"parseArray(%s) error = %v, wantErr %v\", tt.input, err, tt.err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif s != tt.s {\n\t\t\t\tt.Errorf(\"parseArray(%s) s = %s, want %s\", tt.input, s, tt.s)\n\t\t\t}\n\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray(%s) = %v, want %v\", tt.input, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.s != v2.s {\n\t\treturn false\n\t}\n\tif len(v1.a) != len(v2.a) {\n\t\treturn false\n\t}\n\tfor i := range v1.a {\n\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","3f357661c008ff56cdc0f9cfad225fac":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestValue_Bool(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantBool bool\n\t\twantErr  error\n\t}{\n\t\t{`true`, true, nil},\n\t\t{`false`, false, nil},\n\t\t{`\"true\"`, false, fmt.Errorf(\"value doesn't contain bool; it contains %s\", TypeString)},\n\t\t{`{}`, false, fmt.Errorf(\"value doesn't contain bool; it contains %s\", TypeObject)},\n\t}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tv := \u0026Value{t: TypeTrue}\n\t\t\tif tt.input == `false` {\n\t\t\t\tv.t = TypeFalse\n\t\t\t} else if tt.input != `true` {\n\t\t\t\tv, _, _ = parseValue(tt.input, \u0026cache{}, 0)\n\t\t\t}\n\n\t\t\tgotBool, gotErr := v.Bool()\n\t\t\tif gotBool != tt.wantBool {\n\t\t\t\tt.Errorf(\"Bool() gotBool = %v, want %v\", gotBool, tt.wantBool)\n\t\t\t}\n\t\t\tif gotErr == nil \u0026\u0026 tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"Bool() gotErr = nil, want %v\", tt.wantErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr == nil {\n\t\t\t\tt.Errorf(\"Bool() gotErr = %v, want nil\", gotErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"Bool() gotErr = %v, want %v\", gotErr, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","3f7572e75236edb893fcc23f31599964":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\ts string\n\t\tw string\n\t}{\n\t\t// Basic tests.\n\t\t{\"\", \"\"},\n\t\t{\"foo\", \"foo\"},\n\t\t{\"\\\\\\\"\", \"\\\"\"},\n\t\t{\"\\\\\\\\\", \"\\\\\"},\n\t\t{\"\\\\/\", \"/\"},\n\t\t{\"\\\\b\", \"\\b\"},\n\t\t{\"\\\\f\", \"\\f\"},\n\t\t{\"\\\\n\", \"\\n\"},\n\t\t{\"\\\\r\", \"\\r\"},\n\t\t{\"\\\\t\", \"\\t\"},\n\t\t{\"\\\\u0020\", \" \"},\n\t\t{\"\\\\u00A0\", \"\\u00A0\"},\n\t\t{\"\\\\uFFFF\", \"\\uFFFF\"},\n\n\t\t// Surrogate pair.\n\t\t{\"\\\\uD83D\\\\uDE01\", \"\\U0001F601\"},\n\n\t\t// Invalid escape sequences.\n\t\t{\"\\\\\", \"\\\\\"},\n\t\t{\"\\\\a\", \"\\\\a\"},\n\t\t{\"\\\\x\", \"\\\\x\"},\n\t\t{\"\\\\u\", \"\\\\u\"},\n\t\t{\"\\\\u123\", \"\\\\u123\"},\n\t\t{\"\\\\u12345\", \"\\\\u12345\"},\n\t\t{\"\\\\uD800\", \"\\\\uD800\"},\n\t\t{\"\\\\uD800\\\\u\", \"\\\\uD800\\\\u\"},\n\t\t{\"\\\\uD800\\\\uD800\", \"\\\\uD800\\\\uD800\"},\n\t\t{\"\\\\uD800\\\\u12345\", \"\\\\uD800\\\\u12345\"},\n\n\t\t// More complex strings.\n\t\t{`\"foo\\\"bar\\\\baz\"`, `\"foo\"bar\\baz\"`},\n\t\t{`\\u0020\\u00A0\\uFFFF`, \" \\u00A0\\uFFFF\"},\n\t\t{`\"\\\\uD83D\\\\uDE01\\\\\\uD83D\\\\uDE01\"`, `\"\\U0001F601\\\\\\U0001F601\"`},\n\t}\n\tfor i, tt := range tests {\n\t\ts := unescapeStringBestEffort(tt.s)\n\t\tif s != tt.w {\n\t\t\tt.Errorf(\"(%d) unescapeStringBestEffort(%q) = %q; want %q\", i, tt.s, s, tt.w)\n\t\t}\n\t}\n}","40a195db240c45247c569f188288dc15":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantStr  string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Basic cases\n\t\t{`\"foo\"bar`, \"foo\", \"bar\", nil},\n\t\t{`\"fo\\\"o\"bar`, `fo\"o`, \"bar\", nil},\n\t\t{`\"foo\"`, \"foo\", \"\", nil},\n\t\t{`\"\"bar`, \"\", \"bar\", nil},\n\n\t\t// Escaped quotes\n\t\t{`\"fo\\\\o\"bar`, `fo\\o`, \"bar\", nil},\n\t\t{`\"fo\\\\\\\\o\"bar`, `fo\\\\o`, \"bar\", nil},\n\t\t{`\"fo\\\\\\\"o\"bar`, `fo\\\"o`, \"bar\", nil},\n\t\t{`\"fo\\\\\"o\"bar`, `fo\\`, `o\"bar`, nil},\n\n\t\t// Errors\n\t\t{`\"foo`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"fo\\\"o`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`foo\"`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tgotStr, gotTail, gotErr := parseRawString(tt.input)\n\t\t\tif gotStr != tt.wantStr || gotTail != tt.wantTail || !errorEqual(gotErr, tt.wantErr) {\n\t\t\t\tt.Errorf(\"parseRawString(%q):\\ngot:  %q, %q, %v\\nwant: %q, %q, %v\",\n\t\t\t\t\ttt.input, gotStr, gotTail, gotErr, tt.wantStr, tt.wantTail, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc errorEqual(e1, e2 error) bool {\n\tif e1 == nil \u0026\u0026 e2 == nil {\n\t\treturn true\n\t}\n\tif e1 == nil || e2 == nil {\n\t\treturn false\n\t}\n\treturn e1.Error() == e2.Error()\n}","40bce8756653a7f7b2a826f9d1e70a02":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantJSON string\n\t\twantErr  error\n\t}{\n\t\t{\n\t\t\tname:     \"empty object\",\n\t\t\tinput:    \"{}\",\n\t\t\twantJSON: `{}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"simple object\",\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\twantJSON: `{\"key\":\"value\"}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"object with multiple keys\",\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantJSON: `{\"key1\":\"value1\",\"key2\":\"value2\"}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"object with nested object\",\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": {\"nestedKey\": \"nestedValue\"}}`,\n\t\t\twantJSON: `{\"key1\":\"value1\",\"key2\":{\"nestedKey\":\"nestedValue\"}}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"object with nested array\",\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": [\"nestedValue1\", \"nestedValue2\"]}`,\n\t\t\twantJSON: `{\"key1\":\"value1\",\"key2\":[\"nestedValue1\",\"nestedValue2\"]}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"object with escaped characters\",\n\t\t\tinput:    `{\"key1\": \"value with \\\"escaped\\\" characters\"}`,\n\t\t\twantJSON: `{\"key1\":\"value with \\\"escaped\\\" characters\"}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid object: missing closing brace\",\n\t\t\tinput:    `{\"key\": \"value\"`,\n\t\t\twantErr: fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid object: missing colon\",\n\t\t\tinput:    `{\"key\" \"value\"}`,\n\t\t\twantErr: fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid object: missing comma\",\n\t\t\tinput:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseObject(tt.input, c, 0)\n\t\t\tif tt.wantErr != nil {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"parseObject() error = nil, wantErr %v\", tt.wantErr)\n\t\t\t\t} else if err.Error() != tt.wantErr.Error() {\n\t\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr nil\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif s != \"\" {\n\t\t\t\tt.Errorf(\"parseObject() remaining string = %q, want empty\", s)\n\t\t\t}\n\t\t\tgotJSON := got.MarshalTo(nil)\n\t\t\tif string(gotJSON) != tt.wantJSON {\n\t\t\t\tt.Errorf(\"parseObject() got = %s, want %s\", gotJSON, tt.wantJSON)\n\t\t\t}\n\t\t})\n\t}\n}\n","41702ffcac5eb63c344593da8804a2ae":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey string\n\t\tvalue string\n\t\terr error\n\t}{\n\t\t// Basic cases\n\t\t{`\"foo\"bar`, \"foo\", \"bar\", nil},\n\t\t{`\"foo\" bar`, \"foo\", \" bar\", nil},\n\t\t{`\"foo\"  bar`, \"foo\", \"  bar\", nil},\n\t\t{`\"foo\"`, \"foo\", \"\", nil},\n\n\t\t// Escaped quotes\n\t\t{`\"fo\\o\"bar`, \"fo\\o\", \"bar\", nil},\n\t\t{`\"fo\\\\o\"bar`, \"fo\\\\o\", \"bar\", nil},\n\t\t{`\"fo\\\"o\"bar`, \"fo\\\"o\", \"bar\", nil},\n\t\t{`\"fo\\ooo\"bar`, \"fo\\ooo\", \"bar\", nil},\n\n\t\t// Missing closing quote\n\t\t{`\"foo`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"fo\\o`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tkey, value, err := parseRawString(tt.input)\n\t\t\tif key != tt.key || value != tt.value || !errorEqual(err, tt.err) {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = (%q, %q, %v), want (%q, %q, %v)\", tt.input, key, value, err, tt.key, tt.value, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc errorEqual(e1, e2 error) bool {\n\tif e1 == nil \u0026\u0026 e2 == nil {\n\t\treturn true\n\t}\n\tif e1 == nil || e2 == nil {\n\t\treturn false\n\t}\n\treturn e1.Error() == e2.Error()\n}","418c69497f59b9f493827f62e95a9c11":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetBool(t *testing.T) {\n\tvar tests = []struct {\n\t\tname string\n\t\tjson string\n\t\targs []string\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"simple true\",\n\t\t\tjson: `{\"foo\":true}`,\n\t\t\targs: []string{\"foo\"},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"simple false\",\n\t\t\tjson: `{\"foo\":false}`,\n\t\t\targs: []string{\"foo\"},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number true\",\n\t\t\tjson: `{\"foo\":1}`,\n\t\t\targs: []string{\"foo\"},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string true\",\n\t\t\tjson: `{\"foo\":\"true\"}`,\n\t\t\targs: []string{\"foo\"},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested true\",\n\t\t\tjson: `{\"foo\":{\"bar\":true}}`,\n\t\t\targs: []string{\"foo\", \"bar\"},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"nested false\",\n\t\t\tjson: `{\"foo\":{\"bar\":false}}`,\n\t\t\targs: []string{\"foo\", \"bar\"},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array true\",\n\t\t\tjson: `{\"foo\":[true]}`,\n\t\t\targs: []string{\"foo\", \"0\"},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"array false\",\n\t\t\tjson: `{\"foo\":[false]}`,\n\t\t\targs: []string{\"foo\", \"0\"},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing key\",\n\t\t\tjson: `{\"foo\":true}`,\n\t\t\targs: []string{\"bar\"},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid key\",\n\t\t\tjson: `{\"foo\":true}`,\n\t\t\targs: []string{\"foo\", \"bar\"},\n\t\t\twant: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv := MustParse([]byte(tt.json))\n\t\t\tif got := v.GetBool(tt.args...); got != tt.want {\n\t\t\t\tt.Errorf(\"Value.GetBool() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","41eed9330e6f62c05d39e701011084a6":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantN    string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Basic cases\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"123.456\", \"123.456\", \"\", nil},\n\t\t{\"1.2e3\", \"1.2e3\", \"\", nil},\n\t\t{\"1.2E-3\", \"1.2E-3\", \"\", nil},\n\n\t\t// Trailing characters\n\t\t{\"123a\", \"123\", \"a\", nil},\n\t\t{\"123.456 \", \"123.456\", \" \", nil},\n\n\t\t// Invalid numbers\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t\t{\"+\", \"\", \"+\", fmt.Errorf(\"unexpected char: %q\", \"+\")},\n\t\t(\"-\", \"\", \"-\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t\t(\"a123\", \"\", \"a123\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\n\t\t// Special cases: inf, nan\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"+inf\", \"+inf\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"InF\", \"InF\", \"\", nil}, // Case insensitive\n\t\t{\"123inf\", \"123\", \"inf\", nil},\n\t\t{\"+123inf\", \"+123\", \"inf\", nil},\n\t\t{\"-123inf\", \"-123\", \"inf\", nil},\n\n\t\t// Invalid special cases\n\t\t{\"in\", \"\", \"in\", fmt.Errorf(\"unexpected char: %q\", \"i\")},\n\t\t{\"na\", \"\", \"na\", fmt.Errorf(\"unexpected char: %q\", \"n\")},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tgotN, gotTail, gotErr := parseRawNumber(tt.input)\n\t\t\tif gotN != tt.wantN || gotTail != tt.wantTail || (gotErr != nil \u0026\u0026 tt.wantErr == nil) || (gotErr == nil \u0026\u0026 tt.wantErr != nil) || (gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error()) {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = (%q, %q, %v), want (%q, %q, %v)\", tt.input, gotN, gotTail, gotErr, tt.wantN, tt.wantTail, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","42a4581e9bcb47c9cae323e224321838":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"raw string\",\n\t\t\t},\n\t\t\twant: []byte(`\"raw string\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"string\",\n\t\t\t},\n\t\t\twant: []byte(`\"string\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"12345\",\n\t\t\t},\n\t\t\twant: []byte(`12345`),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(`true`),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(`false`),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(`null`),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"string1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"12345\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`[\"string1\",12345]`),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"string1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"12345\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":\"string1\",\"key2\":12345}`),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif string(got) != string(tt.want) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %v, want %v\", string(got), string(tt.want))\n\t\t\t}\n\t\t})\n\t}\n}\n","4317dd94c9c81cdfc7394fab018fe2c2":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantN    string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Empty input.\n\t\t{\"\", \"\", \"\", nil},\n\n\t\t// Valid integers.\n\t\t{\"1\", \"1\", \"\", nil},\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"+123\", \"+123\", \"\", nil},\n\n\t\t// Valid floats.\n\t\t{\"1.23\", \"1.23\", \"\", nil},\n\t\t{\"-1.23\", \"-1.23\", \"\", nil},\n\t\t{\"+1.23\", \"+1.23\", \"\", nil},\n\t\t{\"1e2\", \"1e2\", \"\", nil},\n\t\t{\"1.2e2\", \"1.2e2\", \"\", nil},\n\t\t{\"1.2e+2\", \"1.2e+2\", \"\", nil},\n\t\t{\"1.2e-2\", \"1.2e-2\", \"\", nil},\n\n\t\t// Valid special numbers.\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"+inf\", \"+inf\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"Inf\", \"Inf\", \"\", nil},\n\t\t{\"+Inf\", \"+Inf\", \"\", nil},\n\t\t{\"-Inf\", \"-Inf\", \"\", nil},\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"+nan\", \"+nan\", \"\", nil},\n\t\t{\"-nan\", \"-nan\", \"\", nil},\n\t\t{\"NaN\", \"NaN\", \"\", nil},\n\t\t{\"+NaN\", \"+NaN\", \"\", nil},\n\t\t{\"-NaN\", \"-NaN\", \"\", nil},\n\n\t\t// Invalid numbers.\n\t\t{\"a\", \"\", \"a\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\"1a\", \"1\", \"a\", nil},\n\t\t{\"+a\", \"\", \"+a\", fmt.Errorf(\"unexpected char: %q\", \"+a\")},\n\t\t{\"-a\", \"\", \"-a\", fmt.Errorf(\"unexpected char: %q\", \"-a\")},\n\t\t{\"in\", \"\", \"in\", fmt.Errorf(\"unexpected char: %q\", \"in\")},\n\t\t{\"+in\", \"\", \"+in\", fmt.Errorf(\"unexpected char: %q\", \"+in\")},\n\t\t{\"-in\", \"\", \"-in\", fmt.Errorf(\"unexpected char: %q\", \"-in\")},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tgotN, gotTail, gotErr := parseRawNumber(tt.input)\n\t\t\tif gotN != tt.wantN {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got number = %q, want %q\", tt.input, gotN, tt.wantN)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got tail = %q, want %q\", tt.input, gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif gotErr == nil \u0026\u0026 tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got err = nil, want %v\", tt.input, tt.wantErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr == nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got err = %v, want nil\", tt.input, gotErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got err = %v, want %v\", tt.input, gotErr, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","438cdd38c430e24205d861b12ce862a1":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey string\n\t\tvalue string\n\t\terr error\n\t}{\n\t\t// Test cases here\n\t\t{\n\t\t\tinput: `\"foo\"bar`,\n\t\t\tkey:   \"foo\",\n\t\t\tvalue: \"bar\",\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tinput: `\"fo\\o\"bar`,\n\t\t\tkey:   `fo\\o`,\n\t\t\tvalue: \"bar\",\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tinput: `\"foo\\\"bar\"baz`,\n\t\t\tkey:   `foo\"bar`,\n\t\t\tvalue: \"baz\",\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tinput: `\"foo\", \"bar\"`,\n\t\t\tkey:   \"foo\",\n\t\t\tvalue: `, \"bar\"`,\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tinput: `\"\\\"\"bar`,\n\t\t\tkey:   `\"`,\n\t\t\tvalue: \"bar\",\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tinput: `\"foo`,\n\t\t\tkey:   \"\",\n\t\t\tvalue: \"\",\n\t\t\terr: fmt.Errorf(`missing closing '\"'`),\n\t\t},\n\t}\n\tfor i, tt := range tests {\n\t\tkey, value, err := parseRawString(tt.input)\n\t\tif fmt.Sprintf(\"%v\", err) != fmt.Sprintf(\"%v\", tt.err) {\n\t\t\tt.Errorf(\"test[%d]. Error: got %v, expected: %v\", i, err, tt.err)\n\t\t}\n\t\tif key != tt.key {\n\t\t\tt.Errorf(\"test[%d]. Key: got %q, expected: %q\", i, key, tt.key)\n\t\t}\n\t\tif value != tt.value {\n\t\t\tt.Errorf(\"test[%d]. Value: got %q, expected: %q\", i, value, tt.value)\n\t\t}\n\t}\n}","43f05169bea4b18464c3beff0572b019":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey   string\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t{`\"foo\"bar`, \"foo\", \"bar\", nil},\n\t\t{`\"fo\\o\"bar`, \"fo\\o\", \"bar\", nil},\n\t\t{`\"foo\\\"bar\"baz`, `foo\"bar`, \"baz\", nil},\n\t\t{`\"foo\\\\bar\"baz`, `foo\\bar`, \"baz\", nil},\n\t\t{`\"foo\"bar`, \"foo\", \"bar\", nil},\n\t\t{`\"foo`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test %d\", i), func(t *testing.T) {\n\t\t\tkey, tail, err := parseRawString(tt.input)\n\t\t\tif key != tt.key || tail != tt.tail || !equalError(err, tt.err) {\n\t\t\t\tt.Errorf(\"input: %q, expect(%q, %q, %v), got(%q, %q, %v)\", tt.input, tt.key, tt.tail, tt.err, key, tail, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalError(err1, err2 error) bool {\n\tif err1 == nil \u0026\u0026 err2 == nil {\n\t\treturn true\n\t}\n\tif err1 != nil \u0026\u0026 err2 != nil {\n\t\treturn err1.Error() == err2.Error()\n\t}\n\treturn false\n}","446abaebeeef376ebc93226303f531ed":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ts     string\n\t\terr   error\n\t}{\n\t\t// Empty object\n\t\t{\n\t\t\tinput: \"{}\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Simple object\n\t\t{\n\t\t\tinput: `{\"key1\": \"value1\", \"key2\": 123}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Nested object\n\t\t{\n\t\t\tinput: `{\"key1\": {\"nestedKey\": \"nestedValue\"}, \"key2\": [1,2,3]}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{k: \"nestedKey\", v: \u0026Value{t: TypeString, s: \"nestedValue\"}},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Invalid object: missing closing brace\n\t\t{\n\t\t\tinput: `{\"key1\": \"value1\"`,\n\t\t\twant:  nil,\n\t\t\ts:     `{\"key1\": \"value1\"`,\n\t\t\terr:   fmt.Errorf(`missing '}'`),\n\t\t},\n\t\t// Invalid object: missing colon\n\t\t{\n\t\t\tinput: `{\"key1\" \"value1\"}`,\n\t\t\twant:  nil,\n\t\t\ts:     `\"value1\"}`,\n\t\t\terr:   fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t\t// Invalid object: missing comma\n\t\t{\n\t\t\tinput: `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twant:  nil,\n\t\t\ts:     `\"key2\": \"value2\"}`,\n\t\t\terr:   fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseObject(tt.input, c, 0)\n\t\t\tif fmt.Sprintf(\"%v\", err) != fmt.Sprintf(\"%v\", tt.err) {\n\t\t\t\tt.Errorf(\"parseObject(%s) error mismatch: got %v, want %v\", tt.input, err, tt.err)\n\t\t\t}\n\t\t\tif s != tt.s {\n\t\t\t\tt.Errorf(\"parseObject(%s) remaining string mismatch: got %q, want %q\", tt.input, s, tt.s)\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject(%s) value mismatch:\\ngot  %+v\\nwant %+v\", tt.input, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n","45e9f90038c7ac1a7282335fc1180fe8":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_getKV(t *testing.T) {\n\to := Object{}\n\t// Test adding to empty o.kvs\n\tkv1 := o.getKV()\n\tif kv1 == nil {\n\t\tt.Errorf(\"Expected non-nil kv, got nil\")\n\t}\n\n\t// Test adding when there's capacity\n\to.kvs = append(o.kvs, kv{\"key1\", \u0026Value{}})\n\tkv2 := o.getKV()\n\tif kv2 == nil {\n\t\tt.Errorf(\"Expected non-nil kv, got nil\")\n\t}\n\tif len(o.kvs) != 2 {\n\t\tt.Errorf(\"Expected length of o.kvs to be 2, got %d\", len(o.kvs))\n\t}\n\n\t// Test adding when there's no capacity\n\to.kvs = make([]kv, 1)\n\tkv3 := o.getKV()\n\tif kv3 == nil {\n\t\tt.Errorf(\"Expected non-nil kv, got nil\")\n\t}\n\tif len(o.kvs) != 2 {\n\t\tt.Errorf(\"Expected length of o.kvs to be 2, got %d\", len(o.kvs))\n\t}\n}","46016ef0a20258ffb65f7446c875b298":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\ttests := []struct {\n\t\tinput       string\n\t\texpectValue string\n\t\texpectError bool\n\t}{\n\t\t// Valid JSON strings\n\t\t{\"{\\\"key\\\": \\\"value\\\"}\", `{\"key\":\"value\"}`, false},\n\t\t{\"[1, 2, 3]\", `[1,2,3]`, false},\n\t\t{\"123\", `123`, false},\n\t\t{\"\\\"hello\\\"\", `\"hello\"`, false},\n\t\t{\"true\", `true`, false},\n\t\t{\"false\", `false`, false},\n\t\t{\"null\", `null`, false},\n\n\t\t// Invalid JSON strings\n\t\t{\"{\\\"key\\\": \\\"value}\", \"\", true},\n\t\t{\"{1, 2, 3]\", \"\", true},\n\t\t{\"\\\"hello\", \"\", true},\n\t\t{\"tru\", \"\", true},\n\t\t{\"fals\", \"\", true},\n\t\t{\"nul\", \"\", true},\n\t\t{\"[1 2]\", \"\", true},\n\t}\n\n\tparser := \u0026Parser{}\n\tfor i, test := range tests {\n\t\tvalue, err := parser.Parse(test.input)\n\t\tif test.expectError {\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"Test %d: Expected error for input '%s', but got nil\", i, test.input)\n\t\t\t}\n\t\t} else {\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Test %d: Unexpected error for input '%s': %v\", i, test.input, err)\n\t\t\t} else {\n\t\t\t\tif got := value.String(); got != test.expectValue {\n\t\t\t\t\tt.Errorf(\"Test %d: For input '%s', expected value '%s', but got '%s'\", i, test.input, test.expectValue, got)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","474587a46759d9c9af305ffe6abc10cf":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_unescapeKeys(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tkvs  []kv\n\t\twant *Object\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\to := \u0026Object{\n\t\t\t\tkvs: tt.kvs,\n\t\t\t}\n\t\t\to.unescapeKeys()\n\t\t\tif o.keysUnescaped != true {\n\t\t\t\tt.Errorf(\"Object.unescapeKeys() failed, o.keysUnescaped = %v, want %v\", o.keysUnescaped, true)\n\t\t\t}\n\t\t})\n\t}\n}","4778417afe75368a35b2b6f4f35fc985":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ts     string\n\t\terr   error\n\t}{\n\t\t// Empty input.\n\t\t{\"\", nil, \"\", fmt.Errorf(\"missing ']'\")},\n\t\t// Empty array.\n\t\t{\"[]\", \u0026Value{t: TypeArray, a: []*Value{}}, \"\", nil},\n\t\t// Simple array.\n\t\t{\"[1,2,3]\", \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}}, \"\", nil},\n\t\t// Array with different types.\n\t\t{\"[1,\\\"foo\\\",true]\", \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeString, s: \"foo\"}, {t: TypeTrue}}}, \"\", nil},\n\t\t// Array with nested array.\n\t\t{\"[[1,2],[3,4]]\", \u0026Value{t: TypeArray, a: []*Value{{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}}}, {t: TypeArray, a: []*Value{{t: TypeNumber, s: \"3\"}, {t: TypeNumber, s: \"4\"}}}}}, \"\", nil},\n\t\t// Array with whitespace.\n\t\t{\" [ 1 , 2 , 3 ] \", \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}}, \" \", nil},\n\t\t// Invalid array: missing ']'.\n\t\t{\"[1,2,3\", nil, \"1,2,3\", fmt.Errorf(\"unexpected end of array\")},\n\t\t// Invalid array: missing ','.\n\t\t{\"[1 2,3]\", nil, \" 2,3]\", fmt.Errorf(\"missing ',' after array value\")},\n\t\t// Invalid array: unexpected token.\n\t\t{\"[1,2,3 foo]\", nil, \" foo]\", fmt.Errorf(\"missing ',' after array value\")},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseArray(tt.input, c, 0)\n\n\t\t\tif (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err == nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"Test %d failed: error mismatch. Want: %v, Got: %v\", i, tt.err, err)\n\t\t\t}\n\t\t\tif s != tt.s {\n\t\t\t\tt.Errorf(\"Test %d failed: remaining string mismatch. Want: %q, Got: %q\", i, tt.s, s)\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"Test %d failed: value mismatch. Want: %v, Got: %v\", i, tt.want, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.s != v2.s {\n\t\treturn false\n\t}\n\tif len(v1.a) != len(v2.a) {\n\t\treturn false\n\t}\n\tfor i := range v1.a {\n\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","47a7a73c5d932bf8413c1aa7692b5419":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Empty string\n\t\t{\"\", nil, \"\", fmt.Errorf(\"cannot parse empty string\")},\n\t\t// Invalid JSON\n\t\t{\"{\", nil, \"\", fmt.Errorf(\"cannot parse object: unexpected end of JSON\")},\n\t\t// Object\n\t\t{`{\"foo\":\"bar\"}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: typeRawString, s: \"bar\"}}}}}}, \"\", nil},\n\t\t// Array\n\t\t{`[1,2,3]`, \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}}, \"\", nil},\n\t\t// String\n\t\t{`\"hello\"`, \u0026Value{t: typeRawString, s: \"hello\"}, \"\", nil},\n\t\t// True\n\t\t{\"true\", valueTrue, \"\", nil},\n\t\t// False\n\t\t{\"false\", valueFalse, \"\", nil},\n\t\t// Null\n\t\t{\"null\", valueNull, \"\", nil},\n\t\t// Number\n\t\t{\"123\", \u0026Value{t: TypeNumber, s: \"123\"}, \"\", nil},\n\t\t// NaN\n\t\t{\"NaN\", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"\", nil},\n\t\t// Number with tail\n\t\t{\"123 \", \u0026Value{t: TypeNumber, s: \"123\"}, \" \", nil},\n\t}\n\n\tc := \u0026cache{}\n\tfor i, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tgot, tail, err := parseValue(test.input, c, 0)\n\t\t\tif (err != nil \u0026\u0026 test.err == nil) || (err == nil \u0026\u0026 test.err != nil) || (err != nil \u0026\u0026 test.err != nil \u0026\u0026 err.Error() != test.err.Error()) {\n\t\t\t\tt.Errorf(\"Test %d failed: input %q, got error %v, want %v\", i, test.input, err, test.err)\n\t\t\t}\n\t\t\tif tail != test.tail {\n\t\t\t\tt.Errorf(\"Test %d failed: input %q, got tail %q, want %q\", i, test.input, tail, test.tail)\n\t\t\t}\n\t\t\tif !equalValues(got, test.want) {\n\t\t\t\tt.Errorf(\"Test %d failed: input %q, got %v, want %v\", i, test.input, got, test.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.t == typeRawString {\n\t\treturn v1.s == v2.s\n\t}\n\tif v1.t == TypeNumber {\n\t\treturn v1.s == v2.s\n\t}\n\tif v1.t == TypeObject {\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\tif v1.t == TypeArray {\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\treturn false\n}\n","47b28de27696c7d835e66559172d7cdc":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"raw string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"raw string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"12345\",\n\t\t\t},\n\t\t\twant: []byte(\"12345\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"string1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"12345\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"[\\\"string1\\\",12345]\"),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"string1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"12345\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"{\\\"key1\\\":\\\"string1\\\",\\\"key2\\\":12345}\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif string(got) != string(tt.want) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","482458ac461af40cdb53b92e922369b7":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey string\n\t\ttail string\n\t\terr  error\n\t}{\n\t\t// Unescaped strings\n\t\t{`\"foo\"bar`, \"foo\", \"bar\", nil},\n\t\t{`\"foo bar\"baz`, \"foo bar\", \"baz\", nil},\n\n\t\t// Escaped strings\n\t\t{`\"foo\\\"bar\"baz`, `foo\"bar`, \"baz\", nil},\n\t\t{`\"foo\\\\bar\"baz`, `foo\\bar`, \"baz\", nil},\n\t\t{`\"foo\\tbar\"baz`, \"foo\\tbar\", \"baz\", nil},\n\n\t\t// Missing closing quote\n\t\t{`\"foobar`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo\\\"bar`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\n\t\t// Empty strings\n\t\t{`\"\"bar`, \"\", \"bar\", nil},\n\t\t{`\"foo\"\"\"bar`, `foo\"`, \"bar\", nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tkey, tail, err := parseRawString(tt.input)\n\t\t\tif key != tt.key || tail != tt.tail || (err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = (%q, %q, %v), want (%q, %q, %v)\", tt.input, key, tail, err, tt.key, tt.tail, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}\n","48320e961bd2d8c9a3735fa076ff65ef":"package fastjson\n\nimport \"testing\"\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tt    Type\n\t\twant string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\tfor i, tt := range tests {\n\t\tif got := tt.t.String(); got != tt.want {\n\t\t\tt.Errorf(\"Type.String() test %d failed, got: %v, want: %v\", i, got, tt.want)\n\t\t}\n\t}\n}","48615e4e0f80b59be18ffb71c44492a6":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Empty string\n\t\t{\"\", nil, \"\", fmt.Errorf(\"cannot parse empty string\")},\n\t\t// Invalid JSON\n\t\t{\"{invalid}\", nil, \"\", fmt.Errorf(\"cannot parse object: invalid character 'i' looking for beginning of value\")},\n\t\t// Simple object\n\t\t{`{\"key\": \"value\"}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{t: typeRawString, s: \"value\"}}}}}, \"\", nil},\n\t\t// Simple array\n\t\t{`[1, \"two\", true]`, \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: typeRawString, s: \"two\"}, {t: TypeTrue}}}, \"\", nil},\n\t\t// String with escaped characters\n\t\t{`\"hello\\nworld\"`, \u0026Value{t: typeRawString, s: \"hello\\nworld\"}, \"\", nil},\n\t\t// True boolean\n\t\t{\"true\", valueTrue, \"\", nil},\n\t\t// False boolean\n\t\t{\"false\", valueFalse, \"\", nil},\n\t\t// Null value\n\t\t{\"null\", valueNull, \"\", nil},\n\t\t// Number\n\t\t{\"12345\", \u0026Value{t: TypeNumber, s: \"12345\"}, \"\", nil},\n\t\t// NaN\n\t\t{\"NaN\", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"\", nil},\n\t\t// Trailing whitespace\n\t\t{`\"value\"  `, \u0026Value{t: typeRawString, s: \"value\"}, \"  \", nil},\n\t\t// Number with exponent\n\t\t{\"1.23e5\", \u0026Value{t: TypeNumber, s: \"1.23e5\"}, \"\", nil},\n\t\t// Negative number\n\t\t{\"-123\", \u0026Value{t: TypeNumber, s: \"-123\"}, \"\", nil},\n\t}\n\n\tc := \u0026cache{}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tgot, tail, err := parseValue(tt.input, c, 0)\n\t\t\tif (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"parseValue(%q) error mismatch: got %v, want %v\", tt.input, err, tt.err)\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"parseValue(%q) tail mismatch: got %q, want %q\", tt.input, tail, tt.tail)\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue(%q) value mismatch:\\ngot  %+v\\nwant %+v\", tt.input, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.t == typeRawString {\n\t\treturn v1.s == v2.s\n\t}\n\tif v1.t == TypeNumber {\n\t\treturn v1.s == v2.s\n\t}\n\tif v1.t == TypeObject {\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\tif v1.t == TypeArray {\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\treturn false\n}","487b4d87b952e68219b21d44a1371cea":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ts     string\n\t\terr   string\n\t}{\n\t\t{\n\t\t\tinput: \"[]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: nil,\n\t\t\t},\n\t\t\ts:  \"\",\n\t\t\terr: \"\",\n\t\t},\n\t\t{\n\t\t\tinput: \"[1,2,3]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:  \"\",\n\t\t\terr: \"\",\n\t\t},\n\t\t{\n\t\t\tinput: \"[1, 2,  3]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:  \"\",\n\t\t\terr: \"\",\n\t\t},\n\t\t{\n\t\t\tinput: \"[1 2,  3]\",\n\t\t\twant:  nil,\n\t\t\ts:     \"2,  3]\",\n\t\t\terr:   \"missing ',' after array value\",\n\t\t},\n\t\t{\n\t\t\tinput: \"[1,]\",\n\t\t\twant:  nil,\n\t\t\ts:     \"]\",\n\t\t\terr:   \"cannot parse array value: unexpected end of object\",\n\t\t},\n\t\t{\n\t\t\tinput: \"[1\",\n\t\t\twant:  nil,\n\t\t\ts:     \"1\",\n\t\t\terr:   \"unexpected end of array\",\n\t\t},\n\t\t{\n\t\t\tinput: \"[\\\"hello\\\", true, false, null]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"hello\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t\t{t: TypeFalse},\n\t\t\t\t\t{t: TypeNull},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:  \"\",\n\t\t\terr: \"\",\n\t\t},\n\t\t{\n\t\t\tinput: \"[{\\\"a\\\": 1},{\\\"b\\\":2}]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t{k: \"a\", v: \u0026Value{t: TypeNumber, s: \"1\"}},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t{k: \"b\", v: \u0026Value{t: TypeNumber, s: \"2\"}},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:  \"\",\n\t\t\terr: \"\",\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseArray(tt.input, c, 0)\n\t\t\tif tt.err != \"\" {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"expected error %q but got nil\", tt.err)\n\t\t\t\t} else if err.Error() != tt.err {\n\t\t\t\t\tt.Errorf(\"expected error %q but got %q\", tt.err, err.Error())\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"unexpected error: %s\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif s != tt.s {\n\t\t\t\tt.Errorf(\"expected remaining string %q but got %q\", tt.s, s)\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"expected value %+v but got %+v\", tt.want, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeString, TypeNumber:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\treturn true\n\t}\n}","48c9e62e37da97e070e59a6c5e30e526":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantObj  string\n\t\twantTail string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"empty object\",\n\t\t\tinput:    \"{}\",\n\t\t\twantObj:  \"{}\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"simple object\",\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\twantObj:  `{\"key\": \"value\"}`,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"object with multiple key-value pairs\",\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\", \"key3\": \"value3\"}`,\n\t\t\twantObj:  `{\"key1\": \"value1\", \"key2\": \"value2\", \"key3\": \"value3\"}`,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"object with nested object\",\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": {\"nestedKey\": \"nestedValue\"}}`,\n\t\t\twantObj:  `{\"key1\": \"value1\", \"key2\": {\"nestedKey\": \"nestedValue\"}}`,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"object with nested array\",\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": [\"value2\", \"value3\"]}`,\n\t\t\twantObj:  `{\"key1\": \"value1\", \"key2\": [\"value2\", \"value3\"]}`,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"object with escaped characters\",\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value with \\\"escaped\\\" characters\"}`,\n\t\t\twantObj:  `{\"key1\": \"value1\", \"key2\": \"value with \\\"escaped\\\" characters\"}`,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"object with unicode characters\",\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value with unicode characters: üöÄ\"}`,\n\t\t\twantObj:  `{\"key1\": \"value1\", \"key2\": \"value with unicode characters: üöÄ\"}`,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid object: missing closing brace\",\n\t\t\tinput:    `{\"key\": \"value\"`,\n\t\t\twantObj:  \"\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid object: missing colon\",\n\t\t\tinput:    `{\"key\" \"value\"}`,\n\t\t\twantObj:  \"\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid object: missing comma\",\n\t\t\tinput:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantObj:  \"\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgotObj, gotTail, gotErr := parseObject(tt.input, c, 0)\n\n\t\t\tif (gotErr != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", gotErr, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif gotErr == nil {\n\t\t\t\tgotObjStr := gotObj.String()\n\t\t\t\tif gotObjStr != tt.wantObj {\n\t\t\t\t\tt.Errorf(\"parseObject() gotObj = %s, want %s\", gotObjStr, tt.wantObj)\n\t\t\t\t}\n\t\t\t\tif gotTail != tt.wantTail {\n\t\t\t\t\tt.Errorf(\"parseObject() gotTail = %s, want %s\", gotTail, tt.wantTail)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","48d318ea87ed8fe26689b887bc8fd3c8":"package fastjson\n\nimport \"testing\"\n\nfunc Test_skipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    string\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\ts:    \"\",\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with leading whitespace\",\n\t\t\ts:    \"  foo\",\n\t\t\twant: \"foo\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with no leading whitespace\",\n\t\t\ts:    \"bar\",\n\t\t\twant: \"bar\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with all whitespace\",\n\t\t\ts:    \" \\t\\n\\r\",\n\t\t\twant: \"\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","49c1fd950447c90d34f273d87ba7c002":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\tstr      string\n\t\terr      error\n\t}{\n\t\t// Empty object\n\t\t{\"{}\", \u0026Value{t: TypeObject, o: Object{kvs: nil, keysUnescaped: false}}, \"\", nil},\n\n\t\t// Simple object\n\t\t{`{\"key1\": \"value1\", \"key2\": 123}`,\n\t\t\t\u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\t\"\",\n\t\t\tnil,\n\t\t},\n\n\t\t// Nested object\n\t\t{`{\"key1\": {\"nestedKey\": \"nestedValue\"}, \"key2\": [1,2,3]}`,\n\t\t\t\u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{{k: \"nestedKey\", v: \u0026Value{t: TypeString, s: \"nestedValue\"}}},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\t\"\",\n\t\t\tnil,\n\t\t},\n\n\t\t// Invalid JSON\n\t\t{\"{\", nil, \"{\", fmt.Errorf(`cannot find opening '\"\" for object key`)},\n\t\t{`{\"key\": \"value\"`, nil, `{\"key\": \"value\"`, fmt.Errorf(\"missing '}'\")},\n\t\t{`{\"key\": : \"value\"}`, nil, `{\"key\": : \"value\"}`, fmt.Errorf(\"missing ':' after object key\")},\n\t\t{`{\"key\": \"value\",}`, nil, `}`, fmt.Errorf(\"unexpected end of object\")},\n\t}\n\n\tfor i, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i+1), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tv, str, err := parseObject(test.input, c, 0)\n\n\t\t\tif test.err != nil {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"Expected error %v, got nil\", test.err)\n\t\t\t\t} else if err.Error() != test.err.Error() {\n\t\t\t\t\tt.Errorf(\"Expected error %v, got %v\", test.err, err)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t\t\t}\n\t\t\t\tif str != test.str {\n\t\t\t\t\tt.Errorf(\"Expected remaining string '%s', got '%s'\", test.str, str)\n\t\t\t\t}\n\t\t\t\tif !compareValues(t, test.expected, v) {\n\t\t\t\t\tt.Errorf(\"Expected value:\\n%+v\\ngot:\\n%+v\", test.expected, v)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(t *testing.T, expected, actual *Value) bool {\n\tif expected == nil \u0026\u0026 actual == nil {\n\t\treturn true\n\t}\n\tif expected == nil || actual == nil {\n\t\treturn false\n\t}\n\tif expected.t != actual.t {\n\t\treturn false\n\t}\n\tswitch expected.t {\n\tcase TypeString:\n\t\treturn expected.s == actual.s\n\tcase TypeNumber:\n\t\treturn expected.s == actual.s\n\tcase TypeObject:\n\t\tif expected.o.Len() != actual.o.Len() {\n\t\t\treturn false\n\t\t}\n\t\tfor i := 0; i \u003c expected.o.Len(); i++ {\n\t\t\texpectedKV := expected.o.kvs[i]\n\t\t\tactualKV := actual.o.kvs[i]\n\t\t\tif expectedKV.k != actualKV.k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !compareValues(t, expectedKV.v, actualKV.v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeArray:\n\t\tif len(expected.a) != len(actual.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := 0; i \u003c len(expected.a); i++ {\n\t\t\tif !compareValues(t, expected.a[i], actual.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\tt.Errorf(\"Unsupported type %v\", expected.t)\n\t\treturn false\n\t}\n}","4b129ab98d5c4c731411a79d4a5f508e":"package fastjson\n\nimport \"testing\"\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    string\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\ts:    \"\",\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with leading whitespace\",\n\t\t\ts:    \"  \\n\\t\\r foo\",\n\t\t\twant: \"foo\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with no leading whitespace\",\n\t\t\ts:    \"bar\",\n\t\t\twant: \"bar\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with only whitespace\",\n\t\t\ts:    \" \\t\\r\\n\",\n\t\t\twant: \"\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","4b87cd4d52570dab9666b264f36b07db":"package fastjson\n\nimport \"testing\"\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tinput Type\n\t\twant  string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\tfor i, tt := range tests {\n\t\tgot := tt.input.String()\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"test[%d]: String() = %q, want %q\", i, got, tt.want)\n\t\t}\n\t}\n}","4bfd353ce394104c3e5e7330f2d8c37e":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey   string\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Unescaped strings.\n\t\t{`\"foo\"bar`, \"foo\", \"bar\", nil},\n\t\t{`\"foo\" bar`, \"foo\", \" bar\", nil},\n\t\t{`\"foo\"  bar`, \"foo\", \"  bar\", nil},\n\n\t\t// Escaped strings.\n\t\t{`\"fo\\\"o\"bar`, `fo\"o`, \"bar\", nil},\n\t\t{`\"fo\\\\o\"bar`, `fo\\o`, \"bar\", nil},\n\t\t{`\"fo\\to\"bar`, \"fo\\to\", \"bar\", nil},\n\t\t{`\"fo\\ro\"bar`, \"fo\\ro\", \"bar\", nil},\n\t\t{`\"fo\\no\"bar`, \"fo\\no\", \"bar\", nil},\n\n\t\t// Missing closing quote.\n\t\t{`\"foo`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"fo\\\"o`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\n\t\t// Empty strings.\n\t\t{`\"\"bar`, \"\", \"bar\", nil},\n\t\t{`\"\" bar`, \"\", \" bar\", nil},\n\t\t{`\"\"  bar`, \"\", \"  bar\", nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tkey, tail, err := parseRawString(tt.input)\n\t\t\tif key != tt.key || tail != tt.tail || !equalError(err, tt.err) {\n\t\t\t\tt.Errorf(\"input: %q, want: (%q, %q, %v), got: (%q, %q, %v)\", tt.input, tt.key, tt.tail, tt.err, key, tail, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalError(e1, e2 error) bool {\n\tif e1 == nil \u0026\u0026 e2 == nil {\n\t\treturn true\n\t}\n\tif e1 != nil \u0026\u0026 e2 != nil {\n\t\treturn e1.Error() == e2.Error()\n\t}\n\treturn false\n}","4cdd623a302712e4419ad2c3a2c97876":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey   string\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Basic cases\n\t\t{`\"foo\"bar`, \"foo\", \"bar\", nil},\n\t\t{`\"fo\\\"o\"bar`, `fo\"o`, \"bar\", nil},\n\t\t{`\"foo\" bar`, \"foo\", \" bar\", nil},\n\n\t\t// Escaped quotes\n\t\t{`\"foo\\\\\"bar`, `foo\\`, \"bar\", nil},\n\t\t{`\"foo\\\\\\\"\"bar`, `foo\\\"`, \"bar\", nil},\n\t\t{`\"foo\\\\\\\\\"bar`, `foo\\\\`, \"bar\", nil},\n\n\t\t// Empty strings\n\t\t{`\"\"bar`, \"\", \"bar\", nil},\n\t\t{`\"foo\"\"\"bar`, \"foo\", `\"bar`, nil},\n\n\t\t// Invalid input\n\t\t{`\"foobar`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`foo\"bar`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo\"bar\"`, \"foo\", `bar\"`, nil}, // This is valid JSON, but the function should only parse the first string\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tkey, tail, err := parseRawString(tt.input)\n\t\t\tif key != tt.key || tail != tt.tail || (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = (%q, %q, %v), want (%q, %q, %v)\", tt.input, key, tail, err, tt.key, tt.tail, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}","4d0122a553f10d32bc49513bf0d9a989":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic strings without escape sequences.\n\t\t{\"hello\", \"hello\"},\n\t\t{\"world\", \"world\"},\n\t\t{\"12345\", \"12345\"},\n\n\t\t// Simple escape sequences.\n\t\t{`\\\"`, `\"`},\n\t\t{`\\\\`, `\\`},\n\t\t{`\\/`, `/`},\n\t\t{`\\b`, \"\\b\"},\n\t\t{`\\f`, \"\\f\"},\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\r`, \"\\r\"},\n\t\t{`\\t`, \"\\t\"},\n\n\t\t// Unicode escape sequences.\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A0`, \"\\u00A0\"},\n\t\t{`\\uFFFF`, \"\\uFFFF\"},\n\n\t\t// Surrogate pairs.\n\t\t{`\\uD83D\\uDE01`, \"\\U0001F601\"},\n\n\t\t// Invalid escape sequences.\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\uD800`, `\\uD800`},\n\t\t{`\\uD800\\u`, `\\uD800\\u`},\n\n\t\t// Mixed strings with valid and invalid escape sequences.\n\t\t{`hello\\tworld`, \"hello\\tworld\"},\n\t\t{`\\u0041\\x\\u0042\\u0043`, `A\\xBC`},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}\n","4f4491cb7c5cc7f58615a05c592dd536":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput       string\n\t\twantValue   *Value\n\t\twantTail    string\n\t\twantErr     bool\n\t\twantErrText string\n\t}{\n\t\t// Empty string.\n\t\t{\n\t\t\tinput:       \"\",\n\t\t\twantValue:   nil,\n\t\t\twantTail:    \"\",\n\t\t\twantErr:     true,\n\t\t\twantErrText: \"cannot parse empty string\",\n\t\t},\n\n\t\t// Object.\n\t\t{\n\t\t\tinput:    `{\"foo\": \"bar\"}`,\n\t\t\twantValue: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: typeRawString, s: \"bar\"}}}}}},\n\t\t\twantTail:    \"\",\n\t\t\twantErr:     false,\n\t\t},\n\n\t\t// Array.\n\t\t{\n\t\t\tinput:    `[1, \"foo\"]`,\n\t\t\twantValue: \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: typeRawString, s: \"foo\"}}},\n\t\t\twantTail:    \"\",\n\t\t\twantErr:     false,\n\t\t},\n\n\t\t// String.\n\t\t{\n\t\t\tinput:    `\"foo\"`,\n\t\t\twantValue: \u0026Value{t: typeRawString, s: \"foo\"},\n\t\t\twantTail:    \"\",\n\t\t\twantErr:     false,\n\t\t},\n\n\t\t// True.\n\t\t{\n\t\t\tinput:    \"true\",\n\t\t\twantValue: valueTrue,\n\t\t\twantTail:    \"\",\n\t\t\twantErr:     false,\n\t\t},\n\n\t\t// False.\n\t\t{\n\t\t\tinput:    \"false\",\n\t\t\twantValue: valueFalse,\n\t\t\twantTail:    \"\",\n\t\t\twantErr:     false,\n\t\t},\n\n\t\t// Null.\n\t\t{\n\t\t\tinput:    \"null\",\n\t\t\twantValue: valueNull,\n\t\t\twantTail:    \"\",\n\t\t\twantErr:     false,\n\t\t},\n\n\t\t// NaN.\n\t\t{\n\t\t\tinput:    \"NaN\",\n\t\t\twantValue: \u0026Value{t: TypeNumber, s: \"NaN\"},\n\t\t\twantTail:    \"\",\n\t\t\twantErr:     false,\n\t\t},\n\n\t\t// Number.\n\t\t{\n\t\t\tinput:    \"123.456\",\n\t\t\twantValue: \u0026Value{t: TypeNumber, s: \"123.456\"},\n\t\t\twantTail:    \"\",\n\t\t\twantErr:     false,\n\t\t},\n\n\t\t// Unexpected value.\n\t\t{\n\t\t\tinput:       \"xyz\",\n\t\t\twantValue:   nil,\n\t\t\twantTail:    \"xyz\",\n\t\t\twantErr:     true,\n\t\t\twantErrText: \"unexpected value found: \\\"xyz\\\"\",\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgotValue, gotTail, gotErr := parseValue(tt.input, c, 0)\n\n\t\t\tif (gotErr != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", gotErr, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotErr != nil \u0026\u0026 gotErr.Error() != tt.wantErrText {\n\t\t\t\tt.Errorf(\"parseValue() error text = %v, want error text %v\", gotErr.Error(), tt.wantErrText)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseValue() gotTail = %v, want %v\", gotTail, tt.wantTail)\n\t\t\t}\n\n\t\t\tif gotValue == nil \u0026\u0026 tt.wantValue == nil {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif gotValue.Type() != tt.wantValue.Type() {\n\t\t\t\tt.Errorf(\"parseValue() gotValue.Type = %v, want %v\", gotValue.Type(), tt.wantValue.Type())\n\t\t\t}\n\t\t\tif gotValue.String() != tt.wantValue.String() {\n\t\t\t\tt.Errorf(\"parseValue() gotValue = %v, want %v\", gotValue, tt.wantValue)\n\t\t\t}\n\t\t})\n\t}\n}\n","4fc89e3a630b8e550765596372d584cd":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic escapes\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\t`, \"\\t\"},\n\t\t{`\\\\`, \"\\\\\"},\n\t\t{`\\\"`, \"\\\"\"},\n\t\t{`\\/`, \"/\"},\n\t\t{`\\b`, \"\\b\"},\n\t\t{`\\f`, \"\\f\"},\n\t\t{`\\r`, \"\\r\"},\n\n\t\t// Unicode escapes\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A0`, \"\\u00A0\"},\n\t\t{`\\u20AC`, \"\\u20AC\"},\n\t\t{`\\uD83D\\uDE02`, \"\\U0001F602\"}, // Surrogate pair\n\n\t\t// Invalid escapes (should be left as-is)\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\uD800`, `\\uD800`}, // Unpaired surrogate\n\n\t\t// Mixed escapes and regular characters\n\t\t{`Hello\\tworld\\n`, \"Hello\\tworld\\n\"},\n\t\t{`This is a \\\\\"test\\\\\" string.`, `This is a \"test\" string.`},\n\t\t{`C:\\\\Users\\\\John\\\\Documents`, `C:\\Users\\John\\Documents`},\n\n\t\t// Empty string\n\t\t{``, ``},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}","503f3922e45e669920f6725150e5602b":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tinput   string\n\t\twant    *Value\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tp := \u0026Parser{}\n\t\t\tgot, err := p.Parse(tt.input)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Parser.Parse() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Parser.Parse() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","507ed88071a072bb161e39e02811a740":"package fastjson\n\nimport \"testing\"\n\nfunc Test_skipWSSlow(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with leading whitespace\",\n\t\t\targs: args{s: \"  foo\"},\n\t\t\twant: \"foo\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with no leading whitespace\",\n\t\t\targs: args{s: \"foo\"},\n\t\t\twant: \"foo\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with leading whitespace and embedded whitespace\",\n\t\t\targs: args{s: \"  foo bar\"},\n\t\t\twant: \"foo bar\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with all whitespace\",\n\t\t\targs: args{s: \" \\t\\n\\r\"},\n\t\t\twant: \"\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","51623eafceb80d06c6bf0fcefe4a047b":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\twantS string\n\t\terr   error\n\t}{\n\t\t// Empty input.\n\t\t{\"\", nil, \"\", fmt.Errorf(\"missing ']'\")},\n\t\t// Empty array.\n\t\t{\"[]\", \u0026Value{t: TypeArray}, \"\", nil},\n\t\t// Simple array.\n\t\t{\"[1,2,3]\", \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}}, \"\", nil},\n\t\t// Array with whitespace.\n\t\t{\" [ 1 , 2 , 3 ] \", \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}}, \"\", nil},\n\t\t// Nested array.\n\t\t{\"[[1,2],[3,4]]\", \u0026Value{t: TypeArray, a: []*Value{{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}}}, {t: TypeArray, a: []*Value{{t: TypeNumber, s: \"3\"}, {t: TypeNumber, s: \"4\"}}}}}, \"\", nil},\n\t\t// Array with different types.\n\t\t{\"[1,\\\"foo\\\",true]\", \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeString, s: \"foo\"}, {t: TypeTrue}}}, \"\", nil},\n\t\t// Invalid array: missing comma.\n\t\t{\"[1 2]\", nil, \" 2]\", fmt.Errorf(\"missing ',' after array value\")},\n\t\t// Invalid array: missing closing bracket.\n\t\t{\"[1,2\", nil, \"\", fmt.Errorf(\"unexpected end of array\")},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, gotS, err := parseArray(tt.input, c, 0)\n\n\t\t\tif tt.err != nil {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"Expected error, got nil\")\n\t\t\t\t} else if err.Error() != tt.err.Error() {\n\t\t\t\t\tt.Errorf(\"Expected error %q, got %q\", tt.err, err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"Expected remaining string %q, got %q\", tt.wantS, gotS)\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"Test %d failed: input %q, got %v, want %v\", i, tt.input, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(a, b *Value) bool {\n\tif a == nil \u0026\u0026 b == nil {\n\t\treturn true\n\t}\n\tif a == nil || b == nil {\n\t\treturn false\n\t}\n\tif a.t != b.t {\n\t\treturn false\n\t}\n\tswitch a.t {\n\tcase TypeArray:\n\t\tif len(a.a) != len(b.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range a.a {\n\t\t\tif !equalValues(a.a[i], b.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeString, TypeNumber:\n\t\treturn a.s == b.s\n\tdefault:\n\t\treturn true\n\t}\n}","51deb49920dfc6e510077a17df92cc0a":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tinput   string\n\t\twant    *Value\n\t\twantErr error\n\t}{\n\t\t// TODO: Add test cases.\n\t\t{\n\t\t\tname:  \"empty\",\n\t\t\tinput: \"\",\n\t\t\twant:  nil,\n\t\t\twantErr: fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, _, err := parseValue(tt.input, c, 0)\n\t\t\tif (err != nil) != (tt.wantErr != nil) {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err != nil \u0026\u0026 err.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","51eb580ec9a46535500e7d56e243aafa":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic escapes\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\t`, \"\\t\"},\n\t\t{`\\\\`, \"\\\\\"},\n\t\t{`\\\"`, \"\\\"\"},\n\t\t{`\\/`, \"/\"},\n\n\t\t// Unicode escapes\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A9`, \"¬©\"},\n\t\t{`\\u20AC`, \"‚Ç¨\"},\n\n\t\t// Surrogate pairs\n\t\t{`\\uD83D\\uDE02`, \"üòÇ\"},\n\n\t\t// Invalid escapes\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\uD800`, `\\uD800`}, // Missing low surrogate\n\t\t{`\\uD800\\u1234`, `\\uD800\\u1234`}, // Invalid low surrogate\n\n\t\t// Mixed escapes\n\t\t{`Hello\\tworld\\n`, \"Hello\\tworld\\n\"},\n\t\t{`Copyright \\u00A9 2023`, \"Copyright ¬© 2023\"},\n\t\t{`Invalid escape: \\x, valid escape: \\n`, \"Invalid escape: \\\\x, valid escape: \\n\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}\n","5247ae134bd05d190a83b85d60a407ce":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Empty string\n\t\t{\"\", nil, \"\", fmt.Errorf(\"cannot parse empty string\")},\n\n\t\t// Object\n\t\t{`{\"foo\": \"bar\"}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: typeRawString, s: \"bar\"}}}}}, \"\", nil},\n\n\t\t// Array\n\t\t{`[1, \"two\", true]`, \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: typeRawString, s: \"two\"}, {t: TypeTrue}}}, \"\", nil},\n\n\t\t// String\n\t\t{`\"hello world\"`, \u0026Value{t: typeRawString, s: \"hello world\"}, \"\", nil},\n\n\t\t// True\n\t\t{\"true\", valueTrue, \"\", nil},\n\n\t\t// False\n\t\t{\"false\", valueFalse, \"\", nil},\n\n\t\t// Null\n\t\t{\"null\", valueNull, \"\", nil},\n\n\t\t// NaN\n\t\t{\"NaN\", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"\", nil},\n\n\t\t// Number\n\t\t{\"12345\", \u0026Value{t: TypeNumber, s: \"12345\"}, \"\", nil},\n\t\t{\"-12345\", \u0026Value{t: TypeNumber, s: \"-12345\"}, \"\", nil},\n\t\t{\"123.45\", \u0026Value{t: TypeNumber, s: \"123.45\"}, \"\", nil},\n\t\t{\"-123.45\", \u0026Value{t: TypeNumber, s: \"-123.45\"}, \"\", nil},\n\n\t\t// Invalid JSON\n\t\t{\"{\", nil, \"{\", fmt.Errorf(\"cannot parse object: unexpected EOF\")},\n\t\t{\"[\", nil, \"[\", fmt.Errorf(\"cannot parse array: unexpected EOF\")},\n\t\t{`\"unterminated string`, nil, `\"unterminated string`, fmt.Errorf(\"cannot parse string: unexpected EOF\")},\n\t\t{\"tru\", nil, \"tru\", fmt.Errorf(\"unexpected value found: %q\", \"tru\")},\n\t\t{\"fals\", nil, \"fals\", fmt.Errorf(\"unexpected value found: %q\", \"fals\")},\n\t\t{\"nul\", nil, \"nul\", fmt.Errorf(\"unexpected value found: %q\", \"nul\")},\n\t\t{\"123invalid\", nil, \"invalid\", fmt.Errorf(\"cannot parse number: invalid syntax\")},\n\n\t\t// Trailing data\n\t\t{`\"hello\" world`, \u0026Value{t: typeRawString, s: \"hello\"}, \" world\", nil},\n\t}\n\n\tc := \u0026cache{}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test %d: %s\", i, tt.input), func(t *testing.T) {\n\t\t\tgot, tail, err := parseValue(tt.input, c, 0)\n\n\t\t\tif tt.err != nil {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"Expected error, got nil\")\n\t\t\t\t} else if err.Error() != tt.err.Error() {\n\t\t\t\t\tt.Errorf(\"Expected error: %v, got: %v\", tt.err, err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t\t}\n\n\t\t\tif got == nil \u0026\u0026 tt.want != nil {\n\t\t\t\tt.Errorf(\"Expected non-nil value, got nil\")\n\t\t\t} else if got != nil \u0026\u0026 tt.want == nil {\n\t\t\t\tt.Errorf(\"Expected nil value, got %v\", got)\n\t\t\t} else if got != nil \u0026\u0026 tt.want != nil {\n\t\t\t\tif got.t != tt.want.t {\n\t\t\t\t\tt.Errorf(\"Expected type %d, got %d\", tt.want.t, got.t)\n\t\t\t\t}\n\t\t\t\tif got.s != tt.want.s {\n\t\t\t\t\tt.Errorf(\"Expected string value %q, got %q\", tt.want.s, got.s)\n\t\t\t\t}\n\t\t\t\t// Add more assertions for other fields of Value as needed\n\t\t\t}\n\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"Expected tail %q, got %q\", tt.tail, tail)\n\t\t\t}\n\t\t})\n\t}\n}","526d23c85d09e89c801d9123b00e9a9b":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic escapes\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\t`, \"\\t\"},\n\t\t{`\\\\`, \"\\\\\"},\n\t\t{`\\\"`, \"\\\"\"},\n\t\t{`\\/`, \"/\"},\n\n\t\t// Unicode escapes\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A9`, \"¬©\"},\n\t\t{`\\u20AC`, \"‚Ç¨\"},\n\n\t\t// Surrogate pairs\n\t\t{`\\uD83D\\uDE02`, \"üòÇ\"},\n\n\t\t// Invalid escapes\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u`, `\\u`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\uD800`, `\\uD800`}, // Missing low surrogate\n\t\t{`\\uD800\\u1234`, `\\uD800\\u1234`}, // Invalid low surrogate\n\n\t\t// Mixed strings\n\t\t{`Hello\\tworld\\n`, \"Hello\\tworld\\n\"},\n\t\t{`This is a \\\"test\\\" string.`, \"This is a \\\"test\\\" string.\"},\n\t\t{`C:\\\\Users\\\\John\\\\Documents`, `C:\\\\Users\\\\John\\\\Documents`},\n\n\t\t// Empty string\n\t\t{``, ``},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}","528a2d825a6aee6a7ac7a372fbecd8b5":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"raw string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"raw string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"12345\",\n\t\t\t},\n\t\t\twant: []byte(\"12345\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"string1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"12345\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"[\\\"string1\\\",12345]\"),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"string1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"12345\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"{\\\"key1\\\":\\\"string1\\\",\\\"key2\\\":12345}\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo([]byte{})\n\t\t\tif string(got) != string(tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", string(got), string(tt.want))\n\t\t\t}\n\t\t})\n\t}\n}","52b69c67d9b989e8d08cb882093db87e":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Get(t *testing.T) {\n\tt.Run(\"object\", func(t *testing.T) {\n\t\tv := MustParse(`{\"foo\": \"bar\", \"baz\": {\"qux\": 1}}`)\n\n\t\ttests := []struct {\n\t\t\tkeys []string\n\t\t\twant *Value\n\t\t}{\n\t\t\t{\n\t\t\t\tkeys: []string{\"foo\"},\n\t\t\t\twant: MustParse(`\"bar\"`),\n\t\t\t},\n\t\t\t{\n\t\t\t\tkeys: []string{\"baz\"},\n\t\t\t\twant: MustParse(`{\"qux\": 1}`),\n\t\t\t},\n\t\t\t{\n\t\t\t\tkeys: []string{\"baz\", \"qux\"},\n\t\t\t\twant: MustParse(`1`),\n\t\t\t},\n\t\t\t{\n\t\t\t\tkeys: []string{\"nonexisting\"},\n\t\t\t\twant: nil,\n\t\t\t},\n\t\t\t{\n\t\t\t\tkeys: []string{\"foo\", \"nonexisting\"},\n\t\t\t\twant: nil,\n\t\t\t},\n\t\t}\n\n\t\tfor _, test := range tests {\n\t\t\tif got := v.Get(test.keys...); got != test.want {\n\t\t\t\tt.Errorf(\"Get(%v) = %v, want %v\", test.keys, got, test.want)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"array\", func(t *testing.T) {\n\t\tv := MustParse(`[1, \"foo\", {\"bar\": \"baz\"}]`)\n\n\t\ttests := []struct {\n\t\t\tkeys []string\n\t\t\twant *Value\n\t\t}{\n\t\t\t{\n\t\t\t\tkeys: []string{\"0\"},\n\t\t\t\twant: MustParse(`1`),\n\t\t\t},\n\t\t\t{\n\t\t\t\tkeys: []string{\"1\"},\n\t\t\t\twant: MustParse(`\"foo\"`),\n\t\t\t},\n\t\t\t{\n\t\t\t\tkeys: []string{\"2\", \"bar\"},\n\t\t\t\twant: MustParse(`\"baz\"`),\n\t\t\t},\n\t\t\t{\n\t\t\t\tkeys: []string{\"3\"},\n\t\t\t\twant: nil,\n\t\t\t},\n\t\t\t{\n\t\t\t\tkeys: []string{\"0\", \"nonexisting\"},\n\t\t\t\twant: nil,\n\t\t\t},\n\t\t}\n\n\t\tfor _, test := range tests {\n\t\t\tif got := v.Get(test.keys...); got != test.want {\n\t\t\t\tt.Errorf(\"Get(%v) = %v, want %v\", test.keys, got, test.want)\n\t\t\t}\n\t\t}\n\t})\n}","52d2cdb7fd59ff3333585b77492b3dac":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ts     string\n\t\terr   error\n\t}{\n\t\t// Empty object\n\t\t{\n\t\t\tinput: `{}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Single key-value pair\n\t\t{\n\t\t\tinput: `{\"key\": \"value\"}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts:  \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Multiple key-value pairs\n\t\t{\n\t\t\tinput: `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts:  \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts:  \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Nested object\n\t\t{\n\t\t\tinput: `{\"key1\": {\"key2\": \"value2\"}}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts:  \"value2\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Invalid JSON - missing closing brace\n\t\t{\n\t\t\tinput: `{\"key\": \"value\"`,\n\t\t\twant:  nil,\n\t\t\ts:     `{\"key\": \"value\"`,\n\t\t\terr:   fmt.Errorf(\"unexpected end of object\"),\n\t\t},\n\t\t// Invalid JSON - missing comma\n\t\t{\n\t\t\tinput: `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twant:  nil,\n\t\t\ts:     `\"key2\": \"value2\"}`,\n\t\t\terr:   fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\t}\n\n\tfor i, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i+1), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseObject(test.input, c, 0)\n\n\t\t\tif test.err != nil {\n\t\t\t\tif err == nil || err.Error() != test.err.Error() {\n\t\t\t\t\tt.Errorf(\"Expected error %v, got %v\", test.err, err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif s != test.s {\n\t\t\t\tt.Errorf(\"Expected remaining string %q, got %q\", test.s, s)\n\t\t\t}\n\n\t\t\tif !equalValues(got, test.want) {\n\t\t\t\tt.Errorf(\"Expected value %v, got %v\", test.want, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t// Add cases for other types as needed\n\tdefault:\n\t\treturn false\n\t}\n}\n","52f0859c0121dc670dfa3c6394572777":"package fastjson\n\nimport \"testing\"\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tt    Type\n\t\twant string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\tfor i, tt := range tests {\n\t\tif got := tt.t.String(); got != tt.want {\n\t\t\tt.Errorf(\"test[%d] - String() = %v, want %v\", i, got, tt.want)\n\t\t}\n\t}\n}","53998db868a67109c659274b129aa427":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twant     *Value\n\t\twantRest string\n\t\twantErr  error\n\t}{\n\t\t{\n\t\t\tname:     \"empty array\",\n\t\t\tinput:    \"[]\",\n\t\t\twant:     \u0026Value{t: TypeArray, a: []*Value{}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"single element array\",\n\t\t\tinput:    \"[1]\",\n\t\t\twant:     \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple element array\",\n\t\t\tinput:    \"[1,2,3]\",\n\t\t\twant:     \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with whitespace\",\n\t\t\tinput:    \" [ 1 , 2 , 3 ] \",\n\t\t\twant:     \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}},\n\t\t\twantRest: \" \",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"nested array\",\n\t\t\tinput:    \"[[1,2],[3,4]]\",\n\t\t\twant: \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}}},\n\t\t\t\t{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"3\"}, {t: TypeNumber, s: \"4\"}}},\n\t\t\t}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing closing bracket\",\n\t\t\tinput:    \"[1,2,3\",\n\t\t\twant:     nil,\n\t\t\twantRest: \"\",\n\t\t\twantErr:  fmt.Errorf(\"missing ']'\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"missing comma\",\n\t\t\tinput:    \"[1 2]\",\n\t\t\twant:     nil,\n\t\t\twantRest: \"\",\n\t\t\twantErr:  fmt.Errorf(\"missing ',' after array value\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid value\",\n\t\t\tinput:    \"[1,invalid,3]\",\n\t\t\twant:     nil,\n\t\t\twantRest: \"\",\n\t\t\twantErr:  fmt.Errorf(\"cannot parse array value: invalid number\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, rest, err := parseArray(tt.input, c, 0)\n\n\t\t\tif (err != nil \u0026\u0026 tt.wantErr == nil) || (err == nil \u0026\u0026 tt.wantErr != nil) || (err != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 err.Error() != tt.wantErr.Error()) {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif rest != tt.wantRest {\n\t\t\t\tt.Errorf(\"parseArray() rest = %v, wantRest %v\", rest, tt.wantRest)\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.t == TypeArray {\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\treturn v1.s == v2.s\n}","53b23725d802bd896fea42c9c410de4c":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Empty string\n\t\t{\"\", nil, \"\", fmt.Errorf(\"cannot parse empty string\")},\n\t\t// Invalid JSON\n\t\t{\"{invalid}\", nil, \"\", fmt.Errorf(\"cannot parse object: invalid character 'i' looking for beginning of value\")},\n\t\t// Simple object\n\t\t{`{\"key\": \"value\"}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{t: typeRawString, s: \"value\"}}}}}}, \"\", nil},\n\t\t// Simple array\n\t\t{`[1, \"two\", true]`, \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: typeRawString, s: \"two\"}, {t: TypeTrue}}}, \"\", nil},\n\t\t// String with escaped characters\n\t\t{`\"hello\\nworld\"`, \u0026Value{t: typeRawString, s: \"hello\\nworld\"}, \"\", nil},\n\t\t// True boolean\n\t\t{\"true\", valueTrue, \"\", nil},\n\t\t// False boolean\n\t\t{\"false\", valueFalse, \"\", nil},\n\t\t// Null value\n\t\t{\"null\", valueNull, \"\", nil},\n\t\t// Number\n\t\t{\"12345\", \u0026Value{t: TypeNumber, s: \"12345\"}, \"\", nil},\n\t\t// NaN\n\t\t{\"NaN\", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"\", nil},\n\t\t// Trailing whitespace\n\t\t{`\"value\"  `, \u0026Value{t: typeRawString, s: \"value\"}, \"  \", nil},\n\t\t// Leading whitespace\n\t\t{`  \"value\"`, \u0026Value{t: typeRawString, s: \"value\"}, \"\", nil},\n\t}\n\n\tc := \u0026cache{}\n\tfor i, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tgot, tail, err := parseValue(test.input, c, 0)\n\n\t\t\tif test.err != nil {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"Expected error, got nil\")\n\t\t\t\t} else if err.Error() != test.err.Error() {\n\t\t\t\t\tt.Errorf(\"Expected error %q, got %q\", test.err, err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t\t}\n\n\t\t\tif tail != test.tail {\n\t\t\t\tt.Errorf(\"Expected tail %q, got %q\", test.tail, tail)\n\t\t\t}\n\n\t\t\tif !equalValues(got, test.want) {\n\t\t\t\tt.Errorf(\"Test %d failed: input %q, expected %v, got %v\", i, test.input, test.want, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.t == typeRawString {\n\t\treturn v1.s == v2.s\n\t}\n\tif v1.t == TypeNumber {\n\t\treturn v1.s == v2.s\n\t}\n\tif v1.t == TypeObject {\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\tif v1.t == TypeArray {\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\treturn false\n}","54d21dbd2f396078b3efb6b6942aa1c4":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey   string\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Basic cases\n\t\t{`\"foo\"bar`, \"foo\", \"bar\", nil},\n\t\t{`\"fo\\\"o\"bar`, `fo\"o`, \"bar\", nil},\n\t\t{`\"foo\"`, \"foo\", \"\", nil},\n\t\t{`\"\"bar`, \"\", \"bar\", nil},\n\n\t\t// Escaped quotes\n\t\t{`\"foo\\\\\"bar\"baz`, `foo\\bar`, \"baz\", nil},\n\t\t{`\"foo\\\\\\\\\"bar\"baz`, `foo\\\\`, `bar\"baz`, nil},\n\n\t\t// Missing closing quote\n\t\t{`\"foobar`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo\\\"bar`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\n\t\t// Empty string\n\t\t{`\"\"`, \"\", \"\", nil},\n\n\t\t// String with special characters\n\t\t{`\"foo\\nbar\"baz`, \"foo\\nbar\", \"baz\", nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tkey, tail, err := parseRawString(tt.input)\n\t\t\tif key != tt.key || tail != tt.tail || !errorEqual(err, tt.err) {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = (%q, %q, %v), want (%q, %q, %v)\", tt.input, key, tail, err, tt.key, tt.tail, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc errorEqual(e1, e2 error) bool {\n\tif e1 == nil \u0026\u0026 e2 == nil {\n\t\treturn true\n\t}\n\tif e1 == nil || e2 == nil {\n\t\treturn false\n\t}\n\treturn e1.Error() == e2.Error()\n}","55ab33cd70885a9d7bec39d7c6952a4f":"","55ae7eb91da475c49df165ec95632208":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"raw string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"raw string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"12345\",\n\t\t\t},\n\t\t\twant: []byte(\"12345\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"string\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"12345\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"[\\\"string\\\",12345]\"),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"string\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"string\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"number\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"12345\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"{\\\"string\\\":\\\"string\\\",\\\"number\\\":\\\"12345\\\"}\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif string(got) != string(tt.want) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %v, want %v\", string(got), string(tt.want))\n\t\t\t}\n\t\t})\n\t}\n}\n","55c709ffad8143534ddeaf41a1e7bd19":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput       string\n\t\twantNumber  string\n\t\twantTail    string\n\t\twantErr     bool\n\t\twantErrDesc string\n\t}{\n\t\t{\n\t\t\tinput:      \"123\",\n\t\t\twantNumber: \"123\",\n\t\t\twantTail:    \"\",\n\t\t},\n\t\t{\n\t\t\tinput:      \"123.456\",\n\t\t\twantNumber: \"123.456\",\n\t\t\twantTail:    \"\",\n\t\t},\n\t\t{\n\t\t\tinput:      \"-123\",\n\t\t\twantNumber: \"-123\",\n\t\t\twantTail:    \"\",\n\t\t},\n\t\t{\n\t\t\tinput:      \"123a\",\n\t\t\twantNumber: \"123\",\n\t\t\twantTail:    \"a\",\n\t\t},\n\t\t{\n\t\t\tinput:      \"123.456a\",\n\t\t\twantNumber: \"123.456\",\n\t\t\twantTail:    \"a\",\n\t\t},\n\t\t{\n\t\t\tinput:      \"-123a\",\n\t\t\twantNumber: \"-123\",\n\t\t\twantTail:    \"a\",\n\t\t},\n\t\t{\n\t\t\tinput:      \"123e+10\",\n\t\t\twantNumber: \"123e+10\",\n\t\t\twantTail:    \"\",\n\t\t},\n\t\t{\n\t\t\tinput:      \"123E-10\",\n\t\t\twantNumber: \"123E-10\",\n\t\t\twantTail:    \"\",\n\t\t},\n\t\t{\n\t\t\tinput:      \"123e10\",\n\t\t\twantNumber: \"123e10\",\n\t\t\twantTail:    \"\",\n\t\t},\n\t\t{\n\t\t\tinput:      \"123E10\",\n\t\t\twantNumber: \"123E10\",\n\t\t\twantTail:    \"\",\n\t\t},\n\t\t{\n\t\t\tinput:      \"123e+10a\",\n\t\t\twantNumber: \"123e+10\",\n\t\t\twantTail:    \"a\",\n\t\t},\n\t\t{\n\t\t\tinput:      \"123E-10a\",\n\t\t\twantNumber: \"123E-10\",\n\t\t\twantTail:    \"a\",\n\t\t},\n\t\t{\n\t\t\tinput:      \"123e10a\",\n\t\t\twantNumber: \"123e10\",\n\t\t\twantTail:    \"a\",\n\t\t},\n\t\t{\n\t\t\tinput:      \"123E10a\",\n\t\t\twantNumber: \"123E10\",\n\t\t\twantTail:    \"a\",\n\t\t},\n\t\t{\n\t\t\tinput:       \"a123\",\n\t\t\twantNumber:  \"\",\n\t\t\twantErr:     true,\n\t\t\twantErrDesc: \"unexpected char\",\n\t\t},\n\t\t{\n\t\t\tinput:       \"+a123\",\n\t\t\twantNumber:  \"\",\n\t\t\twantErr:     true,\n\t\t\twantErrDesc: \"unexpected char\",\n\t\t},\n\t\t{\n\t\t\tinput:       \"-a123\",\n\t\t\twantNumber:  \"\",\n\t\t\twantErr:     true,\n\t\t\twantErrDesc: \"unexpected char\",\n\t\t},\n\t\t{\n\t\t\tinput:      \"inf\",\n\t\t\twantNumber: \"inf\",\n\t\t\twantTail:    \"\",\n\t\t},\n\t\t{\n\t\t\tinput:      \"InF\",\n\t\t\twantNumber: \"InF\",\n\t\t\twantTail:    \"\",\n\t\t},\n\t\t{\n\t\t\tinput:      \"INF\",\n\t\t\twantNumber: \"INF\",\n\t\t\twantTail:    \"\",\n\t\t},\n\t\t{\n\t\t\tinput:      \"infa\",\n\t\t\twantNumber: \"inf\",\n\t\t\twantTail:    \"a\",\n\t\t},\n\t\t{\n\t\t\tinput:      \"nan\",\n\t\t\twantNumber: \"nan\",\n\t\t\twantTail:    \"\",\n\t\t},\n\t\t{\n\t\t\tinput:      \"NaN\",\n\t\t\twantNumber: \"NaN\",\n\t\t\twantTail:    \"\",\n\t\t},\n\t\t{\n\t\t\tinput:      \"NAN\",\n\t\t\twantNumber: \"NAN\",\n\t\t\twantTail:    \"\",\n\t\t},\n\t\t{\n\t\t\tinput:      \"nana\",\n\t\t\twantNumber: \"nan\",\n\t\t\twantTail:    \"a\",\n\t\t},\n\t\t{\n\t\t\tinput:       \"n\",\n\t\t\twantNumber:  \"\",\n\t\t\twantErr:     true,\n\t\t\twantErrDesc: \"unexpected char\",\n\t\t},\n\t\t{\n\t\t\tinput:       \"-n\",\n\t\t\twantNumber:  \"\",\n\t\t\twantErr:     true,\n\t\t\twantErrDesc: \"unexpected char\",\n\t\t},\n\t\t{\n\t\t\tinput:       \"+n\",\n\t\t\twantNumber:  \"\",\n\t\t\twantErr:     true,\n\t\t\twantErrDesc: \"unexpected char\",\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test %d\", i), func(t *testing.T) {\n\t\t\tgotNumber, gotTail, err := parseRawNumber(tt.input)\n\t\t\tif tt.wantErr {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"parseRawNumber(%q) got no error, want error with description %q\", tt.input, tt.wantErrDesc)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif !testing.Verbose() {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif tt.wantErrDesc != \"\" \u0026\u0026 !strings.Contains(err.Error(), tt.wantErrDesc) {\n\t\t\t\t\tt.Errorf(\"parseRawNumber(%q) got error %q, want error with description %q\", tt.input, err, tt.wantErrDesc)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got error %q, want no error\", tt.input, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNumber != tt.wantNumber {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got number %q, want %q\", tt.input, gotNumber, tt.wantNumber)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got tail %q, want %q\", tt.input, gotTail, tt.wantTail)\n\t\t\t}\n\t\t})\n\t}\n}","567dc1a07a611eae451a61af6d9ce469":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCache_getValue(t *testing.T) {\n\tt.Run(\"return last element when capacity is larger than length\", func(t *testing.T) {\n\t\tc := \u0026cache{\n\t\t\tvs: make([]Value, 1, 2),\n\t\t}\n\t\tc.vs[0].t = TypeNumber\n\n\t\tv := c.getValue()\n\n\t\tif v.t != TypeNumber {\n\t\t\tt.Errorf(\"Expected TypeNumber, got %v\", v.t)\n\t\t}\n\t})\n\n\tt.Run(\"append new element when capacity is equal to length\", func(t *testing.T) {\n\t\tc := \u0026cache{\n\t\t\tvs: make([]Value, 1, 1),\n\t\t}\n\t\tc.vs[0].t = TypeNumber\n\n\t\tv := c.getValue()\n\n\t\tif v.t != TypeNull {\n\t\t\tt.Errorf(\"Expected TypeNull, got %v\", v.t)\n\t\t}\n\t\tif len(c.vs) != 2 {\n\t\t\tt.Errorf(\"Expected length 2, got %v\", len(c.vs))\n\t\t}\n\t})\n}\n","569adecc916ae3f07b25462da44a89f4":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\tt.Run(\"TypeRawString\", func(t *testing.T) {\n\t\tv := \u0026Value{\n\t\t\tt: typeRawString,\n\t\t\ts: \"raw string\",\n\t\t}\n\t\tdst := v.MarshalTo(nil)\n\t\texpect := []byte(\"\\\"raw string\\\"\")\n\t\tif string(dst) != string(expect) {\n\t\t\tt.Errorf(\"Marshalled TypeRawString incorrectly. Expected '%s', got '%s'\", expect, dst)\n\t\t}\n\t})\n\n\tt.Run(\"TypeString\", func(t *testing.T) {\n\t\tv := \u0026Value{\n\t\t\tt: TypeString,\n\t\t\ts: \"string\",\n\t\t}\n\t\tdst := v.MarshalTo(nil)\n\t\texpect := []byte(\"\\\"string\\\"\")\n\t\tif string(dst) != string(expect) {\n\t\t\tt.Errorf(\"Marshalled TypeString incorrectly. Expected '%s', got '%s'\", expect, dst)\n\t\t}\n\t})\n\n\tt.Run(\"TypeNumber\", func(t *testing.T) {\n\t\tv := \u0026Value{\n\t\t\tt: TypeNumber,\n\t\t\ts: \"123.456\",\n\t\t}\n\t\tdst := v.MarshalTo(nil)\n\t\texpect := []byte(\"123.456\")\n\t\tif string(dst) != string(expect) {\n\t\t\tt.Errorf(\"Marshalled TypeNumber incorrectly. Expected '%s', got '%s'\", expect, dst)\n\t\t}\n\t})\n\n\tt.Run(\"TypeTrue\", func(t *testing.T) {\n\t\tv := \u0026Value{\n\t\t\tt: TypeTrue,\n\t\t}\n\t\tdst := v.MarshalTo(nil)\n\t\texpect := []byte(\"true\")\n\t\tif string(dst) != string(expect) {\n\t\t\tt.Errorf(\"Marshalled TypeTrue incorrectly. Expected '%s', got '%s'\", expect, dst)\n\t\t}\n\t})\n\n\tt.Run(\"TypeFalse\", func(t *testing.T) {\n\t\tv := \u0026Value{\n\t\t\tt: TypeFalse,\n\t\t}\n\t\tdst := v.MarshalTo(nil)\n\t\texpect := []byte(\"false\")\n\t\tif string(dst) != string(expect) {\n\t\t\tt.Errorf(\"Marshalled TypeFalse incorrectly. Expected '%s', got '%s'\", expect, dst)\n\t\t}\n\t})\n\n\tt.Run(\"TypeNull\", func(t *testing.T) {\n\t\tv := \u0026Value{\n\t\t\tt: TypeNull,\n\t\t}\n\t\tdst := v.MarshalTo(nil)\n\t\texpect := []byte(\"null\")\n\t\tif string(dst) != string(expect) {\n\t\t\tt.Errorf(\"Marshalled TypeNull incorrectly. Expected '%s', got '%s'\", expect, dst)\n\t\t}\n\t})\n}","569ceb1896d923fc26f5c3de368f3449":"package fastjson\n\nimport \"testing\"\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"  foo\", \"foo\"},\n\t\t{\"\\n\\tfoo\", \"foo\"},\n\t\t{\"\\r\\nfoo\", \"foo\"},\n\t\t{\"foo  \", \"foo  \"},\n\t\t{\"foo\", \"foo\"},\n\t\t{\"\", \"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := skipWSSlow(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"skipWSSlow(%q) = %q, want %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}","56d6cf5f0d301863de996118db5b3f31":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  string\n\t\twant1 string\n\t\terr   error\n\t}{\n\t\t// Test cases here\n\t\t{\"\\\"hello\\\"\", \"hello\", \"\", nil},\n\t\t{\"\\\"hello world\\\"\", \"hello world\", \"\", nil},\n\t\t{\"\\\"hello\\\\\\\"world\\\"\", \"hello\\\"world\", \"\", nil},\n\t\t{\"\\\"hello\\\\\\\\world\\\"\", \"hello\\\\world\", \"\", nil},\n\t\t{\"\\\"hello\\\\/world\\\"\", \"hello/world\", \"\", nil},\n\t\t{\"\\\"hello\\\\bworld\\\"\", \"hello\\bworld\", \"\", nil},\n\t\t{\"\\\"hello\\\\fworld\\\"\", \"hello\\fworld\", \"\", nil},\n\t\t{\"\\\"hello\\\\nworld\\\"\", \"hello\\nworld\", \"\", nil},\n\t\t{\"\\\"hello\\\\rworld\\\"\", \"hello\\rworld\", \"\", nil},\n\t\t{\"\\\"hello\\\\tworld\\\"\", \"hello\\tworld\", \"\", nil},\n\t\t{\"\\\"hello\\\\u0000world\\\"\", \"hello\\u0000world\", \"\", nil},\n\t\t{\"\\\"hello\\\\u000aworld\\\"\", \"hello\\nworld\", \"\", nil},\n\t\t{\"\\\"hello\\\\u000Aworld\\\"\", \"hello\\nworld\", \"\", nil},\n\t\t{\"\\\"hello\\\\ud83d\\\\ude01world\\\"\", \"helloüòÅworld\", \"\", nil},\n\t\t{\"\\\"hello\\\\uD83d\\\\uDE01world\\\"\", \"helloüòÅworld\", \"\", nil},\n\t\t{\"\\\"hello world\\\\\\\"\", \"hello world\\\"\", \"\", nil},\n\t\t{\"\\\"hello world\\\\\\\"\", \"hello world\\\"\", \"\", nil},\n\t\t{\"\\\"hello world\\\\\\\\\\\"\", \"hello world\\\\\", \"\", nil},\n\t\t{\"\\\"hello world\\\\\\\\\\\\\\\"\", \"hello world\\\\\\\"\", \"\", nil},\n\t\t{\"\\\"hello world\\\\\\\\\\\\\\\\\\\"\", \"hello world\\\\\\\\\", \"\", nil},\n\t\t{\"\\\"hello world\\\\\\\\\\\\\\\\\\\\\\\"\", \"hello world\\\\\\\\\\\\\", \"\", nil},\n\t\t{\"\\\"hello world\\\"\", \"hello world\", \"\", nil},\n\t\t{\"\\\"hello\\\\x00world\\\"\", \"hello\\u0000world\", \"\", nil},\n\t\t{\"\\\"\\\\\\\"\", \"\\\"\", \"\", nil},\n\t\t{\"\\\"\\\"\", \"\", \"\", nil},\n\t\t{\"\", \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{\"\\\"\", \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{\"\\\\\\\"\", \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{\"\\\\\\\\\\\"\", \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.input)\n\t\t\tif got != tt.want || got1 != tt.want1 || !errorEqual(err, tt.err) {\n\t\t\t\tt.Errorf(\"parseRawString() = %v, %v, %v, want %v, %v, %v\", got, got1, err, tt.want, tt.want1, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// errorEqual compares two errors for equality.\nfunc errorEqual(e1, e2 error) bool {\n\tif e1 == nil \u0026\u0026 e2 == nil {\n\t\treturn true\n\t}\n\tif e1 != nil \u0026\u0026 e2 != nil {\n\t\treturn e1.Error() == e2.Error()\n\t}\n\treturn false\n}","5839b963b0f00d47ba1ea71416983cae":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParser_Parse(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\ts       string\n\t\twant    *Value\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tp := \u0026Parser{}\n\t\t\tgot, err := p.Parse(tt.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Parser.Parse() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != nil {\n\t\t\t\tif got.Type() == TypeObject {\n\t\t\t\t\tif len(got.o.kvs) == 0 \u0026\u0026 len(tt.want.o.kvs) == 0 {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !got.Equal(tt.want) {\n\t\t\t\tt.Errorf(\"Parser.Parse() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","5871d8de5bda10f9c2f0957142902f82":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\t// Test cases for various JSON values\n\ttestCases := []struct {\n\t\tinput       string\n\t\texpectedVal *Value\n\t\texpectedTail string\n\t\texpectedErr error\n\t}{\n\t\t// Empty string\n\t\t{\"\", nil, \"\", fmt.Errorf(\"cannot parse empty string\")},\n\n\t\t// Null value\n\t\t{\"null\", valueNull, \"\", nil},\n\t\t{\"null   \", valueNull, \"   \", nil},\n\n\t\t// True value\n\t\t{\"true\", valueTrue, \"\", nil},\n\t\t{\"true  \", valueTrue, \"  \", nil},\n\n\t\t// False value\n\t\t{\"false\", valueFalse, \"\", nil},\n\t\t{\"false \", valueFalse, \" \", nil},\n\n\t\t// String value\n\t\t{`\"hello\"`, \u0026Value{t: typeRawString, s: \"hello\"}, \"\", nil},\n\t\t{`\"hello world\"`, \u0026Value{t: typeRawString, s: \"hello world\"}, \"\", nil},\n\t\t{`\"hello\\\"world\"`, \u0026Value{t: typeRawString, s: \"hello\\\"world\"}, \"\", nil},\n\n\t\t// Number value\n\t\t{\"123\", \u0026Value{t: TypeNumber, s: \"123\"}, \"\", nil},\n\t\t{\"-123.456\", \u0026Value{t: TypeNumber, s: \"-123.456\"}, \"\", nil},\n\t\t{\"1.2e+3\", \u0026Value{t: TypeNumber, s: \"1.2e+3\"}, \"\", nil},\n\n\t\t// NaN value\n\t\t{\"NaN\", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"\", nil},\n\t\t{\"nan\", \u0026Value{t: TypeNumber, s: \"nan\"}, \"\", nil},\n\n\t\t// Object value\n\t\t{`{}`, \u0026Value{t: TypeObject, o: Object{}}, \"\", nil},\n\n\t\t// Array value\n\t\t{`[]`, \u0026Value{t: TypeArray, a: []*Value{}}, \"\", nil},\n\n\t\t// Invalid JSON value\n\t\t{\"invalid\", nil, \"invalid\", fmt.Errorf(\"unexpected value found: %q\", \"invalid\")},\n\t}\n\n\t// Iterate over the test cases\n\tfor i, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"TestCase_%d\", i), func(t *testing.T) {\n\t\t\t// Call the parseValue function\n\t\t\tactualVal, actualTail, actualErr := parseValue(tc.input, c, 0)\n\n\t\t\t// Check for errors\n\t\t\tif tc.expectedErr != nil {\n\t\t\t\tif actualErr == nil {\n\t\t\t\t\tt.Errorf(\"Expected error %v, but got nil\", tc.expectedErr)\n\t\t\t\t} else if actualErr.Error() != tc.expectedErr.Error() {\n\t\t\t\t\tt.Errorf(\"Expected error %v, but got %v\", tc.expectedErr, actualErr)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t} else if actualErr != nil {\n\t\t\t\tt.Errorf(\"Unexpected error: %v\", actualErr)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Check the parsed value\n\t\t\tif tc.expectedVal.t != actualVal.t {\n\t\t\t\tt.Errorf(\"Expected value type %v, but got %v\", tc.expectedVal.t, actualVal.t)\n\t\t\t}\n\t\t\tif tc.expectedVal.s != actualVal.s {\n\t\t\t\tt.Errorf(\"Expected value string %q, but got %q\", tc.expectedVal.s, actualVal.s)\n\t\t\t}\n\n\t\t\t// Check the remaining tail\n\t\t\tif tc.expectedTail != actualTail {\n\t\t\t\tt.Errorf(\"Expected tail %q, but got %q\", tc.expectedTail, actualTail)\n\t\t\t}\n\t\t})\n\t}\n}","58c7405e774342bc9822664969457783":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey string\n\t\ttail string\n\t\terr error\n\t}{\n\t\t// Simple cases\n\t\t{`\"foo\"bar`, \"foo\", \"bar\", nil},\n\t\t{`\"foo\" bar`, \"foo\", \" bar\", nil},\n\t\t{`\"foo\"  bar`, \"foo\", \"  bar\", nil},\n\n\t\t// Empty strings\n\t\t{`\"\"bar`, \"\", \"bar\", nil},\n\t\t{`\"foo\"\"bar`, \"foo\", `\"bar`, nil},\n\n\t\t// Escaped quotes\n\t\t{`\"fo\\\"o\"bar`, `fo\"o`, \"bar\", nil},\n\t\t{`\"fo\\\\\"o\"bar`, `fo\\`, `o\"bar`, nil},\n\t\t{`\"fo\\\\\\\\\"o\"bar`, `fo\\\\o`, \"bar\", nil},\n\n\t\t// Missing closing quote\n\t\t{`\"foo`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"fo\\\"o`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test %d: %s\", i, tt.input))\n\n\t\tkey, tail, err := parseRawString(tt.input)\n\n\t\tif key != tt.key {\n\t\t\tt.Errorf(\"key mismatch: want %q, got %q\", tt.key, key)\n\t\t}\n\n\t\tif tail != tt.tail {\n\t\t\tt.Errorf(\"tail mismatch: want %q, got %q\", tt.tail, tail)\n\t\t}\n\n\t\tif (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\tt.Errorf(\"error mismatch: want %v, got %v\", tt.err, err)\n\t\t}\n\t}\n}","58c88278ce1d66a2a2e9a8ffad165b22":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ts     string\n\t\terr   error\n\t}{\n\t\t// Empty object\n\t\t{\n\t\t\tinput: `{}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Single key-value pair\n\t\t{\n\t\t\tinput: `{\"key\": \"value\"}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: \u0026Value{t: TypeString, s: \"value\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Multiple key-value pairs\n\t\t{\n\t\t\tinput: `{\"key1\": \"value1\", \"key2\": 123, \"key3\": true}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t\t{k: \"key3\", v: \u0026Value{t: TypeTrue}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Nested object\n\t\t{\n\t\t\tinput: `{\"key1\": {\"key2\": \"value2\"}, \"key3\": \"value3\"}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{k: \"key3\", v: \u0026Value{t: TypeString, s: \"value3\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Missing closing brace\n\t\t{\n\t\t\tinput: `{\"key\": \"value\"`,\n\t\t\twant:  nil,\n\t\t\ts:     `\"value\"`,\n\t\t\terr:   fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t\t// Missing opening quote for key\n\t\t{\n\t\t\tinput: `{key\": \"value\"}`,\n\t\t\twant:  nil,\n\t\t\ts:     `key\": \"value\"}`,\n\t\t\terr:   fmt.Errorf(`cannot find opening '\"\" for object key`),\n\t\t},\n\t\t// Missing colon after key\n\t\t{\n\t\t\tinput: `{\"key\" \"value\"}`,\n\t\t\twant:  nil,\n\t\t\ts:     `\"value\"}`,\n\t\t\terr:   fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t\t// Missing comma between key-value pairs\n\t\t{\n\t\t\tinput: `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twant:  nil,\n\t\t\ts:     `\"key2\": \"value2\"}`,\n\t\t\terr:   fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseObject(tt.input, c, 0)\n\t\t\tif fmt.Sprintf(\"%v\", err) != fmt.Sprintf(\"%v\", tt.err) {\n\t\t\t\tt.Errorf(\"parseObject(%s) error mismatch: got %v, want %v\", tt.input, err, tt.err)\n\t\t\t}\n\t\t\tif s != tt.s {\n\t\t\t\tt.Errorf(\"parseObject(%s) remaining string mismatch: got %q, want %q\", tt.input, s, tt.s)\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject(%s) value mismatch:\\ngot  %+v\\nwant %+v\", tt.input, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\treturn true\n\t}\n}\n","5918e72973e48fabd54b0b57cef2017c":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput  string\n\t\texpect string\n\t}{\n\t\t// Basic tests\n\t\t{`\"\"`, `\"\"`},\n\t\t{`\"foo\"`, `foo`},\n\t\t{`\"foo bar\"`, `foo bar`},\n\t\t{`\"foo\\tbar\"`, `foo\\tbar`},\n\t\t{`\"foo\\nbar\"`, `foo\\nbar`},\n\t\t{`\"foo\\rbar\"`, `foo\\rbar`},\n\t\t{`\"foo\\\\bar\"`, `foo\\\\bar`},\n\t\t{`\"foo\\\"bar\"`, `foo\"bar`},\n\t\t{`\"foo/bar\"`, `foo/bar`},\n\n\t\t// Unicode tests\n\t\t{`\"\\u0020\"`, \" \"},\n\t\t{`\"\\u00A0\"`, \"\\u00A0\"},\n\t\t{`\"\\u20AC\"`, \"‚Ç¨\"},\n\t\t{`\"\\uD83D\\uDE01\"`, \"üòÅ\"},\n\t\t{`\"\\uD800\\uDC00\"`, \"\\U00010000\"},\n\n\t\t// Invalid unicode tests\n\t\t{`\"\\uD800\"`, \"\\uD800\"},\n\t\t{`\"\\uDC00\"`, \"\\uDC00\"},\n\t\t{`\"\\uD800\\uD800\"`, \"\\uD800\\uD800\"},\n\t\t{`\"\\u\"`, `\\u`},\n\t\t{`\"\\u1\"`, `\\u1`},\n\t\t{`\"\\u12\"`, `\\u12`},\n\t\t{`\"\\u123\"`, `\\u123`},\n\t\t{`\"\\u12345\"`, `\\u12345`},\n\n\t\t// Escaped backslash tests\n\t\t{`\"\\\\u0020\"`, `\\u0020`},\n\t\t{`\"\\\\\\\\u0020\"`, `\\\\ `},\n\t\t{`\"\\\\\\\\\\\\u0020\"`, `\\\\\\u0020`},\n\n\t\t// Other escape sequence tests\n\t\t{`\"\\b\"`, \"\\b\"},\n\t\t{`\"\\f\"`, \"\\f\"},\n\t}\n\n\tfor i, tt := range tests {\n\t\tactual := unescapeStringBestEffort(tt.input)\n\t\tif actual != tt.expect {\n\t\t\tt.Errorf(\"Test %d: Expected %q, got %q\", i, tt.expect, actual)\n\t\t}\n\t}\n}","59947fc5320ff2dac77bc86ecff32065":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey   string\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Basic cases\n\t\t{`\"foo\"bar`, \"foo\", \"bar\", nil},\n\t\t{`\"fo\\\"o\"bar`, `fo\"o`, \"bar\", nil},\n\t\t{`\"foo\"`, \"foo\", \"\", nil},\n\t\t{`\"\"bar`, \"\", \"bar\", nil},\n\n\t\t// Escaped quotes\n\t\t{`\"foo\\\\\"bar\"baz`, `foo\\bar`, \"baz\", nil},\n\t\t{`\"foo\\\\\\\\\"bar\"baz`, `foo\\\\`, `bar\"baz`, nil},\n\t\t{`\"foo\\\"bar\"baz`, `foo\"bar`, \"baz\", nil},\n\t\t{`\"foo\\\\bar\"baz`, `foo\\bar`, \"baz\", nil},\n\n\t\t// Missing closing quote\n\t\t{`\"foobar`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo\\\"bar`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo\\\\\"bar`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\n\t\t// Empty strings\n\t\t{`\"\"`, \"\", \"\", nil},\n\t\t{`\"`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d:%s\", i, tt.input), func(t *testing.T) {\n\t\t\tkey, tail, err := parseRawString(tt.input)\n\t\t\tif key != tt.key || tail != tt.tail || (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = (%q, %q, %v), want (%q, %q, %v)\", tt.input, key, tail, err, tt.key, tt.tail, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}\n","59b8e71ef0b4aca2099db261e7678633":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ts     string\n\t\terr   error\n\t}{\n\t\t// Empty object\n\t\t{\n\t\t\tinput: \"{}\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Simple object\n\t\t{\n\t\t\tinput: `{\"key\": \"value\"}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: \u0026Value{t: TypeString, s: \"value\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Object with multiple key-value pairs\n\t\t{\n\t\t\tinput: `{\"key1\": \"value1\", \"key2\": 123, \"key3\": true}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t\t{k: \"key3\", v: \u0026Value{t: TypeTrue}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Nested object\n\t\t{\n\t\t\tinput: `{\"key1\": {\"key2\": \"value2\"}}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Missing closing brace\n\t\t{\n\t\t\tinput: `{\"key\": \"value\"`,\n\t\t\twant:  nil,\n\t\t\ts:     `{\"key\": \"value\"`,\n\t\t\terr:   fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t\t// Invalid key\n\t\t{\n\t\t\tinput: `{key: \"value\"}`,\n\t\t\twant:  nil,\n\t\t\ts:     `{key: \"value\"}`,\n\t\t\terr:   fmt.Errorf(`cannot find opening '\"\" for object key`),\n\t\t},\n\t\t// Missing colon\n\t\t{\n\t\t\tinput: `{\"key\" \"value\"}`,\n\t\t\twant:  nil,\n\t\t\ts:     `\"value\"}`,\n\t\t\terr:   fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t\t// Missing comma\n\t\t{\n\t\t\tinput: `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twant:  nil,\n\t\t\ts:     `\"key2\": \"value2\"}`,\n\t\t\terr:   fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseObject(tt.input, c, 0)\n\t\t\tif (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err == nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"parseObject(%s) error mismatch: got %v, want %v\", tt.input, err, tt.err)\n\t\t\t}\n\t\t\tif s != tt.s {\n\t\t\t\tt.Errorf(\"parseObject(%s) remaining string mismatch: got %q, want %q\", tt.input, s, tt.s)\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject(%s) value mismatch:\\ngot  %+v\\nwant %+v\", tt.input, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber, TypeTrue, TypeFalse:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\treturn false\n\t}\n}\n","5babdb3951265dc321e891198b96edd4":"package fastjson\n\nimport \"testing\"\n\nfunc Test_hasSpecialChars(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    string\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\ts:    \"\",\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with no special characters\",\n\t\t\ts:    \"hello world\",\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with double quote\",\n\t\t\ts:    \"hello\\\"world\",\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with backslash\",\n\t\t\ts:    \"hello\\\\world\",\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with control character\",\n\t\t\ts:    \"hello\\x01world\",\n\t\t\twant: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := hasSpecialChars(tt.s); got != tt.want {\n\t\t\t\tt.Errorf(\"hasSpecialChars() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","5cd64ad2aa4560244f16feafbdcdc631":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantJSON string\n\t\twantErr  error\n\t}{\n\t\t{\n\t\t\tname:     \"empty object\",\n\t\t\tinput:    \"{}\",\n\t\t\twantJSON: `{}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"simple object\",\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\twantJSON: `{\"key\":\"value\"}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"object with multiple keys\",\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantJSON: `{\"key1\":\"value1\",\"key2\":\"value2\"}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"object with nested object\",\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": {\"key3\": \"value3\"}}`,\n\t\t\twantJSON: `{\"key1\":\"value1\",\"key2\":{\"key3\":\"value3\"}}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"object with array\",\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": [\"value2\", \"value3\"]}`,\n\t\t\twantJSON: `{\"key1\":\"value1\",\"key2\":[\"value2\",\"value3\"]}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"object with escaped characters\",\n\t\t\tinput:    `{\"key1\": \"value1\\n\\t\\\\\\\"\", \"key2\": \"value2\"}`,\n\t\t\twantJSON: `{\"key1\":\"value1\\n\\t\\\\\\\"\",\"key2\":\"value2\"}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid object: missing closing brace\",\n\t\t\tinput:    `{\"key\": \"value\"`,\n\t\t\twantErr: fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid object: missing colon\",\n\t\t\tinput:    `{\"key\" \"value\"}`,\n\t\t\twantErr: fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid object: missing comma\",\n\t\t\tinput:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseObject(tt.input, c, 0)\n\t\t\tif tt.wantErr != nil {\n\t\t\t\tif err == nil || err.Error() != tt.wantErr.Error() {\n\t\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr nil\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif s != \"\" {\n\t\t\t\tt.Errorf(\"parseObject() remaining string = %q, want empty string\", s)\n\t\t\t}\n\t\t\tgotJSON := got.String()\n\t\t\tif gotJSON != tt.wantJSON {\n\t\t\t\tt.Errorf(\"parseObject() got = %s, want %s\", gotJSON, tt.wantJSON)\n\t\t\t}\n\t\t})\n\t}\n}\n","5d423fabd7fd94b752240bfb62492b92":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetArray(t *testing.T) {\n\tvar v Value\n\t// Test cases for various JSON structures and key paths\n\ttestCases := []struct {\n\t\tinput    string\n\t\tkeys     []string\n\t\texpected []*Value\n\t}{\n\t\t// Accessing array elements\n\t\t{`{\"a\": [1, 2, 3]}`, []string{\"a\"}, []*Value{\n\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t}},\n\t\t{`{\"a\": [{\"b\": 1}, {\"b\": 2}]}`, []string{\"a\", \"1\", \"b\"}, []*Value{\n\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t}},\n\n\t\t// Handling non-existing keys\n\t\t{`{\"a\": [1, 2, 3]}`, []string{\"b\"}, nil},\n\t\t{`{\"a\": [1, 2, 3]}`, []string{\"a\", \"4\"}, nil},\n\n\t\t// Handling invalid value types\n\t\t{`{\"a\": 123}`, []string{\"a\"}, nil},\n\t\t{`{\"a\": \"string\"}`, []string{\"a\"}, nil},\n\n\t\t// Handling array indexes as decimal numbers\n\t\t{`{\"a\": [1, 2, 3]}`, []string{\"a\", \"0\"}, []*Value{{t: TypeNumber, s: \"1\"}}},\n\t\t{`{\"a\": [1, 2, 3]}`, []string{\"a\", \"2\"}, []*Value{{t: TypeNumber, s: \"3\"}}},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tv.o = nil\n\t\tv.a = nil\n\t\tv.s = \"\"\n\t\tv.t = TypeNull\n\n\t\tif _, err := (\u0026v).Parse(tc.input); err != nil {\n\t\t\tt.Fatalf(\"Test case %d: failed to parse JSON: %v\", i+1, err)\n\t\t}\n\n\t\tresult := v.GetArray(tc.keys...)\n\t\tif len(result) != len(tc.expected) {\n\t\t\tt.Errorf(\"Test case %d: expected array length %d, got %d\", i+1, len(tc.expected), len(result))\n\t\t}\n\t\tfor j := 0; j \u003c len(result); j++ {\n\t\t\tif result[j].Type() != tc.expected[j].Type() || result[j].String() != tc.expected[j].String() {\n\t\t\t\tt.Errorf(\"Test case %d: element %d mismatch, expected %v, got %v\", i+1, j+1, tc.expected[j], result[j])\n\t\t\t}\n\t\t}\n\t}\n}","5d50de60db0396b2d0bd0253f72fb162":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Empty string\n\t\t{\"\", nil, \"\", fmt.Errorf(\"cannot parse empty string\")},\n\t\t// Invalid JSON\n\t\t{\"{\", nil, \"{\", fmt.Errorf(\"cannot parse object: unexpected EOF\")},\n\t\t// Object\n\t\t{`{\"foo\":\"bar\"}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: typeRawString, s: \"bar\"}}}}}, \"\", nil},\n\t\t// Array\n\t\t{`[1,2,3]`, \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}}, \"\", nil},\n\t\t// String\n\t\t{`\"hello\"`, \u0026Value{t: typeRawString, s: \"hello\"}, \"\", nil},\n\t\t// True\n\t\t{\"true\", valueTrue, \"\", nil},\n\t\t// False\n\t\t{\"false\", valueFalse, \"\", nil},\n\t\t// Null\n\t\t{\"null\", valueNull, \"\", nil},\n\t\t// Number\n\t\t{\"123\", \u0026Value{t: TypeNumber, s: \"123\"}, \"\", nil},\n\t\t// NaN\n\t\t{\"NaN\", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"\", nil},\n\t\t// Trailing whitespace\n\t\t{\"true \", valueTrue, \" \", nil},\n\t\t// Nested structures\n\t\t{`{\"foo\":[1,{\"bar\":\"baz\"}]}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeObject, o: Object{kvs: []kv{{k: \"bar\", v: \u0026Value{t: typeRawString, s: \"baz\"}}}}}}}}}}}, \"\", nil},\n\t}\n\n\tc := \u0026cache{}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tgot, tail, err := parseValue(tt.input, c, 0)\n\t\t\tif (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"parseValue(%q) error mismatch: got %v, want %v\", tt.input, err, tt.err)\n\t\t\t}\n\t\t\tif got != nil \u0026\u0026 tt.want != nil \u0026\u0026 got.t != tt.want.t {\n\t\t\t\tt.Errorf(\"parseValue(%q) type mismatch: got %v, want %v\", tt.input, got.t, tt.want.t)\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"parseValue(%q) tail mismatch: got %q, want %q\", tt.input, tail, tt.tail)\n\t\t\t}\n\t\t\t// Add more assertions to compare got and tt.want based on their types\n\t\t})\n\t}\n}\n","5d9ba318f485a038f98ce79add0f925e":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantN    string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Empty input.\n\t\t{\"\", \"\", \"\", nil},\n\n\t\t// Valid numbers.\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"123.456\", \"123.456\", \"\", nil},\n\t\t{\"1.2e3\", \"1.2e3\", \"\", nil},\n\t\t{\"1.2E-3\", \"1.2E-3\", \"\", nil},\n\t\t{\"+123\", \"+123\", \"\", nil},\n\n\t\t// Valid numbers with trailing characters.\n\t\t{\"123 \", \"123\", \" \", nil},\n\t\t{\"123a\", \"123\", \"a\", nil},\n\t\t{\"123.456,\", \"123.456\", \",\", nil},\n\n\t\t// Invalid numbers.\n\t\t{\"a123\", \"\", \"a123\", fmt.Errorf(`unexpected char: \"a\"`)},\n\t\t{\"+a123\", \"\", \"+a123\", fmt.Errorf(`unexpected char: \"+\"`)},\n\t\t{\"+ 123\", \"\", \"+ 123\", fmt.Errorf(`unexpected char: \"+\"`)},\n\n\t\t// Special values.\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"+inf\", \"+inf\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"inf \", \"inf\", \" \", nil},\n\t\t{\"inf,\", \"inf\", \",\", nil},\n\t\t{\"in\", \"\", \"in\", fmt.Errorf(`unexpected char: \"i\"`)},\n\t\t{\"+in\", \"\", \"+in\", fmt.Errorf(`unexpected char: \"+\"`)},\n\t\t{\"-in\", \"\", \"-in\", fmt.Errorf(`unexpected char: \"-\"`)},\n\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"+nan\", \"+nan\", \"\", nil},\n\t\t{\"-nan\", \"-nan\", \"\", nil},\n\t\t{\"nan}\", \"nan\", \"}\", nil},\n\t\t{\"na\", \"\", \"na\", fmt.Errorf(`unexpected char: \"n\"`)},\n\t\t{\"+na\", \"\", \"+na\", fmt.Errorf(`unexpected char: \"+\"`)},\n\t\t{\"-na\", \"\", \"-na\", fmt.Errorf(`unexpected char: \"-\"`)},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tgotN, gotTail, gotErr := parseRawNumber(tt.input)\n\t\t\tif gotN != tt.wantN {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got number = %q, want %q\", tt.input, gotN, tt.wantN)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got tail = %q, want %q\", tt.input, gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif gotErr == nil \u0026\u0026 tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got no error, want %v\", tt.input, tt.wantErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr == nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got error = %v, want no error\", tt.input, gotErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got error = %v, want %v\", tt.input, gotErr, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","5da18abcb95e96380f9c8fd275d622fd":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic escapes\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\t`, \"\\t\"},\n\t\t{`\\\\`, `\\`},\n\t\t{`\\/`, `/`},\n\t\t{`\\\"`, `\"`},\n\t\t{`\\b`, \"\\b\"},\n\t\t{`\\f`, \"\\f\"},\n\t\t{`\\r`, \"\\r\"},\n\n\t\t// Unicode escapes\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A0`, \"\\u00A0\"},\n\t\t{`\\u20AC`, \"\\u20AC\"},\n\t\t{`\\uD83D\\uDE02`, \"\\U0001F602\"}, // Surrogate pair\n\n\t\t// Invalid escapes\n\t\t{`\\z`, `\\z`},\n\t\t{`\\u002`, `\\u002`},\n\t\t{`\\uD800`, `\\uD800`}, // Unpaired surrogate\n\t\t{`\\uDFFF`, `\\uDFFF`}, // Unpaired surrogate\n\n\t\t// Mixed escapes\n\t\t{`Hello\\tworld\\n`, \"Hello\\tworld\\n\"},\n\t\t{`C:\\\\Users\\\\John\\\\Doe`, `C:\\Users\\John\\Doe`},\n\t\t{`\\\"quoted text\\\"`, `\"quoted text\"`},\n\n\t\t// No escapes\n\t\t{`Hello, world!`, `Hello, world!`},\n\t\t{`No escapes here`, `No escapes here`},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}\n","5ec1cf68f235fec45dbd1b9bba550fd2":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic strings\n\t\t{\"hello\", \"hello\"},\n\t\t{\"world\", \"world\"},\n\n\t\t// Escaped characters\n\t\t{`\\\"`, `\"`},\n\t\t{`\\\\`, `\\`},\n\t\t{`\\/`, `/`},\n\t\t{`\\b`, \"\\b\"},\n\t\t{`\\f`, \"\\f\"},\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\r`, \"\\r\"},\n\t\t{`\\t`, \"\\t\"},\n\n\t\t// Unicode escape sequences\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A9`, \"¬©\"},\n\t\t{`\\u20AC`, \"‚Ç¨\"},\n\t\t{`\\uD83D\\uDE02`, \"üòÇ\"}, // Surrogate pair\n\n\t\t// Invalid escape sequences\n\t\t{`\\u`, `\\u`},\n\t\t{`\\u002`, `\\u002`},\n\t\t{`\\uD83D`, `\\uD83D`},\n\t\t{`\\uD83D\\u`, `\\uD83D\\u`},\n\n\t\t// Mixed strings\n\t\t{`hello\\tworld`, \"hello\\tworld\"},\n\t\t{`\\u00A9 2023`, \"¬© 2023\"},\n\t\t{`Invalid escape: \\x`, `Invalid escape: \\x`},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}\n","5f00dfe65b2cd06b1edd54aff1a38985":"package fastjson\n\nimport \"testing\"\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tt    Type\n\t\twant string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\tfor i, tt := range tests {\n\t\tif got := tt.t.String(); got != tt.want {\n\t\t\tt.Errorf(\"test[%d] - String() = %v, want %v\", i, got, tt.want)\n\t\t}\n\t}\n}","5f2d638daec8a7a43d52ea4a7cee1688":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Type(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant Type\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.Type(); got != tt.want {\n\t\t\t\tt.Errorf(\"Value.Type() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","5f7e1b408299a5feceba48dcfcc3c3e6":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  string\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Basic cases\n\t\t{`\"foo\"bar`, `foo`, `bar`, nil},\n\t\t{`\"fo\\\"o\"bar`, `fo\"o`, `bar`, nil},\n\t\t{`\"foo\"`, `foo`, ``, nil},\n\t\t{`\"\"bar`, ``, `bar`, nil},\n\n\t\t// Escaped quotes\n\t\t{`\"foo\\\\\"bar\"baz`, `foo\\`, `bar\"baz`, nil},\n\t\t{`\"foo\\\\\\\\\"bar\"baz`, `foo\\\\bar`, `baz`, nil},\n\t\t{`\"foo\\\\\\\"\"bar\"baz`, `foo\\\"bar`, `baz`, nil},\n\n\t\t// Missing closing quote\n\t\t{`\"foo`, ``, ``, fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo\\`, ``, ``, fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo\\\\\"`, ``, ``, fmt.Errorf(`missing closing '\"'`)},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tgot, tail, err := parseRawString(tt.input)\n\t\t\tif got != tt.want || tail != tt.tail || (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = (%q, %q, %v), want (%q, %q, %v)\", tt.input, got, tail, err, tt.want, tt.tail, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}","60373dd5eb43b7806c0c2d73a68b5a1f":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Empty string\n\t\t{\"\", nil, \"\", fmt.Errorf(\"cannot parse empty string\")},\n\t\t// Invalid JSON\n\t\t{\"{invalid}\", nil, \"\", fmt.Errorf(\"cannot parse object: missing '}'\")},\n\t\t// Simple object\n\t\t{`{\"key\": \"value\"}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{t: typeRawString, s: \"value\"}}}}}, \"\", nil},\n\t\t// Nested object\n\t\t{`{\"key\": {\"nested\": \"value\"}}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"nested\", v: \u0026Value{t: typeRawString, s: \"value\"}}}}}}}}}, \"\", nil},\n\t\t// Simple array\n\t\t{`[1, \"two\", true]`, \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: typeRawString, s: \"two\"}, {t: TypeTrue}}}, \"\", nil},\n\t\t// String with escaped characters\n\t\t{`\"hello\\tworld\\n\"`, \u0026Value{t: typeRawString, s: \"hello\\tworld\\n\"}, \"\", nil},\n\t\t// True boolean\n\t\t{\"true\", valueTrue, \"\", nil},\n\t\t// False boolean\n\t\t{\"false\", valueFalse, \"\", nil},\n\t\t// Null value\n\t\t{\"null\", valueNull, \"\", nil},\n\t\t// Number\n\t\t{\"12345\", \u0026Value{t: TypeNumber, s: \"12345\"}, \"\", nil},\n\t\t// Number with trailing whitespace\n\t\t{\"12345 \", \u0026Value{t: TypeNumber, s: \"12345\"}, \" \", nil},\n\t\t// NaN\n\t\t{\"NaN\", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"\", nil},\n\t\t// Trailing comma in object\n\t\t{`{\"key\": \"value\",}`, nil, \"\", fmt.Errorf(\"cannot parse object: trailing comma\")},\n\t}\n\n\tc := \u0026cache{}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tgot, tail, err := parseValue(tt.input, c, 0)\n\t\t\tif fmt.Sprintf(\"%v\", err) != fmt.Sprintf(\"%v\", tt.err) {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, want %v\", tt.input, err, tt.err)\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"parseValue(%q) tail = %q, want %q\", tt.input, tail, tt.tail)\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", tt.input, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.t == typeRawString {\n\t\treturn v1.s == v2.s\n\t}\n\tif v1.t == TypeNumber {\n\t\treturn v1.s == v2.s\n\t}\n\tif v1.t == TypeObject {\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\tif v1.t == TypeArray {\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\treturn false\n}","61b554d4a71f6eec4c4a774e11524106":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ts     string\n\t\terr   error\n\t}{\n\t\t// Empty object\n\t\t{\n\t\t\tinput: `{}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Single key-value pair\n\t\t{\n\t\t\tinput: `{\"key\": \"value\"}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: \u0026Value{t: TypeString, s: \"value\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Multiple key-value pairs\n\t\t{\n\t\t\tinput: `{\"key1\": \"value1\", \"key2\": 123, \"key3\": true}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t\t{k: \"key3\", v: \u0026Value{t: TypeTrue}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Nested object\n\t\t{\n\t\t\tinput: `{\"key1\": {\"key2\": \"value2\"}, \"key3\": \"value3\"}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{k: \"key3\", v: \u0026Value{t: TypeString, s: \"value3\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Missing closing brace\n\t\t{\n\t\t\tinput: `{\"key\": \"value\"`,\n\t\t\twant:  nil,\n\t\t\ts:     `{\"key\": \"value\"`,\n\t\t\terr:   fmt.Errorf(`missing '}'`),\n\t\t},\n\t\t// Invalid key\n\t\t{\n\t\t\tinput: `{key: \"value\"}`,\n\t\t\twant:  nil,\n\t\t\ts:     `{key: \"value\"}`,\n\t\t\terr:   fmt.Errorf(`cannot find opening '\"\" for object key`),\n\t\t},\n\t\t// Missing colon\n\t\t{\n\t\t\tinput: `{\"key\" \"value\"}`,\n\t\t\twant:  nil,\n\t\t\ts:     `\"value\"}`,\n\t\t\terr:   fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t\t// Missing comma\n\t\t{\n\t\t\tinput: `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twant:  nil,\n\t\t\ts:     `\"key2\": \"value2\"}`,\n\t\t\terr:   fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseObject(tt.input, c, 0)\n\t\t\tif fmt.Sprintf(\"%v\", err) != fmt.Sprintf(\"%v\", tt.err) {\n\t\t\t\tt.Errorf(\"parseObject(%s) error mismatch: got %v, want %v\", tt.input, err, tt.err)\n\t\t\t}\n\t\t\tif s != tt.s {\n\t\t\t\tt.Errorf(\"parseObject(%s) remaining string mismatch: got %q, want %q\", tt.input, s, tt.s)\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject(%s) value mismatch:\\ngot  %+v\\nwant %+v\", tt.input, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber, TypeTrue, TypeFalse:\n\t\treturn v1.s == v2.s\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n","61c8116723a685d16e3b316f3a1002d9":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic escapes\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\t`, \"\\t\"},\n\t\t{`\\\\`, \"\\\\\"},\n\t\t{`\\\"`, \"\\\"\"},\n\t\t{`\\/`, \"/\"},\n\t\t{`\\b`, \"\\b\"},\n\t\t{`\\f`, \"\\f\"},\n\t\t{`\\r`, \"\\r\"},\n\n\t\t// Unicode escapes\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A0`, \"\\u00A0\"},\n\t\t{`\\u20AC`, \"\\u20AC\"},\n\t\t{`\\uD83D\\uDE02`, \"\\U0001F602\"}, // Surrogate pair\n\n\t\t// Invalid escapes\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\uD800`, `\\uD800`}, // Unpaired surrogate\n\t\t{`\\uDFFF`, `\\uDFFF`}, // Unpaired surrogate\n\n\t\t// Mixed escapes\n\t\t{`Hello\\tworld\\n`, \"Hello\\tworld\\n\"},\n\t\t{`C:\\\\Program Files\\\\`, `C:\\Program Files\\`},\n\t\t{`{\"key\": \"value\"}`, `{\"key\": \"value\"}`},\n\n\t\t// No escapes\n\t\t{`Hello, world!`, `Hello, world!`},\n\t\t{`This is a string.`, `This is a string.`},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}\n","61fabe52f811641e8d99fbb89579e7fe":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput       string\n\t\twantValue   *Value\n\t\twantTail    string\n\t\twantErr     bool\n\t\twantErrText string\n\t}{\n\t\t// Empty input\n\t\t{\"\", nil, \"\", true, \"cannot parse empty string\"},\n\n\t\t// Object\n\t\t{\"{ \\\"key\\\": \\\"value\\\" }\", \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{t: typeRawString, s: \"value\"}}}}}}, \"\", false, \"\"},\n\t\t// Nested object\n\t\t{\"{ \\\"key\\\": { \\\"nested\\\": \\\"value\\\" } }\", \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"nested\", v: \u0026Value{t: typeRawString, s: \"value\"}}}}}}}}}}, \"\", false, \"\"},\n\n\t\t// Array\n\t\t{\"[1, 2, 3]\", \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}}, \"\", false, \"\"},\n\t\t// Nested array\n\t\t{\"[1, [2, 3]]\", \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeArray, a: []*Value{{t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}}}}, \"\", false, \"\"},\n\n\t\t// String\n\t\t{`\"value\"`, \u0026Value{t: typeRawString, s: \"value\"}, \"\", false, \"\"},\n\t\t// Escaped string\n\t\t{`\"va\\\\lue\\\"\"`, \u0026Value{t: typeRawString, s: `va\\lue\"`}, \"\", false, \"\"},\n\n\t\t// True\n\t\t{\"true\", valueTrue, \"\", false, \"\"},\n\n\t\t// False\n\t\t{\"false\", valueFalse, \"\", false, \"\"},\n\n\t\t// Null\n\t\t{\"null\", valueNull, \"\", false, \"\"},\n\n\t\t// Number\n\t\t{\"123\", \u0026Value{t: TypeNumber, s: \"123\"}, \"\", false, \"\"},\n\t\t{\"-123.45\", \u0026Value{t: TypeNumber, s: \"-123.45\"}, \"\", false, \"\"},\n\t\t{\"1.23e4\", \u0026Value{t: TypeNumber, s: \"1.23e4\"}, \"\", false, \"\"},\n\n\t\t// NaN\n\t\t{\"NaN\", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"\", false, \"\"},\n\n\t\t// Invalid input\n\t\t{\"invalid\", nil, \"invalid\", true, \"unexpected value found: \\\"invalid\\\"\"},\n\t}\n\n\tc := \u0026cache{}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tgotValue, gotTail, gotErr := parseValue(tt.input, c, 0)\n\n\t\t\tif (gotErr != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", gotErr, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotErr != nil \u0026\u0026 tt.wantErrText != \"\" \u0026\u0026 gotErr.Error() != tt.wantErrText {\n\t\t\t\tt.Errorf(\"parseValue() error text = %v, want error text %v\", gotErr.Error(), tt.wantErrText)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseValue() gotTail = %v, want %v\", gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif !equal(gotValue, tt.wantValue) {\n\t\t\t\tt.Errorf(\"parseValue() gotValue = %v, want %v\", gotValue, tt.wantValue)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equal(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase typeRawString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equal(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equal(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\treturn true\n\t}\n}\n","621369ec062ba27fe0667dfb122818cd":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetObject(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tjson  string\n\t\tkeys  []string\n\t\twant  *Object\n\t\twant1 bool\n\t}{\n\t\t{\n\t\t\tname:  \"simple\",\n\t\t\tjson:  `{\"foo\": {\"bar\": 123}}`,\n\t\t\tkeys:  []string{\"foo\"},\n\t\t\twant:  \u0026Object{kvs: []kv{{k: \"bar\", v: \u0026Value{t: TypeNumber, s: \"123\"}}}},\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"arrayIndex\",\n\t\t\tjson:  `{\"foo\": [{\"bar\": 123}]}`,\n\t\t\tkeys:  []string{\"foo\", \"0\"},\n\t\t\twant:  \u0026Object{kvs: []kv{{k: \"bar\", v: \u0026Value{t: TypeNumber, s: \"123\"}}}},\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"nonExistingKey\",\n\t\t\tjson:  `{\"foo\": {\"bar\": 123}}`,\n\t\t\tkeys:  []string{\"baz\"},\n\t\t\twant:  nil,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"invalidValueType\",\n\t\t\tjson:  `{\"foo\": 123}`,\n\t\t\tkeys:  []string{\"foo\"},\n\t\t\twant:  nil,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"emptyInput\",\n\t\t\tjson:  ``,\n\t\t\tkeys:  []string{\"foo\"},\n\t\t\twant:  nil,\n\t\t\twant1: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv, err := ParseBytes([]byte(tt.json))\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"ParseBytes() error = %v\", err)\n\t\t\t}\n\t\t\tgot := v.GetObject(tt.keys...)\n\t\t\tif got != nil \u0026\u0026 tt.want == nil {\n\t\t\t\tt.Errorf(\"GetObject() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got == nil \u0026\u0026 tt.want != nil {\n\t\t\t\tt.Errorf(\"GetObject() = %v, want %v\", got, tt.want)\n\t\t\t}\n\n\t\t\tif got != nil \u0026\u0026 tt.want != nil {\n\t\t\t\tif len(got.kvs) != len(tt.want.kvs) {\n\t\t\t\t\tt.Errorf(\"GetObject() = %v, want %v\", got, tt.want)\n\t\t\t\t} else {\n\t\t\t\t\tfor i := range got.kvs {\n\t\t\t\t\t\tif got.kvs[i].k != tt.want.kvs[i].k {\n\t\t\t\t\t\t\tt.Errorf(\"GetObject() = %v, want %v\", got, tt.want)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif got.kvs[i].v.t != tt.want.kvs[i].v.t {\n\t\t\t\t\t\t\tt.Errorf(\"GetObject() = %v, want %v\", got, tt.want)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif got.kvs[i].v.s != tt.want.kvs[i].v.s {\n\t\t\t\t\t\t\tt.Errorf(\"GetObject() = %v, want %v\", got, tt.want)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","63402e102f86c86928aec807fb0479ab":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput  string\n\t\tns     string\n\t\tremain string\n\t\terr    error\n\t}{\n\t\t// Valid numbers\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"123.456\", \"123.456\", \"\", nil},\n\t\t{\"1.2e3\", \"1.2e3\", \"\", nil},\n\t\t{\"1.2E-3\", \"1.2E-3\", \"\", nil},\n\t\t{\"+123\", \"+123\", \"\", nil},\n\n\t\t// Valid numbers with trailing characters\n\t\t{\"123abc\", \"123\", \"abc\", nil},\n\t\t{\"-123def\", \"-123\", \"def\", nil},\n\t\t{\"123.456xyz\", \"123.456\", \"xyz\", nil},\n\n\t\t// Valid inf and nan\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"+inf\", \"+inf\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"InF\", \"InF\", \"\", nil},\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"+nan\", \"+nan\", \"\", nil},\n\t\t{\"-nan\", \"-nan\", \"\", nil},\n\t\t{\"nAn\", \"nAn\", \"\", nil},\n\t\t{\"infabc\", \"inf\", \"abc\", nil},\n\t\t{\"nandef\", \"nan\", \"def\", nil},\n\n\t\t// Invalid numbers\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t\t{\"a\", \"\", \"a\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\"-\", \"\", \"-\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t\t{\".\", \"\", \".\", fmt.Errorf(\"unexpected char: %q\", \".\")},\n\t\t{\"1.2e\", \"1.2\", \"e\", nil},\n\t\t{\"+abc\", \"\", \"+abc\", fmt.Errorf(\"unexpected char: %q\", \"+a\")},\n\t\t{\"-def\", \"\", \"-def\", fmt.Errorf(\"unexpected char: %q\", \"-d\")},\n\n\t\t// Invalid inf and nan\n\t\t{\"in\", \"\", \"in\", fmt.Errorf(\"unexpected char: %q\", \"i\")},\n\t\t{\"na\", \"\", \"na\", fmt.Errorf(\"unexpected char: %q\", \"n\")},\n\t\t{\"+i\", \"\", \"+i\", fmt.Errorf(\"unexpected char: %q\", \"+i\")},\n\t\t{\"-n\", \"\", \"-n\", fmt.Errorf(\"unexpected char: %q\", \"-n\")},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tns, remain, err := parseRawNumber(tt.input)\n\t\t\tif tt.err != nil {\n\t\t\t\tif err == nil || err.Error() != tt.err.Error() {\n\t\t\t\t\tt.Errorf(\"Expected error %v, but got %v\", tt.err, err)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ns != tt.ns {\n\t\t\t\tt.Errorf(\"Expected ns %q, but got %q\", tt.ns, ns)\n\t\t\t}\n\t\t\tif remain != tt.remain {\n\t\t\t\tt.Errorf(\"Expected remain %q, but got %q\", tt.remain, remain)\n\t\t\t}\n\t\t})\n\t}\n}","638aa3553dd719f069b9f6dffc648994":"package fastjson\n\nimport \"testing\"\n\nfunc TestObject_reset(t *testing.T) {\n\to := \u0026Object{\n\t\tkvs: []kv{\n\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t},\n\t\tkeysUnescaped: true,\n\t}\n\n\to.reset()\n\n\tif len(o.kvs) != 0 {\n\t\tt.Errorf(\"Expected kvs to be empty after reset, got %v\", o.kvs)\n\t}\n\n\tif o.keysUnescaped != false {\n\t\tt.Errorf(\"Expected keysUnescaped to be false after reset, got %v\", o.keysUnescaped)\n\t}\n}\n","63cc792ba38391a1dc1494e0e4f7ffab":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ts     string\n\t\terr   error\n\t}{\n\t\t// Add test cases here\n\t\t{\n\t\t\tinput: `{\"key\": \"value\"}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: \u0026Value{t: TypeString, s: \"value\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tinput: `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Add more test cases for different scenarios\n\t}\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test case %d\", i+1), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseObject(tc.input, c, 0)\n\n\t\t\tif tc.err != nil {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"Expected error for input '%s', but got nil\", tc.input)\n\t\t\t\t} else if err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"Expected error '%s', but got '%s'\", tc.err.Error(), err.Error())\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"Unexpected error for input '%s': %s\", tc.input, err.Error())\n\t\t\t\t} else if s != tc.s {\n\t\t\t\t\tt.Errorf(\"Expected remaining string '%s', but got '%s'\", tc.s, s)\n\t\t\t\t} else if !equalValues(got, tc.want) {\n\t\t\t\t\tt.Errorf(\"Expected value:\\n%+v\\nbut got:\\n%+v\", tc.want, got)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeObject:\n\t\tif v1.o.Len() != v2.o.Len() {\n\t\t\treturn false\n\t\t}\n\t\tfor i := 0; i \u003c v1.o.Len(); i++ {\n\t\t\tkv1 := v1.o.kvs[i]\n\t\t\tkv2 := v2.o.kvs[i]\n\t\t\tif kv1.k != kv2.k || !equalValues(kv1.v, kv2.v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t// Add cases for other types as needed\n\tdefault:\n\t\treturn false\n\t}\n}","63d456ce66116ca7c6f98bdfaf7cb763":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantNum  string\n\t\twantRest string\n\t\twantErr  error\n\t}{\n\t\t// Valid numbers\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"+123\", \"+123\", \"\", nil},\n\t\t{\"123.456\", \"123.456\", \"\", nil},\n\t\t{\"1.2e3\", \"1.2e3\", \"\", nil},\n\t\t{\"1.2E3\", \"1.2E3\", \"\", nil},\n\t\t{\"1.2e+3\", \"1.2e+3\", \"\", nil},\n\t\t{\"1.2e-3\", \"1.2e-3\", \"\", nil},\n\n\t\t// Valid numbers with trailing characters\n\t\t{\"123a\", \"123\", \"a\", nil},\n\t\t{\"-123b\", \"-123\", \"b\", nil},\n\t\t{\"123.456c\", \"123.456\", \"c\", nil},\n\n\t\t// Invalid numbers\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t\t{\"a\", \"\", \"a\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\"+a\", \"\", \"+a\", fmt.Errorf(\"unexpected char: %q\", \"+a\")},\n\t\t{\"-b\", \"\", \"-b\", fmt.Errorf(\"unexpected char: %q\", \"-b\")},\n\t\t{\"1.2e\", \"1.2\", \"e\", nil},\n\n\t\t// Special cases: \"inf\", \"nan\"\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"+inf\", \"+inf\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"+nan\", \"\", \"+nan\", fmt.Errorf(\"unexpected char: %q\", \"+n\")},\n\t\t{\"-nan\", \"\", \"-nan\", fmt.Errorf(\"unexpected char: %q\", \"-n\")},\n\t\t{\"infin\", \"inf\", \"in\", nil},\n\t\t{\"nanx\", \"nan\", \"x\", nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d:%s\", i, tt.input), func(t *testing.T) {\n\t\t\tgotNum, gotRest, gotErr := parseRawNumber(tt.input)\n\t\t\tif gotNum != tt.wantNum {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) num = %q, want %q\", tt.input, gotNum, tt.wantNum)\n\t\t\t}\n\t\t\tif gotRest != tt.wantRest {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) rest = %q, want %q\", tt.input, gotRest, tt.wantRest)\n\t\t\t}\n\t\t\tif gotErr == nil \u0026\u0026 tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) err = nil, want %v\", tt.input, tt.wantErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr == nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) err = %v, want nil\", tt.input, gotErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) err = %v, want %v\", tt.input, gotErr, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","6430a06526b6fe0eb984404080988e8a":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey string\n\t\ttail string\n\t\terr error\n\t}{\n\t\t// Basic cases\n\t\t{`\"foo\"bar`, \"foo\", \"bar\", nil},\n\t\t{`\"foo\" bar`, \"foo\", \" bar\", nil},\n\t\t{`\"foo\"  bar`, \"foo\", \"  bar\", nil},\n\t\t{`\"foo\"`, \"foo\", \"\", nil},\n\n\t\t// Escaped quotes\n\t\t{`\"fo\\\"o\"bar`, `fo\"o`, \"bar\", nil},\n\t\t{`\"fo\\\\\"o\"bar`, `fo\\\"o`, \"bar\", nil},\n\t\t{`\"fo\\\\\\\\\"o\"bar`, `fo\\\\\"o`, \"bar\", nil},\n\t\t{`\"fo\\\\\\\"o\"bar`, `fo\\\"o`, \"bar\", nil},\n\n\t\t// Missing closing quote\n\t\t{`\"foo`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"fo\\\"o`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\n\t\t// Empty strings\n\t\t{`\"\"bar`, \"\", \"bar\", nil},\n\t\t{`\"\" bar`, \"\", \" bar\", nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d:%s\", i, tt.input), func(t *testing.T) {\n\t\t\tkey, tail, err := parseRawString(tt.input)\n\t\t\tif key != tt.key || tail != tt.tail  {\n\t\t\t\tt.Errorf(\"Test[%d]: Expected: key='%s', tail='%s', got: key='%s', tail='%s'\", i, tt.key, tt.tail, key, tail)\n\t\t\t}\n\t\t\tif (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err == nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"Test[%d]: Error mismatch. Expected: %v, got: %v\", i, tt.err, err)\n\t\t\t}\n\t\t})\n\t}\n}\n","645caff14b02a94bc8655b0b42b8bae0":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  string\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Unescaped strings.\n\t\t{`\"foo\"bar`, `foo`, `bar`, nil},\n\t\t{`\"foo\" bar`, `foo`, ` bar`, nil},\n\t\t{`\"foo\"  bar`, `foo`, `  bar`, nil},\n\n\t\t// Escaped strings.\n\t\t{`\"fo\\o\"bar`, `fo\\o`, `bar`, nil},\n\t\t{`\"foo\\\\\"bar`, `foo\\\\`, `bar`, nil},\n\t\t{`\"foo\\\\\\\"\"bar`, `foo\\\\\\\"\"`, `bar`, nil},\n\t\t{`\"foo\\\\\\\\\\\"\"bar`, `foo\\\\\\\\\\\"`, `bar`, nil},\n\n\t\t// Invalid strings.\n\t\t{`\"foo`, ``, ``, fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo\"bar\"`, ``, ``, fmt.Errorf(`missing closing '\"'`)},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tgot, tail, err := parseRawString(tt.input)\n\t\t\tif got != tt.want || tail != tt.tail || !equalError(err, tt.err) {\n\t\t\t\tt.Errorf(\"input: %q, got (%q, %q, %v), want (%q, %q, %v)\", tt.input, got, tail, err, tt.want, tt.tail, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// equalError reports whether errors a and b are considered equal.\n// They're equal if both are nil, or both are not nil and a.Error() == b.Error().\nfunc equalError(a, b error) bool {\n\treturn a == nil \u0026\u0026 b == nil || a != nil \u0026\u0026 b != nil \u0026\u0026 a.Error() == b.Error()\n}\n","649e83338fd51e1621a05feef82da083":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic escapes\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\t`, \"\\t\"},\n\t\t{`\\\\`, \"\\\\\"},\n\t\t{`\\\"`, \"\\\"\"},\n\t\t{`\\/`, \"/\"},\n\n\t\t// Unicode escapes\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A0`, \"\\u00A0\"},\n\t\t{`\\uFFFF`, \"\\uFFFF\"},\n\n\t\t// Surrogate pairs\n\t\t{`\\uD83D\\uDE01`, \"\\U0001F601\"},\n\n\t\t// Invalid escapes\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\uD800`, `\\uD800`},\n\t\t{`\\uD800\\u`, `\\uD800\\u`},\n\n\t\t// Mixed content\n\t\t{`Hello\\tworld\\n`, \"Hello\\tworld\\n\"},\n\t\t{`\\u0041\\u0020string\\twith\\nescapes`, \"A string\\twith\\nescapes\"},\n\n\t\t// Empty string\n\t\t{``, \"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}\n","6548e1529105cef09542af737bec500c":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Empty string\n\t\t{\"\", nil, \"\", fmt.Errorf(\"cannot parse empty string\")},\n\t\t// Invalid JSON\n\t\t{\"{\", nil, \"{\", fmt.Errorf(\"cannot parse object: missing '}'\")},\n\t\t// Object\n\t\t{`{\"foo\":\"bar\"}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: typeRawString, s: \"bar\"}}}}}, \"\", nil},\n\t\t// Array\n\t\t{`[1,2,3]`, \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}}, \"\", nil},\n\t\t// String\n\t\t{`\"hello\"`, \u0026Value{t: typeRawString, s: \"hello\"}, \"\", nil},\n\t\t// True\n\t\t{\"true\", valueTrue, \"\", nil},\n\t\t// False\n\t\t{\"false\", valueFalse, \"\", nil},\n\t\t// Null\n\t\t{\"null\", valueNull, \"\", nil},\n\t\t// Number\n\t\t{\"123\", \u0026Value{t: TypeNumber, s: \"123\"}, \"\", nil},\n\t\t// NaN\n\t\t{\"NaN\", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"\", nil},\n\t\t// Number with tail\n\t\t{\"123 \", \u0026Value{t: TypeNumber, s: \"123\"}, \" \", nil},\n\t\t// Trailing whitespace\n\t\t{\" true \", valueTrue, \" \", nil},\n\t}\n\n\tc := \u0026cache{}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tgot, tail, err := parseValue(tt.input, c, 0)\n\t\t\tif (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, wantErr %v\", tt.input, err, tt.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", tt.input, got, tt.want)\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"parseValue(%q) tail = %q, want %q\", tt.input, tail, tt.tail)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.t == typeRawString {\n\t\treturn v1.s == v2.s\n\t}\n\tif v1.t == TypeNumber {\n\t\treturn v1.s == v2.s\n\t}\n\tif v1.t == TypeObject {\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\tif v1.t == TypeArray {\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\treturn false\n}\n","65d4ee93a3ee3af7d8087f02220faf12":"package fastjson\n\nimport \"testing\"\n\nfunc TestObject_getKV(t *testing.T) {\n\to := Object{}\n\n\t// Test adding a kv when the capacity is less than the length\n\tkv1 := o.getKV()\n\tkv1.k = \"key1\"\n\tkv1.v = \u0026Value{t: TypeString, s: \"value1\"}\n\tif len(o.kvs) != 1 || o.kvs[0].k != \"key1\" || o.kvs[0].v.s != \"value1\" {\n\t\tt.Errorf(\"Failed to add kv when capacity is less than length\")\n\t}\n\n\t// Test adding a kv when the capacity is greater than the length\n\to.kvs = append(o.kvs, kv{}, kv{})\n\tkv2 := o.getKV()\n\tkv2.k = \"key2\"\n\tkv2.v = \u0026Value{t: TypeNumber, s: \"123\"}\n\tif len(o.kvs) != 3 || o.kvs[2].k != \"key2\" || o.kvs[2].v.s != \"123\" {\n\t\tt.Errorf(\"Failed to add kv when capacity is greater than length\")\n\t}\n}","65fc2fe3ed6e0aadf459c8a6722c7911":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCache_getValue(t *testing.T) {\n\tt.Run(\"empty cache\", func(t *testing.T) {\n\t\tc := \u0026cache{}\n\t\tv := c.getValue()\n\n\t\tif v == nil {\n\t\t\tt.Fatal(\"Expected a non-nil value\")\n\t\t}\n\n\t\tif len(c.vs) != 1 {\n\t\t\tt.Errorf(\"Expected cache length to be 1, got %d\", len(c.vs))\n\t\t}\n\t})\n\n\tt.Run(\"cache with existing values\", func(t *testing.T) {\n\t\tc := \u0026cache{\n\t\t\tvs: make([]Value, 10),\n\t\t}\n\t\tv := c.getValue()\n\n\t\tif v == nil {\n\t\t\tt.Fatal(\"Expected a non-nil value\")\n\t\t}\n\n\t\tif len(c.vs) != 11 {\n\t\t\tt.Errorf(\"Expected cache length to be 11, got %d\", len(c.vs))\n\t\t}\n\t})\n\n\tt.Run(\"cache with extra capacity\", func(t *testing.T) {\n\t\tc := \u0026cache{\n\t\t\tvs: make([]Value, 10, 20),\n\t\t}\n\t\tv := c.getValue()\n\n\t\tif v == nil {\n\t\t\tt.Fatal(\"Expected a non-nil value\")\n\t\t}\n\n\t\tif len(c.vs) != 11 {\n\t\t\tt.Errorf(\"Expected cache length to be 11, got %d\", len(c.vs))\n\t\t}\n\n\t\tif cap(c.vs) != 20 {\n\t\t\tt.Errorf(\"Expected cache capacity to be 20, got %d\", cap(c.vs))\n\t\t}\n\t})\n}","667c7903ac2f443de1f8b57d78b53346":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Empty string\n\t\t{\"\", nil, \"\", fmt.Errorf(\"cannot parse empty string\")},\n\t\t// Invalid JSON\n\t\t{\"{\", nil, \"{\", fmt.Errorf(\"cannot parse object: missing '}'\")},\n\t\t// Object\n\t\t{`{\"foo\":\"bar\"}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: typeRawString, s: \"bar\"}}}}}, \"\", nil},\n\t\t// Array\n\t\t{`[1,2,3]`, \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}}, \"\", nil},\n\t\t// String\n\t\t{`\"hello\"`, \u0026Value{t: typeRawString, s: \"hello\"}, \"\", nil},\n\t\t// True\n\t\t{\"true\", valueTrue, \"\", nil},\n\t\t// False\n\t\t{\"false\", valueFalse, \"\", nil},\n\t\t// Null\n\t\t{\"null\", valueNull, \"\", nil},\n\t\t// Number\n\t\t{\"123\", \u0026Value{t: TypeNumber, s: \"123\"}, \"\", nil},\n\t\t// NaN\n\t\t{\"NaN\", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"\", nil},\n\t\t// Number with tail\n\t\t{\"123 \", \u0026Value{t: TypeNumber, s: \"123\"}, \" \", nil},\n\t\t// Invalid value\n\t\t{\"invalid\", nil, \"invalid\", fmt.Errorf(\"unexpected value found: %q\", \"invalid\")},\n\t}\n\n\tc := \u0026cache{}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tgot, tail, err := parseValue(tt.input, c, 0)\n\t\t\tif (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"parseValue(%q) error mismatch: got %v, want %v\", tt.input, err, tt.err)\n\t\t\t}\n\t\t\tif tt.want != nil \u0026\u0026 got == nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) got nil, want non-nil\", tt.input)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif tt.want == nil \u0026\u0026 got != nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) got non-nil, want nil\", tt.input)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif tt.want != nil \u0026\u0026 got != nil {\n\t\t\t\tif tt.want.t != got.t {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) type mismatch: got %v, want %v\", tt.input, got.t, tt.want.t)\n\t\t\t\t}\n\t\t\t\tif tt.want.t == typeRawString \u0026\u0026 tt.want.s != got.s {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) string mismatch: got %q, want %q\", tt.input, got.s, tt.want.s)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"parseValue(%q) tail mismatch: got %q, want %q\", tt.input, tail, tt.tail)\n\t\t\t}\n\t\t})\n\t}\n}","668a856045bb7eb8bad1930a3275cef9":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic cases\n\t\t{`\"hello, world\"`, \"hello, world\"},\n\t\t{`\"escaped \\\\\\\"quotes\\\\\\\" and \\\\\\\\backslashes\\\\\\\\\"`, `escaped \"quotes\" and \\\\backslashes\\\\`},\n\n\t\t// Unicode escapes\n\t\t{`\"\\u0041\\u0042\\u0043\"`, \"ABC\"},\n\t\t{`\"\\u041f\\u0440\\u0438\\u0432\\u0435\\u0442\"`, \"–ü—Ä–∏–≤–µ—Ç\"},\n\n\t\t// Surrogate pairs\n\t\t{`\"\\uD83D\\uDE01\"`, \"üòÅ\"},\n\t\t{`\"\\uD83D\\uDC69\\u200D\\uD83D\\uDC69\\u200D\\uD83D\\uDC67\\u200D\\uD83D\\uDC66\"`, \"üë®‚Äçüë®‚Äçüëß‚Äçüë¶\"},\n\n\t\t// Invalid escape sequences\n\t\t{`\"\\x\"`, `\"\\x\"`},\n\t\t{`\"\\u123\"`, `\"\\u123\"`},\n\t\t{`\"\\uD83D\"`, `\"\\uD83D\"`},\n\t\t{`\"\\uD83D\\uDE0\"`, `\"\\uD83D\\uDE0\"`},\n\t\t{`\"\\uD83D\\uDE01\\uD83D\"`, `\"\\uD83D\\uDE01\\uD83D\"`},\n\n\t\t// Other control characters\n\t\t{`\"\\n\\r\\t\\b\\f\"`, \"\\n\\r\\t\\b\\f\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tactual := unescapeStringBestEffort(tt.input)\n\t\t\tif actual != tt.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", tt.input, actual, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}","6731289aaef77b8400d83d46dbc76417":"package fastjson\n\nimport \"testing\"\n\nfunc Test_hasSpecialChars(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"Test with empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Test with regular string\",\n\t\t\targs: args{s: \"Hello, world!\"},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Test with string containing double quote\",\n\t\t\targs: args{s: \"Hello, \\\"world!\\\"\"},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Test with string containing backslash\",\n\t\t\targs: args{s: \"Hello, \\\\world!\"},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Test with string containing control character\",\n\t\t\targs: args{s: \"Hello, \\tworld!\"},\n\t\t\twant: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := hasSpecialChars(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"hasSpecialChars() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","67b025a3b6f0c6ae2fda197859e96ab1":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantVal  *Value\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\twantVal:  nil,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"object\",\n\t\t\tinput:    `{\"foo\":\"bar\"}`,\n\t\t\twantVal:  \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: typeRawString, s: \"bar\"}}}}}},\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"array\",\n\t\t\tinput:    `[1,2,3]`,\n\t\t\twantVal:  \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}},\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"string\",\n\t\t\tinput:    `\"hello\"`,\n\t\t\twantVal:  \u0026Value{t: typeRawString, s: \"hello\"},\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"true\",\n\t\t\tinput:    \"true\",\n\t\t\twantVal:  valueTrue,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"false\",\n\t\t\tinput:    \"false\",\n\t\t\twantVal:  valueFalse,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"null\",\n\t\t\tinput:    \"null\",\n\t\t\twantVal:  valueNull,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"number\",\n\t\t\tinput:    \"123\",\n\t\t\twantVal:  \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN\",\n\t\t\tinput:    \"NaN\",\n\t\t\twantVal:  \u0026Value{t: TypeNumber, s: \"NaN\"},\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"unexpected value\",\n\t\t\tinput:    \"xyz\",\n\t\t\twantVal:  nil,\n\t\t\twantTail: \"xyz\",\n\t\t\twantErr:  fmt.Errorf(\"unexpected value found: %q\", \"xyz\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgotVal, gotTail, gotErr := parseValue(tt.input, c, 0)\n\t\t\tif gotVal != nil \u0026\u0026 tt.wantVal != nil \u0026\u0026 gotVal.t != tt.wantVal.t {\n\t\t\t\tt.Errorf(\"parseValue() gotVal.t = %v, want %v\", gotVal.t, tt.wantVal.t)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseValue() gotTail = %v, want %v\", gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif (gotErr == nil) != (tt.wantErr == nil) {\n\t\t\t\tt.Errorf(\"parseValue() gotErr = %v, want %v\", gotErr, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}\n","6804e2a188450095521d19251089a3cd":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic strings without escape sequences.\n\t\t{\"hello\", \"hello\"},\n\t\t{\"world\", \"world\"},\n\t\t{\"12345\", \"12345\"},\n\n\t\t// Simple escape sequences.\n\t\t{`\\\"`, `\"`},\n\t\t{`\\\\`, `\\`},\n\t\t{`\\/`, `/`},\n\t\t{`\\b`, \"\\b\"},\n\t\t{`\\f`, \"\\f\"},\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\r`, \"\\r\"},\n\t\t{`\\t`, \"\\t\"},\n\n\t\t// Unicode escape sequences.\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A9`, \"¬©\"},\n\t\t{`\\u20AC`, \"‚Ç¨\"},\n\t\t{`\\uD83D\\uDE02`, \"üòÇ\"}, // Surrogate pair.\n\n\t\t// Invalid escape sequences.\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\uD800`, `\\uD800`}, // Unpaired surrogate.\n\n\t\t// Mixed strings with valid and invalid escape sequences.\n\t\t{`hello\\tworld`, \"hello\\tworld\"},\n\t\t{`\"quoted string\"`, `\"quoted string\"`},\n\t\t{`C:\\\\Users\\\\John`, `C:\\Users\\John`},\n\t\t{`\\u0041\\u0020\\uD83D\\uDE02`, \"A üòÇ\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}","682443aef2bd906bc6223297b5892cb3":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic escapes\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\t`, \"\\t\"},\n\t\t{`\\\\`, `\\`},\n\t\t{`\\/`, `/`},\n\t\t{`\\\"`, `\"`},\n\t\t{`\\b`, \"\\b\"},\n\t\t{`\\f`, \"\\f\"},\n\t\t{`\\r`, \"\\r\"},\n\n\t\t// Unicode escapes\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A0`, \"\\u00A0\"},\n\t\t{`\\u20AC`, \"‚Ç¨\"},\n\t\t{`\\uD83D\\uDE02`, \"üòÇ\"}, // Surrogate pair\n\n\t\t// Invalid escapes\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u`, `\\u`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\uD800`, `\\uD800`}, // Invalid surrogate pair\n\t\t{`\\uD800\\u`, `\\uD800\\u`},\n\n\t\t// Mixed escapes\n\t\t{`Hello\\tworld\\n`, \"Hello\\tworld\\n\"},\n\t\t{`C:\\\\Users\\\\John\\\\Doe`, `C:\\Users\\John\\Doe`},\n\t\t{`\\\"Quotes\\\"`, `\"Quotes\"`},\n\n\t\t// No escapes\n\t\t{`Hello, world!`, `Hello, world!`},\n\t\t{`No escapes here`, `No escapes here`},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Input: %q, Expected: %q, Actual: %q\", test.input, test.expected, actual)\n\t\t}\n\t}\n}","687b07e488e0a192515ad3f89d12c2ca":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic strings without escape sequences.\n\t\t{\"hello\", \"hello\"},\n\t\t{\"world\", \"world\"},\n\t\t{\"12345\", \"12345\"},\n\n\t\t// Simple escape sequences.\n\t\t{`\\\"`, `\"`},\n\t\t{`\\\\`, `\\`},\n\t\t{`\\/`, `/`},\n\t\t{`\\b`, \"\\b\"},\n\t\t{`\\f`, \"\\f\"},\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\r`, \"\\r\"},\n\t\t{`\\t`, \"\\t\"},\n\n\t\t// Unicode escape sequences.\n\t\t{`\\u0027`, \"'\"},\n\t\t{`\\u000A`, \"\\n\"},\n\t\t{`\\u000D`, \"\\r\"},\n\t\t{`\\u03A9`, \"Œ©\"},\n\t\t{`\\uFFFF`, \"Ôøø\"},\n\n\t\t// Surrogate pairs.\n\t\t{`\\uD83D\\uDE02`, \"üòÇ\"},\n\t\t{`\\uD83D\\uDC4D`, \"üëç\"},\n\n\t\t// Invalid escape sequences.\n\t\t{`\\u`, `\\u`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\u123G`, `\\u123G`},\n\t\t{`\\uD800`, `\\uD800`},\n\t\t{`\\uD800\\u`, `\\uD800\\u`},\n\t\t{`\\uD800\\uD800`, `\\uD800\\uD800`},\n\n\t\t// Mixed strings with valid and invalid escape sequences.\n\t\t{`hello\\tworld`, \"hello\\tworld\"},\n\t\t{`\\u0022hello\\u0022`, `\"hello\"`},\n\t\t{`c:\\\\users\\\\user\\`, `c:\\\\users\\\\user\\`},\n\t\t{`\\uD83D\\uDE02\\uD83D\\uDC4D`, \"üòÇüëç\"},\n\t\t{`\\uD800\\uD800\\uD83D\\uDE02\\uD83D\\uDC4D`, `\\uD800\\uD800üòÇüëç`},\n\t}\n\n\tfor i, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Test %d failed: Input: %q, Expected: %q, Actual: %q\", i+1, test.input, test.expected, actual)\n\t\t}\n\t}\n}","68808cd021a8ac028c0531f9704bfc29":"package fastjson\n\nimport \"testing\"\n\nfunc TestObject_getKV(t *testing.T) {\n\to := Object{}\n\t// Test adding a new kv when the capacity is enough\n\tkv1 := o.getKV()\n\tkv1.k = \"key1\"\n\tif kv1.k != \"key1\" || len(o.kvs) != 1 {\n\t\tt.Errorf(\"Failed to add a new kv when capacity is enough\")\n\t}\n\n\t// Test adding a new kv when the capacity is not enough\n\to.kvs = o.kvs[:0]\n\to.kvs = append(o.kvs, kv{k: \"key2\"})\n\tkv2 := o.getKV()\n\tkv2.k = \"key3\"\n\tif kv2.k != \"key3\" || len(o.kvs) != 2 {\n\t\tt.Errorf(\"Failed to add a new kv when capacity is not enough\")\n\t}\n}","68fecac4233379e0ee0add4e25802abc":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ts     string\n\t\terr   error\n\t}{\n\t\t// Empty array\n\t\t{\"[]\", \u0026Value{t: TypeArray, a: []*Value{}}, \"\", nil},\n\t\t// Simple array\n\t\t{\"[1,2,3]\", \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t}}, \"\", nil},\n\t\t// Array with whitespace\n\t\t{\" [ 1 , 2 , 3 ] \", \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t}}, \"\", nil},\n\t\t// Nested array\n\t\t{\"[[1,2],[3,4]]\", \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t}},\n\t\t\t{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t{t: TypeNumber, s: \"4\"},\n\t\t\t}},\n\t\t}}, \"\", nil},\n\t\t// Array with different value types\n\t\t{\"[1,\\\"hello\\\",true]\", \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t{t: TypeString, s: \"hello\"},\n\t\t\t{t: TypeTrue},\n\t\t}}, \"\", nil},\n\t\t// Invalid array: missing closing bracket\n\t\t{\"[1,2,3\", nil, \"[1,2,3\", fmt.Errorf(\"missing ']'\")},\n\t\t// Invalid array: missing comma\n\t\t{\"[1 2 3]\", nil, \" 2 3]\", fmt.Errorf(\"missing ',' after array value\")},\n\t\t// Invalid array: unexpected end of array\n\t\t{\"[1,\", nil, \"\", fmt.Errorf(\"unexpected end of array\")},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseArray(tt.input, c, 0)\n\n\t\t\tif (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err == nil) {\n\t\t\t\tt.Errorf(\"Test %d: Expected error %v, got %v\", i, tt.err, err)\n\t\t\t} else if err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error() {\n\t\t\t\tt.Errorf(\"Test %d: Expected error %v, got %v\", i, tt.err, err)\n\t\t\t} else if s != tt.s {\n\t\t\t\tt.Errorf(\"Test %d: Expected remaining string %q, got %q\", i, tt.s, s)\n\t\t\t} else if !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"Test %d: Expected value %v, got %v\", i, tt.want, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.t == TypeArray {\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\treturn v1.s == v2.s\n}","691a36d7ea06c6aa770c81bab56634b6":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tin  string\n\t\tout string\n\t}{\n\t\t{`\"`, `\"`},\n\t\t{`\\`, `\\`},\n\t\t{`/`, `/`},\n\t\t{`\\b`, \"\\b\"},\n\t\t{`\\f`, \"\\f\"},\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\r`, \"\\r\"},\n\t\t{`\\t`, \"\\t\"},\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\uD83D\\uDE01`, \"üòÅ\"},\n\t\t{`\\uD83D\\uDE01abc`, \"üòÅabc\"},\n\t\t{`abc\\uD83D\\uDE01`, \"abcüòÅ\"},\n\t\t{`abc\\uD83D\\uDE01def`, \"abcüòÅdef\"},\n\t\t{`\\ud83d`, `\\ud83d`},\n\t\t{`\\ud83d\\ude0`, `\\ud83d\\ude0`},\n\t\t{`\\ud83d\\ude0123`, `\\ud83d\\ude0123`},\n\t\t{`\\ud83`, `\\ud83`},\n\t\t{`\\ud83\\ud83d`, `\\ud83\\ud83d`},\n\t\t{`\\ud83\\ud83d\\ude01`, `\\ud83\\ud83d\\ude01`},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.in, func(t *testing.T) {\n\t\t\tactual := unescapeStringBestEffort(tt.in)\n\t\t\tif actual != tt.out {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", tt.in, actual, tt.out)\n\t\t\t}\n\t\t})\n\t}\n}","6978245fc46d5f25aaf2c8cac4473f73":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantNum  string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Basic cases\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"+123.45\", \"+123.45\", \"\", nil},\n\t\t{\"1.23e+4\", \"1.23e+4\", \"\", nil},\n\t\t{\"1.23E-4\", \"1.23E-4\", \"\", nil},\n\n\t\t// Trailing characters\n\t\t{\"123abc\", \"123\", \"abc\", nil},\n\t\t{\"-123.45xyz\", \"-123.45\", \"xyz\", nil},\n\n\t\t// Invalid numbers\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t\t{\"+\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"+\")},\n\t\t{\"-\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t\t{\".\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \".\")},\n\t\t{\"a123\", \"\", \"a123\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\n\t\t// Special values\n\t\t{\"inf\", \"inf\", \"nf\", nil},\n\t\t{\"+Inf\", \"+Inf\", \"nf\", nil},\n\t\t{\"-INFINITY\", \"-INFINITY\", \"ITY\", nil},\n\t\t{\"NaN\", \"NaN\", \"aN\", nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d:%s\", i, tt.input), func(t *testing.T) {\n\t\t\tgotNum, gotTail, gotErr := parseRawNumber(tt.input)\n\n\t\t\tif gotNum != tt.wantNum {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got number = %q, want %q\", tt.input, gotNum, tt.wantNum)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got tail = %q, want %q\", tt.input, gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif gotErr == nil \u0026\u0026 tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got err = nil, want %v\", tt.input, tt.wantErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr == nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got err = %v, want nil\", tt.input, gotErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got err = %v, want %v\", tt.input, gotErr, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","69e14af1a1cf177e765068338ea97f04":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestValue_Bool(t *testing.T) {\n\ttests := []struct {\n\t\tinput       string\n\t\twant        bool\n\t\twantErr     bool\n\t\texpectedErr string\n\t}{\n\t\t{`true`, true, false, \"\"},\n\t\t{`false`, false, false, \"\"},\n\t\t{`\"true\"`, false, true, \"value doesn't contain bool; it contains string\"},\n\t\t{`{}`, false, true, \"value doesn't contain bool; it contains object\"},\n\t\t{`[]`, false, true, \"value doesn't contain bool; it contains array\"},\n\t\t{`123`, false, true, \"value doesn't contain bool; it contains number\"},\n\t\t{`null`, false, true, \"value doesn't contain bool; it contains null\"},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test %d - %v\", i+1, tt.input), func(t *testing.T) {\n\t\t\tv, err := Parse([]byte(tt.input))\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Parse error: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tgot, err := v.Bool()\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"wantErr: %v, got: %v\", tt.wantErr, err)\n\t\t\t}\n\n\t\t\tif tt.wantErr \u0026\u0026 err.Error() != tt.expectedErr {\n\t\t\t\tt.Errorf(\"expected error: %q, got: %q\", tt.expectedErr, err.Error())\n\t\t\t}\n\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"want: %v, got: %v\", tt.want, got)\n\t\t\t}\n\t\t})\n\t}\n}","6aca4cb03aca002182ddf53b78161961":"package fastjson\n\nimport \"testing\"\n\nfunc Test_hasSpecialChars(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    string\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\ts:    \"\",\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with no special characters\",\n\t\t\ts:    \"hello world\",\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with double quote\",\n\t\t\ts:    \"hello\\\"world\",\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with backslash\",\n\t\t\ts:    \"hello\\\\world\",\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with control character\",\n\t\t\ts:    \"hello\\x00world\",\n\t\t\twant: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := hasSpecialChars(tt.s); got != tt.want {\n\t\t\t\tt.Errorf(\"hasSpecialChars() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","6b4af14a43e831b21c655ba7bacce0d5":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"raw string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"raw string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"12345\",\n\t\t\t},\n\t\t\twant: []byte(\"12345\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"string1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"12345\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"[\\\"string1\\\",12345]\"),\n\t\t},\n\t\t// Add more test cases for other types and nested objects/arrays\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif string(got) != string(tt.want) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %v, want %v\", string(got), string(tt.want))\n\t\t\t}\n\t\t})\n\t}\n}","6b82b35fcceba03b7e2a861d1ca8a1bc":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Empty string\n\t\t{\"\", nil, \"\", fmt.Errorf(\"cannot parse empty string\")},\n\t\t// Invalid JSON\n\t\t{\"{\", nil, \"\", fmt.Errorf(\"cannot parse object: missing '}'\")},\n\t\t// Object\n\t\t{`{\"foo\":\"bar\"}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: typeRawString, s: \"bar\"}}}}}, \"\", nil},\n\t\t// Array\n\t\t{`[1,2,3]`, \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}}, \"\", nil},\n\t\t// String\n\t\t{`\"hello\"`, \u0026Value{t: typeRawString, s: \"hello\"}, \"\", nil},\n\t\t// True\n\t\t{\"true\", valueTrue, \"\", nil},\n\t\t// False\n\t\t{\"false\", valueFalse, \"\", nil},\n\t\t// Null\n\t\t{\"null\", valueNull, \"\", nil},\n\t\t// Number\n\t\t{\"123\", \u0026Value{t: TypeNumber, s: \"123\"}, \"\", nil},\n\t\t// NaN\n\t\t{\"NaN\", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"\", nil},\n\t\t// Trailing whitespace\n\t\t{\"true \", valueTrue, \" \", nil},\n\t\t// Nested structures\n\t\t{`{\"foo\":[1,{\"bar\":\"baz\"}]}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeObject, o: Object{kvs: []kv{{k: \"bar\", v: \u0026Value{t: typeRawString, s: \"baz\"}}}}}}}}}}}, \"\", nil},\n\t}\n\n\tc := \u0026cache{}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tgot, tail, err := parseValue(tt.input, c, 0)\n\t\t\tif fmt.Sprintf(\"%v\", err) != fmt.Sprintf(\"%v\", tt.err) {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, want %v\", tt.input, err, tt.err)\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"parseValue(%q) tail = %q, want %q\", tt.input, tail, tt.tail)\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", tt.input, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\treturn v1.s == v2.s\n\t}\n}\n","6d3a5822e00fab03ff2f1d46789bc3de":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey   string\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Basic cases\n\t\t{`\"foo\"bar`, \"foo\", \"bar\", nil},\n\t\t{`\"fo\\\"o\"bar`, `fo\"o`, \"bar\", nil},\n\t\t{`\"foo\" bar`, \"foo\", \" bar\", nil},\n\n\t\t// Escaped quotes\n\t\t{`\"fo\\\\o\"bar`, `fo\\o`, \"bar\", nil},\n\t\t{`\"fo\\\\\\\\o\"bar`, `fo\\\\o`, \"bar\", nil},\n\t\t{`\"fo\\\"o\"bar`, `fo\"o`, \"bar\", nil},\n\t\t{`\"fo\\\\\\\"o\"bar`, `fo\\\"o`, \"bar\", nil},\n\t\t{`\"fo\\\\\\\\\\\"o\"bar`, `fo\\\\\"o`, \"bar\", nil},\n\n\t\t// Missing closing quote\n\t\t{`\"foo`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"fo\\\"o`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"fo\\\\\"o`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d:%s\", i, tt.input), func(t *testing.T) {\n\t\t\tkey, tail, err := parseRawString(tt.input)\n\t\t\tif key != tt.key || tail != tt.tail || (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = (%q, %q, %v), want (%q, %q, %v)\", tt.input, key, tail, err, tt.key, tt.tail, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}","6d42cc491bb7931af5168fb29d450757":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantN    string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Basic cases\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"123.456\", \"123.456\", \"\", nil},\n\t\t{\"1.23e4\", \"1.23e4\", \"\", nil},\n\t\t{\"1.23E+4\", \"1.23E+4\", \"\", nil},\n\t\t{\"-1.23e-4\", \"-1.23e-4\", \"\", nil},\n\n\t\t// Trailing characters\n\t\t{\"123a\", \"123\", \"a\", nil},\n\t\t{\"123.456 \", \"123.456\", \" \", nil},\n\t\t{\"123,\", \"123\", \",\", nil},\n\n\t\t// Invalid numbers\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t\t{\"-\", \"\", \"-\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t\t(\"+\", \"\", \"+\", fmt.Errorf(\"unexpected char: %q\", \"+\")},\n\t\t(\".123\", \"\", \".123\", fmt.Errorf(\"unexpected char: %q\", \".\")},\n\t\t{\"1.2.3\", \"\", \"1.2.3\", fmt.Errorf(\"unexpected char: %q\", \"1.\")},\n\n\t\t// Special cases: inf, nan\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"+inf\", \"+inf\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"InF\", \"InF\", \"\", nil}, // Case insensitive\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"+nan\", \"\", \"+nan\", fmt.Errorf(\"unexpected char: %q\", \"+\")}, // NaN cannot have a sign\n\t\t{\"-nan\", \"\", \"-nan\", fmt.Errorf(\"unexpected char: %q\", \"-\")}, // NaN cannot have a sign\n\t\t{\"in\", \"\", \"in\", fmt.Errorf(\"unexpected char: %q\", \"i\")},     // Not a full \"inf\"\n\t\t{\"na\", \"\", \"na\", fmt.Errorf(\"unexpected char: %q\", \"n\")},     // Not a full \"nan\"\n\t\t{\"123inf\", \"123\", \"inf\", nil},\n\t\t{\"inf123\", \"inf\", \"123\", nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d:%s\", i, tt.input), func(t *testing.T) {\n\t\t\tgotN, gotTail, gotErr := parseRawNumber(tt.input)\n\t\t\tif gotN != tt.wantN || gotTail != tt.wantTail || (gotErr != nil \u0026\u0026 tt.wantErr == nil) || (gotErr == nil \u0026\u0026 tt.wantErr != nil) || (gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error()) {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = (%q, %q, %v), want (%q, %q, %v)\", tt.input, gotN, gotTail, gotErr, tt.wantN, tt.wantTail, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}\n","6d5a8b1708e96dcfd891f4e6f778b2eb":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\ts    string\n\t\tns   string\n\t\ttail string\n\t\terr  error\n\t}{\n\t\t{s: \"123\", ns: \"123\", tail: \"\"},\n\t\t{s: \"123.45\", ns: \"123.45\", tail: \"\"},\n\t\t{s: \"-123\", ns: \"-123\", tail: \"\"},\n\t\t{s: \"-123.45\", ns: \"-123.45\", tail: \"\"},\n\t\t{s: \"123e45\", ns: \"123e45\", tail: \"\"},\n\t\t{s: \"123E45\", ns: \"123E45\", tail: \"\"},\n\t\t{s: \"123e+45\", ns: \"123e+45\", tail: \"\"},\n\t\t{s: \"123E+45\", ns: \"123E+45\", tail: \"\"},\n\t\t{s: \"123e-45\", ns: \"123e-45\", tail: \"\"},\n\t\t{s: \"123E-45\", ns: \"123E-45\", tail: \"\"},\n\t\t{s: \"123a\", ns: \"123\", tail: \"a\"},\n\t\t{s: \"123.45a\", ns: \"123.45\", tail: \"a\"},\n\t\t{s: \"-123a\", ns: \"-123\", tail: \"a\"},\n\t\t{s: \"-123.45a\", ns: \"-123.45\", tail: \"a\"},\n\t\t{s: \"123e45a\", ns: \"123e45\", tail: \"a\"},\n\t\t{s: \"123E45a\", ns: \"123E45\", tail: \"a\"},\n\t\t{s: \"123e+45a\", ns: \"123e+45\", tail: \"a\"},\n\t\t{s: \"123E+45a\", ns: \"123E+45\", tail: \"a\"},\n\t\t{s: \"123e-45a\", ns: \"123e-45\", tail: \"a\"},\n\t\t{s: \"123E-45a\", ns: \"123E-45\", tail: \"a\"},\n\t\t{s: \"inf\", ns: \"\", tail: \"inf\", err: fmt.Errorf(\"unexpected char: %q\", \"i\")},\n\t\t{s: \"nan\", ns: \"\", tail: \"nan\", err: fmt.Errorf(\"unexpected char: %q\", \"n\")},\n\t\t{s: \"+inf\", ns: \"\", tail: \"+inf\", err: fmt.Errorf(\"unexpected char: %q\", \"+\")},\n\t\t{s: \"+nan\", ns: \"\", tail: \"+nan\", err: fmt.Errorf(\"unexpected char: %q\", \"+\")},\n\t\t{s: \"-inf\", ns: \"-inf\", tail: \"\"},\n\t\t{s: \"-nan\", ns: \"-nan\", tail: \"\"},\n\t}\n\tfor i, tt := range tests {\n\t\tns, tail, err := parseRawNumber(tt.s)\n\t\tif tt.err != nil {\n\t\t\tif err == nil || err.Error() != tt.err.Error() {\n\t\t\t\tt.Errorf(\"test %d failed: expected error %v, got %v\", i, tt.err, err)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tif err != nil {\n\t\t\tt.Errorf(\"test %d failed: unexpected error %v\", i, err)\n\t\t\tcontinue\n\t\t}\n\t\tif ns != tt.ns {\n\t\t\tt.Errorf(\"test %d failed: expected ns %q, got %q\", i, tt.ns, ns)\n\t\t}\n\t\tif tail != tt.tail {\n\t\t\tt.Errorf(\"test %d failed: expected tail %q, got %q\", i, tt.tail, tail)\n\t\t}\n\t}\n}","6da65682ce259312ae9b4cdb1e73416a":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantNum  string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Basic cases\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"123.45\", \"123.45\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"+123\", \"+123\", \"\", nil},\n\t\t{\"1.2e3\", \"1.2e3\", \"\", nil},\n\t\t{\"1.2E-3\", \"1.2E-3\", \"\", nil},\n\n\t\t// Trailing characters\n\t\t{\"123a\", \"123\", \"a\", nil},\n\t\t{\"123.45b\", \"123.45\", \"b\", nil},\n\t\t{\"-123c\", \"-123\", \"c\", nil},\n\n\t\t// Invalid numbers\n\t\t{\"a123\", \"\", \"a123\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\".123\", \"\", \".123\", fmt.Errorf(\"unexpected char: %q\", \".\")},\n\t\t{\"+a123\", \"\", \"+a123\", fmt.Errorf(\"unexpected char: %q\", \"+a\")},\n\n\t\t// Special cases: inf, nan\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"+inf\", \"+inf\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"InF\", \"InF\", \"\", nil}, // Case-insensitive\n\t\t{\"123inf\", \"123\", \"inf\", nil},\n\t\t{\"123+inf\", \"123\", \"+inf\", nil},\n\n\t\t// Edge cases\n\t\t{\"\", \"\", \"\", nil},\n\t\t{\"+\", \"\", \"+\", fmt.Errorf(\"unexpected char: %q\", \"+\")},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tgotNum, gotTail, gotErr := parseRawNumber(tt.input)\n\t\t\tif gotNum != tt.wantNum || gotTail != tt.wantTail || (gotErr != nil \u0026\u0026 tt.wantErr == nil) || (gotErr == nil \u0026\u0026 tt.wantErr != nil) || (gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error()) {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = (%q, %q, %v), want (%q, %q, %v)\", tt.input, gotNum, gotTail, gotErr, tt.wantNum, tt.wantTail, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","6db00f06325b618d849dc56822ae75ec":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tt.Parallel()\n\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantVal  *Value\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\twantVal:  nil,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t// Add more test cases for different scenarios like:\n\t\t// - Valid and invalid JSON objects\n\t\t// - Valid and invalid JSON arrays\n\t\t// - Valid and invalid JSON strings\n\t\t// - Valid and invalid JSON numbers\n\t\t// - JSON true, false, and null values\n\t\t// - Test cases with different depths\n\t}\n\n\tfor _, tc := range testCases {\n\t\ttc := tc\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgotVal, gotTail, gotErr := parseValue(tc.input, c, 0)\n\n\t\t\tif tc.wantErr != nil {\n\t\t\t\tif gotErr == nil {\n\t\t\t\t\tt.Errorf(\"expected error %v, got nil\", tc.wantErr)\n\t\t\t\t} else if gotErr.Error() != tc.wantErr.Error() {\n\t\t\t\t\tt.Errorf(\"expected error %v, got %v\", tc.wantErr, gotErr)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotErr != nil {\n\t\t\t\tt.Errorf(\"unexpected error: %v\", gotErr)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif gotTail != tc.wantTail {\n\t\t\t\tt.Errorf(\"expected tail %q, got %q\", tc.wantTail, gotTail)\n\t\t\t}\n\n\t\t\t// Add assertions to compare gotVal with tc.wantVal based on the expected value type\n\t\t\t// For example, for a JSON string:\n\t\t\t// if string(gotVal.s) != tc.wantVal {\n\t\t\t// \tt.Errorf(\"expected value %q, got %q\", tc.wantVal, string(gotVal.s))\n\t\t\t// }\n\t\t})\n\t}\n}\n","6df0d4e5d8c2ff606085628a104b67b6":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput  string\n\t\tns     string\n\t\tremain string\n\t\terr    error\n\t}{\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"123.456\", \"123.456\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"+123\", \"+123\", \"\", nil},\n\t\t{\"1.2e3\", \"1.2e3\", \"\", nil},\n\t\t{\"1.2E-3\", \"1.2E-3\", \"\", nil},\n\t\t{\"123a\", \"123\", \"a\", nil},\n\t\t{\"123.456a\", \"123.456\", \"a\", nil},\n\t\t{\"-123a\", \"-123\", \"a\", nil},\n\t\t{\"+123a\", \"+123\", \"a\", nil},\n\t\t{\"1.2e3a\", \"1.2e3\", \"a\", nil},\n\t\t{\"1.2E-3a\", \"1.2E-3\", \"a\", nil},\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"+inf\", \"+inf\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"InF\", \"InF\", \"\", nil},\n\t\t{\"inF\", \"inF\", \"\", nil},\n\t\t{\"+InF\", \"+InF\", \"\", nil},\n\t\t{\"-InF\", \"-InF\", \"\", nil},\n\t\t{\"NAN\", \"NAN\", \"\", nil},\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"+NAN\", \"+NAN\", \"\", nil},\n\t\t{\"-NAN\", \"-NAN\", \"\", nil},\n\t\t{\"123inf\", \"123\", \"inf\", nil},\n\t\t{\"123InF\", \"123\", \"InF\", nil},\n\t\t{\"123NAN\", \"123\", \"NAN\", nil},\n\t\t{\"123nan\", \"123\", \"nan\", nil},\n\t\t{\"a123\", \"\", \"a123\", fmt.Errorf(`unexpected char: \"a\"`)},\n\t\t{\"-a123\", \"\", \"-a123\", fmt.Errorf(`unexpected char: \"-\"`)},\n\t\t{\"+a123\", \"\", \"+a123\", fmt.Errorf(`unexpected char: \"+\"`)},\n\t}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tns, remain, err := parseRawNumber(tt.input)\n\t\t\tif ns != tt.ns || remain != tt.remain || !errorEqual(err, tt.err) {\n\t\t\t\tt.Errorf(\"input: %q, expect: %q,%q,%v, got: %q,%q,%v\", tt.input, tt.ns, tt.remain, tt.err, ns, remain, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc errorEqual(e1, e2 error) bool {\n\tif e1 == nil \u0026\u0026 e2 == nil {\n\t\treturn true\n\t}\n\tif e1 != nil \u0026\u0026 e2 != nil {\n\t\treturn e1.Error() == e2.Error()\n\t}\n\treturn false\n}","6e33d0d62a23a8721caad8b3e9af809d":"package fastjson\n\nimport \"testing\"\n\nfunc Test_skipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    string\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\ts:    \"\",\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with leading whitespace\",\n\t\t\ts:    \"  foo\",\n\t\t\twant: \"foo\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with leading tab\",\n\t\t\ts:    \"\\tfoo\",\n\t\t\twant: \"foo\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with leading newline\",\n\t\t\ts:    \"\\nfoo\",\n\t\t\twant: \"foo\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with leading carriage return\",\n\t\t\ts:    \"\\rfoo\",\n\t\t\twant: \"foo\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with leading mixed whitespace\",\n\t\t\ts:    \" \\t\\n\\rfoo\",\n\t\t\twant: \"foo\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with no leading whitespace\",\n\t\t\ts:    \"foo\",\n\t\t\twant: \"foo\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with only whitespace\",\n\t\t\ts:    \" \\t\\n\\r\",\n\t\t\twant: \"\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","6e8502e4888bb33c5d31d62ffdb69b41":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic strings\n\t\t{\"hello\", \"hello\"},\n\t\t{\"world\", \"world\"},\n\n\t\t// Escaped characters\n\t\t{`\\\"hello\\\"`, `\"hello\"`},\n\t\t{`\\\\world\\\\`, `\\world\\`},\n\t\t{`\\bfoo\\tbar\\nbaz`, \"\\bfoo\\tbar\\nbaz\"},\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A0`, \"\\u00A0\"},\n\t\t{`\\uFFFF`, \"\\uFFFF\"},\n\n\t\t// Invalid escape sequences\n\t\t{`\\z`, `\\z`},\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\u12345`, `\\u12345`},\n\n\t\t// Surrogate pairs\n\t\t{`\\uD83D\\uDE02`, \"\\U0001F602\"},\n\t\t{`\\uD83D\\uDE02\\uD83D\\uDE02`, \"\\U0001F602\\U0001F602\"},\n\n\t\t// Mixed strings\n\t\t{`hello\\t\"world\"`, \"hello\\t\\\"world\\\"\"},\n\t\t{`\\uD83D\\uDE02\\\"\\uD83D\\uDE02`, \"\\U0001F602\\\"\\U0001F602\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}","6f19aa110e6aa422ecee615bd3adb1ca":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic cases\n\t\t{`\"hello, world\"`, \"hello, world\"},\n\t\t{`\"escaped \\\\\\\"quotes\\\\\\\"\"`, `escaped \\\"quotes\\\"`},\n\t\t{`\"escaped \\\\/slash\"`, `escaped /slash`},\n\n\t\t// Unicode escapes\n\t\t{`\"\\u0041\\u006e\\u006f\\u0074\\u0068\\u0065\\u0072\"`, \"Another\"},\n\t\t{`\"\\u041f\\u0440\\u0438\\u0432\\u0435\\u0442\"`, \"–ü—Ä–∏–≤–µ—Ç\"},\n\n\t\t// Surrogate pairs\n\t\t{`\"\\uD83D\\uDE02\"`, \"üòÇ\"},\n\t\t{`\"\\uD83D\\uDE02\\uD83D\\uDE02\"`, \"üòÇüòÇ\"},\n\n\t\t// Invalid escapes\n\t\t{`\"\\xzz\"`, `\\xzz`},\n\t\t{`\"\\u123\"`, `\\u123`},\n\t\t{`\"\\uD800\"`, `\\uD800`},\n\t\t{`\"\\uD800\\uDC00\\uD800\"`, `\\uD800\\uDC00\\uD800`},\n\n\t\t// Other control characters\n\t\t{`\"\\b\\f\\n\\r\\t\"`, \"\\b\\f\\n\\r\\t\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}","6f44ad38d1750d682e4dc5ccc8c22331":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantObj  string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t{\n\t\t\tname:     \"empty object\",\n\t\t\tinput:    \"{}\",\n\t\t\twantObj:  `{\"t\":1}`,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"simple object\",\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\twantObj:  `{\"t\":1,\"o\":{\"kvs\":[{\"k\":\"key\",\"v\":{\"t\":3,\"s\":\"value\"}}]}}`,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple key-value pairs\",\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantObj:  `{\"t\":1,\"o\":{\"kvs\":[{\"k\":\"key1\",\"v\":{\"t\":3,\"s\":\"value1\"}},{\"k\":\"key2\",\"v\":{\"t\":3,\"s\":\"value2\"}}]}}`,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"nested object\",\n\t\t\tinput:    `{\"key1\": {\"key2\": \"value2\"}}`,\n\t\t\twantObj:  `{\"t\":1,\"o\":{\"kvs\":[{\"k\":\"key1\",\"v\":{\"t\":1,\"o\":{\"kvs\":[{\"k\":\"key2\",\"v\":{\"t\":3,\"s\":\"value2\"}}]}}}]}}`,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing closing brace\",\n\t\t\tinput:    `{\"key\": \"value\"`,\n\t\t\twantObj:  \"\",\n\t\t\twantTail: `{\"key\": \"value\"`,\n\t\t\twantErr:  fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"missing opening quote for key\",\n\t\t\tinput:    \"{key: \\\"value\\\"}\",\n\t\t\twantObj:  \"\",\n\t\t\twantTail: `key: \"value\"}`,\n\t\t\twantErr:  fmt.Errorf(`cannot find opening '\"\" for object key`),\n\t\t},\n\t\t{\n\t\t\tname:     \"missing colon after key\",\n\t\t\tinput:    `{\"key\" \"value\"}`,\n\t\t\twantObj:  \"\",\n\t\t\twantTail: `\"value\"}`,\n\t\t\twantErr:  fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"missing comma between key-value pairs\",\n\t\t\tinput:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantObj:  \"\",\n\t\t\twantTail: `\"key2\": \"value2\"}`,\n\t\t\twantErr:  fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgotObj, gotTail, gotErr := parseObject(tt.input, c, 0)\n\n\t\t\tif fmt.Sprintf(\"%v\", gotErr) != fmt.Sprintf(\"%v\", tt.wantErr) {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", gotErr, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotObj != nil {\n\t\t\t\tgotObjStr := gotObj.String()\n\t\t\t\tif gotObjStr != tt.wantObj {\n\t\t\t\t\tt.Errorf(\"parseObject() gotObj = %s, want %s\", gotObjStr, tt.wantObj)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseObject() gotTail = %s, want %s\", gotTail, tt.wantTail)\n\t\t\t}\n\t\t})\n\t}\n}","6f51b309595c1399dbabe55956e4e70a":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey   string\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Basic cases\n\t\t{`\"foo\"bar`, \"foo\", \"bar\", nil},\n\t\t{`\"fo\\\"o\"bar`, `fo\"o`, \"bar\", nil},\n\t\t{`\"foo\"`, \"foo\", \"\", nil},\n\t\t{`\"\"bar`, \"\", \"bar\", nil},\n\n\t\t// Escaped quotes\n\t\t{`\"foo\\\\\"bar\"baz`, `foo\\bar`, \"baz\", nil},\n\t\t{`\"foo\\\\\\\\\"bar\"baz`, `foo\\\\`, `bar\"baz`, nil},\n\n\t\t// Missing closing quote\n\t\t{`\"foobar`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo\\\"bar`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\n\t\t// Empty string\n\t\t{`\"\"`, \"\", \"\", nil},\n\n\t\t// Special characters\n\t\t{`\"\\n\\t\\r\\b\\f\\\\\\\"\"`, \"\\n\\t\\r\\b\\f\\\\\\\"\", \"\", nil},\n\t}\n\n\tfor i, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tkey, tail, err := parseRawString(test.input)\n\n\t\t\tif key != test.key {\n\t\t\t\tt.Errorf(\"Test %d failed: Expected key '%s', got '%s'\", i, test.key, key)\n\t\t\t}\n\t\t\tif tail != test.tail {\n\t\t\t\tt.Errorf(\"Test %d failed: Expected tail '%s', got '%s'\", i, test.tail, tail)\n\t\t\t}\n\t\t\tif (err != nil \u0026\u0026 test.err == nil) || (err == nil \u0026\u0026 test.err != nil) || (err != nil \u0026\u0026 test.err != nil \u0026\u0026 err.Error() != test.err.Error()) {\n\t\t\t\tt.Errorf(\"Test %d failed: Expected error '%v', got '%v'\", i, test.err, err)\n\t\t\t}\n\t\t})\n\t}\n}\n","6fab218b3923aaaeb15f025f2a5a7e40":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput  string\n\t\texpect string\n\t\ttail   string\n\t\terr    error\n\t}{\n\t\t// Basic cases\n\t\t{`\"hello\" world`, \"hello\", \" world\", nil},\n\t\t{`\"hello\"`, \"hello\", \"\", nil},\n\t\t{`\"\"`, \"\", \"\", nil},\n\n\t\t// Escaped quotes\n\t\t{`\"hello\\\\\" world\"`, \"hello\\\\\\\" world\", \"\", nil},\n\t\t{`\"hello \\\\\" world\"`, \"hello \\\\\\\" world\", \"\", nil},\n\t\t{`\"hello\\\\\\\\\" world\"`, \"hello\\\\\\\\\", \" world\", nil},\n\n\t\t// Missing closing quote\n\t\t{`\"hello world`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"hello`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\n\t\t// Special characters\n\t\t{`\"\\n\\t\\r\\b\\f\\\\\\\"\"`, \"\\n\\t\\r\\b\\f\\\\\\\"\\\"\", \"\", nil},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"Case #%d: %s\", i+1, tc.input), func(t *testing.T) {\n\t\t\tresult, tail, err := parseRawString(tc.input)\n\n\t\t\tif tc.err != nil {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"Expected error %v, got nil\", tc.err)\n\t\t\t\t} else if err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"Expected error %v, got %v\", tc.err, err)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t\t\t} else if result != tc.expect {\n\t\t\t\t\tt.Errorf(\"Expected result %q, got %q\", tc.expect, result)\n\t\t\t\t} else if tail != tc.tail {\n\t\t\t\t\tt.Errorf(\"Expected tail %q, got %q\", tc.tail, tail)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n","6fd24ebeaee11084b0c385bb63aecac6":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\twantS string\n\t\terr   error\n\t}{\n\t\t{\n\t\t\tinput: \"[]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: nil,\n\t\t\t},\n\t\t\twantS: \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: \"[ ]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: nil,\n\t\t\t},\n\t\t\twantS: \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: \"[1]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantS: \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: \"[ 1]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantS: \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: \"[1 ]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantS: \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: \"[1,2]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantS: \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: \"[ 1 , 2 ]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantS: \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: \"[1,2,\",\n\t\t\twant:  nil,\n\t\t\twantS: \"\",\n\t\t\terr:   fmt.Errorf(\"cannot parse array value: unexpected end of object\"),\n\t\t},\n\t\t{\n\t\t\tinput: \"[1,2\",\n\t\t\twant:  nil,\n\t\t\twantS: \"\",\n\t\t\terr:   fmt.Errorf(\"unexpected end of array\"),\n\t\t},\n\t\t{\n\t\t\tinput: \"[1 2]\",\n\t\t\twant:  nil,\n\t\t\twantS: \"2]\",\n\t\t\terr:   fmt.Errorf(\"missing ',' after array value\"),\n\t\t},\n\t}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseArray(tt.input, c, 0)\n\t\t\tif (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif s != tt.wantS {\n\t\t\t\tt.Errorf(\"parseArray() gotS = %v, want %v\", s, tt.wantS)\n\t\t\t}\n\t\t\tif got == nil \u0026\u0026 tt.want == nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got.Type() != tt.want.Type() {\n\t\t\t\tt.Errorf(\"Type mismatch: got %v, want %v\", got.Type(), tt.want.Type())\n\t\t\t}\n\t\t\tif got.Type() == TypeArray {\n\t\t\t\tif len(got.a) != len(tt.want.a) {\n\t\t\t\t\tt.Errorf(\"Array length mismatch: got %v, want %v\", len(got.a), len(tt.want.a))\n\t\t\t\t}\n\t\t\t\tfor j := 0; j \u003c len(got.a); j++ {\n\t\t\t\t\tif got.a[j].Type() != tt.want.a[j].Type() {\n\t\t\t\t\t\tt.Errorf(\"Type mismatch: got %v, want %v\", got.a[j].Type(), tt.want.a[j].Type())\n\t\t\t\t\t}\n\t\t\t\t\tif got.a[j].s != tt.want.a[j].s {\n\t\t\t\t\t\tt.Errorf(\"Value mismatch: got %v, want %v\", got.a[j].s, tt.want.a[j].s)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n","7058efd0c56b597cc2d9223ff1700ad9":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_Visit(t *testing.T) {\n\ttype args struct {\n\t\tf func(key []byte, v *Value)\n\t}\n\ttests := []struct {\n\t\tname string\n\t\to    *Object\n\t\targs args\n\t\twant map[string]string\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\to:    \u0026Object{},\n\t\t\targs: args{\n\t\t\t\tf: func(key []byte, v *Value) {\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: map[string]string{},\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\to: \u0026Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t},\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tf: func(key []byte, v *Value) {\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: map[string]string{\n\t\t\t\t\"key1\": \"value1\",\n\t\t\t\t\"key2\": \"123\",\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := make(map[string]string)\n\t\t\ttt.o.Visit(func(key []byte, v *Value) {\n\t\t\t\tgot[string(key)] = v.s\n\t\t\t})\n\t\t\tif len(got) != len(tt.want) {\n\t\t\t\tt.Errorf(\"Object.Visit() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tfor k, v := range tt.want {\n\t\t\t\tif got[k] != v {\n\t\t\t\t\tt.Errorf(\"Object.Visit() = %v, want %v\", got, tt.want)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","706865992798e2e97cf456a24af456c3":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic strings without escape sequences.\n\t\t{\"hello\", \"hello\"},\n\t\t{\"world\", \"world\"},\n\t\t{\"12345\", \"12345\"},\n\n\t\t// Simple escape sequences.\n\t\t{`\\\"`, `\"`},\n\t\t{`\\\\`, `\\`},\n\t\t{`\\/`, `/`},\n\t\t{`\\b`, \"\\b\"},\n\t\t{`\\f`, \"\\f\"},\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\r`, \"\\r\"},\n\t\t{`\\t`, \"\\t\"},\n\n\t\t// Unicode escape sequences.\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A9`, \"¬©\"},\n\t\t{`\\u20AC`, \"‚Ç¨\"},\n\t\t{`\\uD83D\\uDE02`, \"üòÇ\"}, // Surrogate pair\n\n\t\t// Invalid escape sequences.\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\uD800`, `\\uD800`}, // Unpaired surrogate\n\n\t\t// Mixed strings with valid and invalid escape sequences.\n\t\t{`hello\\tworld`, \"hello\\tworld\"},\n\t\t{`\\u00A92023\\x`, \"¬©2023\\x\"},\n\t\t{`\"escaped\\string\"`, `\"escaped\\string\"`},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Input: %q, Expected: %q, Actual: %q\", test.input, test.expected, actual)\n\t\t}\n\t}\n}\n","706e5a0147669f36804cbc0a3f095f5e":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic strings\n\t\t{\"hello\", \"hello\"},\n\t\t{\"world\", \"world\"},\n\n\t\t// Escaped characters\n\t\t{`\\\"`, `\"`},\n\t\t{`\\\\`, `\\`},\n\t\t{`\\/`, `/`},\n\t\t{`\\b`, `\\b`},\n\t\t{`\\f`, \"\\f\"},\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\r`, \"\\r\"},\n\t\t{`\\t`, \"\\t\"},\n\n\t\t// Unicode escape sequences\n\t\t{`\\u0041`, \"A\"},\n\t\t{`\\u00e9`, \"√©\"},\n\t\t{`\\u20ac`, \"‚Ç¨\"},\n\n\t\t// Surrogate pairs\n\t\t{`\\uD83D\\uDE02`, \"üòÇ\"},\n\n\t\t// Invalid escape sequences\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\uD800`, `\\uD800`},\n\t\t{`\\uD800\\u`, `\\uD800\\u`},\n\n\t\t// Mixed strings\n\t\t{`hello\\tworld`, \"hello\\tworld\"},\n\t\t{`\"quoted string\"`, `\"quoted string\"`},\n\t\t{`C:\\Users\\John\\Documents`, `C:\\Users\\John\\Documents`},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}\n","70a38a44496c23ee87fb465becf29b01":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"raw string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"raw string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"12345\",\n\t\t\t},\n\t\t\twant: []byte(\"12345\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"string\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"12345\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"[\\\"string\\\",12345]\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif string(got) != string(tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","71635dd415056a10080843df1cfc642f":"package fastjson\n\nimport \"testing\"\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    string\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\ts:    \"\",\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with leading whitespace\",\n\t\t\ts:    \"  foo\",\n\t\t\twant: \"foo\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with no leading whitespace\",\n\t\t\ts:    \"bar\",\n\t\t\twant: \"bar\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with only whitespace\",\n\t\t\ts:    \" \\t\\n\\r\",\n\t\t\twant: \"\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","7230092514433d8801df7477caa09618":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey   string\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Simple keys\n\t\t{`\"key\": \"value\"`, \"key\", `: \"value\"`, nil},\n\t\t{`\"key_with_underscores\": 123`, \"key_with_underscores\", `: 123`, nil},\n\t\t{`\"123\": \"value\"`, \"123\", `: \"value\"`, nil},\n\n\t\t// Empty key\n\t\t{`\"\": \"value\"`, \"\", `: \"value\"`, nil},\n\n\t\t// Keys with escaped characters (should go to slow path)\n\t\t{`\"key\\\"with\\\\escaped\\\\characters\": \"value\"`, \"\", \"\", nil},\n\n\t\t// Invalid JSON (missing closing quote)\n\t\t{`\"key: \"value\"`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"key`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tkey, tail, err := parseRawKey(tt.input)\n\n\t\t\tif key != tt.key {\n\t\t\t\tt.Errorf(\"expected key %q, got %q\", tt.key, key)\n\t\t\t}\n\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"expected tail %q, got %q\", tt.tail, tail)\n\t\t\t}\n\n\t\t\tif (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) {\n\t\t\t\tt.Errorf(\"expected error %v, got %v\", tt.err, err)\n\t\t\t}\n\t\t})\n\t}\n}","724994c4227fea1f6874c6180fbf74e8":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantObj  string\n\t\twantTail string\n\t\twantErr  string\n\t}{\n\t\t{\n\t\t\tname:     \"empty object\",\n\t\t\tinput:    \"{}\",\n\t\t\twantObj:  `{\"t\":1}`,\n\t\t\twantTail: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"simple object\",\n\t\t\tinput:    `{\"foo\":\"bar\"}`,\n\t\t\twantObj:  `{\"t\":1,\"o\":{\"kvs\":[{\"k\":\"foo\",\"v\":{\"t\":3,\"s\":\"bar\"}}]}}`,\n\t\t\twantTail: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple key-values\",\n\t\t\tinput:    `{\"foo\":\"bar\",\"baz\":123}`,\n\t\t\twantObj:  `{\"t\":1,\"o\":{\"kvs\":[{\"k\":\"foo\",\"v\":{\"t\":3,\"s\":\"bar\"}},{\"k\":\"baz\",\"v\":{\"t\":4,\"s\":\"123\"}}]}}`,\n\t\t\twantTail: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"nested object\",\n\t\t\tinput:    `{\"foo\":{\"bar\":\"baz\"}}`,\n\t\t\twantObj:  `{\"t\":1,\"o\":{\"kvs\":[{\"k\":\"foo\",\"v\":{\"t\":1,\"o\":{\"kvs\":[{\"k\":\"bar\",\"v\":{\"t\":3,\"s\":\"baz\"}}]}}}]}}`,\n\t\t\twantTail: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"missing closing brace\",\n\t\t\tinput:    `{\"foo\":\"bar\"`,\n\t\t\twantErr:  \"missing '}'\",\n\t\t\twantTail: `{\"foo\":\"bar\"`,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing colon\",\n\t\t\tinput:    `{\"foo\"\"bar\"}`,\n\t\t\twantErr:  \"missing ':' after object key\",\n\t\t\twantTail: `{\"foo\"\"bar\"}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing comma\",\n\t\t\tinput:    `{\"foo\":\"bar\" \"baz\":\"qux\"}`,\n\t\t\twantErr:  \"missing ',' after object value\",\n\t\t\twantTail: ` \"baz\":\"qux\"}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid key\",\n\t\t\tinput:    `{foo:\"bar\"}`,\n\t\t\twantErr:  `cannot find opening '\"\" for object key`,\n\t\t\twantTail: `{foo:\"bar\"}`,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgotObj, gotTail, err := parseObject(tt.input, c, 0)\n\n\t\t\tif tt.wantErr != \"\" {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"expected error %q, got nil\", tt.wantErr)\n\t\t\t\t} else if err.Error() != tt.wantErr {\n\t\t\t\t\tt.Errorf(\"expected error %q, got %q\", tt.wantErr, err.Error())\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"expected tail %q, got %q\", tt.wantTail, gotTail)\n\t\t\t}\n\n\t\t\tgotObjStr := fmt.Sprintf(\"%#v\", *gotObj)\n\t\t\tif gotObjStr != tt.wantObj {\n\t\t\t\tt.Errorf(\"expected object\\n%q\\ngot\\n%q\", tt.wantObj, gotObjStr)\n\t\t\t}\n\t\t})\n\t}\n}","728d133d01cc468ecfd0317cc4c69179":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\terr   error\n\t}{\n\t\t// Add test cases here\n\t\t{\n\t\t\tinput: \"null\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tinput: \"true\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tinput: \"false\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tinput: \"123\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tinput: \"-123.456\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-123.456\",\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tinput: `\"hello world\"`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello world\",\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tinput: `{\"key\": \"value\"}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tinput: `[1, \"2\", true]`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tinput: `{\n\t\t\t\t\"key1\": \"value1\",\n\t\t\t\t\"key2\": [1, 2, 3],\n\t\t\t\t\"key3\": {\n\t\t\t\t\t\"key4\": true\n\t\t\t\t}\n\t\t\t}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"key4\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t// Add more test cases for different scenarios\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i+1), func(t *testing.T) {\n\t\t\tp := Parser{}\n\t\t\tgot, err := p.Parse(tt.input)\n\t\t\tif fmt.Sprintf(\"%v\", err) != fmt.Sprintf(\"%v\", tt.err) {\n\t\t\t\tt.Errorf(\"got error %v, want %v\", err, tt.err)\n\t\t\t}\n\t\t\tif got != nil \u0026\u0026 got.Type().String() != tt.want.Type().String() {\n\t\t\t\tt.Errorf(\"got type %v, want %v\", got.Type().String(), tt.want.Type().String())\n\t\t\t}\n\t\t})\n\t}\n}","73637f7e1e8efbc7668ced1b35bb1c13":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"raw string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"raw string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"12345\",\n\t\t\t},\n\t\t\twant: []byte(\"12345\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"string\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"12345\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"[\\\"string\\\",12345]\"),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"string\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"string\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"number\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"12345\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"{\\\"string\\\":\\\"string\\\",\\\"number\\\":12345}\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif string(got) != string(tt.want) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %v, want %v\", string(got), string(tt.want))\n\t\t\t}\n\t\t})\n\t}\n}","73e81573c1097aa5d3bc8873077efe2d":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic escapes\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\t`, \"\\t\"},\n\t\t{`\\\\`, \"\\\\\"},\n\t\t{`\\\"`, \"\\\"\"},\n\t\t{`\\/`, \"/\"},\n\n\t\t// Unicode escapes\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A9`, \"¬©\"},\n\t\t{`\\u20AC`, \"‚Ç¨\"},\n\n\t\t// Surrogate pairs\n\t\t{`\\uD83D\\uDE02`, \"üòÇ\"},\n\n\t\t// Invalid escapes\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\uD800`, `\\uD800`}, // Invalid surrogate pair\n\t\t{`\\uD800\\u1234`, `\\uD800\\u1234`}, // Invalid surrogate pair\n\n\t\t// Mixed escapes\n\t\t{`Hello\\tworld\\n`, \"Hello\\tworld\\n\"},\n\t\t{`Copyright \\u00A9 2023`, \"Copyright ¬© 2023\"},\n\n\t\t// No escapes\n\t\t{`Hello, world!`, \"Hello, world!\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}","73e9cfe5e08926c7976321a2a9cd9a45":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Empty string\n\t\t{\"\", nil, \"\", fmt.Errorf(\"cannot parse empty string\")},\n\t\t// Invalid JSON\n\t\t{\"{invalid}\", nil, \"\", fmt.Errorf(\"cannot parse object: invalid character 'i' looking for beginning of value\")},\n\t\t// Simple object\n\t\t{`{\"key\": \"value\"}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{t: typeRawString, s: \"value\"}}}}}, \"\", nil},\n\t\t// Simple array\n\t\t{`[1, \"two\", true]`, \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: typeRawString, s: \"two\"}, {t: TypeTrue}}}, \"\", nil},\n\t\t// String with escaped characters\n\t\t{`\"hello\\nworld\"`, \u0026Value{t: typeRawString, s: \"hello\\nworld\"}, \"\", nil},\n\t\t// True boolean\n\t\t{\"true\", valueTrue, \"\", nil},\n\t\t// False boolean\n\t\t{\"false\", valueFalse, \"\", nil},\n\t\t// Null value\n\t\t{\"null\", valueNull, \"\", nil},\n\t\t// Number\n\t\t{\"12345\", \u0026Value{t: TypeNumber, s: \"12345\"}, \"\", nil},\n\t\t// String with tail\n\t\t{`\"hello\" world`, \u0026Value{t: typeRawString, s: \"hello\"}, \" world\", nil},\n\t\t// NaN value\n\t\t{\"NaN\", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"\", nil},\n\t}\n\n\tc := \u0026cache{}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tgot, tail, err := parseValue(tt.input, c, 0)\n\t\t\tif fmt.Sprintf(\"%v\", err) != fmt.Sprintf(\"%v\", tt.err) {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, want %v\", tt.input, err, tt.err)\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"parseValue(%q) tail = %q, want %q\", tt.input, tail, tt.tail)\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", tt.input, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase typeRawString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\treturn v1.t == v2.t\n\t}\n}\n","7401629604b0f70bcbc19d96baaedff5":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic escapes\n\t\t{`\\b`, \"\\b\"},\n\t\t{`\\f`, \"\\f\"},\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\r`, \"\\r\"},\n\t\t{`\\t`, \"\\t\"},\n\t\t{`\\\\`, `\\`},\n\t\t{`\\\"`, `\"`},\n\t\t{`\\/`, `/`},\n\n\t\t// Unicode escapes\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A0`, \"\\u00A0\"},\n\t\t{`\\u20AC`, \"\\u20AC\"},\n\t\t{`\\uD83D\\uDE00`, \"\\U0001F600\"}, // Surrogate pair\n\n\t\t// Invalid escapes\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u`, `\\u`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\uD800`, `\\uD800`}, // Unpaired surrogate\n\t\t{`\\uDFFF`, `\\uDFFF`}, // Unpaired surrogate\n\n\t\t// Mixed content\n\t\t{`Hello\\tworld\\n`, \"Hello\\tworld\\n\"},\n\t\t{`\"This is a string with \\\\backslashes\\\\\"`, `\"This is a string with \\\\backslashes\\\\\"`},\n\t\t{`{\"key\": \"value with \\u00A9 copyright symbol\"}`, `{\"key\": \"value with ¬© copyright symbol\"}`},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}","74d7cae76125b8d48ca978cf0f627552":"package fastjson\n\nimport \"testing\"\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"  foo\", \"foo\"},\n\t\t{\"\\n\\n\\nfoo\", \"foo\"},\n\t\t{\"\\t\\t\\tfoo\", \"foo\"},\n\t\t{\"\\r\\r\\rfoo\", \"foo\"},\n\t\t{\"foo  \", \"foo  \"},\n\t\t{\"foo\\n\\n\\n\", \"foo\\n\\n\\n\"},\n\t\t{\"foo\\t\\t\\t\", \"foo\\t\\t\\t\"},\n\t\t{\"foo\\r\\r\\r\", \"foo\\r\\r\\r\"},\n\t\t{\"  foo  \", \"foo  \"},\n\t\t{\"\\n\\n\\nfoo\\n\\n\\n\", \"foo\\n\\n\\n\"},\n\t\t{\"\\t\\t\\tfoo\\t\\t\\t\", \"foo\\t\\t\\t\"},\n\t\t{\"\\r\\r\\rfoo\\r\\r\\r\", \"foo\\r\\r\\r\"},\n\t\t{\"\", \"\"},\n\t\t{\"\\n\", \"\"},\n\t\t{\"\\t\", \"\"},\n\t\t{\"\\r\", \"\"},\n\t\t{\" \", \"\"},\n\t\t{\"\\n\\t\\r \", \"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := skipWSSlow(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"skipWSSlow('%s') = '%s', expected '%s'\", test.input, actual, test.expected)\n\t\t}\n\t}\n}","753a7a1e99cdb1733921791f2452aeb5":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ts     string\n\t\terr   error\n\t}{\n\t\t// Empty array\n\t\t{\"[]\", \u0026Value{t: TypeArray, a: []*Value{}}, \"\", nil},\n\t\t// Simple array\n\t\t{\"[1,2,3]\", \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t}}, \"\", nil},\n\t\t// Array with spaces\n\t\t{\" [ 1 , 2 , 3 ] \", \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t}}, \"\", nil},\n\t\t// Nested array\n\t\t{\"[[1,2],[3,4]]\", \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t}},\n\t\t\t{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t{t: TypeNumber, s: \"4\"},\n\t\t\t}},\n\t\t}}, \"\", nil},\n\t\t// Invalid array - missing closing bracket\n\t\t{\"[1,2,3\", nil, \"\", fmt.Errorf(\"unexpected end of array\")},\n\t\t// Invalid array - missing comma\n\t\t{\"[1 2 3]\", nil, \" 2 3]\", fmt.Errorf(\"missing ',' after array value\")},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d:%v\", i, tt.input), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseArray(tt.input, c, 0)\n\n\t\t\tif got != nil \u0026\u0026 tt.want != nil \u0026\u0026 got.t != tt.want.t {\n\t\t\t\tt.Errorf(\"parseArray() type mismatch: got %v, want %v\", got.t, tt.want.t)\n\t\t\t}\n\n\t\t\tif got != nil \u0026\u0026 tt.want != nil \u0026\u0026 len(got.a) != len(tt.want.a) {\n\t\t\t\tt.Errorf(\"parseArray() array length mismatch: got %v, want %v\", len(got.a), len(tt.want.a))\n\t\t\t}\n\n\t\t\tif err != nil \u0026\u0026 tt.err == nil {\n\t\t\t\tt.Errorf(\"parseArray() unexpected error: %v\", err)\n\t\t\t} else if err == nil \u0026\u0026 tt.err != nil {\n\t\t\t\tt.Errorf(\"parseArray() expected error; got nil\")\n\t\t\t} else if err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error() {\n\t\t\t\tt.Errorf(\"parseArray() error mismatch: got %v, want %v\", err, tt.err)\n\t\t\t}\n\n\t\t\tif s != tt.s {\n\t\t\t\tt.Errorf(\"parseArray() remaining string mismatch: got %q, want %q\", s, tt.s)\n\t\t\t}\n\t\t})\n\t}\n}","75777daeca0c7bd8df52b21d1b780eff":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"raw string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"raw string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"12345\",\n\t\t\t},\n\t\t\twant: []byte(\"12345\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"string\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"12345\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"[\\\"string\\\",12345]\"),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"string\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"string\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"number\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"12345\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"{\\\"string\\\":\\\"string\\\",\\\"number\\\":12345}\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif string(got) != string(tt.want) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %v, want %v\", string(got), string(tt.want))\n\t\t\t}\n\t\t})\n\t}\n}\n","7687ecf07cfcfde6c5776872c4fb9d33":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput       string\n\t\twantValue   *Value\n\t\twantTail    string\n\t\twantErr     bool\n\t\twantErrText string\n\t}{\n\t\t// Empty input\n\t\t{\"\", nil, \"\", true, \"cannot parse empty string\"},\n\n\t\t// Invalid JSON\n\t\t{\"{\", nil, \"\", true, \"cannot parse object\"},\n\t\t{\"[\", nil, \"\", true, \"cannot parse array\"},\n\t\t{\"\\\"unterminated string\", nil, \"\", true, \"cannot parse string\"},\n\t\t{\"inva\\\\lid\", nil, \"\", true, \"unexpected value found: \\\"inva\\\\lid\\\"\"},\n\n\t\t// Valid JSON values\n\t\t{\"null\", valueNull, \"\", false, \"\"},\n\t\t{\"true\", valueTrue, \"\", false, \"\"},\n\t\t{\"false\", valueFalse, \"\", false, \"\"},\n\t\t{\"\\\"hello\\\"\", \u0026Value{t: typeRawString, s: \"hello\"}, \"\", false, \"\"},\n\t\t{\"123\", \u0026Value{t: TypeNumber, s: \"123\"}, \"\", false, \"\"},\n\t\t{\"-123.456\", \u0026Value{t: TypeNumber, s: \"-123.456\"}, \"\", false, \"\"},\n\t\t{\"NaN\", \u0026Value{t: TypeNumber, s: \"\"}, \"\", false, \"\"},\n\n\t\t// Whitespace handling\n\t\t{\"  null\", valueNull, \"\", false, \"\"},\n\t\t{\"null  \", valueNull, \"  \", false, \"\"},\n\n\t\t// Trailing data\n\t\t{\"nullxxx\", valueNull, \"xxx\", false, \"\"},\n\n\t\t// Nested structures\n\t\t{\"{\\\"foo\\\":\\\"bar\\\"}\", \u0026Value{t: TypeObject}, \"\", false, \"\"},\n\t\t{\"[1,2,3]\", \u0026Value{t: TypeArray}, \"\", false, \"\"},\n\t}\n\n\tc := \u0026cache{}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tgotValue, gotTail, gotErr := parseValue(tt.input, c, 0)\n\n\t\t\tif (gotErr != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", gotErr, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif gotErr != nil \u0026\u0026 tt.wantErrText != \"\" \u0026\u0026 gotErr.Error() != tt.wantErrText {\n\t\t\t\tt.Errorf(\"parseValue() error text = %v, want error text %v\", gotErr.Error(), tt.wantErrText)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseValue() gotTail = %v, want %v\", gotTail, tt.wantTail)\n\t\t\t}\n\n\t\t\tif !equalValues(gotValue, tt.wantValue) {\n\t\t\t\tt.Errorf(\"parseValue() gotValue = %v, want %v\", gotValue, tt.wantValue)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.t == typeRawString {\n\t\treturn v1.s == v2.s\n\t}\n\tif v1.t == TypeNumber {\n\t\treturn v1.s == v2.s\n\t}\n\t// Add more type checks as needed\n\treturn true\n}","76c88dee15d18184fd5aae3fde728d6e":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  string\n\t\twant1 string\n\t\terr   error\n\t}{\n\t\t// Test cases here\n\t\t{\n\t\t\tinput: `\"test\"`,\n\t\t\twant:  \"test\",\n\t\t\twant1: \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `\"test\\\":\\\"value\"`,\n\t\t\twant:  \"test\",\n\t\t\twant1: \":\\\"value\\\"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `\"test\\\\\"test\":\"value\"`,\n\t\t\twant:  \"test\\\\\\\"test\",\n\t\t\twant1: \":\\\"value\\\"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `\"test\\\\\"test\"`,\n\t\t\twant:  \"test\\\\\\\"test\",\n\t\t\twant1: \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `\"test\"trailing`,\n\t\t\twant:  \"test\",\n\t\t\twant1: \"trailing\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `missing quote`,\n\t\t\twant:  \"\",\n\t\t\twant1: \"\",\n\t\t\terr:   fmt.Errorf(`missing closing '\"'`),\n\t\t},\n\t}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.input)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t\tif err != nil \u0026\u0026 tt.err == nil {\n\t\t\t\tt.Errorf(\"parseRawString() got unexpected error: %v\", err)\n\t\t\t} else if err == nil \u0026\u0026 tt.err != nil {\n\t\t\t\tt.Errorf(\"parseRawString() expected error: %v, but got nil\", tt.err)\n\t\t\t} else if err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error() {\n\t\t\t\tt.Errorf(\"parseRawString() got error: %v, want %v\", err, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}","76f5fd995e906a4073d48604a7268b3e":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Test cases here\n\t\t{\n\t\t\tinput: `{}`,\n\t\t\twant:  \u0026Value{t: TypeObject, o: Object{}},\n\t\t\ttail:  \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `[]`,\n\t\t\twant:  \u0026Value{t: TypeArray, a: []*Value{}},\n\t\t\ttail:  \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `\"test\"`,\n\t\t\twant:  \u0026Value{t: typeRawString, s: \"test\"},\n\t\t\ttail:  \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `true`,\n\t\t\twant:  valueTrue,\n\t\t\ttail:  \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `false`,\n\t\t\twant:  valueFalse,\n\t\t\ttail:  \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `null`,\n\t\t\twant:  valueNull,\n\t\t\ttail:  \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `123`,\n\t\t\twant:  \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\ttail:  \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `-123`,\n\t\t\twant:  \u0026Value{t: TypeNumber, s: \"-123\"},\n\t\t\ttail:  \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `123.456`,\n\t\t\twant:  \u0026Value{t: TypeNumber, s: \"123.456\"},\n\t\t\ttail:  \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `\"test\"xxx`,\n\t\t\twant:  \u0026Value{t: typeRawString, s: \"test\"},\n\t\t\ttail:  \"xxx\",\n\t\t\terr:   nil,\n\t\t},\n\t\t// Error cases\n\t\t{\n\t\t\tinput: ``,\n\t\t\twant:  nil,\n\t\t\ttail:  \"\",\n\t\t\terr:   fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tinput: `{`,\n\t\t\twant:  nil,\n\t\t\ttail:  \"{\",\n\t\t\terr:   fmt.Errorf(\"cannot parse object: missing '}'\"),\n\t\t},\n\t\t{\n\t\t\tinput: `[`,\n\t\t\twant:  nil,\n\t\t\ttail:  \"[\",\n\t\t\terr:   fmt.Errorf(\"cannot parse array: missing ']'\"),\n\t\t},\n\t\t{\n\t\t\tinput: `\"test`,\n\t\t\twant:  nil,\n\t\t\ttail:  `\"test`,\n\t\t\terr:   fmt.Errorf(\"cannot parse string: missing '\\\"'\"),\n\t\t},\n\t\t{\n\t\t\tinput: `tru`,\n\t\t\twant:  nil,\n\t\t\ttail:  \"tru\",\n\t\t\terr:   fmt.Errorf(\"unexpected value found: %q\", \"tru\"),\n\t\t},\n\t\t{\n\t\t\tinput: `fals`,\n\t\t\twant:  nil,\n\t\t\ttail:  \"fals\",\n\t\t\terr:   fmt.Errorf(\"unexpected value found: %q\", \"fals\"),\n\t\t},\n\t\t{\n\t\t\tinput: `nul`,\n\t\t\twant:  nil,\n\t\t\ttail:  \"nul\",\n\t\t\terr:   fmt.Errorf(\"unexpected value found: %q\", \"nul\"),\n\t\t},\n\t\t{\n\t\t\tinput: `123x`,\n\t\t\twant:  \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\ttail:  \"x\",\n\t\t\terr:   nil,\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, tail, err := parseValue(tt.input, c, 0)\n\n\t\t\tif tt.err != nil {\n\t\t\t\tif err == nil || err.Error() != tt.err.Error() {\n\t\t\t\t\tt.Errorf(\"Expected error %v, got %v\", tt.err, err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"Expected tail %q, got %q\", tt.tail, tail)\n\t\t\t}\n\n\t\t\tif got.t != tt.want.t {\n\t\t\t\tt.Errorf(\"Expected type %v, got %v\", tt.want.t, got.t)\n\t\t\t}\n\n\t\t\tif got.s != tt.want.s {\n\t\t\t\tt.Errorf(\"Expected value %q, got %q\", tt.want.s, got.s)\n\t\t\t}\n\t\t})\n\t}\n}\n","77bce0e6590e4b18937b930f84c13ca1":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey   string\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t{`\"foo\"bar`, \"foo\", \"bar\", nil},\n\t\t{`\"fo\\o\"bar`, \"fo\\o\", \"bar\", nil},\n\t\t{`\"foo\\\"bar\"baz`, `foo\"bar`, \"baz\", nil},\n\t\t{`\"foo\\\\\"bar`, `foo\\\\`, \"bar\", nil},\n\t\t{`\"foo\"bar`, \"foo\", \"bar\", nil},\n\t\t{`\"foo`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo\\\"`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"fo\\\\\\\"o\"bar`, `fo\\\"o`, \"bar\", nil},\n\t}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tkey, tail, err := parseRawString(tt.input)\n\t\t\tif fmt.Sprintf(\"%v\", tt.err) != fmt.Sprintf(\"%v\", err) {\n\t\t\t\tt.Errorf(\"expected err: %v, got: %v\", tt.err, err)\n\t\t\t}\n\t\t\tif key != tt.key {\n\t\t\t\tt.Errorf(\"expected key: %q, got: %q\", tt.key, key)\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"expected tail: %q, got: %q\", tt.tail, tail)\n\t\t\t}\n\t\t})\n\t}\n}","782108c696836cbdae2916bc481df792":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ts     string\n\t\terr   error\n\t}{\n\t\t// Empty array\n\t\t{\"[]\", \u0026Value{t: TypeArray, a: []*Value{}}, \"\", nil},\n\n\t\t// Simple array\n\t\t{\"[1,2,3]\", \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t}}, \"\", nil},\n\n\t\t// Array with different types\n\t\t{\"[1,\\\"foo\\\",true,null]\", \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t{t: TypeString, s: \"foo\"},\n\t\t\t{t: TypeTrue},\n\t\t\t{t: TypeNull},\n\t\t}}, \"\", nil},\n\n\t\t// Nested array\n\t\t{\"[[1,2],[3,4]]\", \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t}},\n\t\t\t{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t{t: TypeNumber, s: \"4\"},\n\t\t\t}},\n\t\t}}, \"\", nil},\n\n\t\t// Array with whitespace\n\t\t{\" [ 1 , 2 , 3 ] \", \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t}}, \" \", nil},\n\n\t\t// Invalid array - missing closing bracket\n\t\t{\"[1,2,3\", nil, \"\", fmt.Errorf(\"missing ']'\")},\n\n\t\t// Invalid array - missing comma\n\t\t{\"[1 2 3]\", nil, \" 2 3]\", fmt.Errorf(\"missing ',' after array value\")},\n\n\t\t// Invalid array - unexpected end\n\t\t{\"[1,\", nil, \"\", fmt.Errorf(\"unexpected end of array\")},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test%d\", i+1), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseArray(tt.input, c, 0)\n\n\t\t\tif err != nil \u0026\u0026 tt.err == nil {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, want nil\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif err == nil \u0026\u0026 tt.err != nil {\n\t\t\t\tt.Errorf(\"parseArray() error = nil, want %v\", tt.err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error() {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, want %v\", err, tt.err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif s != tt.s {\n\t\t\t\tt.Errorf(\"parseArray() s = %v, want %v\", s, tt.s)\n\t\t\t}\n\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.s != v2.s {\n\t\treturn false\n\t}\n\tif len(v1.a) != len(v2.a) {\n\t\treturn false\n\t}\n\tfor i := range v1.a {\n\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","786947ac52c4718b1416b399695b5978":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ts     string\n\t\terr   error\n\t}{\n\t\t// TODO: Add test cases.\n\t\t{\n\t\t\tinput: \"[]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tinput: \"[1,2,3]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tinput: \"[1, 2,   3]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tinput: \" [1,2,3]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tinput: \"[1,2,3] \",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \" \",\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tinput: `[\n\t\t\t\t1,\n\t\t\t\t2,\n\t\t\t\t3\n\t\t\t]`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tinput: `[\n\t\t\t\t1,\n\t\t\t\t\"hello\",\n\t\t\t\ttrue\n\t\t\t]`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeString, s: \"hello\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tinput: \"[1 2,3]\",\n\t\t\twant:  nil,\n\t\t\ts:     \"2,3]\",\n\t\t\terr:   fmt.Errorf(\"cannot parse array value: missing ',' after array value\"),\n\t\t},\n\t}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test %d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseArray(tt.input, c, 0)\n\t\t\tif (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif s != tt.s {\n\t\t\t\tt.Errorf(\"parseArray() s = %v, want %v\", s, tt.s)\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.s != v2.s {\n\t\treturn false\n\t}\n\tif len(v1.a) != len(v2.a) {\n\t\treturn false\n\t}\n\tfor i := range v1.a {\n\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","798be09ae942c932c643af314a791107":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic strings\n\t\t{\"hello\", \"hello\"},\n\t\t{\"world\", \"world\"},\n\n\t\t// Escaped characters\n\t\t{`\\\"hello\\\"`, `\"hello\"`},\n\t\t{`\\\\world\\\\`, `\\world\\`},\n\t\t{`\\bfoo\\tbar\\nbaz`, \"\\bfoo\\tbar\\nbaz\"},\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A0`, \"\\u00A0\"}, // Non-ASCII character\n\n\t\t// Invalid escape sequences\n\t\t{`\\z`, `\\z`},\n\t\t{`\\u002`, `\\u002`},\n\t\t{`\\u002x`, `\\u002x`},\n\n\t\t// Surrogate pairs\n\t\t{`\\uD83D\\uDE02`, \"\\U0001F602\"}, // FACE WITH TEARS OF JOY\n\n\t\t// Mixed valid and invalid sequences\n\t\t{`hello\\t\\\"world\\\"\\\\\\x`, \"hello\\t\\\"world\\\"\\\\\\x\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}\n","79d8078e796dcbcc4dd823f358ec52aa":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ts     string\n\t\terr   error\n\t}{\n\t\t// Empty input.\n\t\t{\"\", nil, \"\", fmt.Errorf(\"missing ']'\")},\n\t\t// Empty array.\n\t\t{\"[]\", \u0026Value{t: TypeArray, a: []*Value{}}, \"\", nil},\n\t\t// Simple array.\n\t\t{\"[1,2,3]\", \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}}, \"\", nil},\n\t\t// Array with spaces.\n\t\t{\" [ 1 , 2 , 3 ] \", \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}}, \"\", nil},\n\t\t// Array with nested arrays.\n\t\t{\"[[1,2],[3,4]]\", \u0026Value{t: TypeArray, a: []*Value{{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}}}, {t: TypeArray, a: []*Value{{t: TypeNumber, s: \"3\"}, {t: TypeNumber, s: \"4\"}}}}}, \"\", nil},\n\t\t// Array with strings.\n\t\t{`[\"hello\",\"world\"]`, \u0026Value{t: TypeArray, a: []*Value{{t: TypeString, s: \"hello\"}, {t: TypeString, s: \"world\"}}}, \"\", nil},\n\t\t// Invalid array - missing ']'.\n\t\t{\"[1,2,3\", nil, \"1,2,3\", fmt.Errorf(\"unexpected end of array\")},\n\t\t// Invalid array - missing ','.\n\t\t{\"[1,2 3]\", nil, \" 3]\", fmt.Errorf(\"missing ',' after array value\")},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseArray(tt.input, c, 0)\n\n\t\t\tif (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err == nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"Test %d - Error: expected %v, got %v\", i, tt.err, err)\n\t\t\t}\n\t\t\tif s != tt.s {\n\t\t\t\tt.Errorf(\"Test %d - Remaining string: expected %q, got %q\", i, tt.s, s)\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"Test %d - Values are not equal:\\nexpected: %v\\ngot:      %v\", i, tt.want, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.t == TypeArray {\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\treturn v1.s == v2.s\n}","7a92821e0adc82cb85ceea8247358d8a":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\tsleft string\n\t\terr   error\n\t}{\n\t\t// Empty object\n\t\t{\n\t\t\tinput: `{}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\tsleft: \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t// Single key-value pair\n\t\t{\n\t\t\tinput: `{\"key\": \"value\"}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\tsleft: \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t// Multiple key-value pairs\n\t\t{\n\t\t\tinput: `{\"key1\": \"value1\", \"key2\": 123, \"key3\": true}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\tsleft: \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t// With whitespace\n\t\t{\n\t\t\tinput: ` { \"key1\" : \"value1\" , \"key2\" : 123 , \"key3\" : true } `,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\tsleft: \" \",\n\t\t\terr:   nil,\n\t\t},\n\t\t// Invalid JSON: Missing closing brace\n\t\t{\n\t\t\tinput: `{\"key\": \"value\"`,\n\t\t\twant:  nil,\n\t\t\tsleft: \"\",\n\t\t\terr:   fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t\t// Invalid JSON: Missing colon\n\t\t{\n\t\t\tinput: `{\"key\" \"value\"}`,\n\t\t\twant:  nil,\n\t\t\tsleft: \"\",\n\t\t\terr:   fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t\t// Invalid JSON: Missing comma\n\t\t{\n\t\t\tinput: `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twant:  nil,\n\t\t\tsleft: \"\",\n\t\t\terr:   fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i+1), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, sleft, err := parseObject(tt.input, c, 0)\n\n\t\t\tif err != nil {\n\t\t\t\tif tt.err == nil {\n\t\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t\t} else if err.Error() != tt.err.Error() {\n\t\t\t\t\tt.Errorf(\"error mismatch: got %v, want %v\", err, tt.err)\n\t\t\t\t}\n\t\t\t} else if tt.err != nil {\n\t\t\t\tt.Errorf(\"expected error: %v, got nil\", tt.err)\n\t\t\t}\n\n\t\t\tif sleft != tt.sleft {\n\t\t\t\tt.Errorf(\"sleft mismatch: got %q, want %q\", sleft, tt.sleft)\n\t\t\t}\n\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"value mismatch:\\ngot:  %+v\\nwant: %+v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.s != v2.s {\n\t\treturn false\n\t}\n\tif v1.t == TypeObject {\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t}\n\treturn true\n}","7ae139e99d6004412db527f5cec86730":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey   string\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Simple keys\n\t\t{`\"key\":1`, \"key\", `:1`, nil},\n\t\t{`\"key\": \"value\"`, \"key\", `: \"value\"`, nil},\n\t\t{`\"key\" : 1`, \"key\", ` : 1`, nil},\n\n\t\t// Empty key\n\t\t{`\"\":1`, \"\", `:1`, nil},\n\n\t\t// No closing quote\n\t\t{`\"key:1`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\n\t\t// Escaped quotes within the key\n\t\t{`\"ke\\\"y\":1`, \"\", \"\", nil},\n\n\t\t// Key with spaces\n\t\t{`\"key with spaces\":1`, \"\", \"\", nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tkey, tail, err := parseRawKey(tt.input)\n\t\t\tif key != tt.key || tail != tt.tail || (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) {\n\t\t\t\tt.Errorf(\"Input: %s\\nExpected: %s, %s, %v\\nGot: %s, %s, %v\", tt.input, tt.key, tt.tail, tt.err, key, tail, err)\n\t\t\t}\n\t\t})\n\t}\n}","7b0eb03b9c3c5c2a59058e32333f3f39":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey   string\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Simple keys\n\t\t{`\"key\": \"value\"`, \"key\", `: \"value\"`, nil},\n\t\t{`\"key_with_underscore\": 123`, \"key_with_underscore\", `: 123`, nil},\n\t\t{`\"123\": \"value\"`, \"123\", `: \"value\"`, nil},\n\n\t\t// Empty key\n\t\t{`\"\": \"value\"`, \"\", `: \"value\"`, nil},\n\n\t\t// Keys with escaped quotes\n\t\t// Note: parseRawKey should not handle escaped quotes, it should fall back to parseRawString\n\t\t{`\"key\\\"with\\\\escaped\\\\quotes\": \"value\"`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\n\t\t// Invalid input\n\t\t{`\"key: \"value\"`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`key\": \"value\"`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"key\" \"value\"`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d:%s\", i, tt.input), func(t *testing.T) {\n\t\t\tkey, tail, err := parseRawKey(tt.input)\n\n\t\t\tif key != tt.key {\n\t\t\t\tt.Errorf(\"expected key %q, got %q\", tt.key, key)\n\t\t\t}\n\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"expected tail %q, got %q\", tt.tail, tail)\n\t\t\t}\n\n\t\t\tif (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err == nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"expected error %v, got %v\", tt.err, err)\n\t\t\t}\n\t\t})\n\t}\n}","7be990ce79cb1a8b124a128d9ab3387a":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  string\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t{\n\t\t\tinput: `\"foo\"bar`,\n\t\t\twant:  \"foo\",\n\t\t\ttail:  \"bar\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `\"foo`,\n\t\t\twant:  \"\",\n\t\t\ttail:  \"\",\n\t\t\terr:   fmt.Errorf(`missing closing '\"'`),\n\t\t},\n\t\t{\n\t\t\tinput: `foo\"bar`,\n\t\t\twant:  \"foo\\\"bar\",\n\t\t\ttail:  \"\",\n\t\t\terr:   fmt.Errorf(`missing closing '\"'`),\n\t\t},\n\t\t{\n\t\t\tinput: `\"fo\\o\"bar`,\n\t\t\twant:  \"fo\\\\o\",\n\t\t\ttail:  \"bar\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `\"fo\\\\\"bar`,\n\t\t\twant:  \"fo\\\\\",\n\t\t\ttail:  \"bar\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `\"fo\\\"bar`,\n\t\t\twant:  \"\",\n\t\t\ttail:  \"\",\n\t\t\terr:   fmt.Errorf(`missing closing '\"'`),\n\t\t},\n\t}\n\tfor i, tt := range tests {\n\t\tgot, tail, err := parseRawString(tt.input)\n\t\tif got != tt.want || tail != tt.tail || !equalError(err, tt.err) {\n\t\t\tt.Errorf(\"%d. parseRawString(%q) = %q, %q, %v; want %q, %q, %v\", i, tt.input, got, tail, err, tt.want, tt.tail, tt.err)\n\t\t}\n\t}\n}\n\n// equalError reports whether errors a and b are considered equal.\n// They're equal if both are nil, or both are not nil and a.Error() == b.Error().\nfunc equalError(a, b error) bool {\n\treturn (a == nil \u0026\u0026 b == nil) || (a != nil \u0026\u0026 b != nil \u0026\u0026 a.Error() == b.Error())\n}","7c09caf0ea87aa843bac1becd45191fc":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Test cases here\n\t\t{\n\t\t\tinput: \"123\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\ttail: \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `\"abc\"`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"abc\",\n\t\t\t},\n\t\t\ttail: \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: \"true\",\n\t\t\twant:  valueTrue,\n\t\t\ttail:  \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: \"false\",\n\t\t\twant:  valueFalse,\n\t\t\ttail:  \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: \"null\",\n\t\t\twant:  valueNull,\n\t\t\ttail:  \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: \"nullx\",\n\t\t\twant:  nil,\n\t\t\ttail:  \"nullx\",\n\t\t\terr:   fmt.Errorf(\"unexpected value found: %q\", \"nullx\"),\n\t\t},\n\t\t{\n\t\t\tinput: \"NaN\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\ttail: \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: \"123.456\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\ttail: \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: \"  123 \",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\ttail: \" \",\n\t\t\terr:   nil,\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, tail, err := parseValue(tt.input, c, 0)\n\n\t\t\tif got != nil \u0026\u0026 tt.want != nil \u0026\u0026 got.t != tt.want.t {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", tt.input, got.t, tt.want.t)\n\t\t\t}\n\t\t\tif got != nil \u0026\u0026 tt.want != nil \u0026\u0026 got.s != tt.want.s {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", tt.input, got.s, tt.want.s)\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", tt.input, tail, tt.tail)\n\t\t\t}\n\t\t\tif err != nil \u0026\u0026 tt.err == nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, wantErr %v\", tt.input, err, tt.err)\n\t\t\t}\n\t\t\tif err == nil \u0026\u0026 tt.err != nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, wantErr %v\", tt.input, err, tt.err)\n\t\t\t}\n\t\t\tif err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error() {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, wantErr %v\", tt.input, err, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}","7ca549d288828fbe5328bbd86e0db62a":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput  string\n\t\texpect string\n\t\tremain string\n\t\terr    error\n\t}{\n\t\t{`\"foo\"bar`, `foo`, `bar`, nil},\n\t\t{`\"foo\"`, `foo`, ``, nil},\n\t\t{`\"fo\\\"o\"bar`, `fo\\\"o`, `bar`, nil},\n\t\t{`\"fo\\\\o\"bar`, `fo\\\\o`, `bar`, nil},\n\t\t{`\"foo`, ``, ``, fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"fo\\o\"bar`, ``, ``, fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo\"bar\"baz`, `foo`, `bar\"baz`, nil},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test-%d-%s\", i, tc.input), func(t *testing.T) {\n\t\t\tresult, remain, err := parseRawString(tc.input)\n\t\t\tif tc.err != nil {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"Expected error %v, got nil\", tc.err)\n\t\t\t\t} else if err.Error() != tc.err.Error() {\n\t\t\t\t\tt.Errorf(\"Expected error %v, got %v\", tc.err, err)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif result != tc.expect {\n\t\t\t\tt.Errorf(\"Expected result %q, got %q\", tc.expect, result)\n\t\t\t}\n\t\t\tif remain != tc.remain {\n\t\t\t\tt.Errorf(\"Expected remain %q, got %q\", tc.remain, remain)\n\t\t\t}\n\t\t})\n\t}\n}","7dad3b1c46ec53aac2f667a5953c1862":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic escapes\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\t`, \"\\t\"},\n\t\t{`\\\\`, \"\\\\\"},\n\t\t{`\\\"`, \"\\\"\"},\n\t\t{`\\/`, \"/\"},\n\n\t\t// Unicode escapes\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A0`, \"\\u00A0\"},\n\t\t{`\\uFFFF`, \"\\uFFFF\"},\n\n\t\t// Surrogate pairs\n\t\t{`\\uD83D\\uDE02`, \"\\U0001F602\"},\n\n\t\t// Invalid escapes\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\uD800`, `\\uD800`},\n\t\t{`\\uD800\\u`, `\\uD800\\u`},\n\n\t\t// Mixed content\n\t\t{`Hello\\tworld\\n`, \"Hello\\tworld\\n\"},\n\t\t{`\"This is a string with \\\\backslashes\\\\\"`, \"\\\"This is a string with \\\\backslashes\\\\\\\"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}","7db1f88e3c96395375451e83de16c5b6":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantNum  string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Valid numbers\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"123.456\", \"123.456\", \"\", nil},\n\t\t{\"1.2e3\", \"1.2e3\", \"\", nil},\n\t\t{\"1.2E-3\", \"1.2E-3\", \"\", nil},\n\t\t{\"+123\", \"+123\", \"\", nil},\n\n\t\t// Valid numbers with trailing characters\n\t\t{\"123a\", \"123\", \"a\", nil},\n\t\t{\"-123b\", \"-123\", \"b\", nil},\n\t\t{\"123.456c\", \"123.456\", \"c\", nil},\n\n\t\t// Valid inf and nan\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"+inf\", \"+inf\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"InF\", \"InF\", \"\", nil},\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"+nan\", \"+nan\", \"\", nil},\n\t\t{\"-nan\", \"-nan\", \"\", nil},\n\t\t{\"nAn\", \"nAn\", \"\", nil},\n\t\t{\"infx\", \"inf\", \"x\", nil},\n\t\t{\"nanx\", \"nan\", \"x\", nil},\n\n\t\t// Invalid numbers\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t\t{\"a\", \"\", \"a\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\"-\", \"\", \"-\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t\t{\"+\", \"\", \"+\", fmt.Errorf(\"unexpected char: %q\", \"+\")},\n\t\t{\"1.2e\", \"\", \"1.2e\", fmt.Errorf(\"unexpected char: %q\", \"1.2e\")},\n\t\t{\"in\", \"\", \"in\", fmt.Errorf(\"unexpected char: %q\", \"in\")},\n\t\t{\"na\", \"\", \"na\", fmt.Errorf(\"unexpected char: %q\", \"na\")},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d:%s\", i, tt.input), func(t *testing.T) {\n\t\t\tgotNum, gotTail, gotErr := parseRawNumber(tt.input)\n\t\t\tif gotNum != tt.wantNum {\n\t\t\t\tt.Errorf(\"parseRawNumber(%s) gotNum = %v, want %v\", tt.input, gotNum, tt.wantNum)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseRawNumber(%s) gotTail = %v, want %v\", tt.input, gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif gotErr == nil \u0026\u0026 tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%s) gotErr = nil, want %v\", tt.input, tt.wantErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr == nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%s) gotErr = %v, want nil\", tt.input, gotErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"parseRawNumber(%s) gotErr = %v, want %v\", tt.input, gotErr, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","7dcd4b2020590e522e3b8a940cc501f3":"package fastjson\n\nimport \"testing\"\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\ts string\n\t\twant string\n\t}{\n\t\t{\"  foo\", \"foo\"},\n\t\t{\"\\n\\tbar\", \"bar\"},\n\t\t{\"\\r\\n  baz\", \"baz\"},\n\t\t{\"qux\", \"qux\"},\n\t\t{\"\", \"\"},\n\t\t{\"\\t\", \"\"},\n\t\t{\"  \\r\\n\", \"\"},\n\t}\n\tfor i, tt := range tests {\n\t\tgot := skipWSSlow(tt.s)\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"test %d: skipWSSlow(%q) = %q, want %q\", i, tt.s, got, tt.want)\n\t\t}\n\t}\n}","7dd7034a21a9529c961f608a308225ae":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantJSON string\n\t\twantErr  error\n\t}{\n\t\t{\n\t\t\tname:     \"empty object\",\n\t\t\tinput:    \"{}\",\n\t\t\twantJSON: `{}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"simple object\",\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\twantJSON: `{\"key\": \"value\"}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"nested object\",\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": {\"key3\": \"value3\"}}`,\n\t\t\twantJSON: `{\"key1\": \"value1\", \"key2\": {\"key3\": \"value3\"}}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"object with array\",\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": [1, 2, 3]}`,\n\t\t\twantJSON: `{\"key1\": \"value1\", \"key2\": [1, 2, 3]}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"object with escaped characters\",\n\t\t\tinput:    `{\"key1\": \"value1\\nwith\\tescapes\", \"key2\": \"value2\"}`,\n\t\t\twantJSON: `{\"key1\": \"value1\\nwith\\tescapes\", \"key2\": \"value2\"}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid object: missing closing brace\",\n\t\t\tinput:    `{\"key\": \"value\"`,\n\t\t\twantErr: fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid object: missing colon\",\n\t\t\tinput:    `{\"key\" \"value\"}`,\n\t\t\twantErr: fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid object: missing comma\",\n\t\t\tinput:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, _, err := parseObject(tt.input, c, 0)\n\t\t\tif tt.wantErr != nil {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"parseObject() error = nil, wantErr %v\", tt.wantErr)\n\t\t\t\t} else if err.Error() != tt.wantErr.Error() {\n\t\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr nil\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgotJSON := got.String()\n\t\t\tif gotJSON != tt.wantJSON {\n\t\t\t\tt.Errorf(\"parseObject() got = %s, want %s\", gotJSON, tt.wantJSON)\n\t\t\t}\n\t\t})\n\t}\n}\n","7e8e562ef2d27c182d546cf4c9a07086":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetArray(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tjson  string\n\t\tkeys  []string\n\t\twant  []*Value\n\t\twant1 bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tjson:  `{}`,\n\t\t\tkeys:  []string{\"foo\", \"0\"},\n\t\t\twant:  nil,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"empty array\",\n\t\t\tjson:  `[]`,\n\t\t\tkeys:  []string{\"0\"},\n\t\t\twant:  nil,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"simple object\",\n\t\t\tjson:  `{\"foo\": [1,2,3]}`,\n\t\t\tkeys:  []string{\"foo\", \"1\"},\n\t\t\twant:  nil,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"array with different types\",\n\t\t\tjson:  `{\"foo\": [1,\"2\",true]}`,\n\t\t\tkeys:  []string{\"foo\"},\n\t\t\twant:  func() []*Value {\n\t\t\t\tv1, _ := ParseBytes([]byte(`[1,\"2\",true]`))\n\t\t\t\treturn v1.a\n\t\t\t}(),\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"nested array\",\n\t\t\tjson:  `{\"foo\": [[1,2],[3,4]]}`,\n\t\t\tkeys:  []string{\"foo\", \"1\"},\n\t\t\twant:  func() []*Value {\n\t\t\t\tv1, _ := ParseBytes([]byte(`[3,4]`))\n\t\t\t\treturn v1.a\n\t\t\t}(),\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array index out of range\",\n\t\t\tjson:  `{\"foo\": [1,2,3]}`,\n\t\t\tkeys:  []string{\"foo\", \"3\"},\n\t\t\twant:  nil,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"invalid array index\",\n\t\t\tjson:  `{\"foo\": [1,2,3]}`,\n\t\t\tkeys:  []string{\"foo\", \"a\"},\n\t\t\twant:  nil,\n\t\t\twant1: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv, _ := ParseBytes([]byte(tt.json))\n\t\t\tgot := v.GetArray(tt.keys...)\n\t\t\tif (got == nil \u0026\u0026 tt.want != nil) || (got != nil \u0026\u0026 tt.want == nil) {\n\t\t\t\tt.Errorf(\"Value.GetArray() got = %v, want %v\", got, tt.want)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif len(got) != len(tt.want) {\n\t\t\t\tt.Errorf(\"Value.GetArray() got = %v, want %v\", got, tt.want)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tfor i := range got {\n\t\t\t\tif got[i].String() != tt.want[i].String() {\n\t\t\t\t\tt.Errorf(\"Value.GetArray() got = %v, want %v\", got, tt.want)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","7f4ba0b171c71cd762dba9c2e617f4ff":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetUint(t *testing.T) {\n\tvar v Value\n\ttestCases := []struct {\n\t\tjson     string\n\t\tkeys     []string\n\t\texpected uint\n\t}{\n\t\t// Existing keys\n\t\t{`{\"a\":123}`, []string{\"a\"}, 123},\n\t\t{`{\"a\":{\"b\":123}}`, []string{\"a\", \"b\"}, 123},\n\t\t{`{\"a\":[1, 2, 3]}`, []string{\"a\", \"1\"}, 2},\n\t\t{`{\"a\":[1, 2, 3]}`, []string{\"a\", \"1.0\"}, 2},\n\n\t\t// Non-existing keys\n\t\t{`{\"a\":123}`, []string{\"b\"}, 0},\n\t\t{`{\"a\":{\"b\":123}}`, []string{\"a\", \"c\"}, 0},\n\t\t{`{\"a\":[1, 2, 3]}`, []string{\"a\", \"4\"}, 0},\n\n\t\t// Invalid value type\n\t\t{`{\"a\":\"123\"}`, []string{\"a\"}, 0},\n\t\t{`{\"a\":{\"b\":\"123\"}}`, []string{\"a\", \"b\"}, 0},\n\t\t{`{\"a\":[1, \"2\", 3]}`, []string{\"a\", \"1\"}, 0},\n\n\t\t// Overflow\n\t\t{`{\"a\":18446744073709551615}`, []string{\"a\"}, 0},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tif err := v.Parse(tc.json); err != nil {\n\t\t\tt.Fatalf(\"Test[%d]: cannot parse json: %s, err: %v\", i, tc.json, err)\n\t\t}\n\t\tif got := v.GetUint(tc.keys...); got != tc.expected {\n\t\t\tt.Errorf(\"Test[%d]: v.GetUint(%v) = %d; want %d, json: %s\", i, tc.keys, got, tc.expected, tc.json)\n\t\t}\n\t}\n}","7f60f1b39103ded7daa1b75a4ee76a2d":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantValue *Value\n\t\twantTail string\n\t\twantErr   error\n\t}{\n\t\t// TODO: Add test cases\n\t\t{\n\t\t\tname:     \"empty string\",\n\t\t\tinput:    \"\",\n\t\t\twantValue: nil,\n\t\t\twantTail: \"\",\n\t\t\twantErr:   fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"true\",\n\t\t\tinput:    \"true\",\n\t\t\twantValue: valueTrue,\n\t\t\twantTail: \"\",\n\t\t\twantErr:   nil,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgotValue, gotTail, gotErr := parseValue(tt.input, c, 0)\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseValue() gotTail = %v, want %v\", gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif gotErr != nil {\n\t\t\t\tif gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue() gotErr = %v, want %v\", gotErr, tt.wantErr)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif gotValue == nil \u0026\u0026 tt.wantValue == nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotValue.Type() != tt.wantValue.Type() {\n\t\t\t\tt.Errorf(\"parseValue() gotValue = %v, want %v\", gotValue, tt.wantValue)\n\t\t\t}\n\t\t})\n\t}\n}\n","807d013abe86474680c99a8397c44ef9":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Get(t *testing.T) {\n\tt.Run(\"object\", func(t *testing.T) {\n\t\tv := MustParse(`{\"foo\": {\"bar\": \"baz\"}}`)\n\t\tif got := v.Get(\"foo\", \"bar\").String(); got != \"baz\" {\n\t\t\tt.Fatalf(\"unexpected value %q. Expecting %q\", got, \"baz\")\n\t\t}\n\t\tif got := v.Get(\"foo\", \"bar\", \"baz\"); got != nil {\n\t\t\tt.Fatalf(\"unexpected non-nil result: %v\", got)\n\t\t}\n\t\tif got := v.Get(\"foo\", \"\"); got != nil {\n\t\t\tt.Fatalf(\"unexpected non-nil result: %v\", got)\n\t\t}\n\t})\n\n\tt.Run(\"array\", func(t *testing.T) {\n\t\tv := MustParse(`{\"foo\": [{\"bar\": \"baz\"}]}`)\n\t\tif got := v.Get(\"foo\", \"0\", \"bar\").String(); got != \"baz\" {\n\t\t\tt.Fatalf(\"unexpected value %q. Expecting %q\", got, \"baz\")\n\t\t}\n\t\tif got := v.Get(\"foo\", \"1\"); got != nil {\n\t\t\tt.Fatalf(\"unexpected non-nil result: %v\", got)\n\t\t}\n\t\tif got := v.Get(\"foo\", \"0\", \"baz\"); got != nil {\n\t\t\tt.Fatalf(\"unexpected non-nil result: %v\", got)\n\t\t}\n\t})\n\n\tt.Run(\"missing-key\", func(t *testing.T) {\n\t\tv := MustParse(`{\"foo\": {\"bar\": \"baz\"}}`)\n\t\tif got := v.Get(\"fo\"); got != nil {\n\t\t\tt.Fatalf(\"unexpected non-nil result: %v\", got)\n\t\t}\n\t\tif got := v.Get(\"foo\", \"ba\"); got != nil {\n\t\t\tt.Fatalf(\"unexpected non-nil result: %v\", got)\n\t\t}\n\t})\n\n\tt.Run(\"null\", func(t *testing.T) {\n\t\tv := MustParse(`{\"foo\": null}`)\n\t\tif got := v.Get(\"foo\"); got == nil {\n\t\t\tt.Fatalf(\"unexpected nil result\")\n\t\t}\n\t\tif got := got.Type(); got != TypeNull {\n\t\t\tt.Fatalf(\"unexpected type %v. Expecting %v\", got, TypeNull)\n\t\t}\n\t})\n}","80eb4c1412d255ee46292aae604c32df":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantNum  string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Valid numbers\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"123.456\", \"123.456\", \"\", nil},\n\t\t{\"1.2e3\", \"1.2e3\", \"\", nil},\n\t\t{\"1.2E-3\", \"1.2E-3\", \"\", nil},\n\t\t{\"+123\", \"+123\", \"\", nil},\n\n\t\t// Valid numbers with trailing characters\n\t\t{\"123a\", \"123\", \"a\", nil},\n\t\t{\"-123 \", \"-123\", \" \", nil},\n\t\t{\"123.456,\", \"123.456\", \",\", nil},\n\n\t\t// Invalid numbers\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t\t{\"a\", \"\", \"a\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\"-\", \"\", \"-\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t\t{\"+\", \"\", \"+\", fmt.Errorf(\"unexpected char: %q\", \"+\")},\n\t\t{\"1.2e\", \"\", \"1.2e\", fmt.Errorf(\"unexpected char: %q\", \"1.2e\")},\n\n\t\t// Special cases: inf, nan\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"+inf\", \"+inf\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"InF\", \"InF\", \"\", nil},\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"+nan\", \"\", \"+nan\", fmt.Errorf(\"unexpected char: %q\", \"+n\")},\n\t\t{\"-nan\", \"\", \"-nan\", fmt.Errorf(\"unexpected char: %q\", \"-n\")},\n\t\t{\"in\", \"\", \"in\", fmt.Errorf(\"unexpected char: %q\", \"in\")},\n\t\t{\"na\", \"\", \"na\", fmt.Errorf(\"unexpected char: %q\", \"na\")},\n\t\t{\"infx\", \"inf\", \"x\", nil},\n\t\t{\"nanx\", \"nan\", \"x\", nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d:%s\", i, tt.input), func(t *testing.T) {\n\t\t\tgotNum, gotTail, gotErr := parseRawNumber(tt.input)\n\t\t\tif gotNum != tt.wantNum {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got number = %q, want %q\", tt.input, gotNum, tt.wantNum)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got tail = %q, want %q\", tt.input, gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif (gotErr == nil \u0026\u0026 tt.wantErr != nil) || (gotErr != nil \u0026\u0026 tt.wantErr == nil) || (gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error()) {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got error = %v, want %v\", tt.input, gotErr, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","813b6cc65bfab253187227574002ee26":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Get(t *testing.T) {\n\tt.Run(\"null\", func(t *testing.T) {\n\t\tvar v *Value\n\t\tgot := v.Get(\"key\")\n\t\tif got != nil {\n\t\t\tt.Errorf(\"Get() = %v, want nil\", got)\n\t\t}\n\t})\n\n\tt.Run(\"object\", func(t *testing.T) {\n\t\tv := \u0026Value{\n\t\t\to: Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t},\n\t\t\t},\n\t\t\tt: TypeObject,\n\t\t}\n\n\t\ttests := []struct {\n\t\t\tname string\n\t\t\tkeys []string\n\t\t\twant *Value\n\t\t}{\n\t\t\t{\n\t\t\t\tname: \"existing key\",\n\t\t\t\tkeys: []string{\"key1\"},\n\t\t\t\twant: \u0026Value{t: TypeString, s: \"value1\"},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"non-existing key\",\n\t\t\t\tkeys: []string{\"key3\"},\n\t\t\t\twant: nil,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"nested key\",\n\t\t\t\tkeys: []string{\"key2\"},\n\t\t\t\twant: \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t},\n\t\t}\n\n\t\tfor _, tt := range tests {\n\t\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t\tgot := v.Get(tt.keys...)\n\t\t\t\tif got != tt.want {\n\t\t\t\t\tt.Errorf(\"Get() = %v, want %v\", got, tt.want)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"array\", func(t *testing.T) {\n\t\tv := \u0026Value{\n\t\t\ta: []*Value{\n\t\t\t\t{t: TypeString, s: \"value1\"},\n\t\t\t\t{t: TypeNumber, s: \"123\"},\n\t\t\t},\n\t\t\tt: TypeArray,\n\t\t}\n\n\t\ttests := []struct {\n\t\t\tname string\n\t\t\tkeys []string\n\t\t\twant *Value\n\t\t}{\n\t\t\t{\n\t\t\t\tname: \"existing index\",\n\t\t\t\tkeys: []string{\"0\"},\n\t\t\t\twant: \u0026Value{t: TypeString, s: \"value1\"},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"non-existing index\",\n\t\t\t\tkeys: []string{\"2\"},\n\t\t\t\twant: nil,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"invalid index\",\n\t\t\t\tkeys: []string{\"abc\"},\n\t\t\t\twant: nil,\n\t\t\t},\n\t\t}\n\n\t\tfor _, tt := range tests {\n\t\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t\tgot := v.Get(tt.keys...)\n\t\t\t\tif got != tt.want {\n\t\t\t\t\tt.Errorf(\"Get() = %v, want %v\", got, tt.want)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t})\n}\n","8177a350d4c4cce2597cc004623711f5":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  string\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Basic cases\n\t\t{`\"foo\"`, `foo`, ``, nil},\n\t\t{`\"fo\\\"o\"`, `fo\"o`, ``, nil},\n\t\t{`\"foo\"bar`, `foo`, `bar`, nil},\n\n\t\t// Escaped quotes\n\t\t{`\"fo\\\\o\"`, `fo\\o`, ``, nil},\n\t\t{`\"fo\\\\\\\\o\"`, `fo\\\\o`, ``, nil},\n\t\t{`\"fo\\\\\\\"o\"`, `fo\\\"o`, ``, nil},\n\n\t\t// Missing closing quote\n\t\t{`\"foo`, ``, ``, fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"fo\\o`, ``, ``, fmt.Errorf(`missing closing '\"'`)},\n\n\t\t// Empty strings\n\t\t{`\"\"`, ``, ``, nil},\n\t\t{`\"\"\"\"`, `\"`, ``, nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tgot, tail, err := parseRawString(tt.input)\n\t\t\tif got != tt.want || tail != tt.tail || (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = (%q, %q, %v); want (%q, %q, %v)\", tt.input, got, tail, err, tt.want, tt.tail, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}","829f3bee55cc6c18e8df104328bf5e2b":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey   string\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Basic cases\n\t\t{`\"foo\"bar`, \"foo\", \"bar\", nil},\n\t\t{`\"fo\\\"o\"bar`, `fo\"o`, \"bar\", nil},\n\t\t{`\"foo\"`, \"foo\", \"\", nil},\n\t\t{`\"\"bar`, \"\", \"bar\", nil},\n\n\t\t// Escaped quotes\n\t\t{`\"fo\\\\o\"bar`, `fo\\o`, \"bar\", nil},\n\t\t{`\"fo\\\\\\\\o\"bar`, `fo\\\\o`, \"bar\", nil},\n\t\t{`\"fo\\\"o\"bar`, `fo\"o`, \"bar\", nil},\n\t\t{`\"fo\\\\\\\"o\"bar`, `fo\\\"o`, \"bar\", nil},\n\n\t\t// Missing closing quote\n\t\t{`\"foobar`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo\\\"bar`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo\\\\\"bar`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tkey, tail, err := parseRawString(tt.input)\n\t\t\tif key != tt.key || tail != tt.tail || !equalError(err, tt.err) {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = (%q, %q, %v), want (%q, %q, %v)\", tt.input, key, tail, err, tt.key, tt.tail, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// equalError compares two errors for equality.\nfunc equalError(err1, err2 error) bool {\n\tif err1 == nil \u0026\u0026 err2 == nil {\n\t\treturn true\n\t}\n\tif err1 == nil || err2 == nil {\n\t\treturn false\n\t}\n\treturn err1.Error() == err2.Error()\n}","8357f5d24e1cdb9aefc22a135c1b9466":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic escapes\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\t`, \"\\t\"},\n\t\t{`\\\\`, \"\\\\\"},\n\t\t{`\\\"`, \"\\\"\"},\n\t\t{`\\/`, \"/\"},\n\t\t{`\\b`, \"\\b\"},\n\t\t{`\\f`, \"\\f\"},\n\t\t{`\\r`, \"\\r\"},\n\n\t\t// Unicode escapes\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A0`, \"\\u00A0\"},\n\t\t{`\\uFFFF`, \"\\uFFFF\"},\n\t\t{`\\uD83D\\uDE02`, \"üòÇ\"}, // Surrogate pair\n\n\t\t// Invalid escapes\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\uD800`, `\\uD800`}, // Unpaired surrogate\n\t\t{`\\uDC00`, `\\uDC00`}, // Unpaired surrogate\n\n\t\t// Mixed escapes\n\t\t{`Hello\\tworld\\n`, \"Hello\\tworld\\n\"},\n\t\t{`\\u00A92023`, \"\\u00A92023\"},\n\t\t{`C:\\\\Program Files\\\\`, `C:\\\\Program Files\\\\`},\n\n\t\t// No escapes\n\t\t{`Hello, world!`, `Hello, world!`},\n\t\t{`{}[]:,\"`, `{}[]:,\"`},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tactual := unescapeStringBestEffort(tt.input)\n\t\t\tif actual != tt.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", tt.input, actual, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}","846b5a8936b60cdcefab9152a8a78e08":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantN    string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Valid numbers\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"123.456\", \"123.456\", \"\", nil},\n\t\t{\"1.2e3\", \"1.2e3\", \"\", nil},\n\t\t{\"1.2E-3\", \"1.2E-3\", \"\", nil},\n\t\t{\"+123\", \"+123\", \"\", nil},\n\n\t\t// Valid numbers with trailing characters\n\t\t{\"123a\", \"123\", \"a\", nil},\n\t\t{\"-123b\", \"-123\", \"b\", nil},\n\t\t{\"123.456c\", \"123.456\", \"c\", nil},\n\n\t\t// Invalid numbers\n\t\t{\"a123\", \"\", \"a123\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\".123\", \"\", \".123\", fmt.Errorf(\"unexpected char: %q\", \".\")},\n\t\t{\"e123\", \"\", \"e123\", fmt.Errorf(\"unexpected char: %q\", \"e\")},\n\n\t\t// Special cases\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"InF\", \"InF\", \"\", nil},\n\t\t{\"+inf\", \"+inf\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"nAn\", \"nAn\", \"\", nil},\n\t\t{\"in\", \"\", \"in\", fmt.Errorf(\"unexpected char: %q\", \"i\")},\n\t\t{\"na\", \"\", \"na\", fmt.Errorf(\"unexpected char: %q\", \"n\")},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tgotN, gotTail, gotErr := parseRawNumber(tt.input)\n\t\t\tif gotN != tt.wantN {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got number = %q, want %q\", tt.input, gotN, tt.wantN)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got tail = %q, want %q\", tt.input, gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif gotErr == nil \u0026\u0026 tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got no error, want %v\", tt.input, tt.wantErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr == nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got error = %v, want nil\", tt.input, gotErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got error = %v, want %v\", tt.input, gotErr, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","85860e752a54f3e60b619400d8ea0e22":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantN    string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Basic cases\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"123.456\", \"123.456\", \"\", nil},\n\t\t{\"1.2e3\", \"1.2e3\", \"\", nil},\n\t\t{\"1.2E-3\", \"1.2E-3\", \"\", nil},\n\t\t{\"+123\", \"+123\", \"\", nil},\n\n\t\t// Trailing characters\n\t\t{\"123a\", \"123\", \"a\", nil},\n\t\t{\"123.456 \", \"123.456\", \" \", nil},\n\t\t{\"-123\\\"\", \"-123\", \"\\\"\", nil},\n\n\t\t// Invalid numbers\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t\t{\"+\", \"\", \"+\", fmt.Errorf(\"unexpected char: %q\", \"+\")},\n\t\t(\"-\", \"\", \"-\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t\t(\".123\", \"\", \".123\", fmt.Errorf(\"unexpected char: %q\", \".\")},\n\t\t(\"1.2.3\", \"\", \"1.2.3\", fmt.Errorf(\"unexpected char: %q\", \".\")},\n\n\t\t// Special cases: inf and nan\n\t\t{\"inf\", \"in\", \"f\", nil},\n\t\t{\"+inf\", \"+in\", \"f\", nil},\n\t\t{\"-inf\", \"-in\", \"f\", nil},\n\t\t{\"InF\", \"In\", \"F\", nil},\n\t\t{\"nan\", \"na\", \"n\", nil},\n\t\t{\"+nan\", \"+na\", \"n\", nil},\n\t\t{\"-nan\", \"-na\", \"n\", nil},\n\t\t{\"NAN\", \"NA\", \"N\", nil},\n\n\t\t// Special cases: invalid inf and nan\n\t\t{\"in\", \"\", \"in\", fmt.Errorf(\"unexpected char: %q\", \"i\")},\n\t\t{\"na\", \"\", \"na\", fmt.Errorf(\"unexpected char: %q\", \"n\")},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d:%s\", i, tt.input), func(t *testing.T) {\n\t\t\tgotN, gotTail, gotErr := parseRawNumber(tt.input)\n\t\t\tif gotN != tt.wantN || gotTail != tt.wantTail || (gotErr != nil \u0026\u0026 tt.wantErr == nil) || (gotErr == nil \u0026\u0026 tt.wantErr != nil) || (gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error()) {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = (%q, %q, %v), want (%q, %q, %v)\", tt.input, gotN, gotTail, gotErr, tt.wantN, tt.wantTail, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","867153df9b6a69ea618b77a3fc27945c":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantN    string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Valid numbers\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"123.456\", \"123.456\", \"\", nil},\n\t\t{\"1.2e3\", \"1.2e3\", \"\", nil},\n\t\t{\"1.2E-3\", \"1.2E-3\", \"\", nil},\n\t\t{\"+123\", \"+123\", \"\", nil},\n\n\t\t// Valid numbers with trailing characters\n\t\t{\"123a\", \"123\", \"a\", nil},\n\t\t{\"-123 \", \"-123\", \" \", nil},\n\t\t{\"123.456,\", \"123.456\", \",\", nil},\n\n\t\t// Invalid numbers\n\t\t{\"a123\", \"\", \"a123\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\".123\", \"\", \".123\", fmt.Errorf(\"unexpected char: %q\", \".\")},\n\t\t{\"+a123\", \"\", \"+a123\", fmt.Errorf(\"unexpected char: %q\", \"+\")},\n\t\t{\"-a123\", \"\", \"-a123\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\n\t\t// Special cases: inf, nan\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"InF\", \"InF\", \"\", nil},\n\t\t{\"+inf\", \"+inf\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"nAn\", \"nAn\", \"\", nil},\n\n\t\t// Special cases with trailing characters\n\t\t{\"inf,\", \"inf\", \",\", nil},\n\t\t{\"nan}\", \"nan\", \"}\", nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d:%s\", i, tt.input), func(t *testing.T) {\n\t\t\tgotN, gotTail, gotErr := parseRawNumber(tt.input)\n\n\t\t\tif gotN != tt.wantN {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got number = %q, want %q\", tt.input, gotN, tt.wantN)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got tail = %q, want %q\", tt.input, gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif gotErr == nil \u0026\u0026 tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got no error, want %v\", tt.input, tt.wantErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr == nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got error = %v, want no error\", tt.input, gotErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got error = %v, want %v\", tt.input, gotErr, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","8717eb40e7c5b1502a86c46aec6f0a2f":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic cases\n\t\t{`\"hello world\"`, \"hello world\"},\n\t\t{`\"escaped \\\\ slash\"`, \"escaped \\\\ slash\"},\n\t\t{`\"escaped \\\" quote\"`, \"escaped \\\" quote\"},\n\t\t{`\"escaped \\/ slash\"`, \"escaped / slash\"},\n\n\t\t// Unicode escapes\n\t\t{`\"\\u0041\"`, \"A\"},\n\t\t{`\"\\u00e9\"`, \"√©\"},\n\t\t{`\"\\u20ac\"`, \"‚Ç¨\"},\n\n\t\t// Surrogate pairs\n\t\t{`\"\\uD83D\\uDE02\"`, \"üòÇ\"},\n\n\t\t// Invalid escape sequences\n\t\t{`\"\\u004\\u0042\"`, `\\u004\\u0042`},\n\t\t{`\"\\uD800\"`, `\\uD800`},\n\t\t{`\"\\uD83D\\uXXXX\"`, `\\uD83D\\uXXXX`},\n\n\t\t// Mixed cases\n\t\t{`\"hello \\u0041 world\"`, \"hello A world\"},\n\t\t{`\"escaped \\\\ slash \\u20ac\"`, \"escaped \\\\ slash ‚Ç¨\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}","871e93cc734c52c098de30486d1c84ef":"package fastjson\n\nimport \"testing\"\n\nfunc TestValue_GetFloat64(t *testing.T) {\n\tvar tests = []struct {\n\t\tname     string\n\t\tjson     string\n\t\targs     []string\n\t\twant     float64\n\t\twantFail bool\n\t}{\n\t\t{\n\t\t\tname: \"simple\",\n\t\t\tjson: `{\"test\":1.23}`,\n\t\t\targs: []string{\"test\"},\n\t\t\twant: 1.23,\n\t\t},\n\t\t{\n\t\t\tname: \"nested\",\n\t\t\tjson: `{\"test\":{\"nested\":1.23}}`,\n\t\t\targs: []string{\"test\", \"nested\"},\n\t\t\twant: 1.23,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tjson: `{\"test\":[1.23, 4.56]}`,\n\t\t\targs: []string{\"test\", \"1\"},\n\t\t\twant: 4.56,\n\t\t},\n\t\t{\n\t\t\tname: \"array decimal index\",\n\t\t\tjson: `{\"test\":[1.23, 4.56]}`,\n\t\t\targs: []string{\"test\", \"1.0\"},\n\t\t\twant: 4.56,\n\t\t},\n\t\t{\n\t\t\tname:     \"non-existing key\",\n\t\t\tjson:     `{\"test\":1.23}`,\n\t\t\targs:     []string{\"test2\"},\n\t\t\twant:     0,\n\t\t\twantFail: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid value type\",\n\t\t\tjson:     `{\"test\":\"1.23\"}`,\n\t\t\targs:     []string{\"test\"},\n\t\t\twant:     0,\n\t\t\twantFail: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv := MustParse([]byte(tt.json))\n\t\t\tgot := v.GetFloat64(tt.args...)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"GetFloat64() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","880ea0b271ad5f9e12e05cf9dcf137a3":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic escapes\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\t`, \"\\t\"},\n\t\t{`\\\\`, \"\\\\\"},\n\t\t{`\\\"`, \"\\\"\"},\n\t\t{`\\/`, \"/\"},\n\n\t\t// Unicode escapes\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A0`, \"\\u00A0\"},\n\t\t{`\\uFFFF`, \"\\uFFFF\"},\n\n\t\t// Surrogate pairs\n\t\t{`\\uD83D\\uDE02`, \"\\U0001F602\"},\n\n\t\t// Invalid escapes\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\uD800`, `\\uD800`},\n\t\t{`\\uD800\\u1234`, `\\uD800\\u1234`},\n\n\t\t// Mixed content\n\t\t{`Hello\\tworld\\n`, \"Hello\\tworld\\n\"},\n\t\t{`\\u0041\\u0020\\u0073\\u0074\\u0072\\u0069\\u006e\\u0067`, \"A string\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}\n","88843da73a4c0686070c97ea98d37280":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Empty array\n\t\t{\n\t\t\tinput: \"[]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\ttail: \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t// Simple array\n\t\t{\n\t\t\tinput: \"[1,2,3]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttail: \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t// Array with different types\n\t\t{\n\t\t\tinput: `[1,\"test\",true,null]`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeString, s: \"test\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t\t{t: TypeNull},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttail: \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t// Array with nested array\n\t\t{\n\t\t\tinput: \"[1,[2,3],4]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeArray, a: []*Value{\n\t\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t\t}},\n\t\t\t\t\t{t: TypeNumber, s: \"4\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttail: \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t// Array with whitespace\n\t\t{\n\t\t\tinput: \" [ 1 , 2 , 3 ] \",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttail: \" \",\n\t\t\terr:   nil,\n\t\t},\n\t\t// Invalid array - missing closing bracket\n\t\t{\n\t\t\tinput: \"[1,2,3\",\n\t\t\twant:  nil,\n\t\t\ttail:  \"\",\n\t\t\terr:   fmt.Errorf(\"missing ']'\"),\n\t\t},\n\t\t// Invalid array - missing comma\n\t\t{\n\t\t\tinput: \"[1,2 3]\",\n\t\t\twant:  nil,\n\t\t\ttail:  \"\",\n\t\t\terr:   fmt.Errorf(\"missing ',' after array value\"),\n\t\t},\n\t\t// Invalid array - unexpected end\n\t\t{\n\t\t\tinput: \"[1,2,\",\n\t\t\twant:  nil,\n\t\t\ttail:  \"\",\n\t\t\terr:   fmt.Errorf(\"unexpected end of array\"),\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i+1), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, tail, err := parseArray(tt.input, c, 0)\n\n\t\t\tif (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err == nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"Test-%d: Expected error '%v', got '%v'\", i+1, tt.err, err)\n\t\t\t}\n\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"Test-%d: Expected tail '%s', got '%s'\", i+1, tt.tail, tail)\n\t\t\t}\n\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"Test-%d: Values are not equal\\nExpected:\\n%v\\nGot:\\n%v\", i+1, tt.want, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\treturn v1.s == v2.s\n\t}\n}","88b3d88545e7b71fef3f2ddd387f7e6d":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey string\n\t\tvalue string\n\t\terr error\n\t}{\n\t\t// Basic cases\n\t\t{`\"foo\"bar`, \"foo\", \"bar\", nil},\n\t\t{`\"fo\\\"o\"bar`, `fo\"o`, \"bar\", nil},\n\t\t{`\"foo\"`, \"foo\", \"\", nil},\n\t\t{`\"\"bar`, \"\", \"bar\", nil},\n\n\t\t// Escaped quotes\n\t\t{`\"foo\\\\\"bar`, `foo\\`, \"bar\", nil},\n\t\t{`\"foo\\\\\\\\\"bar`, `foo\\\\`, \"bar\", nil},\n\t\t{`\"foo\\\"bar`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo\\\\bar`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\n\t\t// Empty input\n\t\t{`\"\"`, \"\", \"\", nil},\n\t\t{`\"`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{``, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d:%s\", i, tt.input), func(t *testing.T) {\n\t\t\tkey, value, err := parseRawString(tt.input)\n\t\t\tif fmt.Sprintf(\"%v\", err) != fmt.Sprintf(\"%v\", tt.err) {\n\t\t\t\tt.Errorf(\"Input: %s, Expected error: %v, Got: %v\", tt.input, tt.err, err)\n\t\t\t}\n\t\t\tif key != tt.key {\n\t\t\t\tt.Errorf(\"Input: %s, Expected key: %s, Got: %s\", tt.input, tt.key, key)\n\t\t\t}\n\t\t\tif value != tt.value {\n\t\t\t\tt.Errorf(\"Input: %s, Expected value: %s, Got: %s\", tt.input, tt.value, value)\n\t\t\t}\n\t\t})\n\t}\n}","88bc848125f2ad9eae9f374f797cdd6d":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic escapes\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\t`, \"\\t\"},\n\t\t{`\\\\`, \"\\\\\"},\n\t\t{`\\\"`, \"\\\"\"},\n\t\t{`\\/`, \"/\"},\n\n\t\t// Unicode escapes\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A0`, \"\\u00A0\"},\n\t\t{`\\u20AC`, \"\\u20AC\"},\n\n\t\t// Surrogate pairs\n\t\t{`\\uD83D\\uDE02`, \"\\U0001F602\"},\n\n\t\t// Invalid escapes\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\uD800`, `\\uD800`},\n\t\t{`\\uD800\\u`, `\\uD800\\u`},\n\n\t\t// Mixed content\n\t\t{`Hello\\tworld\\n`, \"Hello\\tworld\\n\"},\n\t\t{`\\u0041\\u0020\\u0077\\u006f\\u0072\\u006c\\u0064`, \"A world\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}","8a73b2899763b71a1e7be8fdde02f4a4":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput  string\n\t\tns     string\n\t\tremain string\n\t\terr    error\n\t}{\n\t\t// Valid numbers\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"123.456\", \"123.456\", \"\", nil},\n\t\t{\"1.2e3\", \"1.2e3\", \"\", nil},\n\t\t{\"1.2E-3\", \"1.2E-3\", \"\", nil},\n\t\t{\"+123\", \"+123\", \"\", nil},\n\n\t\t// Valid numbers with trailing characters\n\t\t{\"123a\", \"123\", \"a\", nil},\n\t\t{\"-123 \", \"-123\", \" \", nil},\n\t\t{\"123.456,\", \"123.456\", \",\", nil},\n\n\t\t// Invalid numbers\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t\t{\"a\", \"\", \"a\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\"+a\", \"\", \"+a\", fmt.Errorf(\"unexpected char: %q\", \"+a\")},\n\t\t{\"-b\", \"\", \"-b\", fmt.Errorf(\"unexpected char: %q\", \"-b\")},\n\n\t\t// Special cases with \"inf\" and \"nan\"\n\t\t{\"inf\", \"\", \"inf\", nil},\n\t\t{\"+inf\", \"\", \"+inf\", nil},\n\t\t{\"-inf\", \"\", \"-inf\", nil},\n\t\t{\"nan\", \"\", \"nan\", nil},\n\t\t{\"+nan\", \"\", \"+nan\", nil},\n\t\t{\"-nan\", \"\", \"-nan\", nil},\n\t\t{\"123inf\", \"123\", \"inf\", nil},\n\t\t{\"-123inf\", \"-123\", \"inf\", nil},\n\t\t{\"123nan\", \"123\", \"nan\", nil},\n\t\t{\"-123nan\", \"-123\", \"nan\", nil},\n\t\t{\"123 inf\", \"123\", \" inf\", nil},\n\t\t{\"-123 inf\", \"-123\", \" inf\", nil},\n\t\t{\"123 nan\", \"123\", \" nan\", nil},\n\t\t{\"-123 nan\", \"-123\", \" nan\", nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d:%s\", i, tt.input), func(t *testing.T) {\n\t\t\tns, remain, err := parseRawNumber(tt.input)\n\t\t\tif ns != tt.ns || remain != tt.remain || !errorEqual(err, tt.err) {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = (%q, %q, %v), want (%q, %q, %v)\", tt.input, ns, remain, err, tt.ns, tt.remain, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc errorEqual(e1, e2 error) bool {\n\tif e1 == nil \u0026\u0026 e2 == nil {\n\t\treturn true\n\t}\n\tif e1 != nil \u0026\u0026 e2 != nil {\n\t\treturn e1.Error() == e2.Error()\n\t}\n\treturn false\n}","8a92d6cf40fb9967c46b22a97cd7d74c":"package fastjson\n\nimport \"testing\"\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    string\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\ts:    \"\",\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with leading whitespace\",\n\t\t\ts:    \"  \\t\\n\\r foo\",\n\t\t\twant: \"foo\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with no leading whitespace\",\n\t\t\ts:    \"bar\",\n\t\t\twant: \"bar\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with only whitespace\",\n\t\t\ts:    \" \\t\\n\\r\",\n\t\t\twant: \"\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %q, want %q\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","8bd5ac54a8d97cb3498cac05c38ebb21":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantNum  string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Valid numbers\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"123.456\", \"123.456\", \"\", nil},\n\t\t{\"1.2e3\", \"1.2e3\", \"\", nil},\n\t\t{\"1.2E-3\", \"1.2E-3\", \"\", nil},\n\t\t{\"+123\", \"+123\", \"\", nil},\n\n\t\t// Valid numbers with trailing characters\n\t\t{\"123a\", \"123\", \"a\", nil},\n\t\t{\"-123 \", \"-123\", \" \", nil},\n\t\t{\"123.456,\", \"123.456\", \",\", nil},\n\n\t\t// Invalid numbers\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t\t{\"a123\", \"\", \"a123\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\"+a123\", \"\", \"+a123\", fmt.Errorf(\"unexpected char: %q\", \"+a\")},\n\t\t{\"-a123\", \"\", \"-a123\", fmt.Errorf(\"unexpected char: %q\", \"-a\")},\n\n\t\t// Special cases: Inf, NaN\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"+Inf\", \"+Inf\", \"\", nil},\n\t\t{\"-INF\", \"-INF\", \"\", nil},\n\t\t{\"NaN\", \"NaN\", \"\", nil},\n\t\t{\"infx\", \"inf\", \"x\", nil},\n\t\t{\"+Infy\", \"+Inf\", \"y\", nil},\n\t\t{\"-INFz\", \"-INF\", \"z\", nil},\n\t\t{\"NaNw\", \"NaN\", \"w\", nil},\n\n\t\t// Special cases: invalid Inf, NaN\n\t\t{\"in\", \"\", \"in\", fmt.Errorf(\"unexpected char: %q\", \"i\")},\n\t\t{\"+I\", \"\", \"+I\", fmt.Errorf(\"unexpected char: %q\", \"+I\")},\n\t\t{\"-IN\", \"\", \"-IN\", fmt.Errorf(\"unexpected char: %q\", \"-I\")},\n\t\t{\"Na\", \"\", \"Na\", fmt.Errorf(\"unexpected char: %q\", \"N\")},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test %d - %s\", i, tt.input), func(t *testing.T) {\n\t\t\tgotNum, gotTail, gotErr := parseRawNumber(tt.input)\n\t\t\tif gotNum != tt.wantNum {\n\t\t\t\tt.Errorf(\"parseRawNumber(%s) gotNum = %v, want %v\", tt.input, gotNum, tt.wantNum)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseRawNumber(%s) gotTail = %v, want %v\", tt.input, gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif (gotErr == nil \u0026\u0026 tt.wantErr != nil) || (gotErr != nil \u0026\u0026 tt.wantErr == nil) || (gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error()) {\n\t\t\t\tt.Errorf(\"parseRawNumber(%s) gotErr = %v, want %v\", tt.input, gotErr, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","8cebbaf56eed54ae7ac1f41dc7bca55a":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey string\n\t\tvalue string\n\t\terr error\n\t}{\n\t\t// Simple cases\n\t\t{`\"key\":\"value\"`, \"key\", \"value\", nil},\n\t\t{`\"key\": \"value\"`, \"key\", \"value\", nil},\n\t\t{`\"key\" : \"value\"`, \"key\", \"value\", nil},\n\n\t\t// Escaped quotes\n\t\t{`\"\\\\\"key\\\\\"\": \"value\"`, `\"key\"`, \"value\", nil},\n\t\t{`\"ke\\\\\\\"y\": \"value\"`, `ke\\\"y`, \"value\", nil},\n\t\t{`\"key\\\\\": \"value\"`, `key\\`, \"value\", nil},\n\n\t\t// Empty strings\n\t\t{`\"\" : \"\"`, \"\", \"\", nil},\n\t\t{`\"key\":\"\"`, \"key\", \"\", nil},\n\n\t\t// Error cases\n\t\t{`\"key: \"value\"`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"key :value\"`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"key\" \"value\"`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tkey, value, err := parseRawString(tt.input)\n\t\t\tif fmt.Sprintf(\"%v\", err) != fmt.Sprintf(\"%v\", tt.err) {\n\t\t\t\tt.Errorf(\"Input: %s, Expected error: %v, Got: %v\", tt.input, tt.err, err)\n\t\t\t}\n\t\t\tif key != tt.key {\n\t\t\t\tt.Errorf(\"Input: %s, Expected key: %s, Got: %s\", tt.input, tt.key, key)\n\t\t\t}\n\t\t\tif value != tt.value {\n\t\t\t\tt.Errorf(\"Input: %s, Expected value: %s, Got: %s\", tt.input, tt.value, value)\n\t\t\t}\n\t\t})\n\t}\n}\n","8e7a2d1d824892a379375c34369f029f":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ts     string\n\t\terr   error\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseObject(tt.input, c, 0)\n\t\t\tif (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif s != tt.s {\n\t\t\t\tt.Errorf(\"parseObject() s = %v, want %v\", s, tt.s)\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\t// TODO: Implement a proper comparison for *Value.\n\treturn fmt.Sprintf(\"%#v\", v1) == fmt.Sprintf(\"%#v\", v2)\n}","8eae25ac5e53288751b9137800585cf9":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tvar c cache\n\ttests := []struct {\n\t\tin   string\n\t\twant *Value\n\t\ttail string\n\t\terr  error\n\t}{\n\t\t// Empty string\n\t\t{\"\", nil, \"\", fmt.Errorf(\"cannot parse empty string\")},\n\n\t\t// Object\n\t\t{\"{ \\\"key\\\": \\\"value\\\" }\", \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{t: typeRawString, s: \"value\"}}}}}}, \"\", nil},\n\n\t\t// Array\n\t\t{\"[1, 2, 3]\", \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}}, \"\", nil},\n\n\t\t// String\n\t\t{`\"hello, world\"`, \u0026Value{t: typeRawString, s: \"hello, world\"}, \"\", nil},\n\n\t\t// True\n\t\t{\"true\", valueTrue, \"\", nil},\n\n\t\t// False\n\t\t{\"false\", valueFalse, \"\", nil},\n\n\t\t// Null\n\t\t{\"null\", valueNull, \"\", nil},\n\n\t\t// Number\n\t\t{\"12345\", \u0026Value{t: TypeNumber, s: \"12345\"}, \"\", nil},\n\t\t{\"-12345\", \u0026Value{t: TypeNumber, s: \"-12345\"}, \"\", nil},\n\t\t{\"12.345\", \u0026Value{t: TypeNumber, s: \"12.345\"}, \"\", nil},\n\t\t{\"-12.345\", \u0026Value{t: TypeNumber, s: \"-12.345\"}, \"\", nil},\n\n\t\t// NaN\n\t\t{\"NaN\", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"\", nil},\n\n\t\t// Trailing whitespace\n\t\t{\"true  \", valueTrue, \"  \", nil},\n\n\t\t// Invalid input\n\t\t{\"invalid\", nil, \"invalid\", fmt.Errorf(\"cannot parse number: invalid\")},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tgot, tail, err := parseValue(tt.in, \u0026c, 0)\n\n\t\t\tif tt.err != nil {\n\t\t\t\tif err == nil || err.Error() != tt.err.Error() {\n\t\t\t\t\tt.Errorf(\"Expected error %v, got %v\", tt.err, err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"Expected tail %q, got %q\", tt.tail, tail)\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"Test %d - Expected %v, got %v\", i, tt.want, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(a, b *Value) bool {\n\tif a == nil \u0026\u0026 b == nil {\n\t\treturn true\n\t}\n\tif a == nil || b == nil {\n\t\treturn false\n\t}\n\tif a.t != b.t {\n\t\treturn false\n\t}\n\tswitch a.t {\n\tcase TypeObject:\n\t\tif len(a.o.kvs) != len(b.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range a.o.kvs {\n\t\t\tif a.o.kvs[i].k != b.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(a.o.kvs[i].v, b.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeArray:\n\t\tif len(a.a) != len(b.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range a.a {\n\t\t\tif !equalValues(a.a[i], b.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\treturn a.s == b.s\n\t}\n}","8f3577abc1e9b4953cc10e31b104475d":"package fastjson\n\nimport \"testing\"\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"  foo\", \"foo\"},\n\t\t{\"\\n\\n\\n bar\", \"bar\"},\n\t\t{\" \\t\\r\\n baz\", \"baz\"},\n\t\t{\"qux\", \"qux\"},\n\t\t{\"\", \"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := skipWSSlow(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"skipWSSlow(%q) = %q, expected %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}","8f686768662947d3b2eeeb2bfd5865e5":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic escapes\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\t`, \"\\t\"},\n\t\t{`\\\\`, \"\\\\\"},\n\t\t{`\\\"`, \"\\\"\"},\n\t\t{`\\/`, \"/\"},\n\n\t\t// Unicode escapes\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A0`, \"\\u00A0\"},\n\t\t{`\\uFFFF`, \"\\uFFFF\"},\n\n\t\t// Surrogate pairs\n\t\t{`\\uD83D\\uDE02`, \"\\U0001F602\"},\n\n\t\t// Invalid escapes\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\uD800`, `\\uD800`},\n\t\t{`\\uD800\\u`, `\\uD800\\u`},\n\n\t\t// Mixed content\n\t\t{`Hello\\tworld\\n`, \"Hello\\tworld\\n\"},\n\t\t{`\"This is a string with \\\\backslashes\\\\\"`, \"\\\"This is a string with \\\\backslashes\\\\\\\"\"},\n\t\t{`{\"key\": \"value with \\u00A0 unicode\"}`, `{\"key\": \"value with \\u00A0 unicode\"}`},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}","9077a4076d664e3c106ffc6a35892930":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantN    string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Basic cases\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"123.456\", \"123.456\", \"\", nil},\n\t\t{\"1.2e3\", \"1.2e3\", \"\", nil},\n\t\t{\"1.2E-3\", \"1.2E-3\", \"\", nil},\n\n\t\t// Trailing characters\n\t\t{\"123a\", \"123\", \"a\", nil},\n\t\t{\"123.456xyz\", \"123.456\", \"xyz\", nil},\n\n\t\t// Invalid numbers\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t\t{\"+\", \"\", \"+\", fmt.Errorf(\"unexpected char: %q\", \"+\")},\n\t\t(\"-\", \"\", \"-\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t\t(\".123\", \"\", \".123\", fmt.Errorf(\"unexpected char: %q\", \".\")},\n\n\t\t// Special cases: inf, nan\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"+inf\", \"+inf\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"InF\", \"InF\", \"\", nil},\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"+nan\", \"\", \"+nan\", fmt.Errorf(\"unexpected char: %q\", \"+\")}, // Invalid\n\t\t{\"-nan\", \"\", \"-nan\", fmt.Errorf(\"unexpected char: %q\", \"-\")}, // Invalid\n\n\t\t// Trailing characters after inf/nan\n\t\t{\"infx\", \"inf\", \"x\", nil},\n\t\t{\"nan,\", \"nan\", \",\", nil},\n\n\t\t// Incomplete inf/nan\n\t\t{\"in\", \"\", \"in\", fmt.Errorf(\"unexpected char: %q\", \"i\")},\n\t\t{\"na\", \"\", \"na\", fmt.Errorf(\"unexpected char: %q\", \"n\")},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tgotN, gotTail, gotErr := parseRawNumber(tt.input)\n\t\t\tif gotN != tt.wantN || gotTail != tt.wantTail || (gotErr != nil \u0026\u0026 tt.wantErr == nil) || (gotErr == nil \u0026\u0026 tt.wantErr != nil) || (gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error()) {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = (%q, %q, %v), want (%q, %q, %v)\", tt.input, gotN, gotTail, gotErr, tt.wantN, tt.wantTail, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}\n","90accc99b0223bbeeeeba3f4b5a0306c":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_reset(t *testing.T) {\n\to := \u0026Object{\n\t\tkvs:           make([]kv, 2),\n\t\tkeysUnescaped: true,\n\t}\n\to.reset()\n\tif len(o.kvs) != 1 {\n\t\tt.Errorf(\"Expected length of kvs to be 1, got %d\", len(o.kvs))\n\t}\n\tif o.keysUnescaped {\n\t\tt.Errorf(\"Expected keysUnescaped to be false, got true\")\n\t}\n}","927442f535b7e4a37d3a499635756263":"package fastjson\n\nimport \"testing\"\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    string\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\ts:    \"\",\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with leading whitespace\",\n\t\t\ts:    \"  foo\",\n\t\t\twant: \"foo\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with trailing whitespace\",\n\t\t\ts:    \"foo  \",\n\t\t\twant: \"foo  \",\n\t\t},\n\t\t{\n\t\t\tname: \"string with leading and trailing whitespace\",\n\t\t\ts:    \"  foo  \",\n\t\t\twant: \"foo  \",\n\t\t},\n\t\t{\n\t\t\tname: \"string with no whitespace\",\n\t\t\ts:    \"foo\",\n\t\t\twant: \"foo\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with only whitespace\",\n\t\t\ts:    \" \\t\\n\\r\",\n\t\t\twant: \"\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %q, want %q\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","931de4c9bc95fb1424329131cacd818c":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic escapes\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\t`, \"\\t\"},\n\t\t{`\\\\`, `\\`},\n\t\t{`\\\"`, `\"`},\n\t\t{`\\/`, `/`},\n\n\t\t// Unicode escapes\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u03c0`, \"œÄ\"},\n\t\t{`\\uFFFF`, \"Ôøø\"},\n\n\t\t// Surrogate pairs\n\t\t{`\\uD83D\\uDE02`, \"üòÇ\"},\n\n\t\t// Invalid escapes\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\uD800`, `\\uD800`}, // Invalid surrogate pair\n\t\t{`\\uD800\\u1234`, `\\uD800\\u1234`}, // Invalid surrogate pair\n\n\t\t// Mixed escapes\n\t\t{`Hello\\tworld\\n`, \"Hello\\tworld\\n\"},\n\t\t{`\\u0041\\u0020string\\twith\\nescapes`, \"A string\\twith\\nescapes\"},\n\n\t\t// No escapes\n\t\t{`Hello, world!`, \"Hello, world!\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}","944cf59ea2ceb697831d45af4347d2e0":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey   string\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Basic cases\n\t\t{`\"foo\"bar`, `foo`, `bar`, nil},\n\t\t{`\"foo\" bar`, `foo`, ` bar`, nil},\n\t\t{`\"foo\"  bar`, `foo`, `  bar`, nil},\n\n\t\t// Escaped quotes\n\t\t{`\"fo\\\"o\"bar`, `fo\"o`, `bar`, nil},\n\t\t{`\"fo\\\\\"o\"bar`, `fo\\\"o`, `bar`, nil},\n\t\t{`\"fo\\\\\\\\\"o\"bar`, `fo\\\\\"o`, `bar`, nil},\n\n\t\t// Missing closing quote\n\t\t{`\"foo`, ``, ``, fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"fo\\\"o`, ``, ``, fmt.Errorf(`missing closing '\"'`)},\n\n\t\t// Empty strings\n\t\t{`\"\"bar`, ``, `bar`, nil},\n\t\t{`\"foo\"\"bar`, `foo`, `\"bar`, nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d:%s\", i, tt.input), func(t *testing.T) {\n\t\t\tkey, tail, err := parseRawString(tt.input)\n\t\t\tif key != tt.key || tail != tt.tail || !equalError(err, tt.err) {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = (%q, %q, %v); want (%q, %q, %v)\", tt.input, key, tail, err, tt.key, tt.tail, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// equalError reports whether errors a and b are considered equal.\n// They're equal if both are nil, or both are not nil and have the same error message.\nfunc equalError(a, b error) bool {\n\treturn (a == nil \u0026\u0026 b == nil) || (a != nil \u0026\u0026 b != nil \u0026\u0026 a.Error() == b.Error())\n}","95389a6837d9eb3a84111077fcf4a879":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput    string\n\t\twantNum  string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Valid numbers\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"123.456\", \"123.456\", \"\", nil},\n\t\t{\"1.2e3\", \"1.2e3\", \"\", nil},\n\t\t{\"1.2E-3\", \"1.2E-3\", \"\", nil},\n\t\t{\"+123\", \"+123\", \"\", nil},\n\n\t\t// Valid numbers with trailing characters\n\t\t{\"123a\", \"123\", \"a\", nil},\n\t\t{\"-123 \", \"-123\", \" \", nil},\n\t\t{\"123.456,\", \"123.456\", \",\", nil},\n\n\t\t// Invalid numbers\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t\t{\"a123\", \"\", \"a123\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\"+a123\", \"\", \"+a123\", fmt.Errorf(\"unexpected char: %q\", \"+a\")},\n\t\t{\"-a123\", \"\", \"-a123\", fmt.Errorf(\"unexpected char: %q\", \"-a\")},\n\t\t{\".123\", \"\", \".123\", fmt.Errorf(\"unexpected char: %q\", \".\")},\n\n\t\t// NaN handling\n\t\t{\"NaN\", \"NaN\", \"\", nil},\n\t\t{\"nAn\", \"nAn\", \"\", nil},\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"NaN123\", \"NaN\", \"123\", nil},\n\t\t{\"nAn123\", \"nAn\", \"123\", nil},\n\t\t{\"nan123\", \"nan\", \"123\", nil},\n\t\t{\"Na\", \"\", \"Na\", fmt.Errorf(\"unexpected char: %q\", \"N\")},\n\t\t{\"na\", \"\", \"na\", fmt.Errorf(\"unexpected char: %q\", \"n\")},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"TestCase_%d\", i+1), func(t *testing.T) {\n\t\t\tgotNum, gotTail, gotErr := parseRawNumber(tc.input)\n\n\t\t\tif gotNum != tc.wantNum {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got number = %q, want %q\", tc.input, gotNum, tc.wantNum)\n\t\t\t}\n\t\t\tif gotTail != tc.wantTail {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got tail = %q, want %q\", tc.input, gotTail, tc.wantTail)\n\t\t\t}\n\t\t\tif gotErr == nil \u0026\u0026 tc.wantErr != nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got err = nil, want %v\", tc.input, tc.wantErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tc.wantErr == nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got err = %v, want nil\", tc.input, gotErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tc.wantErr != nil \u0026\u0026 gotErr.Error() != tc.wantErr.Error() {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got err = %v, want %v\", tc.input, gotErr, tc.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","962a6598fdf73728f2ed67799af5edd1":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\ts       string\n\t\twant    *Value\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tp := \u0026Parser{}\n\t\t\tgot, err := p.Parse(tt.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Parser.Parse() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Parser.Parse() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","973c84c52e171785247ca35616aa1d1f":"package fastjson\n\nimport \"testing\"\n\nfunc TestSkipWS(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"  \\t\\n foo\", \"foo\"},\n\t\t{\"bar\", \"bar\"},\n\t\t{\"\", \"\"},\n\t\t{\"   \", \"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := skipWS(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"skipWS(%q) = %q, want %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}","97f2c7add671ebe3902cf2bb0b7a7f33":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantJSON string\n\t\twantErr  error\n\t}{\n\t\t{\n\t\t\tname:     \"empty object\",\n\t\t\tinput:    \"{}\",\n\t\t\twantJSON: `{}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"simple object\",\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\twantJSON: `{\"key\":\"value\"}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"object with multiple values\",\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantJSON: `{\"key1\":\"value1\",\"key2\":\"value2\"}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"object with nested object\",\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": {\"key3\": \"value3\"}}`,\n\t\t\twantJSON: `{\"key1\":\"value1\",\"key2\":{\"key3\":\"value3\"}}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"object with array\",\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": [\"value2\", \"value3\"]}`,\n\t\t\twantJSON: `{\"key1\":\"value1\",\"key2\":[\"value2\",\"value3\"]}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"object with escaped characters\",\n\t\t\tinput:    `{\"key1\": \"value1\\nvalue2\", \"key2\": \"value2\\tvalue3\"}`,\n\t\t\twantJSON: `{\"key1\":\"value1\\nvalue2\",\"key2\":\"value2\\tvalue3\"}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid object: missing closing brace\",\n\t\t\tinput:    `{\"key\": \"value\"`,\n\t\t\twantErr: fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid object: missing colon\",\n\t\t\tinput:    `{\"key\" \"value\"}`,\n\t\t\twantErr: fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid object: missing comma\",\n\t\t\tinput:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, tail, err := parseObject(tt.input, c, 0)\n\n\t\t\tif tt.wantErr != nil {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"parseObject() error = nil, wantErr %v\", tt.wantErr)\n\t\t\t\t} else if err.Error() != tt.wantErr.Error() {\n\t\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr nil\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif len(tail) != 0 {\n\t\t\t\tt.Errorf(\"parseObject() tail = %q, want empty\", tail)\n\t\t\t}\n\n\t\t\tgotJSON := got.MarshalTo(nil)\n\t\t\tif string(gotJSON) != tt.wantJSON {\n\t\t\t\tt.Errorf(\"parseObject() = %s, want %s\", gotJSON, tt.wantJSON)\n\t\t\t}\n\t\t})\n\t}\n}\n","988e774d0c9bbf8ebec69401aa6197ef":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput  string\n\t\texpect string\n\t}{\n\t\t// Basic strings.\n\t\t{\"\", \"\"},\n\t\t{\"hello\", \"hello\"},\n\t\t{\"world\", \"world\"},\n\n\t\t// Simple escape sequences.\n\t\t{`\\\"`, `\"`},\n\t\t{`\\\\`, `\\`},\n\t\t{`\\/`, `/`},\n\t\t{`\\b`, \"\\b\"},\n\t\t{`\\f`, \"\\f\"},\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\r`, \"\\r\"},\n\t\t{`\\t`, \"\\t\"},\n\n\t\t// Unicode escape sequences.\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A0`, \"\\u00A0\"},\n\t\t{`\\u20AC`, \"\\u20AC\"},\n\t\t{`\\uD83D\\uDE01`, \"\\U0001F601\"},\n\n\t\t// Invalid escape sequences.\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\uD800`, `\\uD800`},\n\t\t{`\\uD83D\\uXXXX`, `\\uD83D\\uXXXX`},\n\n\t\t// Mixed strings.\n\t\t{`hello\\tworld`, \"hello\\tworld\"},\n\t\t{`\\u0022hello\\u0022`, `\"hello\"`},\n\t\t{`c:\\\\path\\\\to\\\\file`, `c:\\path\\to\\file`},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expect {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", test.input, actual, test.expect)\n\t\t}\n\t}\n}\n","98c795bf1798c0c906aef3710ac7839f":"package fastjson\n\nimport \"testing\"\n\nfunc Test_hasSpecialChars(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    string\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\ts:    \"\",\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with no special characters\",\n\t\t\ts:    \"hello world\",\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with backslash\",\n\t\t\ts:    \"hello\\\\world\",\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with control character\",\n\t\t\ts:    \"hello\\nworld\",\n\t\t\twant: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := hasSpecialChars(tt.s); got != tt.want {\n\t\t\t\tt.Errorf(\"hasSpecialChars() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","9914998199e4809edead0dd3661441c4":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey string\n\t\tvalue string\n\t\terr error\n\t}{\n\t\t// Basic cases\n\t\t{`\"foo\"bar`, \"foo\", \"bar\", nil},\n\t\t{`\"foo\" bar`, \"foo\", \" bar\", nil},\n\t\t{`\"foo\"  bar`, \"foo\", \"  bar\", nil},\n\t\t{`\"foo\"`, \"foo\", \"\", nil},\n\n\t\t// Escaped quotes\n\t\t{`\"fo\\\"o\"bar`, `fo\"o`, \"bar\", nil},\n\t\t{`\"fo\\\\\"o\"bar`, `fo\\\"o`, \"bar\", nil},\n\t\t{`\"fo\\\\\\\\\"o\"bar`, `fo\\\\\"o`, \"bar\", nil},\n\t\t{`\"fo\\\\\\\"o\"bar`, `fo\\\"o`, \"bar\", nil},\n\n\t\t// Errors\n\t\t{`\"foo`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"fo\\\"o`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`fo\"o\"`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t}\n\n\tfor i, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tkey, value, err := parseRawString(test.input)\n\t\t\tif key != test.key || value != test.value || !errorEqual(err, test.err) {\n\t\t\t\tt.Errorf(\"Input: %s, Expected: %s/%s/%v, Got: %s/%s/%v\", test.input, test.key, test.value, test.err, key, value, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc errorEqual(e1, e2 error) bool {\n\tif e1 == nil \u0026\u0026 e2 == nil {\n\t\treturn true\n\t}\n\tif e1 == nil || e2 == nil {\n\t\treturn false\n\t}\n\treturn e1.Error() == e2.Error()\n}","99f957235d301b83e920e28e6e699f3b":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput       string\n\t\texpected    *Value\n\t\texpectedStr string\n\t\texpectedErr error\n\t}{\n\t\t// Empty array\n\t\t{\"[]\", \u0026Value{t: TypeArray, a: []*Value{}}, \"\", nil},\n\t\t// Simple array\n\t\t{\"[1,2,3]\", \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t}}, \"\", nil},\n\t\t// Array with different types\n\t\t{`[\"hello\", true, 123.45, null]`, \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t{t: TypeString, s: \"hello\"},\n\t\t\t{t: TypeTrue},\n\t\t\t{t: TypeNumber, s: \"123.45\"},\n\t\t\t{t: TypeNull},\n\t\t}}, \"\", nil},\n\t\t// Nested array\n\t\t{`[1, [2, 3], 4]`, \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t}},\n\t\t\t{t: TypeNumber, s: \"4\"},\n\t\t}}, \"\", nil},\n\t\t// Array with whitespace\n\t\t{\" [ 1 , 2 , 3 ] \", \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t}}, \"\", nil},\n\t\t// Invalid array - missing closing bracket\n\t\t{\"[1,2,3\", nil, \"[1,2,3\", fmt.Errorf(\"missing ']'\")},\n\t\t// Invalid array - unexpected end\n\t\t{\"[1, 2,\", nil, \"[1, 2,\", fmt.Errorf(\"unexpected end of array\")},\n\t\t// Invalid array - missing comma\n\t\t{\"[1 2 3]\", nil, \"[1 2 3]\", fmt.Errorf(\"missing ',' after array value\")},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"Test case %d: %s\", i, tc.input), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tactual, str, err := parseArray(tc.input, c, 0)\n\n\t\t\tif tc.expectedErr != nil {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"Expected error %v, but got nil\", tc.expectedErr)\n\t\t\t\t} else if err.Error() != tc.expectedErr.Error() {\n\t\t\t\t\tt.Errorf(\"Expected error %v, but got %v\", tc.expectedErr, err)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t\t\t} else if !compareValues(actual, tc.expected) {\n\t\t\t\t\tt.Errorf(\"Expected value %v, but got %v\", tc.expected, actual)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif str != tc.expectedStr {\n\t\t\t\tt.Errorf(\"Expected remaining string %q, but got %q\", tc.expectedStr, str)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.s != v2.s {\n\t\treturn false\n\t}\n\tif len(v1.a) != len(v2.a) {\n\t\treturn false\n\t}\n\tfor i := range v1.a {\n\t\tif !compareValues(v1.a[i], v2.a[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","9a400049bc667439078b6f295edaa514":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\tstr      string\n\t\terr      error\n\t}{\n\t\t// Empty array\n\t\t{\"[]\", \u0026Value{t: TypeArray, a: []*Value{}}, \"\", nil},\n\n\t\t// Simple array\n\t\t{\"[1,2,3]\", \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t}}, \"\", nil},\n\n\t\t// Array with different types\n\t\t{\"[1,\\\"foo\\\",true,null]\", \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t{t: TypeString, s: \"foo\"},\n\t\t\t{t: TypeTrue},\n\t\t\t{t: TypeNull},\n\t\t}}, \"\", nil},\n\n\t\t// Nested array\n\t\t{\"[[1,2],[3,4]]\", \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t}},\n\t\t\t{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t{t: TypeNumber, s: \"4\"},\n\t\t\t}},\n\t\t}}, \"\", nil},\n\n\t\t// Array with whitespace\n\t\t{\" [ 1 , 2 , 3 ] \", \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t}}, \"\", nil},\n\n\t\t// Invalid array - missing closing bracket\n\t\t{\"[1,2,3\", nil, \"\", fmt.Errorf(\"unexpected end of array\")},\n\n\t\t// Invalid array - missing comma\n\t\t{\"[1 2 3]\", nil, \"2 3]\", fmt.Errorf(\"missing ',' after array value\")},\n\n\t\t// Invalid array - trailing comma\n\t\t{\"[1,2,3,]\", nil, \"\", fmt.Errorf(\"cannot parse array value: unexpected end of JSON\")},\n\t}\n\n\tfor i, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i+1), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tactual, str, err := parseArray(test.input, c, 0)\n\n\t\t\tif test.err != nil {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"Expected error, got nil\")\n\t\t\t\t} else if err.Error() != test.err.Error() {\n\t\t\t\t\tt.Errorf(\"Expected error %v, got %v\", test.err, err)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif str != test.str {\n\t\t\t\tt.Errorf(\"Expected remaining string %q, got %q\", test.str, str)\n\t\t\t}\n\n\t\t\tif !equalValues(actual, test.expected) {\n\t\t\t\tt.Errorf(\"Test %d failed. Expected %v, got %v\", i+1, test.expected, actual)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.s != v2.s {\n\t\treturn false\n\t}\n\tif len(v1.a) != len(v2.a) {\n\t\treturn false\n\t}\n\tfor i := range v1.a {\n\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","9b380eec8fa2e09aba0eeacd0f8da3ef":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic escapes\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\t`, \"\\t\"},\n\t\t{`\\\\`, \"\\\\\"},\n\t\t{`\\\"`, \"\\\"\"},\n\t\t{`\\/`, \"/\"},\n\n\t\t// Unicode escapes\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A0`, \"\\u00A0\"},\n\t\t{`\\uFFFF`, \"\\uFFFF\"},\n\n\t\t// Surrogate pairs\n\t\t{`\\uD83D\\uDE02`, \"\\U0001F602\"},\n\n\t\t// Invalid escapes\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\uD800`, `\\uD800`},\n\t\t{`\\uD800\\u`, `\\uD800\\u`},\n\n\t\t// Mixed content\n\t\t{`Hello\\tworld\\n`, \"Hello\\tworld\\n\"},\n\t\t{`\"This is a string with \\\\backslashes\\\\\"`, \"\\\"This is a string with \\\\backslashes\\\\\\\"\"},\n\t\t{`{\"key\": \"value with \\u00A0 unicode\"}`, `{\"key\": \"value with \\u00A0 unicode\"}`},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}\n","9c63bb399dab302f6903eab6bf141443":"package fastjson\n\nimport \"testing\"\n\nfunc TestCache_getValue(t *testing.T) {\n\tt.Run(\"getValue with empty cache\", func(t *testing.T) {\n\t\tc := \u0026cache{}\n\t\tv := c.getValue()\n\n\t\tif v == nil {\n\t\t\tt.Errorf(\"Expected a non-nil value, got nil\")\n\t\t}\n\t})\n\n\tt.Run(\"getValue with non-empty cache\", func(t *testing.T) {\n\t\tc := \u0026cache{\n\t\t\tvs: make([]Value, 1),\n\t\t}\n\t\tv := c.getValue()\n\n\t\tif v == nil {\n\t\t\tt.Errorf(\"Expected a non-nil value, got nil\")\n\t\t}\n\n\t\tif len(c.vs) != 2 {\n\t\t\tt.Errorf(\"Expected cache length to be 2, got %d\", len(c.vs))\n\t\t}\n\t})\n\n\tt.Run(\"getValue with full cache\", func(t *testing.T) {\n\t\tc := \u0026cache{\n\t\t\tvs: make([]Value, 10),\n\t\t}\n\t\tv := c.getValue()\n\n\t\tif v == nil {\n\t\t\tt.Errorf(\"Expected a non-nil value, got nil\")\n\t\t}\n\n\t\tif len(c.vs) != 11 {\n\t\t\tt.Errorf(\"Expected cache length to be 11, got %d\", len(c.vs))\n\t\t}\n\t})\n}","9d1c733b765c6e5bb2e318b7bf7b1f1d":"package fastjson\n\nimport \"testing\"\n\nfunc TestValue_GetFloat64(t *testing.T) {\n\tvar v Value\n\ttests := []struct {\n\t\tjson     string\n\t\tkeys     []string\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\t`{\"a\": 1.23}`,\n\t\t\t[]string{\"a\"},\n\t\t\t1.23,\n\t\t},\n\t\t{\n\t\t\t`{\"a\": \"1.23\"}`,\n\t\t\t[]string{\"a\"},\n\t\t\t1.23,\n\t\t},\n\t\t{\n\t\t\t`{\"a\": \"1.23e+10\"}`,\n\t\t\t[]string{\"a\"},\n\t\t\t1.23e+10,\n\t\t},\n\t\t{\n\t\t\t`{\"a\": \"1234\"}`,\n\t\t\t[]string{\"a\"},\n\t\t\t1234,\n\t\t},\n\t\t{\n\t\t\t`{\"a\": \"12.34.56\"}`,\n\t\t\t[]string{\"a\"},\n\t\t\t0,\n\t\t},\n\t\t{\n\t\t\t`{\"a\": [1, 2, 3.14]}`,\n\t\t\t[]string{\"a\", \"2\"},\n\t\t\t3.14,\n\t\t},\n\t\t{\n\t\t\t`{\"a\": {\"b\": 4.56}}`,\n\t\t\t[]string{\"a\", \"b\"},\n\t\t\t4.56,\n\t\t},\n\t\t{\n\t\t\t`{\"a\": {\"b\": \"4.56e-10\"}}`,\n\t\t\t[]string{\"a\", \"b\"},\n\t\t\t4.56e-10,\n\t\t},\n\t\t{\n\t\t\t`{\"a\": [1, 2, {\"b\": 7.89}]}`,\n\t\t\t[]string{\"a\", \"2\", \"b\"},\n\t\t\t7.89,\n\t\t},\n\t\t{\n\t\t\t`{\"a\": {\"b\": [1, 2, {\"c\": 9.01}]}}`,\n\t\t\t[]string{\"a\", \"b\", \"2\", \"c\"},\n\t\t\t9.01,\n\t\t},\n\t\t// Test array indexes as decimal numbers\n\t\t{\n\t\t\t`{\"a\": [1, 2, [3, 4, 5.67]]}`,\n\t\t\t[]string{\"a\", \"2.0\", \"2.0\"},\n\t\t\t5.67,\n\t\t},\n\t\t// Test non-existing keys\n\t\t{\n\t\t\t`{\"a\": 1.23}`,\n\t\t\t[]string{\"b\"},\n\t\t\t0,\n\t\t},\n\t\t{\n\t\t\t`{\"a\": 1.23}`,\n\t\t\t[]string{\"a\", \"b\"},\n\t\t\t0,\n\t\t},\n\t\t// Test invalid value type\n\t\t{\n\t\t\t`{\"a\": \"hello\"}`,\n\t\t\t[]string{\"a\"},\n\t\t\t0,\n\t\t},\n\t\t{\n\t\t\t`{\"a\": true}`,\n\t\t\t[]string{\"a\"},\n\t\t\t0,\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\terr := v.Unmarshal([]byte(tt.json))\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Test %d: failed to unmarshal json %q: %v\", i, tt.json, err)\n\t\t\tcontinue\n\t\t}\n\t\tresult := v.GetFloat64(tt.keys...)\n\t\tif result != tt.expected {\n\t\t\tt.Errorf(\"Test %d: GetFloat64(%q) = %v, want %v\", i, tt.keys, result, tt.expected)\n\t\t}\n\t}\n}","9d722c9775b36fd5ffebc9644db7afd5":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey   string\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t{\"\\\"key\\\":123\", \"key\", \":123\", nil},\n\t\t{\"\\\"key with space\\\":123\", \"key with space\", \":123\", nil},\n\t\t{\"key\\\":123\", \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{\"\\\"key\\\\\\\"escaped\\\\\\\"\\\":123\", \"\", \"\", nil},\n\t}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tkey, tail, err := parseRawKey(tt.input)\n\t\t\tif key != tt.key || tail != tt.tail {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"parseRawKey(%q) = (%q, %q, %v), want (%q, %q, %v)\", tt.input, key, tail, err, tt.key, tt.tail, tt.err)\n\t\t\t\t} else if tt.err == nil || err.Error() != tt.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseRawKey(%q) = (%q, %q, %v), want (%q, %q, %v)\", tt.input, key, tail, err, tt.key, tt.tail, tt.err)\n\t\t\t\t}\n\t\t\t} else if err != nil \u0026\u0026 tt.err == nil {\n\t\t\t\tt.Errorf(\"parseRawKey(%q) error = %v, wantErr %v\", tt.input, err, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}","9ded4cbbfb091b99193517a3125351b6":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic strings\n\t\t{\"hello\", \"hello\"},\n\t\t{\"world\", \"world\"},\n\n\t\t// Escaped characters\n\t\t{`\\\"hello\\\"`, `\"hello\"`},\n\t\t{`\\\\world\\\\`, `\\world\\`},\n\t\t{`\\bfoo\\tbar\\nbaz`, \"\\bfoo\\tbar\\nbaz\"},\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A0`, \"\\u00A0\"}, // Non-breaking space, should be unescaped\n\n\t\t// Invalid escape sequences\n\t\t{`\\z`, `\\z`},\n\t\t{`\\u002`, `\\u002`},\n\t\t{`\\u002x`, `\\u002x`},\n\n\t\t// Surrogate pairs\n\t\t{`\\uD83D\\uDE02`, \"\\U0001F602\"}, // üòÇ\n\n\t\t// Mixed strings\n\t\t{`hello\\t\"world\"`, \"hello\\t\\\"world\\\"\"},\n\t\t{`\\uD83D\\uDE02 is funny!\\n`, \"\\U0001F602 is funny!\\n\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}\n","9e07e1684a9175571829fc4b6c2848ae":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Get(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tjson string\n\t\targs []string\n\t\twant *Value\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\ts := \u0026Parser{}\n\t\t\tv, _ := s.Parse(tt.json)\n\t\t\tif got := v.Get(tt.args...); got != tt.want {\n\t\t\t\tt.Errorf(\"Value.Get() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","9e0ed56369c9670fc81d5c33642bb3d0":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWS(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"  \\t\\n foo\", \"foo\"},\n\t\t{\"bar\", \"bar\"},\n\t\t{\"\", \"\"},\n\t\t{\"\\x00\", \"\\x00\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := skipWS(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"skipWS(%q) = %q, want %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}","9e524aa14aefac4ab3ed67beab293c90":"package fastjson\n\nimport \"testing\"\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"  foo\", \"foo\"},\n\t\t{\"\\n\\n\\tbar\", \"bar\"},\n\t\t{\"\\r\\n  baz\", \"baz\"},\n\t\t{\"qux\", \"qux\"},\n\t\t{\"\", \"\"},\n\t\t{\"\\t\", \"\"},\n\t\t{\"\\n\\r\", \"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := skipWSSlow(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"skipWSSlow(%q) = %q, expected %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}","9ecd12b15090c9fb41c1b44b254548bd":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput  string\n\t\texpect string\n\t\ttail   string\n\t\terr    error\n\t}{\n\t\t// Basic cases\n\t\t{`\"hello\"`, `hello`, ``, nil},\n\t\t{`\"hello world\"`, `hello world`, ``, nil},\n\t\t{`\"hello\\\"world\"`, `hello\"world`, ``, nil},\n\t\t{`\"hello\\\\world\"`, `hello\\world`, ``, nil},\n\t\t{`\"hello\\nworld\"`, `hello\\nworld`, ``, nil},\n\n\t\t// Empty strings\n\t\t{`\"\"`, ``, ``, nil},\n\t\t{`\"\"\"\"`, `\"`, ``, nil},\n\n\t\t// Escaped quotes\n\t\t{`\"\\\\\"\"`, `\\\"`, ``, nil},\n\t\t{`\"\\\\\\\"\"`, `\\\"`, ``, nil},\n\t\t{`\"\\\\\\\\\\\"\"`, `\\\\\"`, ``, nil},\n\n\t\t// Invalid strings\n\t\t{`\"hello`, ``, ``, fmt.Errorf(`missing closing '\"'`)},\n\t\t{`hello\"`, ``, ``, fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"hello\"world`, ``, ``, fmt.Errorf(`missing closing '\"'`)},\n\t}\n\n\tfor i, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tresult, tail, err := parseRawString(test.input)\n\n\t\t\tif test.err != nil {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"Expected error, got nil\")\n\t\t\t\t} else if err.Error() != test.err.Error() {\n\t\t\t\t\tt.Errorf(\"Expected error %q, got %q\", test.err, err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t\t}\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"Expected %q, got %q\", test.expect, result)\n\t\t\t}\n\t\t\tif tail != test.tail {\n\t\t\t\tt.Errorf(\"Expected tail %q, got %q\", test.tail, tail)\n\t\t\t}\n\t\t})\n\t}\n}","9f53176c39cd51e97ea861dcb0f5391f":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Empty string\n\t\t{\"\", nil, \"\", fmt.Errorf(\"cannot parse empty string\")},\n\t\t// Invalid JSON\n\t\t{\"{\", nil, \"\", fmt.Errorf(\"cannot parse object: unexpected EOF\")},\n\t\t// Object\n\t\t{`{\"foo\": \"bar\"}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: typeRawString, s: \"bar\"}}}}}, \"\", nil},\n\t\t// Array\n\t\t{`[1, 2, 3]`, \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}}, \"\", nil},\n\t\t// String\n\t\t{`\"hello\"`, \u0026Value{t: typeRawString, s: \"hello\"}, \"\", nil},\n\t\t// True\n\t\t{\"true\", valueTrue, \"\", nil},\n\t\t// False\n\t\t{\"false\", valueFalse, \"\", nil},\n\t\t// Null\n\t\t{\"null\", valueNull, \"\", nil},\n\t\t// Number\n\t\t{\"123\", \u0026Value{t: TypeNumber, s: \"123\"}, \"\", nil},\n\t\t// NaN\n\t\t{\"NaN\", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"\", nil},\n\t\t// Trailing whitespace\n\t\t{\"true \", valueTrue, \" \", nil},\n\t\t// Number with exponent\n\t\t{\"1.23e4\", \u0026Value{t: TypeNumber, s: \"1.23e4\"}, \"\", nil},\n\t\t// Negative number\n\t\t{\"-123\", \u0026Value{t: TypeNumber, s: \"-123\"}, \"\", nil},\n\t\t// Number with leading zero\n\t\t{\"0.123\", \u0026Value{t: TypeNumber, s: \"0.123\"}, \"\", nil},\n\t\t// Invalid number\n\t\t{\"123a\", nil, \"123a\", fmt.Errorf(\"cannot parse number: invalid syntax\")},\n\t\t// Unexpected value\n\t\t{\"xyz\", nil, \"xyz\", fmt.Errorf(\"unexpected value found: \\\"xyz\\\"\")},\n\t}\n\n\tc := \u0026cache{}\n\tfor i, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test case %d: %s\", i+1, test.input), func(t *testing.T) {\n\t\t\tgot, tail, err := parseValue(test.input, c, 0)\n\t\t\tif test.err != nil {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"Expected error, got nil\")\n\t\t\t\t} else if err.Error() != test.err.Error() {\n\t\t\t\t\tt.Errorf(\"Expected error %q, got %q\", test.err, err)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t\t\t} else if !equalValues(got, test.want) {\n\t\t\t\t\tt.Errorf(\"Expected value %v, got %v\", test.want, got)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif tail != test.tail {\n\t\t\t\tt.Errorf(\"Expected tail %q, got %q\", test.tail, tail)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn equalObjects(\u0026v1.o, \u0026v2.o)\n\tcase TypeArray:\n\t\treturn equalArrays(v1.a, v2.a)\n\tcase typeRawString, TypeNumber:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\treturn true\n\t}\n}\n\nfunc equalObjects(o1, o2 *Object) bool {\n\tif o1.Len() != o2.Len() {\n\t\treturn false\n\t}\n\tfor _, kv1 := range o1.kvs {\n\t\tkv2 := o2.Get(kv1.k)\n\t\tif kv2 == nil || !equalValues(kv1.v, kv2) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc equalArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i := range a1 {\n\t\tif !equalValues(a1[i], a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n","9f91440c10436878372c66e4c407c431":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc Test_escapeString(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\ts   string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"SimpleString\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\ts:   \"hello\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello\"),\n\t\t},\n\t\t{\n\t\t\tname: \"StringWithEscapedChars\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\ts:   \"he\\tl\\nlo\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"he\\\\tl\\\\nlo\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := escapeString(tt.args.dst, tt.args.s); string(got) != string(tt.want) {\n\t\t\t\tt.Errorf(\"escapeString() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","9fedd9038220768c2bac39e510f99dc1":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCache_getValue(t *testing.T) {\n\tt.Run(\"empty cache\", func(t *testing.T) {\n\t\tc := \u0026cache{}\n\t\tv := c.getValue()\n\n\t\tif v == nil {\n\t\t\tt.Fatal(\"Expected a non-nil value, got nil\")\n\t\t}\n\n\t\tif len(c.vs) != 1 {\n\t\t\tt.Errorf(\"Expected cache length to be 1, got %d\", len(c.vs))\n\t\t}\n\t})\n\n\tt.Run(\"cache with existing values\", func(t *testing.T) {\n\t\tc := \u0026cache{\n\t\t\tvs: make([]Value, 2),\n\t\t}\n\t\tv := c.getValue()\n\n\t\tif v == nil {\n\t\t\tt.Fatal(\"Expected a non-nil value, got nil\")\n\t\t}\n\n\t\tif len(c.vs) != 3 {\n\t\t\tt.Errorf(\"Expected cache length to be 3, got %d\", len(c.vs))\n\t\t}\n\t})\n\n\tt.Run(\"cache at capacity\", func(t *testing.T) {\n\t\tc := \u0026cache{\n\t\t\tvs: make([]Value, 10, 10),\n\t\t}\n\t\tv := c.getValue()\n\n\t\tif v == nil {\n\t\t\tt.Fatal(\"Expected a non-nil value, got nil\")\n\t\t}\n\n\t\tif len(c.vs) != 11 {\n\t\t\tt.Errorf(\"Expected cache length to be 11, got %d\", len(c.vs))\n\t\t}\n\n\t\tif cap(c.vs) != 20 {\n\t\t\tt.Errorf(\"Expected cache capacity to be 20, got %d\", cap(c.vs))\n\t\t}\n\t})\n}\n","a0373d3677e79e645b6cf3ae1430e524":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\tstr      string\n\t\terr      error\n\t}{\n\t\t// Empty array\n\t\t{\"[]\", \u0026Value{t: TypeArray}, \"\", nil},\n\t\t// Simple array\n\t\t{\"[1,2,3]\", \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}}, \"\", nil},\n\t\t// Array with whitespace\n\t\t{\" [ 1 , 2 , 3 ] \", \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}}, \"\", nil},\n\t\t// Array with nested arrays\n\t\t{\"[[1,2],[3,4]]\", \u0026Value{t: TypeArray, a: []*Value{{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}}}, {t: TypeArray, a: []*Value{{t: TypeNumber, s: \"3\"}, {t: TypeNumber, s: \"4\"}}}}}, \"\", nil},\n\t\t// Array with different value types\n\t\t{\"[1,\\\"hello\\\",true,null]\", \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeString, s: \"hello\"}, {t: TypeTrue}, {t: TypeNull}}}, \"\", nil},\n\t\t// Invalid array - missing closing bracket\n\t\t{\"[1,2,3\", nil, \"\", fmt.Errorf(\"unexpected end of array\")},\n\t\t// Invalid array - missing comma\n\t\t{\"[1 2 3]\", nil, \"2 3]\", fmt.Errorf(\"missing ',' after array value\")},\n\t\t// Invalid array - trailing comma\n\t\t{\"[1,2,]\", nil, \"\", fmt.Errorf(\"cannot parse array value: unexpected end of JSON\")},\n\t}\n\n\tc := \u0026cache{}\n\tfor i, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test %d\", i), func(t *testing.T) {\n\t\t\tv, str, err := parseArray(test.input, c, 0)\n\n\t\t\tif err != nil {\n\t\t\t\tif test.err == nil {\n\t\t\t\t\tt.Errorf(\"Expected no error, got %v\", err)\n\t\t\t\t} else if err.Error() != test.err.Error() {\n\t\t\t\t\tt.Errorf(\"Expected error %v, got %v\", test.err, err)\n\t\t\t\t}\n\t\t\t} else if test.err != nil {\n\t\t\t\tt.Errorf(\"Expected error %v, got nil\", test.err)\n\t\t\t}\n\n\t\t\tif v == nil \u0026\u0026 test.expected != nil {\n\t\t\t\tt.Errorf(\"Expected non-nil value, got nil\")\n\t\t\t} else if v != nil \u0026\u0026 test.expected == nil {\n\t\t\t\tt.Errorf(\"Expected nil value, got %v\", v)\n\t\t\t} else if v != nil \u0026\u0026 test.expected != nil {\n\t\t\t\tif v.t != test.expected.t {\n\t\t\t\t\tt.Errorf(\"Expected type %v, got %v\", test.expected.t, v.t)\n\t\t\t\t}\n\t\t\t\tif len(v.a) != len(test.expected.a) {\n\t\t\t\t\tt.Errorf(\"Expected array length %d, got %d\", len(test.expected.a), len(v.a))\n\t\t\t\t} else {\n\t\t\t\t\tfor j := range v.a {\n\t\t\t\t\t\tif v.a[j].t != test.expected.a[j].t {\n\t\t\t\t\t\t\tt.Errorf(\"Expected type %v for element %d, got %v\", test.expected.a[j].t, j, v.a[j].t)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif v.a[j].s != test.expected.a[j].s {\n\t\t\t\t\t\t\tt.Errorf(\"Expected value %q for element %d, got %q\", test.expected.a[j].s, j, v.a[j].s)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif str != test.str {\n\t\t\t\tt.Errorf(\"Expected remaining string %q, got %q\", test.str, str)\n\t\t\t}\n\t\t})\n\t}\n}","a0be294fe6b017709180cd40c5a0fee5":"package fastjson\n\nimport \"testing\"\n\nfunc TestValue_GetFloat64(t *testing.T) {\n\tvar v Value\n\ttests := []struct {\n\t\tname  string\n\t\tinput string\n\t\tkeys  []string\n\t\twant  float64\n\t}{\n\t\t{\n\t\t\tname:  \"simple\",\n\t\t\tinput: `{\"foo\": 123.456}`,\n\t\t\tkeys:  []string{\"foo\"},\n\t\t\twant:  123.456,\n\t\t},\n\t\t{\n\t\t\tname:  \"nested\",\n\t\t\tinput: `{\"bar\": {\"baz\": 789.012}}`,\n\t\t\tkeys:  []string{\"bar\", \"baz\"},\n\t\t\twant:  789.012,\n\t\t},\n\t\t{\n\t\t\tname:  \"array\",\n\t\t\tinput: `{\"qux\": [1.2, 3.4, 5.6]}`,\n\t\t\tkeys:  []string{\"qux\", \"1\"},\n\t\t\twant:  3.4,\n\t\t},\n\t\t{\n\t\t\tname:  \"array decimal index\",\n\t\t\tinput: `{\"qux\": [1.2, 3.4, 5.6]}`,\n\t\t\tkeys:  []string{\"qux\", \"1.0\"},\n\t\t\twant:  3.4,\n\t\t},\n\t\t{\n\t\t\tname:  \"nonexistent key\",\n\t\t\tinput: `{\"foo\": 123.456}`,\n\t\t\tkeys:  []string{\"bar\"},\n\t\t\twant:  0,\n\t\t},\n\t\t{\n\t\t\tname:  \"invalid value type\",\n\t\t\tinput: `{\"foo\": \"not a number\"}`,\n\t\t\tkeys:  []string{\"foo\"},\n\t\t\twant:  0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv.Parse(tt.input)\n\t\t\tif got := v.GetFloat64(tt.keys...); got != tt.want {\n\t\t\t\tt.Errorf(\"Value.GetFloat64() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","a182a5363911766a168f3e7aaec2dfd7":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"raw string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"raw string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"12345\",\n\t\t\t},\n\t\t\twant: []byte(\"12345\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"string\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"12345\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"[\\\"string\\\",12345]\"),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"string\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"string\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"number\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"12345\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"{\\\"string\\\":\\\"string\\\",\\\"number\\\":12345}\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif string(got) != string(tt.want) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %v, want %v\", string(got), string(tt.want))\n\t\t\t}\n\t\t})\n\t}\n}","a1999ce8c66e2667b511eb94b5a41394":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantN    string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Basic cases\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"123.456\", \"123.456\", \"\", nil},\n\t\t{\"1.2e3\", \"1.2e3\", \"\", nil},\n\t\t{\"1.2E-3\", \"1.2E-3\", \"\", nil},\n\n\t\t// Trailing characters\n\t\t{\"123a\", \"123\", \"a\", nil},\n\t\t{\"123.456 \", \"123.456\", \" \", nil},\n\n\t\t// Invalid numbers\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t\t{\"+\", \"\", \"+\", fmt.Errorf(\"unexpected char: %q\", \"+\")},\n\t\t{\"-\", \"\", \"-\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t\t{\"a123\", \"\", \"a123\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\n\t\t// Special values\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"+inf\", \"+inf\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"InF\", \"InF\", \"\", nil},\n\t\t{\"inF123\", \"inF\", \"123\", nil},\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"+nan\", \"+nan\", \"\", nil},\n\t\t{\"-nan\", \"-nan\", \"\", nil},\n\t\t{\"naN\", \"naN\", \"\", nil},\n\t\t{\"NAN123\", \"NAN\", \"123\", nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tgotN, gotTail, gotErr := parseRawNumber(tt.input)\n\t\t\tif gotN != tt.wantN {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got number = %q, want %q\", tt.input, gotN, tt.wantN)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got tail = %q, want %q\", tt.input, gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif gotErr == nil \u0026\u0026 tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got err = nil, want %v\", tt.input, tt.wantErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr == nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got err = %v, want nil\", tt.input, gotErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got err = %v, want %v\", tt.input, gotErr, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}\n","a1df8c3e567b7b354393345c6fe5b1af":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Get(t *testing.T) {\n\t// Test cases for Get function\n\ttests := []struct {\n\t\tname   string\n\t\tjson   string\n\t\tkeys   []string\n\t\texpect *Value\n\t}{\n\t\t// Test case 1: Accessing existing key in a simple object\n\t\t{\n\t\t\t\"SimpleObjectExistingKey\",\n\t\t\t`{\"name\": \"John\", \"age\": 30}`,\n\t\t\t[]string{\"name\"},\n\t\t\t\u0026Value{t: TypeString, s: \"John\"},\n\t\t},\n\t\t// Test case 2: Accessing non-existing key in a simple object\n\t\t{\n\t\t\t\"SimpleObjectNonExistingKey\",\n\t\t\t`{\"name\": \"John\", \"age\": 30}`,\n\t\t\t[]string{\"city\"},\n\t\t\tnil,\n\t\t},\n\t\t// Test case 3: Accessing nested key in a complex object\n\t\t{\n\t\t\t\"ComplexObjectNestedKey\",\n\t\t\t`{\"person\": {\"name\": \"John\", \"address\": {\"street\": \"123 Main St\"}}}`,\n\t\t\t[]string{\"person\", \"address\", \"street\"},\n\t\t\t\u0026Value{t: TypeString, s: \"123 Main St\"},\n\t\t},\n\t\t// Test case 4: Accessing array element by index\n\t\t{\n\t\t\t\"ArrayElementByIndex\",\n\t\t\t`{\"fruits\": [\"apple\", \"banana\", \"orange\"]}`,\n\t\t\t[]string{\"fruits\", \"1\"},\n\t\t\t\u0026Value{t: TypeString, s: \"banana\"},\n\t\t},\n\t\t// Test case 5: Accessing key in an object within an array\n\t\t{\n\t\t\t\"KeyInObjectWithinArray\",\n\t\t\t`{\"people\": [{\"name\": \"John\", \"age\": 30}, {\"name\": \"Jane\", \"age\": 25}]}`,\n\t\t\t[]string{\"people\", \"1\", \"name\"},\n\t\t\t\u0026Value{t: TypeString, s: \"Jane\"},\n\t\t},\n\t\t// Test case 6: Accessing non-existing array index\n\t\t{\n\t\t\t\"NonExistingArrayIndex\",\n\t\t\t`{\"fruits\": [\"apple\", \"banana\", \"orange\"]}`,\n\t\t\t[]string{\"fruits\", \"3\"},\n\t\t\tnil,\n\t\t},\n\t\t// Test case 7: Accessing key with invalid type\n\t\t{\n\t\t\t\"InvalidKeyType\",\n\t\t\t`{\"name\": 123}`,\n\t\t\t[]string{\"name\", \"test\"},\n\t\t\tnil,\n\t\t},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tv, _ := Parse(tc.json)\n\t\t\tresult := v.Get(tc.keys...)\n\n\t\t\t// Compare result with expected value\n\t\t\tif (result == nil \u0026\u0026 tc.expect != nil) || (result != nil \u0026\u0026 tc.expect == nil) {\n\t\t\t\tt.Errorf(\"Expected %v, but got %v\", tc.expect, result)\n\t\t\t} else if result != nil \u0026\u0026 tc.expect != nil {\n\t\t\t\tif result.t != tc.expect.t || result.s != tc.expect.s {\n\t\t\t\t\tt.Errorf(\"Expected %v, but got %v\", tc.expect, result)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","a235cfa8a800f97d978cf0010f204605":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Empty string\n\t\t{\"\", nil, \"\", fmt.Errorf(\"cannot parse empty string\")},\n\t\t// Invalid JSON\n\t\t{\"{invalid}\", nil, \"\", fmt.Errorf(\"cannot parse object: invalid character 'i' looking for beginning of value\")},\n\t\t// Object\n\t\t{`{\"key\": \"value\"}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{t: typeRawString, s: \"value\"}}}}}, \"\", nil},\n\t\t// Array\n\t\t{`[1, \"two\", true]`, \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: typeRawString, s: \"two\"}, {t: TypeTrue}}}, \"\", nil},\n\t\t// String\n\t\t{`\"hello\"`, \u0026Value{t: typeRawString, s: \"hello\"}, \"\", nil},\n\t\t// True\n\t\t{\"true\", valueTrue, \"\", nil},\n\t\t// False\n\t\t{\"false\", valueFalse, \"\", nil},\n\t\t// Null\n\t\t{\"null\", valueNull, \"\", nil},\n\t\t// Number\n\t\t{\"12345\", \u0026Value{t: TypeNumber, s: \"12345\"}, \"\", nil},\n\t\t// NaN\n\t\t{\"NaN\", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"\", nil},\n\t\t// Trailing whitespace\n\t\t{\"true  \", valueTrue, \"  \", nil},\n\t\t// Number with exponent\n\t\t{\"1.23e4\", \u0026Value{t: TypeNumber, s: \"1.23e4\"}, \"\", nil},\n\t\t// Negative number\n\t\t{\"-123\", \u0026Value{t: TypeNumber, s: \"-123\"}, \"\", nil},\n\t}\n\n\tc := \u0026cache{}\n\tfor i, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tgot, tail, err := parseValue(test.input, c, 0)\n\n\t\t\tif test.err != nil {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"Expected error, got nil\")\n\t\t\t\t} else if err.Error() != test.err.Error() {\n\t\t\t\t\tt.Errorf(\"Expected error %v, got %v\", test.err, err)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif tail != test.tail {\n\t\t\t\tt.Errorf(\"Expected tail %q, got %q\", test.tail, tail)\n\t\t\t}\n\n\t\t\tif !equalValues(got, test.want) {\n\t\t\t\tt.Errorf(\"Test %d failed. Expected %v, got %v\", i, test.want, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.t == TypeObject {\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\tif v1.t == TypeArray {\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\treturn v1.s == v2.s\n}","a25d25f02f8b86580274389aa74aef8f":"","a26b80d5cf03fc8984eb5057109c119c":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Empty string\n\t\t{\"\", nil, \"\", fmt.Errorf(\"cannot parse empty string\")},\n\n\t\t// Object\n\t\t{`{\"foo\":\"bar\"}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: typeRawString, s: \"bar\"}}}}}, \"\", nil},\n\n\t\t// Array\n\t\t{`[1,2,3]`, \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}}, \"\", nil},\n\n\t\t// String\n\t\t{`\"hello\"`, \u0026Value{t: typeRawString, s: \"hello\"}, \"\", nil},\n\n\t\t// True\n\t\t{\"true\", valueTrue, \"\", nil},\n\n\t\t// False\n\t\t{\"false\", valueFalse, \"\", nil},\n\n\t\t// Null\n\t\t{\"null\", valueNull, \"\", nil},\n\n\t\t// Number\n\t\t{\"123\", \u0026Value{t: TypeNumber, s: \"123\"}, \"\", nil},\n\t\t{\"-123\", \u0026Value{t: TypeNumber, s: \"-123\"}, \"\", nil},\n\t\t{\"123.456\", \u0026Value{t: TypeNumber, s: \"123.456\"}, \"\", nil},\n\t\t{\"-123.456\", \u0026Value{t: TypeNumber, s: \"-123.456\"}, \"\", nil},\n\t\t{\"1e10\", \u0026Value{t: TypeNumber, s: \"1e10\"}, \"\", nil},\n\n\t\t// NaN\n\t\t{\"NaN\", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"\", nil},\n\n\t\t// Trailing whitespace\n\t\t{\"true \", valueTrue, \" \", nil},\n\n\t\t// Invalid input\n\t\t{\"invalid\", nil, \"invalid\", fmt.Errorf(\"cannot parse number: invalid\")},\n\t}\n\n\tc := \u0026cache{}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test %d - %s\", i, tt.input), func(t *testing.T) {\n\t\t\tgot, tail, err := parseValue(tt.input, c, 0)\n\n\t\t\tif tt.err != nil {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"Expected error, got nil\")\n\t\t\t\t} else if err.Error() != tt.err.Error() {\n\t\t\t\t\tt.Errorf(\"Expected error %v, got %v\", tt.err, err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t\t}\n\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"Expected tail %q, got %q\", tt.tail, tail)\n\t\t\t}\n\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"Expected value %v, got %v\", tt.want, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.t == TypeObject {\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\tif v1.t == TypeArray {\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\treturn v1.s == v2.s\n}","a26ff4e2909ed2e5edc90ee00447e0ab":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"raw string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"raw string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"12345\",\n\t\t\t},\n\t\t\twant: []byte(\"12345\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"string\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"12345\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"[\\\"string\\\",12345]\"),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"string\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"string\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"number\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"12345\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"{\\\"string\\\":\\\"string\\\",\\\"number\\\":12345}\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif string(got) != string(tt.want) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %v, want %v\", string(got), string(tt.want))\n\t\t\t}\n\t\t})\n\t}\n}","a2c3d304cfd86c61fd58859dae8a49a4":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic strings\n\t\t{\"hello\", \"hello\"},\n\t\t{\"world\", \"world\"},\n\n\t\t// Escaped characters\n\t\t{`\"hello\\\"world\"`, `\"hello\"world\"`},\n\t\t{`\\b\\f\\n\\r\\t`, \"\\b\\f\\n\\r\\t\"},\n\t\t{`\\\\\\/`, `\\/`},\n\n\t\t// Unicode escape sequences\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A9`, \"¬©\"},\n\t\t{`\\u20AC`, \"‚Ç¨\"},\n\n\t\t// Invalid escape sequences\n\t\t{`\\u`, `\\u`},\n\t\t{`\\u002`, `\\u002`},\n\t\t{`\\uxyz`, `\\uxyz`},\n\n\t\t// Surrogate pairs\n\t\t{`\\uD83D\\uDE02`, \"üòÇ\"},\n\n\t\t// Mixed strings\n\t\t{`hello\\t\"world\"`, \"hello\\t\\\"world\\\"\"},\n\t\t{`\\u00A92023`, \"¬©2023\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}","a2f4f8f4570d0c7dbc3af7e259d2ec73":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic strings without escape sequences.\n\t\t{\"hello\", \"hello\"},\n\t\t{\"world\", \"world\"},\n\n\t\t// Simple escape sequences.\n\t\t{`\\\"hello\\\"`, `\"hello\"`},\n\t\t{`\\\\world\\\\`, `\\world\\`},\n\t\t{`\\bfoo\\tbar\\n`, \"\\bfoo\\tbar\\n\"},\n\n\t\t// Unicode escape sequences.\n\t\t{`\\u0041`, \"A\"},\n\t\t{`\\u00e9`, \"√©\"},\n\t\t{`\\u20ac`, \"‚Ç¨\"},\n\n\t\t// Handling of invalid escape sequences.\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\u12345`, `\\u12345`},\n\n\t\t// Surrogate pairs.\n\t\t{`\\uD83D\\uDE02`, \"üòÇ\"},\n\n\t\t// Handling of incomplete surrogate pairs.\n\t\t{`\\uD83D`, `\\uD83D`},\n\t\t{`\\uD83D\\u`, `\\uD83D\\u`},\n\t\t{`\\uD83D\\uD`, `\\uD83D\\uD`},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Input: %q, Expected: %q, Got: %q\", test.input, test.expected, actual)\n\t\t}\n\t}\n}\n","a31ab6e2a85edb4433203a49ee3c665e":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic cases\n\t\t{\"\", \"\"},\n\t\t{\"hello\", \"hello\"},\n\t\t{\"hello\\\\world\", \"hello\\\\world\"},\n\t\t{\"hello\\\\\\\"world\", \"hello\\\"world\"},\n\t\t{\"hello\\\\\\\\world\", \"hello\\\\world\"},\n\n\t\t// Escape sequences\n\t\t{\"\\\\\\\"\", \"\\\"\"},\n\t\t{\"\\\\\\\\\", \"\\\\\"},\n\t\t{\"\\\\/\", \"/\"},\n\t\t{\"\\\\b\", \"\\b\"},\n\t\t{\"\\\\f\", \"\\f\"},\n\t\t{\"\\\\n\", \"\\n\"},\n\t\t{\"\\\\r\", \"\\r\"},\n\t\t{\"\\\\t\", \"\\t\"},\n\n\t\t// Unicode escape sequences\n\t\t{\"\\\\u0020\", \" \"},\n\t\t{\"\\\\u00A9\", \"¬©\"},\n\t\t{\"\\\\u20AC\", \"‚Ç¨\"},\n\t\t{\"\\\\uD83D\\\\uDE02\", \"üòÇ\"}, // Surrogate pair\n\n\t\t// Invalid escape sequences\n\t\t{\"\\\\x\", \"\\\\x\"},\n\t\t{\"\\\\u123\", \"\\\\u123\"},\n\t\t{\"\\\\uD800\", \"\\\\uD800\"}, // Unpaired surrogate\n\n\t\t// Mixed cases\n\t\t{\"hello\\\\\\\"world\\\\n\", \"hello\\\"world\\n\"},\n\t\t{\"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\\\\\\", \"\\\"hello\\\" \\\\world\\\\\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}","a33528d332979ee2e87754f0c86d20ab":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twant     *Value\n\t\twantRest string\n\t\twantErr  error\n\t}{\n\t\t{\n\t\t\tname:     \"empty array\",\n\t\t\tinput:    \"[]\",\n\t\t\twant:     \u0026Value{t: TypeArray},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"single element array\",\n\t\t\tinput:    \"[1]\",\n\t\t\twant:     \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple element array\",\n\t\t\tinput:    \"[1,2,3]\",\n\t\t\twant:     \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with whitespace\",\n\t\t\tinput:    \" [ 1 , 2 , 3 ] \",\n\t\t\twant:     \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}},\n\t\t\twantRest: \" \",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"nested array\",\n\t\t\tinput:    \"[[1,2],[3,4]]\",\n\t\t\twant: \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}}},\n\t\t\t\t{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"3\"}, {t: TypeNumber, s: \"4\"}}},\n\t\t\t}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing closing bracket\",\n\t\t\tinput:    \"[1,2\",\n\t\t\twant:     nil,\n\t\t\twantRest: \"\",\n\t\t\twantErr:  fmt.Errorf(\"unexpected end of array\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"missing comma\",\n\t\t\tinput:    \"[1 2]\",\n\t\t\twant:     nil,\n\t\t\twantRest: \"\",\n\t\t\twantErr:  fmt.Errorf(\"missing ',' after array value\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid value\",\n\t\t\tinput:    \"[1,invalid,3]\",\n\t\t\twant:     nil,\n\t\t\twantRest: \"\",\n\t\t\twantErr:  fmt.Errorf(\"cannot parse array value: invalid number\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, rest, err := parseArray(tt.input, c, 0)\n\n\t\t\tif (err != nil \u0026\u0026 tt.wantErr == nil) || (err == nil \u0026\u0026 tt.wantErr != nil) || (err != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 err.Error() != tt.wantErr.Error()) {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif rest != tt.wantRest {\n\t\t\t\tt.Errorf(\"parseArray() rest = %v, wantRest %v\", rest, tt.wantRest)\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.t == TypeArray {\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\treturn v1.s == v2.s\n}","a3df68aeb767bb59890390b17452dac4":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ts     string\n\t\terr   error\n\t}{\n\t\t// Empty object\n\t\t{\n\t\t\tinput: \"{}\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Simple object\n\t\t{\n\t\t\tinput: `{\"key1\": \"value1\", \"key2\": 123}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Nested object\n\t\t{\n\t\t\tinput: `{\"key1\": {\"key2\": \"value2\"}, \"key3\": true}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{k: \"key3\", v: \u0026Value{t: TypeTrue}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Missing closing brace\n\t\t{\n\t\t\tinput: `{\"key1\": \"value1\"`,\n\t\t\twant:  nil,\n\t\t\ts:     `{\"key1\": \"value1\"`,\n\t\t\terr:   fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t\t// Invalid key\n\t\t{\n\t\t\tinput: `{key1: \"value1\"}`,\n\t\t\twant:  nil,\n\t\t\ts:     `key1: \"value1\"}`,\n\t\t\terr:   fmt.Errorf(`cannot find opening '\"\" for object key`),\n\t\t},\n\t\t// Missing colon\n\t\t{\n\t\t\tinput: `{\"key1\" \"value1\"}`,\n\t\t\twant:  nil,\n\t\t\ts:     `\"value1\"}`,\n\t\t\terr:   fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t\t// Missing comma\n\t\t{\n\t\t\tinput: `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twant:  nil,\n\t\t\ts:     `\"key2\": \"value2\"}`,\n\t\t\terr:   fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\t}\n\n\tfor i, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseObject(test.input, c, 0)\n\n\t\t\tif test.err != nil {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"Expected error, got nil\")\n\t\t\t\t} else if err.Error() != test.err.Error() {\n\t\t\t\t\tt.Errorf(\"Expected error %q, got %q\", test.err, err)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif s != test.s {\n\t\t\t\tt.Errorf(\"Expected remaining string %q, got %q\", test.s, s)\n\t\t\t}\n\n\t\t\tif !equalValues(got, test.want) {\n\t\t\t\tt.Errorf(\"Test %d failed: input %q, got %v, want %v\", i, test.input, got, test.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeObject:\n\t\tif v1.o.Len() != v2.o.Len() {\n\t\t\treturn false\n\t\t}\n\t\tfor i := 0; i \u003c v1.o.Len(); i++ {\n\t\t\tkv1 := v1.o.kvs[i]\n\t\t\tkv2 := v2.o.kvs[i]\n\t\t\tif kv1.k != kv2.k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(kv1.v, kv2.v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := 0; i \u003c len(v1.a); i++ {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeTrue, TypeFalse, TypeNull:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n","a3e48b7e8794256346743472b05097d3":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic strings without escape sequences.\n\t\t{\"hello\", \"hello\"},\n\t\t{\"world\", \"world\"},\n\n\t\t// Strings with escape sequences.\n\t\t{`\\\"hello\\\"`, `\"hello\"`},\n\t\t{`\\\\hello\\\\`, `\\hello\\`},\n\t\t{`\\/hello\\/`, `/hello/`},\n\t\t{`\\bhello\\b`, \"\\bhello\\b\"},\n\t\t{`\\fhello\\f`, \"\\fhello\\f\"},\n\t\t{`\\nhello\\n`, \"\\nhello\\n\"},\n\t\t{`\\rhello\\r`, \"\\rhello\\r\"},\n\t\t{`\\thello\\t`, \"\\thello\\t\"},\n\n\t\t// Unicode escape sequences.\n\t\t{`\\u0041`, \"A\"},\n\t\t{`\\u00A9`, \"¬©\"},\n\t\t{`\\u20AC`, \"‚Ç¨\"},\n\n\t\t// Invalid escape sequences.\n\t\t{`\\zhello\\z`, `\\zhello\\z`},\n\t\t{`\\xhello\\x`, `\\xhello\\x`},\n\n\t\t// Mixed valid and invalid escape sequences.\n\t\t{`hello\\nworld\\x`, \"hello\\nworld\\\\x\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}","a4fba82f647f277618decc132ad6bbbd":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc Test_unescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello world\",\n\t\t\t},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"simple escape\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello \\\\\\\"world\\\\\\\"\",\n\t\t\t},\n\t\t\twant: \"hello \\\"world\\\"\",\n\t\t},\n\t\t{\n\t\t\tname: \"unicode escape\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello \\\\u0020world\",\n\t\t\t},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid unicode escape\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello \\\\u002 world\",\n\t\t\t},\n\t\t\twant: \"hello \\\\u002 world\",\n\t\t},\n\t\t{\n\t\t\tname: \"surrogate pair\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello \\\\uD83D\\\\uDE02world\",\n\t\t\t},\n\t\t\twant: \"hello üòÇworld\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid surrogate pair\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello \\\\uD83D\\\\u0020world\",\n\t\t\t},\n\t\t\twant: \"hello \\\\uD83D world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escape at end\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello world\\\\\",\n\t\t\t},\n\t\t\twant: \"hello world\\\\\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","a5b8556bdc21d1ed32652816cb936193":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"raw string\",\n\t\t\t},\n\t\t\twant: []byte(\"raw string\"),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":\"value1\",\"key2\":123}`),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"value1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"123\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`[\"value1\",123]`),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"value1\",\n\t\t\t},\n\t\t\twant: []byte(`\"value1\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant: []byte(\"123\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif string(got) != string(tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", string(got), string(tt.want))\n\t\t\t}\n\t\t})\n\t}\n}","a5e01f7b9aa5ec2f7147d5827f47b853":"package fastjson\n\nimport \"testing\"\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tinput Type\n\t\twant  string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\tfor i, tt := range tests {\n\t\tif got := tt.input.String(); got != tt.want {\n\t\t\tt.Errorf(\"test[%d]: String() = %q, want %q\", i, got, tt.want)\n\t\t}\n\t}\n}","a5e6d71fa8c194773dae5aec918f7650":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ts     string\n\t\terr   error\n\t}{\n\t\t// Empty object\n\t\t{\"{}\", \u0026Value{t: TypeObject, o: Object{}}, \"\", nil},\n\t\t// Single key-value pair\n\t\t{`{\"key\": \"value\"}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{t: TypeString, s: \"value\"}}}}}}, \"\", nil},\n\t\t// Multiple key-value pairs\n\t\t{`{\"key1\": \"value1\", \"key2\": 123, \"key3\": true}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}}, {k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}}, {k: \"key3\", v: \u0026Value{t: TypeTrue}}}}}}, \"\", nil},\n\t\t// Nested objects\n\t\t{`{\"outer\": {\"inner\": \"value\"}}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"outer\", v: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"inner\", v: \u0026Value{t: TypeString, s: \"value\"}}}}}}}}}}}, \"\", nil},\n\t\t// With whitespace\n\t\t{\"{ \\\"key\\\" : \\\"value\\\" }\", \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{t: TypeString, s: \"value\"}}}}}}, \"\", nil},\n\t\t// Invalid JSON\n\t\t{\"{key: value}\", nil, \"\", fmt.Errorf(`cannot find opening '\"\" for object key`)},\n\t\t// Missing closing brace\n\t\t{`{\"key\": \"value\"`, nil, \"\", fmt.Errorf(\"missing '}'\")},\n\t\t// Missing comma\n\t\t{`{\"key1\": \"value1\" \"key2\": \"value2\"}`, nil, \"\", fmt.Errorf(\"missing ',' after object value\")},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseObject(tt.input, c, 0)\n\n\t\t\tif (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) {\n\t\t\t\tt.Errorf(\"Expected error %v, got %v\", tt.err, err)\n\t\t\t}\n\n\t\t\tif err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error() {\n\t\t\t\tt.Errorf(\"Expected error message '%s', got '%s'\", tt.err.Error(), err.Error())\n\t\t\t}\n\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"Expected value %+v, got %+v\", tt.want, got)\n\t\t\t}\n\n\t\t\tif s != tt.s {\n\t\t\t\tt.Errorf(\"Expected remaining string '%s', got '%s'\", tt.s, s)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeTrue, TypeFalse, TypeNull:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}","a68b8acf83004d4b6f250b3f0d6d4899":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twant     *Value\n\t\twantRest string\n\t\twantErr  error\n\t}{\n\t\t{\n\t\t\tname:     \"empty object\",\n\t\t\tinput:    \"{}\",\n\t\t\twant:     \u0026Value{t: TypeObject, o: Object{}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"single key-value\",\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\twant:     \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{t: TypeString, s: \"value\"}}}}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple key-values\",\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 123, \"key3\": true}`,\n\t\t\twant: \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t{k: \"key3\", v: \u0026Value{t: TypeTrue}},\n\t\t\t}}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"nested object\",\n\t\t\tinput:    `{\"key1\": {\"key2\": \"value2\"}}`,\n\t\t\twant: \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}}}}}},\n\t\t\t}}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing closing brace\",\n\t\t\tinput:    `{\"key\": \"value\"`,\n\t\t\twant:     nil,\n\t\t\twantRest: \"\",\n\t\t\twantErr:  fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"missing opening quote for key\",\n\t\t\tinput:    \"{key: \\\"value\\\"}\",\n\t\t\twant:     nil,\n\t\t\twantRest: \"\",\n\t\t\twantErr:  fmt.Errorf(`cannot find opening '\"\" for object key`),\n\t\t},\n\t\t{\n\t\t\tname:     \"missing colon after key\",\n\t\t\tinput:    `{\"key\" \"value\"}`,\n\t\t\twant:     nil,\n\t\t\twantRest: \"\",\n\t\t\twantErr:  fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"missing comma between key-values\",\n\t\t\tinput:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twant:     nil,\n\t\t\twantRest: \"\",\n\t\t\twantErr:  fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, gotRest, gotErr := parseObject(tt.input, c, 0)\n\n\t\t\tif gotErr != nil \u0026\u0026 tt.wantErr == nil {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", gotErr, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif gotErr == nil \u0026\u0026 tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", gotErr, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", gotErr, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif gotRest != tt.wantRest {\n\t\t\t\tt.Errorf(\"parseObject() gotRest = %v, want %v\", gotRest, tt.wantRest)\n\t\t\t}\n\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn equalObjects(\u0026v1.o, \u0026v2.o)\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeTrue:\n\t\treturn true\n\tcase TypeFalse:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc equalObjects(o1, o2 *Object) bool {\n\tif o1.Len() != o2.Len() {\n\t\treturn false\n\t}\n\tfor i := 0; i \u003c o1.Len(); i++ {\n\t\tkv1 := o1.kvs[i]\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !equalValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n","a70e42d00ffb9791be3db5ccdfec5efc":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"RawString\",\n\t\t\tv:    \u0026Value{t: typeRawString, s: \"rawString\"},\n\t\t\twant: []byte(\"\\\"rawString\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"Object\",\n\t\t\tv:    \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}}}}},\n\t\t\twant: []byte(\"{\\\"key1\\\":\\\"value1\\\"}\"),\n\t\t},\n\t\t{\n\t\t\tname: \"Array\",\n\t\t\tv: \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeString, s: \"value1\"},\n\t\t\t\t{t: TypeNumber, s: \"123\"},\n\t\t\t}},\n\t\t\twant: []byte(\"[\\\"value1\\\",123]\"),\n\t\t},\n\t\t{\n\t\t\tname: \"String\",\n\t\t\tv:    \u0026Value{t: TypeString, s: \"string\"},\n\t\t\twant: []byte(\"\\\"string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"Number\",\n\t\t\tv:    \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\twant: []byte(\"123\"),\n\t\t},\n\t\t{\n\t\t\tname: \"True\",\n\t\t\tv:    \u0026Value{t: TypeTrue},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"False\",\n\t\t\tv:    \u0026Value{t: TypeFalse},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"Null\",\n\t\t\tv:    \u0026Value{t: TypeNull},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif string(got) != string(tt.want) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %s, want %s\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","a811fb62916e790dd566077bd6a35109":"package fastjson\n\nimport \"testing\"\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tt    Type\n\t\twant string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"\"},\n\t}\n\tfor i, tt := range tests {\n\t\tgot := tt.t.String()\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"test[%d]: String() = %q, want %q\", i, got, tt.want)\n\t\t}\n\t}\n}","a9e232b93b484e6e3469207334efc237":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCache_getValue(t *testing.T) {\n\tt.Run(\"grow\", func(t *testing.T) {\n\t\tc := \u0026cache{}\n\t\tif got := c.getValue(); got == nil {\n\t\t\tt.Errorf(\"getValue() = nil, want non-nil\")\n\t\t}\n\t\tif got := c.getValue(); got == nil {\n\t\t\tt.Errorf(\"getValue() = nil, want non-nil\")\n\t\t}\n\t})\n\tt.Run(\"reuse\", func(t *testing.T) {\n\t\tc := \u0026cache{\n\t\t\tvs: make([]Value, 10),\n\t\t}\n\t\tv1 := c.getValue()\n\t\tv2 := c.getValue()\n\t\tif v1 != v2 {\n\t\t\tt.Errorf(\"getValue() returned different pointers after reuse\")\n\t\t}\n\t})\n}","aa6b9126a55855fa7d61ff927be5d07b":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_unescapeKeys(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tkvs  []kv\n\t\twant []kv\n\t}{\n\t\t{\n\t\t\tname: \"basic\",\n\t\t\tkvs: []kv{\n\t\t\t\t{k: \"key\\\\u0031\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}},\n\t\t\t},\n\t\t\twant: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"no escape\",\n\t\t\tkvs: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}},\n\t\t\t},\n\t\t\twant: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"empty\",\n\t\t\tkvs:  []kv{},\n\t\t\twant: []kv{},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\to := \u0026Object{\n\t\t\t\tkvs:           tt.kvs,\n\t\t\t\tkeysUnescaped: false,\n\t\t\t}\n\t\t\to.unescapeKeys()\n\t\t\tfor i := range o.kvs {\n\t\t\t\tif o.kvs[i].k != tt.want[i].k {\n\t\t\t\t\tt.Errorf(\"unescapeKeys() = %v, want %v\", o.kvs[i].k, tt.want[i].k)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","aadbb8a32afe4362ea210a5afd1631b3":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Get(t *testing.T) {\n\t// Test cases for Get function\n\ttests := []struct {\n\t\tname   string\n\t\tjson   string\n\t\tkeys   []string\n\t\texpect *Value\n\t}{\n\t\t{\n\t\t\t\"simple object\",\n\t\t\t`{\"a\": 123, \"b\": \"hello\"}`,\n\t\t\t[]string{\"a\"},\n\t\t\t\u0026Value{t: TypeNumber, s: \"123\"},\n\t\t},\n\t\t{\n\t\t\t\"nested object\",\n\t\t\t`{\"a\": {\"b\": {\"c\": 123}}}`,\n\t\t\t[]string{\"a\", \"b\", \"c\"},\n\t\t\t\u0026Value{t: TypeNumber, s: \"123\"},\n\t\t},\n\t\t{\n\t\t\t\"array index\",\n\t\t\t`{\"a\": [1, 2, 3]}`,\n\t\t\t[]string{\"a\", \"1\"},\n\t\t\t\u0026Value{t: TypeNumber, s: \"2\"},\n\t\t},\n\t\t{\n\t\t\t\"non-existing key\",\n\t\t\t`{\"a\": 123}`,\n\t\t\t[]string{\"b\"},\n\t\t\tnil,\n\t\t},\n\t\t{\n\t\t\t\"invalid array index\",\n\t\t\t`{\"a\": [1, 2, 3]}`,\n\t\t\t[]string{\"a\", \"abc\"},\n\t\t\tnil,\n\t\t},\n\t\t{\n\t\t\t\"out of range array index\",\n\t\t\t`{\"a\": [1, 2, 3]}`,\n\t\t\t[]string{\"a\", \"3\"},\n\t\t\tnil,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv, _ := Parse(tt.json)\n\t\t\tresult := v.Get(tt.keys...)\n\t\t\tif result == nil \u0026\u0026 tt.expect == nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif result.Type() != tt.expect.Type() || result.String() != tt.expect.String() {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", tt.expect, result)\n\t\t\t}\n\t\t})\n\t}\n}\n","ab7254c63d697a2098f1843de7716d02":"package fastjson\n\nimport \"testing\"\n\nfunc TestValue_GetFloat64(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tjson  string\n\t\tkeys  []string\n\t\twant  float64\n\t\twant1 bool\n\t}{\n\t\t// Test cases for existing keys and valid float64 values.\n\t\t{\n\t\t\tname:  \"simple_key\",\n\t\t\tjson:  `{\"a\": 1.23}`,\n\t\t\tkeys:  []string{\"a\"},\n\t\t\twant:  1.23,\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"nested_key\",\n\t\t\tjson:  `{\"a\": {\"b\": {\"c\": 4.56}}}`,\n\t\t\tkeys:  []string{\"a\", \"b\", \"c\"},\n\t\t\twant:  4.56,\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array_index\",\n\t\t\tjson:  `{\"a\": [1, 2, 3.14]}`,\n\t\t\tkeys:  []string{\"a\", \"2\"},\n\t\t\twant:  3.14,\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"decimal_array_index\",\n\t\t\tjson:  `{\"a\": [1, 2, 3.14]}`,\n\t\t\tkeys:  []string{\"a\", \"2.0\"},\n\t\t\twant:  3.14,\n\t\t\twant1: true,\n\t\t},\n\n\t\t// Test cases for non-existing keys.\n\t\t{\n\t\t\tname:  \"non_existing_key\",\n\t\t\tjson:  `{\"a\": 1}`,\n\t\t\tkeys:  []string{\"b\"},\n\t\t\twant:  0,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"non_existing_nested_key\",\n\t\t\tjson:  `{\"a\": {\"b\": 1}}`,\n\t\t\tkeys:  []string{\"a\", \"c\"},\n\t\t\twant:  0,\n\t\t\twant1: false,\n\t\t},\n\n\t\t// Test cases for invalid value types.\n\t\t{\n\t\t\tname:  \"invalid_value_type_string\",\n\t\t\tjson:  `{\"a\": \"hello\"}`,\n\t\t\tkeys:  []string{\"a\"},\n\t\t\twant:  0,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"invalid_value_type_bool\",\n\t\t\tjson:  `{\"a\": true}`,\n\t\t\tkeys:  []string{\"a\"},\n\t\t\twant:  0,\n\t\t\twant1: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tvar v Value\n\t\t\tif err := v.Unmarshal([]byte(tt.json)); err != nil {\n\t\t\t\tt.Errorf(\"Unmarshal() error = %v, wantErr %v\", err, false)\n\t\t\t}\n\n\t\t\tgot := v.GetFloat64(tt.keys...)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"GetFloat64() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","abaa0a9b4a1101f0ffe6fbdd0d47f13e":"package fastjson\n\nimport \"testing\"\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    string\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty\",\n\t\t\ts:    \"\",\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"space\",\n\t\t\ts:    \" \",\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"spaces\",\n\t\t\ts:    \"  \",\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"tab\",\n\t\t\ts:    \"\\t\",\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"tabs\",\n\t\t\ts:    \"\\t\\t\",\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"newline\",\n\t\t\ts:    \"\\n\",\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"newlines\",\n\t\t\ts:    \"\\n\\n\",\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"carriage return\",\n\t\t\ts:    \"\\r\",\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"carriage returns\",\n\t\t\ts:    \"\\r\\r\",\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"mixed whitespace\",\n\t\t\ts:    \" \\t\\n\\r\",\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace\",\n\t\t\ts:    \"  foo\",\n\t\t\twant: \"foo\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailing whitespace\",\n\t\t\ts:    \"foo  \",\n\t\t\twant: \"foo  \",\n\t\t},\n\t\t{\n\t\t\tname: \"whitespace in the middle\",\n\t\t\ts:    \"foo  bar\",\n\t\t\twant: \"foo  bar\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %q, want %q\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","abc7cd4d914a92eeb50b3ac0d0168973":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\tns       string\n\t\ttail     string\n\t\thasError bool\n\t}{\n\t\t{\"123\", \"123\", \"\", false},\n\t\t{\"123.456\", \"123.456\", \"\", false},\n\t\t{\"-123\", \"-123\", \"\", false},\n\t\t{\"+123\", \"+123\", \"\", false},\n\t\t{\"1.23e+4\", \"1.23e+4\", \"\", false},\n\t\t{\"1.23e-4\", \"1.23e-4\", \"\", false},\n\t\t{\"inf\", \"inf\", \"\", false},\n\t\t{\"+inf\", \"+inf\", \"\", false},\n\t\t{\"-inf\", \"-inf\", \"\", false},\n\t\t{\"nan\", \"nan\", \"\", false},\n\t\t{\"+nan\", \"+nan\", \"\", false},\n\t\t{\"-nan\", \"-nan\", \"\", false},\n\t\t{\"123abc\", \"123\", \"abc\", false},\n\t\t{\"123.456abc\", \"123.456\", \"abc\", false},\n\t\t{\"-123abc\", \"-123\", \"abc\", false},\n\t\t{\"+123abc\", \"+123\", \"abc\", false},\n\t\t{\"1.23e+4abc\", \"1.23e+4\", \"abc\", false},\n\t\t{\"1.23e-4abc\", \"1.23e-4\", \"abc\", false},\n\t\t{\"infabc\", \"inf\", \"abc\", false},\n\t\t{\"+infabc\", \"+inf\", \"abc\", false},\n\t\t{\"-infabc\", \"-inf\", \"abc\", false},\n\t\t{\"nanabc\", \"nan\", \"abc\", false},\n\t\t{\"+nanabc\", \"+nan\", \"abc\", false},\n\t\t{\"-nanabc\", \"-nan\", \"abc\", false},\n\t\t{\"\", \"\", \"\", true},\n\t\t{\"a\", \"\", \"a\", true},\n\t\t{\"+a\", \"\", \"+a\", true},\n\t\t{\"-a\", \"\", \"-a\", true},\n\t\t{\"+in\", \"\", \"+in\", true},\n\t\t{\"-na\", \"\", \"-na\", true},\n\t}\n\n\tfor i, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i+1), func(t *testing.T) {\n\t\t\tns, tail, err := parseRawNumber(test.input)\n\t\t\tif test.hasError {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"Expected error, got nil\")\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t\t\t}\n\t\t\t\tif ns != test.ns {\n\t\t\t\t\tt.Errorf(\"Expected ns %q, got %q\", test.ns, ns)\n\t\t\t\t}\n\t\t\t\tif tail != test.tail {\n\t\t\t\t\tt.Errorf(\"Expected tail %q, got %q\", test.tail, tail)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","abf55f53ceb89bc55eca47b43f24c5c4":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tinput   string\n\t\twant    *Value\n\t\twantErr error\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: \"{}\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"simple object\",\n\t\t\tinput: `{\"key\": \"value\"}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"missing closing brace\",\n\t\t\tinput: `{\"key\": \"value\"`,\n\t\t\twant:    nil,\n\t\t\twantErr: fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t\t{\n\t\t\tname:  \"missing opening quote for key\",\n\t\t\tinput: `{key: \"value\"}`,\n\t\t\twant:    nil,\n\t\t\twantErr: fmt.Errorf(`cannot find opening '\"\" for object key`),\n\t\t},\n\t\t{\n\t\t\tname:  \"missing colon after key\",\n\t\t\tinput: `{\"key\" \"value\"}`,\n\t\t\twant:    nil,\n\t\t\twantErr: fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t\t{\n\t\t\tname:  \"missing comma between key-value pairs\",\n\t\t\tinput: `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twant:    nil,\n\t\t\twantErr: fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, _, err := parseObject(tt.input, c, 0)\n\t\t\tif tt.wantErr != nil {\n\t\t\t\tif err == nil || err.Error() != tt.wantErr.Error() {\n\t\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}","ac3e7c0295a352264e9924a302df5bfd":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey   string\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t{`\"key\":1`, \"key\", `:1`, nil},\n\t\t{`\"key\":`, \"key\", `:`, nil},\n\t\t{`\"key\"`, \"key\", \"\", nil},\n\t\t{`\"k\\\"ey\":1`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"key\\n\":1`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"key\\\\\":1`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`key\":1`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"key`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"\"`, \"\", \"\", nil},\n\t\t{``, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tkey, tail, err := parseRawKey(tt.input)\n\t\t\tif key != tt.key || tail != tt.tail || !equalError(err, tt.err) {\n\t\t\t\tt.Errorf(\"input: %q, expect(%q, %q, %v), got(%q, %q, %v)\", tt.input, tt.key, tt.tail, tt.err, key, tail, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalError(a, b error) bool {\n\tif a == nil {\n\t\treturn b == nil\n\t}\n\tif b == nil {\n\t\treturn false\n\t}\n\treturn a.Error() == b.Error()\n}\n","ac7b78a14ebcaa3e2da32258ce951a82":"package fastjson\n\nimport \"testing\"\n\nfunc Test_parseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"basic positive integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"12345\",\n\t\t\t},\n\t\t\twantNs:  \"12345\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"-12345\",\n\t\t\t},\n\t\t\twantNs:  \"-12345\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"positive float with dot\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.45\",\n\t\t\t},\n\t\t\twantNs:  \"123.45\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative float with dot\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123.45\",\n\t\t\t},\n\t\t\twantNs:  \"-123.45\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"scientific notation\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.2345e+10\",\n\t\t\t},\n\t\t\twantNs:  \"1.2345e+10\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with trailing space\",\n\t\t\targs: args{\n\t\t\t\ts: \"123 \",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \" \",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with trailing comma\",\n\t\t\targs: args{\n\t\t\t\ts: \"123,\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \",\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with trailing bracket\",\n\t\t\targs: args{\n\t\t\t\ts: \"123]\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"]\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number\",\n\t\t\targs: args{\n\t\t\t\ts: \"abc\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"abc\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}","adf277bf36616eaa81aa73858644bb63":"package fastjson\n\nimport \"testing\"\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tt    Type\n\t\twant string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\tfor i, tt := range tests {\n\t\tgot := tt.t.String()\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"test[%d]: String() = %q, want %q\", i, got, tt.want)\n\t\t}\n\t}\n}","ae0b572cc88c22817952f3cafbbcef57":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\t// Test cases for various JSON values\n\ttestCases := []struct {\n\t\tinput       string\n\t\texpectedVal *Value\n\t\texpectedTail string\n\t\texpectedErr error\n\t}{\n\t\t// Empty string\n\t\t{\"\", nil, \"\", fmt.Errorf(\"cannot parse empty string\")},\n\n\t\t// Null value\n\t\t{\"null\", valueNull, \"\", nil},\n\t\t{\"null   \", valueNull, \"   \", nil},\n\n\t\t// True value\n\t\t{\"true\", valueTrue, \"\", nil},\n\t\t{\"true  \", valueTrue, \"  \", nil},\n\n\t\t// False value\n\t\t{\"false\", valueFalse, \"\", nil},\n\t\t{\"false \", valueFalse, \" \", nil},\n\n\t\t// String value\n\t\t{`\"hello\"`, \u0026Value{t: typeRawString, s: \"hello\"}, \"\", nil},\n\t\t{`\"hello world\"  `, \u0026Value{t: typeRawString, s: \"hello world\"}, \"  \", nil},\n\n\t\t// Number value\n\t\t{\"123\", \u0026Value{t: TypeNumber, s: \"123\"}, \"\", nil},\n\t\t{\"123.456\", \u0026Value{t: TypeNumber, s: \"123.456\"}, \"\", nil},\n\t\t{\"-123\", \u0026Value{t: TypeNumber, s: \"-123\"}, \"\", nil},\n\t\t{\"123  \", \u0026Value{t: TypeNumber, s: \"123\"}, \"  \", nil},\n\n\t\t// NaN value\n\t\t{\"NaN\", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"\", nil},\n\t\t{\"nan\", \u0026Value{t: TypeNumber, s: \"nan\"}, \"\", nil},\n\n\t\t// Object value\n\t\t{`{}`, \u0026Value{t: TypeObject, o: Object{}}, \"\", nil},\n\n\t\t// Array value\n\t\t{`[]`, \u0026Value{t: TypeArray, a: []*Value{}}, \"\", nil},\n\n\t\t// Invalid value\n\t\t{\"invalid\", nil, \"invalid\", fmt.Errorf(\"unexpected value found: %q\", \"invalid\")},\n\t}\n\n\t// Iterate over test cases\n\tfor i, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"TestCase_%d\", i+1), func(t *testing.T) {\n\t\t\t// Call parseValue function\n\t\t\tactualVal, actualTail, actualErr := parseValue(tc.input, c, 0)\n\n\t\t\t// Check for errors\n\t\t\tif tc.expectedErr != nil {\n\t\t\t\tif actualErr == nil {\n\t\t\t\t\tt.Errorf(\"Expected error: %v, but got nil\", tc.expectedErr)\n\t\t\t\t} else if actualErr.Error() != tc.expectedErr.Error() {\n\t\t\t\t\tt.Errorf(\"Expected error: %v, but got: %v\", tc.expectedErr, actualErr)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t} else if actualErr != nil {\n\t\t\t\tt.Errorf(\"Unexpected error: %v\", actualErr)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Check for value type\n\t\t\tif actualVal.t != tc.expectedVal.t {\n\t\t\t\tt.Errorf(\"Expected value type: %v, but got: %v\", tc.expectedVal.t, actualVal.t)\n\t\t\t}\n\n\t\t\t// Check for value string\n\t\t\tif actualVal.s != tc.expectedVal.s {\n\t\t\t\tt.Errorf(\"Expected value string: %q, but got: %q\", tc.expectedVal.s, actualVal.s)\n\t\t\t}\n\n\t\t\t// Check for tail\n\t\t\tif actualTail != tc.expectedTail {\n\t\t\t\tt.Errorf(\"Expected tail: %q, but got: %q\", tc.expectedTail, actualTail)\n\t\t\t}\n\t\t})\n\t}\n}","ae4d8039b488babc11d0ff7d99cdce09":"package fastjson\n\nimport \"testing\"\n\nfunc TestObject_getKV(t *testing.T) {\n\to := Object{}\n\t// Test adding to empty o.kvs\n\tkv1 := o.getKV()\n\tif kv1 == nil {\n\t\tt.Errorf(\"Expected non-nil kv, got nil\")\n\t}\n\tif len(o.kvs) != 1 {\n\t\tt.Errorf(\"Expected o.kvs length 1, got %d\", len(o.kvs))\n\t}\n\n\t// Test adding to non-empty o.kvs\n\tkv2 := o.getKV()\n\tif kv2 == nil {\n\t\tt.Errorf(\"Expected non-nil kv, got nil\")\n\t}\n\tif len(o.kvs) != 2 {\n\t\tt.Errorf(\"Expected o.kvs length 2, got %d\", len(o.kvs))\n\t}\n\n\t// Test that different calls return different addresses\n\tif kv1 == kv2 {\n\t\tt.Errorf(\"Expected different kv addresses, got the same\")\n\t}\n}","ae9123f503428ba5692e3ea27ac17461":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey   string\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Basic cases\n\t\t{`\"foo\"bar`, \"foo\", \"bar\", nil},\n\t\t{`\"fo\\\"o\"bar`, `fo\"o`, \"bar\", nil},\n\t\t{`\"foo\"`, \"foo\", \"\", nil},\n\t\t{`\"\"bar`, \"\", \"bar\", nil},\n\n\t\t// Escaped quotes\n\t\t{`\"fo\\\\o\"bar`, `fo\\o`, \"bar\", nil},\n\t\t{`\"fo\\\\\\\\o\"bar`, `fo\\\\o`, \"bar\", nil},\n\t\t{`\"fo\\\"o\"bar`, `fo\"o`, \"bar\", nil},\n\t\t{`\"fo\\\\\\\"o\"bar`, `fo\\\"o`, \"bar\", nil},\n\t\t{`\"fo\\\\\\\\\\\"o\"bar`, `fo\\\\\"o`, \"bar\", nil},\n\n\t\t// Missing closing quote\n\t\t{`\"foobar`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo\\\"bar`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo\\\\\"bar`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\n\t\t// Empty string\n\t\t{`\"\"`, \"\", \"\", nil},\n\n\t\t// Unescaped backslashes\n\t\t{`\"foo\\bar\"baz`, `foo\\bar`, \"baz\", nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i+1), func(t *testing.T) {\n\t\t\tkey, tail, err := parseRawString(tt.input)\n\t\t\tif key != tt.key || tail != tt.tail || !errorEqual(err, tt.err) {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = (%q, %q, %v), want (%q, %q, %v)\", tt.input, key, tail, err, tt.key, tt.tail, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc errorEqual(e1, e2 error) bool {\n\tif e1 == nil \u0026\u0026 e2 == nil {\n\t\treturn true\n\t}\n\tif e1 == nil || e2 == nil {\n\t\treturn false\n\t}\n\treturn e1.Error() == e2.Error()\n}","ae9693e983789f3217631b97120308a1":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantN    string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Empty input.\n\t\t{\"\", \"\", \"\", nil},\n\n\t\t// Valid numbers.\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"123.456\", \"123.456\", \"\", nil},\n\t\t{\"-123.456\", \"-123.456\", \"\", nil},\n\t\t{\"1.2e3\", \"1.2e3\", \"\", nil},\n\t\t{\"1.2E3\", \"1.2E3\", \"\", nil},\n\t\t{\"-1.2e3\", \"-1.2e3\", \"\", nil},\n\t\t{\"-1.2E3\", \"-1.2E3\", \"\", nil},\n\n\t\t// Valid numbers with trailing characters.\n\t\t{\"123a\", \"123\", \"a\", nil},\n\t\t{\"-123a\", \"-123\", \"a\", nil},\n\t\t{\"123.456a\", \"123.456\", \"a\", nil},\n\t\t{\"-123.456a\", \"-123.456\", \"a\", nil},\n\t\t{\"1.2e3a\", \"1.2e3\", \"a\", nil},\n\t\t{\"1.2E3a\", \"1.2E3\", \"a\", nil},\n\t\t{\"-1.2e3a\", \"-1.2e3\", \"a\", nil},\n\t\t{\"-1.2E3a\", \"-1.2E3\", \"a\", nil},\n\n\t\t// Invalid numbers.\n\t\t{\"a\", \"\", \"a\", fmt.Errorf(`unexpected char: \"a\"`)},\n\t\t{\"+a\", \"\", \"+a\", fmt.Errorf(`unexpected char: \"+\"`)},\n\t\t{\"-a\", \"\", \"-a\", fmt.Errorf(`unexpected char: \"-\"`)},\n\t\t{\"1.2e\", \"\", \"1.2e\", fmt.Errorf(`unexpected char: \"1\"`)},\n\t\t{\"1.2E\", \"\", \"1.2E\", fmt.Errorf(`unexpected char: \"1\"`)},\n\t\t{\"-1.2e\", \"\", \"-1.2e\", fmt.Errorf(`unexpected char: \"-\"`)},\n\t\t{\"-1.2E\", \"\", \"-1.2E\", fmt.Errorf(`unexpected char: \"-\"`)},\n\n\t\t// Special cases: \"inf\" and \"nan\".\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"+inf\", \"+inf\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"in\", \"\", \"in\", fmt.Errorf(`unexpected char: \"i\"`)},\n\t\t{\"+in\", \"\", \"+in\", fmt.Errorf(`unexpected char: \"+\"`)},\n\t\t{\"-in\", \"\", \"-in\", fmt.Errorf(`unexpected char: \"-\"`)},\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"+nan\", \"+nan\", \"\", nil},\n\t\t{\"-nan\", \"-nan\", \"\", nil},\n\t\t{\"na\", \"\", \"na\", fmt.Errorf(`unexpected char: \"n\"`)},\n\t\t{\"+na\", \"\", \"+na\", fmt.Errorf(`unexpected char: \"+\"`)},\n\t\t{\"-na\", \"\", \"-na\", fmt.Errorf(`unexpected char: \"-\"`)},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tgotN, gotTail, gotErr := parseRawNumber(tt.input)\n\t\t\tif gotN != tt.wantN {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got number = %q, want %q\", tt.input, gotN, tt.wantN)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got tail = %q, want %q\", tt.input, gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif gotErr == nil \u0026\u0026 tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got no error, want %v\", tt.input, tt.wantErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr == nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got error = %v, want nil\", tt.input, gotErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got error = %v, want %v\", tt.input, gotErr, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","af10a7f04b7057fbe477a26022125bc6":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\ts   string\n\t\tkey string\n\t\ttail string\n\t\terr error\n\t}{\n\t\t{`\"foo\"bar`, `foo`, `bar`, nil},\n\t\t{`\"foo\" bar`, `foo`, ` bar`, nil},\n\t\t{`\"foo\"  bar`, `foo`, `  bar`, nil},\n\t\t{`\"foo\"bar `, `foo`, `bar `, nil},\n\t\t{`\"foo\"`, `foo`, ``, nil},\n\t\t{`\"\"`, ``, ``, nil},\n\n\t\t{`\"foo`, ``, ``, fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"fo\\o\"`, `fo\\o`, ``, nil},\n\t\t{`\"fo\\\\o\"`, `fo\\\\o`, ``, nil},\n\t\t{`\"fo\\\"o\"`, `fo\"o`, ``, nil},\n\t\t{`\"fo\\ro\"`, `fo\\ro`, ``, nil},\n\t\t{`\"fo\\to\"`, `fo\\to`, ``, nil},\n\t\t{`\"fo\\no\"`, `fo\\no`, ``, nil},\n\t\t{`\"fo\\fo\"`, `fo\\fo`, ``, nil},\n\t\t{`\"fo\\bo\"`, `fo\\bo`, ``, nil},\n\t\t{`\"fo\\\\\\\"o\"`, `fo\\\"o`, ``, nil},\n\t\t{`\"fo\\\\\"o\"`, `fo\\o`, ``, nil},\n\n\t\t{`\"foo\\\"\"bar`, `foo\"`, `bar`, nil},\n\t\t{`\"foo\\\\\\\"\"bar`, `foo\\\"`, `bar`, nil},\n\t\t{`\"foo\\\\\\\\\\\"\"bar`, `foo\\\\\"`, `bar`, nil},\n\t\t{`\"foo\\\\\\\\\\\\\\\"\"bar`, `foo\\\\\\`, `bar`, nil},\n\n\t\t{`\"\\\"\"bar`, `\"`, `bar`, nil},\n\t\t{`\"\\\\\"\"bar`, `\\\"`, `bar`, nil},\n\t\t{`\"\\\\\\\"\"bar`, `\\\\\"`, `bar`, nil},\n\t\t{`\"\\\\\\\\\"\"bar`, `\\\\\\`, `bar`, nil},\n\n\t\t{`\"a\\b\\f\\n\\r\\t\\v\\u1234\\U00010100\\\"\\\"\\\\\\a\\\\\"`,\n\t\t\t\"a\\b\\f\\n\\r\\t\\v\\u1234\\U00010100\\\"\\\"\\\\a\\\\\", \"\", nil},\n\t}\n\tfor i, tt := range tests {\n\t\tkey, tail, err := parseRawString(tt.s)\n\t\tif fmt.Sprintf(\"%v\", tt.err) != fmt.Sprintf(\"%v\", err) {\n\t\t\tt.Errorf(\"#%d: %v != %v\", i, tt.err, err)\n\t\t\tcontinue\n\t\t}\n\t\tif key != tt.key {\n\t\t\tt.Errorf(\"#%d: key mismatch: want %q, got %q\", i, tt.key, key)\n\t\t}\n\t\tif tail != tt.tail {\n\t\t\tt.Errorf(\"#%d: tail mismatch: want %q, got %q\", i, tt.tail, tail)\n\t\t}\n\t}\n}","afef6c05b46268a259be59a5a9fca661":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv:    \u0026Value{t: typeRawString, s: \"hello\"},\n\t\t\twant: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv:    \u0026Value{t: TypeString, s: \"hello\"},\n\t\t\twant: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv:    \u0026Value{t: TypeNumber, s: \"123.456\"},\n\t\t\twant: []byte(`123.456`),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv:    \u0026Value{t: TypeTrue},\n\t\t\twant: []byte(`true`),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv:    \u0026Value{t: TypeFalse},\n\t\t\twant: []byte(`false`),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv:    \u0026Value{t: TypeNull},\n\t\t\twant: []byte(`null`),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t{t: TypeString, s: \"hello\"},\n\t\t\t\t{t: TypeNull},\n\t\t\t}},\n\t\t\twant: []byte(`[1,\"hello\",null]`),\n\t\t},\n\t\t// Add more test cases for other types and nested objects/arrays\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif string(got) != string(tt.want) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","b04b74319d940f0635ec6c3ab0c4f8db":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\twantS string\n\t\terr   error\n\t}{\n\t\t// Empty array\n\t\t{\"[]\", \u0026Value{t: TypeArray, a: []*Value{}}, \"\", nil},\n\t\t// Simple array\n\t\t{\"[1,2,3]\", \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t}}, \"\", nil},\n\t\t// Array with whitespace\n\t\t{\" [ 1 , 2 , 3 ] \", \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t}}, \"\", nil},\n\t\t// Nested array\n\t\t{\"[[1,2],[3,4]]\", \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t}},\n\t\t\t{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t{t: TypeNumber, s: \"4\"},\n\t\t\t}},\n\t\t}}, \"\", nil},\n\t\t// Array with different value types\n\t\t{`[\"a\",1,true,null]`, \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t{t: TypeString, s: \"a\"},\n\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t{t: TypeTrue},\n\t\t\t{t: TypeNull},\n\t\t}}, \"\", nil},\n\t\t// Invalid array: missing closing bracket\n\t\t{\"[1,2,3\", nil, \"\", fmt.Errorf(\"unexpected end of array\")},\n\t\t// Invalid array: missing comma\n\t\t{\"[1 2 3]\", nil, \" 2 3]\", fmt.Errorf(\"missing ',' after array value\")},\n\t\t// Invalid array: trailing comma\n\t\t{\"[1,2,]\", nil, \"\", fmt.Errorf(\"cannot parse array value: unexpected end of JSON\")},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, gotS, err := parseArray(tt.input, c, 0)\n\n\t\t\tif tt.err != nil {\n\t\t\t\tif err == nil || err.Error() != tt.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr nil\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseArray() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(a, b *Value) bool {\n\tif a == nil \u0026\u0026 b == nil {\n\t\treturn true\n\t}\n\tif a == nil || b == nil {\n\t\treturn false\n\t}\n\tif a.t != b.t {\n\t\treturn false\n\t}\n\tswitch a.t {\n\tcase TypeArray:\n\t\tif len(a.a) != len(b.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range a.a {\n\t\t\tif !equalValues(a.a[i], b.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\tcase TypeObject:\n\t\t// Not testing object equality here\n\t\treturn false\n\tdefault:\n\t\treturn a.s == b.s\n\t}\n\treturn true\n}","b0b5fd686ad16fef8e8d59f74a9f67c4":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Get(t *testing.T) {\n\tt.Run(\"object\", func(t *testing.T) {\n\t\tv := MustParse(`{\"foo\": {\"bar\": \"baz\"}}`)\n\t\tassert(t, v.Get(\"foo\", \"bar\").String() == \"baz\")\n\t\tassert(t, v.Get(\"foo\", \"bar\", \"baz\") == nil)\n\t\tassert(t, v.Get(\"foo\", \"baz\") == nil)\n\t\tassert(t, v.Get(\"baz\") == nil)\n\t})\n\n\tt.Run(\"array\", func(t *testing.T) {\n\t\tv := MustParse(`{\"foo\": [1, 2, 3]}`)\n\t\tassert(t, v.Get(\"foo\", \"0\").Int() == 1)\n\t\tassert(t, v.Get(\"foo\", \"1\").Int() == 2)\n\t\tassert(t, v.Get(\"foo\", \"2\").Int() == 3)\n\t\tassert(t, v.Get(\"foo\", \"3\") == nil)\n\t\tassert(t, v.Get(\"foo\", \"-1\") == nil)\n\t\tassert(t, v.Get(\"foo\", \"abc\") == nil)\n\t})\n\n\tt.Run(\"mixed\", func(t *testing.T) {\n\t\tv := MustParse(`{\"foo\": [{\"bar\": 1}, {\"baz\": 2}]}`)\n\t\tassert(t, v.Get(\"foo\", \"0\", \"bar\").Int() == 1)\n\t\tassert(t, v.Get(\"foo\", \"1\", \"baz\").Int() == 2)\n\t\tassert(t, v.Get(\"foo\", \"0\", \"baz\") == nil)\n\t\tassert(t, v.Get(\"foo\", \"1\", \"bar\") == nil)\n\t})\n\n\tt.Run(\"non-existing\", func(t *testing.T) {\n\t\tv := MustParse(`{\"foo\": \"bar\"}`)\n\t\tassert(t, v.Get(\"baz\") == nil)\n\t\tassert(t, v.Get(\"foo\", \"baz\") == nil)\n\t})\n\n\tt.Run(\"nil\", func(t *testing.T) {\n\t\tvar v *Value\n\t\tassert(t, v.Get(\"foo\") == nil)\n\t})\n}\n\nfunc assert(tb testing.TB, condition bool, msg ...interface{}) {\n\tif !condition {\n\t\ttb.Helper()\n\t\ttb.Fatal(msg...)\n\t}\n}","b19489aa7c40cead98db30a214543112":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantNum  string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Basic cases\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"123.456\", \"123.456\", \"\", nil},\n\t\t{\"1.2e3\", \"1.2e3\", \"\", nil},\n\t\t{\"1.2E-3\", \"1.2E-3\", \"\", nil},\n\n\t\t// Trailing characters\n\t\t{\"123a\", \"123\", \"a\", nil},\n\t\t{\"123.456xyz\", \"123.456\", \"xyz\", nil},\n\n\t\t// Invalid numbers\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t\t{\"+\", \"\", \"+\", fmt.Errorf(\"unexpected char: %q\", \"+\")},\n\t\t(\"-\", \"\", \"-\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t\t(\"a123\", \"\", \"a123\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\n\t\t// Special cases: inf, nan\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"+inf\", \"+inf\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"123inf\", \"123\", \"inf\", nil},\n\t\t{\"+123inf\", \"+123\", \"inf\", nil},\n\t\t{\"-123inf\", \"-123\", \"inf\", nil},\n\n\t\t// More complex cases\n\t\t{\"123{\", \"123\", \"{\", nil},\n\t\t{\"-123.456e7+8\", \"-123.456e7\", \"+8\", nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d:%s\", i, tt.input), func(t *testing.T) {\n\t\t\tgotNum, gotTail, gotErr := parseRawNumber(tt.input)\n\n\t\t\tif gotNum != tt.wantNum {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got number = %q, want %q\", tt.input, gotNum, tt.wantNum)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got tail = %q, want %q\", tt.input, gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif gotErr == nil \u0026\u0026 tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got no error, want error %v\", tt.input, tt.wantErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr == nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got error = %v, want no error\", tt.input, gotErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got error = %v, want error %v\", tt.input, gotErr, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","b23f165790dec92592a71e74e8fd8fd3":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\twantS string\n\t\terr   error\n\t}{\n\t\t// Empty array\n\t\t{\n\t\t\tinput: \"[]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\twantS: \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t// Simple array\n\t\t{\n\t\t\tinput: \"[1,2,3]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantS: \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t// Array with different types\n\t\t{\n\t\t\tinput: `[1,\"test\",true,null]`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeString, s: \"test\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t\t{t: TypeNull},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantS: \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t// Array with nested array\n\t\t{\n\t\t\tinput: \"[1,[2,3],4]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeArray, a: []*Value{\n\t\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t\t}},\n\t\t\t\t\t{t: TypeNumber, s: \"4\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantS: \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t// Invalid array - missing closing bracket\n\t\t{\n\t\t\tinput: \"[1,2,3\",\n\t\t\twant:  nil,\n\t\t\twantS: \"\",\n\t\t\terr:   fmt.Errorf(\"unexpected end of array\"),\n\t\t},\n\t\t// Invalid array - missing comma\n\t\t{\n\t\t\tinput: \"[1 2 3]\",\n\t\t\twant:  nil,\n\t\t\twantS: \" 2 3]\",\n\t\t\terr:   fmt.Errorf(\"missing ',' after array value\"),\n\t\t},\n\t\t// Invalid array - trailing comma\n\t\t{\n\t\t\tinput: \"[1,2,]\",\n\t\t\twant:  nil,\n\t\t\twantS: \"\",\n\t\t\terr:   fmt.Errorf(\"cannot parse array value: unexpected end of JSON\"),\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, gotS, err := parseArray(tt.input, c, 0)\n\n\t\t\tif tt.err != nil {\n\t\t\t\tif err == nil || err.Error() != tt.err.Error() {\n\t\t\t\t\tt.Errorf(\"Expected error %v, got %v\", tt.err, err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"Expected remaining string %q, got %q\", tt.wantS, gotS)\n\t\t\t}\n\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"Test %d failed: Expected\\n\\t%v\\ngot\\n\\t%v\", i, tt.want, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(a, b *Value) bool {\n\tif a == nil \u0026\u0026 b == nil {\n\t\treturn true\n\t}\n\tif a == nil || b == nil {\n\t\treturn false\n\t}\n\tif a.t != b.t {\n\t\treturn false\n\t}\n\tswitch a.t {\n\tcase TypeArray:\n\t\tif len(a.a) != len(b.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range a.a {\n\t\t\tif !equalValues(a.a[i], b.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeString, TypeNumber:\n\t\treturn a.s == b.s\n\tdefault:\n\t\treturn true\n\t}\n}","b274ce25e34f5619bedd4d1f51c52eb9":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ts     string\n\t\terr   error\n\t}{\n\t\t// Empty array\n\t\t{\n\t\t\tinput: \"[]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Simple array\n\t\t{\n\t\t\tinput: \"[1,2,3]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Array with different types\n\t\t{\n\t\t\tinput: `[1,\"test\",true,null]`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeString, s: \"test\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t\t{t: TypeNull},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Array with nested array\n\t\t{\n\t\t\tinput: \"[1,[2,3],4]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeArray, a: []*Value{\n\t\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t\t}},\n\t\t\t\t\t{t: TypeNumber, s: \"4\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Array with whitespace\n\t\t{\n\t\t\tinput: \" [ 1 , 2 , 3 ] \",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Invalid array - missing comma\n\t\t{\n\t\t\tinput: \"[1 2 3]\",\n\t\t\twant:  nil,\n\t\t\ts:     \"2 3]\",\n\t\t\terr:   fmt.Errorf(\"missing ',' after array value\"),\n\t\t},\n\t\t// Invalid array - missing closing bracket\n\t\t{\n\t\t\tinput: \"[1,2,3\",\n\t\t\twant:  nil,\n\t\t\ts:     \"\",\n\t\t\terr:   fmt.Errorf(\"unexpected end of array\"),\n\t\t},\n\t\t// Invalid array - unexpected character\n\t\t{\n\t\t\tinput: \"[1,2,3}a\",\n\t\t\twant:  nil,\n\t\t\ts:     \"}a\",\n\t\t\terr:   fmt.Errorf(\"missing ',' after array value\"),\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseArray(tt.input, c, 0)\n\n\t\t\tif got == nil \u0026\u0026 tt.want == nil {\n\t\t\t\t// Both are nil, check error\n\t\t\t\tif err == nil \u0026\u0026 tt.err != nil {\n\t\t\t\t\tt.Errorf(\"expected error %v, got nil\", tt.err)\n\t\t\t\t} else if err != nil \u0026\u0026 tt.err == nil {\n\t\t\t\t\tt.Errorf(\"unexpected error %v\", err)\n\t\t\t\t} else if err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error() {\n\t\t\t\t\tt.Errorf(\"expected error %v, got %v\", tt.err, err)\n\t\t\t\t}\n\t\t\t} else if got == nil \u0026\u0026 tt.want != nil {\n\t\t\t\tt.Errorf(\"expected non-nil value, got nil\")\n\t\t\t} else if got != nil \u0026\u0026 tt.want == nil {\n\t\t\t\tt.Errorf(\"unexpected non-nil value, want nil\")\n\t\t\t} else {\n\t\t\t\t// Compare values\n\t\t\t\tif got.t != tt.want.t {\n\t\t\t\t\tt.Errorf(\"expected type %v, got %v\", tt.want.t, got.t)\n\t\t\t\t}\n\t\t\t\tif len(got.a) != len(tt.want.a) {\n\t\t\t\t\tt.Errorf(\"expected array length %d, got %d\", len(tt.want.a), len(got.a))\n\t\t\t\t}\n\t\t\t\tfor j := range got.a {\n\t\t\t\t\tif got.a[j].t != tt.want.a[j].t {\n\t\t\t\t\t\tt.Errorf(\"expected type %v for element %d, got %v\", tt.want.a[j].t, j, got.a[j].t)\n\t\t\t\t\t}\n\t\t\t\t\tif got.a[j].s != tt.want.a[j].s {\n\t\t\t\t\t\tt.Errorf(\"expected value %q for element %d, got %q\", tt.want.a[j].s, j, got.a[j].s)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif s != tt.s {\n\t\t\t\tt.Errorf(\"expected remaining string %q, got %q\", tt.s, s)\n\t\t\t}\n\t\t})\n\t}\n}\n","b2c1c16f19f788e01adcb94f55cad0b0":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantObj  string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t{\n\t\t\tname:     \"EmptyObject\",\n\t\t\tinput:    \"{}\",\n\t\t\twantObj:  `{\"t\":1}`,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"SimpleObject\",\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\twantObj:  `{\"t\":1,\"o\":{\"kvs\":[{\"k\":\"key\",\"v\":{\"t\":3,\"s\":\"value\"}}]}}`,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"MultipleKeyValues\",\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 123, \"key3\": true}`,\n\t\t\twantObj:  `{\"t\":1,\"o\":{\"kvs\":[{\"k\":\"key1\",\"v\":{\"t\":3,\"s\":\"value1\"}},{\"k\":\"key2\",\"v\":{\"t\":4,\"s\":\"123\"}},{\"k\":\"key3\",\"v\":{\"t\":5}}]}}`,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"NestedObject\",\n\t\t\tinput:    `{\"key1\": {\"key2\": \"value2\"}, \"key3\": \"value3\"}`,\n\t\t\twantObj:  `{\"t\":1,\"o\":{\"kvs\":[{\"k\":\"key1\",\"v\":{\"t\":1,\"o\":{\"kvs\":[{\"k\":\"key2\",\"v\":{\"t\":3,\"s\":\"value2\"}}]}}},{\"k\":\"key3\",\"v\":{\"t\":3,\"s\":\"value3\"}}]}}`,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"MissingClosingBrace\",\n\t\t\tinput:    `{\"key\": \"value\"`,\n\t\t\twantObj:  \"\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"MissingColon\",\n\t\t\tinput:    `{\"key\" \"value\"}`,\n\t\t\twantObj:  \"\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"MissingComma\",\n\t\t\tinput:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantObj:  \"\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"InvalidKey\",\n\t\t\tinput:    `{key: \"value\"}`,\n\t\t\twantObj:  \"\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  fmt.Errorf(\"cannot parse object key: cannot find opening '\\\"' for object key\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgotObj, gotTail, gotErr := parseObject(tt.input, c, 0)\n\n\t\t\tif gotObj != nil {\n\t\t\t\tgotObjStr := gotObj.String()\n\t\t\t\tif gotObjStr != tt.wantObj {\n\t\t\t\t\tt.Errorf(\"parseObject() gotObj = %v, want %v\", gotObjStr, tt.wantObj)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif tt.wantObj != \"\" {\n\t\t\t\t\tt.Errorf(\"parseObject() gotObj = nil, want %v\", tt.wantObj)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseObject() gotTail = %v, want %v\", gotTail, tt.wantTail)\n\t\t\t}\n\n\t\t\tif gotErr == nil \u0026\u0026 tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"parseObject() gotErr = nil, want %v\", tt.wantErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr == nil {\n\t\t\t\tt.Errorf(\"parseObject() gotErr = %v, want nil\", gotErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"parseObject() gotErr = %v, want %v\", gotErr, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}\n","b2cf84a6aeb0b423ad46a2a92b4babdf":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant: []byte(\"123\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"hello\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"[\\\"hello\\\",123]\"),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"message\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"hello\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"count\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"{\\\"message\\\":\\\"hello\\\",\\\"count\\\":\\\"123\\\"}\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif string(got) != string(tt.want) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %v, want %v\", string(got), string(tt.want))\n\t\t\t}\n\t\t})\n\t}\n}\n","b450486b468a9852733fdb3976569a3c":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetFloat64(t *testing.T) {\n\tvar v Value\n\n\t// Test case 1: Valid JSON with float64 value\n\tv.UnmarshalString(`{\"key1\": 123.456}`)\n\tf := v.GetFloat64(\"key1\")\n\tif f != 123.456 {\n\t\tt.Errorf(\"Expected 123.456, got %v\", f)\n\t}\n\n\t// Test case 2: Valid JSON with string value\n\tv.UnmarshalString(`{\"key1\": \"123.456\"}`)\n\tf = v.GetFloat64(\"key1\")\n\tif f != 123.456 {\n\t\tt.Errorf(\"Expected 123.456, got %v\", f)\n\t}\n\n\t// Test case 3: Valid JSON with nested key\n\tv.UnmarshalString(`{\"key1\": {\"key2\": 789.012}}`)\n\tf = v.GetFloat64(\"key1\", \"key2\")\n\tif f != 789.012 {\n\t\tt.Errorf(\"Expected 789.012, got %v\", f)\n\t}\n\n\t// Test case 4: Valid JSON with array index\n\tv.UnmarshalString(`{\"key1\": [1.23, 4.56, 7.89]}`)\n\tf = v.GetFloat64(\"key1\", \"1\")\n\tif f != 4.56 {\n\t\tt.Errorf(\"Expected 4.56, got %v\", f)\n\t}\n\n\t// Test case 5: Non-existing key\n\tf = v.GetFloat64(\"nonexistingkey\")\n\tif f != 0 {\n\t\tt.Errorf(\"Expected 0, got %v\", f)\n\t}\n\n\t// Test case 6: Invalid value type\n\tv.UnmarshalString(`{\"key1\": \"not a number\"}`)\n\tf = v.GetFloat64(\"key1\")\n\tif f != 0 {\n\t\tt.Errorf(\"Expected 0, got %v\", f)\n\t}\n}","b514df76d6af14fc4f444c942cde5ac8":"package fastjson\n\nimport \"testing\"\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    string\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\ts:    \"\",\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"all whitespace\",\n\t\t\ts:    \" \\t\\n\\r\",\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace\",\n\t\t\ts:    \"  foo\",\n\t\t\twant: \"foo\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailing whitespace\",\n\t\t\ts:    \"foo  \",\n\t\t\twant: \"foo  \",\n\t\t},\n\t\t{\n\t\t\tname: \"whitespace in the middle\",\n\t\t\ts:    \"foo bar\",\n\t\t\twant: \"foo bar\",\n\t\t},\n\t\t{\n\t\t\tname: \"no whitespace\",\n\t\t\ts:    \"foobar\",\n\t\t\twant: \"foobar\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %q, want %q\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","b5ba9e305ed271a13086bb75c92eeb74":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Empty string\n\t\t{\"\", nil, \"\", fmt.Errorf(\"cannot parse empty string\")},\n\t\t// Object\n\t\t{`{\"foo\":\"bar\"}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: typeRawString, s: \"bar\"}}}}}, \"\", nil},\n\t\t// Array\n\t\t{`[1,2,3]`, \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}}, \"\", nil},\n\t\t// String\n\t\t{`\"hello\"`, \u0026Value{t: typeRawString, s: \"hello\"}, \"\", nil},\n\t\t// True\n\t\t{\"true\", valueTrue, \"\", nil},\n\t\t// False\n\t\t{\"false\", valueFalse, \"\", nil},\n\t\t// Null\n\t\t{\"null\", valueNull, \"\", nil},\n\t\t// Number\n\t\t{\"123\", \u0026Value{t: TypeNumber, s: \"123\"}, \"\", nil},\n\t\t// NaN\n\t\t{\"NaN\", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"\", nil},\n\t\t// Invalid value\n\t\t{\"invalid\", nil, \"invalid\", fmt.Errorf(\"unexpected value found: %q\", \"invalid\")},\n\t}\n\n\tc := \u0026cache{}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tgot, tail, err := parseValue(tt.input, c, 0)\n\t\t\tif (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, wantErr %v\", tt.input, err, tt.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"parseValue(%q) tail = %q, wantTail %q\", tt.input, tail, tt.tail)\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", tt.input, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.t == TypeObject {\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\tif v1.t == TypeArray {\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\treturn v1.s == v2.s\n}\n","b649516c92ed84646401f9a0c8be1b42":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Get(t *testing.T) {\n\t// Test cases for Get function\n\ttests := []struct {\n\t\tname     string\n\t\tjson     string\n\t\tkeys     []string\n\t\texpected *Value\n\t}{\n\t\t{\n\t\t\tname:     \"GetExistingKey\",\n\t\t\tjson:     `{\"name\": \"John\", \"age\": 30}`,\n\t\t\tkeys:     []string{\"name\"},\n\t\t\texpected: \u0026Value{t: TypeString, s: \"John\"},\n\t\t},\n\t\t{\n\t\t\tname:     \"GetNestedKey\",\n\t\t\tjson:     `{\"person\": {\"name\": \"John\", \"age\": 30}}`,\n\t\t\tkeys:     []string{\"person\", \"age\"},\n\t\t\texpected: \u0026Value{t: TypeNumber, s: \"30\"},\n\t\t},\n\t\t{\n\t\t\tname:     \"GetArrayElement\",\n\t\t\tjson:     `{\"fruits\": [\"apple\", \"banana\", \"orange\"]}`,\n\t\t\tkeys:     []string{\"fruits\", \"1\"},\n\t\t\texpected: \u0026Value{t: TypeString, s: \"banana\"},\n\t\t},\n\t\t{\n\t\t\tname:     \"GetNonExistingKey\",\n\t\t\tjson:     `{\"name\": \"John\", \"age\": 30}`,\n\t\t\tkeys:     []string{\"address\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"GetInvalidArrayIndex\",\n\t\t\tjson:     `{\"fruits\": [\"apple\", \"banana\", \"orange\"]}`,\n\t\t\tkeys:     []string{\"fruits\", \"abc\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"GetFromNilValue\",\n\t\t\tjson:     \"\",\n\t\t\tkeys:     []string{\"name\"},\n\t\t\texpected: nil,\n\t\t},\n\t}\n\n\tfor _, tt := var v *Value\n\t\t\tvar err error\n\n\t\t\tif tt.json != \"\" {\n\t\t\t\tv, err = Parse(tt.json)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"Test case %s failed to parse JSON: %v\", tt.name, err)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tv = nil\n\t\t\t}\n\n\t\t\tactual := v.Get(tt.keys...)\n\n\t\t\tif actual != nil \u0026\u0026 tt.expected != nil {\n\t\t\t\tif actual.Type() != tt.expected.Type() || actual.String() != tt.expected.String() {\n\t\t\t\t\tt.Errorf(\"Test case %s failed. Expected: %v, Actual: %v\", tt.name, tt.expected, actual)\n\t\t\t\t}\n\t\t\t} else if (actual == nil \u0026\u0026 tt.expected != nil) || (actual != nil \u0026\u0026 tt.expected == nil) {\n\t\t\t\tt.Errorf(\"Test case %s failed. Expected: %v, Actual: %v\", tt.name, tt.expected, actual)\n\t\t\t}\n\t\t})\n}","b677050dbcec629c8d29f82e2c3f2fd6":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Type(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tjson  string\n\t\twant  Type\n\t\twant1 string\n\t}{\n\t\t{\n\t\t\tname:  \"null\",\n\t\t\tjson:  \"null\",\n\t\t\twant:  TypeNull,\n\t\t\twant1: \"null\",\n\t\t},\n\t\t{\n\t\t\tname:  \"object\",\n\t\t\tjson:  `{\"foo\": \"bar\"}`,\n\t\t\twant:  TypeObject,\n\t\t\twant1: `{\"foo\": \"bar\"}`,\n\t\t},\n\t\t{\n\t\t\tname:  \"array\",\n\t\t\tjson:  `[1, 2, 3]`,\n\t\t\twant:  TypeArray,\n\t\t\twant1: `[1, 2, 3]`,\n\t\t},\n\t\t{\n\t\t\tname:  \"string\",\n\t\t\tjson:  `\"hello, world\"`,\n\t\t\twant:  TypeString,\n\t\t\twant1: `\"hello, world\"`,\n\t\t},\n\t\t{\n\t\t\tname:  \"number\",\n\t\t\tjson:  `12345`,\n\t\t\twant:  TypeNumber,\n\t\t\twant1: `12345`,\n\t\t},\n\t\t{\n\t\t\tname:  \"true\",\n\t\t\tjson:  `true`,\n\t\t\twant:  TypeTrue,\n\t\t\twant1: `true`,\n\t\t},\n\t\t{\n\t\t\tname:  \"false\",\n\t\t\tjson:  `false`,\n\t\t\twant:  TypeFalse,\n\t\t\twant1: `false`,\n\t\t},\n\t\t{\n\t\t\tname:  \"raw string\",\n\t\t\tjson:  `\"\\u003c\\u003e\"`,\n\t\t\twant:  TypeString,\n\t\t\twant1: `\"\u003c\\\\\u003e\"`,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv := ParseBytes([]byte(tt.json))\n\t\t\tif got := v.Type(); got != tt.want {\n\t\t\t\tt.Errorf(\"Type() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got := v.String(); got != tt.want1 {\n\t\t\t\tt.Errorf(\"String() = %v, want %v\", got, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","b702b7f64b16cbf5e64694750a7a6b86":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey   string\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t{`\"key\": \"value\"`, \"key\", `: \"value\"`, nil},\n\t\t{`\"key\":`, \"key\", `:`, nil},\n\t\t{`\"key\"`, \"key\", \"\", nil},\n\t\t{`\"ke\\\"y\": \"value\"`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"key\\u0000\": \"value\"`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"key\": \"value`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test_%d\", i), func(t *testing.T) {\n\t\t\tkey, tail, err := parseRawKey(tt.input)\n\t\t\tif key != tt.key || tail != tt.tail || !errorEqual(err, tt.err) {\n\t\t\t\tt.Errorf(\"parseRawKey(%q) = (%q, %q, %v), want (%q, %q, %v)\", tt.input, key, tail, err, tt.key, tt.tail, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc errorEqual(e1, e2 error) bool {\n\tif e1 == nil \u0026\u0026 e2 == nil {\n\t\treturn true\n\t}\n\tif e1 != nil \u0026\u0026 e2 != nil {\n\t\treturn e1.Error() == e2.Error()\n\t}\n\treturn false\n}","b77435e569aff9b55cf6558a968f476c":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey   string\n\t\tvalue string\n\t\terr   error\n\t}{\n\t\t// Basic cases\n\t\t{`\"foo\"bar`, \"foo\", \"bar\", nil},\n\t\t{`\"foo\" bar`, \"foo\", \" bar\", nil},\n\t\t{`\"foo\"  bar`, \"foo\", \"  bar\", nil},\n\t\t{`\"foo\"`, \"foo\", \"\", nil},\n\n\t\t// Escaped quotes\n\t\t{`\"fo\\\"o\"bar`, `fo\"o`, \"bar\", nil},\n\t\t{`\"fo\\\\\"o\"bar`, `fo\\\"o`, \"bar\", nil},\n\t\t{`\"fo\\\\\\\\\"o\"bar`, `fo\\\\\"o`, \"bar\", nil},\n\t\t{`\"fo\\\\\\\"o\"bar`, `fo\\\"o`, \"bar\", nil},\n\n\t\t// Errors\n\t\t{`\"foo`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"fo\"o\"bar`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`fo\"o\"bar`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tkey, value, err := parseRawString(tt.input)\n\t\t\tif key != tt.key || value != tt.value || !errorEqual(err, tt.err) {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = (%q, %q, %v), want (%q, %q, %v)\", tt.input, key, value, err, tt.key, tt.value, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc errorEqual(e1, e2 error) bool {\n\tif e1 == nil \u0026\u0026 e2 == nil {\n\t\treturn true\n\t}\n\tif e1 == nil || e2 == nil {\n\t\treturn false\n\t}\n\treturn e1.Error() == e2.Error()\n}","b7a19dad9f8dc44de63625c70135f9cb":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput  string\n\t\tns     string\n\t\ttail   string\n\t\thasErr bool\n\t}{\n\t\t{\"123\", \"123\", \"\", false},\n\t\t{\"123a\", \"123\", \"a\", false},\n\t\t{\"-123\", \"-123\", \"\", false},\n\t\t{\"+123\", \"+123\", \"\", false},\n\t\t{\"123.456\", \"123.456\", \"\", false},\n\t\t{\"123e+456\", \"123e+456\", \"\", false},\n\t\t{\"123e-456\", \"123e-456\", \"\", false},\n\t\t{\"123E+456\", \"123E+456\", \"\", false},\n\t\t{\"123E-456\", \"123E-456\", \"\", false},\n\t\t{\"-inf\", \"-inf\", \"\", false},\n\t\t{\"+inf\", \"+inf\", \"\", false},\n\t\t{\"inf\", \"inf\", \"\", false},\n\t\t{\"-Inf\", \"-Inf\", \"\", false},\n\t\t{\"+Inf\", \"+Inf\", \"\", false},\n\t\t{\"Inf\", \"Inf\", \"\", false},\n\t\t{\"-nan\", \"-nan\", \"\", false},\n\t\t{\"+nan\", \"+nan\", \"\", false},\n\t\t{\"nan\", \"nan\", \"\", false},\n\t\t{\"-NaN\", \"-NaN\", \"\", false},\n\t\t{\"+NaN\", \"+NaN\", \"\", false},\n\t\t{\"NaN\", \"NaN\", \"\", false},\n\t\t{\"-123inf\", \"-123\", \"inf\", false},\n\t\t{\"+123inf\", \"+123\", \"inf\", false},\n\t\t{\"123inf\", \"123\", \"inf\", false},\n\t\t{\"-123Inf\", \"-123\", \"Inf\", false},\n\t\t{\"+123Inf\", \"+123\", \"Inf\", false},\n\t\t{\"123Inf\", \"123\", \"Inf\", false},\n\t\t{\"-123nan\", \"-123\", \"nan\", false},\n\t\t{\"+123nan\", \"+123\", \"nan\", false},\n\t\t{\"123nan\", \"123\", \"nan\", false},\n\t\t{\"-123NaN\", \"-123\", \"NaN\", false},\n\t\t{\"+123NaN\", \"+123\", \"NaN\", false},\n\t\t{\"123NaN\", \"123\", \"NaN\", false},\n\t\t{\"a123\", \"\", \"a123\", true},\n\t\t{\"-a123\", \"\", \"-a123\", true},\n\t\t{\"+a123\", \"\", \"+a123\", true},\n\t\t{\"\", \"\", \"\", true},\n\t\t{\"-\", \"\", \"-\", true},\n\t\t{\"+\", \"\", \"+\", true},\n\t}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i+1), func(t *testing.T) {\n\t\t\tns, tail, err := parseRawNumber(tt.input)\n\t\t\tif (err != nil) != tt.hasErr {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tt.input, err, tt.hasErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif ns != tt.ns {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) ns = %q, want %q\", tt.input, ns, tt.ns)\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) tail = %q, want %q\", tt.input, tail, tt.tail)\n\t\t\t}\n\t\t})\n\t}\n}","b820683300c14c36357582b48bac4df3":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := [2]struct {\n\t\ts        string\n\t\twantS    string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t{\n\t\t\ts:        `\"foo\"bar`,\n\t\t\twantS:    \"foo\",\n\t\t\twantTail: \"bar\",\n\t\t},\n\t\t{\n\t\t\ts:        `\"foo\\\"bar\"baz`,\n\t\t\twantS:    `foo\\\"bar`,\n\t\t\twantTail: \"baz\",\n\t\t},\n\t}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test %d\", i), func(t *testing.T) {\n\t\t\tgotS, gotTail, err := parseRawString(tt.s)\n\t\t\tif gotS != tt.wantS || gotTail != tt.wantTail || !equalError(err, tt.wantErr) {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = %q, %q, %v, want %q, %q, %v\", tt.s, gotS, gotTail, err, tt.wantS, tt.wantTail, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// equalError tells whether errors a and b contain the same error message.\n//\n// The error messages are compared as string, so this function should\n// be used only for testing errors.\nfunc equalError(a, b error) bool {\n\tif a == nil {\n\t\treturn b == nil\n\t}\n\tif b == nil {\n\t\treturn false\n\t}\n\treturn a.Error() == b.Error()\n}","b9027e608afcd64bdeefc42196d68462":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv:    \u0026Value{t: typeRawString, s: \"raw string\"},\n\t\t\twant: []byte(\"\\\"raw string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv:    \u0026Value{t: TypeString, s: \"string\"},\n\t\t\twant: []byte(\"\\\"string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv:    \u0026Value{t: TypeNumber, s: \"1234\"},\n\t\t\twant: []byte(\"1234\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv:    \u0026Value{t: TypeTrue},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv:    \u0026Value{t: TypeFalse},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv:    \u0026Value{t: TypeNull},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t{t: TypeString, s: \"string\"},\n\t\t\t\t{t: TypeTrue},\n\t\t\t}},\n\t\t\twant: []byte(\"[1,\\\"string\\\",true]\"),\n\t\t},\n\t\t// TODO: add test case for object\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif string(got) != string(tt.want) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %v, want %v\", string(got), string(tt.want))\n\t\t\t}\n\t\t})\n\t}\n}","b94c8a675ca01c0e5705f4898a327a1f":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ts     string\n\t\terr   error\n\t}{\n\t\t// Empty input.\n\t\t{\"\", nil, \"\", fmt.Errorf(\"missing ']'\")},\n\t\t// Empty array.\n\t\t{\"[]\", \u0026Value{t: TypeArray}, \"\", nil},\n\t\t// Simple array.\n\t\t{\"[1,2,3]\", \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}}, \"\", nil},\n\t\t// Array with whitespace.\n\t\t{\" [ 1 , 2 , 3 ] \", \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}}, \"\", nil},\n\t\t// Nested array.\n\t\t{\"[[1,2],[3,4]]\", \u0026Value{t: TypeArray, a: []*Value{{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}}}, {t: TypeArray, a: []*Value{{t: TypeNumber, s: \"3\"}, {t: TypeNumber, s: \"4\"}}}}}, \"\", nil},\n\t\t// Array with different types.\n\t\t{\"[1,\\\"foo\\\",true]\", \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeString, s: \"foo\"}, {t: TypeTrue}}}, \"\", nil},\n\t\t// Invalid array: missing comma.\n\t\t{\"[1 2]\", nil, \" 2]\", fmt.Errorf(\"missing ',' after array value\")},\n\t\t// Invalid array: missing closing bracket.\n\t\t{\"[1,2\", nil, \"\", fmt.Errorf(\"unexpected end of array\")},\n\t\t// Invalid array: unexpected token.\n\t\t{\"[1,2,foo]\", nil, \",foo]\", fmt.Errorf(\"cannot parse array value: invalid character 'f' looking for beginning of value\")},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseArray(tt.input, c, 0)\n\n\t\t\tif got != nil \u0026\u0026 tt.want != nil \u0026\u0026 got.t != tt.want.t {\n\t\t\t\tt.Errorf(\"got type %v, want %v\", got.t, tt.want.t)\n\t\t\t}\n\t\t\tif got != nil \u0026\u0026 tt.want != nil \u0026\u0026 len(got.a) != len(tt.want.a) {\n\t\t\t\tt.Errorf(\"got array length %v, want %v\", len(got.a), len(tt.want.a))\n\t\t\t}\n\t\t\tif s != tt.s {\n\t\t\t\tt.Errorf(\"got string remainder %q, want %q\", s, tt.s)\n\t\t\t}\n\t\t\tif (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err == nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"got error %v, want %v\", err, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}","b986d4c589f56a16c52eb378505a2e52":"package fastjson\n\nimport \"testing\"\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tt        Type\n\t\texpected string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\tfor _, test := range tests {\n\t\tactual := test.t.String()\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Expected String() to return %q for type %d, got %q\", test.expected, test.t, actual)\n\t\t}\n\t}\n}","bae59786f5c861d477ca897b14a101e7":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"raw string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"raw string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"string\",\n\t\t\t},\n\t\t\twant: []byte(\"string\"),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"12345\",\n\t\t\t},\n\t\t\twant: []byte(\"12345\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"string1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"[\\\"string1\\\",123]\"),\n\t\t},\n\t\t// Add more test cases for other types and nested objects/arrays\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif string(got) != string(tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", string(got), string(tt.want))\n\t\t\t}\n\t\t})\n\t}\n}","bae6aaeb6d2dde466a9d225e8b25689e":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"raw string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"raw string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"12345\",\n\t\t\t},\n\t\t\twant: []byte(\"12345\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"string\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"12345\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"[\\\"string\\\",12345]\"),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"{\\\"key\\\":\\\"value\\\"}\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif string(got) != string(tt.want) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %v, want %v\", string(got), string(tt.want))\n\t\t\t}\n\t\t})\n\t}\n}\n","bba33bd45299023ca8b7a83a78d12329":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ts     string\n\t\terr   error\n\t}{\n\t\t// Empty array\n\t\t{\n\t\t\tinput: \"[]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Simple array\n\t\t{\n\t\t\tinput: \"[1,2,3]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Array with whitespace\n\t\t{\n\t\t\tinput: \" [ 1 , 2 , 3 ] \",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Nested array\n\t\t{\n\t\t\tinput: \"[[1,2],[3,4]]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t\t\t\t{t: TypeNumber, s: \"4\"},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Missing ']'\n\t\t{\n\t\t\tinput: \"[1,2,3\",\n\t\t\twant:  nil,\n\t\t\ts:     \"[1,2,3\",\n\t\t\terr:   fmt.Errorf(\"missing ']'\"),\n\t\t},\n\t\t// Unexpected end of array\n\t\t{\n\t\t\tinput: \"[1,2,\",\n\t\t\twant:  nil,\n\t\t\ts:     \"[1,2,\",\n\t\t\terr:   fmt.Errorf(\"unexpected end of array\"),\n\t\t},\n\t\t// Missing ',' after array value\n\t\t{\n\t\t\tinput: \"[1 2]\",\n\t\t\twant:  nil,\n\t\t\ts:     \" 2]\",\n\t\t\terr:   fmt.Errorf(\"missing ',' after array value\"),\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseArray(tt.input, c, 0)\n\n\t\t\tif (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err == nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"Test %d: Expected error %v, got %v\", i, tt.err, err)\n\t\t\t}\n\n\t\t\tif s != tt.s {\n\t\t\t\tt.Errorf(\"Test %d: Expected remaining string %q, got %q\", i, tt.s, s)\n\t\t\t}\n\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"Test %d: Expected value %v, got %v\", i, tt.want, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.t == TypeArray {\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\treturn v1.s == v2.s\n}","bbd4aacd501b5510c301e28e2c99a7a2":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetStringBytes(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tjson  string\n\t\tkeys  []string\n\t\twant  []byte\n\t\twant1 bool\n\t}{\n\t\t{\n\t\t\tname:  \"simple\",\n\t\t\tjson:  `{\"foo\": \"bar\"}`,\n\t\t\tkeys:  []string{\"foo\"},\n\t\t\twant:  []byte(\"bar\"),\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"number\",\n\t\t\tjson:  `{\"foo\": 123}`,\n\t\t\tkeys:  []string{\"foo\"},\n\t\t\twant:  nil,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"nested\",\n\t\t\tjson:  `{\"foo\": {\"bar\": \"baz\"}}`,\n\t\t\tkeys:  []string{\"foo\", \"bar\"},\n\t\t\twant:  []byte(\"baz\"),\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array\",\n\t\t\tjson:  `{\"foo\": [\"bar\", \"baz\"]}`,\n\t\t\tkeys:  []string{\"foo\", \"1\"},\n\t\t\twant:  []byte(\"baz\"),\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array decimal index\",\n\t\t\tjson:  `{\"foo\": [\"bar\", \"baz\"]}`,\n\t\t\tkeys:  []string{\"foo\", \"1.0\"},\n\t\t\twant:  []byte(\"baz\"),\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"non-existing key\",\n\t\t\tjson:  `{\"foo\": \"bar\"}`,\n\t\t\tkeys:  []string{\"baz\"},\n\t\t\twant:  nil,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"non-existing nested key\",\n\t\t\tjson:  `{\"foo\": {\"bar\": \"baz\"}}`,\n\t\t\tkeys:  []string{\"foo\", \"qux\"},\n\t\t\twant:  nil,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"invalid array index\",\n\t\t\tjson:  `{\"foo\": [\"bar\", \"baz\"]}`,\n\t\t\tkeys:  []string{\"foo\", \"2\"},\n\t\t\twant:  nil,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"invalid array index decimal\",\n\t\t\tjson:  `{\"foo\": [\"bar\", \"baz\"]}`,\n\t\t\tkeys:  []string{\"foo\", \"1.1\"},\n\t\t\twant:  nil,\n\t\t\twant1: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv, err := ParseBytes([]byte(tt.json))\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"ParseBytes() error = %v, wantErr %v\", err, nil)\n\t\t\t}\n\n\t\t\tgot := v.GetStringBytes(tt.keys...)\n\t\t\tif !bytesEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"GetStringBytes() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc bytesEqual(a, b []byte) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i, v := range a {\n\t\tif v != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","bbe3e673670e6d1a8100b95f3f3b6604":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ts     string\n\t\terr   error\n\t}{\n\t\t// Empty object\n\t\t{\n\t\t\tinput: `{}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: true,\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Simple object\n\t\t{\n\t\t\tinput: `{\"key\": \"value\"}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: \u0026Value{t: TypeString, s: \"value\"}},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: true,\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Object with multiple key-value pairs\n\t\t{\n\t\t\tinput: `{\"key1\": \"value1\", \"key2\": 123, \"key3\": true}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t\t{k: \"key3\", v: \u0026Value{t: TypeTrue}},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: true,\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Object with nested object\n\t\t{\n\t\t\tinput: `{\"key1\": {\"key2\": \"value2\"}}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: true,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: true,\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Invalid object: missing closing brace\n\t\t{\n\t\t\tinput: `{\"key\": \"value\"`,\n\t\t\twant:  nil,\n\t\t\ts:     `{\"key\": \"value\"`,\n\t\t\terr:   fmt.Errorf(`missing '}'`),\n\t\t},\n\t\t// Invalid object: missing colon\n\t\t{\n\t\t\tinput: `{\"key\" \"value\"}`,\n\t\t\twant:  nil,\n\t\t\ts:     `\"value\"}`,\n\t\t\terr:   fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t\t// Invalid object: missing comma\n\t\t{\n\t\t\tinput: `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twant:  nil,\n\t\t\ts:     `\"key2\": \"value2\"}`,\n\t\t\terr:   fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseObject(tt.input, c, 0)\n\t\t\tif (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif s != tt.s {\n\t\t\t\tt.Errorf(\"parseObject() s = %s, want %s\", s, tt.s)\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\treturn true\n\t}\n}","bc32bb4bd7cd7c280d27c80f1da62f5b":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantNum  string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Basic cases\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"123.456\", \"123.456\", \"\", nil},\n\t\t{\"1.2e3\", \"1.2e3\", \"\", nil},\n\t\t{\"1.2E-3\", \"1.2E-3\", \"\", nil},\n\n\t\t// Trailing characters\n\t\t{\"123a\", \"123\", \"a\", nil},\n\t\t{\"123 \", \"123\", \" \", nil},\n\n\t\t// Invalid numbers\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t\t{\"a\", \"\", \"a\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\"1a\", \"\", \"1a\", fmt.Errorf(\"unexpected char: %q\", \"1a\")},\n\t\t{\"+a\", \"\", \"+a\", fmt.Errorf(\"unexpected char: %q\", \"+a\")},\n\t\t{\"-a\", \"\", \"-a\", fmt.Errorf(\"unexpected char: %q\", \"-a\")},\n\n\t\t// Special cases with \"inf\" and \"nan\"\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"+inf\", \"+inf\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"123inf\", \"123\", \"inf\", nil},\n\t\t{\"123nan\", \"123\", \"nan\", nil},\n\t\t{\"123in\", \"123\", \"in\", nil}, // Not a valid \"inf\"\n\t\t{\"123na\", \"123\", \"na\", nil}, // Not a valid \"nan\"\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tgotNum, gotTail, gotErr := parseRawNumber(tt.input)\n\t\t\tif gotNum != tt.wantNum {\n\t\t\t\tt.Errorf(\"input %q: got number %q, want %q\", tt.input, gotNum, tt.wantNum)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"input %q: got tail %q, want %q\", tt.input, gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif gotErr == nil \u0026\u0026 tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"input %q: got no error, want %v\", tt.input, tt.wantErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr == nil {\n\t\t\t\tt.Errorf(\"input %q: got error %v, want no error\", tt.input, gotErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"input %q: got error %v, want %v\", tt.input, gotErr, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","bc5d285469a1c0d8fc4ef44b5183d6ea":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput       string\n\t\texpectedVal *Value\n\t\texpectedStr string\n\t\texpectedErr error\n\t}{\n\t\t// Empty array\n\t\t{\"[]\", \u0026Value{t: TypeArray, a: []*Value{}}, \"\", nil},\n\n\t\t// Simple array\n\t\t{\"[1,2,3]\", \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t}}, \"\", nil},\n\n\t\t// Array with different types\n\t\t{\"[1,\\\"hello\\\",true]\", \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t{t: TypeString, s: \"hello\"},\n\t\t\t{t: TypeTrue},\n\t\t}}, \"\", nil},\n\n\t\t// Nested array\n\t\t{\"[[1,2],[3,4]]\", \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t}},\n\t\t\t{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t{t: TypeNumber, s: \"4\"},\n\t\t\t}},\n\t\t}}, \"\", nil},\n\n\t\t// Array with whitespace\n\t\t{\" [ 1 , 2 , 3 ] \", \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t}}, \" \", nil},\n\n\t\t// Invalid array - missing closing bracket\n\t\t{\"[1,2,3\", nil, \"\", fmt.Errorf(\"unexpected end of array\")},\n\n\t\t// Invalid array - missing comma\n\t\t{\"[1 2 3]\", nil, \"2 3]\", fmt.Errorf(\"missing ',' after array value\")},\n\n\t\t// Invalid array - trailing comma\n\t\t{\"[1,2,]\", nil, \"\", fmt.Errorf(\"cannot parse array value: unexpected end of JSON\")},\n\t}\n\n\tc := \u0026cache{}\n\tfor i, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tv, str, err := parseArray(test.input, c, 0)\n\n\t\t\tif test.expectedErr != nil {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"Expected error %v, got nil\", test.expectedErr)\n\t\t\t\t} else if err.Error() != test.expectedErr.Error() {\n\t\t\t\t\tt.Errorf(\"Expected error %v, got %v\", test.expectedErr, err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t\t}\n\t\t\tif str != test.expectedStr {\n\t\t\t\tt.Errorf(\"Expected remaining string '%s', got '%s'\", test.expectedStr, str)\n\t\t\t}\n\t\t\tif !equalValues(v, test.expectedVal) {\n\t\t\t\tt.Errorf(\"Test %d failed: Expected\\n%v\\ngot\\n%v\", i, test.expectedVal, v)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.t == TypeArray {\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\treturn v1.s == v2.s\n}","bd08cdc2e23161062627047e003b8850":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic escapes\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\t`, \"\\t\"},\n\t\t{`\\\\`, \"\\\\\"},\n\t\t{`\\\"`, \"\\\"\"},\n\t\t{`\\/`, \"/\"},\n\n\t\t// Unicode escapes\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A0`, \"\\u00A0\"},\n\t\t{`\\u20AC`, \"\\u20AC\"},\n\n\t\t// Surrogate pairs\n\t\t{`\\uD83D\\uDE02`, \"\\U0001F602\"},\n\n\t\t// Invalid escapes\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\uD800`, `\\uD800`},\n\t\t{`\\uD800\\u`, `\\uD800\\u`},\n\n\t\t// Mixed escapes\n\t\t{`Hello\\tworld\\n`, \"Hello\\tworld\\n\"},\n\t\t{`\\u0041\\u0020\\u0073\\u0074\\u0072\\u0069\\u006e\\u0067`, \"A string\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}","bd43f4fafcaeeba798c3f402040ffc31":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic cases\n\t\t{`\"hello world\"`, \"hello world\"},\n\t\t{`\"escaped \\\\\\\" string\"', \"escaped \\\" string\"},\n\t\t{`\"escaped \\\\/ string\"', \"escaped / string\"},\n\t\t{`\"escaped \\\\b string\"', \"escaped \\b string\"},\n\t\t{`\"escaped \\\\f string\"', \"escaped \\f string\"},\n\t\t{`\"escaped \\\\n string\"', \"escaped \\n string\"},\n\t\t{`\"escaped \\\\r string\"', \"escaped \\r string\"},\n\t\t{`\"escaped \\\\t string\"', \"escaped \\t string\"},\n\n\t\t// Unicode escapes\n\t\t{`\"\\u0041\\u0042\\u0043\"`, \"ABC\"},\n\t\t{`\"\\u041f\\u0440\\u0438\\u0432\\u0435\\u0442\"`, \"–ü—Ä–∏–≤–µ—Ç\"},\n\t\t{`\"\\uD83D\\uDE02\"`, \"üòÇ\"}, // Surrogate pair\n\n\t\t// Invalid escapes\n\t\t{`\"\\x\"`, `\\x`},\n\t\t{`\"\\u\"`, `\\u`},\n\t\t{`\"\\u123\"`, `\\u123`},\n\t\t{`\"\\uD800\"`, `\\uD800`}, // Invalid surrogate pair\n\t\t{`\"\\uD800\\u\"`, `\\uD800\\u`},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}\n","be3fef38b753fb00b2dd27df1c22fb9f":"package fastjson\n\nimport \"testing\"\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tt    Type\n\t\twant string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\tfor i, tt := range tests {\n\t\tif got := tt.t.String(); got != tt.want {\n\t\t\tt.Errorf(\"test[%d] - String() = %v, want %v\", i, got, tt.want)\n\t\t}\n\t}\n}","bfd9bf47990529b6e2f1fe69b5593909":"package fastjson\n\nimport \"testing\"\n\nfunc Test_hasSpecialChars(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    string\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\ts:    \"\",\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with no special characters\",\n\t\t\ts:    \"hello world\",\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with double quote\",\n\t\t\ts:    \"hello\\\"world\",\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with backslash\",\n\t\t\ts:    \"hello\\\\world\",\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with control character\",\n\t\t\ts:    \"hello\\x01world\",\n\t\t\twant: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := hasSpecialChars(tt.s); got != tt.want {\n\t\t\t\tt.Errorf(\"hasSpecialChars() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","bfff9a81256b0c60aeeaa312fc7ea322":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ts     string\n\t\terr   error\n\t}{\n\t\t// Empty array\n\t\t{\n\t\t\tinput: \"[]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Simple array\n\t\t{\n\t\t\tinput: \"[1,2,3]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Array with different types\n\t\t{\n\t\t\tinput: `[1,\"test\",true,null]`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeString, s: \"test\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t\t{t: TypeNull},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Nested array\n\t\t{\n\t\t\tinput: \"[1,[2,3],4]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeArray, a: []*Value{\n\t\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t\t}},\n\t\t\t\t\t{t: TypeNumber, s: \"4\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Array with whitespace\n\t\t{\n\t\t\tinput: \" [ 1 , 2 , 3 ] \",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \" \",\n\t\t\terr: nil,\n\t\t},\n\t\t// Invalid array - missing closing bracket\n\t\t{\n\t\t\tinput: \"[1,2,3\",\n\t\t\twant:  nil,\n\t\t\ts:     \"[1,2,3\",\n\t\t\terr:   fmt.Errorf(\"unexpected end of array\"),\n\t\t},\n\t\t// Invalid array - missing comma\n\t\t{\n\t\t\tinput: \"[1,2 3]\",\n\t\t\twant:  nil,\n\t\t\ts:     \" 3]\",\n\t\t\terr:   fmt.Errorf(\"missing ',' after array value\"),\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i+1), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseArray(tt.input, c, 0)\n\n\t\t\tif (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"parseArray(%s) error mismatch: got %v, want %v\", tt.input, err, tt.err)\n\t\t\t}\n\n\t\t\tif s != tt.s {\n\t\t\t\tt.Errorf(\"parseArray(%s) remaining string mismatch: got %q, want %q\", tt.input, s, tt.s)\n\t\t\t}\n\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray(%s) value mismatch:\\ngot  %+v\\nwant %+v\", tt.input, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.s != v2.s {\n\t\treturn false\n\t}\n\tif len(v1.a) != len(v2.a) {\n\t\treturn false\n\t}\n\tfor i := range v1.a {\n\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","c0874c7164c921c92d5c73b5e96f2adc":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantN    string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Basic cases.\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"123.45\", \"123.45\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"+123\", \"+123\", \"\", nil},\n\t\t{\"1e5\", \"1e5\", \"\", nil},\n\t\t{\"1.2e-5\", \"1.2e-5\", \"\", nil},\n\n\t\t// Trailing garbage.\n\t\t{\"123a\", \"123\", \"a\", nil},\n\t\t{\"123.45b\", \"123.45\", \"b\", nil},\n\n\t\t// Leading garbage.\n\t\t{\"a123\", \"\", \"a123\", fmt.Errorf(`unexpected char: \"a\"`)},\n\n\t\t// Invalid numbers.\n\t\t{\"\", \"\", \"\", fmt.Errorf(`unexpected char: \"\"`)},\n\t\t{\"-\", \"\", \"-\", fmt.Errorf(`unexpected char: \"-\"`)},\n\t\t{\"+\", \"\", \"+\", fmt.Errorf(`unexpected char: \"+\"`)},\n\t\t{\".\", \"\", \".\", fmt.Errorf(`unexpected char: \".\"`)},\n\t\t{\"e\", \"\", \"e\", fmt.Errorf(`unexpected char: \"e\"`)},\n\n\t\t// Special values.\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"+inf\", \"+inf\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"Inf\", \"Inf\", \"\", nil},\n\t\t{\"+Inf\", \"+Inf\", \"\", nil},\n\t\t{\"-Inf\", \"-Inf\", \"\", nil},\n\t\t{\"in\", \"\", \"in\", fmt.Errorf(`unexpected char: \"i\"`)},\n\t\t{\"+i\", \"\", \"+i\", fmt.Errorf(`unexpected char: \"+\"`)},\n\t\t{\"-i\", \"\", \"-i\", fmt.Errorf(`unexpected char: \"-\"`)},\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"+nan\", \"+nan\", \"\", nil},\n\t\t{\"-nan\", \"-nan\", \"\", nil},\n\t\t{\"NaN\", \"NaN\", \"\", nil},\n\t\t{\"+NaN\", \"+NaN\", \"\", nil},\n\t\t{\"-NaN\", \"-NaN\", \"\", nil},\n\t\t{\"na\", \"\", \"na\", fmt.Errorf(`unexpected char: \"n\"`)},\n\t\t{\"+n\", \"\", \"+n\", fmt.Errorf(`unexpected char: \"+\"`)},\n\t\t{\"-n\", \"\", \"-n\", fmt.Errorf(`unexpected char: \"-\"`)},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tgotN, gotTail, gotErr := parseRawNumber(tt.input)\n\t\t\tif gotN != tt.wantN || gotTail != tt.wantTail || (gotErr != nil \u0026\u0026 tt.wantErr == nil) || (gotErr == nil \u0026\u0026 tt.wantErr != nil) || (gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error()) {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = (%q, %q, %v), want (%q, %q, %v)\", tt.input, gotN, gotTail, gotErr, tt.wantN, tt.wantTail, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","c139b8b840fd95c233cf58a5b0b8e307":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\tvar cases = []struct {\n\t\tin         string\n\t\twantResult string\n\t\twantTail   string\n\t\twantErr    error\n\t}{\n\t\t// Simple cases.\n\t\t{`\"foo\"bar`, \"foo\", \"bar\", nil},\n\t\t{`\"foo\"`, \"foo\", \"\", nil},\n\n\t\t// Escaped quotes.\n\t\t{`\"foo\\\"bar\"baz`, `foo\"bar`, \"baz\", nil},\n\t\t{`\"foo\\\\\"bar\"baz`, `foo\\\"bar`, \"baz\", nil},\n\t\t{`\"foo\\\\\\bar\"baz`, `foo\\\\bar`, \"baz\", nil},\n\t\t{`\"foo\\\\\\\\bar\"baz`, `foo\\\\bar`, \"baz\", nil},\n\n\t\t// Missing closing quote.\n\t\t{`\"foo`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo\\\"`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo\\\\\"`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t}\n\n\tfor i, tc := range cases {\n\t\tt.Run(fmt.Sprintf(\"case-%d\", i+1), func(t *testing.T) {\n\t\t\tresult, tail, err := parseRawString(tc.in)\n\t\t\tif result != tc.wantResult {\n\t\t\t\tt.Errorf(\"result mismatch.\\ngot:  %q\\nwant: %q\", result, tc.wantResult)\n\t\t\t}\n\t\t\tif tail != tc.wantTail {\n\t\t\t\tt.Errorf(\"tail mismatch.\\ngot:  %q\\nwant: %q\", tail, tc.wantTail)\n\t\t\t}\n\t\t\tif tc.wantErr != nil {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"error expected on input %q\", tc.in)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif got, want := err.Error(), tc.wantErr.Error(); got != want {\n\t\t\t\t\tt.Errorf(\"error mismatch.\\ngot:  %q\\nwant: %q\", got, want)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"unexpected error: %s\", err)\n\t\t\t}\n\t\t})\n\t}\n}","c2da5751cd2c5398838167b28b6919cf":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"raw string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"raw string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"12345\",\n\t\t\t},\n\t\t\twant: []byte(\"12345\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"string\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"12345\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"[\\\"string\\\",12345]\"),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"string\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"string\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"number\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"12345\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"{\\\"string\\\":\\\"string\\\",\\\"number\\\":12345}\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif string(got) != string(tt.want) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %v, want %v\", string(got), string(tt.want))\n\t\t\t}\n\t\t})\n\t}\n}","c32a429bd8165819c0e2efc39c6b825a":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey   string\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Basic cases\n\t\t{`\"foo\"bar`, \"foo\", \"bar\", nil},\n\t\t{`\"fo\\\"o\"bar`, `fo\"o`, \"bar\", nil},\n\t\t{`\"foo\"`, \"foo\", \"\", nil},\n\t\t{`\"\"bar`, \"\", \"bar\", nil},\n\n\t\t// Escaped quotes\n\t\t{`\"foo\\\\\"bar`, `foo\\`, `bar`, nil},\n\t\t{`\"foo\\\\\\\\\"bar`, `foo\\\\`, \"bar\", nil},\n\t\t{`\"foo\\\"bar`, `\"foo\\\"bar`, \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo\\\\bar`, `\"foo\\\\bar`, \"\", fmt.Errorf(`missing closing '\"'`)},\n\n\t\t// Empty strings\n\t\t{`\"\"`, \"\", \"\", nil},\n\t\t{`\"`, `\"`, \"\", fmt.Errorf(`missing closing '\"'`)},\n\n\t\t// Invalid inputs\n\t\t{`foo`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo`, `\"foo`, \"\", fmt.Errorf(`missing closing '\"'`)},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d:%s\", i, tt.input), func(t *testing.T) {\n\t\t\tkey, tail, err := parseRawString(tt.input)\n\t\t\tif key != tt.key || tail != tt.tail || (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = (%q, %q, %v), want (%q, %q, %v)\", tt.input, key, tail, err, tt.key, tt.tail, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}","c3af1e47e08002ea2a66ba4555dc8b2c":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetStringBytes(t *testing.T) {\n\tt.Run(\"simple object\", func(t *testing.T) {\n\t\ts := `{\"foo\":\"bar\", \"baz\": {\"qux\": \"quux\"}}`\n\t\tv, _ := Parse(s)\n\n\t\ttestCases := []struct {\n\t\t\tkeys []string\n\t\t\twant []byte\n\t\t}{\n\t\t\t{[]string{\"foo\"}, []byte(\"bar\")},\n\t\t\t{[]string{\"baz\", \"qux\"}, []byte(\"quux\")},\n\t\t\t{[]string{\"non\", \"existing\", \"key\"}, nil},\n\t\t}\n\n\t\tfor i, tc := range testCases {\n\t\t\tgot := v.GetStringBytes(tc.keys...)\n\t\t\tif string(got) != string(tc.want) {\n\t\t\t\tt.Errorf(\"Test case %d: GetStringBytes(%v) = %v, want %v\", i+1, tc.keys, got, tc.want)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"array access\", func(t *testing.T) {\n\t\ts := `{\"foo\": [{\"bar\": \"baz\"}, {\"qux\": \"quux\"}]}`\n\t\tv, _ := Parse(s)\n\n\t\ttestCases := []struct {\n\t\t\tkeys []string\n\t\t\twant []byte\n\t\t}{\n\t\t\t{[]string{\"foo\", \"0\", \"bar\"}, []byte(\"baz\")},\n\t\t\t{[]string{\"foo\", \"1\", \"qux\"}, []byte(\"quux\")},\n\t\t\t{[]string{\"foo\", \"2\", \"qux\"}, nil},\n\t\t}\n\n\t\tfor i, tc := range testCases {\n\t\t\tgot := v.GetStringBytes(tc.keys...)\n\t\t\tif string(got) != string(tc.want) {\n\t\t\t\tt.Errorf(\"Test case %d: GetStringBytes(%v) = %v, want %v\", i+1, tc.keys, got, tc.want)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"non-string value\", func(t *testing.T) {\n\t\ts := `{\"foo\": 123}`\n\t\tv, _ := Parse(s)\n\n\t\tgot := v.GetStringBytes(\"foo\")\n\t\tif got != nil {\n\t\t\tt.Errorf(\"GetStringBytes() on non-string value = %v, want nil\", got)\n\t\t}\n\t})\n}","c3ca300ea3ef3c2d58924dcfd3e7b4d8":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic escapes\n\t\t{`\\a`, `\\a`},\n\t\t{`\\b`, \"\\b\"},\n\t\t{`\\f`, \"\\f\"},\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\r`, \"\\r\"},\n\t\t{`\\t`, \"\\t\"},\n\t\t{`\\\\`, `\\`},\n\t\t{`\\/`, `/`},\n\t\t{`\\\"`, `\"`},\n\n\t\t// Unicode escapes\n\t\t{`\\u0000`, \"\\u0000\"},\n\t\t{`\\u0001`, \"\\u0001\"},\n\t\t{`\\u0010`, \"\\u0010\"},\n\t\t{`\\u001A`, \"\\u001A\"},\n\t\t{`\\u007F`, \"\\u007F\"},\n\t\t{`\\u0080`, \"\\u0080\"},\n\t\t{`\\u07FF`, \"\\u07FF\"},\n\t\t{`\\u0800`, \"\\u0800\"},\n\t\t{`\\uFFFF`, \"\\uFFFF\"},\n\t\t{`\\uD800\\uDC00`, \"\\U00010000\"},\n\t\t{`\\uD800\\uDFFF`, \"\\U000103FF\"},\n\t\t{`\\uDFFF\\uDFFF`, `\\uDFFF\\uDFFF`}, // invalid surrogate pair\n\n\t\t// Invalid escapes\n\t\t{`\\`, `\\`},\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u`, `\\u`},\n\t\t{`\\u0`, `\\u0`},\n\t\t{`\\u00`, `\\u00`},\n\t\t{`\\u000`, `\\u000`},\n\t\t{`\\u000g`, `\\u000g`},\n\t\t{`\\uD800`, `\\uD800`},\n\t\t{`\\uD800\\u`, `\\uD800\\u`},\n\t\t{`\\uD800\\uD`, `\\uD800\\uD`},\n\t\t{`\\uD800\\uDF`, `\\uD800\\uDF`},\n\t\t{`\\uD800\\uDFF`, `\\uD800\\uDFF`},\n\t\t{`\\uD800\\uDFFG`, `\\uD800\\uDFFG`},\n\n\t\t// Mixed content\n\t\t{`Hello\\tworld`, \"Hello\\tworld\"},\n\t\t{`\\u0041\\u0020\\u0073\\u0074\\u0072\\u0069\\u006e\\u0067`, \"A string\"},\n\t\t{`Escaped\\nnewline`, \"Escaped\\nnewline\"},\n\t\t{`This is a \\\\ backslash`, \"This is a \\\\ backslash\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.input, func(t *testing.T) {\n\t\t\tactual := unescapeStringBestEffort(test.input)\n\t\t\tif actual != test.expected {\n\t\t\t\tt.Errorf(\"For input %q, expected %q but got %q\", test.input, test.expected, actual)\n\t\t\t}\n\t\t})\n\t}\n}","c3d3743fdc801655ec63135d7bb59672":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc Test_cache_getValue(t *testing.T) {\n\tt.Run(\"grow cache\", func(t *testing.T) {\n\t\tc := \u0026cache{}\n\t\tif got := c.getValue(); got == nil {\n\t\t\tt.Errorf(\"cache.getValue() = %v, want not nil\", got)\n\t\t}\n\t})\n\tt.Run(\"reuse cache\", func(t *testing.T) {\n\t\tc := \u0026cache{\n\t\t\tvs: make([]Value, 10),\n\t\t}\n\t\twant := c.getValue()\n\t\tgot := c.getValue()\n\t\tif got != want {\n\t\t\tt.Errorf(\"cache.getValue() = %p, want %p\", got, want)\n\t\t}\n\t})\n}","c3f9de78bc4ab5f2c224c68fe6a512d2":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetObject(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tjson  string\n\t\tkeys  []string\n\t\twant  *Object\n\t\twant1 bool\n\t}{\n\t\t{\n\t\t\tname:  \"simple\",\n\t\t\tjson:  `{\"foo\": {\"bar\": 123}}`,\n\t\t\tkeys:  []string{\"foo\"},\n\t\t\twant:  \u0026Object{kvs: []kv{{k: \"bar\", v: \u0026Value{t: TypeNumber, s: \"123\"}}}},\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array_index\",\n\t\t\tjson:  `{\"foo\": [{\"bar\": 123}]}`,\n\t\t\tkeys:  []string{\"foo\", \"0\"},\n\t\t\twant:  \u0026Object{kvs: []kv{{k: \"bar\", v: \u0026Value{t: TypeNumber, s: \"123\"}}}},\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"non_existing_key\",\n\t\t\tjson:  `{\"foo\": {\"bar\": 123}}`,\n\t\t\tkeys:  []string{\"baz\"},\n\t\t\twant:  nil,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"invalid_value_type\",\n\t\t\tjson:  `{\"foo\": 123}`,\n\t\t\tkeys:  []string{\"foo\"},\n\t\t\twant:  nil,\n\t\t\twant1: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv, err := Parse(tt.json)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"Parse() error = %v\", err)\n\t\t\t}\n\t\t\tgot, got1 := v.GetObject(tt.keys...)\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"Value.GetObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t\tif (got == nil \u0026\u0026 tt.want != nil) || (got != nil \u0026\u0026 tt.want == nil) {\n\t\t\t\tt.Errorf(\"Value.GetObject() got = %v, want %v\", got, tt.want)\n\t\t\t} else if got != nil \u0026\u0026 tt.want != nil {\n\t\t\t\tif len(got.kvs) != len(tt.want.kvs) {\n\t\t\t\t\tt.Errorf(\"Value.GetObject() got = %v, want %v\", got, tt.want)\n\t\t\t\t} else {\n\t\t\t\t\tfor i := range got.kvs {\n\t\t\t\t\t\tif got.kvs[i].k != tt.want.kvs[i].k {\n\t\t\t\t\t\t\tt.Errorf(\"Value.GetObject() got = %v, want %v\", got, tt.want)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif got.kvs[i].v.Type() != tt.want.kvs[i].v.Type() {\n\t\t\t\t\t\t\tt.Errorf(\"Value.GetObject() got = %v, want %v\", got, tt.want)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif got.kvs[i].v.String() != tt.want.kvs[i].v.String() {\n\t\t\t\t\t\t\tt.Errorf(\"Value.GetObject() got = %v, want %v\", got, tt.want)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","c41fada46f28a36a945f14b1dabf43f8":"package fastjson\n\nimport \"testing\"\n\nfunc Test_skipWSSlow(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with leading whitespace\",\n\t\t\targs: args{\n\t\t\t\ts: \"  foo\",\n\t\t\t},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with trailing whitespace\",\n\t\t\targs: args{\n\t\t\t\ts: \"foo  \",\n\t\t\t},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with leading and trailing whitespace\",\n\t\t\targs: args{\n\t\t\t\ts: \"  foo  \",\n\t\t\t},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with no whitespace\",\n\t\t\targs: args{\n\t\t\t\ts: \"foo\",\n\t\t\t},\n\t\t\twant: \"\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","c4ca0fa3d11b72162681fabfbab58d61":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCache_getValue(t *testing.T) {\n\tt.Run(\"grow\", func(t *testing.T) {\n\t\tc := \u0026cache{}\n\t\tif got := c.getValue(); got == nil {\n\t\t\tt.Errorf(\"getValue() = nil, want non-nil\")\n\t\t}\n\t\tif got := c.getValue(); got == nil {\n\t\t\tt.Errorf(\"getValue() = nil, want non-nil\")\n\t\t}\n\t})\n\n\tt.Run(\"reuse\", func(t *testing.T) {\n\t\tc := \u0026cache{\n\t\t\tvs: make([]Value, 10),\n\t\t}\n\t\twant := c.getValue()\n\t\tgot := c.getValue()\n\t\tif got != want {\n\t\t\tt.Errorf(\"getValue() = %p, want %p\", got, want)\n\t\t}\n\t})\n}","c5586c4ceae5d3f167bcc3ee23c33dbe":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantNum  string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Valid numbers\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"123.456\", \"123.456\", \"\", nil},\n\t\t{\"1.2e3\", \"1.2e3\", \"\", nil},\n\t\t{\"1.2E-3\", \"1.2E-3\", \"\", nil},\n\t\t{\"+123\", \"+123\", \"\", nil},\n\n\t\t// Valid numbers with trailing characters\n\t\t{\"123a\", \"123\", \"a\", nil},\n\t\t{\"-123 \", \"-123\", \" \", nil},\n\t\t{\"123.456,\", \"123.456\", \",\", nil},\n\n\t\t// Invalid numbers\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t\t{\"a123\", \"\", \"a123\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\"+a123\", \"\", \"+a123\", fmt.Errorf(\"unexpected char: %q\", \"+a\")},\n\t\t{\"-a123\", \"\", \"-a123\", fmt.Errorf(\"unexpected char: %q\", \"-a\")},\n\n\t\t// Special cases: inf and nan\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"+inf\", \"+inf\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"InF\", \"InF\", \"\", nil}, // Case-insensitive\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"+nan\", \"+nan\", \"\", nil},\n\t\t{\"-nan\", \"-nan\", \"\", nil},\n\t\t{\"nAn\", \"nAn\", \"\", nil}, // Case-insensitive\n\n\t\t// Special cases: inf and nan with trailing characters\n\t\t{\"inf,\", \"inf\", \",\", nil},\n\t\t{\"+Inf}\", \"+Inf\", \"}\", nil},\n\t\t{\"-NAN \", \"-NAN\", \" \", nil},\n\n\t\t// Special cases: invalid inf and nan\n\t\t{\"in\", \"\", \"in\", fmt.Errorf(\"unexpected char: %q\", \"i\")},\n\t\t{\"na\", \"\", \"na\", fmt.Errorf(\"unexpected char: %q\", \"n\")},\n\t\t{\"+i\", \"\", \"+i\", fmt.Errorf(\"unexpected char: %q\", \"+i\")},\n\t\t{\"-n\", \"\", \"-n\", fmt.Errorf(\"unexpected char: %q\", \"-n\")},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test case %d: %s\", i, tt.input), func(t *testing.T) {\n\t\t\tgotNum, gotTail, gotErr := parseRawNumber(tt.input)\n\t\t\tif gotNum != tt.wantNum {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got number = %q, want %q\", tt.input, gotNum, tt.wantNum)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got tail = %q, want %q\", tt.input, gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif gotErr == nil \u0026\u0026 tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got no error, want error %v\", tt.input, tt.wantErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr == nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got error = %v, want no error\", tt.input, gotErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got error = %v, want error %v\", tt.input, gotErr, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","c55ae409893aa760b6837960ae6d3139":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic escapes\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\t`, \"\\t\"},\n\t\t{`\\\\`, \"\\\\\"},\n\t\t{`\\\"`, \"\\\"\"},\n\t\t{`\\/`, \"/\"},\n\n\t\t// Unicode escapes\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A0`, \"\\u00A0\"},\n\t\t{`\\uFFFF`, \"\\uFFFF\"},\n\n\t\t// Surrogate pairs\n\t\t{`\\uD83D\\uDE01`, \"\\U0001F601\"},\n\n\t\t// Invalid escapes\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\uD800`, `\\uD800`},\n\t\t{`\\uD800\\u`, `\\uD800\\u`},\n\n\t\t// Mixed strings\n\t\t{`Hello\\tworld\\n`, \"Hello\\tworld\\n\"},\n\t\t{`\\u0041\\u0020string\\twith\\tsome\\tescapes`, \"A string\\twith\\tsome\\tescapes\"},\n\n\t\t// Empty string\n\t\t{``, \"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}\n","c5cb7d728cb8fdc34f85c406b961cc9e":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic escapes\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\t`, \"\\t\"},\n\t\t{`\\\\`, \"\\\\\"},\n\t\t{`\\\"`, \"\\\"\"},\n\t\t{`\\/`, \"/\"},\n\n\t\t// Unicode escapes\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A0`, \"\\u00A0\"},\n\t\t{`\\u00e9`, \"\\u00e9\"},\n\t\t{`\\u20AC`, \"\\u20AC\"},\n\n\t\t// Surrogate pairs\n\t\t{`\\uD83D\\uDE02`, \"\\U0001F602\"},\n\n\t\t// Invalid escapes\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\uD800`, `\\uD800`},\n\t\t{`\\uD800\\u`, `\\uD800\\u`},\n\n\t\t// Mixed strings\n\t\t{`Hello\\tworld\\n`, \"Hello\\tworld\\n\"},\n\t\t{`This is a \\\"test\\\" string.`, `This is a \"test\" string.`},\n\t\t{`C:\\\\path\\\\to\\\\file.txt`, `C:\\path\\to\\file.txt`},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}","c5cdd5f26f85c8b4f71fd4ad327b5a2e":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_reset(t *testing.T) {\n\to := Object{\n\t\tkvs: []kv{\n\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t},\n\t\tkeysUnescaped: true,\n\t}\n\n\to.reset()\n\n\tif len(o.kvs) != 0 {\n\t\tt.Errorf(\"Expected kvs to be empty after reset, got %v\", o.kvs)\n\t}\n\n\tif o.keysUnescaped != false {\n\t\tt.Errorf(\"Expected keysUnescaped to be false after reset, got %v\", o.keysUnescaped)\n\t}\n}","c6faba2bbfc994b9485296bddc91361b":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ts     string\n\t\terr   error\n\t}{\n\t\t// Empty object\n\t\t{\n\t\t\tinput: \"{}\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Simple object\n\t\t{\n\t\t\tinput: `{\"key1\": \"value1\", \"key2\": 123}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Nested object\n\t\t{\n\t\t\tinput: `{\"key1\": {\"key2\": \"value2\"}, \"key3\": [1,2,3]}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Invalid object: missing closing brace\n\t\t{\n\t\t\tinput: `{\"key1\": \"value1\"`,\n\t\t\twant:  nil,\n\t\t\ts:     `{\"key1\": \"value1\"`,\n\t\t\terr:   fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t\t// Invalid object: missing colon\n\t\t{\n\t\t\tinput: `{\"key1\" \"value1\"}`,\n\t\t\twant:  nil,\n\t\t\ts:     `\"value1\"}`,\n\t\t\terr:   fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t\t// Invalid object: missing comma\n\t\t{\n\t\t\tinput: `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twant:  nil,\n\t\t\ts:     `\"key2\": \"value2\"}`,\n\t\t\terr:   fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseObject(tt.input, c, 0)\n\t\t\tif fmt.Sprintf(\"%v\", err) != fmt.Sprintf(\"%v\", tt.err) {\n\t\t\t\tt.Errorf(\"parseObject(%s) error = %v, wantErr %v\", tt.input, err, tt.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif s != tt.s {\n\t\t\t\tt.Errorf(\"parseObject(%s) s = %s, want %s\", tt.input, s, tt.s)\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject(%s) = %v, want %v\", tt.input, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}","c764ce35ca14ae6a72207278122d0d5b":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"raw string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"raw string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"string\",\n\t\t\t},\n\t\t\twant: []byte(`\"string\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"12345\",\n\t\t\t},\n\t\t\twant: []byte(\"12345\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"[1,\\\"2\\\"]\"),\n\t\t},\n\t\t// TODO: add test case for object\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo([]byte{})\n\t\t\tif string(got) != string(tt.want) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","c7df6ab3486acf816f4a9b764f6a03d8":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey   string\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Basic cases\n\t\t{`\"foo\"bar`, \"foo\", \"bar\", nil},\n\t\t{`\"fo\\\"o\"bar`, `fo\"o`, \"bar\", nil},\n\t\t{`\"foo\"`, \"foo\", \"\", nil},\n\t\t{`\"\"bar`, \"\", \"bar\", nil},\n\n\t\t// Escaped quotes\n\t\t{`\"foo\\\\\"bar\"baz`, `foo\\bar`, \"baz\", nil},\n\t\t{`\"foo\\\\\\\\\"bar\"baz`, `foo\\\\`, `bar\"baz`, nil},\n\t\t{`\"foo\\\\\\\"bar\"baz`, `foo\\\"bar`, \"baz\", nil},\n\n\t\t// Errors\n\t\t{`\"foo`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`foo\"`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo\"bar\"`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tkey, tail, err := parseRawString(tt.input)\n\t\t\tif key != tt.key || tail != tt.tail || (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = (%q, %q, %v), want (%q, %q, %v)\", tt.input, key, tail, err, tt.key, tt.tail, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}","c8009aa53c1b79da028713d43677a10e":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantValue *Value\n\t\twantTail string\n\t\twantErr   error\n\t}{\n\t\t{\n\t\t\tname:     \"empty array\",\n\t\t\tinput:    \"[]\",\n\t\t\twantValue: \u0026Value{t: TypeArray, a: []*Value{}},\n\t\t\twantTail: \"\",\n\t\t\twantErr:   nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"simple array\",\n\t\t\tinput:    \"[1,2,3]\",\n\t\t\twantValue: \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}} },\n\t\t\twantTail: \"\",\n\t\t\twantErr:   nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with spaces\",\n\t\t\tinput:    \" [ 1 , 2 , 3 ] \",\n\t\t\twantValue: \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}} },\n\t\t\twantTail: \" \",\n\t\t\twantErr:   nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with different types\",\n\t\t\tinput:    \"[1,\\\"hello\\\",true]\",\n\t\t\twantValue: \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeString, s: \"hello\"}, {t: TypeTrue}}},\n\t\t\twantTail: \"\",\n\t\t\twantErr:   nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"nested array\",\n\t\t\tinput:    \"[[1,2],[3,4]]\",\n\t\t\twantValue: \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}}},\n\t\t\t\t{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"3\"}, {t: TypeNumber, s: \"4\"}}},\n\t\t\t}},\n\t\t\twantTail: \"\",\n\t\t\twantErr:   nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing closing bracket\",\n\t\t\tinput:    \"[1,2,3\",\n\t\t\twantValue: nil,\n\t\t\twantTail: \"\",\n\t\t\twantErr:   fmt.Errorf(\"missing ']'\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"missing comma\",\n\t\t\tinput:    \"[1 2]\",\n\t\t\twantValue: nil,\n\t\t\twantTail: \"\",\n\t\t\twantErr:   fmt.Errorf(\"missing ',' after array value\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid value\",\n\t\t\tinput:    \"[1,invalid,3]\",\n\t\t\twantValue: nil,\n\t\t\twantTail: \"\",\n\t\t\twantErr:   fmt.Errorf(\"cannot parse array value: invalid character 'i' looking for beginning of value\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgotValue, gotTail, gotErr := parseArray(tt.input, c, 0)\n\n\t\t\tif fmt.Sprintf(\"%v\", gotErr) != fmt.Sprintf(\"%v\", tt.wantErr) {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", gotErr, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseArray() gotTail = %v, want %v\", gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif !equalValues(gotValue, tt.wantValue) {\n\t\t\t\tt.Errorf(\"parseArray() gotValue = %v, want %v\", gotValue, tt.wantValue)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.s != v2.s {\n\t\treturn false\n\t}\n\tif len(v1.a) != len(v2.a) {\n\t\treturn false\n\t}\n\tfor i := range v1.a {\n\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","c80f450b5ed4b0fa2ce024b7f69bb8fc":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantJSON string\n\t\twantErr  error\n\t}{\n\t\t{\n\t\t\tname:     \"empty object\",\n\t\t\tinput:    \"{}\",\n\t\t\twantJSON: `{}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"simple object\",\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\twantJSON: `{\"key\": \"value\"}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"nested object\",\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": {\"key3\": \"value3\"}}`,\n\t\t\twantJSON: `{\"key1\": \"value1\", \"key2\": {\"key3\": \"value3\"}}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"object with array\",\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": [1, 2, 3]}`,\n\t\t\twantJSON: `{\"key1\": \"value1\", \"key2\": [1, 2, 3]}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"object with escaped characters\",\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value with \\\"escaped\\\" characters\"}`,\n\t\t\twantJSON: `{\"key1\": \"value1\", \"key2\": \"value with \\\"escaped\\\" characters\"}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid object: missing closing brace\",\n\t\t\tinput:    `{\"key\": \"value\"`,\n\t\t\twantErr: fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid object: missing colon\",\n\t\t\tinput:    `{\"key\" \"value\"}`,\n\t\t\twantErr: fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid object: missing comma\",\n\t\t\tinput:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, _, err := parseObject(tt.input, c, 0)\n\n\t\t\tif tt.wantErr != nil {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"parseObject() error = nil, wantErr %v\", tt.wantErr)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif err.Error() != tt.wantErr.Error() {\n\t\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr nil\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tgotJSON := got.String()\n\t\t\tif gotJSON != tt.wantJSON {\n\t\t\t\tt.Errorf(\"parseObject() got = %s, want %s\", gotJSON, tt.wantJSON)\n\t\t\t}\n\t\t})\n\t}\n}\n","c862c57bfd6664eb3772ddfd9cc5ec8c":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic cases\n\t\t{\"\", \"\"},\n\t\t{\"hello\", \"hello\"},\n\t\t{\"hello\\\\world\", \"hello\\\\world\"},\n\n\t\t// Escaped characters\n\t\t{\"\\\\\\\"\", \"\\\"\"},\n\t\t{\"\\\\\\\\\", \"\\\\\"},\n\t\t{\"\\\\/\", \"/\"},\n\t\t{\"\\\\b\", \"\\b\"},\n\t\t{\"\\\\f\", \"\\f\"},\n\t\t{\"\\\\n\", \"\\n\"},\n\t\t{\"\\\\r\", \"\\r\"},\n\t\t{\"\\\\t\", \"\\t\"},\n\n\t\t// Unicode escape sequences\n\t\t{\"\\\\u0022\", \"\\\"\"},\n\t\t{\"\\\\u005c\", \"\\\\\"},\n\t\t{\"\\\\u002f\", \"/\"},\n\t\t{\"\\\\u0008\", \"\\b\"},\n\t\t{\"\\\\u000c\", \"\\f\"},\n\t\t{\"\\\\u000a\", \"\\n\"},\n\t\t{\"\\\\u000d\", \"\\r\"},\n\t\t{\"\\\\u0009\", \"\\t\"},\n\n\t\t// Invalid escape sequences\n\t\t{\"\\\\x\", \"\\\\x\"},\n\t\t{\"\\\\u002\", \"\\\\u002\"},\n\t\t{\"\\\\u002x\", \"\\\\u002x\"},\n\t\t{\"\\\\u1234\\\\u567\", \"\\\\u1234\\\\u567\"},\n\n\t\t// Surrogate pairs\n\t\t{\"\\\\uD83D\\\\uDE01\", \"\\U0001F601\"},\n\t\t{\"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\", \"\\U0001F601\\U0001F602\"},\n\n\t\t// Mixed cases\n\t\t{\"hello\\\\\\\"world\\\\\\\"\", \"hello\\\"world\\\"\"},\n\t\t{\"\\\\u0022hello\\\\u0022\", \"\\\"hello\\\"\"},\n\t\t{\"hello\\\\uD83D\\\\uDE01world\", \"hello\\U0001F601world\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}","c89109383f77829fd96d34eb2ecc83ef":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"raw string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"raw string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"12345\",\n\t\t\t},\n\t\t\twant: []byte(\"12345\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"string\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"12345\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"[\\\"string\\\",12345]\"),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"string\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"string\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"number\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"12345\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"{\\\"string\\\":\\\"string\\\",\\\"number\\\":12345}\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif string(got) != string(tt.want) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %v, want %v\", string(got), string(tt.want))\n\t\t\t}\n\t\t})\n\t}\n}","c9f4acd3cb04b2ed994e2e7099cc5b41":"package fastjson\n\nimport \"testing\"\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tinput Type\n\t\twant  string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\tfor i, tt := range tests {\n\t\tgot := tt.input.String()\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"test[%d]: String() = %q, want %q\", i, got, tt.want)\n\t\t}\n\t}\n}","cac4f04680835dd843013cfc1b730880":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEscapeString(t *testing.T) {\n\ttests := []struct {\n\t\tin  string\n\t\tout string\n\t}{\n\t\t{\"\", `\"\"`},\n\t\t{\"hello\", `\"hello\"`},\n\t\t{\"\\n\", `\"\\n\"`},\n\t\t{\"\\r\", `\"\\r\"`},\n\t\t{\"\\t\", `\"\\t\"`},\n\t\t{\"\\\"\", `\"\\\"\"`},\n\t\t{\"\\\\\", `\"\\\\\"`},\n\t\t{\"\\u0000\", `\"\\u0000\"`},\n\t\t{\"\\u001f\", `\"\\u001f\"`},\n\t\t{\"\\u007f\", `\"\\u007f\"`},\n\t\t{\"\\u0080\", `\"\\u0080\"`},\n\t\t{\"\\uffff\", `\"\\uffff\"`},\n\t\t{\"‰Ω†Â•Ω\", `\"‰Ω†Â•Ω\"`},\n\t\t{\"\\xed\\xa0\\x80\", `\"\\ufffd\"`}, // invalid UTF-8\n\t\t{\"\\xed\\xbf\\xbf\", `\"\\ufffd\"`}, // invalid UTF-8\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.in, func(t *testing.T) {\n\t\t\tout := escapeString(nil, tt.in)\n\t\t\tif string(out) != tt.out {\n\t\t\t\tt.Errorf(\"escapeString(%q) = %q, want %q\", tt.in, out, tt.out)\n\t\t\t}\n\t\t})\n\t}\n}","cb85710523cfb04cdcdf04451f7449d2":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey string\n\t\tvalue string\n\t\terr error\n\t}{\n\t\t// Test cases here\n\t\t{`\"key\":\"value\"`, `\"key\"`, `value`, nil},\n\t\t{`\"key\": \"value\"`, `\"key\"`, ` value`, nil},\n\t\t{`\"key\" :\"value\"`, `\"key\"`, `value`, nil},\n\t\t{`\"key\" : \"value\"`, `\"key\"`, ` value`, nil},\n\t\t{`\"escaped\\\"key\":\"value\"`, `\"escaped\\\"key\"`, `value`, nil},\n\t\t{`\"\\\\\" : \"value\"`, `\"\\\\\"`, ` value`, nil},\n\t\t{`\"key\\\\\"\" : \"value\"`, `\"key\\\\\"\"`, ` value`, nil},\n\t\t{`\"key\"`, ``, ``, fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"key`, ``, ``, fmt.Errorf(`missing closing '\"'`)},\n\t}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test_%d\", i), func(t *testing.T) {\n\t\t\tkey, value, err := parseRawString(tt.input)\n\t\t\tif key != tt.key || value != tt.value || (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) {\n\t\t\t\tt.Errorf(\"input: %s, expect (%s, %s, %v), got (%s, %s, %v)\", tt.input, tt.key, tt.value, tt.err, key, value, err)\n\t\t\t}\n\t\t})\n\t}\n}","cb8b337a5da945f53db16b6db1e7cef5":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey   string\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t{\"\\\"key\\\":123\", \"key\", \":123\", nil},\n\t\t{\"\\\"key with spaces\\\":123\", \"key with spaces\", \":123\", nil},\n\t\t{\"\\\"key\\\\twith\\\\tescapes\\\":123\", \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{\"invalid\", \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tkey, tail, err := parseRawKey(tt.input)\n\t\t\tif key != tt.key || tail != tt.tail || !errorEqual(err, tt.err) {\n\t\t\t\tt.Errorf(\"parseRawKey(%q) = (%q, %q, %v), want (%q, %q, %v)\", tt.input, key, tail, err, tt.key, tt.tail, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc errorEqual(e1, e2 error) bool {\n\tif e1 == nil \u0026\u0026 e2 == nil {\n\t\treturn true\n\t}\n\tif e1 == nil || e2 == nil {\n\t\treturn false\n\t}\n\treturn e1.Error() == e2.Error()\n}","cbef8bb22fee92b10afa87f54f0a53b0":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Empty string\n\t\t{\"\", nil, \"\", fmt.Errorf(\"cannot parse empty string\")},\n\n\t\t// Object\n\t\t{\"{ \\\"key\\\": \\\"value\\\" }\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{t: typeRawString, s: \"value\"}}}}, t: TypeObject}, \"\", nil},\n\n\t\t// Array\n\t\t{\"[1, 2, 3]\", \u0026Value{a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}, t: TypeArray}, \"\", nil},\n\n\t\t// String\n\t\t{`\"hello\"`, \u0026Value{t: typeRawString, s: \"hello\"}, \"\", nil},\n\n\t\t// True\n\t\t{\"true\", valueTrue, \"\", nil},\n\n\t\t// False\n\t\t{\"false\", valueFalse, \"\", nil},\n\n\t\t// Null\n\t\t{\"null\", valueNull, \"\", nil},\n\n\t\t// Number\n\t\t{\"12345\", \u0026Value{t: TypeNumber, s: \"12345\"}, \"\", nil},\n\n\t\t// Invalid JSON\n\t\t{\"{key: value}\", nil, \"\", fmt.Errorf(\"cannot parse object: invalid character 'k' looking for beginning of object key string\")},\n\n\t\t// Too deep nesting\n\t\t{`{\"a\":{\"b\":{\"c\":{\"d\":{\"e\":{\"f\":{\"g\":{\"h\":{\"i\":{\"j\":{\"k\":{\"l\":{\"m\":{\"n\":{\"o\":{\"p\":{\"q\":{\"r\":{\"s\":{\"t\":{\"u\":{\"v\":{\"w\":{\"x\":{\"y\":{\"z\":{}}}}}}}}}}}}}}}}}}}}}}}}}}}}}`, nil, \"\", fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth)},\n\t}\n\n\tc := \u0026cache{}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test #%d\", i), func(t *testing.T) {\n\t\t\tgot, tail, err := parseValue(tt.input, c, 0)\n\t\t\tif (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, wantErr %v\", tt.input, err, tt.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"parseValue(%q) tail = %q, wantTail %q\", tt.input, tail, tt.tail)\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", tt.input, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\treturn v1.s == v2.s\n\t}\n}","cc2ca3ffb95a189c0927b89f2ea28794":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput  string\n\t\texpect string\n\t\tremain string\n\t\terr    error\n\t}{\n\t\t// Basic cases.\n\t\t{`\"foo\"bar`, `foo`, `bar`, nil},\n\t\t{`\"fo\\o\"bar`, `fo\\o`, `bar`, nil},\n\t\t{`\"foo\"`, `foo`, ``, nil},\n\t\t{`\"foo`, ``, ``, fmt.Errorf(`missing closing '\"'`)},\n\n\t\t// Escaped quotes.\n\t\t{`\"fo\\\"o\"bar`, `fo\"o`, `bar`, nil},\n\t\t{`\"fo\\\\\"o\"bar`, `fo\\\\\"o`, `bar`, nil},\n\t\t{`\"fo\\\\\\\"\"o\"bar`, `fo\\\"o`, `bar`, nil},\n\t\t{`\"fo\\\\\\\\\"o\"bar`, `fo\\\\\"o`, `bar`, nil},\n\n\t\t// Unescaped quotes.\n\t\t{`\"fo\"o\"bar`, `fo`, `o\"bar`, nil},\n\t\t{`\"fo\\\"o\"bar`, `fo\\\"o`, `bar`, nil},\n\n\t\t// Empty strings.\n\t\t{`\"\"bar`, ``, `bar`, nil},\n\t\t{`\"\"`, ``, ``, nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tresult, remain, err := parseRawString(tt.input)\n\t\t\tif result != tt.expect || remain != tt.remain || (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) {\n\t\t\t\tt.Errorf(\"Input: %s\\nExpect: %s, %s, %v\\nGot: %s, %s, %v\",\n\t\t\t\t\ttt.input, tt.expect, tt.remain, tt.err, result, remain, err)\n\t\t\t}\n\t\t})\n\t}\n}","cc89c1bed9800d39da5e4dc1a0fd47ba":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantN    string\n\t\twantTail string\n\t\twantErr  string\n\t}{\n\t\t{\n\t\t\tinput:    \"123\",\n\t\t\twantN:    \"123\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  \"\",\n\t\t},\n\t\t{\n\t\t\tinput:    \"123.456\",\n\t\t\twantN:    \"123.456\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  \"\",\n\t\t},\n\t\t{\n\t\t\tinput:    \"-123\",\n\t\t\twantN:    \"-123\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  \"\",\n\t\t},\n\t\t{\n\t\t\tinput:    \"123e+456\",\n\t\t\twantN:    \"123e+456\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  \"\",\n\t\t},\n\t\t{\n\t\t\tinput:    \"123abc\",\n\t\t\twantN:    \"123\",\n\t\t\twantTail: \"abc\",\n\t\t\twantErr:  \"\",\n\t\t},\n\t\t{\n\t\t\tinput:    \"inf\",\n\t\t\twantN:    \"inf\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  \"\",\n\t\t},\n\t\t{\n\t\t\tinput:    \"infinity\",\n\t\t\twantN:    \"inf\",\n\t\t\twantTail: \"inity\",\n\t\t\twantErr:  \"\",\n\t\t},\n\t\t{\n\t\t\tinput:    \"InFiNiTy\",\n\t\t\twantN:    \"InFiNiTy\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  \"\",\n\t\t},\n\t\t{\n\t\t\tinput:    \"nAn\",\n\t\t\twantN:    \"nAn\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  \"\",\n\t\t},\n\t\t{\n\t\t\tinput:    \"nanxxx\",\n\t\t\twantN:    \"nan\",\n\t\t\twantTail: \"xxx\",\n\t\t\twantErr:  \"\",\n\t\t},\n\t\t{\n\t\t\tinput:    \"123x\",\n\t\t\twantN:    \"123\",\n\t\t\twantTail: \"x\",\n\t\t\twantErr:  \"\",\n\t\t},\n\t\t{\n\t\t\tinput:    \"-abc\",\n\t\t\twantN:    \"\",\n\t\t\twantTail: \"-abc\",\n\t\t\twantErr:  \"unexpected char: \\\"-\\\"\",\n\t\t},\n\t\t{\n\t\t\tinput:    \"+abc\",\n\t\t\twantN:    \"\",\n\t\t\twantTail: \"+abc\",\n\t\t\twantErr:  \"unexpected char: \\\"+\\\"\",\n\t\t},\n\t}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tgotN, gotTail, gotErr := parseRawNumber(tt.input)\n\t\t\tif gotN != tt.wantN {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) gotN = %q, want %q\", tt.input, gotN, tt.wantN)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) gotTail = %q, want %q\", tt.input, gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif (gotErr == nil \u0026\u0026 tt.wantErr != \"\") || (gotErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr) {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) gotErr = %q, want %q\", tt.input, gotErr, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","cd096a26bec96244813fa324ca0118d3":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Empty string\n\t\t{\"\", nil, \"\", fmt.Errorf(\"cannot parse empty string\")},\n\t\t// Invalid JSON\n\t\t{\"{invalid}\", nil, \"\", fmt.Errorf(\"cannot parse object: invalid character 'i' looking for beginning of value\")},\n\t\t// Simple object\n\t\t{`{\"key\": \"value\"}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{t: typeRawString, s: \"value\"}}}}}}, \"\", nil},\n\t\t// Simple array\n\t\t{`[1, \"two\", true]`, \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: typeRawString, s: \"two\"}, {t: TypeTrue}}}, \"\", nil},\n\t\t// String with escapes\n\t\t{`\"hello\\nworld\"`, \u0026Value{t: typeRawString, s: \"hello\\nworld\"}, \"\", nil},\n\t\t// True boolean\n\t\t{\"true\", valueTrue, \"\", nil},\n\t\t// False boolean\n\t\t{\"false\", valueFalse, \"\", nil},\n\t\t// Null value\n\t\t{\"null\", valueNull, \"\", nil},\n\t\t// Number\n\t\t{\"12345\", \u0026Value{t: TypeNumber, s: \"12345\"}, \"\", nil},\n\t\t// String with tail\n\t\t{`\"hello\" world`, \u0026Value{t: typeRawString, s: \"hello\"}, \" world\", nil},\n\t\t// NaN value\n\t\t{\"NaN\", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"\", nil},\n\t}\n\n\tc := \u0026cache{}\n\tfor i, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tgot, tail, err := parseValue(test.input, c, 0)\n\n\t\t\tif test.err != nil {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"Expected error, got nil\")\n\t\t\t\t} else if err.Error() != test.err.Error() {\n\t\t\t\t\tt.Errorf(\"Expected error %q, got %q\", test.err, err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif tail != test.tail {\n\t\t\t\tt.Errorf(\"Expected tail %q, got %q\", test.tail, tail)\n\t\t\t}\n\n\t\t\tif !equalValues(got, test.want) {\n\t\t\t\tt.Errorf(\"Test %d failed: input %q, expected %+v, got %+v\", i, test.input, test.want, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.t == typeRawString {\n\t\treturn v1.s == v2.s\n\t}\n\tif v1.t == TypeNumber {\n\t\treturn v1.s == v2.s\n\t}\n\tif v1.t == TypeObject {\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\tif v1.t == TypeArray {\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\treturn false\n}","cd09872ff98ed51df9fc60253203ac1c":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey string\n\t\ttail string\n\t\terr error\n\t}{\n\t\t// Basic cases\n\t\t{`\"foo\"bar`, \"foo\", \"bar\", nil},\n\t\t{`\"foo\" bar`, \"foo\", \" bar\", nil},\n\t\t{`\"foo\"  bar`, \"foo\", \"  bar\", nil},\n\t\t{`\"foo\"`, \"foo\", \"\", nil},\n\n\t\t// Escaped quotes\n\t\t{`\"fo\\o\"bar`, \"fo\\o\", \"bar\", nil},\n\t\t{`\"fo\\\\o\"bar`, \"fo\\\\o\", \"bar\", nil},\n\t\t{`\"fo\\\"o\"bar`, \"fo\\\"o\", \"bar\", nil},\n\t\t{`\"fo\\ooo\"bar`, `fo\\ooo`, \"bar\", nil},\n\n\t\t// Missing closing quote\n\t\t{`\"foo`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"fo\\o`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"fo\\\\o`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\n\t\t// Empty strings\n\t\t{`\"\"bar`, \"\", \"bar\", nil},\n\t\t{`\"\" bar`, \"\", \" bar\", nil},\n\t\t{`\"\"`, \"\", \"\", nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d:%s\", i, tt.input), func(t *testing.T) {\n\t\t\tkey, tail, err := parseRawString(tt.input)\n\t\t\tif key != tt.key || tail != tt.tail || (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = (%q, %q, %v), want (%q, %q, %v)\", tt.input, key, tail, err, tt.key, tt.tail, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}\n","cd6cb6e8218d1f8c8539694471a3eebe":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\tvar tests = []struct {\n\t\tin  string\n\t\tout string\n\t}{\n\t\t{`\"foo\"`, `foo`},\n\t\t{`\"fo\\no\"`, `fo\\no`},\n\t\t{`\"foo bar\"`, `foo bar`},\n\t\t{`\"foo\\\"bar\"`, `foo\"bar`},\n\t\t{`\"foo\\\\bar\"`, `foo\\bar`},\n\t\t{`\"foo\\tbar\"`, `foo\tbar`},\n\t\t{`\"foo\\rbar\"`, `foo\\rbar`},\n\t\t{`\"foo\\nbar\"`, `foo\\nbar`},\n\t\t{`\"foo\\fbar\"`, `foo\\fbar`},\n\t\t{`\"foo\\bbar\"`, `foo\\bbar`},\n\t\t{`\"\\u0000\"`, \"\\u0000\"},\n\t\t{`\"\\u20ac\"`, \"‚Ç¨\"},\n\t\t{`\"\\ud83d\\ude01\"`, \"üòÅ\"},\n\t\t{`\"\\ud83d\\ude01\\ud83d\\ude01\"`, \"üòÅüòÅ\"},\n\t\t{`\"\\\\u123\"`, `\\u123`},\n\t\t{`\"\\\\u12345\"`, `\\u12345`},\n\t\t{`\"\\\\ud83d\"`, `\\ud83d`},\n\t\t{`\"\\\\ud83d\\\\\"`, `\\ud83d\\\\`},\n\t\t{`\"\\\\ud83d\\ude0\"`, `\\ud83d\\ude0`},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.in, func(t *testing.T) {\n\t\t\tout := unescapeStringBestEffort(tt.in)\n\t\t\tif out != tt.out {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", tt.in, out, tt.out)\n\t\t\t}\n\t\t})\n\t}\n}\n","ce19768ad4ca3977d0976120357c68d6":"package fastjson\n\nimport \"testing\"\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    string\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\ts:    \"\",\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with leading whitespace\",\n\t\t\ts:    \" \\t\\n\\r foo\",\n\t\t\twant: \"foo\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with no leading whitespace\",\n\t\t\ts:    \"bar\",\n\t\t\twant: \"bar\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with only whitespace\",\n\t\t\ts:    \" \\t\\n\\r\",\n\t\t\twant: \"\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","ce393aeae9568082d69d7a6c00ded17e":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Empty string\n\t\t{\"\", nil, \"\", fmt.Errorf(\"cannot parse empty string\")},\n\t\t// Invalid JSON\n\t\t{\"{\", nil, \"{\", fmt.Errorf(\"cannot parse object: missing '}'\")},\n\t\t// Object\n\t\t{`{\"key\": \"value\"}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{t: typeRawString, s: \"value\"}}}}}}, \"\", nil},\n\t\t// Array\n\t\t{`[1, \"test\"]`, \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: typeRawString, s: \"test\"}}}, \"\", nil},\n\t\t// String\n\t\t{`\"test\"`, \u0026Value{t: typeRawString, s: \"test\"}, \"\", nil},\n\t\t// True\n\t\t{\"true\", valueTrue, \"\", nil},\n\t\t// False\n\t\t{\"false\", valueFalse, \"\", nil},\n\t\t// Null\n\t\t{\"null\", valueNull, \"\", nil},\n\t\t// Number\n\t\t{\"123\", \u0026Value{t: TypeNumber, s: \"123\"}, \"\", nil},\n\t\t// NaN\n\t\t{\"NaN\", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"\", nil},\n\t\t// Trailing whitespace\n\t\t{\"true \", valueTrue, \" \", nil},\n\t}\n\n\tc := \u0026cache{}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test %d\", i+1), func(t *testing.T) {\n\t\t\tgot, tail, err := parseValue(tt.input, c, 0)\n\t\t\tif (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, wantErr %v\", tt.input, err, tt.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"parseValue(%q) tail = %q, wantTail %q\", tt.input, tail, tt.tail)\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", tt.input, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\treturn v1.s == v2.s\n\t}\n}","cee6ab93546cb62c80fb31265cc0b0c3":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantN    string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Basic cases\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"123.456\", \"123.456\", \"\", nil},\n\t\t{\"1.2e3\", \"1.2e3\", \"\", nil},\n\t\t{\"1.2E-3\", \"1.2E-3\", \"\", nil},\n\n\t\t// Trailing characters\n\t\t{\"123a\", \"123\", \"a\", nil},\n\t\t{\"123.456 \", \"123.456\", \" \", nil},\n\n\t\t// Invalid numbers\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t\t{\"a123\", \"\", \"a123\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\"+a123\", \"\", \"+a123\", fmt.Errorf(\"unexpected char: %q\", \"+\")},\n\t\t{\"+123a\", \"+123\", \"a\", nil},\n\n\t\t// Special cases: inf, nan\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"+inf\", \"+inf\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"InF\", \"InF\", \"\", nil},\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"+nan\", \"\", \"+nan\", fmt.Errorf(\"unexpected char: %q\", \"+\")},\n\t\t{\"-nan\", \"\", \"-nan\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t\t{\"in\", \"\", \"in\", fmt.Errorf(\"unexpected char: %q\", \"i\")},\n\t\t{\"+i\", \"\", \"+i\", fmt.Errorf(\"unexpected char: %q\", \"+\")},\n\t\t{\"123inf\", \"123\", \"inf\", nil},\n\t\t{\"123InF\", \"123\", \"InF\", nil},\n\t\t{\"123nan\", \"123\", \"nan\", nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tgotN, gotTail, gotErr := parseRawNumber(tt.input)\n\t\t\tif gotN != tt.wantN || gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = (%q, %q, %v), want (%q, %q, %v)\", tt.input, gotN, gotTail, gotErr, tt.wantN, tt.wantTail, tt.wantErr)\n\t\t\t}\n\t\t\tif gotErr != nil \u0026\u0026 tt.wantErr == nil || gotErr == nil \u0026\u0026 tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tt.input, gotErr, tt.wantErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", tt.input, gotErr, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","cf569eccca807a583e3e1abb4542ed42":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey string\n\t\tvalue string\n\t\terr error\n\t}{\n\t\t{\n\t\t\tinput: `\"foo\"bar`,\n\t\t\tkey: \"foo\",\n\t\t\tvalue: \"bar\",\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tinput: `\"fo\\o\"bar`,\n\t\t\tkey: `fo\\o`,\n\t\t\tvalue: \"bar\",\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tinput: `\"foo\\\"bar\"baz`,\n\t\t\tkey: `foo\\\"bar`,\n\t\t\tvalue: \"baz\",\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tinput: `\"foo\\\\\"bar`,\n\t\t\tkey: `foo\\\\`,\n\t\t\tvalue: \"bar\",\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tinput: `\"foo`,\n\t\t\tkey: ``,\n\t\t\tvalue: ``,\n\t\t\terr: fmt.Errorf(`missing closing '\"'`),\n\t\t},\n\t}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test %d\", i), func(t *testing.T) {\n\t\t\tkey, value, err := parseRawString(tt.input)\n\t\t\tif key != tt.key || value != tt.value || !errorEqual(err, tt.err) {\n\t\t\t\tt.Errorf(\"input: %q, expect(%q, %q, %v), got(%q, %q, %v)\", tt.input, tt.key, tt.value, tt.err, key, value, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc errorEqual(e1, e2 error) bool {\n\tif e1 == nil \u0026\u0026 e2 == nil {\n\t\treturn true\n\t}\n\tif e1 != nil \u0026\u0026 e2 != nil {\n\t\treturn e1.Error() == e2.Error()\n\t}\n\treturn false\n}","cfc916037e0bc9ef8c3ad68cd5ccc315":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Get(t *testing.T) {\n\tt.Run(\"object\", func(t *testing.T) {\n\t\tv := MustParse(`{\"foo\": {\"bar\": \"baz\"}}`)\n\t\tassert(t, v.Get(\"foo\", \"bar\").String() == \"baz\", \"Get failed\")\n\t\tassert(t, v.Get(\"foo\", \"xyz\") == nil, \"Get should return nil for non-existing key\")\n\t})\n\n\tt.Run(\"array\", func(t *testing.T) {\n\t\tv := MustParse(`[1, 2, 3]`)\n\t\tassert(t, v.Get(\"0\").Int() == 1, \"Get failed\")\n\t\tassert(t, v.Get(\"1\").Int() == 2, \"Get failed\")\n\t\tassert(t, v.Get(\"2\").Int() == 3, \"Get failed\")\n\t\tassert(t, v.Get(\"3\") == nil, \"Get should return nil for out of range index\")\n\t\tassert(t, v.Get(\"-1\") == nil, \"Get should return nil for negative index\")\n\t\tassert(t, v.Get(\"abc\") == nil, \"Get should return nil for invalid index\")\n\t})\n\n\tt.Run(\"nested\", func(t *testing.T) {\n\t\tv := MustParse(`{\"foo\": [{\"bar\": 1}, {\"baz\": 2}]}`)\n\t\tassert(t, v.Get(\"foo\", \"0\", \"bar\").Int() == 1, \"Get failed\")\n\t\tassert(t, v.Get(\"foo\", \"1\", \"baz\").Int() == 2, \"Get failed\")\n\t})\n\n\tt.Run(\"non-existing\", func(t *testing.T) {\n\t\tv := MustParse(`{\"foo\": \"bar\"}`)\n\t\tassert(t, v.Get(\"baz\") == nil, \"Get should return nil for non-existing key\")\n\t\tassert(t, v.Get(\"foo\", \"xyz\") == nil, \"Get should return nil for non-existing nested key\")\n\t})\n\n\tt.Run(\"nil\", func(t *testing.T) {\n\t\tvar v *Value\n\t\tassert(t, v.Get(\"foo\") == nil, \"Get on nil Value should return nil\")\n\t})\n}\n\nfunc assert(tb testing.TB, condition bool, msg string, v ...interface{}) {\n\tif !condition {\n\t\ttb.Helper()\n\t\ttb.Errorf(msg, v...)\n\t}\n}","d022cd027712a505cb7c482afa838bb6":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Empty string\n\t\t{\"\", nil, \"\", fmt.Errorf(\"cannot parse empty string\")},\n\t\t// Invalid JSON\n\t\t{\"{\", nil, \"{\", fmt.Errorf(\"cannot parse object: missing '}'\")},\n\t\t// Object\n\t\t{`{\"foo\":\"bar\"}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: typeRawString, s: \"bar\"}}}}}, \"\", nil},\n\t\t// Array\n\t\t{`[1,2,3]`, \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}}, \"\", nil},\n\t\t// String\n\t\t{`\"hello\"`, \u0026Value{t: typeRawString, s: \"hello\"}, \"\", nil},\n\t\t// True\n\t\t{\"true\", valueTrue, \"\", nil},\n\t\t// False\n\t\t{\"false\", valueFalse, \"\", nil},\n\t\t// Null\n\t\t{\"null\", valueNull, \"\", nil},\n\t\t// Number\n\t\t{\"123\", \u0026Value{t: TypeNumber, s: \"123\"}, \"\", nil},\n\t\t// NaN\n\t\t{\"NaN\", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"\", nil},\n\t\t// Number with tail\n\t\t{\"123 \", \u0026Value{t: TypeNumber, s: \"123\"}, \" \", nil},\n\t\t// Invalid value\n\t\t{\"invalid\", nil, \"invalid\", fmt.Errorf(\"unexpected value found: \\\"invalid\\\"\")},\n\t}\n\n\tc := \u0026cache{}\n\tfor i, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tgot, tail, err := parseValue(test.input, c, 0)\n\t\t\tif test.err != nil {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"Expected error, got nil\")\n\t\t\t\t} else if err.Error() != test.err.Error() {\n\t\t\t\t\tt.Errorf(\"Expected error %v, got %v\", test.err, err)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t\t\t}\n\t\t\t\tif got == nil {\n\t\t\t\t\tt.Errorf(\"Expected non-nil value, got nil\")\n\t\t\t\t} else if !got.equal(test.want) {\n\t\t\t\t\tt.Errorf(\"Test-%d: Expected %v, got %v\", i, test.want, got)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif tail != test.tail {\n\t\t\t\tt.Errorf(\"Expected tail %q, got %q\", test.tail, tail)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// Helper function to compare values\nfunc (v *Value) equal(other *Value) bool {\n\tif v == nil \u0026\u0026 other == nil {\n\t\treturn true\n\t}\n\tif v == nil || other == nil {\n\t\treturn false\n\t}\n\tif v.t != other.t {\n\t\treturn false\n\t}\n\tswitch v.t {\n\tcase TypeObject:\n\t\treturn v.o.equal(\u0026other.o)\n\tcase TypeArray:\n\t\tif len(v.a) != len(other.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v.a {\n\t\t\tif !v.a[i].equal(other.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\treturn v.s == other.s\n\t}\n}\n\n// Helper function to compare objects\nfunc (o *Object) equal(other *Object) bool {\n\tif len(o.kvs) != len(other.kvs) {\n\t\treturn false\n\t}\n\tfor i := range o.kvs {\n\t\tif o.kvs[i].k != other.kvs[i].k {\n\t\t\treturn false\n\t\t}\n\t\tif !o.kvs[i].v.equal(other.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","d08a0b4bda078a33a560fef033579209":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic escapes\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\t`, \"\\t\"},\n\t\t{`\\\\`, \"\\\\\"},\n\t\t{`\\\"`, \"\\\"\"},\n\t\t{`\\/`, \"/\"},\n\n\t\t// Unicode escapes\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A9`, \"¬©\"},\n\t\t{`\\u20AC`, \"‚Ç¨\"},\n\n\t\t// Surrogate pairs\n\t\t{`\\uD83D\\uDE02`, \"üòÇ\"},\n\n\t\t// Invalid escapes\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\uD800`, `\\uD800`}, // Invalid surrogate pair\n\n\t\t// Mixed escapes\n\t\t{`Hello\\tworld\\n`, \"Hello\\tworld\\n\"},\n\t\t{`Copyright: \\u00A9`, \"Copyright: ¬©\"},\n\t\t{`Invalid escape: \\x, valid escape: \\n`, \"Invalid escape: \\\\x, valid escape: \\n\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}","d17936696f61395fe3f9b52667ef3ece":"package fastjson\n\nimport \"testing\"\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\ts string\n\t\twant string\n\t}{\n\t\t// Test cases here\n\t\t{\"  foo\", \"foo\"},\n\t\t{\"\\n\\tbar\", \"bar\"},\n\t\t{\"baz\", \"baz\"},\n\t\t{\"\\r\\n\", \"\"},\n\t\t{\"\", \"\"},\n\t}\n\tfor i, tt := range tests {\n\t\tgot := skipWSSlow(tt.s)\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"test %d failed, want: %s, got: %s\", i, tt.want, got)\n\t\t}\n\t}\n}","d19552cb4a85b8bdc7ee59d416f1defb":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"raw string\",\n\t\t\t},\n\t\t\twant: []byte(`\"raw string\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"string\",\n\t\t\t},\n\t\t\twant: []byte(`\"string\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"12345\",\n\t\t\t},\n\t\t\twant: []byte(`12345`),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(`true`),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(`false`),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(`null`),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"string\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"12345\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`[\"string\",12345]`),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"string\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"string\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"number\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"12345\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`{\"string\":\"string\",\"number\":12345}`),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif string(got) != string(tt.want) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %v, want %v\", string(got), string(tt.want))\n\t\t\t}\n\t\t})\n\t}\n}\n","d1c42aa0ff9a668dfcf23c9f797c946e":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput       string\n\t\twantValue   string\n\t\twantTail    string\n\t\twantErr     bool\n\t\twantCacheLen int\n\t}{\n\t\t// Empty object.\n\t\t{\n\t\t\tinput:       \"{}\",\n\t\t\twantValue:   `{\"Object\":null}`,\n\t\t\twantTail:    \"\",\n\t\t\twantErr:     false,\n\t\t\twantCacheLen: 1,\n\t\t},\n\t\t// Simple object.\n\t\t{\n\t\t\tinput:       `{\"foo\": \"bar\"}`,\n\t\t\twantValue:   `{\"Object\":{\"foo\":\"bar\"}}`,\n\t\t\twantTail:    \"\",\n\t\t\twantErr:     false,\n\t\t\twantCacheLen: 2,\n\t\t},\n\t\t// Escape chars in key.\n\t\t{\n\t\t\tinput:       `{\"fo\\no\": \"bar\"}`,\n\t\t\twantValue:   `{\"Object\":{\"fo\\no\":\"bar\"}}`,\n\t\t\twantTail:    \"\",\n\t\t\twantErr:     false,\n\t\t\twantCacheLen: 2,\n\t\t},\n\t\t// Object with multiple fields.\n\t\t{\n\t\t\tinput:       `{\"foo\":\"bar\",  \"baz\":  42}`,\n\t\t\twantValue:   `{\"Object\":{\"foo\":\"bar\",\"baz\":42}}`,\n\t\t\twantTail:    \"\",\n\t\t\twantErr:     false,\n\t\t\twantCacheLen: 3,\n\t\t},\n\t\t// Nested object.\n\t\t{\n\t\t\tinput:       `{\"foo\":{\"bar\":\"baz\"}}`,\n\t\t\twantValue:   `{\"Object\":{\"foo\":{\"Object\":{\"bar\":\"baz\"}}}}`,\n\t\t\twantTail:    \"\",\n\t\t\twantErr:     false,\n\t\t\twantCacheLen: 3,\n\t\t},\n\t\t// Null value.\n\t\t{\n\t\t\tinput:       `{\"foo\":null}`,\n\t\t\twantValue:   `{\"Object\":{\"foo\":null}}`,\n\t\t\twantTail:    \"\",\n\t\t\twantErr:     false,\n\t\t\twantCacheLen: 2,\n\t\t},\n\t\t// Empty string value.\n\t\t{\n\t\t\tinput:       `{\"foo\":\"\"}`,\n\t\t\twantValue:   `{\"Object\":{\"foo\":\"\"}}`,\n\t\t\twantTail:    \"\",\n\t\t\twantErr:     false,\n\t\t\twantCacheLen: 2,\n\t\t},\n\t\t// Trailing comma.\n\t\t{\n\t\t\tinput:       `{\"foo\":\"bar\",}`,\n\t\t\twantValue:   \"\",\n\t\t\twantTail:    `{\"foo\":\"bar\",}`,\n\t\t\twantErr:     true,\n\t\t\twantCacheLen: 2,\n\t\t},\n\t\t// Missing closing bracket.\n\t\t{\n\t\t\tinput:       `{\"foo\":\"bar\"`,\n\t\t\twantValue:   \"\",\n\t\t\twantTail:    `{\"foo\":\"bar\"`,\n\t\t\twantErr:     true,\n\t\t\twantCacheLen: 2,\n\t\t},\n\t\t// Invalid key.\n\t\t{\n\t\t\tinput:       `{foo:\"bar\"}`,\n\t\t\twantValue:   \"\",\n\t\t\twantTail:    `{foo:\"bar\"}`,\n\t\t\twantErr:     true,\n\t\t\twantCacheLen: 1,\n\t\t},\n\t\t// Missing colon.\n\t\t{\n\t\t\tinput:       `{\"foo\" \"bar\"}`,\n\t\t\twantValue:   \"\",\n\t\t\twantTail:    `{\"foo\" \"bar\"}`,\n\t\t\twantErr:     true,\n\t\t\twantCacheLen: 1,\n\t\t},\n\t\t// Invalid value.\n\t\t{\n\t\t\tinput:       `{\"foo\":bar}`,\n\t\t\twantValue:   \"\",\n\t\t\twantTail:    `{\"foo\":bar}`,\n\t\t\twantErr:     true,\n\t\t\twantCacheLen: 1,\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i+1), func(t *testing.T) {\n\t\t\tc := \u0026cache{\n\t\t\t\tvs: make([]Value, 0, 10),\n\t\t\t}\n\t\t\tgotValue, gotTail, gotErr := parseObject(tt.input, c, 0)\n\n\t\t\tif (gotErr != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", gotErr, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotValue != nil {\n\t\t\t\tif gotValue.String() != tt.wantValue {\n\t\t\t\t\tt.Errorf(\"parseObject() gotValue = %v, want %v\", gotValue.String(), tt.wantValue)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseObject() gotTail = %v, want %v\", gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif len(c.vs) != tt.wantCacheLen {\n\t\t\t\tt.Errorf(\"parseObject() cache len = %v, want %v\", len(c.vs), tt.wantCacheLen)\n\t\t\t}\n\t\t})\n\t}\n}","d2756c18d2278ae148d9b3426eb9553b":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tinput    string\n\t\twant    *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty object\",\n\t\t\tinput: \"{}\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: nil,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"single key-value object\",\n\t\t\tinput: `{\"key\": \"value\"}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"multiple key-value object\",\n\t\t\tinput: `{\"key1\": \"value1\", \"key2\": 123, \"key3\": true}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid object: missing closing brace\",\n\t\t\tinput:    `{\"key\": \"value\"`,\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid object: missing colon\",\n\t\t\tinput:    `{\"key\" \"value\"}`,\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid object: missing comma\",\n\t\t\tinput:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, _, err := parseObject(tt.input, c, 0)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\treturn true\n\t}\n}","d37f73f2514549345a227ae9b96d41ee":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey   string\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t{`\"foo\": \"bar\"`, \"foo\", `: \"bar\"`, nil},\n\t\t{`\"foo\":`, \"foo\", `:`, nil},\n\t\t{`\"foo\"`, \"foo\", \"\", nil},\n\t\t{`\"foo`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`foo\"`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo\\bar\": \"baz\"`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo\\\"bar\": \"baz\"`, \"foo\\\"bar\", `: \"baz\"`, nil},\n\t}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tkey, tail, err := parseRawKey(tt.input)\n\t\t\tif key != tt.key || tail != tt.tail || !equalError(err, tt.err) {\n\t\t\t\tt.Errorf(\"input: %q, expect(%q, %q, %v), got(%q, %q, %v)\", tt.input, tt.key, tt.tail, tt.err, key, tail, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalError(a, b error) bool {\n\tif a == nil {\n\t\treturn b == nil\n\t}\n\tif b == nil {\n\t\treturn false\n\t}\n\treturn a.Error() == b.Error()\n}","d384e78a0455b8094e0cc981c2bfffd0":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_unescapeKeys(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tkvs  []kv\n\t\twant []kv\n\t}{\n\t\t{\n\t\t\tname: \"basic\",\n\t\t\tkvs: []kv{\n\t\t\t\t{k: \"key\\\\u0031\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}},\n\t\t\t},\n\t\t\twant: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"no escape\",\n\t\t\tkvs: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}},\n\t\t\t},\n\t\t\twant: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"empty\",\n\t\t\tkvs:  []kv{},\n\t\t\twant: []kv{},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\to := \u0026Object{\n\t\t\t\tkvs: tt.kvs,\n\t\t\t}\n\t\t\to.unescapeKeys()\n\t\t\tfor i := range o.kvs {\n\t\t\t\tif o.kvs[i].k != tt.want[i].k {\n\t\t\t\t\tt.Errorf(\"unescapeKeys() = %v, want %v\", o.kvs[i].k, tt.want[i].k)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","d4399876666ac672c67f3ad25ddf2cf4":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Empty string\n\t\t{\"\", nil, \"\", fmt.Errorf(\"cannot parse empty string\")},\n\t\t// Invalid JSON\n\t\t{\"{\", nil, \"{\", fmt.Errorf(\"cannot parse object: missing '}'\")},\n\t\t// Object\n\t\t{`{\"foo\":\"bar\"}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: typeRawString, s: \"bar\"}}}}}, \"\", nil},\n\t\t// Array\n\t\t{`[1,2,3]`, \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}}, \"\", nil},\n\t\t// String\n\t\t{`\"hello\"`, \u0026Value{t: typeRawString, s: \"hello\"}, \"\", nil},\n\t\t// True\n\t\t{\"true\", valueTrue, \"\", nil},\n\t\t// False\n\t\t{\"false\", valueFalse, \"\", nil},\n\t\t// Null\n\t\t{\"null\", valueNull, \"\", nil},\n\t\t// Number\n\t\t{\"123\", \u0026Value{t: TypeNumber, s: \"123\"}, \"\", nil},\n\t\t// NaN\n\t\t{\"NaN\", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"\", nil},\n\t\t// Trailing whitespace\n\t\t{\"true \", valueTrue, \" \", nil},\n\t\t// Nested structures\n\t\t{`{\"foo\":[1,{\"bar\":\"baz\"}]}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeObject, o: Object{kvs: []kv{{k: \"bar\", v: \u0026Value{t: typeRawString, s: \"baz\"}}}}}}}}}}}, \"\", nil},\n\t}\n\n\tc := \u0026cache{}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tgot, tail, err := parseValue(tt.input, c, 0)\n\t\t\tif (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"parseValue(%q) error mismatch: got %v, want %v\", tt.input, err, tt.err)\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"parseValue(%q) tail mismatch: got %q, want %q\", tt.input, tail, tt.tail)\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue(%q) value mismatch:\\ngot  %+v\\nwant %+v\", tt.input, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase typeRawString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\treturn v1.t == v2.t\n\t}\n}","d4b604f7b013fd7cbb085e5d0f4c170d":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantN    string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Empty input\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t\t// Valid integers\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"0\", \"0\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t// Valid floats\n\t\t{\"123.456\", \"123.456\", \"\", nil},\n\t\t{\"-123.456\", \"-123.456\", \"\", nil},\n\t\t{\"0.123\", \"0.123\", \"\", nil},\n\t\t// Valid exponents\n\t\t{\"123e4\", \"123e4\", \"\", nil},\n\t\t{\"123E4\", \"123E4\", \"\", nil},\n\t\t{\"123e+4\", \"123e+4\", \"\", nil},\n\t\t{\"123e-4\", \"123e-4\", \"\", nil},\n\t\t// Valid infinities\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"+inf\", \"+inf\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"InF\", \"InF\", \"\", nil},\n\t\t// Valid NaNs\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"+nan\", \"+nan\", \"\", nil},\n\t\t{\"-nan\", \"-nan\", \"\", nil},\n\t\t{\"nAn\", \"nAn\", \"\", nil},\n\t\t// Invalid numbers\n\t\t{\"123a\", \"\", \"123a\", fmt.Errorf(\"unexpected char: %q\", \"123a\")},\n\t\t{\"a123\", \"\", \"a123\", fmt.Errorf(\"unexpected char: %q\", \"a123\")},\n\t\t// Number with trailing characters\n\t\t{\"123abc\", \"123\", \"abc\", nil},\n\t\t// Number with leading whitespace\n\t\t{\" 123\", \"\", \" 123\", fmt.Errorf(\"unexpected char: %q\", \" 123\")},\n\t\t// Number with trailing whitespace\n\t\t{\"123 \", \"123\", \" \", nil},\n\t\t// Special cases\n\t\t{\"+123\", \"+123\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\".123\", \"\", \".123\", fmt.Errorf(\"unexpected char: %q\", \".123\")},\n\t\t{\"123.\", \"123\", \".\", nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d:%s\", i, tt.input), func(t *testing.T) {\n\t\t\tgotN, gotTail, gotErr := parseRawNumber(tt.input)\n\t\t\tif gotN != tt.wantN {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got number = %q, want %q\", tt.input, gotN, tt.wantN)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got tail = %q, want %q\", tt.input, gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif gotErr == nil \u0026\u0026 tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got no error, want %v\", tt.input, tt.wantErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr == nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got error = %v, want nil\", tt.input, gotErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got error = %v, want %v\", tt.input, gotErr, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","d5afcbd21334131754f319a21296c8e1":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Empty array\n\t\t{\n\t\t\tinput: \"[]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\ttail: \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t// Simple array\n\t\t{\n\t\t\tinput: \"[1,2,3]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttail: \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t// Array with different types\n\t\t{\n\t\t\tinput: `[1,\"test\",true,null]`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeString, s: \"test\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t\t{t: TypeNull},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttail: \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t// Nested array\n\t\t{\n\t\t\tinput: \"[1,[2,3],4]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeArray, a: []*Value{\n\t\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t\t}},\n\t\t\t\t\t{t: TypeNumber, s: \"4\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttail: \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t// Array with whitespace\n\t\t{\n\t\t\tinput: \" [ 1 , 2 , 3 ] \",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttail: \" \",\n\t\t\terr:   nil,\n\t\t},\n\t\t// Invalid array - missing closing bracket\n\t\t{\n\t\t\tinput: \"[1,2,3\",\n\t\t\twant:  nil,\n\t\t\ttail:  \"\",\n\t\t\terr:   fmt.Errorf(\"missing ']'\"),\n\t\t},\n\t\t// Invalid array - missing comma\n\t\t{\n\t\t\tinput: \"[1 2 3]\",\n\t\t\twant:  nil,\n\t\t\ttail:  \"2 3]\",\n\t\t\terr:   fmt.Errorf(\"missing ',' after array value\"),\n\t\t},\n\t\t// Invalid array - unexpected end\n\t\t{\n\t\t\tinput: \"[1,\",\n\t\t\twant:  nil,\n\t\t\ttail:  \"\",\n\t\t\terr:   fmt.Errorf(\"unexpected end of array\"),\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i+1), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, tail, err := parseArray(tt.input, c, 0)\n\n\t\t\tif (err != nil) != (tt.err != nil) {\n\t\t\t\tt.Errorf(\"expected error %v, got %v\", tt.err, err)\n\t\t\t}\n\t\t\tif err != nil \u0026\u0026 err.Error() != tt.err.Error() {\n\t\t\t\tt.Errorf(\"expected error %q, got %q\", tt.err.Error(), err.Error())\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"expected tail %q, got %q\", tt.tail, tail)\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"expected value %v, got %v\", tt.want, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.s != v2.s {\n\t\treturn false\n\t}\n\tif len(v1.a) != len(v2.a) {\n\t\treturn false\n\t}\n\tfor i := range v1.a {\n\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","d6b58a3300f6f0aa3be4fdc50d3224d9":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_StringBytes(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tv       *Value\n\t\twant    []byte\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant:    []byte(\"hello\"),\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := tt.v.StringBytes()\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"StringBytes() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !equalBytes(got, tt.want) {\n\t\t\t\tt.Errorf(\"StringBytes() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalBytes(a, b []byte) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","d82823f69afa030b585520cf90bdf567":"package fastjson\n\nimport \"testing\"\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tt    Type\n\t\twant string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t\t{Type(100), \"\"},\n\t}\n\tfor i, tt := range tests {\n\t\tgot := tt.t.String()\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"test[%d]: String() = %q, want %q\", i, got, tt.want)\n\t\t}\n\t}\n}\n","db61f8c8bafafa3f785b8278370ea805":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey string\n\t\tvalue string\n\t\terr error\n\t}{\n\t\t// Basic cases\n\t\t{`\"foo\"bar`, \"foo\", \"bar\", nil},\n\t\t{`\"foo\" bar`, \"foo\", \" bar\", nil},\n\t\t{`\"foo\"  bar`, \"foo\", \"  bar\", nil},\n\t\t{`\"foo\"`, \"foo\", \"\", nil},\n\n\t\t// Escaped quotes\n\t\t{`\"\\\\\"foo\"bar`, `\\\"foo`, \"bar\", nil},\n\t\t{`\"fo\\\\o\"bar`, `fo\\o`, \"bar\", nil},\n\t\t{`\"foo\\\\\"bar`, `foo\\`, \"bar\", nil},\n\t\t{`\"foo\\\\\\\"\"bar`, `foo\\\"`, \"bar\", nil},\n\t\t{`\"foo\\\\\\\\\"bar`, `foo\\\\`, \"bar\", nil},\n\n\t\t// Missing closing quote\n\t\t{`\"foo`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo bar`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo\\\"`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tkey, value, err := parseRawString(tt.input)\n\t\t\tif key != tt.key || value != tt.value || !errorEqual(err, tt.err) {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = (%q, %q, %v), want (%q, %q, %v)\", tt.input, key, value, err, tt.key, tt.value, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// errorEqual compares two errors for equality.\nfunc errorEqual(e1, e2 error) bool {\n\tif e1 == nil \u0026\u0026 e2 == nil {\n\t\treturn true\n\t}\n\tif e1 == nil || e2 == nil {\n\t\treturn false\n\t}\n\treturn e1.Error() == e2.Error()\n}","dc8534c514a95ac790249388b3fb0c86":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantN    string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Basic cases.\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"123.456\", \"123.456\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"+123\", \"+123\", \"\", nil},\n\t\t{\"1.2e3\", \"1.2e3\", \"\", nil},\n\t\t{\"1.2E3\", \"1.2E3\", \"\", nil},\n\t\t{\"1.2e+3\", \"1.2e+3\", \"\", nil},\n\t\t{\"1.2e-3\", \"1.2e-3\", \"\", nil},\n\n\t\t// Trailing garbage.\n\t\t{\"123a\", \"123\", \"a\", nil},\n\t\t{\"123.456a\", \"123.456\", \"a\", nil},\n\n\t\t// Leading garbage.\n\t\t{\"a123\", \"\", \"a123\", fmt.Errorf(`unexpected char: \"a\"`)},\n\n\t\t// Invalid numbers.\n\t\t{\"\", \"\", \"\", fmt.Errorf(`unexpected char: \"\"`)},\n\t\t{\"-\", \"\", \"-\", fmt.Errorf(`unexpected char: \"-\"`)},\n\t\t{\"+\", \"\", \"+\", fmt.Errorf(`unexpected char: \"+\"`)},\n\t\t{\"1.2e\", \"\", \"1.2e\", nil},\n\n\t\t// Special values.\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"+inf\", \"+inf\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"+nan\", \"\", \"+nan\", fmt.Errorf(`unexpected char: \"+\"`)},\n\t\t{\"-nan\", \"\", \"-nan\", fmt.Errorf(`unexpected char: \"-\"`)},\n\n\t\t// Special values with trailing garbage.\n\t\t{\"infa\", \"inf\", \"a\", nil},\n\t\t{\"+infa\", \"+inf\", \"a\", nil},\n\t\t{\"-infa\", \"-inf\", \"a\", nil},\n\t\t{\"nana\", \"nan\", \"a\", nil},\n\n\t\t// Special values with leading garbage.\n\t\t{\"ainf\", \"\", \"ainf\", fmt.Errorf(`unexpected char: \"a\"`)},\n\t\t{\"+ainf\", \"\", \"+ainf\", fmt.Errorf(`unexpected char: \"+\"`)},\n\t\t{\"-ainf\", \"\", \"-ainf\", fmt.Errorf(`unexpected char: \"-\"`)},\n\t\t{\"anan\", \"\", \"anan\", fmt.Errorf(`unexpected char: \"a\"`)},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tgotN, gotTail, gotErr := parseRawNumber(tt.input)\n\t\t\tif gotN != tt.wantN {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, want %q\", tt.input, gotN, tt.wantN)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, want %q\", tt.input, gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif gotErr == nil \u0026\u0026 tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = nil error, want %v\", tt.input, tt.wantErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr == nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = %v, want nil error\", tt.input, gotErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = %v, want %v\", tt.input, gotErr, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","dc8ba8ea3d6e15a7873c4367652b2c60":"package fastjson\n\nimport \"testing\"\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"  foo\", \"foo\"},\n\t\t{\"\\n\\n\\tbar\", \"bar\"},\n\t\t{\" \\t\\r\\n baz\", \"baz\"},\n\t\t{\"qux\", \"qux\"},\n\t\t{\"\", \"\"},\n\t\t{\"\\t\", \"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := skipWSSlow(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"skipWSSlow(%q) = %q, want %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}","dca2d006634fa60407c962b9f0af8fda":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\tsleft string\n\t\terr   error\n\t}{\n\t\t// Empty object.\n\t\t{\n\t\t\tinput: `{}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{},\n\t\t\t},\n\t\t\tsleft: \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t// Simple object.\n\t\t{\n\t\t\tinput: `{\"foo\": \"bar\"}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"foo\", v: \u0026Value{t: TypeString, s: \"bar\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tsleft: \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t// Missing closing curly brace.\n\t\t{\n\t\t\tinput: `{\"foo\": \"bar\"`,\n\t\t\twant:  nil,\n\t\t\tsleft: `{\"foo\": \"bar\"`,\n\t\t\terr:   fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t\t// Missing key.\n\t\t{\n\t\t\tinput: `{:\"bar\"}`,\n\t\t\twant:  nil,\n\t\t\tsleft: `{:\"bar\"}`,\n\t\t\terr:   fmt.Errorf(`cannot find opening '\"\" for object key`),\n\t\t},\n\t\t// Missing colon.\n\t\t{\n\t\t\tinput: `{\"foo\" \"bar\"}`,\n\t\t\twant:  nil,\n\t\t\tsleft: ` \"bar\"}`,\n\t\t\terr:   fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t\t// Missing comma.\n\t\t{\n\t\t\tinput: `{\"foo\":\"bar\" \"baz\":\"qux\"}`,\n\t\t\twant:  nil,\n\t\t\tsleft: ` \"baz\":\"qux\"}`,\n\t\t\terr:   fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\t\t// Trailing comma.\n\t\t{\n\t\t\tinput: `{\"foo\":\"bar\",}`,\n\t\t\twant:  nil,\n\t\t\tsleft: `,`,\n\t\t\terr:   fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, sleft, err := parseObject(tt.input, c, 0)\n\t\t\tif tt.err != nil {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"expected error %v, got nil\", tt.err)\n\t\t\t\t} else if err.Error() != tt.err.Error() {\n\t\t\t\t\tt.Errorf(\"expected error %v, got %v\", tt.err, err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif sleft != tt.sleft {\n\t\t\t\tt.Errorf(\"expected sleft %q, got %q\", tt.sleft, sleft)\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"test %d failed: got %v, want %v\", i, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\tpanic(fmt.Sprintf(\"unsupported type: %v\", v1.t))\n\t}\n}\n","dd219a2aa44bcb66c6744f5b2ba36ce9":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput  string\n\t\texpect string\n\t}{\n\t\t// Basic escapes\n\t\t{`\\a`, `\\a`},\n\t\t{`\\b`, \"\\b\"},\n\t\t{`\\f`, \"\\f\"},\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\r`, \"\\r\"},\n\t\t{`\\t`, \"\\t\"},\n\t\t{`\\\\`, `\\`},\n\t\t{`\\/`, `/`},\n\t\t{`\\\"`, `\"`},\n\n\t\t// Unicode escapes\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A0`, \"\\u00A0\"},\n\t\t{`\\uFFFF`, \"\\uFFFF\"},\n\t\t{`\\uD83D\\uDE01`, \"\\U0001F601\"}, // Surrogate pair\n\n\t\t// Invalid escapes\n\t\t{`\\u`, `\\u`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\uD800`, `\\uD800`}, // Unpaired surrogate\n\t\t{`\\uDC00`, `\\uDC00`}, // Unpaired surrogate\n\n\t\t// Mixed strings\n\t\t{`Hello\\tworld`, \"Hello\\tworld\"},\n\t\t{`\"This is a \\\\\\\"test\\\\\\\"\"`, `\"This is a \"test\"`},\n\t\t{`C:\\Users\\john\\Documents`, `C:\\Users\\john\\Documents`},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expect {\n\t\t\tt.Errorf(\"Input: %q, Expected: %q, Actual: %q\", test.input, test.expect, actual)\n\t\t}\n\t}\n}","dde25cf643e56e97e53ca4ead8c2e7f0":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput    string\n\t\twantN    string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Empty input.\n\t\t{\n\t\t\tinput:    \"\",\n\t\t\twantN:    \"\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  fmt.Errorf(\"unexpected char: %q\", \"\"),\n\t\t},\n\t\t// Valid integers.\n\t\t{\n\t\t\tinput:    \"123\",\n\t\t\twantN:    \"123\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"0\",\n\t\t\twantN:    \"0\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"-123\",\n\t\t\twantN:    \"-123\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t// Valid floats.\n\t\t{\n\t\t\tinput:    \"123.456\",\n\t\t\twantN:    \"123.456\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"-123.456\",\n\t\t\twantN:    \"-123.456\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"0.123\",\n\t\t\twantN:    \"0.123\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t// Valid exponents.\n\t\t{\n\t\t\tinput:    \"123e4\",\n\t\t\twantN:    \"123e4\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"123E4\",\n\t\t\twantN:    \"123E4\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"123e+4\",\n\t\t\twantN:    \"123e+4\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"123e-4\",\n\t\t\twantN:    \"123e-4\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t// Valid inf, nan.\n\t\t{\n\t\t\tinput:    \"inf\",\n\t\t\twantN:    \"inf\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"InF\",\n\t\t\twantN:    \"InF\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"nan\",\n\t\t\twantN:    \"nan\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"nAn\",\n\t\t\twantN:    \"nAn\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t// Numbers with trailing characters.\n\t\t{\n\t\t\tinput:    \"123abc\",\n\t\t\twantN:    \"123\",\n\t\t\twantTail: \"abc\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"123.456xyz\",\n\t\t\twantN:    \"123.456\",\n\t\t\twantTail: \"xyz\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t// Invalid numbers.\n\t\t{\n\t\t\tinput:    \"a123\",\n\t\t\twantN:    \"\",\n\t\t\twantTail: \"a123\",\n\t\t\twantErr:  fmt.Errorf(\"unexpected char: %q\", \"a\"),\n\t\t},\n\t\t{\n\t\t\tinput:    \".123\",\n\t\t\twantN:    \"\",\n\t\t\twantTail: \".123\",\n\t\t\twantErr:  fmt.Errorf(\"unexpected char: %q\", \".\"),\n\t\t},\n\t\t{\n\t\t\tinput:    \"123.\",\n\t\t\twantN:    \"123.\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"+123\",\n\t\t\twantN:    \"+123\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"-a123\",\n\t\t\twantN:    \"\",\n\t\t\twantTail: \"-a123\",\n\t\t\twantErr:  fmt.Errorf(\"unexpected char: %q\", \"-\"),\n\t\t},\n\t\t{\n\t\t\tinput:    \"-\",\n\t\t\twantN:    \"\",\n\t\t\twantTail: \"-\",\n\t\t\twantErr:  fmt.Errorf(\"unexpected char: %q\", \"-\"),\n\t\t},\n\t\t{\n\t\t\tinput:    \"in\",\n\t\t\twantN:    \"\",\n\t\t\twantTail: \"in\",\n\t\t\twantErr:  fmt.Errorf(\"unexpected char: %q\", \"i\"),\n\t\t},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test case %d\", i), func(t *testing.T) {\n\t\t\tn, tail, err := parseRawNumber(tc.input)\n\t\t\tif tc.wantErr != nil {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"Expected error %v, got nil\", tc.wantErr)\n\t\t\t\t} else if err.Error() != tc.wantErr.Error() {\n\t\t\t\t\tt.Errorf(\"Expected error %v, got %v\", tc.wantErr, err)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif n != tc.wantN {\n\t\t\t\tt.Errorf(\"Expected number %q, got %q\", tc.wantN, n)\n\t\t\t}\n\t\t\tif tail != tc.wantTail {\n\t\t\t\tt.Errorf(\"Expected tail %q, got %q\", tc.wantTail, tail)\n\t\t\t}\n\t\t})\n\t}\n}","de1d09d9d4effb17d78a1263560aee71":"package fastjson\n\nimport \"testing\"\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"  foo\", \"foo\"},\n\t\t{\"\\n\\n\\tbar\", \"bar\"},\n\t\t{\"\\r\\n  baz\", \"baz\"},\n\t\t{\"qux\", \"qux\"},\n\t\t{\"\", \"\"},\n\t\t{\"\\t\", \"\"},\n\t\t{\"\\r\\n\", \"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := skipWSSlow(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"skipWSSlow(%q) = %q, expected %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}","df4c44fc41f3659b59dbb32405ad0613":"package fastjson\n\nimport \"testing\"\n\nfunc TestValue_GetBool(t *testing.T) {\n\tvar tests = []struct {\n\t\tJSON     string\n\t\tPath     []string\n\t\tExpected bool\n\t}{\n\t\t// Existing keys.\n\t\t{`{\"foo\": {\"bar\": true}}`, []string{\"foo\", \"bar\"}, true},\n\t\t{`{\"foo\": {\"bar\": false}}`, []string{\"foo\", \"bar\"}, false},\n\t\t{`{\"foo\": [true]}`, []string{\"foo\", \"0\"}, true},\n\n\t\t// Non-existing keys.\n\t\t{`{\"foo\": {\"bar\": true}}`, []string{\"foo\", \"baz\"}, false},\n\t\t{`{\"foo\": {\"bar\": true}}`, []string{\"foo\"}, false},\n\t\t{`{\"foo\": {\"bar\": true}}`, []string{}, false},\n\t\t{`{\"foo\": []}`, []string{\"foo\", \"0\"}, false},\n\n\t\t// Invalid value type.\n\t\t{`{\"foo\": {\"bar\": null}}`, []string{\"foo\", \"bar\"}, false},\n\t\t{`{\"foo\": {\"bar\": {}}}`, []string{\"foo\", \"bar\"}, false},\n\t\t{`{\"foo\": {\"bar\": []}}`, []string{\"foo\", \"bar\"}, false},\n\t\t{`{\"foo\": {\"bar\": \"true\"}}`, []string{\"foo\", \"bar\"}, false},\n\t}\n\n\tfor _, test := range tests {\n\t\tv, err := Parse(test.JSON)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Error parsing JSON: %s\", err)\n\t\t\tcontinue\n\t\t}\n\t\tif actual := v.GetBool(test.Path...); actual != test.Expected {\n\t\t\tt.Errorf(\"Expected %v, got %v for path %v in JSON %s\", test.Expected, actual, test.Path, test.JSON)\n\t\t}\n\t}\n}","e08540605cae6ed9a666d3cee7b412f7":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic escapes\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\t`, \"\\t\"},\n\t\t{`\\r`, \"\\r\"},\n\t\t{`\\b`, \"\\b\"},\n\t\t{`\\f`, \"\\f\"},\n\t\t{`\\\\`, \"\\\\\"},\n\t\t{`\\/`, \"/\"},\n\t\t{`\\\"`, \"\\\"\"},\n\n\t\t// Unicode escapes\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A0`, \"\\u00A0\"},\n\t\t{`\\uFFFF`, \"\\uFFFF\"},\n\t\t{`\\uD83D\\uDE01`, \"\\U0001F601\"}, // Smiley face\n\n\t\t// Invalid escapes\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\uD800`, `\\uD800`}, // Invalid surrogate pair\n\t\t{`\\uD800\\u`, `\\uD800\\u`},\n\n\t\t// Mixed strings\n\t\t{`Hello\\tworld\\n`, \"Hello\\tworld\\n\"},\n\t\t{`This is a \"test\" string.`, `This is a \"test\" string.`},\n\t\t{`C:\\\\Users\\\\John\\\\Documents`, `C:\\Users\\John\\Documents`},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Input: %q\\nExpected: %q\\nActual: %q\", test.input, test.expected, actual)\n\t\t}\n\t}\n}\n","e0c44423b42e12e4986c689637048fc2":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic strings\n\t\t{\"hello\", \"hello\"},\n\t\t{\"world\", \"world\"},\n\n\t\t// Escaped characters\n\t\t{`\\\"`, `\"`},\n\t\t{`\\\\`, `\\`},\n\t\t{`\\/`, `/`},\n\t\t{`\\b`, \"\\b\"},\n\t\t{`\\f`, \"\\f\"},\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\r`, \"\\r\"},\n\t\t{`\\t`, \"\\t\"},\n\n\t\t// Unicode escape sequences\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A9`, \"¬©\"},\n\t\t{`\\u20AC`, \"‚Ç¨\"},\n\t\t{`\\uD83D\\uDE02`, \"üòÇ\"}, // Surrogate pair\n\n\t\t// Invalid escape sequences\n\t\t{`\\u`, `\\u`},\n\t\t{`\\u002`, `\\u002`},\n\t\t{`\\uD83D`, `\\uD83D`},\n\t\t{`\\uD83D\\u`, `\\uD83D\\u`},\n\t\t{`\\uD83D\\uXXXX`, `\\uD83D\\uXXXX`},\n\n\t\t// Mixed strings\n\t\t{`hello\\tworld`, \"hello\\tworld\"},\n\t\t{`\\u00A9 2023`, \"¬© 2023\"},\n\t\t{`Invalid\\uD83D escape sequence`, \"Invalid\\uD83D escape sequence\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, expected %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}","e21671345d404e178d58a9be757c585b":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twant     *Value\n\t\twantRest string\n\t\twantErr  error\n\t}{\n\t\t{\n\t\t\tname:     \"empty array\",\n\t\t\tinput:    \"[]\",\n\t\t\twant:     \u0026Value{t: TypeArray},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"single element array\",\n\t\t\tinput:    \"[1]\",\n\t\t\twant:     \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple elements array\",\n\t\t\tinput:    \"[1,2,3]\",\n\t\t\twant:     \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with whitespace\",\n\t\t\tinput:    \" [ 1 , 2 , 3 ] \",\n\t\t\twant:     \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}},\n\t\t\twantRest: \" \",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"nested array\",\n\t\t\tinput:    \"[[1,2],[3,4]]\",\n\t\t\twant: \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}}},\n\t\t\t\t{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"3\"}, {t: TypeNumber, s: \"4\"}}},\n\t\t\t}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing closing bracket\",\n\t\t\tinput:    \"[1,2\",\n\t\t\twant:     nil,\n\t\t\twantRest: \"\",\n\t\t\twantErr:  fmt.Errorf(\"unexpected end of array\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"missing comma\",\n\t\t\tinput:    \"[1 2]\",\n\t\t\twant:     nil,\n\t\t\twantRest: \"\",\n\t\t\twantErr:  fmt.Errorf(\"missing ',' after array value\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, rest, err := parseArray(tt.input, c, 0)\n\t\t\tif (err != nil \u0026\u0026 tt.wantErr == nil) || (err == nil \u0026\u0026 tt.wantErr != nil) || (err != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 err.Error() != tt.wantErr.Error()) {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif rest != tt.wantRest {\n\t\t\t\tt.Errorf(\"parseArray() rest = %v, wantRest %v\", rest, tt.wantRest)\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.t == TypeArray {\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\treturn v1.s == v2.s\n}","e23f2363915a7f8671a8500fbf19be5d":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\tt.Run(\"rawString\", func(t *testing.T) {\n\t\tv := Value{t: typeRawString, s: \"rawString\"}\n\t\tdst := v.MarshalTo(nil)\n\t\texpect := []byte(\"\\\"rawString\\\"\")\n\t\tif string(dst) != string(expect) {\n\t\t\tt.Errorf(\"Marshal raw string error, expect: %v, got: %v\", expect, dst)\n\t\t}\n\t})\n\tt.Run(\"string\", func(t *testing.T) {\n\t\tv := Value{t: TypeString, s: \"string\"}\n\t\tdst := v.MarshalTo(nil)\n\t\texpect := []byte(\"\\\"string\\\"\")\n\t\tif string(dst) != string(expect) {\n\t\t\tt.Errorf(\"Marshal string error, expect: %v, got: %v\", expect, dst)\n\t\t}\n\t})\n\tt.Run(\"number\", func(t *testing.T) {\n\t\tv := Value{t: TypeNumber, s: \"123456\"}\n\t\tdst := v.MarshalTo(nil)\n\t\texpect := []byte(\"123456\")\n\t\tif string(dst) != string(expect) {\n\t\t\tt.Errorf(\"Marshal number error, expect: %v, got: %v\", expect, dst)\n\t\t}\n\t})\n\tt.Run(\"true\", func(t *testing.T) {\n\t\tv := Value{t: TypeTrue}\n\t\tdst := v.MarshalTo(nil)\n\t\texpect := []byte(\"true\")\n\t\tif string(dst) != string(expect) {\n\t\t\tt.Errorf(\"Marshal true error, expect: %v, got: %v\", expect, dst)\n\t\t}\n\t})\n\tt.Run(\"false\", func(t *testing.T) {\n\t\tv := Value{t: TypeFalse}\n\t\tdst := v.MarshalTo(nil)\n\t\texpect := []byte(\"false\")\n\t\tif string(dst) != string(expect) {\n\t\t\tt.Errorf(\"Marshal false error, expect: %v, got: %v\", expect, dst)\n\t\t}\n\t})\n\tt.Run(\"null\", func(t *testing.T) {\n\t\tv := Value{t: TypeNull}\n\t\tdst := v.MarshalTo(nil)\n\t\texpect := []byte(\"null\")\n\t\tif string(dst) != string(expect) {\n\t\t\tt.Errorf(\"Marshal null error, expect: %v, got: %v\", expect, dst)\n\t\t}\n\t})\n\n\tt.Run(\"array\", func(t *testing.T) {\n\t\tv := Value{\n\t\t\tt: TypeArray,\n\t\t\ta: []*Value{\n\t\t\t\t{t: TypeString, s: \"a\"},\n\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t{t: TypeTrue},\n\t\t\t},\n\t\t}\n\t\tdst := v.MarshalTo(nil)\n\t\texpect := []byte(\"[\\\"a\\\",1,true]\")\n\t\tif string(dst) != string(expect) {\n\t\t\tt.Errorf(\"Marshal array error, expect: %v, got: %v\", expect, dst)\n\t\t}\n\t})\n\tt.Run(\"object\", func(t *testing.T) {\n\t\tv := Value{\n\t\t\tt: TypeObject,\n\t\t\to: Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"name\", v: \u0026Value{t: TypeString, s: \"Alice\"}},\n\t\t\t\t\t{k: \"age\", v: \u0026Value{t: TypeNumber, s: \"30\"}},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t\tdst := v.MarshalTo(nil)\n\t\texpect := []byte(\"{\\\"name\\\":\\\"Alice\\\",\\\"age\\\":\\\"30\\\"}\")\n\t\tif string(dst) != string(expect) {\n\t\t\tt.Errorf(\"Marshal object error, expect: %v, got: %v\", expect, dst)\n\t\t}\n\t})\n}","e29ea33cab5b9f9fb4523fdea62a7bfd":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantN    string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Empty input.\n\t\t{\"\", \"\", \"\", nil},\n\t\t// Simple integers.\n\t\t{\"1\", \"1\", \"\", nil},\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t// Negative integers.\n\t\t{\"-1\", \"-1\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t// Positive sign.\n\t\t{\"+123\", \"+123\", \"\", nil},\n\t\t// Floats.\n\t\t{\"1.23\", \"1.23\", \"\", nil},\n\t\t{\"-1.23\", \"-1.23\", \"\", nil},\n\t\t{\"1.23e4\", \"1.23e4\", \"\", nil},\n\t\t{\"1.23e-4\", \"1.23e-4\", \"\", nil},\n\t\t// Leading zeros are not allowed.\n\t\t{\"0123\", \"\", \"0123\", fmt.Errorf(\"unexpected char: %q\", \"0\")},\n\t\t// Invalid characters.\n\t\t{\"1a\", \"1\", \"a\", nil},\n\t\t{\"1.2.3\", \"1.2\", \".3\", nil},\n\t\t// Special cases: inf, nan.\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"+inf\", \"+inf\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"InF\", \"InF\", \"\", nil},\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"+nan\", \"\", \"+nan\", fmt.Errorf(\"unexpected char: %q\", \"+\")},\n\t\t{\"-nan\", \"\", \"-nan\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t\t{\"NaN\", \"NaN\", \"\", nil},\n\t\t// Numbers with trailing data.\n\t\t{\"123abc\", \"123\", \"abc\", nil},\n\t\t{\"-123abc\", \"-123\", \"abc\", nil},\n\t\t{\"1.23abc\", \"1.23\", \"abc\", nil},\n\t\t// Special cases with trailing data.\n\t\t{\"infabc\", \"inf\", \"abc\", nil},\n\t\t{\"nanabc\", \"nan\", \"abc\", nil},\n\t\t// Invalid special cases.\n\t\t{\"in\", \"\", \"in\", fmt.Errorf(\"unexpected char: %q\", \"i\")},\n\t\t{\"na\", \"\", \"na\", fmt.Errorf(\"unexpected char: %q\", \"n\")},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tgotN, gotTail, gotErr := parseRawNumber(tt.input)\n\t\t\tif gotN != tt.wantN {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got number = %q, want %q\", tt.input, gotN, tt.wantN)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got tail = %q, want %q\", tt.input, gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif gotErr == nil \u0026\u0026 tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got no error, want %v\", tt.input, tt.wantErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr == nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got error = %v, want no error\", tt.input, gotErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got error = %v, want %v\", tt.input, gotErr, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","e2f1c5765c1a8aba24c0ebf5d434d945":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ts     string\n\t\terr   error\n\t}{\n\t\t// Empty object\n\t\t{\n\t\t\tinput: \"{}\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Single key-value pair\n\t\t{\n\t\t\tinput: `{\"key\": \"value\"}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Multiple key-value pairs\n\t\t{\n\t\t\tinput: `{\"key1\": \"value1\", \"key2\": 123, \"key3\": true}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Nested objects\n\t\t{\n\t\t\tinput: `{\"key1\": {\"key2\": \"value2\"}, \"key3\": \"value3\"}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Invalid JSON\n\t\t{\n\t\t\tinput: `{\"key\": \"value\"`,\n\t\t\twant:  nil,\n\t\t\ts:     `{\"key\": \"value\"`,\n\t\t\terr:   fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t\t{\n\t\t\tinput: `{key\": \"value\"}`,\n\t\t\twant:  nil,\n\t\t\ts:     `key\": \"value\"}`,\n\t\t\terr:   fmt.Errorf(`cannot find opening '\"\" for object key`),\n\t\t},\n\t\t{\n\t\t\tinput: `{\"key\" \"value\"}`,\n\t\t\twant:  nil,\n\t\t\ts:     `\"value\"}`,\n\t\t\terr:   fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t\t{\n\t\t\tinput: `{\"key\": \"value\" \"key2\": \"value2\"}`,\n\t\t\twant:  nil,\n\t\t\ts:     `\"key2\": \"value2\"}`,\n\t\t\terr:   fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test %d\", i+1), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseObject(tt.input, c, 0)\n\n\t\t\tif (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"Expected error %v, but got %v\", tt.err, err)\n\t\t\t}\n\n\t\t\tif s != tt.s {\n\t\t\t\tt.Errorf(\"Expected remaining string %q, but got %q\", tt.s, s)\n\t\t\t}\n\n\t\t\tif got == nil \u0026\u0026 tt.want == nil {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif got.Type() != tt.want.Type() {\n\t\t\t\tt.Errorf(\"Expected type %v, but got %v\", tt.want.Type(), got.Type())\n\t\t\t}\n\n\t\t\tif got.Type() == TypeObject {\n\t\t\t\tif len(got.o.kvs) != len(tt.want.o.kvs) {\n\t\t\t\t\tt.Errorf(\"Expected %d key-value pairs, but got %d\", len(tt.want.o.kvs), len(got.o.kvs))\n\t\t\t\t}\n\n\t\t\t\tfor j := 0; j \u003c len(got.o.kvs); j++ {\n\t\t\t\t\tif got.o.kvs[j].k != tt.want.o.kvs[j].k {\n\t\t\t\t\t\tt.Errorf(\"Expected key %q, but got %q\", tt.want.o.kvs[j].k, got.o.kvs[j].k)\n\t\t\t\t\t}\n\n\t\t\t\t\tif got.o.kvs[j].v.Type() != tt.want.o.kvs[j].v.Type() {\n\t\t\t\t\t\tt.Errorf(\"Expected type %v for value %d, but got %v\", tt.want.o.kvs[j].v.Type(), j, got.o.kvs[j].v.Type())\n\t\t\t\t\t}\n\n\t\t\t\t\tif got.o.kvs[j].v.Type() == TypeString \u0026\u0026 got.o.kvs[j].v.s != tt.want.o.kvs[j].v.s {\n\t\t\t\t\t\tt.Errorf(\"Expected value %q, but got %q\", tt.want.o.kvs[j].v.s, got.o.kvs[j].v.s)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n","e310404b1d11354d4286fbf82a7a9788":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct{\n\t\tinput string\n\t\twant *Value\n\t\twantRest string\n\t\twantErr error\n\t}{\n\t\t// TODO: Add test cases\n\t}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, rest, err := parseObject(tt.input, c, 0)\n\t\t\tif tt.wantErr != nil {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"expected error but got nil\")\n\t\t\t\t} else if err.Error() != tt.wantErr.Error() {\n\t\t\t\t\tt.Errorf(\"error mismatch: want %v, got %v\", tt.wantErr, err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif rest != tt.wantRest {\n\t\t\t\tt.Errorf(\"rest mismatch: want %q, got %q\", tt.wantRest, rest)\n\t\t\t}\n\t\t\t// Compare got and tt.want\n\t\t\t// TODO: Implement deep comparison for *Value\n\t\t})\n\t}\n}","e32f3799b5fb1bcda0719fd195661530":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc Test_unescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello world\",\n\t\t\t},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"simple escape\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello\\\\tworld\",\n\t\t\t},\n\t\t\twant: \"hello\\tworld\",\n\t\t},\n\t\t{\n\t\t\tname: \"unicode escape\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello\\\\u0020world\",\n\t\t\t},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid unicode escape\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello\\\\u002world\",\n\t\t\t},\n\t\t\twant: \"hello\\\\u002world\",\n\t\t},\n\t\t{\n\t\t\tname: \"surrogate pair\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello\\\\uD83D\\\\uDE01world\",\n\t\t\t},\n\t\t\twant: \"helloüòÅworld\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid surrogate pair\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello\\\\uD83Dworld\",\n\t\t\t},\n\t\t\twant: \"hello\\\\uD83Dworld\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","e367c07855bfa56e25589782286ec8b7":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey   string\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Basic cases\n\t\t{`\"foo\"bar`, \"foo\", \"bar\", nil},\n\t\t{`\"fo\\\"o\"bar`, `fo\"o`, \"bar\", nil},\n\t\t{`\"foo\"`, \"foo\", \"\", nil},\n\t\t{`\"\"bar`, \"\", \"bar\", nil},\n\n\t\t// Escaped quotes\n\t\t{`\"foo\\\\\"bar\"baz`, `foo\\bar`, \"baz\", nil},\n\t\t{`\"foo\\\\\\\\\"bar\"baz`, `foo\\\\`, `bar\"baz`, nil},\n\t\t{`\"foo\\\"bar\"baz`, `foo\"bar`, \"baz\", nil},\n\t\t{`\"fo\\\\o\"bar`, `fo\\o`, \"bar\", nil},\n\t\t{`\"f\\\\oo\"bar`, `f\\oo`, \"bar\", nil},\n\t\t{`\"foo\\\\bar\"baz`, `foo\\bar`, \"baz\", nil},\n\n\t\t// Missing closing quote\n\t\t{`\"foobar`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo\\\"bar`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo\\\\\"bar`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\n\t\t// Empty strings\n\t\t{`\"\"`, \"\", \"\", nil},\n\t\t{`\"`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d:%s\", i, tt.input), func(t *testing.T) {\n\t\t\tkey, tail, err := parseRawString(tt.input)\n\t\t\tif key != tt.key || tail != tt.tail || (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = (%q, %q, %v), want (%q, %q, %v)\", tt.input, key, tail, err, tt.key, tt.tail, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}","e3b625c10b9083a177ee75bf2554ab5a":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ts     string\n\t\terr   error\n\t}{\n\t\t// Add test cases here\n\t\t{\n\t\t\tinput: \"[]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tinput: \"[1,2,3]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tinput: \"[1, 2,   3]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tinput: \" [1,2,3]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tinput: \"[1,2,3] \",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \" \",\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tinput: \"[[1,2],[3,4]]\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t\t\t\t{t: TypeNumber, s: \"4\"},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Error cases\n\t\t{\n\t\t\tinput: \"[\",\n\t\t\twant:  nil,\n\t\t\ts:     \"\",\n\t\t\terr:   fmt.Errorf(\"missing ']'\"),\n\t\t},\n\t\t{\n\t\t\tinput: \"[1,2,\",\n\t\t\twant:  nil,\n\t\t\ts:     \"\",\n\t\t\terr:   fmt.Errorf(\"unexpected end of array\"),\n\t\t},\n\t\t{\n\t\t\tinput: \"[1 2,3]\",\n\t\t\twant:  nil,\n\t\t\ts:     \"2,3]\",\n\t\t\terr:   fmt.Errorf(\"missing ',' after array value\"),\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseArray(tt.input, c, 0)\n\n\t\t\tif got == nil \u0026\u0026 tt.want == nil {\n\t\t\t\t// Both are nil, check the errors\n\t\t\t\tif (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err == nil) || (err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\t\tt.Errorf(\"expected error %v, got %v\", tt.err, err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t} else if got == nil || tt.want == nil {\n\t\t\t\t// One of them is nil, not expected\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.want, got)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif got.t != tt.want.t {\n\t\t\t\tt.Errorf(\"expected type %v, got %v\", tt.want.t, got.t)\n\t\t\t}\n\n\t\t\tif len(got.a) != len(tt.want.a) {\n\t\t\t\tt.Errorf(\"expected array length %d, got %d\", len(tt.want.a), len(got.a))\n\t\t\t}\n\n\t\t\tfor j := range got.a {\n\t\t\t\tif got.a[j].s != tt.want.a[j].s {\n\t\t\t\t\tt.Errorf(\"expected array element %d to be %s, got %s\", j, tt.want.a[j].s, got.a[j].s)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif s != tt.s {\n\t\t\t\tt.Errorf(\"expected remaining string to be %q, got %q\", tt.s, s)\n\t\t\t}\n\t\t})\n\t}\n}","e3eb0620aefa4f7a91429e17a5df1d87":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic escapes\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\t`, \"\\t\"},\n\t\t{`\\\\`, \"\\\\\"},\n\t\t{`\\\"`, \"\\\"\"},\n\t\t{`\\/`, \"/\"},\n\n\t\t// Unicode escapes\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A0`, \"\\u00A0\"},\n\t\t{`\\u20AC`, \"\\u20AC\"},\n\n\t\t// Surrogate pairs\n\t\t{`\\uD83D\\uDE02`, \"\\U0001F602\"},\n\n\t\t// Invalid escapes\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\uD800`, `\\uD800`},\n\t\t{`\\uD800\\u`, `\\uD800\\u`},\n\n\t\t// Mixed content\n\t\t{`Hello\\tworld\\n`, \"Hello\\tworld\\n\"},\n\t\t{`\"This is a string with \\\\ escapes\"`, \"\\\"This is a string with \\\\ escapes\\\"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}","e3f590dbf2ba58be97e9c05ed05fbb1a":"package fastjson\n\nimport \"testing\"\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tt    Type\n\t\twant string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.want, func(t *testing.T) {\n\t\t\tif got := tt.t.String(); got != tt.want {\n\t\t\t\tt.Errorf(\"Type.String() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","e51e94608dd11bf35b4e80233aad4416":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"raw string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"raw string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"1234\",\n\t\t\t},\n\t\t\twant: []byte(\"1234\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"string\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1234\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"[\\\"string\\\",1234]\"),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"string\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"string\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"number\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"1234\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"{\\\"string\\\":\\\"string\\\",\\\"number\\\":1234}\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif string(got) != string(tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", string(got), string(tt.want))\n\t\t\t}\n\t\t})\n\t}\n}","e5485be886fbf998b404fd9392355eb6":"package fastjson\n\nimport \"testing\"\n\nfunc TestValue_GetFloat64(t *testing.T) {\n\tvar tests = []struct {\n\t\tname     string\n\t\tjson     string\n\t\targs     []string\n\t\twantRes  float64\n\t\twantFail bool\n\t}{\n\t\t{\n\t\t\tname:     \"empty_object\",\n\t\t\tjson:     `{}`,\n\t\t\targs:     []string{\"non\", \"existing\", \"key\"},\n\t\t\twantRes:  0,\n\t\t\twantFail: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"simple_object\",\n\t\t\tjson:     `{\"test\":12.34}`,\n\t\t\targs:     []string{\"test\"},\n\t\t\twantRes:  12.34,\n\t\t\twantFail: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"nested_object\",\n\t\t\tjson:     `{\"parent\":{\"child\":-5.67}}`,\n\t\t\targs:     []string{\"parent\", \"child\"},\n\t\t\twantRes:  -5.67,\n\t\t\twantFail: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array_element\",\n\t\t\tjson:     `{\"array\":[1,2,3.14,4]}`,\n\t\t\targs:     []string{\"array\", \"2\"},\n\t\t\twantRes:  3.14,\n\t\t\twantFail: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"non_numeric_value\",\n\t\t\tjson:     `{\"key\":\"value\"}`,\n\t\t\targs:     []string{\"key\"},\n\t\t\twantRes:  0,\n\t\t\twantFail: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tvar p Parser\n\t\t\tv, err := p.Parse(tt.json)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Parse error: %v\", err)\n\t\t\t}\n\n\t\t\tgotRes := v.GetFloat64(tt.args...)\n\t\t\tif gotRes != tt.wantRes {\n\t\t\t\tt.Errorf(\"GetFloat64() = %v, want %v\", gotRes, tt.wantRes)\n\t\t\t}\n\t\t})\n\t}\n}\n","e5859f88ecff2e15e312b6c54fde32c3":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"raw string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"raw string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"1234\",\n\t\t\t},\n\t\t\twant: []byte(\"1234\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif string(got) != string(tt.want) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","e59539ec2cf73eea40662f8b045e72c5":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_Visit(t *testing.T) {\n\ttype args struct {\n\t\to *Object\n\t\tf func(key []byte, v *Value)\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\to: \u0026Object{},\n\t\t\t\tf: func(key []byte, v *Value) {},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\to: \u0026Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tf: func(key []byte, v *Value) {},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\ttt.args.o.Visit(tt.args.f)\n\t\t})\n\t}\n}\n","e68dfded8d2b26a44da71ff5e78c83dd":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantN    string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Valid numbers\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"123.456\", \"123.456\", \"\", nil},\n\t\t{\"1.2e3\", \"1.2e3\", \"\", nil},\n\t\t{\"1.2E-3\", \"1.2E-3\", \"\", nil},\n\t\t{\"+123\", \"+123\", \"\", nil},\n\n\t\t// Valid numbers with trailing characters\n\t\t{\"123a\", \"123\", \"a\", nil},\n\t\t{\"-123 \", \"-123\", \" \", nil},\n\t\t{\"123.456,\", \"123.456\", \",\", nil},\n\n\t\t// Invalid numbers\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t\t{\"a\", \"\", \"a\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\"-\", \"\", \"-\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t\t{\"+\", \"\", \"+\", fmt.Errorf(\"unexpected char: %q\", \"+\")},\n\n\t\t// Special cases: \"inf\", \"Inf\", \"iNf\", etc.\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"Inf\", \"Inf\", \"\", nil},\n\t\t{\"inF\", \"inF\", \"\", nil},\n\t\t{\"INf\", \"INf\", \"\", nil},\n\t\t{\"InF\", \"InF\", \"\", nil},\n\t\t{\"INF\", \"INF\", \"\", nil},\n\t\t{\"infinity\", \"inf\", \"inity\", nil}, // Should only parse \"inf\"\n\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"+inf\", \"+inf\", \"\", nil},\n\t\t{\" inf\", \"inf\", \"\", nil}, // Leading space is not part of the number\n\n\t\t// Special cases: \"nan\", \"NaN\", \"nAn\", etc.\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"NaN\", \"NaN\", \"\", nil},\n\t\t{\"naN\", \"naN\", \"\", nil},\n\t\t{\"NAN\", \"NAN\", \"\", nil},\n\t\t{\"Nan\", \"Nan\", \"\", nil},\n\t\t{\"nAN\", \"nAN\", \"\", nil},\n\t\t{\"+nan\", \"+nan\", \"\", nil},\n\t\t{\"-nan\", \"-nan\", \"\", nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d:%s\", i, tt.input), func(t *testing.T) {\n\t\t\tgotN, gotTail, gotErr := parseRawNumber(tt.input)\n\n\t\t\tif gotN != tt.wantN {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got number = %q, want %q\", tt.input, gotN, tt.wantN)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got tail = %q, want %q\", tt.input, gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif gotErr == nil \u0026\u0026 tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got err = nil, want %v\", tt.input, tt.wantErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr == nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got err = %v, want nil\", tt.input, gotErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got err = %v, want %v\", tt.input, gotErr, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}\n","e6b2976f720156be6211fd77b2f75c07":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv:    \u0026Value{t: typeRawString, s: \"raw string\"},\n\t\t\twant: []byte(`\"raw string\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv:    \u0026Value{t: TypeString, s: \"string\"},\n\t\t\twant: []byte(`\"string\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv:    \u0026Value{t: TypeNumber, s: \"1234\"},\n\t\t\twant: []byte(`1234`),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv:    \u0026Value{t: TypeTrue},\n\t\t\twant: []byte(`true`),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv:    \u0026Value{t: TypeFalse},\n\t\t\twant: []byte(`false`),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv:    \u0026Value{t: TypeNull},\n\t\t\twant: []byte(``),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeString, s: \"string1\"},\n\t\t\t\t{t: TypeString, s: \"string2\"},\n\t\t\t}},\n\t\t\twant: []byte(`[\"string1\",\"string2\"]`),\n\t\t},\n\t\t// TODO: add test cases for TypeObject\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif string(got) != string(tt.want) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %v, want %v\", string(got), string(tt.want))\n\t\t\t}\n\t\t})\n\t}\n}\n","e6cb490bb2c0d83ed347c3d9f08ba14a":"package fastjson\n\nimport \"testing\"\n\nfunc TestSkipWS(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  string\n\t}{\n\t\t{\"  foo\", \"foo\"},\n\t\t{\"\\n\\tbar\", \"bar\"},\n\t\t{\" \\r\\nbaz\", \"baz\"},\n\t\t{\"qux\", \"qux\"},\n\t\t{\"\", \"\"},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tgot := skipWS(tt.input)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"skipWS(%q) = %q, want %q\", tt.input, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","e7400b10fb6d7115b93dba7c2dfd9129":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic escapes\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\t`, \"\\t\"},\n\t\t{`\\\\`, \"\\\\\"},\n\t\t{`\\\"`, \"\\\"\"},\n\t\t{`\\/`, \"/\"},\n\n\t\t// Unicode escapes\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A0`, \"\\u00A0\"},\n\t\t{`\\uFFFF`, \"\\uFFFF\"},\n\n\t\t// Surrogate pairs\n\t\t{`\\uD83D\\uDE01`, \"\\U0001F601\"},\n\n\t\t// Invalid escapes\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u`, `\\u`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\uD800`, `\\uD800`},\n\t\t{`\\uD800\\u`, `\\uD800\\u`},\n\t\t{`\\uD800\\u123`, `\\uD800\\u123`},\n\n\t\t// Mixed content\n\t\t{`Hello\\tworld\\n`, \"Hello\\tworld\\n\"},\n\t\t{`\\u0041\\u0020\\u0073\\u0074\\u0072\\u0069\\u006e\\u0067`, \"A string\"},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.input, func(t *testing.T) {\n\t\t\tactual := unescapeStringBestEffort(tc.input)\n\t\t\tif actual != tc.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", tc.input, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}","e74702fd6fc7d1ac731ed0c5591cd278":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantJSON string\n\t\twantErr  error\n\t}{\n\t\t{\n\t\t\tname:     \"empty object\",\n\t\t\tinput:    \"{}\",\n\t\t\twantJSON: `{}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"simple object\",\n\t\t\tinput:    `{\"foo\": \"bar\"}`,\n\t\t\twantJSON: `{\"foo\":\"bar\"}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"nested object\",\n\t\t\tinput:    `{\"foo\": {\"bar\": \"baz\"}}`,\n\t\t\twantJSON: `{\"foo\":{\"bar\":\"baz\"}}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"object with multiple keys\",\n\t\t\tinput:    `{\"foo\": \"bar\", \"baz\": 123}`,\n\t\t\twantJSON: `{\"foo\":\"bar\",\"baz\":123}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"object with escaped characters\",\n\t\t\tinput:    `{\"foo\": \"bar\\\"baz\", \"baz\": \"qux\\nquux\"}`,\n\t\t\twantJSON: `{\"foo\":\"bar\\\"baz\",\"baz\":\"qux\\nquux\"}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid object: missing closing brace\",\n\t\t\tinput:    `{\"foo\": \"bar\"`,\n\t\t\twantErr: fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid object: missing colon\",\n\t\t\tinput:    `{\"foo\" \"bar\"}`,\n\t\t\twantErr: fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid object: missing comma\",\n\t\t\tinput:    `{\"foo\": \"bar\" \"baz\": 123}`,\n\t\t\twantErr: fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseObject(tt.input, c, 0)\n\n\t\t\tif tt.wantErr != nil {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"parseObject() error = nil, wantErr %v\", tt.wantErr)\n\t\t\t\t} else if err.Error() != tt.wantErr.Error() {\n\t\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr nil\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif s != \"\" {\n\t\t\t\tt.Errorf(\"parseObject() remaining string = %q, want empty string\", s)\n\t\t\t}\n\n\t\t\tgotJSON := got.MarshalTo(nil)\n\t\t\tif string(gotJSON) != tt.wantJSON {\n\t\t\t\tt.Errorf(\"parseObject() got = %s, want %s\", gotJSON, tt.wantJSON)\n\t\t\t}\n\t\t})\n\t}\n}\n","e7490200a8c15ff50bab2c7d5fde9cac":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey   string\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Basic cases\n\t\t{`\"foo\"bar`, \"foo\", \"bar\", nil},\n\t\t{`\"fo\\\"o\"bar`, `fo\"o`, \"bar\", nil},\n\t\t{`\"foo\" bar`, \"foo\", \" bar\", nil},\n\n\t\t// Escaped quotes\n\t\t{`\"foo\\\\\"bar\"baz`, `foo\\bar`, \"baz\", nil},\n\t\t{`\"foo\\\\\\\\\"bar\"baz`, `foo\\\\`, `bar\"baz`, nil},\n\n\t\t// Missing closing quote\n\t\t{`\"foo`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo\"bar\"`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\n\t\t// Empty strings\n\t\t{`\"\"bar`, \"\", \"bar\", nil},\n\t\t{`\"foo\"\"\"bar`, \"foo\", `\"bar`, nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d:%s\", i, tt.input), func(t *testing.T) {\n\t\t\tkey, tail, err := parseRawString(tt.input)\n\t\t\tif key != tt.key || tail != tt.tail || !errorEqual(err, tt.err) {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = (%q, %q, %v), want (%q, %q, %v)\", tt.input, key, tail, err, tt.key, tt.tail, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc errorEqual(e1, e2 error) bool {\n\tif e1 == nil \u0026\u0026 e2 == nil {\n\t\treturn true\n\t}\n\tif e1 == nil || e2 == nil {\n\t\treturn false\n\t}\n\treturn e1.Error() == e2.Error()\n}\n","e783a3e5d0076d408007be0cbdc07566":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_reset(t *testing.T) {\n\to := \u0026Object{\n\t\tkvs: []kv{\n\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t},\n\t\tkeysUnescaped: true,\n\t}\n\n\to.reset()\n\n\tif len(o.kvs) != 0 {\n\t\tt.Errorf(\"Expected kvs to be empty after reset, got %v\", o.kvs)\n\t}\n\n\tif o.keysUnescaped != false {\n\t\tt.Errorf(\"Expected keysUnescaped to be false after reset, got %v\", o.keysUnescaped)\n\t}\n}","e7853b1995be2a7e0f2c932045cca477":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Empty string\n\t\t{\"\", nil, \"\", fmt.Errorf(\"cannot parse empty string\")},\n\t\t// Invalid JSON\n\t\t{\"{\", nil, \"{\", fmt.Errorf(\"cannot parse object: unexpected EOF\")},\n\t\t// Object\n\t\t{`{\"foo\":\"bar\"}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: typeRawString, s: \"bar\"}}}}}, \"\", nil},\n\t\t// Array\n\t\t{`[1,2,3]`, \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}}, \"\", nil},\n\t\t// String\n\t\t{`\"hello\"`, \u0026Value{t: typeRawString, s: \"hello\"}, \"\", nil},\n\t\t// True\n\t\t{\"true\", valueTrue, \"\", nil},\n\t\t// False\n\t\t{\"false\", valueFalse, \"\", nil},\n\t\t// Null\n\t\t{\"null\", valueNull, \"\", nil},\n\t\t// Number\n\t\t{\"123\", \u0026Value{t: TypeNumber, s: \"123\"}, \"\", nil},\n\t\t// NaN\n\t\t{\"NaN\", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"\", nil},\n\t\t// Number with tail\n\t\t{\"123 \", \u0026Value{t: TypeNumber, s: \"123\"}, \" \", nil},\n\t\t// Invalid value\n\t\t{\"invalid\", nil, \"invalid\", fmt.Errorf(\"unexpected value found: \\\"invalid\\\"\")},\n\t}\n\n\tc := \u0026cache{}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tgot, tail, err := parseValue(tt.input, c, 0)\n\t\t\tif (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, wantErr %v\", tt.input, err, tt.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"parseValue(%q) tail = %q, wantTail %q\", tt.input, tail, tt.tail)\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", tt.input, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.t == typeRawString {\n\t\treturn v1.s == v2.s\n\t}\n\tif v1.t == TypeNumber {\n\t\treturn v1.s == v2.s\n\t}\n\tif v1.t == TypeObject {\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\tif v1.t == TypeArray {\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\treturn false\n}","e83bb0b3a53e8c49660f6e11d35138f1":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ts     string\n\t\terr   error\n\t}{\n\t\t// Empty object\n\t\t{\n\t\t\tinput: \"{}\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Simple object\n\t\t{\n\t\t\tinput: `{\"key1\": \"value1\", \"key2\": 123}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Nested object\n\t\t{\n\t\t\tinput: `{\"key1\": {\"key2\": \"value2\"}, \"key3\": true}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{k: \"key3\", v: \u0026Value{t: TypeTrue}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Missing closing brace\n\t\t{\n\t\t\tinput: `{\"key1\": \"value1\"`,\n\t\t\twant:  nil,\n\t\t\ts:     `{\"key1\": \"value1\"`,\n\t\t\terr:   fmt.Errorf(`missing '}'`),\n\t\t},\n\t\t// Missing colon\n\t\t{\n\t\t\tinput: `{\"key1\" \"value1\"}`,\n\t\t\twant:  nil,\n\t\t\ts:     `\"value1\"}`,\n\t\t\terr:   fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t\t// Missing comma\n\t\t{\n\t\t\tinput: `{\"key1\": \"value1\" \"key2\": 123}`,\n\t\t\twant:  nil,\n\t\t\ts:     `\"key2\": 123}`,\n\t\t\terr:   fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\t\t// Invalid key\n\t\t{\n\t\t\tinput: `{key1: \"value1\"}`,\n\t\t\twant:  nil,\n\t\t\ts:     `key1: \"value1\"}`,\n\t\t\terr:   fmt.Errorf(`cannot find opening '\"\" for object key`),\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseObject(tt.input, c, 0)\n\t\t\tif fmt.Sprintf(\"%v\", err) != fmt.Sprintf(\"%v\", tt.err) {\n\t\t\t\tt.Errorf(\"parseObject(%s) error mismatch: got %v, want %v\", tt.input, err, tt.err)\n\t\t\t}\n\t\t\tif s != tt.s {\n\t\t\t\tt.Errorf(\"parseObject(%s) remaining string mismatch: got %q, want %q\", tt.input, s, tt.s)\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject(%s) value mismatch:\\ngot  %v\\nwant %v\", tt.input, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeTrue, TypeFalse, TypeNull:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n","e897c35ec322a812216cfd3f5ff03ffd":"package fastjson\n\nimport \"testing\"\n\nfunc TestValue_GetInt(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tjson  string\n\t\tkeys  []string\n\t\twant  int\n\t\twant1 bool\n\t}{\n\t\t{\n\t\t\tname:  \"simple\",\n\t\t\tjson:  `{\"foo\":123}`,\n\t\t\tkeys:  []string{\"foo\"},\n\t\t\twant:  123,\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"nested\",\n\t\t\tjson:  `{\"foo\":{\"bar\":123}}`,\n\t\t\tkeys:  []string{\"foo\", \"bar\"},\n\t\t\twant:  123,\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array\",\n\t\t\tjson:  `{\"foo\":[123,456]}`,\n\t\t\tkeys:  []string{\"foo\", \"1\"},\n\t\t\twant:  456,\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array decimal\",\n\t\t\tjson:  `{\"foo\":[123,456]}`,\n\t\t\tkeys:  []string{\"foo\", \"1.0\"},\n\t\t\twant:  456,\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"non-existing key\",\n\t\t\tjson:  `{\"foo\":123}`,\n\t\t\tkeys:  []string{\"bar\"},\n\t\t\twant:  0,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"invalid value type\",\n\t\t\tjson:  `{\"foo\":\"bar\"}`,\n\t\t\tkeys:  []string{\"foo\"},\n\t\t\twant:  0,\n\t\t\twant1: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tvar p Parser\n\t\t\tv, err := p.Parse(tt.json)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Parse() error = %v, wantErr %v\", err, nil)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgot := v.GetInt(tt.keys...)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"GetInt() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","ea1af124e3f14fce95ff74dac77cb87e":"package fastjson\n\nimport \"testing\"\n\nfunc TestObject_getKV(t *testing.T) {\n\to := Object{}\n\t// Test adding a new kv when the capacity is greater than the length\n\tkv1 := o.getKV()\n\tkv1.k = \"key1\"\n\tkv1.v = \u0026Value{t: TypeString, s: \"value1\"}\n\tif len(o.kvs) != 1 || o.kvs[0].k != \"key1\" || o.kvs[0].v.s != \"value1\" {\n\t\tt.Errorf(\"Failed to add kv when capacity is greater than length\")\n\t}\n\n\t// Test adding a new kv when the capacity is equal to the length\n\tkv2 := o.getKV()\n\tkv2.k = \"key2\"\n\tkv2.v = \u0026Value{t: TypeNumber, s: \"123\"}\n\tif len(o.kvs) != 2 || o.kvs[1].k != \"key2\" || o.kvs[1].v.s != \"123\" {\n\t\tt.Errorf(\"Failed to add kv when capacity is equal to length\")\n\t}\n}","eb071f816583aa7cfc1e96a4582d81f2":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantN    string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Basic cases\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"123.456\", \"123.456\", \"\", nil},\n\t\t{\"-123.456\", \"-123.456\", \"\", nil},\n\t\t{\"1.23e4\", \"1.23e4\", \"\", nil},\n\t\t{\"-1.23e-4\", \"-1.23e-4\", \"\", nil},\n\n\t\t// Trailing characters\n\t\t{\"123a\", \"123\", \"a\", nil},\n\t\t{\"123.456xyz\", \"123.456\", \"xyz\", nil},\n\n\t\t// Invalid numbers\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t\t{\"+\", \"\", \"+\", fmt.Errorf(\"unexpected char: %q\", \"+\")},\n\t\t(\"-\", \"\", \"-\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t\t(\".123\", \"\", \".123\", fmt.Errorf(\"unexpected char: %q\", \".\")},\n\t\t{\"1.2.3\", \"1.2\", \".3\", nil},\n\n\t\t// Special values\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"+inf\", \"+inf\", \"\", nil},\n\t\t{\"InF\", \"InF\", \"\", nil},\n\t\t{\"Infinity\", \"Infinity\", \"\", nil}, // This should be an error, but the current implementation allows it\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"+nan\", \"+nan\", \"\", nil},\n\t\t{\"-nan\", \"-nan\", \"\", nil},\n\t\t{\"NAN\", \"NAN\", \"\", nil},\n\n\t\t// Trailing special values\n\t\t{\"123inf\", \"123\", \"inf\", nil},\n\t\t{\"123nan\", \"123\", \"nan\", nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tgotN, gotTail, gotErr := parseRawNumber(tt.input)\n\t\t\tif gotN != tt.wantN || gotTail != tt.wantTail || (gotErr != nil \u0026\u0026 tt.wantErr == nil) || (gotErr == nil \u0026\u0026 tt.wantErr != nil) || (gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error()) {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = (%q, %q, %v), want (%q, %q, %v)\", tt.input, gotN, gotTail, gotErr, tt.wantN, tt.wantTail, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","eb0bed6b248796ac2aa5e59b1e4f4066":"package fastjson\n\nimport \"testing\"\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tt    Type\n\t\twant string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\tfor i, tt := range tests {\n\t\tgot := tt.t.String()\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"test[%d]: String() = %q, want %q\", i, got, tt.want)\n\t\t}\n\t}\n}","eb2f7a09786ed520e3c0026730fb8e56":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"raw string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"raw string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"12345\",\n\t\t\t},\n\t\t\twant: []byte(\"12345\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif string(got) != string(tt.want) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","eb885289b7d2fd99a584dd8528e7a597":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantStr  string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Basic cases\n\t\t{`\"foo\"bar`, `foo`, `bar`, nil},\n\t\t{`\"fo\\\"o\"bar`, `fo\\\"o`, `bar`, nil},\n\t\t{`\"foo\"`, `foo`, ``, nil},\n\t\t{`\"foo`, ``, ``, fmt.Errorf(`missing closing '\"'`)},\n\n\t\t// Escaped quotes\n\t\t{`\"fo\\\\o\"bar`, `fo\\\\o`, `bar`, nil},\n\t\t{`\"fo\\\\\\\\o\"bar`, `fo\\\\\\\\o`, `bar`, nil},\n\t\t{`\"fo\\\\\\\"o\"bar`, `fo\\\\\\\"o`, `bar`, nil},\n\t\t{`\"fo\\\\\\o\"bar`, `fo\\\\\\o`, `bar`, nil},\n\n\t\t// Empty strings\n\t\t{`\"\"bar`, ``, `bar`, nil},\n\t\t{`\"\\\\\"bar`, `\\\\`, `bar`, nil},\n\t\t{`\"\\\\\\\"\"bar`, `\\\\\"`, `bar`, nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test %d\", i), func(t *testing.T) {\n\t\t\tgotStr, gotTail, gotErr := parseRawString(tt.input)\n\t\t\tif gotStr != tt.wantStr || gotTail != tt.wantTail || (gotErr != nil \u0026\u0026 tt.wantErr == nil) || (gotErr == nil \u0026\u0026 tt.wantErr != nil) || (gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error()) {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = (%q, %q, %v), want (%q, %q, %v)\", tt.input, gotStr, gotTail, gotErr, tt.wantStr, tt.wantTail, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}\n","ebf2cbcce69e6375a3f5bae521ef8b70":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantN    string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Basic cases\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"123.456\", \"123.456\", \"\", nil},\n\t\t{\"1.2e3\", \"1.2e3\", \"\", nil},\n\t\t{\"1.2E-3\", \"1.2E-3\", \"\", nil},\n\n\t\t// Trailing characters\n\t\t{\"123a\", \"123\", \"a\", nil},\n\t\t{\"123.456 \", \"123.456\", \" \", nil},\n\n\t\t// Invalid numbers\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t\t{\"+\", \"\", \"+\", fmt.Errorf(\"unexpected char: %q\", \"+\")},\n\t\t(\"-\", \"\", \"-\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t\t(\".123\", \"\", \".123\", fmt.Errorf(\"unexpected char: %q\", \".\")},\n\n\t\t// Special values\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"+inf\", \"+inf\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"InF\", \"InF\", \"\", nil},\n\t\t{\"inF\", \"inF\", \"\", nil},\n\t\t{\"123inf\", \"123\", \"inf\", nil},\n\t\t{\"inf123\", \"inf\", \"123\", nil},\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"+nan\", \"+nan\", \"\", nil},\n\t\t{\"-nan\", \"-nan\", \"\", nil},\n\t\t{\"123nan\", \"123\", \"nan\", nil},\n\t\t{\"nan123\", \"nan\", \"123\", nil},\n\n\t\t// Invalid special values\n\t\t{\"in\", \"\", \"in\", fmt.Errorf(\"unexpected char: %q\", \"i\")},\n\t\t{\"na\", \"\", \"na\", fmt.Errorf(\"unexpected char: %q\", \"n\")},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tgotN, gotTail, gotErr := parseRawNumber(tt.input)\n\t\t\tif gotN != tt.wantN {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got number = %q, want %q\", tt.input, gotN, tt.wantN)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got tail = %q, want %q\", tt.input, gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif gotErr == nil \u0026\u0026 tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got no error, want %v\", tt.input, tt.wantErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr == nil {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got error = %v, want no error\", tt.input, gotErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) got error = %v, want %v\", tt.input, gotErr, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","ebf877e63e90ebbf0504c5ddb8afea58":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Empty string\n\t\t{\"\", nil, \"\", fmt.Errorf(\"cannot parse empty string\")},\n\t\t// Object\n\t\t{`{\"foo\":\"bar\"}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: typeRawString, s: \"bar\"}}}}}}, \"\", nil},\n\t\t// Array\n\t\t{`[1,2,3]`, \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}}, \"\", nil},\n\t\t// String\n\t\t{`\"hello\"`, \u0026Value{t: typeRawString, s: \"hello\"}, \"\", nil},\n\t\t// True\n\t\t{\"true\", valueTrue, \"\", nil},\n\t\t// False\n\t\t{\"false\", valueFalse, \"\", nil},\n\t\t// Null\n\t\t{\"null\", valueNull, \"\", nil},\n\t\t// Number\n\t\t{\"123\", \u0026Value{t: TypeNumber, s: \"123\"}, \"\", nil},\n\t\t// NaN\n\t\t{\"NaN\", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"\", nil},\n\t\t// Invalid value\n\t\t{\"invalid\", nil, \"invalid\", fmt.Errorf(\"unexpected value found: %q\", \"invalid\")},\n\t}\n\n\tc := \u0026cache{}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test %d\", i), func(t *testing.T) {\n\t\t\tgot, tail, err := parseValue(tt.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tt.err == nil {\n\t\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.err)\n\t\t\t\t} else if err.Error() != tt.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif tt.err != nil {\n\t\t\t\tt.Errorf(\"parseValue() error = nil, wantErr %v\", tt.err)\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"parseValue() tail = %v, want %v\", tail, tt.tail)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.t == typeRawString {\n\t\treturn v1.s == v2.s\n\t}\n\tif v1.t == TypeNumber {\n\t\treturn v1.s == v2.s\n\t}\n\tif v1.t == TypeObject {\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\tif v1.t == TypeArray {\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\treturn false\n}","ec026c231b0d836d21a262081a7a59a0":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetObject(t *testing.T) {\n\tt.Run(\"simple object\", func(t *testing.T) {\n\t\tv, _ := Parse(`{\"foo\": \"bar\"}`)\n\t\to := v.GetObject(\"foo\")\n\t\tif o == nil {\n\t\t\tt.Fatal(\"o is nil\")\n\t\t}\n\t\tif o.kvs[0].k != \"foo\" {\n\t\t\tt.Fatalf(\"unexpected key: %s\", o.kvs[0].k)\n\t\t}\n\t\tif o.kvs[0].v.t != TypeString {\n\t\t\tt.Fatalf(\"unexpected type: %v\", o.kvs[0].v.t)\n\t\t}\n\t\tif string(o.kvs[0].v.s) != \"bar\" {\n\t\t\tt.Fatalf(\"unexpected value: %s\", o.kvs[0].v.s)\n\t\t}\n\t})\n\n\tt.Run(\"nested object\", func(t *testing.T) {\n\t\tv, _ := Parse(`{\"foo\": {\"bar\": \"baz\"}}`)\n\t\to := v.GetObject(\"foo\", \"bar\")\n\t\tif o == nil {\n\t\t\tt.Fatal(\"o is nil\")\n\t\t}\n\t\tif o.kvs[0].k != \"bar\" {\n\t\t\tt.Fatalf(\"unexpected key: %s\", o.kvs[0].k)\n\t\t}\n\t\tif o.kvs[0].v.t != TypeString {\n\t\t\tt.Fatalf(\"unexpected type: %v\", o.kvs[0].v.t)\n\t\t}\n\t\tif string(o.kvs[0].v.s) != \"baz\" {\n\t\t\tt.Fatalf(\"unexpected value: %s\", o.kvs[0].v.s)\n\t\t}\n\t})\n\n\tt.Run(\"array index\", func(t *testing.T) {\n\t\tv, _ := Parse(`{\"foo\": [{\"bar\": \"baz\"}]}`)\n\t\to := v.GetObject(\"foo\", \"0\", \"bar\")\n\t\tif o == nil {\n\t\t\tt.Fatal(\"o is nil\")\n\t\t}\n\t\tif o.kvs[0].k != \"bar\" {\n\t\t\tt.Fatalf(\"unexpected key: %s\", o.kvs[0].k)\n\t\t}\n\t\tif o.kvs[0].v.t != TypeString {\n\t\t\tt.Fatalf(\"unexpected type: %v\", o.kvs[0].v.t)\n\t\t}\n\t\tif string(o.kvs[0].v.s) != \"baz\" {\n\t\t\tt.Fatalf(\"unexpected value: %s\", o.kvs[0].v.s)\n\t\t}\n\t})\n\n\tt.Run(\"non-existing key\", func(t *testing.T) {\n\t\tv, _ := Parse(`{\"foo\": \"bar\"}`)\n\t\to := v.GetObject(\"baz\")\n\t\tif o != nil {\n\t\t\tt.Fatal(\"o is not nil\")\n\t\t}\n\t})\n\n\tt.Run(\"invalid value type\", func(t *testing.T) {\n\t\tv, _ := Parse(`\"foo\"`)\n\t\to := v.GetObject(\"bar\")\n\t\tif o != nil {\n\t\t\tt.Fatal(\"o is not nil\")\n\t\t}\n\t})\n}","ecb9681ec50f26f5fdb26414aabd3121":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic escapes\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\t`, \"\\t\"},\n\t\t{`\\\\`, \"\\\\\"},\n\t\t{`\\/`, \"/\"},\n\t\t{`\\\"`, \"\\\"\"},\n\t\t{`\\b`, \"\\b\"},\n\t\t{`\\f`, \"\\f\"},\n\t\t{`\\r`, \"\\r\"},\n\n\t\t// Unicode escapes\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A0`, \"\\u00A0\"},\n\t\t{`\\uFFFF`, \"\\uFFFF\"},\n\n\t\t// Surrogate pairs\n\t\t{`\\uD83D\\uDE02`, \"\\U0001F602\"},\n\n\t\t// Invalid escapes\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\uD800`, `\\uD800`},\n\t\t{`\\uD800\\u`, `\\uD800\\u`},\n\n\t\t// Mixed strings\n\t\t{`Hello\\tworld\\n`, \"Hello\\tworld\\n\"},\n\t\t{`\\u0041\\u0020\\u0073\\u0074\\u0072\\u0069\\u006e\\u0067`, \"A string\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}","ed2bbe5d8b0addacee0007eb6c33fdd0":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tt    Type\n\t\twant string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\tfor i, tt := range tests {\n\t\tif got := tt.t.String(); got != tt.want {\n\t\t\tt.Errorf(\"test %d: String() = %q, want %q\", i, got, tt.want)\n\t\t}\n\t}\n}","ed60335579948b7d973b557c9487f30f":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestValue_Uint64(t *testing.T) {\n\ttests := []struct {\n\t\tinput       string\n\t\twantUint64 uint64\n\t\twantErr    error\n\t}{\n\t\t{`{\"foo\":123}`, 0, fmt.Errorf(\"value doesn't contain number; it contains object\")},\n\t\t{`{\"foo\":\"bar\"}`, 0, fmt.Errorf(\"value doesn't contain number; it contains string\")},\n\t\t{`{\"foo\":[1,2,3]}`, 0, fmt.Errorf(\"value doesn't contain number; it contains array\")},\n\t\t{`{\"foo\":true}`, 0, fmt.Errorf(\"value doesn't contain number; it contains true\")},\n\t\t{`{\"foo\":false}`, 0, fmt.Errorf(\"value doesn't contain number; it contains false\")},\n\t\t{`{\"foo\":null}`, 0, fmt.Errorf(\"value doesn't contain number; it contains null\")},\n\t\t{`{\"foo\":123.45}`, 123, nil},\n\t\t{`{\"foo\":123}`, 123, nil},\n\t\t{`{\"foo\":\"123\"}`, 123, nil},\n\t}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tp := Parser{}\n\t\t\tv, err := p.Parse(tt.input)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"failed to parse input: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgot, err := v.Get(\"foo\").Uint64()\n\t\t\tif got != tt.wantUint64 {\n\t\t\t\tt.Errorf(\"want %v, got %v\", tt.wantUint64, got)\n\t\t\t}\n\t\t\tif fmt.Sprintf(\"%v\", err) != fmt.Sprintf(\"%v\", tt.wantErr) {\n\t\t\t\tt.Errorf(\"want error %v, got %v\", tt.wantErr, err)\n\t\t\t}\n\t\t})\n\t}\n}","ed7f1f9db9ebf8c730e6dec6ab9e2901":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\ts       string\n\t\twant    *Value\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tp := \u0026Parser{}\n\t\t\tgot, err := p.Parse(tt.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Parser.Parse() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != nil {\n\t\t\t\tif got.Type() == TypeObject {\n\t\t\t\t\tif !got.Object().equal(tt.want.Object()) {\n\t\t\t\t\t\tt.Errorf(\"Parser.Parse() = %v, want %v\", got, tt.want)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif got.String() != tt.want.String() {\n\t\t\t\t\t\tt.Errorf(\"Parser.Parse() = %v, want %v\", got, tt.want)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc (o *Object) equal(other *Object) bool {\n\tif o.Len() != other.Len() {\n\t\treturn false\n\t}\n\tfor _, kv := range o.kvs {\n\t\totherV := other.Get(kv.k)\n\t\tif otherV == nil {\n\t\t\treturn false\n\t\t}\n\t\tif kv.v.Type() != otherV.Type() {\n\t\t\treturn false\n\t\t}\n\t\tif kv.v.Type() == TypeString \u0026\u0026 kv.v.String() != otherV.String() {\n\t\t\treturn false\n\t\t}\n\t\tif kv.v.Type() == TypeNumber \u0026\u0026 kv.v.String() != otherV.String() {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","edc73e729f5fb16c77ddb02f2d62c7f4":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\t// Test cases for each supported type\n\ttests := []struct {\n\t\tname     string\n\t\tv        *Value\n\t\texpected []byte\n\t}{\n\t\t{\n\t\t\tname:     \"TypeRawString\",\n\t\t\tv:        \u0026Value{t: typeRawString, s: \"raw string\"},\n\t\t\texpected: []byte(\"\\\"raw string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"TypeObject\",\n\t\t\tv: \u0026Value{t: TypeObject, o: Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t},\n\t\t\t}},\n\t\t\texpected: []byte(\"{\\\"key1\\\":\\\"value1\\\",\\\"key2\\\":123}\"),\n\t\t},\n\t\t{\n\t\t\tname: \"TypeArray\",\n\t\t\tv: \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeString, s: \"value1\"},\n\t\t\t\t{t: TypeNumber, s: \"123\"},\n\t\t\t\t{t: TypeNull},\n\t\t\t}},\n\t\t\texpected: []byte(\"[\\\"value1\\\",123,null]\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeString\",\n\t\t\tv:        \u0026Value{t: TypeString, s: \"string value\"},\n\t\t\texpected: []byte(\"\\\"string value\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeNumber\",\n\t\t\tv:        \u0026Value{t: TypeNumber, s: \"123.456\"},\n\t\t\texpected: []byte(\"123.456\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeTrue\",\n\t\t\tv:        \u0026Value{t: TypeTrue},\n\t\t\texpected: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeFalse\",\n\t\t\tv:        \u0026Value{t: TypeFalse},\n\t\t\texpected: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeNull\",\n\t\t\tv:        \u0026Value{t: TypeNull},\n\t\t\texpected: []byte(\"null\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := make([]byte, 0, len(tt.expected))\n\t\t\tactual := tt.v.MarshalTo(dst)\n\t\t\tif string(actual) != string(tt.expected) {\n\t\t\t\tt.Errorf(\"Expected %q, got %q\", tt.expected, actual)\n\t\t\t}\n\t\t})\n\t}\n}","ee281fd673e0e5921d985e16d66274ec":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic escapes\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\t`, \"\\t\"},\n\t\t{`\\\\`, \"\\\\\"},\n\t\t{`\\\"`, \"\\\"\"},\n\t\t{`\\/`, \"/\"},\n\n\t\t// Unicode escapes\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u03c0`, \"œÄ\"},\n\t\t{`\\uFFFF`, \"\\uFFFF\"},\n\n\t\t// Surrogate pairs\n\t\t{`\\uD83D\\uDE02`, \"üòÇ\"},\n\n\t\t// Invalid escapes\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u123`, `\\u123`},\n\t\t{`\\uD800`, `\\uD800`}, // Missing low surrogate\n\t\t{`\\uDFFF`, `\\uDFFF`}, // Missing high surrogate\n\n\t\t// Mixed strings\n\t\t{`Hello\\tworld\\n`, \"Hello\\tworld\\n\"},\n\t\t{`\"This is a \\\\test\\\\\"`, \"\\\"This is a \\\\test\\\\\\\"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}","efa4903c7248777618b60131d2acc577":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic strings\n\t\t{\"hello\", \"hello\"},\n\t\t{\"world\", \"world\"},\n\n\t\t// Escaped characters\n\t\t{`\\\"`, `\"`},\n\t\t{`\\\\`, `\\`},\n\t\t{`\\/`, `/`},\n\t\t{`\\b`, \"\\b\"},\n\t\t{`\\f`, \"\\f\"},\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\r`, \"\\r\"},\n\t\t{`\\t`, \"\\t\"},\n\n\t\t// Unicode escape sequences\n\t\t{`\\u0020`, \" \"},\n\t\t{`\\u00A0`, \"\\u00A0\"},\n\t\t{`\\u20AC`, \"\\u20AC\"},\n\t\t{`\\uD83D\\uDE02`, \"\\U0001F602\"}, // Surrogate pair\n\n\t\t// Invalid escape sequences\n\t\t{`\\u`, `\\u`},\n\t\t{`\\u002`, `\\u002`},\n\t\t{`\\uD83D`, `\\uD83D`},\n\t\t{`\\uD83D\\u`, `\\uD83D\\u`},\n\t\t{`\\uD83D\\uDE0`, `\\uD83D\\uDE0`},\n\n\t\t// Mixed strings\n\t\t{`hello\\tworld`, \"hello\\tworld\"},\n\t\t{`\\u0041\\u0020\\u0062`, \"A b\"},\n\t\t{`\\uD83D\\uDE02\\uD83D\\uDE02`, \"\\U0001F602\\U0001F602\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}\n","f05845715af1ed66ea29327c8a4a23ec":"package fastjson\n\nimport \"testing\"\n\nfunc Test_cache_getValue(t *testing.T) {\n\tt.Run(\"empty cache\", func(t *testing.T) {\n\t\tc := \u0026cache{}\n\t\tv := c.getValue()\n\n\t\tif v == nil {\n\t\t\tt.Errorf(\"Expected a non-nil value, got nil\")\n\t\t}\n\n\t\tif len(c.vs) != 1 {\n\t\t\tt.Errorf(\"Expected cache length to be 1, got %d\", len(c.vs))\n\t\t}\n\t})\n\n\tt.Run(\"cache with existing values\", func(t *testing.T) {\n\t\tc := \u0026cache{\n\t\t\tvs: make([]Value, 5),\n\t\t}\n\t\tv := c.getValue()\n\n\t\tif v == nil {\n\t\t\tt.Errorf(\"Expected a non-nil value, got nil\")\n\t\t}\n\n\t\tif len(c.vs) != 6 {\n\t\t\tt.Errorf(\"Expected cache length to be 6, got %d\", len(c.vs))\n\t\t}\n\t})\n\n\tt.Run(\"cache with extra capacity\", func(t *testing.T) {\n\t\tc := \u0026cache{\n\t\t\tvs: make([]Value, 0, 10),\n\t\t}\n\t\tv := c.getValue()\n\n\t\tif v == nil {\n\t\t\tt.Errorf(\"Expected a non-nil value, got nil\")\n\t\t}\n\n\t\tif len(c.vs) != 1 {\n\t\t\tt.Errorf(\"Expected cache length to be 1, got %d\", len(c.vs))\n\t\t}\n\n\t\tif cap(c.vs) != 10 {\n\t\t\tt.Errorf(\"Expected cache capacity to be 10, got %d\", cap(c.vs))\n\t\t}\n\t})\n}\n","f0667afc84cf5da4eedaac8df46a195b":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantJSON string\n\t\twantErr  error\n\t}{\n\t\t{\n\t\t\tname:     \"empty object\",\n\t\t\tinput:    \"{}\",\n\t\t\twantJSON: `{}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"simple object\",\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\twantJSON: `{\"key\":\"value\"}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple key-value pairs\",\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantJSON: `{\"key1\":\"value1\",\"key2\":\"value2\"}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"nested object\",\n\t\t\tinput:    `{\"key1\": {\"key2\": \"value2\"}}`,\n\t\t\twantJSON: `{\"key1\":{\"key2\":\"value2\"}}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"object with array\",\n\t\t\tinput:    `{\"key1\": [\"value1\", \"value2\"]}`,\n\t\t\twantJSON: `{\"key1\":[\"value1\",\"value2\"]}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"object with different value types\",\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 123, \"key3\": true, \"key4\": null}`,\n\t\t\twantJSON: `{\"key1\":\"value1\",\"key2\":123,\"key3\":true,\"key4\":null}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing closing brace\",\n\t\t\tinput:    `{\"key\": \"value\"`,\n\t\t\twantErr: fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"missing opening quote for key\",\n\t\t\tinput:    \"{key: \\\"value\\\"}\",\n\t\t\twantErr: fmt.Errorf(`cannot find opening '\"\" for object key`),\n\t\t},\n\t\t{\n\t\t\tname:     \"missing closing quote for key\",\n\t\t\tinput:    `{\"key: \"value\"}`,\n\t\t\twantErr: fmt.Errorf(\"cannot parse object key: unexpected EOF\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"missing colon after key\",\n\t\t\tinput:    `{\"key\" \"value\"}`,\n\t\t\twantErr: fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"missing comma between key-value pairs\",\n\t\t\tinput:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseObject(tt.input, c, 0)\n\t\t\tif tt.wantErr != nil {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"parseObject() error = nil, wantErr %v\", tt.wantErr)\n\t\t\t\t} else if err.Error() != tt.wantErr.Error() {\n\t\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr nil\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif s != \"\" {\n\t\t\t\tt.Errorf(\"parseObject() remaining string = %q, want empty\", s)\n\t\t\t}\n\t\t\tgotJSON := got.MarshalTo(nil)\n\t\t\tif string(gotJSON) != tt.wantJSON {\n\t\t\t\tt.Errorf(\"parseObject() = %s, want %s\", gotJSON, tt.wantJSON)\n\t\t\t}\n\t\t})\n\t}\n}","f090bde8d09c3c16eb0203495d317a50":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ts     string\n\t\terr   error\n\t}{\n\t\t// Test cases here\n\t\t{\n\t\t\tinput: `{\"key\": \"value\"}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: \u0026Value{t: TypeString, s: \"value\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tinput: `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tinput: `{\"key\": \"value\"`,\n\t\t\twant:  nil,\n\t\t\ts:     `{\"key\": \"value\"`,\n\t\t\terr:   fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t\t{\n\t\t\tinput: `{key\": \"value\"}`,\n\t\t\twant:  nil,\n\t\t\ts:     `key\": \"value\"}`,\n\t\t\terr:   fmt.Errorf(`cannot find opening '\"\" for object key`),\n\t\t},\n\t\t{\n\t\t\tinput: `{\"key\": \"value\",}`,\n\t\t\twant:  nil,\n\t\t\ts:     `}`,\n\t\t\terr:   fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseObject(tt.input, c, 0)\n\n\t\t\tif tt.err != nil {\n\t\t\t\tif err == nil || err.Error() != tt.err.Error() {\n\t\t\t\t\tt.Errorf(\"Expected error %v, but got %v\", tt.err, err)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t\t\t}\n\t\t\t\tif s != tt.s {\n\t\t\t\t\tt.Errorf(\"Expected remaining string %q, but got %q\", tt.s, s)\n\t\t\t\t}\n\t\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\t\tt.Errorf(\"Test %d failed: Expected\\n\\t%v\\nbut got\\n\\t%v\", i, tt.want, got)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t// Add cases for other types as needed\n\tdefault:\n\t\treturn false\n\t}\n}","f131920ae34d0848f01ae4cda57a1695":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_getKV(t *testing.T) {\n\t// Create a new Object.\n\to := \u0026Object{}\n\n\t// Case 1: Empty kvs.\n\tkv1 := o.getKV()\n\tif kv1 == nil {\n\t\tt.Errorf(\"TestObject_getKV Case 1 Failed: Expected non-nil kv, got nil\")\n\t}\n\n\t// Case 2: Add one kv.\n\tkv2 := o.getKV()\n\tif kv2 == nil {\n\t\tt.Errorf(\"TestObject_getKV Case 2 Failed: Expected non-nil kv, got nil\")\n\t}\n\tif len(o.kvs) != 2 {\n\t\tt.Errorf(\"TestObject_getKV Case 2 Failed: Expected length of kvs to be 2, got %d\", len(o.kvs))\n\t}\n\n\t// Case 3: Reuse kv.\n\tkv3 := o.getKV()\n\tif kv3 == nil {\n\t\tt.Errorf(\"TestObject_getKV Case 3 Failed: Expected non-nil kv, got nil\")\n\t}\n\tif len(o.kvs) != 2 {\n\t\tt.Errorf(\"TestObject_getKV Case 3 Failed: Expected length of kvs to be 2, got %d\", len(o.kvs))\n\t}\n}","f1d4a580fbdf8c143281df8713dc7b06":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Empty string\n\t\t{\"\", nil, \"\", fmt.Errorf(\"cannot parse empty string\")},\n\t\t// Invalid JSON\n\t\t{\"{\", nil, \"\", fmt.Errorf(\"cannot parse object: missing '}'\")},\n\t\t// Object\n\t\t{`{\"foo\":\"bar\"}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: typeRawString, s: \"bar\"}}}}}, \"\", nil},\n\t\t// Array\n\t\t{`[1,2,3]`, \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}}, \"\", nil},\n\t\t// String\n\t\t{`\"hello\"`, \u0026Value{t: typeRawString, s: \"hello\"}, \"\", nil},\n\t\t// True\n\t\t{\"true\", valueTrue, \"\", nil},\n\t\t// False\n\t\t{\"false\", valueFalse, \"\", nil},\n\t\t// Null\n\t\t{\"null\", valueNull, \"\", nil},\n\t\t// Number\n\t\t{\"123\", \u0026Value{t: TypeNumber, s: \"123\"}, \"\", nil},\n\t\t// NaN\n\t\t{\"NaN\", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"\", nil},\n\t\t// Trailing whitespace\n\t\t{\"true \", valueTrue, \" \", nil},\n\t\t// Nested structures\n\t\t{`{\"foo\":[1,{\"bar\":\"baz\"}]}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeObject, o: Object{kvs: []kv{{k: \"bar\", v: \u0026Value{t: typeRawString, s: \"baz\"}}}}}}}}}}}, \"\", nil},\n\t}\n\n\tc := \u0026cache{}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tgot, tail, err := parseValue(tt.input, c, 0)\n\t\t\tif fmt.Sprintf(\"%v\", err) != fmt.Sprintf(\"%v\", tt.err) {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, want %v\", tt.input, err, tt.err)\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"parseValue(%q) tail = %q, want %q\", tt.input, tail, tt.tail)\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", tt.input, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.t == TypeObject {\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\tif v1.t == TypeArray {\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\treturn v1.s == v2.s\n}\n","f1fe434c7c5c4eee4f1b5f499d63ef52":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Test cases here\n\t\t{\n\t\t\tinput: `{}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{},\n\t\t\t},\n\t\t\ttail: \"\",\n\t\t\terr:  nil,\n\t\t},\n\t\t{\n\t\t\tinput: `[]`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\ttail: \"\",\n\t\t\terr:  nil,\n\t\t},\n\t\t{\n\t\t\tinput: `\"test\"`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"test\",\n\t\t\t},\n\t\t\ttail: \"\",\n\t\t\terr:  nil,\n\t\t},\n\t\t{\n\t\t\tinput: `true`,\n\t\t\twant:  valueTrue,\n\t\t\ttail:  \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `false`,\n\t\t\twant:  valueFalse,\n\t\t\ttail:  \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `null`,\n\t\t\twant:  valueNull,\n\t\t\ttail:  \"\",\n\t\t\terr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput: `123`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\ttail: \"\",\n\t\t\terr:  nil,\n\t\t},\n\t\t// Add more test cases for different scenarios\n\t}\n\n\tc := \u0026cache{}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tgot, tail, err := parseValue(tt.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tif tt.err == nil {\n\t\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif err.Error() != tt.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif got.Type() != tt.want.Type() {\n\t\t\t\t\tt.Errorf(\"parseValue() got type = %v, want %v\", got.Type(), tt.want.Type())\n\t\t\t\t}\n\t\t\t\tif got.String() != tt.want.String() {\n\t\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"parseValue() tail = %v, want %v\", tail, tt.tail)\n\t\t\t}\n\t\t})\n\t}\n}\n","f23543cc8a2f20450756636e16c7ac84":"package fastjson\n\nimport \"testing\"\n\nfunc TestObject_getKV(t *testing.T) {\n\to := Object{}\n\t// Test adding the first kv\n\tkv1 := o.getKV()\n\tif kv1 == nil {\n\t\tt.Errorf(\"Expected non-nil kv, got nil\")\n\t}\n\tif len(o.kvs) != 1 {\n\t\tt.Errorf(\"Expected length of kvs to be 1, got %d\", len(o.kvs))\n\t}\n\n\t// Test adding another kv\n\tkv2 := o.getKV()\n\tif kv2 == nil {\n\t\tt.Errorf(\"Expected non-nil kv, got nil\")\n\t}\n\tif len(o.kvs) != 2 {\n\t\tt.Errorf(\"Expected length of kvs to be 2, got %d\", len(o.kvs))\n\t}\n\n\t// Test reusing existing capacity\n\to.kvs = o.kvs[:1]\n\tkv3 := o.getKV()\n\tif kv3 == nil {\n\t\tt.Errorf(\"Expected non-nil kv, got nil\")\n\t}\n\tif len(o.kvs) != 2 {\n\t\tt.Errorf(\"Expected length of kvs to be 2, got %d\", len(o.kvs))\n\t}\n}","f42b808694ac056f3434ca48d3a97f42":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ts     string\n\t\terr   error\n\t}{\n\t\t// Empty object\n\t\t{\n\t\t\tinput: \"{}\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Simple object\n\t\t{\n\t\t\tinput: `{\"key1\": \"value1\", \"key2\": 123}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Nested object\n\t\t{\n\t\t\tinput: `{\"key1\": {\"nestedKey\": \"nestedValue\"}, \"key2\": [1,2,3]}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{k: \"nestedKey\", v: \u0026Value{t: TypeString, s: \"nestedValue\"}},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Invalid JSON\n\t\t{\n\t\t\tinput: `{\"key1\": \"value1\"`,\n\t\t\twant:  nil,\n\t\t\ts:     `{\"key1\": \"value1\"`,\n\t\t\terr:   fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseObject(tt.input, c, 0)\n\t\t\tif fmt.Sprintf(\"%v\", err) != fmt.Sprintf(\"%v\", tt.err) {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif s != tt.s {\n\t\t\t\tt.Errorf(\"parseObject() s = %s, want %s\", s, tt.s)\n\t\t\t}\n\t\t\tif fmt.Sprintf(\"%#v\", got) != fmt.Sprintf(\"%#v\", tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","f43be1abf4b1b32657a9009cca3aa5f7":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantStr  string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Basic cases\n\t\t{\"\\\"hello\\\"\", \"hello\", \"\", nil},\n\t\t{\"\\\"hello world\\\"\", \"hello world\", \"\", nil},\n\t\t{\"\\\"\\\"\", \"\", \"\", nil},\n\n\t\t// Escaped quotes\n\t\t{`\"hello\\\\\\\"world\\\"\", \"hello\\\\\\\"world\", \"\", nil`},\n\t\t{`\"hello\\\\\\\"\", \"hello\\\\\", \"\", nil`},\n\t\t{`\"\\\\\\\"\", \"\\\\\", \"\", nil`},\n\n\t\t// No closing quote\n\t\t{`\"hello`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"hello\\\\`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\n\t\t// Empty string\n\t\t{\"\", \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i), func(t *testing.T) {\n\t\t\tgotStr, gotTail, gotErr := parseRawString(tt.input)\n\t\t\tif gotStr != tt.wantStr {\n\t\t\t\tt.Errorf(\"parseRawString(%q) got str = %q, want %q\", tt.input, gotStr, tt.wantStr)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseRawString(%q) got tail = %q, want %q\", tt.input, gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif gotErr != nil \u0026\u0026 tt.wantErr == nil {\n\t\t\t\tt.Errorf(\"parseRawString(%q) got unexpected error: %v\", tt.input, gotErr)\n\t\t\t} else if gotErr == nil \u0026\u0026 tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"parseRawString(%q) expected error, but got nil\", tt.input)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"parseRawString(%q) got error = %v, want %v\", tt.input, gotErr, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","f4bcb92947eb553e92ce8b89aba331e3":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Basic strings\n\t\t{\"hello\", \"hello\"},\n\t\t{\"world\", \"world\"},\n\n\t\t// Escaped characters\n\t\t{`\\\"hello\\\"`, `\"hello\"`},\n\t\t{`\\\\world\\\\`, `\\world\\`},\n\t\t{`\\bfoo\\tbar\\nbaz`, \"\\bfoo\\tbar\\nbaz\"},\n\t\t{`\\u0020`, \" \"},\n\n\t\t// Invalid escape sequences\n\t\t{`\\z`, `\\z`},\n\t\t{`\\u002`, `\\u002`},\n\t\t{`\\u002x`, `\\u002x`},\n\n\t\t// Surrogate pairs\n\t\t{`\\uD83D\\uDE02`, \"üòÇ\"},\n\t\t{`\\uD83D\\uDE02\\uD83D\\uDE02`, \"üòÇüòÇ\"},\n\n\t\t// Mixed valid and invalid escape sequences\n\t\t{`hello\\nworld\\z`, \"hello\\nworld\\z\"},\n\t\t{`\\uD83D\\uDE02\\u002x`, \"üòÇ\\u002x\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q, want %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}\n","f4ec22d1a5a18bc89b39a41074f20a98":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput  string\n\t\tns     string\n\t\ttail   string\n\t\terrStr string\n\t}{\n\t\t{\"123\", \"123\", \"\", \"\"},\n\t\t{\"123.456\", \"123.456\", \"\", \"\"},\n\t\t{\"-123\", \"-123\", \"\", \"\"},\n\t\t{\"+123\", \"+123\", \"\", \"\"},\n\t\t{\"1e5\", \"1e5\", \"\", \"\"},\n\t\t{\"1.2e5\", \"1.2e5\", \"\", \"\"},\n\t\t{\"1.2e+5\", \"1.2e+5\", \"\", \"\"},\n\t\t{\"1.2e-5\", \"1.2e-5\", \"\", \"\"},\n\t\t{\"123a\", \"123\", \"a\", \"\"},\n\t\t{\"123 \", \"123\", \" \", \"\"},\n\t\t{\"123\\\"\", \"123\", \"\\\"\", \"\"},\n\t\t{\"inf\", \"inf\", \"\", \"\"},\n\t\t{\"+inf\", \"+inf\", \"\", \"\"},\n\t\t{\"-inf\", \"-inf\", \"\", \"\"},\n\t\t{\"infx\", \"inf\", \"x\", \"\"},\n\t\t{\"inf \", \"inf\", \" \", \"\"},\n\t\t{\"nan\", \"nan\", \"\", \"\"},\n\t\t{\"+nan\", \"\", \"+nan\", \"unexpected char: \\\"+\\\"\"},\n\t\t{\"-nan\", \"\", \"-nan\", \"unexpected char: \\\"-\\\"\"},\n\t\t{\"nanx\", \"nan\", \"x\", \"\"},\n\t\t{\"nan \", \"nan\", \" \", \"\"},\n\t\t{\"\", \"\", \"\", \"\"},\n\t\t{\"a123\", \"\", \"a123\", \"unexpected char: \\\"a\\\"\"},\n\t\t{\"+123x\", \"+123\", \"x\", \"\"},\n\t\t{\"-123x\", \"-123\", \"x\", \"\"},\n\t}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tns, tail, err := parseRawNumber(tt.input)\n\t\t\tif tt.errStr != \"\" {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"expected error %q, got nil\", tt.errStr)\n\t\t\t\t} else if err.Error() != tt.errStr {\n\t\t\t\t\tt.Errorf(\"expected error %q, got %q\", tt.errStr, err.Error())\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif ns != tt.ns {\n\t\t\t\tt.Errorf(\"expected ns %q, got %q\", tt.ns, ns)\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"expected tail %q, got %q\", tt.tail, tail)\n\t\t\t}\n\t\t})\n\t}\n}","f507afd9a2e710907103163f30938768":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc Test_unescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello world\",\n\t\t\t},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"simple escape\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello\\\\tworld\",\n\t\t\t},\n\t\t\twant: \"hello\\tworld\",\n\t\t},\n\t\t{\n\t\t\tname: \"unicode escape\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello\\\\u0020world\",\n\t\t\t},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid unicode escape\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello\\\\u002\",\n\t\t\t},\n\t\t\twant: \"hello\\\\u002\",\n\t\t},\n\t\t{\n\t\t\tname: \"surrogate pair\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello\\\\uD83D\\\\uDE01world\",\n\t\t\t},\n\t\t\twant: \"helloüòÅworld\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid surrogate pair\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello\\\\uD83Dworld\",\n\t\t\t},\n\t\t\twant: \"hello\\\\uD83Dworld\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","f52a9ba437685c8435afc8b5272bb656":"package fastjson\n\nimport \"testing\"\n\nfunc TestValue_GetInt(t *testing.T) {\n\tvar v Value\n\ttestCases := []struct {\n\t\tjson     string\n\t\tkeys     []string\n\t\texpected int\n\t}{\n\t\t// Existing keys\n\t\t{`{\"a\": 123}`, []string{\"a\"}, 123},\n\t\t{`{\"a\": {\"b\": 456}}`, []string{\"a\", \"b\"}, 456},\n\t\t{`{\"a\": [1, 2, 3]}`, []string{\"a\", \"1\"}, 2},\n\t\t{`{\"a\": [1, 2, 3]}`, []string{\"a\", \"1.0\"}, 2},\n\n\t\t// Non-existing keys\n\t\t{`{\"a\": 123}`, []string{\"b\"}, 0},\n\t\t{`{\"a\": {\"b\": 456}}`, []string{\"a\", \"c\"}, 0},\n\t\t{`{\"a\": [1, 2, 3]}`, []string{\"a\", \"4\"}, 0},\n\n\t\t// Invalid value types\n\t\t{`{\"a\": \"123\"}`, []string{\"a\"}, 0},\n\t\t{`{\"a\": {\"b\": true}}`, []string{\"a\", \"b\"}, 0},\n\t\t{`{\"a\": [1, \"2\", 3]}`, []string{\"a\", \"1\"}, 0},\n\n\t\t// Overflow\n\t\t{`{\"a\": 9223372036854775808}`, []string{\"a\"}, 0},\n\t\t{`{\"a\": -9223372036854775809}`, []string{\"a\"}, 0},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tv.Parse(tc.json)\n\t\tif got := v.GetInt(tc.keys...); got != tc.expected {\n\t\t\tt.Errorf(\"Test case %d: expected %d, got %d\", i+1, tc.expected, got)\n\t\t}\n\t}\n}","f583068e21b7ee06f424a489cd2eb93d":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Empty string\n\t\t{\"\", nil, \"\", fmt.Errorf(\"cannot parse empty string\")},\n\t\t// Invalid JSON\n\t\t{\"{invalid}\", nil, \"\", fmt.Errorf(\"cannot parse object: invalid character 'i' looking for beginning of value\")},\n\t\t// Object\n\t\t{`{\"key\": \"value\"}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{t: TypeString, s: \"value\"}}}}}, \"\", nil},\n\t\t// Array\n\t\t{`[1, \"two\", true]`, \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeString, s: \"two\"}, {t: TypeTrue}}}, \"\", nil},\n\t\t// String\n\t\t{`\"hello\"`, \u0026Value{t: TypeString, s: \"hello\"}, \"\", nil},\n\t\t// True\n\t\t{\"true\", valueTrue, \"\", nil},\n\t\t// False\n\t\t{\"false\", valueFalse, \"\", nil},\n\t\t// Null\n\t\t{\"null\", valueNull, \"\", nil},\n\t\t// Number\n\t\t{\"12345\", \u0026Value{t: TypeNumber, s: \"12345\"}, \"\", nil},\n\t\t// NaN\n\t\t{\"NaN\", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"\", nil},\n\t\t// Trailing whitespace\n\t\t{\"true \", valueTrue, \" \", nil},\n\t\t// Nested structures\n\t\t{`{\"array\": [1,2,3], \"object\": {\"key\": \"value\"}}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"array\", v: \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}}}}, {k: \"object\", v: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{t: TypeString, s: \"value\"}}}}}}}}}, \"\", nil},\n\t}\n\n\tc := \u0026cache{}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tgot, tail, err := parseValue(tt.input, c, 0)\n\t\t\tif (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"parseValue(%q) error mismatch: got %v, want %v\", tt.input, err, tt.err)\n\t\t\t}\n\t\t\tif got != nil \u0026\u0026 tt.want != nil \u0026\u0026 got.String() != tt.want.String() {\n\t\t\t\tt.Errorf(\"parseValue(%q) got = %v, want %v\", tt.input, got, tt.want)\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"parseValue(%q) tail mismatch: got %q, want %q\", tt.input, tail, tt.tail)\n\t\t\t}\n\t\t})\n\t}\n}","f59ee05c8531a20d9be7e8f6127935d7":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\ts string\n\t\twant string\n\t}{\n\t\t// Empty string.\n\t\t{\"\", \"\"},\n\n\t\t// String without escape sequences.\n\t\t{\"foobar\", \"foobar\"},\n\t\t{\"foo bar\", \"foo bar\"},\n\t\t{\"foo\\\"bar\", \"foo\\\"bar\"},\n\t\t{\"foo\\\\bar\", \"foo\\\\bar\"},\n\t\t{\"foo\\nbar\", \"foo\\nbar\"},\n\n\t\t// Valid escape sequences.\n\t\t{`\"`, \"\\\"\"},\n\t\t{`\\`, `\\`},\n\t\t{`/`, `/`},\n\t\t{`\\b`, \"\\b\"},\n\t\t{`\\f`, \"\\f\"},\n\t\t{`\\n`, \"\\n\"},\n\t\t{`\\r`, \"\\r\"},\n\t\t{`\\t`, \"\\t\"},\n\t\t{`\\u0000`, \"\\x00\"},\n\t\t{`\\u0001`, \"\\x01\"},\n\t\t{`\\u0010`, \"\\x10\"},\n\t\t{`\\u001A`, \"\\x1A\"},\n\t\t{`\\u00FF`, \"\\xFF\"},\n\t\t{`\\u0442`, \"—Ç\"},\n\t\t{`\\u4e2d`, \"‰∏≠\"},\n\t\t{`\\uD83D\\uDE02`, \"üòÇ\"},\n\n\t\t// Invalid escape sequences.\n\t\t{`\\a`, `\\a`},\n\t\t{`\\x`, `\\x`},\n\t\t{`\\u`, `\\u`},\n\t\t{`\\u000`, `\\u000`},\n\t\t{`\\u000z`, `\\u000z`},\n\t\t{`\\u000`, `\\u000`},\n\t\t{`\\uzzz`, `\\uzzz`},\n\t\t{`\\uD800`, `\\uD800`},\n\t\t{`\\uD800\\`, `\\uD800\\`},\n\t\t{`\\uD800\\x`, `\\uD800\\x`},\n\t\t{`\\uD800\\uD800`, `\\uD800\\uD800`},\n\t\t{`\\uD800\\uFFFF`, `\\uD800\\uFFFF`},\n\t\t{`\\uDFFF`, `\\uDFFF`},\n\t\t{`\\uDFFF\\`, `\\uDFFF\\`},\n\t\t{`\\uDFFF\\x`, `\\uDFFF\\x`},\n\t\t{`\\uDFFF\\uD800`, `\\uDFFF\\uD800`},\n\t\t{`\\uDFFF\\uFFFF`, `\\uDFFF\\uFFFF`},\n\t}\n\tfor i, tt := range tests {\n\t\tgot := unescapeStringBestEffort(tt.s)\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"test #%v: unescapeStringBestEffort(%q) = %q; want %q\", i, tt.s, got, tt.want)\n\t\t}\n\t}\n}","f5e0639406a7ac149ef59ce46b9fd877":"package fastjson\n\nimport \"testing\"\n\nfunc TestObject_getKV(t *testing.T) {\n\to := Object{}\n\t// Test adding the first kv\n\tkv1 := o.getKV()\n\tif kv1 == nil {\n\t\tt.Errorf(\"Expected non-nil kv, got nil\")\n\t}\n\t// Test adding another kv\n\tkv2 := o.getKV()\n\tif kv2 == nil {\n\t\tt.Errorf(\"Expected non-nil kv, got nil\")\n\t}\n\t// Check if the capacity is doubled\n\tif cap(o.kvs) != 2 {\n\t\tt.Errorf(\"Expected capacity to be 2, got %d\", cap(o.kvs))\n\t}\n}","f61bfa80baef78dd9ee3035bba841ed5":"package fastjson\n\nimport \"testing\"\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"  foo\", \"foo\"},\n\t\t{\"\\n\\t bar\", \"bar\"},\n\t\t{\" \\r\\n baz\", \"baz\"},\n\t\t{\"qux\", \"qux\"},\n\t\t{\"\", \"\"},\n\t\t{\"\\n\", \"\"},\n\t\t{\"\\t\", \"\"},\n\t\t{\" \", \"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := skipWSSlow(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"skipWSSlow(%q) = %q, want %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}","f625b903fe1f87df3db897c6edb4f6ae":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw_string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"raw string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"raw string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"array\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"[\\\"array\\\",123]\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif string(got) != string(tt.want) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","f6f799d652f95548df1454b0da524481":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput  string\n\t\texpect string\n\t\tremain string\n\t\terr    error\n\t}{\n\t\t// Basic cases\n\t\t{`\"hello\"`, `hello`, ``, nil},\n\t\t{`\"hello world\"`, `hello world`, ``, nil},\n\t\t{`\"hello\\\"world\"`, `hello\"world`, ``, nil},\n\t\t{`\"\\\\\"`, `\\`, ``, nil},\n\t\t{`\"\\\\\\\"\"`, `\\\"`, ``, nil},\n\n\t\t// Empty string\n\t\t{`\"\"`, ``, ``, nil},\n\n\t\t// With remaining string\n\t\t{`\"hello\", \"world\"`, `hello`, `, \"world\"`, nil},\n\n\t\t// Invalid cases\n\t\t{`\"hello`, ``, ``, fmt.Errorf(`missing closing '\"'`)},\n\t\t{`hello\"`, ``, ``, fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"hello\\\\\"`, ``, ``, fmt.Errorf(`missing closing '\"'`)},\n\t}\n\n\tfor i, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d\", i+1), func(t *testing.T) {\n\t\t\tresult, remain, err := parseRawString(test.input)\n\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"Expected result '%s', got '%s'\", test.expect, result)\n\t\t\t}\n\n\t\t\tif remain != test.remain {\n\t\t\t\tt.Errorf(\"Expected remaining string '%s', got '%s'\", test.remain, remain)\n\t\t\t}\n\n\t\t\tif (err != nil \u0026\u0026 test.err == nil) || (err == nil \u0026\u0026 test.err != nil) || (err != nil \u0026\u0026 test.err != nil \u0026\u0026 err.Error() != test.err.Error()) {\n\t\t\t\tt.Errorf(\"Expected error '%v', got '%v'\", test.err, err)\n\t\t\t}\n\t\t})\n\t}\n}\n","f7174365718278f6c246af3c02df800c":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParser_Parse(t *testing.T) {\n\t// Add your test cases here\n}","f7c57cc5d4987c63433126e4c45ef159":"package fastjson\n\nimport \"testing\"\n\nfunc Test_skipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    string\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\ts:    \"\",\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with leading whitespace\",\n\t\t\ts:    \"  \\n\\t\\r foo\",\n\t\t\twant: \"foo\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with no leading whitespace\",\n\t\t\ts:    \"bar\",\n\t\t\twant: \"bar\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with only whitespace\",\n\t\t\ts:    \" \\t\\r\\n\",\n\t\t\twant: \"\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","f8928951972e02af89edabbec7377750":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestValue_Int(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twant     int\n\t\twantFail bool\n\t}{\n\t\t{`123`, 123, false},\n\t\t{`-123`, -123, false},\n\t\t{`123.456`, 0, true},\n\t\t{`\"123\"`, 0, true},\n\t\t{`null`, 0, true},\n\t\t{`{}`, 0, true},\n\t\t{`[]`, 0, true},\n\t\t{`9223372036854775807`, 0, true},\n\t\t{`-9223372036854775808`, 0, true},\n\t}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tv := ParseString(tt.input)\n\t\t\tgot, err := v.Int()\n\t\t\tif tt.wantFail {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"want error, got nil\")\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"want %v, got %v\", tt.want, got)\n\t\t\t}\n\t\t})\n\t}\n}","f8da9bdf20008c2b106a9e69d349e4ba":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  string\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Basic cases\n\t\t{`\"foo\"bar`, \"foo\", \"bar\", nil},\n\t\t{`\"fo\\o\"bar`, \"fo\\o\", \"bar\", nil},\n\t\t{`\"foo\"`, \"foo\", \"\", nil},\n\t\t{`\"\"bar`, \"\", \"bar\", nil},\n\n\t\t// Escaped quotes\n\t\t{`\"foo\\\"bar\"baz`, `foo\"bar`, \"baz\", nil},\n\t\t{`\"foo\\\\\\\"bar\"baz`, `foo\\\"bar`, \"baz\", nil},\n\t\t{`\"foo\\\\\\\\\"bar\"baz`, `foo\\\\`, `bar\"baz`, nil},\n\n\t\t// Missing closing quote\n\t\t{`\"foobar`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo\\\"bar`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo\\\\\"bar`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(t *testing.T) {\n\t\t\tgot, tail, err := parseRawString(tt.input)\n\t\t\tif got != tt.want || tail != tt.tail || (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = (%q, %q, %v), want (%q, %q, %v)\", tt.input, got, tail, err, tt.want, tt.tail, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}","f95819b73bedc0740878a7252e4ef62b":"package fastjson\n\nimport \"testing\"\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tt    Type\n\t\twant string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.want, func(t *testing.T) {\n\t\t\tif got := tt.t.String(); got != tt.want {\n\t\t\t\tt.Errorf(\"Type.String() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","f9747230c68e23c0a3a3fc2165b2b8a6":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"raw string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"raw string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"12345\",\n\t\t\t},\n\t\t\twant: []byte(\"12345\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"string\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"12345\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"[\\\"string\\\",12345]\"),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"string\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"string\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"number\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"12345\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"{\\\"string\\\":\\\"string\\\",\\\"number\\\":\\\"12345\\\"}\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif string(got) != string(tt.want) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %v, want %v\", string(got), string(tt.want))\n\t\t\t}\n\t\t})\n\t}\n}\n","f981bfe9171513de09c0681357443d27":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey   string\n\t\tvalue string\n\t\terr   error\n\t}{\n\t\t{`\"foo\"bar`, \"foo\", \"bar\", nil},\n\t\t{`\"fo\\\"o\"bar`, \"fo\\\"o\", \"bar\", nil},\n\t\t{`\"fo\\\\o\"bar`, `fo\\o`, \"bar\", nil},\n\t\t{`\"foo\"`, \"foo\", \"\", nil},\n\t\t{`\"foo`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"fo\\o`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"fo\\\\\\\"o\"bar`, `fo\\\"o`, \"bar\", nil},\n\t\t{`\"\\\\\"foo`, `\\`, \"foo\", nil},\n\t}\n\tfor i, tt := range tests {\n\t\tk, v, err := parseRawString(tt.input)\n\t\tif fmt.Sprintf(\"%v\", err) != fmt.Sprintf(\"%v\", tt.err) {\n\t\t\tt.Errorf(\"test[%d]: error mismatch, want %v, got %v\", i, tt.err, err)\n\t\t}\n\t\tif k != tt.key {\n\t\t\tt.Errorf(\"test[%d]: key mismatch, want %q, got %q\", i, tt.key, k)\n\t\t}\n\t\tif v != tt.value {\n\t\t\tt.Errorf(\"test[%d]: value mismatch, want %q, got %q\", i, tt.value, v)\n\t\t}\n\t}\n}","fa1f625cfa6f647e389ef8b2e4a2b0f7":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ts     string\n\t\terr   error\n\t}{\n\t\t// Empty object\n\t\t{\n\t\t\tinput: \"{}\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Simple object\n\t\t{\n\t\t\tinput: `{\"key1\": \"value1\", \"key2\": 123}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Nested object\n\t\t{\n\t\t\tinput: `{\"key1\": {\"key2\": \"value2\"}, \"key3\": true}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{k: \"key3\", v: \u0026Value{t: TypeTrue}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Missing closing brace\n\t\t{\n\t\t\tinput: `{\"key1\": \"value1\"`,\n\t\t\twant:  nil,\n\t\t\ts:     `{\"key1\": \"value1\"`,\n\t\t\terr:   fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t\t// Invalid key\n\t\t{\n\t\t\tinput: `{key1: \"value1\"}`,\n\t\t\twant:  nil,\n\t\t\ts:     `key1: \"value1\"}`,\n\t\t\terr:   fmt.Errorf(`cannot find opening '\"\" for object key`),\n\t\t},\n\t\t// Missing colon\n\t\t{\n\t\t\tinput: `{\"key1\" \"value1\"}`,\n\t\t\twant:  nil,\n\t\t\ts:     `\"value1\"}`,\n\t\t\terr:   fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t\t// Invalid value\n\t\t{\n\t\t\tinput: `{\"key1\": invalid}`,\n\t\t\twant:  nil,\n\t\t\ts:     `invalid}`,\n\t\t\terr:   fmt.Errorf(\"cannot parse object value: invalid character 'i' looking for beginning of value\"),\n\t\t},\n\t\t// Missing comma\n\t\t{\n\t\t\tinput: `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twant:  nil,\n\t\t\ts:     `\"key2\": \"value2\"}`,\n\t\t\terr:   fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseObject(tt.input, c, 0)\n\t\t\tif fmt.Sprintf(\"%v\", err) != fmt.Sprintf(\"%v\", tt.err) {\n\t\t\t\tt.Errorf(\"expected error %v, got %v\", tt.err, err)\n\t\t\t}\n\t\t\tif s != tt.s {\n\t\t\t\tt.Errorf(\"expected remaining string %q, got %q\", tt.s, s)\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"expected value %v, got %v\", tt.want, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeTrue, TypeFalse, TypeNull:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n","fa43a2f1438e1f409b9dcf9d2fc25dc6":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twantObj  string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t{\n\t\t\tname:     \"empty object\",\n\t\t\tinput:    \"{}\",\n\t\t\twantObj:  `{\"t\":1}`,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"simple object\",\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\twantObj:  `{\"t\":1,\"o\":{\"kvs\":[{\"k\":\"key\",\"v\":{\"t\":3,\"s\":\"value\"}}]}}`,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple key-value pairs\",\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 123, \"key3\": true}`,\n\t\t\twantObj:  `{\"t\":1,\"o\":{\"kvs\":[{\"k\":\"key1\",\"v\":{\"t\":3,\"s\":\"value1\"}},{\"k\":\"key2\",\"v\":{\"t\":4,\"i\":123}},{\"k\":\"key3\",\"v\":{\"t\":5}}]}}`,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"nested object\",\n\t\t\tinput:    `{\"key1\": {\"key2\": \"value2\"}, \"key3\": \"value3\"}`,\n\t\t\twantObj:  `{\"t\":1,\"o\":{\"kvs\":[{\"k\":\"key1\",\"v\":{\"t\":1,\"o\":{\"kvs\":[{\"k\":\"key2\",\"v\":{\"t\":3,\"s\":\"value2\"}}]}}},{\"k\":\"key3\",\"v\":{\"t\":3,\"s\":\"value3\"}}]}}`,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing closing brace\",\n\t\t\tinput:    `{\"key\": \"value\",`,\n\t\t\twantObj:  \"\",\n\t\t\twantTail: `{\"key\": \"value\",`,\n\t\t\twantErr:  fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"missing opening quote for key\",\n\t\t\tinput:    \"{key: \\\"value\\\"}\",\n\t\t\twantObj:  \"\",\n\t\t\twantTail: \"key: \\\"value\\\"}\",\n\t\t\twantErr:  fmt.Errorf(`cannot find opening '\"\" for object key`),\n\t\t},\n\t\t{\n\t\t\tname:     \"missing closing quote for key\",\n\t\t\tinput:    `{\"key: \"value\"}`,\n\t\t\twantObj:  \"\",\n\t\t\twantTail: \": \\\"value\\\"}\",\n\t\t\twantErr:  fmt.Errorf(\"cannot parse object key: unexpected EOF\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"missing colon after key\",\n\t\t\tinput:    `{\"key\" \"value\"}`,\n\t\t\twantObj:  \"\",\n\t\t\twantTail: `\"value\"}`,\n\t\t\twantErr:  fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"missing comma between key-value pairs\",\n\t\t\tinput:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantObj:  \"\",\n\t\t\twantTail: `\"key2\": \"value2\"}`,\n\t\t\twantErr:  fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgotObj, gotTail, gotErr := parseObject(tt.input, c, 0)\n\n\t\t\tif gotObj != nil {\n\t\t\t\tgotObjStr := gotObj.String()\n\t\t\t\tif gotObjStr != tt.wantObj {\n\t\t\t\t\tt.Errorf(\"parseObject() gotObj = %v, want %v\", gotObjStr, tt.wantObj)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif tt.wantObj != \"\" {\n\t\t\t\t\tt.Errorf(\"parseObject() gotObj = nil, want %v\", tt.wantObj)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseObject() gotTail = %v, want %v\", gotTail, tt.wantTail)\n\t\t\t}\n\n\t\t\tif gotErr == nil \u0026\u0026 tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"parseObject() gotErr = nil, want %v\", tt.wantErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr == nil {\n\t\t\t\tt.Errorf(\"parseObject() gotErr = %v, want nil\", gotErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"parseObject() gotErr = %v, want %v\", gotErr, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","fad2cd55a1437b3ce0da7feb21a2c28c":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"raw string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"raw string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"string\",\n\t\t\t},\n\t\t\twant: []byte(\"\\\"string\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"12345\",\n\t\t\t},\n\t\t\twant: []byte(\"12345\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"string\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"12345\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"[\\\"string\\\",12345]\"),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"12345\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"{\\\"key1\\\":\\\"value1\\\",\\\"key2\\\":12345}\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(nil)\n\t\t\tif string(got) != string(tt.want) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %v, want %v\", string(got), string(tt.want))\n\t\t\t}\n\t\t})\n\t}\n}","fafe949e40ef0e679a1dce9f0ab14244":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ts     string\n\t\terr   error\n\t}{\n\t\t// Empty object\n\t\t{\n\t\t\tinput: \"{}\",\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Single key-value pair\n\t\t{\n\t\t\tinput: `{\"key\": \"value\"}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Multiple key-value pairs\n\t\t{\n\t\t\tinput: `{\"key1\": \"value1\", \"key2\": 123, \"key3\": true}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Nested object\n\t\t{\n\t\t\tinput: `{\"key1\": {\"key2\": \"value2\"}}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\ts:   \"\",\n\t\t\terr: nil,\n\t\t},\n\t\t// Invalid JSON\n\t\t{\n\t\t\tinput: `{\"key\": \"value\"`,\n\t\t\twant:  nil,\n\t\t\ts:     `{\"key\": \"value\"`,\n\t\t\terr:   fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d\", i), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, s, err := parseObject(tt.input, c, 0)\n\t\t\tif (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"parseObject(%q) error mismatch: got %v, want %v\", tt.input, err, tt.err)\n\t\t\t}\n\t\t\tif s != tt.s {\n\t\t\t\tt.Errorf(\"parseObject(%q) remaining string mismatch: got %q, want %q\", tt.input, s, tt.s)\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject(%q) value mismatch:\\ngot  %+v\\nwant %+v\", tt.input, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !equalValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\treturn true\n\t}\n}\n","fb729c9e664590824f43d00dd4575e18":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tkey   string\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Basic cases\n\t\t{`\"foo\"bar`, \"foo\", \"bar\", nil},\n\t\t{`\"fo\\\"o\"bar`, `fo\"o`, \"bar\", nil},\n\t\t{`\"foo\" bar`, \"foo\", \" bar\", nil},\n\n\t\t// Escaped quotes\n\t\t{`\"foo\\\\\"bar\"baz`, `foo\\bar`, \"baz\", nil},\n\t\t{`\"foo\\\\\\\\\"bar\"baz`, `foo\\\\`, `bar\"baz`, nil},\n\n\t\t// Missing closing quote\n\t\t{`\"foo`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"foo\"bar\"`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\n\t\t// Empty strings\n\t\t{`\"\"bar`, \"\", \"bar\", nil},\n\t\t{`\"foo\"\"\"bar`, \"foo\", `\"bar`, nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test_%d:%s\", i, tt.input), func(t *testing.T) {\n\t\t\tkey, tail, err := parseRawString(tt.input)\n\t\t\tif key != tt.key || tail != tt.tail || (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = (%q, %q, %v), want (%q, %q, %v)\", tt.input, key, tail, err, tt.key, tt.tail, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}\n","fb7e9ab90d925bed85b64d15b8032d26":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\twant     *Value\n\t\twantRest string\n\t\twantErr  error\n\t}{\n\t\t{\n\t\t\tname:     \"empty array\",\n\t\t\tinput:    \"[]\",\n\t\t\twant:     \u0026Value{t: TypeArray, a: []*Value{}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"single element array\",\n\t\t\tinput:    \"[1]\",\n\t\t\twant:     \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple element array\",\n\t\t\tinput:    \"[1,2,3]\",\n\t\t\twant: \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with whitespace\",\n\t\t\tinput:    \" [ 1 , 2 , 3 ] \",\n\t\t\twant: \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"nested array\",\n\t\t\tinput:    \"[[1,2],[3,4]]\",\n\t\t\twant: \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeArray, a: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t}},\n\t\t\t\t{t: TypeArray, a: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t\t{t: TypeNumber, s: \"4\"},\n\t\t\t\t}},\n\t\t\t}},\n\t\t\twantRest: \"\",\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing closing bracket\",\n\t\t\tinput:    \"[1,2,3\",\n\t\t\twant:     nil,\n\t\t\twantRest: \"\",\n\t\t\twantErr:  fmt.Errorf(\"unexpected end of array\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"missing comma\",\n\t\t\tinput:    \"[1 2 3]\",\n\t\t\twant:     nil,\n\t\t\twantRest: \"\",\n\t\t\twantErr:  fmt.Errorf(\"missing ',' after array value\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, rest, err := parseArray(tt.input, c, 0)\n\n\t\t\tif (err != nil \u0026\u0026 tt.wantErr == nil) || (err == nil \u0026\u0026 tt.wantErr != nil) || (err != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 err.Error() != tt.wantErr.Error()) {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif rest != tt.wantRest {\n\t\t\t\tt.Errorf(\"parseArray() rest = %v, wantRest %v\", rest, tt.wantRest)\n\t\t\t}\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.s != v2.s {\n\t\treturn false\n\t}\n\tif len(v1.a) != len(v2.a) {\n\t\treturn false\n\t}\n\tfor i := range v1.a {\n\t\tif !equalValues(v1.a[i], v2.a[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","fce70cc9e40ba2c400ed89f3e0ba423b":"package fastjson\n\nimport \"testing\"\n\nfunc TestValue_GetInt(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tjson  string\n\t\tkeys  []string\n\t\twant  int\n\t\twant1 bool\n\t}{\n\t\t{\n\t\t\tname:  \"simple\",\n\t\t\tjson:  `{\"foo\":123}`,\n\t\t\tkeys:  []string{\"foo\"},\n\t\t\twant:  123,\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"nested\",\n\t\t\tjson:  `{\"foo\":{\"bar\":123}}`,\n\t\t\tkeys:  []string{\"foo\", \"bar\"},\n\t\t\twant:  123,\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array\",\n\t\t\tjson:  `{\"foo\":[123,456]}`,\n\t\t\tkeys:  []string{\"foo\", \"1\"},\n\t\t\twant:  456,\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array decimal\",\n\t\t\tjson:  `{\"foo\":[123,456]}`,\n\t\t\tkeys:  []string{\"foo\", \"1.0\"},\n\t\t\twant:  456,\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"non-existing key\",\n\t\t\tjson:  `{\"foo\":123}`,\n\t\t\tkeys:  []string{\"bar\"},\n\t\t\twant:  0,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"invalid value type\",\n\t\t\tjson:  `{\"foo\":\"bar\"}`,\n\t\t\tkeys:  []string{\"foo\"},\n\t\t\twant:  0,\n\t\t\twant1: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv := ParseBytes([]byte(tt.json))\n\t\t\tgot := v.GetInt(tt.keys...)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"GetInt() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","feacaa5e88202caacf33cb33a02608a6":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Empty string\n\t\t{\"\", nil, \"\", fmt.Errorf(\"cannot parse empty string\")},\n\t\t// Invalid JSON\n\t\t{\"{\", nil, \"{\", fmt.Errorf(\"cannot parse object: missing '}'\")},\n\t\t// Object\n\t\t{`{\"foo\":\"bar\"}`, \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: typeRawString, s: \"bar\"}}}}}, \"\", nil},\n\t\t// Array\n\t\t{`[1,2,3]`, \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}}, \"\", nil},\n\t\t// String\n\t\t{`\"hello\"`, \u0026Value{t: typeRawString, s: \"hello\"}, \"\", nil},\n\t\t// True\n\t\t{\"true\", valueTrue, \"\", nil},\n\t\t// False\n\t\t{\"false\", valueFalse, \"\", nil},\n\t\t// Null\n\t\t{\"null\", valueNull, \"\", nil},\n\t\t// Number\n\t\t{\"123\", \u0026Value{t: TypeNumber, s: \"123\"}, \"\", nil},\n\t\t// NaN\n\t\t{\"NaN\", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"\", nil},\n\t\t// Trailing space\n\t\t{`\"hello\" `, \u0026Value{t: typeRawString, s: \"hello\"}, \" \", nil},\n\t\t// Number with exponent\n\t\t{\"1.23e4\", \u0026Value{t: TypeNumber, s: \"1.23e4\"}, \"\", nil},\n\t\t// Negative number\n\t\t{\"-123\", \u0026Value{t: TypeNumber, s: \"-123\"}, \"\", nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test %d: %s\", i, tt.input), func(t *testing.T) {\n\t\t\tgot, tail, err := parseValue(tt.input, c, 0)\n\n\t\t\tif tt.err != nil {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"expected error, got nil\")\n\t\t\t\t} else if err.Error() != tt.err.Error() {\n\t\t\t\t\tt.Errorf(\"expected error %q, got %q\", tt.err, err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"expected tail %q, got %q\", tt.tail, tail)\n\t\t\t}\n\n\t\t\tif !equalValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"expected value %v, got %v\", tt.want, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tif v1.t == typeRawString \u0026\u0026 v1.s != v2.s {\n\t\treturn false\n\t}\n\tif v1.t == TypeNumber \u0026\u0026 v1.s != v2.s {\n\t\treturn false\n\t}\n\tif v1.t == TypeObject \u0026\u0026 !equalObjects(\u0026v1.o, \u0026v2.o) {\n\t\treturn false\n\t}\n\tif v1.t == TypeArray \u0026\u0026 !equalArrays(v1.a, v2.a) {\n\t\treturn false\n\t}\n\treturn true\n}\n\nfunc equalObjects(o1, o2 *Object) bool {\n\tif o1.Len() != o2.Len() {\n\t\treturn false\n\t}\n\tfor i := 0; i \u003c o1.Len(); i++ {\n\t\tkv1 := o1.kvs[i]\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !equalValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc equalArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i := 0; i \u003c len(a1); i++ {\n\t\tif !equalValues(a1[i], a2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","ff29818ed9c5eb2e04b751c3ad5a474c":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  *Value\n\t\ttail  string\n\t\terr   error\n\t}{\n\t\t// Empty string\n\t\t{\"\", nil, \"\", fmt.Errorf(\"cannot parse empty string\")},\n\n\t\t// String\n\t\t{`\"hello\"`, \u0026Value{t: typeRawString, s: \"hello\"}, \"\", nil},\n\n\t\t// True\n\t\t{\"true\", valueTrue, \"\", nil},\n\n\t\t// False\n\t\t{\"false\", valueFalse, \"\", nil},\n\n\t\t// Null\n\t\t{\"null\", valueNull, \"\", nil},\n\n\t\t// NaN\n\t\t{\"NaN\", \u0026Value{t: TypeNumber, s: \"NaN\"}, \"\", nil},\n\n\t\t// Number\n\t\t{\"123\", \u0026Value{t: TypeNumber, s: \"123\"}, \"\", nil},\n\t\t{\"-123.456\", \u0026Value{t: TypeNumber, s: \"-123.456\"}, \"\", nil},\n\n\t\t// Array\n\t\t{\"[1,2,3]\", \u0026Value{t: TypeArray}, \"\", nil},\n\n\t\t// Object\n\t\t// Note: Object parsing is not tested here as it depends on parseObject\n\t\t// which is not provided in the given code.\n\n\t\t// Trailing whitespace\n\t\t{`\"hello\" `, \u0026Value{t: typeRawString, s: \"hello\"}, \" \", nil},\n\n\t\t// Invalid JSON\n\t\t{\"invalid\", nil, \"invalid\", fmt.Errorf(\"cannot parse number: invalid\")},\n\t}\n\n\tc := \u0026cache{}\n\tfor i, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test-%d-%s\", i, test.input), func(t *testing.T) {\n\t\t\tgot, tail, err := parseValue(test.input, c, 0)\n\n\t\t\tif test.err != nil {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"Expected error, got nil\")\n\t\t\t\t} else if err.Error() != test.err.Error() {\n\t\t\t\t\tt.Errorf(\"Expected error %q, got %q\", test.err, err)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif tail != test.tail {\n\t\t\t\tt.Errorf(\"Expected tail %q, got %q\", test.tail, tail)\n\t\t\t}\n\n\t\t\tif test.want == nil \u0026\u0026 got != nil {\n\t\t\t\tt.Errorf(\"Expected nil value, got %+v\", got)\n\t\t\t} else if test.want != nil {\n\t\t\t\tif got == nil {\n\t\t\t\t\tt.Errorf(\"Expected %+v value, got nil\", test.want)\n\t\t\t\t} else {\n\t\t\t\t\tif got.t != test.want.t {\n\t\t\t\t\t\tt.Errorf(\"Expected type %v, got %v\", test.want.t, got.t)\n\t\t\t\t\t}\n\t\t\t\t\tif got.s != test.want.s {\n\t\t\t\t\t\tt.Errorf(\"Expected value %q, got %q\", test.want.s, got.s)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n","ff2e64941735c4b5b5fb0f73d2564232":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetUint(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tjson  string\n\t\tkeys  []string\n\t\twant  uint\n\t\twant1 bool\n\t}{\n\t\t{\n\t\t\tname:  \"simple\",\n\t\t\tjson:  `{\"foo\":123}`,\n\t\t\tkeys:  []string{\"foo\"},\n\t\t\twant:  123,\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"nested\",\n\t\t\tjson:  `{\"foo\":{\"bar\":123}}`,\n\t\t\tkeys:  []string{\"foo\", \"bar\"},\n\t\t\twant:  123,\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array\",\n\t\t\tjson:  `{\"foo\":[123,456]}`,\n\t\t\tkeys:  []string{\"foo\", \"1\"},\n\t\t\twant:  456,\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"array decimal\",\n\t\t\tjson:  `{\"foo\":[123,456]}`,\n\t\t\tkeys:  []string{\"foo\", \"1.0\"},\n\t\t\twant:  456,\n\t\t\twant1: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"non-existing key\",\n\t\t\tjson:  `{\"foo\":123}`,\n\t\t\tkeys:  []string{\"bar\"},\n\t\t\twant:  0,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"invalid value type\",\n\t\t\tjson:  `{\"foo\":\"bar\"}`,\n\t\t\tkeys:  []string{\"foo\"},\n\t\t\twant:  0,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"number overflow\",\n\t\t\tjson:  `{\"foo\":18446744073709551616}`,\n\t\t\tkeys:  []string{\"foo\"},\n\t\t\twant:  0,\n\t\t\twant1: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"negative number\",\n\t\t\tjson:  `{\"foo\":-123}`,\n\t\t\tkeys:  []string{\"foo\"},\n\t\t\twant:  0,\n\t\t\twant1: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tvar p Parser\n\t\t\tv, err := p.Parse(tt.json)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Parse() error = %v, wantErr %v\", err, nil)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgot := v.GetUint(tt.keys...)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Value.GetUint() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","ff75975ea5cedab01a573834e62bf964":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\twantN    string\n\t\twantTail string\n\t\twantErr  error\n\t}{\n\t\t// Valid numbers\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"-123\", \"-123\", \"\", nil},\n\t\t{\"123.456\", \"123.456\", \"\", nil},\n\t\t{\"1.2e3\", \"1.2e3\", \"\", nil},\n\t\t{\"1.2E-3\", \"1.2E-3\", \"\", nil},\n\t\t{\"+123\", \"+123\", \"\", nil},\n\n\t\t// Valid numbers with trailing characters\n\t\t{\"123a\", \"123\", \"a\", nil},\n\t\t{\"123.456 \", \"123.456\", \" \", nil},\n\t\t{\"-123\\t\", \"-123\", \"\\t\", nil},\n\n\t\t// Invalid numbers\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t\t{\"a123\", \"\", \"a123\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t(\".123\", \"\", \".123\", fmt.Errorf(\"unexpected char: %q\", \".\")},\n\n\t\t// Special cases: \"inf\", \"Inf\", \"iNf\", etc. are valid\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"InF\", \"InF\", \"\", nil},\n\t\t{\"INF\", \"INF\", \"\", nil},\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"nAn\", \"nAn\", \"\", nil},\n\t\t{\"NAN\", \"NAN\", \"\", nil},\n\n\t\t// Special cases with trailing characters\n\t\t{\"infx\", \"inf\", \"x\", nil},\n\t\t{\"NaN}\", \"NaN\", \"}\", nil},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test-%d:%s\", i, tt.input), func(t *testing.T) {\n\t\t\tgotN, gotTail, gotErr := parseRawNumber(tt.input)\n\t\t\tif gotN != tt.wantN {\n\t\t\t\tt.Errorf(\"input: %s, gotN: %s, want: %s\", tt.input, gotN, tt.wantN)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"input: %s, gotTail: %s, want: %s\", tt.input, gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif gotErr == nil \u0026\u0026 tt.wantErr != nil {\n\t\t\t\tt.Errorf(\"input: %s, got no error, want: %v\", tt.input, tt.wantErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr == nil {\n\t\t\t\tt.Errorf(\"input: %s, got error: %v, want no error\", tt.input, gotErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tt.wantErr != nil \u0026\u0026 gotErr.Error() != tt.wantErr.Error() {\n\t\t\t\tt.Errorf(\"input: %s, got error: %v, want: %v\", tt.input, gotErr, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}"}