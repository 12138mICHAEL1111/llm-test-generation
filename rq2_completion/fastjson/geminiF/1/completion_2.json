{
    "00278ae3692fa09d9f958ad63beba116": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Exists(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant bool\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.Exists(tt.args.keys...); got != tt.want {\n\t\t\t\tt.Errorf(\"Value.Exists() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0144670a849d18faf8a4f3ce07fa7a09": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObjectVisit(t *testing.T) {\n\ttype args struct {\n\t\to *Object\n\t\tf func(key []byte, v *Value)\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\ttt.args.o.Visit(tt.args.f)\n\t\t})\n\t}\n}",
    "02a8269c4ee18a4fbb8c09411ab1841f": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestUint(t *testing.T) {\n\ttype args struct {\n\t\tv *Value\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    uint\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"ValidUint\",\n\t\t\targs: args{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"12345\",\n\t\t\t\t},\n\t\t\t},\n\t\t\twant:    12345,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"InvalidUint\",\n\t\t\targs: args{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"18446744073709551616\", // uint64 max + 1\n\t\t\t\t},\n\t\t\t},\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"InvalidType\",\n\t\t\targs: args{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeString,\n\t\t\t\t\ts: \"abc\",\n\t\t\t\t},\n\t\t\t},\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := tt.args.v.Uint()\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Uint() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Uint() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "030050b2471e57cd0d6c0d511578aae8": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWS(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no whitespace\",\n\t\t\targs: args{s: \"abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace\",\n\t\t\targs: args{s: \"  abc\"},\n\t\t\twant: \"  abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailing whitespace\",\n\t\t\targs: args{s: \"abc  \"},\n\t\t\twant: \"abc  \",\n\t\t},\n\t\t{\n\t\t\tname: \"leading and trailing whitespace\",\n\t\t\targs: args{s: \"  abc  \"},\n\t\t\twant: \"  abc  \",\n\t\t},\n\t\t{\n\t\t\tname: \"internal whitespace\",\n\t\t\targs: args{s: \"a bc\"},\n\t\t\twant: \"a bc\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple whitespace\",\n\t\t\targs: args{s: \"  a  bc  \"},\n\t\t\twant: \"  a  bc  \",\n\t\t},\n\t\t{\n\t\t\tname: \"control characters\",\n\t\t\targs: args{s: \"\\t\\r\\n abc\"},\n\t\t\twant: \"\\t\\r\\n abc\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWS(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWS() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "030088fada765edfb609350d13c2384f": "```go\npackage fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"empty string\",\n\t\t\targs:    args{s: \"\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"single digit\",\n\t\t\targs:    args{s: \"1\"},\n\t\t\twantNs:  \"1\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"multiple digits\",\n\t\t\targs:    args{s: \"123\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"decimal number\",\n\t\t\targs:    args{s: \"123.456\"},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"negative number\",\n\t\t\targs:    args{s: \"-123\"},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"positive number\",\n\t\t\targs:    args{s: \"+123\"},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"exponential number\",\n\t\t\targs:    args{s: \"1.23e4\"},\n\t\t\twantNs:  \"1.23e4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"exponential number with capital E\",\n\t\t\targs:    args{s: \"1.23E4\"},\n\t\t\twantNs:  \"1.23E4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading zeros\",\n\t\t\targs:    args{s: \"00123\"},\n\t\t\twantNs:  \"00123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with trailing zeros\",\n\t\t\targs:    args{s: \"12300\"},\n\t\t\twantNs:  \"12300\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading and trailing zeros\",\n\t\t\targs:    args{s: \"0012300\"},\n\t\t\twantNs:  \"0012300\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign\",\n\t\t\targs:    args{s: \"+123\"},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading minus sign\",\n\t\t\targs:    args{s: \"-123\"},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+12300\"},\n\t\t\twantNs:  \"+12300\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading minus sign and trailing zeros\",\n\t\t\targs:    args{s: \"-12300\"},\n\t\t\twantNs:  \"-12300\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and leading zeros\",\n\t\t\targs:    args{s: \"+00123\"},\n\t\t\twantNs:  \"+00123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading minus sign and leading zeros\",\n\t\t\targs:    args{s: \"-00123\"},\n\t\t\twantNs:  \"-00123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and leading and trailing zeros\",\n\t\t\targs:    args{s: \"+0012300\"},\n\t\t\twantNs:  \"+0012300\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading minus sign and leading and trailing zeros\",\n\t\t\targs:    args{s: \"-0012300\"},\n\t\t\twantNs:  \"-0012300\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and decimal point\",\n\t\t\targs:    args{s: \"+123.456\"},\n\t\t\twantNs:  \"+123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading minus sign and decimal point\",\n\t\t\targs:    args{s: \"-123.456\"},\n\t\t\twantNs:  \"-123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and decimal point and trailing zeros\",\n\t\t\targs:    args{s: \"+123.45600\"},\n\t\t\twantNs:  \"+123.45600\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading minus sign and decimal point and trailing zeros\",\n\t\t\targs:    args{s: \"-123.45600\"},\n\t\t\twantNs:  \"-123.45600\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and decimal point and leading zeros\",\n\t\t\targs:    args{s: \"+00123.456\"},\n\t\t\twantNs:  \"+00123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading minus sign and decimal point and leading zeros\",\n\t\t\targs:    args{s: \"-00123.456\"},\n\t\t\twantNs:  \"-00123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and decimal point and leading and trailing zeros\",\n\t\t\targs:    args{s: \"+00123.45600\"},\n\t\t\twantNs:  \"+00123.45600\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading minus sign and decimal point and leading and trailing zeros\",\n\t\t\targs:    args{s: \"-00123.45600\"},\n\t\t\twantNs:  \"-00123.45600\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and exponential notation\",\n\t\t\targs:    args{s: \"+123e4\"},\n\t\t\twantNs:  \"+123e4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading minus sign and exponential notation\",\n\t\t\targs:    args{s: \"-123e4\"},\n\t\t\twantNs:  \"-123e4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and exponential notation and trailing zeros\",\n\t\t\targs:    args{s: \"+12300e4\"},\n\t\t\twantNs:  \"+12300e4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading minus sign and exponential notation and trailing zeros\",\n\t\t\targs:    args{s: \"-12300e4\"},\n\t\t\twantNs:  \"-12300e4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and exponential notation and leading zeros\",\n\t\t\targs:    args{s: \"+00123e4\"},\n\t\t\twantNs:  \"+00123e4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading minus sign and exponential notation and leading zeros\",\n\t\t\targs:    args{s: \"-00123e4\"},\n\t\t\twantNs:  \"-00123e4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and exponential notation and leading and trailing zeros\",\n\t\t\targs:    args{s: \"+0012300e4\"},\n\t\t\twantNs:  \"+0012300e4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading minus sign and exponential notation and leading and trailing zeros\",\n\t\t\targs:    args{s: \"-0012300e4\"},\n\t\t\twantNs:  \"-0012300e4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and exponential notation and decimal point\",\n\t\t\targs:    args{s: \"+123.456e4\"},\n\t\t\twantNs:  \"+123.456e4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading minus sign and exponential notation and decimal point\",\n\t\t\targs:    args{s: \"-123.456e4\"},\n\t\t\twantNs:  \"-123.456e4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and exponential notation and decimal point and trailing zeros\",\n\t\t\targs:    args{s: \"+123.45600e4\"},\n\t\t\twantNs:  \"+123.45600e4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading minus sign and exponential notation and decimal point and trailing zeros\",\n\t\t\targs:    args{s: \"-123.45600e4\"},\n\t\t\twantNs:  \"-123.45600e4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and exponential notation and decimal point and leading zeros\",\n\t\t\targs:    args{s: \"+00123.456e4\"},\n\t\t\twantNs:  \"+00123.456e4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading minus sign and exponential notation and decimal point and leading zeros\",\n\t\t\targs:    args{s: \"-00123.456e4\"},\n\t\t\twantNs:  \"-00123.456e4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and exponential notation and decimal point and leading and trailing zeros\",\n\t\t\targs:    args{s: \"+00123.45600e4\"},\n\t\t\twantNs:  \"+00123.45600e4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading minus sign and exponential notation and decimal point and leading and trailing zeros\",\n\t\t\targs:    args{s: \"-00123.45600e4\"},\n\t\t\twantNs:  \"-00123.45600e4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and exponential notation and capital E\",\n\t\t\targs:    args{s: \"+123E4\"},\n\t\t\twantNs:  \"+123E4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading minus sign and exponential notation and capital E\",\n\t\t\targs:    args{s: \"-123E4\"},\n\t\t\twantNs:  \"-123E4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and exponential notation and capital E and trailing zeros\",\n\t\t\targs:    args{s: \"+12300E4\"},\n\t\t\twantNs:  \"+12300E4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading minus sign and exponential notation and capital E and trailing zeros\",\n\t\t\targs:    args{s: \"-12300E4\"},\n\t\t\twantNs:  \"-12300E4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and exponential notation and capital E and leading zeros\",\n\t\t\targs:    args{s: \"+00123E4\"},\n\t\t\twantNs:  \"+00123E4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading minus sign and exponential notation and capital E and leading zeros\",\n\t\t\targs:    args{s: \"-00123E4\"},\n\t\t\twantNs:  \"-00123E4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and exponential notation and capital E and leading and trailing zeros\",\n\t\t\targs:    args{s: \"+0012300E4\"},\n\t\t\twantNs:  \"+0012300E4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading minus sign and exponential notation and capital E and leading and trailing zeros\",\n\t\t\targs:    args{s: \"-0012300E4\"},\n\t\t\twantNs:  \"-0012300E4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and exponential notation and capital E and decimal point\",\n\t\t\targs:    args{s: \"+123.456E4\"},\n\t\t\twantNs:  \"+123.456E4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading minus sign and exponential notation and capital E and decimal point\",\n\t\t\targs:    args{s: \"-123.456E4\"},\n\t\t\twantNs:  \"-123.456E4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and exponential notation and capital E and decimal point and trailing zeros\",\n\t\t\targs:    args{s: \"+123.45600E4\"},\n\t\t\twantNs:  \"+123.45600E4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading minus sign and exponential notation and capital E and decimal point and trailing zeros\",\n\t\t\targs:    args{s: \"-123.45600E4\"},\n\t\t\twantNs:  \"-123.45600E4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and exponential notation and capital E and decimal point and leading zeros\",\n\t\t\targs:    args{s: \"+00123.456E4\"},\n\t\t\twantNs:  \"+00123.456E4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading minus sign and exponential notation and capital E and decimal point and leading zeros\",\n\t\t\targs:    args{s: \"-00123.456E4\"},\n\t\t\twantNs:  \"-00123.456E4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and exponential notation and capital E and decimal point and leading and trailing zeros\",\n\t\t\targs:    args{s: \"+00123.45600E4\"},\n\t\t\twantNs:  \"+00123.45600E4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading minus sign and exponential notation and capital E and decimal point and leading and trailing zeros\",\n\t\t\targs:    args{s: \"-00123.45600E4\"},\n\t\t\twantNs:  \"-00123.45600E4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"inf\",\n\t\t\targs:    args{s: \"inf\"},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"Inf\",\n\t\t\targs:    args{s: \"Inf\"},\n\t\t\twantNs:  \"Inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"inF\",\n\t\t\targs:    args{s: \"inF\"},\n\t\t\twantNs:  \"inF\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"iNf\",\n\t\t\targs:    args{s: \"iNf\"},\n\t\t\twantNs:  \"iNf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"inf+\",\n\t\t\targs:    args{s: \"inf+\"},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"inf-\",\n\t\t\targs:    args{s: \"inf-\"},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"nan\",\n\t\t\targs:    args{s: \"nan\"},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"Nan\",\n\t\t\targs:    args{s: \"Nan\"},\n\t\t\twantNs:  \"Nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"nAn\",\n\t\t\targs:    args{s: \"nAn\"},\n\t\t\twantNs:  \"nAn\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"NaN\",\n\t\t\targs:    args{s: \"NaN\"},\n\t\t\twantNs:  \"NaN\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"nan+\",\n\t\t\targs:    args{s: \"nan+\"},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"nan-\",\n\t\t\targs:    args{s: \"nan-\"},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number\",\n\t\t\targs:    args{s: \"123a\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading plus sign\",\n\t\t\targs:    args{s: \"+123a\"},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading minus sign\",\n\t\t\targs:    args{s: \"-123a\"},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+12300a\"},\n\t\t\twantNs:  \"+12300\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading minus sign and trailing zeros\",\n\t\t\targs:    args{s: \"-12300a\"},\n\t\t\twantNs:  \"-12300\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading plus sign and leading zeros\",\n\t\t\targs:    args{s: \"+00123a\"},\n\t\t\twantNs:  \"+00123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading minus sign and leading zeros\",\n\t\t\targs:    args{s: \"-00123a\"},\n\t\t\twantNs:  \"-00123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading plus sign and leading and trailing zeros\",\n\t\t\targs:    args{s: \"+0012300a\"},\n\t\t\twantNs:  \"+0012300\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading minus sign and leading and trailing zeros\",\n\t\t\targs:    args{s: \"-0012300a\"},\n\t\t\twantNs:  \"-0012300\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading plus sign and decimal point\",\n\t\t\targs:    args{s: \"+123.456a\"},\n\t\t\twantNs:  \"+123.456\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading minus sign and decimal point\",\n\t\t\targs:    args{s: \"-123.456a\"},\n\t\t\twantNs:  \"-123.456\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading plus sign and decimal point and trailing zeros\",\n\t\t\targs:    args{s: \"+123.45600a\"},\n\t\t\twantNs:  \"+123.45600\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading minus sign and decimal point and trailing zeros\",\n\t\t\targs:    args{s: \"-123.45600a\"},\n\t\t\twantNs:  \"-123.45600\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading plus sign and decimal point and leading zeros\",\n\t\t\targs:    args{s: \"+00123.456a\"},\n\t\t\twantNs:  \"+00123.456\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading minus sign and decimal point and leading zeros\",\n\t\t\targs:    args{s: \"-00123.456a\"},\n\t\t\twantNs:  \"-00123.456\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading plus sign and decimal point and leading and trailing zeros\",\n\t\t\targs:    args{s: \"+00123.45600a\"},\n\t\t\twantNs:  \"+00123.45600\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading minus sign and decimal point and leading and trailing zeros\",\n\t\t\targs:    args{s: \"-00123.45600a\"},\n\t\t\twantNs:  \"-00123.45600\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading plus sign and exponential notation\",\n\t\t\targs:    args{s: \"+123e4a\"},\n\t\t\twantNs:  \"+123e4\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading minus sign and exponential notation\",\n\t\t\targs:    args{s: \"-123e4a\"},\n\t\t\twantNs:  \"-123e4\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading plus sign and exponential notation and trailing zeros\",\n\t\t\targs:    args{s: \"+12300e4a\"},\n\t\t\twantNs:  \"+12300e4\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading minus sign and exponential notation and trailing zeros\",\n\t\t\targs:    args{s: \"-12300e4a\"},\n\t\t\twantNs:  \"-12300e4\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading plus sign and exponential notation and leading zeros\",\n\t\t\targs:    args{s: \"+00123e4a\"},\n\t\t\twantNs:  \"+00123e4\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading minus sign and exponential notation and leading zeros\",\n\t\t\targs:    args{s: \"-00123e4a\"},\n\t\t\twantNs:  \"-00123e4\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading plus sign and exponential notation and leading and trailing zeros\",\n\t\t\targs:    args{s: \"+0012300e4a\"},\n\t\t\twantNs:  \"+0012300e4\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading minus sign and exponential notation and leading and trailing zeros\",\n\t\t\targs:    args{s: \"-0012300e4a\"},\n\t\t\twantNs:  \"-0012300e4\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading plus sign and exponential notation and decimal point\",\n\t\t\targs:    args{s: \"+123.456e4a\"},\n\t\t\twantNs:  \"+123.456e4\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading minus sign and exponential notation and decimal point\",\n\t\t\targs:    args{s: \"-123.456e4a\"},\n\t\t\twantNs:  \"-123.456e4\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading plus sign and exponential notation and decimal point and trailing zeros\",\n\t\t\targs:    args{s: \"+123.45600e4a\"},\n\t\t\twantNs:  \"+123.45600e4\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading minus sign and exponential notation and decimal point and trailing zeros\",\n\t\t\targs:    args{s: \"-123.45600e4a\"},\n\t\t\twantNs:  \"-123.45600e4\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading plus sign and exponential notation and decimal point and leading zeros\",\n\t\t\targs:    args{s: \"+00123.456e4a\"},\n\t\t\twantNs:  \"+00123.456e4\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading minus sign and exponential notation and decimal point and leading zeros\",\n\t\t\targs:    args{s: \"-00123.456e4a\"},\n\t\t\twantNs:  \"-00123.456e4\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading plus sign and exponential notation and decimal point and leading and trailing zeros\",\n\t\t\targs:    args{s: \"+00123.45600e4a\"},\n\t\t\twantNs:  \"+00123.45600e4\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading minus sign and exponential notation and decimal point and leading and trailing zeros\",\n\t\t\targs:    args{s: \"-00123.45600e4a\"},\n\t\t\twantNs:  \"-00123.45600e4\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading plus sign and exponential notation and capital E\",\n\t\t\targs:    args{s: \"+123E4a\"},\n\t\t\twantNs:  \"+123E4\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading minus sign and exponential notation and capital E\",\n\t\t\targs:    args{s: \"-123E4a\"},\n\t\t\twantNs:  \"-123E4\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading plus sign and exponential notation and capital E and trailing zeros\",\n\t\t\targs:    args{s: \"+12300E4a\"},\n\t\t\twantNs:  \"+12300E4\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading minus sign and exponential notation and capital E and trailing zeros\",\n\t\t\targs:    args{s: \"-12300E4a\"},\n\t\t\twantNs:  \"-12300E4\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading plus sign and exponential notation and capital E and leading zeros\",\n\t\t\targs:    args{s: \"+00123E4a\"},\n\t\t\twantNs:  \"+00123E4\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading minus sign and exponential notation and capital E and leading zeros\",\n\t\t\targs:    args{s: \"-00123E4a\"},\n\t\t\twantNs:  \"-00123E4\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading plus sign and exponential notation and capital E and leading and trailing zeros\",\n\t\t\targs:    args{s: \"+0012300E4a\"},\n\t\t\twantNs:  \"+0012300E4\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading minus sign and exponential notation and capital E and leading and trailing zeros\",\n\t\t\targs:    args{s: \"-0012300E4a\"},\n\t\t\twantNs:  \"-0012300E4\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading plus sign and exponential notation and capital E and decimal point\",\n\t\t\targs:    args{s: \"+123.456E4a\"},\n\t\t\twantNs:  \"+123.456E4\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading minus sign and exponential notation and capital E and decimal point\",\n\t\t\targs:    args{s: \"-123.456E4a\"},\n\t\t\twantNs:  \"-123.456E4\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading plus sign and exponential notation and capital E and decimal point and trailing zeros\",\n\t\t\targs:    args{s: \"+123.45600E4a\"},\n\t\t\twantNs:  \"+123.45600E4\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n",
    "033289b6ad4a2cc3c8f2036ab17e5a0b": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"single element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,3]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[[1,2],[3,4]]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"4\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with string elements\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[\\\"hello\\\",\\\"world\\\"]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"hello\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"world\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1,2\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"array with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1 2]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1 2]\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseArray() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "033e68fd7e13f2d9c2f9e28af7b159b4": "package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u world\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u world\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\\\\\ \\\\/\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\x\\\\u world\"},\n\t\t\twant: \"\\\"hello\\\" \\\\world\\\\ /\\\\b\\\\f\\\\n\\\\r\\tabcüòÅ\\\\x\\\\u world\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "038822c39cb85eb822913d7b1c215e0d": "```go\npackage fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth + 1,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"{}\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\": \"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"value1\", \"value2\"]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"value\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"value\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   `true`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueTrue,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   `false`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueFalse,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   `null`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueNull,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with decimal\",\n\t\t\targs: args{\n\t\t\t\ts:   `123.456`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e+4`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e-4`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"1.23e-4\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `-123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zero\",\n\t\t\targs: args{\n\t\t\t\ts:   `0123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"0123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with trailing zero\",\n\t\t\targs: args{\n\t\t\t\ts:   `123.0`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123.0\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading plus sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `+123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"+123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   `NaN`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with Infinity\",\n\t\t\targs: args{\n\t\t\t\ts:   `Infinity`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"Infinity\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative Infinity\",\n\t\t\targs: args{\n\t\t\t\ts:   `-Infinity`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-Infinity\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123.456.789`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123.456.789\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e+4.5`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e+4.5\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e-4.5`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e-4.5\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading zero\",\n\t\t\targs: args{\n\t\t\t\ts:   `00123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"00123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing zero\",\n\t\t\targs: args{\n\t\t\t\ts:   `123.00`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123.00\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `++123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"++123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `--123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"--123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading dot\",\n\t\t\targs: args{\n\t\t\t\ts:   `.123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \".123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing dot\",\n\t\t\targs: args{\n\t\t\t\ts:   `123.`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123.\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with multiple dots\",\n\t\t\targs: args{\n\t\t\t\ts:   `123..456`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123..456\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with multiple exponents\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e+4e+5`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e+4e+5\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with multiple signs\",\n\t\t\targs: args{\n\t\t\t\ts:   `+123-456`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"+123-456\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid exponent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e+`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e+\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid exponent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e-`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e-\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid exponent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e+`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e+\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid exponent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e-`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e-\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid exponent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e+`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e+\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid exponent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e-`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e-\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid exponent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e+`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e+\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid exponent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e-`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e-\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid exponent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e+`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e+\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid exponent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e-`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e-\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid exponent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e+`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e+\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid exponent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e-`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e-\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid exponent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e+`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e+\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid exponent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e-`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e-\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid exponent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e+`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e+\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid exponent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e-`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e-\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid exponent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e+`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e+\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid exponent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e-`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e-\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid exponent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e+`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e+\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid exponent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e-`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e-\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid exponent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e+`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e+\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid exponent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e-`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e-\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid exponent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e+`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e+\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid exponent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e-`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e-\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid exponent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e+`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e+\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid exponent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e-`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e-\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid exponent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e+`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e+\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid exponent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e-`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e-\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid exponent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e+`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e+\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid exponent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e-`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e-\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid exponent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e+`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e+\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid exponent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e-`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e-\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid exponent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e+`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e+\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid exponent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e-`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e-\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid exponent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e+`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e+\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid exponent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e-`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e-\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid exponent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e+`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e+\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid exponent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e-`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e-\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid exponent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e+`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e+\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid exponent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e-`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e-\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid exponent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e+`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e+\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid exponent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e-`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e-\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid exponent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e+`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e+\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid exponent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e-`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e-\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid exponent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e+`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e+\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid exponent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e-`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e-\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid exponent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e+`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e+\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid exponent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e-`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e-\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid exponent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e+`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e+\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid exponent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e-`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e-\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid exponent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e+`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e+\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid exponent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e-`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e-\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid exponent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e+`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e+\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid exponent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e-`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e-\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid exponent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e+`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e+\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid exponent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e-`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e-\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid exponent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e+`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e+\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid exponent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e-`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e-\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid exponent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e+`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e+\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid exponent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e-`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e-\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid exponent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e+`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e+\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid exponent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e-`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e-\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid exponent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e+`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e+\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid exponent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e-`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e-\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid exponent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e+`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e+\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid exponent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e-`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e-\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{",
    "04d0d806717ea36eb17f2b72144f32a0": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetBool(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant bool\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.GetBool(tt.args.keys...); got != tt.want {\n\t\t\t\tt.Errorf(\"Value.GetBool() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "04d6e97909589953719868a25b6e57cd": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantKey string\n\t\twantRest string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"simple key\",\n\t\t\targs:    args{s: `\"key\"`},\n\t\t\twantKey: \"key\",\n\t\t\twantRest: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"key with spaces\",\n\t\t\targs:    args{s: `\"key with spaces\"`},\n\t\t\twantKey: \"key with spaces\",\n\t\t\twantRest: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"key with escaped characters\",\n\t\t\targs:    args{s: `\"key\\\\\"with\\\\\"escaped\\\\\"characters\"`},\n\t\t\twantKey: \"key\\\\\\\"with\\\\\\\"escaped\\\\\\\"characters\",\n\t\t\twantRest: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"missing closing quote\",\n\t\t\targs:    args{s: `\"key`},\n\t\t\twantKey: \"key\",\n\t\t\twantRest: \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"empty key\",\n\t\t\targs:    args{s: `\"\"`},\n\t\t\twantKey: \"\",\n\t\t\twantRest: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotKey, gotRest, err := parseRawKey(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawKey() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotKey != tt.wantKey {\n\t\t\t\tt.Errorf(\"parseRawKey() gotKey = %v, want %v\", gotKey, tt.wantKey)\n\t\t\t}\n\t\t\tif gotRest != tt.wantRest {\n\t\t\t\tt.Errorf(\"parseRawKey() gotRest = %v, want %v\", gotRest, tt.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}",
    "04dc8272468e903ebae88b5145747003": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_reset(t *testing.T) {\n\ttype args struct {\n\t\to *Object\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant *Object\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.o.reset(); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Object.reset() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0579ad30148187ef9637d5bc4d216b67": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\tv   *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"marshal raw string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: typeRawString, s: \"hello world\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello world\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal object\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}}, {k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}}}}},\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":\"value1\",\"key2\":123}`),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal array\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeArray, a: []*Value{{t: TypeString, s: \"value1\"}, {t: TypeNumber, s: \"123\"}}},\n\t\t\t},\n\t\t\twant: []byte(`[\"value1\",123]`),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeString, s: \"hello world\"},\n\t\t\t},\n\t\t\twant: []byte(`\"hello world\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal number\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t},\n\t\t\twant: []byte(`123`),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal true\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeTrue},\n\t\t\t},\n\t\t\twant: []byte(`true`),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal false\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeFalse},\n\t\t\t},\n\t\t\twant: []byte(`false`),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal null\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNull},\n\t\t\t},\n\t\t\twant: []byte(`null`),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.v.MarshalTo(tt.args.dst); !bytesEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc bytesEqual(a, b []byte) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "05d5d41f64663ccd061a86a2c50439e7": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\"world\\\\\\\"\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped backslash\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\\world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: ``,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with no quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `hello`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "05f386d6426b2ba51ab1618802020780": "```go\npackage fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u world\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\ux\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\ux\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 2\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00x\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00x\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 3\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0x\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0x\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 4\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 5\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 6\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 7\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 8\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 9\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 10\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 11\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 12\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 13\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 14\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 15\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 16\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 17\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 18\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 19\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 20\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 21\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 22\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 23\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 24\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 25\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 26\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 27\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 28\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 29\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 30\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 31\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 32\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 33\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 34\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 35\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 36\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 37\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789012\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789012\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 38\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890123\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890123\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 39\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901234\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901234\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 40\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789012345\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789012345\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 41\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890123456\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890123456\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 42\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901234567\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901234567\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 43\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789012345678\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789012345678\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 44\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890123456789\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890123456789\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 45\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901234567890\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901234567890\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 46\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789012345678901\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789012345678901\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 47\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890123456789012\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890123456789012\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 48\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901234567890123\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901234567890123\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 49\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789012345678901234\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789012345678901234\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 50\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890123456789012345\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890123456789012345\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 51\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901234567890123456\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901234567890123456\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 52\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789012345678901234567\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789012345678901234567\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 53\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890123456789012345678\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890123456789012345678\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 54\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901234567890123456789\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901234567890123456789\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 55\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789012345678901234567890\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789012345678901234567890\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 56\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890123456789012345678901\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890123456789012345678901\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 57\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901234567890123456789012\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901234567890123456789012\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 58\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789012345678901234567890123\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789012345678901234567890123\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 59\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890123456789012345678901234\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890123456789012345678901234\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 60\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901234567890123456789012345\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901234567890123456789012345\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 61\",\n\t\t\targs:",
    "07b09c2d02a2a43bf3bdfe6d215f6090": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestInt(t *testing.T) {\n\ttype args struct {\n\t\tv *Value\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    int\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := tt.args.v.Int()\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Int() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Int() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0939d19a198a44e82a69f74a6213352e": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\"world\\\\\\\"\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quotes and other characters\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"\\\\\\\\\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\\\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: ``,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with no quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `hello`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "09ab002c025559c976b4c2b3658e55f7": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts: \"null\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts: \"true\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts: \"false\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello\\\"\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts: \"[1,2,3]\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts: `{\"key1\": \"value1\", \"key2\": 2}`,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested object\",\n\t\t\targs: args{\n\t\t\t\ts: `{\"key1\": {\"key2\": \"value2\"}}`,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts: `{\"key1\": [1, 2, 3]}`,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid json\",\n\t\t\targs: args{\n\t\t\t\ts: `{\"key1\": \"value1\", \"key2\": 2`,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tp := \u0026Parser{}\n\t\t\tgot, err := p.Parse(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Parse() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr {\n\t\t\t\tif !compareValues(got, tt.want) {\n\t\t\t\t\tt.Errorf(\"Parse() = %v, want %v\", got, tt.want)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeNull:\n\t\treturn true\n\tcase TypeTrue:\n\t\treturn true\n\tcase TypeFalse:\n\t\treturn true\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !compareValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !compareValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc TestParse_CompareWithStdlib(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t}{\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts: \"null\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts: \"true\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts: \"false\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello\\\"\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts: \"[1,2,3]\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts: `{\"key1\": \"value1\", \"key2\": 2}`,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"nested object\",\n\t\t\targs: args{\n\t\t\t\ts: `{\"key1\": {\"key2\": \"value2\"}}`,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts: `{\"key1\": [1, 2, 3]}`,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tp := \u0026Parser{}\n\t\t\tgot, err := p.Parse(tt.args.s)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Parse() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tvar want interface{}\n\t\t\tif err := json.Unmarshal([]byte(tt.args.s), \u0026want); err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !compareValuesWithStdlib(got, want) {\n\t\t\t\tt.Errorf(\"Parse() = %v, want %v\", got, want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValuesWithStdlib(v *Value, want interface{}) bool {\n\tswitch want := want.(type) {\n\tcase nil:\n\t\treturn v.t == TypeNull\n\tcase bool:\n\t\tif v.t == TypeTrue {\n\t\t\treturn want\n\t\t}\n\t\tif v.t == TypeFalse {\n\t\t\treturn !want\n\t\t}\n\t\treturn false\n\tcase float64:\n\t\tif v.t != TypeNumber {\n\t\t\treturn false\n\t\t}\n\t\tf, err := v.Float64()\n\t\tif err != nil {\n\t\t\treturn false\n\t\t}\n\t\treturn f == want\n\tcase string:\n\t\tif v.t != TypeString {\n\t\t\treturn false\n\t\t}\n\t\treturn v.s == want\n\tcase []interface{}:\n\t\tif v.t != TypeArray {\n\t\t\treturn false\n\t\t}\n\t\tif len(v.a) != len(want) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v.a {\n\t\t\tif !compareValuesWithStdlib(v.a[i], want[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase map[string]interface{}:\n\t\tif v.t != TypeObject {\n\t\t\treturn false\n\t\t}\n\t\tif len(v.o.kvs) != len(want) {\n\t\t\treturn false\n\t\t}\n\t\tfor k, w := range want {\n\t\t\tfor _, kv := range v.o.kvs {\n\t\t\t\tif kv.k == k {\n\t\t\t\t\tif !compareValuesWithStdlib(kv.v, w) {\n\t\t\t\t\t\treturn false\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}",
    "0a78ec200670858320d02e398f83adb6": "```go\npackage fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"single character\",\n\t\t\targs: args{\n\t\t\t\ts:   \"a\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"a\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\": \"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"value1\", \"value2\"]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"value\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"value\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   `true`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueTrue,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   `false`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueFalse,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   `null`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueNull,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative number\",\n\t\t\targs: args{\n\t\t\t\ts:   `-123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"float number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123.456`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential number\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e+4`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   `NaN`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\": \"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key\": \"value\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseValue() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseValue_JSON(t *testing.T) {\n\ttype testCase struct {\n\t\tjson string\n\t\twant string\n\t}\n\ttestCases := []testCase{\n\t\t{\n\t\t\tjson: `{\"key\": \"value\"}`,\n\t\t\twant: `{\"key\":\"value\"}`,\n\t\t},\n\t\t{\n\t\t\tjson: `{\"key\": 123}`,\n\t\t\twant: `{\"key\":123}`,\n\t\t},\n\t\t{\n\t\t\tjson: `{\"key\": true}`,\n\t\t\twant: `{\"key\":true}`,\n\t\t},\n\t\t{\n\t\t\tjson: `{\"key\": false}`,\n\t\t\twant: `{\"key\":false}`,\n\t\t},\n\t\t{\n\t\t\tjson: `{\"key\": null}`,\n\t\t\twant: `{\"key\":null}`,\n\t\t},\n\t\t{\n\t\t\tjson: `{\"key\": [1, 2, 3]}`,\n\t\t\twant: `{\"key\":[1,2,3]}`,\n\t\t},\n\t\t{\n\t\t\tjson: `{\"key\": {\"nested\": \"value\"}}`,\n\t\t\twant: `{\"key\":{\"nested\":\"value\"}}`,\n\t\t},\n\t\t{\n\t\t\tjson: `{\"key\": \"value\", \"key2\": \"value2\"}`,\n\t\t\twant: `{\"key\":\"value\",\"key2\":\"value2\"}`,\n\t\t},\n\t\t{\n\t\t\tjson: `[1, 2, 3]`,\n\t\t\twant: `[1,2,3]`,\n\t\t},\n\t\t{\n\t\t\tjson: `[{\"key\": \"value\"}, {\"key\": \"value2\"}]`,\n\t\t\twant: `[{\"key\":\"value\"},{\"key\":\"value2\"}]`,\n\t\t},\n\t\t{\n\t\t\tjson: `[1, \"2\", true, false, null]`,\n\t\t\twant: `[1,\"2\",true,false,null]`,\n\t\t},\n\t\t{\n\t\t\tjson: `123`,\n\t\t\twant: `123`,\n\t\t},\n\t\t{\n\t\t\tjson: `-123`,\n\t\t\twant: `-123`,\n\t\t},\n\t\t{\n\t\t\tjson: `123.4",
    "0ac5d665a06f3aea0c44fc787c1e6312": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           make([]kv, 0),\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\"`,\n\t\t\t\tc:    \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\"`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\" \"value1\"}`,\n\t\t\t\tc:    \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_JSONUnmarshal(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    map[string]interface{}\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    map[string]interface{}{},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    map[string]interface{}{\"key1\": \"value1\", \"key2\": \"value2\"},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    map[string]interface{}{\"key1\": map[string]interface{}{\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    map[string]interface{}{\"key\\\"1\": \"value1\"},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif tt.wantErr {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tvar wantJSON map[string]interface{}\n\t\t\tif err := json.Unmarshal([]byte(tt.args.s), \u0026wantJSON); err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got.o.ToMap(), wantJSON) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got.o.ToMap(), wantJSON)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0b937229edec31861deb151c4b2bde02": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"single element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,3]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[[1,2],[3,4]]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"4\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with string\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[\\\"hello\\\", \\\"world\\\"]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"hello\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"world\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1,2\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"array with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1 2]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1 2]\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseArray() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0caf733fa5305edee132705c431f4cb5": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestValueUint(t *testing.T) {\n\ttype args struct {\n\t\tv *Value\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    uint\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"ValidUint\",\n\t\t\targs: args{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"12345\",\n\t\t\t\t},\n\t\t\t},\n\t\t\twant:    12345,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"InvalidUint\",\n\t\t\targs: args{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"18446744073709551616\", // uint64 max + 1\n\t\t\t\t},\n\t\t\t},\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"InvalidType\",\n\t\t\targs: args{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeString,\n\t\t\t\t\ts: \"abc\",\n\t\t\t\t},\n\t\t\t},\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := tt.args.v.Uint()\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Value.Uint() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Value.Uint() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0cd53799171f8eab7a7786371d5f8f6a": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"empty string\",\n\t\t\targs:    args{s: \"\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"single digit\",\n\t\t\targs:    args{s: \"1\"},\n\t\t\twantNs:  \"1\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"multiple digits\",\n\t\t\targs:    args{s: \"123\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"decimal number\",\n\t\t\targs:    args{s: \"123.456\"},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"negative number\",\n\t\t\targs:    args{s: \"-123\"},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"positive number\",\n\t\t\targs:    args{s: \"+123\"},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"exponential number\",\n\t\t\targs:    args{s: \"1.23e+4\"},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"exponential number with lowercase e\",\n\t\t\targs:    args{s: \"1.23e-4\"},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading zeros\",\n\t\t\targs:    args{s: \"00123\"},\n\t\t\twantNs:  \"00123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with trailing zeros\",\n\t\t\targs:    args{s: \"123.00\"},\n\t\t\twantNs:  \"123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign\",\n\t\t\targs:    args{s: \"+123\"},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading minus sign\",\n\t\t\targs:    args{s: \"-123\"},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading whitespace\",\n\t\t\targs:    args{s: \" 123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" 123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with trailing whitespace\",\n\t\t\targs:    args{s: \"123 \"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \" \",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with internal whitespace\",\n\t\t\targs:    args{s: \"12 3\"},\n\t\t\twantNs:  \"12\",\n\t\t\twantS:   \" 3\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with invalid character\",\n\t\t\targs:    args{s: \"123a\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with inf\",\n\t\t\targs:    args{s: \"123inf\"},\n\t\t\twantNs:  \"123inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with inf lowercase\",\n\t\t\targs:    args{s: \"123inf\"},\n\t\t\twantNs:  \"123inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with nan\",\n\t\t\targs:    args{s: \"123nan\"},\n\t\t\twantNs:  \"123nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with nan lowercase\",\n\t\t\targs:    args{s: \"123nan\"},\n\t\t\twantNs:  \"123nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with inf at the beginning\",\n\t\t\targs:    args{s: \"inf123\"},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"123\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with nan at the beginning\",\n\t\t\targs:    args{s: \"nan123\"},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"123\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with inf at the beginning with leading whitespace\",\n\t\t\targs:    args{s: \" inf123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" inf123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with nan at the beginning with leading whitespace\",\n\t\t\targs:    args{s: \" nan123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" nan123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with inf at the beginning with trailing whitespace\",\n\t\t\targs:    args{s: \"inf123 \"},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"123 \",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with nan at the beginning with trailing whitespace\",\n\t\t\targs:    args{s: \"nan123 \"},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"123 \",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with inf at the beginning with internal whitespace\",\n\t\t\targs:    args{s: \"inf 123\"},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \" 123\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with nan at the beginning with internal whitespace\",\n\t\t\targs:    args{s: \"nan 123\"},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \" 123\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0d8972029cfd570b7b6fadd35e2a9a42": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Type(t *testing.T) {\n\ttype args struct {\n\t\tv *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant Type\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.v.Type(); got != tt.want {\n\t\t\t\tt.Errorf(\"Value.Type() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0dd52c43968564e6763558b0b79bfa78": "```go\npackage fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth + 1,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"{}\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\": \"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"value1\", \"value2\"]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"value\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"value\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   `true`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueTrue,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   `false`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueFalse,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   `null`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueNull,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with decimal\",\n\t\t\targs: args{\n\t\t\t\ts:   `123.456`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e+4`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e-4`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"1.23e-4\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `-123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with positive sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `+123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"+123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zero\",\n\t\t\targs: args{\n\t\t\t\ts:   `0123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"0123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with trailing zero\",\n\t\t\targs: args{\n\t\t\t\ts:   `123.0`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123.0\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zero and decimal\",\n\t\t\targs: args{\n\t\t\t\ts:   `0.123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"0.123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zero and exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `0e+4`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth:",
    "0e137cd85ee0d22389c92c89df6ce95f": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_JSON(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_JSON_Compare(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tvar want map[string]interface{}\n\t\t\tif err := json.Unmarshal([]byte(tt.args.s), \u0026want); err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got.o.kvs, want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got.o.kvs, want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0e2fc36867a75303a40fd010715ca652": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts: \"null\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts: \"true\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts: \"false\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello\\\"\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts: \"[1, 2, 3]\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts: `{\"key1\": \"value1\", \"key2\": 2}`,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested object\",\n\t\t\targs: args{\n\t\t\t\ts: `{\"key1\": {\"key2\": \"value2\"}}`,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts: `{\"key1\": [1, 2, 3]}`,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid json\",\n\t\t\targs: args{\n\t\t\t\ts: \"{\",\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tp := \u0026Parser{}\n\t\t\tgot, err := p.Parse(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Parse() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr {\n\t\t\t\tif !compareValue(got, tt.want) {\n\t\t\t\t\tt.Errorf(\"Parse() = %v, want %v\", got, tt.want)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValue(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeNull:\n\t\treturn true\n\tcase TypeTrue:\n\t\treturn true\n\tcase TypeFalse:\n\t\treturn true\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !compareValue(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !compareValue(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc TestParse_InvalidJSON(t *testing.T) {\n\tp := \u0026Parser{}\n\t_, err := p.Parse(\"{\")\n\tif err == nil {\n\t\tt.Errorf(\"Parse() should have returned an error for invalid JSON\")\n\t}\n}\n\nfunc TestParse_UnescapedString(t *testing.T) {\n\tp := \u0026Parser{}\n\t_, err := p.Parse(`{\"key\": \"value\\n\"}`)\n\tif err != nil {\n\t\tt.Errorf(\"Parse() should have parsed unescaped string: %v\", err)\n\t}\n}\n\nfunc TestParse_LargeJSON(t *testing.T) {\n\t// Create a large JSON string\n\tvar largeJSON []byte\n\tfor i := 0; i \u003c 10000; i++ {\n\t\tlargeJSON = append(largeJSON, []byte(fmt.Sprintf(`{\"key%d\": \"value%d\"}`, i, i))...)\n\t\tif i \u003c 9999 {\n\t\t\tlargeJSON = append(largeJSON, ',')\n\t\t}\n\t}\n\tlargeJSON = append(largeJSON, ']')\n\n\t// Parse the large JSON string\n\tp := \u0026Parser{}\n\t_, err := p.Parse(string(largeJSON))\n\tif err != nil {\n\t\tt.Errorf(\"Parse() should have parsed large JSON: %v\", err)\n\t}\n}\n\nfunc TestParse_CompareWithStdlib(t *testing.T) {\n\ttests := []string{\n\t\t`{\"key1\": \"value1\", \"key2\": 2}`,\n\t\t`{\"key1\": [1, 2, 3], \"key2\": {\"key3\": \"value3\"}}`,\n\t\t`{\"key1\": {\"key2\": \"value2\", \"key3\": [1, 2, 3]}, \"key2\": 4}`,\n\t}\n\tfor _, test := range tests {\n\t\tt.Run(test, func(t *testing.T) {\n\t\t\tp := \u0026Parser{}\n\t\t\tv, err := p.Parse(test)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Parse() error: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tvar stdlibValue interface{}\n\t\t\terr = json.Unmarshal([]byte(test), \u0026stdlibValue)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !compareValueWithStdlib(v, stdlibValue) {\n\t\t\t\tt.Errorf(\"Parse() result does not match json.Unmarshal() result\")\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValueWithStdlib(v *Value, stdlibValue interface{}) bool {\n\tswitch stdlibValue := stdlibValue.(type) {\n\tcase nil:\n\t\treturn v.t == TypeNull\n\tcase bool:\n\t\treturn (v.t == TypeTrue \u0026\u0026 stdlibValue) || (v.t == TypeFalse \u0026\u0026 !stdlibValue)\n\tcase string:\n\t\treturn v.t == TypeString \u0026\u0026 v.s == stdlibValue\n\tcase float64:\n\t\treturn v.t == TypeNumber \u0026\u0026 v.s == fmt.Sprintf(\"%f\", stdlibValue)\n\tcase []interface{}:\n\t\tif v.t != TypeArray || len(v.a) != len(stdlibValue) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v.a {\n\t\t\tif !compareValueWithStdlib(v.a[i], stdlibValue[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase map[string]interface{}:\n\t\tif v.t != TypeObject || len(v.o.kvs) != len(stdlibValue) {\n\t\t\treturn false\n\t\t}\n\t\tfor k, v2 := range stdlibValue {\n\t\t\tfound := false\n\t\t\tfor _, kv := range v.o.kvs {\n\t\t\t\tif kv.k == k {\n\t\t\t\t\tfound = true\n\t\t\t\t\tif !compareValueWithStdlib(kv.v, v2) {\n\t\t\t\t\t\treturn false\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !found {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}",
    "0e9eb289cd868b9e3366eb39a10000e2": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"single element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,3]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[[1,2],[3,4]]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"4\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with whitespace\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[ 1 , 2 , 3 ]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,3\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1,2,3\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1 2,3]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1 2,3]\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid array value\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,a]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1,2,a]\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseArray() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0f26a105e8a6525daf65d26615bb027c": "package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u world\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u world\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\\\\\ \\\\/\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\x\\\\u world\"},\n\t\t\twant: \"\\\"hello\\\" \\\\world\\\\ /\\\\b\\\\f\\\\n\\\\r\\tabcüòÅ\\\\x\\\\u world\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0f616e71d39628a3904565c42de8b8bc": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCacheGetValue(t *testing.T) {\n\tt.Run(\"empty cache\", func(t *testing.T) {\n\t\tc := \u0026cache{}\n\t\tv := c.getValue()\n\t\tif v == nil {\n\t\t\tt.Error(\"getValue() returned nil for empty cache\")\n\t\t}\n\t})\n\n\tt.Run(\"non-empty cache\", func(t *testing.T) {\n\t\tc := \u0026cache{vs: []Value{{t: TypeString, s: \"test\"}}}\n\t\tv := c.getValue()\n\t\tif v == nil {\n\t\t\tt.Error(\"getValue() returned nil for non-empty cache\")\n\t\t}\n\t\tif v.t != TypeString || v.s != \"test\" {\n\t\t\tt.Errorf(\"getValue() returned unexpected value: %v\", v)\n\t\t}\n\t})\n\n\tt.Run(\"capacity greater than length\", func(t *testing.T) {\n\t\tc := \u0026cache{vs: make([]Value, 1, 10)}\n\t\tv := c.getValue()\n\t\tif v == nil {\n\t\t\tt.Error(\"getValue() returned nil for cache with capacity greater than length\")\n\t\t}\n\t})\n}",
    "102240021d6c63d042cc29f0cf5c3c80": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_getKV(t *testing.T) {\n\ttype args struct {\n\t\to *Object\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant *kv\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.o.getKV(); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Object.getKV() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "10bbc6828a6fc03332fc16f5cfb25807": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"simple integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"float\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential notation\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential notation with negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e-4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"inf\",\n\t\t\t},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"nan\",\n\t\t\t},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123a\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"-inf\",\n\t\t\t},\n\t\t\twantNs:  \"-inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"-nan\",\n\t\t\t},\n\t\t\twantNs:  \"-nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}",
    "127578a71a6a36cc5701f713d549647a": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\" \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "131c5e909188ccddbdbc641839726007": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"single element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,3]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[[1,2],[3,4]]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"4\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1,2\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"array with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1 2]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1 2]\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseArray() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "13ac2e84e94bb35e0a1906d0f00aa5aa": "package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061hello\\\\u0062 world\"},\n\t\t\twant: \"ahello b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01hello\\\\uD83D\\\\uDE02 world\"},\n\t\t\twant: \"üòÅhelloüòÇ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061hello\\\\u world\"},\n\t\t\twant: \"\\\\u0061hello\\\\u world\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\\\\\ \\\\/test\\\\/ \\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\uD83D\\\\uDE01\\\\x\\\\u world\"},\n\t\t\twant: \"\\\"hello\\\" \\\\world\\\\ /test/ \\b\\f\\n\\r\\taüòÅ\\\\x\\\\u world\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "148ad80a180eea71a492d6b0b24097d2": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetStringBytes(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.GetStringBytes(tt.args.keys...); !bytesEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.GetStringBytes() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc bytesEqual(a, b []byte) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "1490d6cb217dd451490dc28ee87e21f0": "```go\npackage fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"single digit\",\n\t\t\targs: args{\n\t\t\t\ts: \"1\",\n\t\t\t},\n\t\t\twantNs:  \"1\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple digits\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"decimal number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative number\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential number\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential number with lowercase e\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e-4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"inf\",\n\t\t\t},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"INF\",\n\t\t\targs: args{\n\t\t\t\ts: \"INF\",\n\t\t\t},\n\t\t\twantNs:  \"INF\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"nan\",\n\t\t\t},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NAN\",\n\t\t\targs: args{\n\t\t\t\ts: \"NAN\",\n\t\t\t},\n\t\t\twantNs:  \"NAN\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with trailing whitespace\",\n\t\t\targs: args{\n\t\t\t\ts: \"123 \",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \" \",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading whitespace\",\n\t\t\targs: args{\n\t\t\t\ts: \" 123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" 123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character\",\n\t\t\targs: args{\n\t\t\t\ts: \"123a\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at the beginning\",\n\t\t\targs: args{\n\t\t\t\ts: \"a123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"a123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"-a123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"-a123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 2\",\n\t\t\targs: args{\n\t\t\t\ts: \"+a123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+a123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 3\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 4\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 5\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 6\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 7\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 8\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 9\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 10\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 11\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 12\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 13\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 14\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 15\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 16\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 17\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 18\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 19\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 20\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 21\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 22\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 23\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 24\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 25\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 26\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 27\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 28\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 29\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 30\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 31\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 32\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 33\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 34\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 35\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 36\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 37\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 38\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 39\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 40\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 41\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 42\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 43\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 44\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 45\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 46\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 47\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 48\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 49\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 50\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 51\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 52\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 53\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 54\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 55\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 56\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 57\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 58\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 59\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 60\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 61\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 62\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 63\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 64\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 65\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 66\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 67\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 68\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 69\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 70\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 71\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 72\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 73\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 74\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 75\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 76\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 77\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 78\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 79\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 80\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 81\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 82\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 83\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 84\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 85\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 86\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 87\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 88\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 89\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 90\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 91\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 92\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 93\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 94\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 95\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 96\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 97\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 98\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 99\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 100\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 101\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 102\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 103\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 104\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 105\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 106\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 107\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 108\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 109\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character after sign 110\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false",
    "14c58917c9d82fa6db5387dd24350ac4": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{\\\"a\\\": 1}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"{\\\"a\\\": 1}\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{\\\"a\\\": 1}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"a\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[1, 2, 3]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\\\"hello\\\"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   \"true\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueTrue,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   \"false\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueFalse,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   \"null\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueNull,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   \"123\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseValue() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseValue_InvalidJSON(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"invalid object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{a: 1}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[1, 2, ]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"hello\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid true\",\n\t\t\targs: args{\n\t\t\t\ts:   \"tru\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid false\",\n\t\t\targs: args{\n\t\t\t\ts:   \"fals\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid null\",\n\t\t\targs: args{\n\t\t\t\ts:   \"nul\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number\",\n\t\t\targs: args{\n\t\t\t\ts:   \"123a\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t_, _, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseValue_CompareWithStdlib(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t}{\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts: `{\"a\": 1, \"b\": \"hello\", \"c\": true, \"d\": [1, 2, 3], \"e\": {\"f\": 4}}`,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts: `[1, \"hello\", true, [1, 2, 3], {\"f\": 4}]`,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts: `true`,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts: `false`,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts: `null`,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts: `123`,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tv, _, err := parseValue(tt.args.s, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"parseValue() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tvar stdlibValue interface{}\n\t\t\tif err := json.Unmarshal([]byte(tt.args.s), \u0026stdlibValue); err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(v, stdlibValue) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", v, stdlibValue)\n\t\t\t}\n\t\t})\n\t}\n}",
    "14fbe10b0680f4221116e7b1870b9a89": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"single element array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[1]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[1,2,3]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[[1,2],[3,4]]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"4\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with whitespace\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[ 1 , 2 , 3 ]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[1,2,3\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1,2,3\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected end of array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[1,2,\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1,2,\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing comma after array value\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[1 2,3]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1 2,3]\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseArray() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "15857d05467c9fab2c5649930ceed954": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no whitespace\",\n\t\t\targs: args{s: \"abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace\",\n\t\t\targs: args{s: \"  abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailing whitespace\",\n\t\t\targs: args{s: \"abc  \"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading and trailing whitespace\",\n\t\t\targs: args{s: \"  abc  \"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"whitespace in the middle\",\n\t\t\targs: args{s: \"a bc\"},\n\t\t\twant: \"bc\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple whitespace\",\n\t\t\targs: args{s: \"  a  b  c  \"},\n\t\t\twant: \"c\",\n\t\t},\n\t\t{\n\t\t\tname: \"all whitespace\",\n\t\t\targs: args{s: \"  \\t\\n\\r  \"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace with special character\",\n\t\t\targs: args{s: \"  \\t\\n\\r  abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailing whitespace with special character\",\n\t\t\targs: args{s: \"abc  \\t\\n\\r  \"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"whitespace with special character in the middle\",\n\t\t\targs: args{s: \"a  \\t\\n\\r  bc\"},\n\t\t\twant: \"bc\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "15a1bd9c4cb7d2c8250487d176211055": "package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u006\"},\n\t\t\twant: \"\\\\u0061\\\\u006\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\\\\\ \\\\/\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\x\\\\u006\"},\n\t\t\twant: \"\\\"hello\\\" \\\\world\\\\ /\\\\b\\\\f\\\\n\\\\r\\\\tabcüòÅ\\\\x\\\\u006\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "15d7ed731d71f30fb541c89324e4ba82": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttype want struct {\n\t\tv   *Value\n\t\ttail string\n\t\terr  error\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant want\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  fmt.Errorf(\"cannot parse empty string\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"{}\",\n\t\t\t\terr:  fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{ \\\"key\\\": \\\"value\\\" }\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[ \\\"value1\\\", \\\"value2\\\" ]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\\\"value\\\"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: typeRawString,\n\t\t\t\t\ts: \"value\",\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   \"true\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueTrue,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   \"false\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueFalse,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   \"null\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueNull,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   \"123\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"123\",\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   \"NaN\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"NaN\",\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotV, gotTail, gotErr := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif gotErr != nil \u0026\u0026 tt.want.err == nil {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, want nil\", gotErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotErr == nil \u0026\u0026 tt.want.err != nil {\n\t\t\t\tt.Errorf(\"parseValue() error = nil, want %v\", tt.want.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotErr != nil \u0026\u0026 tt.want.err != nil {\n\t\t\t\tif gotErr.Error() != tt.want.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue() error = %v, want %v\", gotErr, tt.want.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(gotV, tt.want.v) {\n\t\t\t\tt.Errorf(\"parseValue() gotV = %v, want %v\", gotV, tt.want.v)\n\t\t\t}\n\t\t\tif gotTail != tt.want.tail {\n\t\t\t\tt.Errorf(\"parseValue() gotTail = %v, want %v\", gotTail, tt.want.tail)\n\t\t\t}\n\t\t})\n\t}\n}",
    "164ccc2a2be2f8e88436d7a4daedb07f": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"{}\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\": \"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"value1\", \"value2\"]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"value\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"value\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   `true`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueTrue,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   `false`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueFalse,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   `null`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueNull,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with decimal\",\n\t\t\targs: args{\n\t\t\t\ts:   `123.456`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e+4`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e-4`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"1.23e-4\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `-123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   `NaN`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseValue() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseValue_JSON(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\": \"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `{\"key\":\"value\"}`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"value1\", \"value2\"]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `[\"value1\",\"value2\"]`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"value\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `\"value\"`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   `true`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `true`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   `false`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `false`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   `null`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `null`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `123`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with decimal\",\n\t\t\targs: args{\n\t\t\t\ts:   `123.456`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `123.456`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e+4`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `1.23e+4`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e-4`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `1.23e-4`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `-123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `-123`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   `NaN`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `NaN`,\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err == nil {\n\t\t\t\tb, err := json.Marshal(got)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"json.Marshal() error = %v\", err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif string(b) != tt.want {\n\t\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", string(b), tt.want)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}",
    "16723f2ffc32b29d413163cff8fbb420": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\"world\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped backslashes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\\world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: ``,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with no quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `hello`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "1776fcb07dc4d492159b07148dfcd15c": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueGet(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttype want struct {\n\t\twant *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant want\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.Get(tt.args.keys...); !reflect.DeepEqual(got, tt.want.want) {\n\t\t\t\tt.Errorf(\"Value.Get() = %v, want %v\", got, tt.want.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "17b32a79b708d7306585f51b4a70cf38": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quotes and other characters\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"\\\\\\\\\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\\\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped closing quote and other characters\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"\\\\\\\\\\\\\"`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "19b178d5d315f1ee4a910530c85798c5": "package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u006\"},\n\t\t\twant: \"\\\\u0061\\\\u006\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\\\\\ \\\\/test\\\\/ \\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"\\\"hello\\\" \\\\world\\\\ /test/ \\b\\f\\n\\r\\tabcüòÅ\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "19b3a5701e18b77f98195cf754c31c57": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\"world\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quotes and other characters\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"\\\\\\\\\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\\\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with no quotes\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with leading quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello world\"`,\n\t\t\t},\n\t\t\twant:    \"hello world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with trailing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello world\"`,\n\t\t\t},\n\t\t\twant:    \"hello world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with leading and trailing quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\"`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "19cc1c015d27484dc43e312ff7b721be": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"single element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,3]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[[1,2],[3,4]]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"4\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with whitespace\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[ 1 , 2 , 3 ]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,3\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1,2,3\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1 2,3]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1 2,3]\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected end of array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1,2,\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseArray() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "1aa906ed44c98caf0327578912d5774d": "package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u006\"},\n\t\t\twant: \"\\\\u0061\\\\u006\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\\\\\ \\\\/\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\x\\\\u006\"},\n\t\t\twant: \"\\\"hello\\\" \\\\world\\\\ /\\\\b\\\\f\\\\n\\\\r\\\\tabcüòÅ\\\\x\\\\u006\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "1b0cb5367fdb39bc465b2887e82894b3": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestType_String(t *testing.T) {\n\ttype args struct {\n\t\tt Type\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"TypeObject\",\n\t\t\targs: args{t: TypeObject},\n\t\t\twant: \"object\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeArray\",\n\t\t\targs: args{t: TypeArray},\n\t\t\twant: \"array\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeString\",\n\t\t\targs: args{t: TypeString},\n\t\t\twant: \"string\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeNumber\",\n\t\t\targs: args{t: TypeNumber},\n\t\t\twant: \"number\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeTrue\",\n\t\t\targs: args{t: TypeTrue},\n\t\t\twant: \"true\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeFalse\",\n\t\t\targs: args{t: TypeFalse},\n\t\t\twant: \"false\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeNull\",\n\t\t\targs: args{t: TypeNull},\n\t\t\twant: \"null\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.t.String(); got != tt.want {\n\t\t\t\tt.Errorf(\"Type.String() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "1bca194f17562f1a6b2bfbc4f35dc226": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCacheGetValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\t// Test initial state\n\tv := c.getValue()\n\tif len(c.vs) != 1 {\n\t\tt.Errorf(\"Expected length of vs to be 1, got %d\", len(c.vs))\n\t}\n\tif v == nil {\n\t\tt.Error(\"Expected v to not be nil\")\n\t}\n\n\t// Test appending a new value\n\tc.getValue()\n\tif len(c.vs) != 2 {\n\t\tt.Errorf(\"Expected length of vs to be 2, got %d\", len(c.vs))\n\t}\n\n\t// Test resizing the slice\n\tc.vs = c.vs[:1]\n\tc.getValue()\n\tif len(c.vs) != 3 {\n\t\tt.Errorf(\"Expected length of vs to be 3, got %d\", len(c.vs))\n\t}\n}",
    "1c00ead46802235ac5eed2c1d0ca0b65": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetStringBytes(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttype want struct {\n\t\twant []byte\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant want\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.GetStringBytes(tt.args.keys...); !bytesEqual(got, tt.want.want) {\n\t\t\t\tt.Errorf(\"Value.GetStringBytes() = %v, want %v\", got, tt.want.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc bytesEqual(a, b []byte) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "1c610a9276eeb78e756f2c509ddd525f": "```go\npackage fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u world\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00zz\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00zz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with incomplete hex\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00z\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00z\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with incomplete hex\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\u\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\u\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\x\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\x\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 2\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\z\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\z\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 3\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 4\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 5\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 6\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 7\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 8\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 9\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 10\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 11\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 12\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 13\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 14\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 15\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 16\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 17\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 18\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 19\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 20\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 21\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 22\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 23\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 24\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 25\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 26\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 27\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 28\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 29\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 30\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 31\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 32\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 33\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 34\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 35\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 36\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 37\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 38\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 39\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 40\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 41\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 42\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 43\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 44\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 45\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 46\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 47\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 48\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 49\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 50\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 51\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 52\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 53\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 54\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 55\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 56\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 57\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 58\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 59\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 60\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 61\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 62\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 63\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 64\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 65\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 66\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 67\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 68\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 69\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 70\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 71\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 72\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 73\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 74\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 75\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 76\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz",
    "1ce43c5fa81158f58acaadeba7b8f216": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestType_String(t *testing.T) {\n\ttype args struct {\n\t\tt Type\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"TestType_String_Object\",\n\t\t\targs: args{t: TypeObject},\n\t\t\twant: \"object\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_Array\",\n\t\t\targs: args{t: TypeArray},\n\t\t\twant: \"array\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_String\",\n\t\t\targs: args{t: TypeString},\n\t\t\twant: \"string\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_Number\",\n\t\t\targs: args{t: TypeNumber},\n\t\t\twant: \"number\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_True\",\n\t\t\targs: args{t: TypeTrue},\n\t\t\twant: \"true\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_False\",\n\t\t\targs: args{t: TypeFalse},\n\t\t\twant: \"false\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_Null\",\n\t\t\targs: args{t: TypeNull},\n\t\t\twant: \"null\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.t.String(); got != tt.want {\n\t\t\t\tt.Errorf(\"Type.String() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "1d6102038107577e8f368fb5065b7559": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"simple integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"float\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential notation\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential notation with lowercase e\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e-4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"leading plus sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"leading plus sign with float\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123.456\",\n\t\t\t},\n\t\t\twantNs:  \"+123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"leading plus sign with exponential notation\",\n\t\t\targs: args{\n\t\t\t\ts: \"+1.23e+4\",\n\t\t\t},\n\t\t\twantNs:  \"+1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"leading plus sign with exponential notation and lowercase e\",\n\t\t\targs: args{\n\t\t\t\ts: \"+1.23e-4\",\n\t\t\t},\n\t\t\twantNs:  \"+1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"inf\",\n\t\t\t},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"INF\",\n\t\t\targs: args{\n\t\t\t\ts: \"INF\",\n\t\t\t},\n\t\t\twantNs:  \"INF\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inF\",\n\t\t\targs: args{\n\t\t\t\ts: \"inF\",\n\t\t\t},\n\t\t\twantNs:  \"inF\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123a\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and float\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123.456a\",\n\t\t\t},\n\t\t\twantNs:  \"+123.456\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and float\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123.456a\",\n\t\t\t},\n\t\t\twantNs:  \"-123.456\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and exponential notation\",\n\t\t\targs: args{\n\t\t\t\ts: \"+1.23e+4a\",\n\t\t\t},\n\t\t\twantNs:  \"+1.23e+4\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and exponential notation\",\n\t\t\targs: args{\n\t\t\t\ts: \"-1.23e+4a\",\n\t\t\t},\n\t\t\twantNs:  \"-1.23e+4\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and exponential notation with lowercase e\",\n\t\t\targs: args{\n\t\t\t\ts: \"+1.23e-4a\",\n\t\t\t},\n\t\t\twantNs:  \"+1.23e-4\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and exponential notation with lowercase e\",\n\t\t\targs: args{\n\t\t\t\ts: \"-1.23e-4a\",\n\t\t\t},\n\t\t\twantNs:  \"-1.23e-4\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"-inf\",\n\t\t\t},\n\t\t\twantNs:  \"-inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and INF\",\n\t\t\targs: args{\n\t\t\t\ts: \"+INF\",\n\t\t\t},\n\t\t\twantNs:  \"+INF\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and INF\",\n\t\t\targs: args{\n\t\t\t\ts: \"-INF\",\n\t\t\t},\n\t\t\twantNs:  \"-INF\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inF\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inF\",\n\t\t\t},\n\t\t\twantNs:  \"+inF\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and inF\",\n\t\t\targs: args{\n\t\t\t\ts: \"-inF\",\n\t\t\t},\n\t\t\twantNs:  \"-inF\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf followed by a character\",\n\t\t\targs: args{\n\t\t\t\ts: \"+infx\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"x\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and inf followed by a character\",\n\t\t\targs: args{\n\t\t\t\ts: \"-infx\",\n\t\t\t},\n\t\t\twantNs:  \"-inf\",\n\t\t\twantS:   \"x\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and INF followed by a character\",\n\t\t\targs: args{\n\t\t\t\ts: \"+INFx\",\n\t\t\t},\n\t\t\twantNs:  \"+INF\",\n\t\t\twantS:   \"x\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and INF followed by a character\",\n\t\t\targs: args{\n\t\t\t\ts: \"-INFx\",\n\t\t\t},\n\t\t\twantNs:  \"-INF\",\n\t\t\twantS:   \"x\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inF followed by a character\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inFx\",\n\t\t\t},\n\t\t\twantNs:  \"+inF\",\n\t\t\twantS:   \"x\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and inF followed by a character\",\n\t\t\targs: args{\n\t\t\t\ts: \"-inFx\",\n\t\t\t},\n\t\t\twantNs:  \"-inF\",\n\t\t\twantS:   \"x\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf followed by a character\",\n\t\t\targs: args{\n\t\t\t\ts: \"+infx\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"x\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and inf followed by a character\",\n\t\t\targs: args{\n\t\t\t\ts: \"-infx\",\n\t\t\t},\n\t\t\twantNs:  \"-inf\",\n\t\t\twantS:   \"x\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and INF followed by a character\",\n\t\t\targs: args{\n\t\t\t\ts: \"+INFx\",\n\t\t\t},\n\t\t\twantNs:  \"+INF\",\n\t\t\twantS:   \"x\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and INF followed by a character\",\n\t\t\targs: args{\n\t\t\t\ts: \"-INFx\",\n\t\t\t},\n\t\t\twantNs:  \"-INF\",\n\t\t\twantS:   \"x\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inF followed by a character\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inFx\",\n\t\t\t},\n\t\t\twantNs:  \"+inF\",\n\t\t\twantS:   \"x\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and inF followed by a character\",\n\t\t\targs: args{\n\t\t\t\ts: \"-inFx\",\n\t\t\t},\n\t\t\twantNs:  \"-inF\",\n\t\t\twantS:   \"x\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}",
    "1dca8b16fd1f12843f54c38e028842d2": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetUint(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant uint\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.GetUint(tt.args.keys...); got != tt.want {\n\t\t\t\tt.Errorf(\"Value.GetUint() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "1ea4de15947de5848d3c8cf899c4801a": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestType_String(t *testing.T) {\n\ttype args struct {\n\t\tt Type\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"TestType_String_Object\",\n\t\t\targs: args{t: TypeObject},\n\t\t\twant: \"object\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_Array\",\n\t\t\targs: args{t: TypeArray},\n\t\t\twant: \"array\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_String\",\n\t\t\targs: args{t: TypeString},\n\t\t\twant: \"string\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_Number\",\n\t\t\targs: args{t: TypeNumber},\n\t\t\twant: \"number\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_True\",\n\t\t\targs: args{t: TypeTrue},\n\t\t\twant: \"true\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_False\",\n\t\t\targs: args{t: TypeFalse},\n\t\t\twant: \"false\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_Null\",\n\t\t\targs: args{t: TypeNull},\n\t\t\twant: \"null\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.t.String(); got != tt.want {\n\t\t\t\tt.Errorf(\"Type.String() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "1ef5dafc5651aab64d7c67dcd23d202e": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueGet(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant *Value\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.Get(tt.args.keys...); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.Get() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2013af45e79fe47fbf01b0eaa4ee45fa": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"single element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,3]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[[1,2],[3,4]]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"4\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with string elements\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[\\\"hello\\\",\\\"world\\\"]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"hello\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"world\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1,2\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"array with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1 2]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1 2]\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseArray() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "20b5c1c1a4dfaafd124f9ff342248bef": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"empty string\",\n\t\t\targs:    args{s: \"\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"single digit\",\n\t\t\targs:    args{s: \"1\"},\n\t\t\twantNs:  \"1\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"multiple digits\",\n\t\t\targs:    args{s: \"123\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"negative number\",\n\t\t\targs:    args{s: \"-123\"},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"decimal number\",\n\t\t\targs:    args{s: \"123.456\"},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"exponent number\",\n\t\t\targs:    args{s: \"123e456\"},\n\t\t\twantNs:  \"123e456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"exponent number with sign\",\n\t\t\targs:    args{s: \"123e+456\"},\n\t\t\twantNs:  \"123e+456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"exponent number with negative sign\",\n\t\t\targs:    args{s: \"123e-456\"},\n\t\t\twantNs:  \"123e-456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"inf\",\n\t\t\targs:    args{s: \"inf\"},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"INF\",\n\t\t\targs:    args{s: \"INF\"},\n\t\t\twantNs:  \"INF\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"nan\",\n\t\t\targs:    args{s: \"nan\"},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"NAN\",\n\t\t\targs:    args{s: \"NAN\"},\n\t\t\twantNs:  \"NAN\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"unexpected char\",\n\t\t\targs:    args{s: \"123a\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"123a\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"unexpected char at start\",\n\t\t\targs:    args{s: \"a123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"a123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"unexpected char at start 2\",\n\t\t\targs:    args{s: \"+123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"unexpected char at start 3\",\n\t\t\targs:    args{s: \"-123a\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"-123a\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}",
    "20bdc202f514624e2445ff26eb23a8bf": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_unescapeKeys(t *testing.T) {\n\ttype args struct {\n\t\to *Object\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant *Object\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\ttt.args.o.unescapeKeys()\n\t\t\tif got := tt.args.o; !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Object.unescapeKeys() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "20c0b47d55f6f1274b8c35f08b22d4a0": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\"world\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\\\\\\\"\",\n\t\t\twant1:   \"!\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\"`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with no quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `hello`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "20c410e6014f42776532d2abe3f935ad": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\"`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with no quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `hello`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote at the beginning\",\n\t\t\targs: args{\n\t\t\t\ts: `\\\\\"hello\"`,\n\t\t\t},\n\t\t\twant:    `\\\"hello`,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote at the end\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "20f4fca86896e8b2a8b5f24aff6e129d": "```go\npackage fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\x\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\x\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\ux\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\ux\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 2\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0x\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0x\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 3\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 4\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 5\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 6\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 7\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 8\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 9\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 10\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 11\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 12\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 13\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 14\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 15\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 16\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 17\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 18\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 19\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 20\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 21\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 22\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 23\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 24\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 25\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 26\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 27\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 28\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 29\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 30\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 31\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 32\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 33\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 34\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 35\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789012\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789012\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 36\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890123\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890123\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 37\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901234\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901234\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 38\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789012345\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789012345\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 39\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890123456\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890123456\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 40\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901234567\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901234567\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 41\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789012345678\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789012345678\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 42\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890123456789\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890123456789\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 43\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901234567890\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901234567890\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 44\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789012345678901\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789012345678901\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 45\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890123456789012\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890123456789012\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 46\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901234567890123\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901234567890123\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 47\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789012345678901234\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789012345678901234\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 48\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890123456789012345\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890123456789012345\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 49\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901234567890123456\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901234567890123456\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 50\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789012345678901234567\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789012345678901234567\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 51\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890123456789012345678\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890123456789012345678\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 52\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901234567890123456789\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901234567890123456789\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 53\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789012345678901234567890\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789012345678901234567890\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 54\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890123456789012345678901\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890123456789012345678901\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 55\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901234567890123456789012\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901234567890123456789012\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 56\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789012345678901234567890123\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789012345678901234567890123\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 57\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890123456789012345678901234\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890123456789012345678901234\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 58\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901234567890123456789012345\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901234567890123456789012345\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 59\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789012345678901234567890123456\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901",
    "2100dd028b870c5605e39b71dc4b7a32": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"{}\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\": \"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"value1\", \"value2\"]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"value\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"value\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   `true`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueTrue,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   `false`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueFalse,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   `null`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueNull,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   `NaN`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid value\",\n\t\t\targs: args{\n\t\t\t\ts:   `invalid`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `invalid`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseValue() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseValue_MarshalJSON(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    string\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"object\",\n\t\t\ts:    `{\"key\": \"value\"}`,\n\t\t\twant: `{\"key\":\"value\"}`,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\ts:    `[\"value1\", \"value2\"]`,\n\t\t\twant: `[\"value1\",\"value2\"]`,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\ts:    `\"value\"`,\n\t\t\twant: `\"value\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\ts:    `true`,\n\t\t\twant: `true`,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\ts:    `false`,\n\t\t\twant: `false`,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\ts:    `null`,\n\t\t\twant: `null`,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\ts:    `123`,\n\t\t\twant: `123`,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\ts:    `NaN`,\n\t\t\twant: `\"NaN\"`,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tv, _, err := parseValue(tt.s, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"parseValue() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgot, err := json.Marshal(v)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"json.Marshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif string(got) != tt.want {\n\t\t\t\tt.Errorf(\"json.Marshal() got = %v, want %v\", string(got), tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "21563450aa831ddb46cebdbf589fe705": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestType_String(t *testing.T) {\n\ttype args struct {\n\t\tt Type\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"TestType_String_Object\",\n\t\t\targs: args{t: TypeObject},\n\t\t\twant: \"object\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_Array\",\n\t\t\targs: args{t: TypeArray},\n\t\t\twant: \"array\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_String\",\n\t\t\targs: args{t: TypeString},\n\t\t\twant: \"string\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_Number\",\n\t\t\targs: args{t: TypeNumber},\n\t\t\twant: \"number\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_True\",\n\t\t\targs: args{t: TypeTrue},\n\t\t\twant: \"true\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_False\",\n\t\t\targs: args{t: TypeFalse},\n\t\t\twant: \"false\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_Null\",\n\t\t\targs: args{t: TypeNull},\n\t\t\twant: \"null\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.t.String(); got != tt.want {\n\t\t\t\tt.Errorf(\"Type.String() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "219d017f87ef89c0155d62b9adcf69a1": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "21c8b9ab6e61b74c9c277e147ee024f4": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\"`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\" \"value1\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_JSON(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_JSON_Compare(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tvar want map[string]interface{}\n\t\t\tif err := json.Unmarshal([]byte(tt.args.s), \u0026want); err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got.o.kvs, want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got.o.kvs, want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "21fe26a1eb0ca3f4d414e14beec4b95b": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\tv   *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"marshal string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeString, s: \"hello\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal number\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t},\n\t\t\twant: []byte(\"123\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal true\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeTrue},\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal false\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeFalse},\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal null\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNull},\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal object\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":\"value1\",\"key2\":123}`),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal array\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{t: TypeString, s: \"value1\"},\n\t\t\t\t\t\t{t: TypeNumber, s: \"123\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`[\"value1\",123]`),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.v.MarshalTo(tt.args.dst); !bytesEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", string(got), string(tt.want))\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc bytesEqual(a, b []byte) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "240bda3681d592206cdcef8ff7978b96": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"key2\": \"value2\"}, \"key3\": \"value3\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\" \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_JSONUnmarshal(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"key2\": \"value2\"}, \"key3\": \"value3\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\" \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_JSONUnmarshal_Compare(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"key2\": \"value2\"}, \"key3\": \"value3\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\" \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t\tvar want interface{}\n\t\t\tif err := json.Unmarshal([]byte(tt.args.s), \u0026want); err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(want, got.o) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got.o, want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2442be74b57fe2079b5eff0a2bc0c33a": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{\\\"a\\\": 1}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"{\\\"a\\\": 1}\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{\\\"a\\\": 1}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"a\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[1, 2, 3]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\\\"hello\\\"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   \"true\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueTrue,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   \"false\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueFalse,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   \"null\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueNull,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   \"123\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   \"NaN\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseValue() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseValue_JSON(t *testing.T) {\n\ttype testCase struct {\n\t\tinput  string\n\t\texpect string\n\t}\n\ttestCases := []testCase{\n\t\t{\n\t\t\tinput:  `{\"a\": 1}`,\n\t\t\texpect: `{\"a\":1}`,\n\t\t},\n\t\t{\n\t\t\tinput:  `[1, 2, 3]`,\n\t\t\texpect: `[1,2,3]`,\n\t\t},\n\t\t{\n\t\t\tinput:  `\"hello\"`,\n\t\t\texpect: `\"hello\"`,\n\t\t},\n\t\t{\n\t\t\tinput:  `true`,\n\t\t\texpect: `true`,\n\t\t},\n\t\t{\n\t\t\tinput:  `false`,\n\t\t\texpect: `false`,\n\t\t},\n\t\t{\n\t\t\tinput:  `null`,\n\t\t\texpect: `null`,\n\t\t},\n\t\t{\n\t\t\tinput:  `123`,\n\t\t\texpect: `123`,\n\t\t},\n\t\t{\n\t\t\tinput:  `NaN`,\n\t\t\texpect: `NaN`,\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.input, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tv, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"parseValue() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tb, err := json.Marshal(v)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"json.Marshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif string(b) != tc.expect {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", string(b), tc.expect)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2450389b1bc6ad67b7ef7b1235a62386": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escaped string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"test\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\\\\\\\"test\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: ``,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with no quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `hello`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2476caea5205f813f94d185bcf37165b": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetUint64(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant uint64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.GetUint64(tt.args.keys...); got != tt.want {\n\t\t\t\tt.Errorf(\"Value.GetUint64() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "24aa5034a511785e1541e0d1a6b12b78": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestValueUint(t *testing.T) {\n\ttype args struct {\n\t\tv *Value\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    uint\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"valid uint\",\n\t\t\targs: args{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"12345\",\n\t\t\t\t},\n\t\t\t},\n\t\t\twant:    12345,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid uint\",\n\t\t\targs: args{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"18446744073709551616\", // uint64 max + 1\n\t\t\t\t},\n\t\t\t},\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"not a number\",\n\t\t\targs: args{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeString,\n\t\t\t\t\ts: \"hello\",\n\t\t\t\t},\n\t\t\t},\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := tt.args.v.Uint()\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Value.Uint() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Value.Uint() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "24e116bdb8eb228efbb3cb4d39692562": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttype want struct {\n\t\tv   *Value\n\t\ttail string\n\t\terr  error\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant want\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  fmt.Errorf(\"cannot parse empty string\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"{}\",\n\t\t\t\terr:  fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{ \\\"key\\\": \\\"value\\\" }\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\tt: TypeRawString,\n\t\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[ \\\"value1\\\", \\\"value2\\\" ]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeRawString,\n\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeRawString,\n\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\\\"value\\\"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeRawString,\n\t\t\t\t\ts: \"value\",\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   \"true\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueTrue,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   \"false\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueFalse,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   \"null\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueNull,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   \"123\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"123\",\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   \"NaN\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"NaN\",\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected value\",\n\t\t\targs: args{\n\t\t\t\ts:   \"t\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"t\",\n\t\t\t\terr:  fmt.Errorf(\"unexpected value found: %q\", \"t\"),\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotV, gotTail, gotErr := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (gotErr == nil) != (tt.want.err == nil) {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", gotErr, tt.want.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotErr != nil \u0026\u0026 tt.want.err != nil {\n\t\t\t\tif gotErr.Error() != tt.want.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", gotErr, tt.want.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(gotV, tt.want.v) {\n\t\t\t\tt.Errorf(\"parseValue() gotV = %v, want %v\", gotV, tt.want.v)\n\t\t\t}\n\t\t\tif gotTail != tt.want.tail {\n\t\t\t\tt.Errorf(\"parseValue() gotTail = %v, want %v\", gotTail, tt.want.tail)\n\t\t\t}\n\t\t})\n\t}\n}",
    "24f6ab7fa227301c86006c63fd2bf228": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueGet(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttype want struct {\n\t\twant *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant want\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.Get(tt.args.keys...); !reflect.DeepEqual(got, tt.want.want) {\n\t\t\t\tt.Errorf(\"Value.Get() = %v, want %v\", got, tt.want.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2571a7638b76ad2d74e4411f384573ac": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts: \"null\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts: \"true\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts: \"false\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello\\\"\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts: \"[1,2,3]\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts: `{\"key1\": \"value1\", \"key2\": 2}`,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested object\",\n\t\t\targs: args{\n\t\t\t\ts: `{\"key1\": {\"key2\": \"value2\"}}`,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts: `{\"key1\": [1, 2, 3]}`,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tp := \u0026Parser{}\n\t\t\tgot, err := p.Parse(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Parse() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr \u0026\u0026 !compareValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"Parse() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeNull:\n\t\treturn true\n\tcase TypeTrue:\n\t\treturn true\n\tcase TypeFalse:\n\t\treturn true\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !compareValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !compareValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc TestParse_InvalidJSON(t *testing.T) {\n\ttests := []string{\n\t\t\"{\",\n\t\t\"}\",\n\t\t\"[\",\n\t\t\"]\",\n\t\t\"1,\",\n\t\t\"1 2\",\n\t\t`\"hello`,\n\t\t`hello\"`,\n\t\t`{\"key1\": \"value1\", \"key2\": 2`,\n\t\t`{\"key1\": \"value1\", \"key2\": 2}`,\n\t}\n\tfor _, s := range tests {\n\t\tt.Run(s, func(t *testing.T) {\n\t\t\tp := \u0026Parser{}\n\t\t\t_, err := p.Parse(s)\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"Parse(%q) should have returned an error\", s)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParse_CompareWithStdlib(t *testing.T) {\n\ttests := []string{\n\t\t`null`,\n\t\t`true`,\n\t\t`false`,\n\t\t`123`,\n\t\t`\"hello\"`,\n\t\t`[1,2,3]`,\n\t\t`{\"key1\": \"value1\", \"key2\": 2}`,\n\t\t`{\"key1\": {\"key2\": \"value2\"}}`,\n\t\t`{\"key1\": [1, 2, 3]}`,\n\t}\n\tfor _, s := range tests {\n\t\tt.Run(s, func(t *testing.T) {\n\t\t\tp := \u0026Parser{}\n\t\t\tv1, err := p.Parse(s)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Parse(%q) error: %v\", s, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tvar v2 interface{}\n\t\t\tif err := json.Unmarshal([]byte(s), \u0026v2); err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal(%q) error: %v\", s, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !compareValuesWithStdlib(v1, v2) {\n\t\t\t\tt.Errorf(\"Parse(%q) result doesn't match json.Unmarshal(%q)\", s, s)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValuesWithStdlib(v1 *Value, v2 interface{}) bool {\n\tswitch v2 := v2.(type) {\n\tcase nil:\n\t\treturn v1.t == TypeNull\n\tcase bool:\n\t\treturn (v1.t == TypeTrue \u0026\u0026 v2) || (v1.t == TypeFalse \u0026\u0026 !v2)\n\tcase float64:\n\t\treturn v1.t == TypeNumber \u0026\u0026 v1.s == fmt.Sprintf(\"%f\", v2)\n\tcase string:\n\t\treturn v1.t == TypeString \u0026\u0026 v1.s == v2\n\tcase []interface{}:\n\t\tif v1.t != TypeArray || len(v1.a) != len(v2) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !compareValuesWithStdlib(v1.a[i], v2[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase map[string]interface{}:\n\t\tif v1.t != TypeObject || len(v1.o.kvs) != len(v2) {\n\t\t\treturn false\n\t\t}\n\t\tfor k, v := range v2 {\n\t\t\tif !compareValuesWithStdlib(v1.o.Get(k), v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}",
    "2598149e38f0e0fe920438f700e84475": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_JSONUnmarshal(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_JSONUnmarshal_Compare(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\n\t\t\tvar wantJSON map[string]interface{}\n\t\t\tif err := json.Unmarshal([]byte(tt.args.s), \u0026wantJSON); err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tvar gotJSON map[string]interface{}\n\t\t\tif err := json.Unmarshal([]byte(got.String()), \u0026gotJSON); err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !reflect.DeepEqual(gotJSON, wantJSON) {\n\t\t\t\tt.Errorf(\"parseObject() gotJSON = %v, wantJSON %v\", gotJSON, wantJSON)\n\t\t\t}\n\t\t})\n\t}\n}",
    "25f24fcc36cc60aec68c7ede89d509c3": "```go\npackage fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"empty string\",\n\t\t\targs:    args{s: \"\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"single digit\",\n\t\t\targs:    args{s: \"1\"},\n\t\t\twantNs:  \"1\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"multiple digits\",\n\t\t\targs:    args{s: \"123\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"negative number\",\n\t\t\targs:    args{s: \"-123\"},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"decimal number\",\n\t\t\targs:    args{s: \"123.456\"},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"exponential number\",\n\t\t\targs:    args{s: \"1.23e+4\"},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"exponential number with negative exponent\",\n\t\t\targs:    args{s: \"1.23e-4\"},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading zeros\",\n\t\t\targs:    args{s: \"00123\"},\n\t\t\twantNs:  \"00123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with trailing zeros\",\n\t\t\targs:    args{s: \"12300\"},\n\t\t\twantNs:  \"12300\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign\",\n\t\t\targs:    args{s: \"+123\"},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+12300\"},\n\t\t\twantNs:  \"+12300\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and decimal\",\n\t\t\targs:    args{s: \"+123.456\"},\n\t\t\twantNs:  \"+123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and exponent\",\n\t\t\targs:    args{s: \"+1.23e+4\"},\n\t\t\twantNs:  \"+1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and negative exponent\",\n\t\t\targs:    args{s: \"+1.23e-4\"},\n\t\t\twantNs:  \"+1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading minus sign and trailing zeros\",\n\t\t\targs:    args{s: \"-12300\"},\n\t\t\twantNs:  \"-12300\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading minus sign and decimal\",\n\t\t\targs:    args{s: \"-123.456\"},\n\t\t\twantNs:  \"-123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading minus sign and exponent\",\n\t\t\targs:    args{s: \"-1.23e+4\"},\n\t\t\twantNs:  \"-1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading minus sign and negative exponent\",\n\t\t\targs:    args{s: \"-1.23e-4\"},\n\t\t\twantNs:  \"-1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading zeros and decimal\",\n\t\t\targs:    args{s: \"00123.456\"},\n\t\t\twantNs:  \"00123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading zeros and exponent\",\n\t\t\targs:    args{s: \"001.23e+4\"},\n\t\t\twantNs:  \"001.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading zeros and negative exponent\",\n\t\t\targs:    args{s: \"001.23e-4\"},\n\t\t\twantNs:  \"001.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with trailing zeros and decimal\",\n\t\t\targs:    args{s: \"12300.456\"},\n\t\t\twantNs:  \"12300.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with trailing zeros and exponent\",\n\t\t\targs:    args{s: \"12300e+4\"},\n\t\t\twantNs:  \"12300e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with trailing zeros and negative exponent\",\n\t\t\targs:    args{s: \"12300e-4\"},\n\t\t\twantNs:  \"12300e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading and trailing zeros\",\n\t\t\targs:    args{s: \"0012300\"},\n\t\t\twantNs:  \"0012300\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading and trailing zeros and decimal\",\n\t\t\targs:    args{s: \"0012300.456\"},\n\t\t\twantNs:  \"0012300.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading and trailing zeros and exponent\",\n\t\t\targs:    args{s: \"0012300e+4\"},\n\t\t\twantNs:  \"0012300e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading and trailing zeros and negative exponent\",\n\t\t\targs:    args{s: \"0012300e-4\"},\n\t\t\twantNs:  \"0012300e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading and trailing zeros and decimal and exponent\",\n\t\t\targs:    args{s: \"0012300.456e+4\"},\n\t\t\twantNs:  \"0012300.456e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading and trailing zeros and decimal and negative exponent\",\n\t\t\targs:    args{s: \"0012300.456e-4\"},\n\t\t\twantNs:  \"0012300.456e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading and trailing zeros and exponent and decimal\",\n\t\t\targs:    args{s: \"0012300e+4.456\"},\n\t\t\twantNs:  \"0012300e+4\",\n\t\t\twantS:   \".456\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading and trailing zeros and negative exponent and decimal\",\n\t\t\targs:    args{s: \"0012300e-4.456\"},\n\t\t\twantNs:  \"0012300e-4\",\n\t\t\twantS:   \".456\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading and trailing zeros and exponent and decimal and leading plus sign\",\n\t\t\targs:    args{s: \"+0012300e+4.456\"},\n\t\t\twantNs:  \"+0012300e+4\",\n\t\t\twantS:   \".456\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading and trailing zeros and negative exponent and decimal and leading plus sign\",\n\t\t\targs:    args{s: \"+0012300e-4.456\"},\n\t\t\twantNs:  \"+0012300e-4\",\n\t\t\twantS:   \".456\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading and trailing zeros and exponent and decimal and leading minus sign\",\n\t\t\targs:    args{s: \"-0012300e+4.456\"},\n\t\t\twantNs:  \"-0012300e+4\",\n\t\t\twantS:   \".456\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading and trailing zeros and negative exponent and decimal and leading minus sign\",\n\t\t\targs:    args{s: \"-0012300e-4.456\"},\n\t\t\twantNs:  \"-0012300e-4\",\n\t\t\twantS:   \".456\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading and trailing zeros and exponent and decimal and leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+0012300e+4.45600\"},\n\t\t\twantNs:  \"+0012300e+4\",\n\t\t\twantS:   \".45600\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading and trailing zeros and negative exponent and decimal and leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+0012300e-4.45600\"},\n\t\t\twantNs:  \"+0012300e-4\",\n\t\t\twantS:   \".45600\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading and trailing zeros and exponent and decimal and leading minus sign and trailing zeros\",\n\t\t\targs:    args{s: \"-0012300e+4.45600\"},\n\t\t\twantNs:  \"-0012300e+4\",\n\t\t\twantS:   \".45600\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading and trailing zeros and negative exponent and decimal and leading minus sign and trailing zeros\",\n\t\t\targs:    args{s: \"-0012300e-4.45600\"},\n\t\t\twantNs:  \"-0012300e-4\",\n\t\t\twantS:   \".45600\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading and trailing zeros and exponent and decimal and leading plus sign and trailing zeros and leading plus sign\",\n\t\t\targs:    args{s: \"+0012300e+4.45600+\"},\n\t\t\twantNs:  \"+0012300e+4\",\n\t\t\twantS:   \".45600+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading and trailing zeros and negative exponent and decimal and leading plus sign and trailing zeros and leading plus sign\",\n\t\t\targs:    args{s: \"+0012300e-4.45600+\"},\n\t\t\twantNs:  \"+0012300e-4\",\n\t\t\twantS:   \".45600+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading and trailing zeros and exponent and decimal and leading minus sign and trailing zeros and leading plus sign\",\n\t\t\targs:    args{s: \"-0012300e+4.45600+\"},\n\t\t\twantNs:  \"-0012300e+4\",\n\t\t\twantS:   \".45600+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading and trailing zeros and negative exponent and decimal and leading minus sign and trailing zeros and leading plus sign\",\n\t\t\targs:    args{s: \"-0012300e-4.45600+\"},\n\t\t\twantNs:  \"-0012300e-4\",\n\t\t\twantS:   \".45600+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading and trailing zeros and exponent and decimal and leading plus sign and trailing zeros and leading minus sign\",\n\t\t\targs:    args{s: \"+0012300e+4.45600-\"},\n\t\t\twantNs:  \"+0012300e+4\",\n\t\t\twantS:   \".45600-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading and trailing zeros and negative exponent and decimal and leading plus sign and trailing zeros and leading minus sign\",\n\t\t\targs:    args{s: \"+0012300e-4.45600-\"},\n\t\t\twantNs:  \"+0012300e-4\",\n\t\t\twantS:   \".45600-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading and trailing zeros and exponent and decimal and leading minus sign and trailing zeros and leading minus sign\",\n\t\t\targs:    args{s: \"-0012300e+4.45600-\"},\n\t\t\twantNs:  \"-0012300e+4\",\n\t\t\twantS:   \".45600-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading and trailing zeros and negative exponent and decimal and leading minus sign and trailing zeros and leading minus sign\",\n\t\t\targs:    args{s: \"-0012300e-4.45600-\"},\n\t\t\twantNs:  \"-0012300e-4\",\n\t\t\twantS:   \".45600-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading and trailing zeros and exponent and decimal and leading plus sign and trailing zeros and leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+0012300e+4.45600+00\"},\n\t\t\twantNs:  \"+0012300e+4\",\n\t\t\twantS:   \".45600+00\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading and trailing zeros and negative exponent and decimal and leading plus sign and trailing zeros and leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+0012300e-4.45600+00\"},\n\t\t\twantNs:  \"+0012300e-4\",\n\t\t\twantS:   \".45600+00\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading and trailing zeros and exponent and decimal and leading minus sign and trailing zeros and leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"-0012300e+4.45600+00\"},\n\t\t\twantNs:  \"-0012300e+4\",\n\t\t\twantS:   \".45600+00\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading and trailing zeros and negative exponent and decimal and leading minus sign and trailing zeros and leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"-0012300e-4.45600+00\"},\n\t\t\twantNs:  \"-0012300e-4\",\n\t\t\twantS:   \".45600+00\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading and trailing zeros and exponent and decimal and leading plus sign and trailing zeros and leading minus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+0012300e+4.45600-00\"},\n\t\t\twantNs:  \"+0012300e+4\",\n\t\t\twantS:   \".45600-00\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading and trailing zeros and negative exponent and decimal and leading plus sign and trailing zeros and leading minus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+0012300e-4.45600-00\"},\n\t\t\twantNs:  \"+0012300e-4\",\n\t\t\twantS:   \".45600-00\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading and trailing zeros and exponent and decimal and leading minus sign and trailing zeros and leading minus sign and trailing zeros\",\n\t\t\targs:    args{s: \"-0012300e+4.45600-00\"},\n\t\t\twantNs:  \"-0012300e+4\",\n\t\t\twantS:   \".45600-00\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading and trailing zeros and negative exponent and decimal and leading minus sign and trailing zeros and leading minus sign and trailing zeros\",\n\t\t\targs:    args{s: \"-0012300e-4.45600-00\"},\n\t\t\twantNs:  \"-0012300e-4\",\n\t\t\twantS:   \".45600-00\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading and trailing zeros and exponent and decimal and leading plus sign and trailing zeros and leading plus sign and trailing zeros and leading plus sign\",\n\t\t\targs:    args{s: \"+0012300e+4.45600+00+\"},\n\t\t\twantNs:  \"+0012300e+4\",\n\t\t\twantS:   \".45600+00+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading and trailing zeros and negative exponent and decimal and leading plus sign and trailing zeros and leading plus sign and trailing zeros and leading plus sign\",\n\t\t\targs:    args{s: \"+0012300e-4.45600+00+\"},\n\t\t\twantNs:  \"+0012300e-4\",\n\t\t\twantS:   \".45600+00+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading and trailing zeros and exponent and decimal and leading minus sign and trailing zeros and leading plus sign and trailing zeros and leading plus sign\",\n\t\t\targs:    args{s: \"-0012300e+4.45600+00+\"},\n\t\t\twantNs:  \"-0012300e+4\",\n\t\t\twantS:   \".45600+00+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading and trailing zeros and negative exponent and decimal and leading minus sign and trailing zeros and leading plus sign and trailing zeros and leading plus sign\",\n\t\t\targs:    args{s: \"-0012300e-4.45600+00+\"},\n\t\t\twantNs:  \"-0012300e-4\",\n\t\t\twantS:   \".45600+00+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading and trailing zeros and exponent and decimal and leading plus sign and trailing zeros and leading minus sign and trailing zeros and leading plus sign\",\n\t\t\targs:    args{s: \"+0012300e+4.45600-00+\"},\n\t\t\twantNs:  \"+0012300e+4\",\n\t\t\twantS:   \".45600-00+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading and trailing zeros and negative exponent and decimal and leading plus sign and trailing zeros and leading minus sign and trailing zeros and leading plus sign\",\n\t\t\targs:    args{s: \"+0012300e-4.45600-00+\"},\n\t\t\twantNs:  \"+0012300e-4\",\n\t\t\twantS:   \".45600-00+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading and trailing zeros and exponent and decimal and leading minus sign and trailing zeros and leading minus sign and trailing zeros and leading plus sign\",\n\t\t\targs:    args{s: \"-0012300e+4.45600-00+\"},\n\t\t\twantNs:  \"-0012300e+4\",\n\t\t\twantS:   \".45600-00+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading and trailing zeros and negative exponent and decimal and leading minus sign and trailing zeros and leading minus sign and trailing zeros and leading plus sign\",\n\t\t\targs:    args{s: \"-0012300e-4.45600-00+\"},\n\t\t\twantNs:  \"-0012300e-4\",\n\t\t\twantS:   \".45600-00+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading and trailing zeros and exponent and decimal and leading plus sign and trailing zeros and leading plus sign and trailing zeros and leading minus sign\",\n\t\t\targs:    args{s: \"+0012300e+4.45600+00-\"},\n\t\t\twantNs:  \"+0012300e+4\",\n\t\t\twantS:   \".45600+00-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading and trailing zeros and negative exponent and decimal and leading plus sign and trailing zeros and leading plus sign and trailing zeros and leading minus sign\",\n\t\t\targs:    args{s: \"+0012300e-4.45600+00-\"},\n\t\t\twantNs:  \"+0012300e-4\",\n\t\t\twantS:   \".45600+00-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading and trailing zeros and exponent and decimal and leading minus sign and trailing zeros and leading plus sign and trailing zeros and leading minus sign\",\n\t\t\targs:    args{s: \"-0012300e+4.45600+00-\"},\n\t\t\twantNs:  \"-0012300e+4\",\n\t\t\twantS:   \".45600+00-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading and trailing zeros and negative exponent and decimal and leading minus sign and trailing zeros and leading plus sign and trailing zeros and leading minus sign\",\n\t\t\targs:    args{s: \"-0012300e-4.45600+00-\"},\n\t\t\twantNs:  \"-0012300e-4\",\n\t\t\twantS:   \".45600+00-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading and trailing zeros and exponent and decimal and leading plus sign and trailing zeros and leading minus sign and trailing zeros and leading minus sign\",\n\t\t\targs:    args{s: \"+0012300e+4.45600-00-\"},\n\t\t\twantNs:  \"+0012300e+4\",\n\t\t\twantS:   \".45600-00-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading and trailing zeros and negative exponent and decimal and leading plus sign and trailing zeros and leading minus sign and trailing zeros and leading minus sign\",\n\t\t\targs:    args{s: \"+0012300e-4.45600-00-\"},\n\t\t\twantNs:  \"+0012300e-4\",\n\t\t\twantS:   \".45600-00-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading and trailing zeros and exponent and decimal and leading minus sign and trailing zeros and leading minus sign and trailing zeros and leading minus sign\",\n\t\t\targs:    args{s: \"-0012300e+4.45600-00-\"},\n\t\t\twantNs:  \"-0012300e+4\",\n\t\t\twantS:   \".45600-00-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading and trailing zeros and negative exponent and decimal and leading minus sign and trailing zeros and leading minus sign and trailing zeros and leading minus sign\",\n\t\t\targs:    args{s: \"-0012300e-4.45600-00-\"},\n\t\t\twantNs:  \"-0012300e-4\",\n\t\t\twantS:   \".45600-00-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading and trailing zeros and exponent and decimal and leading plus sign and trailing zeros and leading plus sign and trailing zeros and leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+0012300e+4.45600+00+00\"},\n\t\t\twantNs:  \"+0012300e+4\",\n\t\t\twantS:   \".45600+00+00\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading and trailing zeros and negative exponent and decimal and leading plus sign and trailing zeros and leading plus sign and trailing zeros and leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+0012300e-4.45600+00+00\"},\n\t\t\twantNs:  \"+0012300e-4\",\n\t\t\twantS:   \".45600+00+00\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading and trailing zeros and exponent and decimal and leading minus sign and trailing zeros and leading plus sign and trailing zeros and leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"-0012300e+4.45600+00+00\"},\n\t\t\twantNs:  \"-0012300e+4\",\n\t\t\twantS:   \".45600+00+00\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading and trailing zeros and negative exponent and decimal and leading minus sign and trailing zeros and leading plus sign and trailing zeros and leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"-0012300e-4.45600+00+00\"},\n\t\t\twantNs:  \"-0012300e-4\",\n\t\t\twantS:   \".45600+00+00\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading and trailing zeros and exponent and decimal and leading plus sign and trailing zeros and leading minus sign and trailing zeros and leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+0012300e+4.45600-00+00\"},\n\t\t\twantNs:  \"+0012300e+4\",\n\t\t\twantS:   \".45600-00+00\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading and trailing zeros and negative exponent and decimal and leading plus sign and trailing zeros and leading minus sign and trailing zeros and leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+0012300e-4.45600-00+00\"},\n\t\t\twantNs:  \"+0012300e-4\",\n\t\t\twantS:   \".45600-00+00\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading and trailing zeros and exponent and decimal and leading minus sign and trailing zeros and leading minus sign and trailing zeros and leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"-0012300e+4.45600-00+00\"},\n\t\t\twantNs:  \"-0012300e+4\",\n\t\t\twantS:   \".45600-00+00\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading and trailing zeros and negative exponent and decimal and leading minus sign and trailing zeros and leading minus sign and trailing zeros and leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"-0012300e-4.45600-00+00\"},\n\t\t\twantNs:  \"-0012300e-4\",\n\t\t\twantS:   \".45600-00+00\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading and trailing zeros and exponent and decimal and leading plus sign and trailing zeros and leading plus sign and trailing zeros and leading minus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+0012300e+4.45600+00-00\"},\n\t\t\twantNs:  \"+0012300e+4\",\n\t\t\twantS:   \".45600+00-00\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading and trailing zeros and negative exponent and decimal and leading plus sign and trailing zeros and leading plus sign and trailing zeros and leading minus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+0012300e-4.45600+00-00\"},\n\t\t\twantNs:  \"+0012300e-4\",\n\t\t\twantS:   \".45600+00-00\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading and trailing zeros and exponent and decimal and leading minus sign and trailing zeros and leading plus sign and trailing zeros and leading minus sign and trailing zeros\",\n\t\t\targs:    args{s: \"-0012300e+4.45600+00-00\"},\n\t\t\twantNs:  \"-0012300e+4\",\n\t\t\twantS:   \".45600+00-00\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading and trailing zeros and negative exponent and decimal and leading minus sign and trailing zeros and leading plus sign and trailing zeros and leading minus sign and trailing zeros\",\n\t\t\targs:    args{s: \"-0012300e-4.45600+00-00\"},\n\t\t\twantNs:  \"-0012300e-4\",\n\t\t\twantS:   \".45600+00-00\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading and trailing zeros and exponent and decimal and leading plus sign and trailing zeros and leading minus sign and trailing zeros and leading minus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+0012300e+4.45600-00-00\"},\n\t\t\twantNs:  \"+0012300e+4\",\n\t\t\twantS:   \".45600-00-00\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading and trailing zeros and negative exponent and decimal and leading plus sign and trailing zeros and leading minus sign and trailing zeros and leading minus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+0012300e-4.45600-00-00\"},\n\t\t\twantNs:  \"+0012300e-4\",\n\t\t\twantS:   \".45600-00-00\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading and trailing zeros and exponent and decimal and leading minus sign and trailing zeros and leading minus sign and trailing zeros and leading minus sign and trailing zeros\",\n\t\t\targs:    args{s: \"-0012300e+4.45600-00-00\"},\n\t\t\twantNs:  \"-0012300e+4\",\n\t\t\twantS:   \".45600-00-00\",\n\t\t\twantErr: false,\n\t\t",
    "2611c8b38fe13525416c8e88ca98ba23": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWS(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no whitespace\",\n\t\t\targs: args{s: \"abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace\",\n\t\t\targs: args{s: \"  abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailing whitespace\",\n\t\t\targs: args{s: \"abc  \"},\n\t\t\twant: \"abc  \",\n\t\t},\n\t\t{\n\t\t\tname: \"whitespace in the middle\",\n\t\t\targs: args{s: \"a bc\"},\n\t\t\twant: \"a bc\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple whitespace\",\n\t\t\targs: args{s: \"  a  b  c  \"},\n\t\t\twant: \"a  b  c  \",\n\t\t},\n\t\t{\n\t\t\tname: \"tab whitespace\",\n\t\t\targs: args{s: \"\\tabc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"newline whitespace\",\n\t\t\targs: args{s: \"\\nabc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"carriage return whitespace\",\n\t\t\targs: args{s: \"\\rabc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWS(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWS() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "26212585ff2cf80f2aa004def4351ae6": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestString(t *testing.T) {\n\ttype args struct {\n\t\tt Type\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"TestString_Object\",\n\t\t\targs: args{t: TypeObject},\n\t\t\twant: \"object\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestString_Array\",\n\t\t\targs: args{t: TypeArray},\n\t\t\twant: \"array\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestString_String\",\n\t\t\targs: args{t: TypeString},\n\t\t\twant: \"string\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestString_Number\",\n\t\t\targs: args{t: TypeNumber},\n\t\t\twant: \"number\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestString_True\",\n\t\t\targs: args{t: TypeTrue},\n\t\t\twant: \"true\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestString_False\",\n\t\t\targs: args{t: TypeFalse},\n\t\t\twant: \"false\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestString_Null\",\n\t\t\targs: args{t: TypeNull},\n\t\t\twant: \"null\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.t.String(); got != tt.want {\n\t\t\t\tt.Errorf(\"String() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "264992c214c752cc47b58bbf20058423": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": {\"nested_key1\": \"nested_value1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nested_key1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nested_value1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "26e7b14d9c8c2b77c7f3fa7a3edd517c": "```go\npackage fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth + 1,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"{}\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\": \"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"value1\", \"value2\"]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"value\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"value\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   `true`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueTrue,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   `false`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueFalse,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   `null`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueNull,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with decimal\",\n\t\t\targs: args{\n\t\t\t\ts:   `123.456`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e+4`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e-4`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"1.23e-4\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `-123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zero\",\n\t\t\targs: args{\n\t\t\t\ts:   `0123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"0123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with trailing zero\",\n\t\t\targs: args{\n\t\t\t\ts:   `123.0`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123.0\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading plus sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `+123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"+123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zero and decimal\",\n\t\t\targs: args{\n\t\t\t\ts:   `0.123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"0.123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zero and exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `0e+10`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"0e+10\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zero and negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `0e-10`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"0e-10\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zero and decimal and exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `0.123e+10`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"0.123e+10\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zero and decimal and negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `0.123e-10`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"0.123e-10\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zero and decimal and negative sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `-0.123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-0.123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zero and decimal and plus sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `+0.123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"+0.123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zero and decimal and plus sign and exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `+0.123e+10`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"+0.123e+10\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zero and decimal and plus sign and negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `+0.123e-10`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"+0.123e-10\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zero and decimal and negative sign and exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `-0.123e+10`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-0.123e+10\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zero and decimal and negative sign and negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `-0.123e-10`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-0.123e-10\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zero and decimal and negative sign and exponent and trailing zero\",\n\t\t\targs: args{\n\t\t\t\ts:   `-0.123e+100`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-0.123e+100\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zero and decimal and negative sign and negative exponent and trailing zero\",\n\t\t\targs: args{\n\t\t\t\ts:   `-0.123e-100`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-0.123e-100\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zero and decimal and negative sign and exponent and trailing zero\",\n\t\t\targs: args{\n\t\t\t\ts:   `-0.123e+1000`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-0.123e+1000\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zero and decimal and negative sign and negative exponent and trailing zero\",\n\t\t\targs: args{\n\t\t\t\ts:   `-0.123e-1000`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-0.123e-1000\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zero and decimal and negative sign and exponent and trailing zero\",\n\t\t\targs: args{\n\t\t\t\ts:   `-0.123e+10000`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-0.123e+10000\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zero and decimal and negative sign and negative exponent and trailing zero\",\n\t\t\targs: args{\n\t\t\t\ts:   `-0.123e-10000`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-0.123e-10000\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zero and decimal and negative sign and exponent and trailing zero\",\n\t\t\targs: args{\n\t\t\t\ts:   `-0.123e+100000`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-0.123e+100000\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zero and decimal and negative sign and negative exponent and trailing zero\",\n\t\t\targs: args{\n\t\t\t\ts:   `-0.123e-100000`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-0.123e-100000\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zero and decimal and negative sign and exponent and trailing zero\",\n\t\t\targs: args{\n\t\t\t\ts:   `-0.123e+1000000`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-0.123e+1000000\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zero and decimal and negative sign and negative exponent and trailing zero\",\n\t\t\targs: args{\n\t\t\t\ts:   `-0.123e-1000000`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-0.123e-1000000\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zero and decimal and negative sign and exponent and trailing zero\",\n\t\t\targs: args{\n\t\t\t\ts:   `-0.123e+10000000`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-0.123e+10000000\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zero and decimal and negative sign and negative exponent and trailing zero\",\n\t\t\targs: args{\n\t\t\t\ts:   `-0.123e-10000000`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-0.123e-10000000\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zero and decimal and negative sign and exponent and trailing zero\",\n\t\t\targs: args{\n\t\t\t\ts:   `-0.123e+100000000`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-0.123e+100000000\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zero and decimal and negative sign and negative exponent and trailing zero\",\n\t\t\targs: args{\n\t\t\t\ts:   `-0.123e-100000000`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-0.123e-100000000\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zero and decimal and negative sign and exponent and trailing zero\",\n\t\t\targs: args{\n\t\t\t\ts:   `-0.123e+1000000000`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-0.123e+1000000000\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zero and decimal and negative sign and negative exponent and trailing zero\",\n\t\t\targs: args{\n\t\t\t\ts:   `-0.123e-1000000000`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-0.123e-1000000000\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zero and decimal and negative sign and exponent and trailing zero\",\n\t\t\targs: args{\n\t\t\t\ts:   `-0.123e+10000000000`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-0.123e+10000000000\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zero and decimal and negative sign and negative exponent and trailing zero\",\n\t\t\targs: args{\n\t\t\t\ts:   `-0.123e-10000000000`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-0.123e-10000000000\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zero and decimal and negative sign and exponent and trailing zero\",\n\t\t\targs: args{\n\t\t\t\ts:   `-0.123e+100000000000`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-0.123e+100000000000\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zero and decimal and negative sign and negative exponent and trailing zero\",\n\t\t\targs: args{\n\t\t\t\ts:   `-0.123e-100000000000`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-0.123e-100000000000\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zero and decimal and negative sign and exponent and trailing zero\",\n\t\t\targs: args{\n\t\t\t\ts:   `-0.123e+1000000000000`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-0.123e+1000000000000\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zero and decimal and negative sign and negative exponent and trailing zero\",\n\t\t\targs: args{\n\t\t\t\ts:   `-0.123e-1000000000000`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-0.123e-1000000000000\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zero and decimal and negative sign and exponent and trailing zero\",\n\t\t\targs: args{\n\t\t\t\ts:   `-0.123e+10000000000000`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-0.123e+10000000000000\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zero and decimal and negative sign and negative exponent and trailing zero\",\n\t\t\targs: args{\n\t\t\t\ts:   `-0.123e-10000000000000`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-0.123e-10000000000000\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zero and decimal and negative sign and exponent and trailing zero\",\n\t\t\targs: args{\n\t\t\t\ts:   `-0.123e+100000000000000`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-0.123e+100000000000000\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zero and decimal and negative sign and negative exponent and trailing zero\",\n\t\t\targs: args{\n\t\t\t\ts:   `-0.123e-100000000000000`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-0.123e-100000000000000\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zero and decimal and negative sign and exponent and trailing zero\",\n\t\t\targs: args{\n\t\t\t\ts:   `-0.123e+1000000000000000`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-0.123e+1000000000000000\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zero and decimal and negative sign and negative exponent and trailing zero\",\n\t\t\targs: args{\n\t\t\t\ts:   `-0.123e-1000000000000000`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-0.123e-1000000000000000\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zero and decimal and negative sign and exponent and trailing zero\",\n\t\t\targs: args{\n\t\t\t\ts:   `-0.123e+10000000000000000`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-0.123e+10000000000000000\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zero and decimal and negative sign and negative exponent and trailing zero\",\n\t\t\targs: args{\n\t\t\t\ts:   `-0.123e-10000000000000000`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-0.123e-10000000000000000\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zero and decimal and negative sign and exponent and trailing zero\",\n\t\t\targs: args{\n\t\t\t\ts:   `-0.123e+100000000000000000`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-0.123e+100000000000000000\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zero and decimal and negative sign and negative exponent and trailing zero\",\n\t\t\targs: args{\n\t\t\t\ts:   `-0.123e-100000000000000000`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-0.123e-100000000000000000\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zero and decimal and negative sign and exponent and trailing zero\",\n\t\t\targs: args{\n\t\t\t\ts:   `-0.123e+1000000000000000000`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-0.123e+1000000000000000000\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zero and decimal and negative sign and negative exponent and trailing zero\",\n\t\t\targs: args{\n\t\t\t\ts:   `-0.123e-1000000000000000000`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-0.123e-1000000000000000000\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zero and decimal and negative sign and exponent and trailing zero\",\n\t\t\targs: args{\n\t\t\t\ts:   `-0.123e+10000000000000000000`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-0.123e+10000000000000000000\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zero and decimal and negative sign and negative exponent and trailing zero\",\n\t\t\targs: args{\n\t\t\t\ts:   `-0.123e-10000000000000000000`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-0.123e-10000000000000000000\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zero and decimal and negative sign and exponent and trailing zero\",\n\t\t\targs: args{\n\t\t\t\ts:   `-0.123e+100000000000000000000`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-0.123e+100000000000000000000\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zero and decimal and negative sign and negative exponent and trailing zero\",\n\t\t\targs: args{\n\t\t\t\ts:   `-0.123e-100000000000000000000`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-0.123e-100000000000000000000\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zero and decimal and negative sign and exponent and trailing zero\",\n\t\t\targs: args{\n\t\t\t\ts:   `-0.123e+1000000000000000000000`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-0.123e+1000000000000000000000\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zero and decimal and negative sign and negative exponent and trailing zero\",\n\t\t\targs: args{\n\t\t\t\ts:   `-0.123e-1000000000000000000000`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-0.123e-1000000000000000000000\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zero and decimal and negative sign and exponent and trailing zero\",\n\t\t\targs: args{\n\t\t\t\ts:   `-0.123e+10000000000000000000000`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-0.123e+10000000000000000000000\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zero and decimal and negative sign and negative exponent and trailing zero\",\n\t\t\targs: args{\n\t\t\t\ts:   `-0",
    "272c0c6a1e68be2b97a6035d445c2919": "package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u006\"},\n\t\t\twant: \"\\\\u0061\\\\u006\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\\\\\ \\\\/test\\\\/ \\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\"hello\\\" \\\\world\\\\ /test/ \\b\\f\\n\\r\\t abcüòÅ\\\\xhello\\\\x world\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "27cd5aa55d8e553f006c9edbd010abf8": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestHasSpecialChars(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with double quote\",\n\t\t\targs: args{s: \"hello\\\"\"},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with backslash\",\n\t\t\targs: args{s: \"hello\\\\\"},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with control character\",\n\t\t\targs: args{s: \"hello\\x01\"},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with no special characters\",\n\t\t\targs: args{s: \"hello\"},\n\t\t\twant: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := hasSpecialChars(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"hasSpecialChars() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2806f695f214a4e8dff15db27c43a129": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_JSON(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_JSON_Unmarshal(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    map[string]interface{}\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    map[string]interface{}{},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    map[string]interface{}{\"key1\": \"value1\", \"key2\": \"value2\"},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    map[string]interface{}{\"key1\": map[string]interface{}{\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    map[string]interface{}{\"key\\\"1\": \"value1\"},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif tt.wantErr {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tvar unmarshaled map[string]interface{}\n\t\t\tif err := json.Unmarshal(got.MarshalTo(nil), \u0026unmarshaled); err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(unmarshaled, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", unmarshaled, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "297412639b832349e7f5ce6fcb4c4db4": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\\\\\\\"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"\\\\\\\\\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\\\\\\\"\\\\\\\\\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: ``,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with no quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `hello`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "297a10288aca5d542180707ce840f7cb": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no whitespace\",\n\t\t\targs: args{s: \"abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace\",\n\t\t\targs: args{s: \"  abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailing whitespace\",\n\t\t\targs: args{s: \"abc  \"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"whitespace in the middle\",\n\t\t\targs: args{s: \"a bc\"},\n\t\t\twant: \"bc\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple whitespace\",\n\t\t\targs: args{s: \"  a  bc  \"},\n\t\t\twant: \"bc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading and trailing whitespace\",\n\t\t\targs: args{s: \"  abc  \"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"all whitespace\",\n\t\t\targs: args{s: \"  \"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"newline\",\n\t\t\targs: args{s: \"\\n abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"tab\",\n\t\t\targs: args{s: \"\\t abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"carriage return\",\n\t\t\targs: args{s: \"\\r abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"mixed whitespace\",\n\t\t\targs: args{s: \" \\t\\n\\r abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2ac68ec39b10b3df95bc31cb624004c3": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"single element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,3]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[[1,2],[3,4]]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"4\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with string elements\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[\\\"hello\\\",\\\"world\\\"]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"hello\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"world\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with mixed elements\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,\\\"hello\\\",true,null]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"hello\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNull,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1,2\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1 2]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1 2]\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid array value\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1,2,\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseArray() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2ad93eb098464d4bf66381bf823da026": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Get(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttype want struct {\n\t\twant *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant want\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.Get(tt.args.keys...); !reflect.DeepEqual(got, tt.want.want) {\n\t\t\t\tt.Errorf(\"Value.Get() = %v, want %v\", got, tt.want.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2ae0ecdcd56d387cccfbe4e2f5863e58": "package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u006\"},\n\t\t\twant: \"\\\\u0061\\\\u006\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\\\\\ \\\\/test\\\\/\"},\n\t\t\twant: \"\\\"hello\\\" \\\\world\\\\ /test/\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2cb611f73ab55538a6a679daf9e960b9": "```go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n",
    "2cbc97769b8869a07f477d36c29e51d9": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttype want struct {\n\t\tv   *Value\n\t\ttail string\n\t\terr  error\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant want\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  fmt.Errorf(\"cannot parse empty string\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"{}\",\n\t\t\t\terr:  fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\": \"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"value1\", \"value2\"]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"value\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeString,\n\t\t\t\t\ts: \"value\",\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   `true`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueTrue,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   `false`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueFalse,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   `null`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueNull,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"123\",\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   `NaN`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"NaN\",\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotV, gotTail, gotErr := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif gotErr != nil \u0026\u0026 tt.want.err == nil {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, want nil\", gotErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotErr == nil \u0026\u0026 tt.want.err != nil {\n\t\t\t\tt.Errorf(\"parseValue() error = nil, want %v\", tt.want.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotErr != nil \u0026\u0026 tt.want.err != nil {\n\t\t\t\tif gotErr.Error() != tt.want.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue() error = %v, want %v\", gotErr, tt.want.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(gotV, tt.want.v) {\n\t\t\t\tt.Errorf(\"parseValue() gotV = %v, want %v\", gotV, tt.want.v)\n\t\t\t}\n\t\t\tif gotTail != tt.want.tail {\n\t\t\t\tt.Errorf(\"parseValue() gotTail = %v, want %v\", gotTail, tt.want.tail)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseValue_JSON(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttype want struct {\n\t\tv   *Value\n\t\ttail string\n\t\terr  error\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant want\n\t}{\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\": \"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"value1\", \"value2\"]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"value\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeString,\n\t\t\t\t\ts: \"value\",\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   `true`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueTrue,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   `false`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueFalse,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   `null`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueNull,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"123\",\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   `NaN`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"NaN\",\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotV, gotTail, gotErr := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif gotErr != nil \u0026\u0026 tt.want.err == nil {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, want nil\", gotErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotErr == nil \u0026\u0026 tt.want.err != nil {\n\t\t\t\tt.Errorf(\"parseValue() error = nil, want %v\", tt.want.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotErr != nil \u0026\u0026 tt.want.err != nil {\n\t\t\t\tif gotErr.Error() != tt.want.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue() error = %v, want %v\", gotErr, tt.want.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Compare the parsed Value with the expected Value using JSON encoding/decoding\n\t\t\tgotJSON, err := json.Marshal(gotV)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"parseValue() error marshalling gotV: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\twantJSON, err := json.Marshal(tt.want.v)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"parseValue() error marshalling wantV: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(gotJSON, wantJSON) {\n\t\t\t\tt.Errorf(\"parseValue() gotV = %v, want %v\", string(gotJSON), string(wantJSON))\n\t\t\t}\n\t\t\tif gotTail != tt.want.tail {\n\t\t\t\tt.Errorf(\"parseValue() gotTail = %v, want %v\", gotTail, tt.want.tail)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "2cc3b709604c5951ce3e82ebc9f8d8ad": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_JSON(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_JSON_Unmarshal(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    map[string]interface{}\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    map[string]interface{}{},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    map[string]interface{}{\"key1\": \"value1\", \"key2\": \"value2\"},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    map[string]interface{}{\"key1\": map[string]interface{}{\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    map[string]interface{}{\"key\\\"1\": \"value1\"},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif tt.wantErr {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tvar unmarshaled map[string]interface{}\n\t\t\tif err := json.Unmarshal([]byte(got.MarshalTo(nil)), \u0026unmarshaled); err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(unmarshaled, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", unmarshaled, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2ceadea7d3d22fb61a883ee6a8978095": "```go\npackage fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"empty string\",\n\t\t\targs:    args{s: \"\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"single digit\",\n\t\t\targs:    args{s: \"1\"},\n\t\t\twantNs:  \"1\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"multiple digits\",\n\t\t\targs:    args{s: \"123\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"negative number\",\n\t\t\targs:    args{s: \"-123\"},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"decimal number\",\n\t\t\targs:    args{s: \"123.456\"},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"exponential number\",\n\t\t\targs:    args{s: \"1.23e+4\"},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"exponential number with negative exponent\",\n\t\t\targs:    args{s: \"1.23e-4\"},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading zeros\",\n\t\t\targs:    args{s: \"00123\"},\n\t\t\twantNs:  \"00123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with trailing zeros\",\n\t\t\targs:    args{s: \"123.00\"},\n\t\t\twantNs:  \"123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign\",\n\t\t\targs:    args{s: \"+123\"},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+123.00\"},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\t",
    "2d5f2487d64d711a19307d18f38dabf3": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"simple integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"float\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential notation\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential notation with negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e-4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"inf\",\n\t\t\t},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"Inf\",\n\t\t\t},\n\t\t\twantNs:  \"Inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inF\",\n\t\t\targs: args{\n\t\t\t\ts: \"inF\",\n\t\t\t},\n\t\t\twantNs:  \"inF\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"nan\",\n\t\t\t},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"Nan\",\n\t\t\t},\n\t\t\twantNs:  \"Nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nAn\",\n\t\t\targs: args{\n\t\t\t\ts: \"nAn\",\n\t\t\t},\n\t\t\twantNs:  \"nAn\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123a\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"-123a\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"-inf\",\n\t\t\t},\n\t\t\twantNs:  \"-inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"-nan\",\n\t\t\t},\n\t\t\twantNs:  \"-nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2d6e38d353e304097ec83f3d45819f1d": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\" \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2df992bd75b18193a3fe156e4b85d482": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"simple integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"float\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential notation\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential notation with negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e-4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"inf\",\n\t\t\t},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"Inf\",\n\t\t\t},\n\t\t\twantNs:  \"Inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inF\",\n\t\t\targs: args{\n\t\t\t\ts: \"inF\",\n\t\t\t},\n\t\t\twantNs:  \"inF\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"nan\",\n\t\t\t},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"Nan\",\n\t\t\t},\n\t\t\twantNs:  \"Nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nAn\",\n\t\t\targs: args{\n\t\t\t\ts: \"nAn\",\n\t\t\t},\n\t\t\twantNs:  \"nAn\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123a\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"-123a\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"-inf\",\n\t\t\t},\n\t\t\twantNs:  \"-inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"-nan\",\n\t\t\t},\n\t\t\twantNs:  \"-nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2e1e87a1802ab10a8d0fff9413ec247c": "package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u006\"},\n\t\t\twant: \"\\\\u0061\\\\u006\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\\\\\ \\\\/\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\x\\\\u006\"},\n\t\t\twant: \"\\\"hello\\\" \\\\world\\\\ /\\\\b\\\\f\\\\n\\\\r\\\\tabcüòÅ\\\\x\\\\u006\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2e2c86f97ac7952a6d612a1dfbcc2116": "```go\npackage fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:    \"\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"{}\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\": \"value\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:    `[\"value1\", \"value2\"]`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:    `\"value\"`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"value\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:    `true`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueTrue,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:    `false`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueFalse,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:    `null`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueNull,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:    `123`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:    `NaN`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseValue() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseValue_Invalid(t *testing.T) {\n\ttests := []string{\n\t\t\"truee\",\n\t\t\"fals\",\n\t\t\"nul\",\n\t\t\"{\",\n\t\t\"[\",\n\t\t`\"`,\n\t\t\"123a\",\n\t\t\"123.a\",\n\t\t\"123e\",\n\t\t\"123+\",\n\t\t\"123-\",\n\t\t\"123/\",\n\t\t\"123*\",\n\t\t\"123%\",\n\t\t\"123$\",\n\t\t\"123^\",\n\t\t\"123\u0026\",\n\t\t\"123~\",\n\t\t\"123!\",\n\t\t\"123?\",\n\t\t\"123:\",\n\t\t\"123;\",\n\t\t\"123\\\"\",\n\t\t\"123'\",\n\t\t\"123\\\\\",\n\t\t\"123\\n\",\n\t\t\"123\\r\",\n\t\t\"123\\t\",\n\t\t\"123\\b\",\n\t\t\"123\\f\",\n\t\t\"123\\v\",\n\t\t\"123\\x00\",\n\t\t\"123\\x01\",\n\t\t\"123\\x02\",\n\t\t\"123\\x03\",\n\t\t\"123\\x04\",\n\t\t\"123\\x05\",\n\t\t\"123\\x06\",\n\t\t\"123\\x07\",\n\t\t\"123\\x08\",\n\t\t\"123\\x09\",\n\t\t\"123\\x0a\",\n\t\t\"123\\x0b\",\n\t\t\"123\\x0c\",\n\t\t\"123\\x0d\",\n\t\t\"123\\x0e\",\n\t\t\"123\\x0f\",\n\t\t\"123\\x10\",\n\t\t\"123\\x11\",\n\t\t\"123\\x12\",\n\t\t\"123\\x13\",\n\t\t\"123\\x14\",\n\t\t\"123\\x15\",\n\t\t\"123\\x16\",\n\t\t\"123\\x17\",\n\t\t\"123\\x18\",\n\t\t\"123\\x19\",\n\t\t\"123\\x1a\",\n\t\t\"123\\x1b\",\n\t\t\"123\\x1c\",\n\t\t\"123\\x1d\",\n\t\t\"123\\x1e\",\n\t\t\"123\\x1f\",\n\t\t\"123\\x20\",\n\t\t\"123\\x21\",\n\t\t\"123\\x22\",\n\t\t\"123\\x23\",\n\t\t\"123\\x24\",\n\t\t\"123\\x25\",\n\t\t\"123\\x26\",\n\t\t\"123\\x27\",\n\t\t\"123\\x28\",\n\t\t\"123\\x29\",\n\t\t\"123\\x2a\",\n\t\t\"123\\x2b\",\n\t\t\"123\\x2c\",\n\t\t\"123\\x2d\",\n\t\t\"123\\x2e\",\n\t\t\"123\\x2f\",\n\t\t\"123\\x30\",\n\t\t\"123\\x31\",\n\t\t\"123\\x32\",\n\t\t\"123\\x33\",\n\t\t\"123\\x34\",\n\t\t\"123\\x35\",\n\t\t\"123\\x36\",\n\t\t\"123\\x37\",\n\t\t\"123\\x38\",\n\t\t\"123\\x39\",\n\t\t\"123\\x3a\",\n\t\t\"123\\x3b\",\n\t\t\"123\\x3c\",\n\t\t\"123\\x3d\",\n\t\t\"123\\x3e\",\n\t\t\"123\\x3f\",\n\t\t\"123\\x40\",\n\t\t\"123\\x41\",\n\t\t\"123\\x42\",\n\t\t\"123\\x43\",\n\t\t\"123\\x44\",\n\t\t\"123\\x45\",\n\t\t\"123\\x46\",\n\t\t\"123\\x47\",\n\t\t\"123\\x48\",\n\t\t\"123\\x49\",\n\t\t\"123\\x4a\",\n\t\t\"123\\x4b\",\n\t\t\"123\\x4c\",\n\t\t\"123\\x4d\",\n\t\t\"123\\x4e\",\n\t\t\"123\\x4f\",\n\t\t\"123\\x50\",\n\t\t\"123\\x51\",\n\t\t\"123\\x52\",\n\t\t\"123\\x53\",\n\t\t\"123\\x54\",\n\t\t\"123\\x55\",\n\t\t\"123\\x56\",\n\t\t\"123\\x57\",\n\t\t\"123\\x58\",\n\t\t\"123\\x59\",\n\t\t\"123\\x5a\",\n\t\t\"123\\x5b\",\n\t\t\"123\\x5c\",\n\t\t\"123\\x5d\",\n\t\t\"123\\x5e\",\n\t\t\"123\\x5f\",\n\t\t\"123\\x60\",\n\t\t\"123\\x61\",\n\t\t\"123\\x62\",\n\t\t\"123\\x63\",\n\t\t\"123\\x64\",\n\t\t\"123\\x65\",\n\t\t\"123\\x66\",\n\t\t\"123\\x67\",\n\t\t\"123\\x68\",\n\t\t\"123\\x69\",\n\t\t\"123\\x6a\",\n\t\t\"123\\x6b\",\n\t\t\"123\\x6c\",\n\t\t\"123\\x6d\",\n\t\t\"123\\x6e\",\n\t\t\"123\\x6f\",\n\t\t\"123\\x70\",\n\t\t\"123\\x71\",\n\t\t\"123\\x72\",\n\t\t\"123\\x73\",\n\t\t\"123\\x74\",\n\t\t\"123\\x75\",\n\t\t\"123\\x76\",\n\t\t\"123\\x77\",\n\t\t\"123\\x78\",\n\t\t\"123\\x79\",\n\t\t\"123\\x7a\",\n\t\t\"123\\x7b\",\n\t\t\"123\\x7c\",\n\t\t\"123\\x7d\",\n\t\t\"123\\x7e\",\n\t\t\"123\\x7f\",\n\t\t\"123\\x80\",\n\t\t\"123\\x81\",\n\t\t\"123\\x82\",\n\t\t\"123\\x83\",\n\t\t\"123\\x84\",\n\t\t\"123\\x85\",\n\t\t\"123\\x86\",\n\t\t\"123\\x87\",\n\t\t\"123\\x88\",\n\t\t\"123\\x89\",\n\t\t\"123\\x8a\",\n\t\t\"123\\x8b\",\n\t\t\"123\\x8c\",\n\t\t\"123\\x8d\",\n\t\t\"123\\x8e\",\n\t\t\"123\\x8f\",\n\t\t\"123\\x90\",\n\t\t\"123\\x91\",\n\t\t\"123\\x92\",\n\t\t\"123\\x93\",\n\t\t\"123\\x94\",\n\t\t\"123\\x95\",\n\t\t\"123\\x96\",\n\t\t\"123\\x97\",\n\t\t\"123\\x98\",\n\t\t\"123\\x99\",\n\t\t\"123\\x9a\",\n\t\t\"123\\x9b\",\n\t\t\"123\\x9c\",\n\t\t\"123\\x9d\",\n\t\t\"123\\x9e\",\n\t\t\"123\\x9f\",\n\t\t\"123\\xa0\",\n\t\t\"123\\xa1\",\n\t\t\"123\\xa2\",\n\t\t\"123\\xa3\",\n\t\t\"123\\xa4\",\n\t\t\"123\\xa5\",\n\t\t\"123\\xa6\",\n\t\t\"123\\xa7\",\n\t\t\"123\\xa8\",\n\t\t\"123\\xa9\",\n\t\t\"123\\xaa\",\n\t\t\"123\\xab\",\n\t\t\"123\\xac\",\n\t\t\"123\\xad\",\n\t\t\"123\\xae\",\n\t\t\"123\\xaf\",\n\t\t\"123\\xb0\",\n\t\t\"123\\xb1\",\n\t\t\"123\\xb2\",\n\t\t\"123\\xb3\",\n\t\t\"123\\xb4\",\n\t\t\"123\\xb5\",\n\t\t\"123\\xb6\",\n\t\t\"123\\xb7\",\n\t\t\"123\\xb8\",\n\t\t\"123\\xb9\",\n\t\t\"123\\xba\",\n\t\t\"123\\xbb\",\n\t\t\"123\\xbc\",\n\t\t\"123\\xbd\",\n\t\t\"123\\xbe\",\n\t\t\"123\\xbf\",\n\t\t\"123\\xc0\",\n\t\t\"123\\xc1\",\n\t\t\"123\\xc2\",\n\t\t\"123\\xc3\",\n\t\t\"123\\xc4\",\n\t\t\"123\\xc5\",\n\t\t\"123\\xc6\",\n\t\t\"123\\xc7\",\n\t\t\"123\\xc8\",\n\t\t\"123\\xc9\",\n\t\t\"123\\xca\",\n\t\t\"123\\xcb\",\n\t\t\"123\\xcc\",\n\t\t\"123\\xcd\",\n\t\t\"123\\xce\",\n\t\t\"123\\xcf\",\n\t\t\"123\\xd0\",\n\t\t\"123\\xd1\",\n\t\t\"123\\xd2\",\n\t\t\"123\\xd3\",\n\t\t\"123\\xd4\",\n\t\t\"123\\xd5\",\n\t\t\"123\\xd6\",\n\t\t\"123\\xd7\",\n\t\t\"123\\xd8\",\n\t\t\"123\\xd9\",\n\t\t\"123\\xda\",\n\t\t\"123\\xdb\",\n\t\t\"123\\xdc\",\n\t\t\"123\\xdd\",\n\t\t\"123\\xde\",\n\t\t\"123\\xdf\",\n\t\t\"123\\xe0\",\n\t\t\"123\\xe1\",\n\t\t\"123\\xe2\",\n\t\t\"123\\xe3\",\n\t\t\"123\\xe4\",\n\t\t\"123\\xe5\",\n\t\t\"123\\xe6\",\n\t\t\"123\\xe7\",\n\t\t\"123\\xe8\",\n\t\t\"123\\xe9\",\n\t\t\"123\\xea\",\n\t\t\"123\\xeb\",\n\t\t\"123\\xec\",\n\t\t\"123\\xed\",\n\t\t\"123\\xee\",\n\t\t\"123\\xef\",\n\t\t\"123\\xf0\",\n\t\t\"123\\xf1\",\n\t\t\"123\\xf2\",\n\t\t\"123\\xf3\",\n\t\t\"123\\xf4\",\n\t\t\"123\\xf5\",\n\t\t\"123\\xf6\",\n\t\t\"123\\xf7\",\n\t\t\"123\\xf8\",\n\t\t\"123\\xf9\",\n\t\t\"123\\xfa\",\n\t\t\"123\\xfb\",\n\t\t\"123\\xfc\",\n\t\t\"123\\xfd\",\n\t\t\"123\\xfe\",\n\t\t\"123\\xff\",\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt, func(t *testing.T) {\n\t\t\t_, _, err := parseValue(tt, \u0026cache{}, 0)\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) = nil, want error\", tt)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseValue_EscapedString(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"escaped backslash\",\n\t\t\tinput:    `\"\\\\\"`,\n\t\t\texpected: `\\`,\n\t\t},\n\t\t{\n\t\t\tname:     \"escaped double quote\",\n\t\t\tinput:    `\"\\\"\"`,\n\t\t\texpected: `\"`,\n\t\t},\n\t\t{\n\t\t\tname:     \"escaped forward slash\",\n\t\t\tinput:    `\"\\/\"`,\n\t\t\texpected: `/`,\n\t\t},\n\t\t{\n\t\t\tname:     \"escaped backspace\",\n\t\t\tinput:    `\"\\b\"`,\n\t\t\texpected: \"\\b\",\n\t\t},\n\t\t{\n\t\t\tname:     \"escaped form feed\",\n\t\t\tinput:    `\"\\f\"`,\n\t\t\texpected: \"\\f\",\n\t\t},\n\t\t{\n\t\t\tname:     \"escaped newline\",\n\t\t\tinput:    `\"\\n\"`,\n\t\t\texpected: \"\\n\",\n\t\t},\n\t\t{\n\t\t\tname:     \"escaped carriage return\",\n\t\t\tinput:    `\"\\r\"`,\n\t\t\texpected: \"\\r\",\n\t\t},\n\t\t{\n\t\t\tname:     \"escaped tab\",\n\t\t\tinput:    `\"\\t\"`,\n\t\t\texpected: \"\\t\",\n\t\t},\n\t\t{\n\t\t\tname:     \"escaped unicode\",\n\t\t\tinput:    `\"\\u0061\"`,\n\t\t\texpected: \"a\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tv, _, err := parseValue(tt.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"parseValue() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif v.s != tt.expected {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", v.s, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseValue_InvalidEscapedString(t *testing.T) {\n\ttests := []string{\n\t\t`\"\\x\"`,\n\t\t`\"\\u\"`,\n\t\t`\"\\u0\"`,\n\t\t`\"\\u00\"`,\n\t\t`\"\\u000\"`,\n\t\t`\"\\u0000\"`,\n\t\t`\"\\u00000\"`,\n\t\t`\"\\u000000\"`,\n\t\t`\"\\u0000000\"`,\n\t\t`\"\\u00000000\"`,\n\t\t`\"\\u000000000\"`,\n\t\t`\"\\u0000000000\"`,\n\t\t`\"\\u00000000000\"`,\n\t\t`\"\\u000000000000\"`,\n\t\t`\"\\u0000000000000\"`,\n\t\t`\"\\u00000000000000\"`,\n\t\t`\"\\u000000000000000\"`,\n\t\t`\"\\u0000000000000000\"`,\n\t\t`\"\\u00000000000000000\"`,\n\t\t`\"\\u000000000000000000\"`,\n\t\t`\"\\u0000000000000000000\"`,\n\t\t`\"\\u00000000000000000000\"`,\n\t\t`\"\\u000000000000000000000\"`,\n\t\t`\"\\u0000000000000000000000\"`,\n\t\t`\"\\u00000000000000000000000\"`,\n\t\t`\"\\u000000000000000000000000\"`,\n\t\t`\"\\u0000000000000000000000000\"`,\n\t\t`\"\\u00000000000000000000000000\"`,\n\t\t`\"\\u000000000000000000000000000\"`,\n\t\t`\"\\u0000000000000000000000000000\"`,\n\t\t`\"\\u00000000000000000000000000000\"`,\n\t\t`\"\\u000000000000000000000000000000\"`,\n\t\t`\"\\u0000000000000000000000000000000\"`,\n\t\t`\"\\u00000000000000000000000000000000\"`,\n\t\t`\"\\u000000000000000000000000000000000\"`,\n\t\t`\"\\u0000000000000000000000000000000000\"`,\n\t\t`\"\\u00000000000000000000000000000000000\"`,\n\t\t`\"\\u000000000000000000000000000000000000\"`,\n\t\t`\"\\u0000000000000000000000000000000000000\"`,\n\t\t`\"\\u00000000000000000000000000000000000000\"`,\n\t\t`\"\\u000000000000000000000000000000000000000\"`,\n\t\t`\"\\u0000000000000000000000000000000000000000\"`,\n\t\t`\"\\u00000000000000000000000000000000000000000\"`,\n\t\t`\"\\u000000000000000000000000000000000000000000\"`,\n\t\t`\"\\u0000000000000000000000000000000000000000000\"`,\n\t\t`\"\\u00000000000000000000000000000000000000000000\"`,\n\t\t`\"\\u000000000000000000000000000000000000000000000\"`,\n\t\t`\"\\u0000000000000000000000000000000000000000000000\"`,\n\t\t`\"\\u00000000000000000000000000000000000000000000000\"`,\n\t\t`\"\\u000000000000000000000000000000000000000000000000\"`,\n\t\t`\"\\u0000000000000000000000000000000000000000000000000\"`,\n\t\t`\"\\u00000000000000000000000000000000000000000000000000\"`,\n\t\t`\"\\u000000000000000000000000000000000000000000000000000\"`,\n\t\t`\"\\u0000000000000000000000000000000000000000000000000000\"`,\n\t\t`\"\\u00000000000000000000000000000000000000000000000000000\"`,\n\t\t`\"\\u000000000000000000000000000000000000000000000000000000\"`,\n\t\t`\"\\u0000000000000000000000000000000000000000000000000000000\"`,\n\t\t`\"\\u00000000000000000000000000000000000000000000000000000000\"`,\n\t\t`\"\\u000000000000000000000000000000000000000000000000000000000\"`,\n\t\t`\"\\u0000000000000000000000000000000000000000000000000000000000\"`,\n\t\t`\"\\u00000000000000000000000000000000000000000000000000000000000\"`,\n\t\t`\"\\u000000000000000000000000000000000000000000000000000000000000\"`,\n\t\t`\"\\u0000000000000000000000000000000000000000000000000000000000000\"`,\n\t\t`\"\\u00000000000000000000000000000000000000000000000000000000000000\"`,\n\t\t`\"\\u000000000000000000000000000000000000000000000000000000000000000\"`,\n\t\t`\"\\u0000000000000000000000000000000000000000000000000000000000000000\"`,\n\t\t`\"\\u00000000000000000000000000000000000000000000000000000000000000000\"`,\n\t\t`\"\\u000000000000000000000000000000000000000000000000000000000000000000\"`,\n\t\t`\"\\u0000000000000000000000000000000000000000000000000000000000000000000\"`,\n\t\t`\"\\u00000000000000000000000000000000000000000000000000000000000000000000\"`,\n\t\t`\"\\u000000000000000000000000000000000000000000000000000000000000000000000\"`,\n\t\t`\"\\u0000000000000000000000000000000000000000000000000000000000000000000000\"`,\n\t\t`\"\\u00000000000000000000000000000000000000000000000000000000000000000000000\"`,\n\t\t`\"\\u000000000000000000000000000000000000000000000000000000000000000000000000\"`,\n\t\t`\"\\u0000000000000000000000000000000000000000000000000000000000000000000000000\"`,\n\t\t`\"\\u00000000000000000000000000000000000000000000000000000000000000000000000000\"`,\n\t\t`\"\\u000000000000000000000000000000000000000000000000000000000000000000000000000\"`,\n\t\t`\"\\u0000000000000000000000000000000000000000000000000000000000000000000000000000\"`,\n\t\t`\"\\u000000000000000000000000000000000000000000000000000000000000",
    "2f909e3670e0008a815b20c6f7e8a3a7": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped string with multiple escapes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: ``,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with no quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `hello`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2fa92d72de8793804a62897e8d2d73f2": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestType_String(t *testing.T) {\n\ttype args struct {\n\t\tt Type\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"TestType_String_Object\",\n\t\t\targs: args{t: TypeObject},\n\t\t\twant: \"object\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_Array\",\n\t\t\targs: args{t: TypeArray},\n\t\t\twant: \"array\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_String\",\n\t\t\targs: args{t: TypeString},\n\t\t\twant: \"string\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_Number\",\n\t\t\targs: args{t: TypeNumber},\n\t\t\twant: \"number\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_True\",\n\t\t\targs: args{t: TypeTrue},\n\t\t\twant: \"true\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_False\",\n\t\t\targs: args{t: TypeFalse},\n\t\t\twant: \"false\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_Null\",\n\t\t\targs: args{t: TypeNull},\n\t\t\twant: \"null\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.t.String(); got != tt.want {\n\t\t\t\tt.Errorf(\"Type.String() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2fb0fc2eb32e058ac2dd842299b25569": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueGet(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant *Value\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.Get(tt.args.keys...); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.Get() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2fe3ae84a715a014fd4df63781c671e4": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"{}\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\": \"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"value1\", \"value2\"]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"value\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"value\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   `true`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueTrue,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   `false`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueFalse,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   `null`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueNull,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with decimal\",\n\t\t\targs: args{\n\t\t\t\ts:   `123.456`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e+4`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e-4`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"1.23e-4\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `-123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative sign and decimal\",\n\t\t\targs: args{\n\t\t\t\ts:   `-123.456`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-123.456\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative sign and exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `-1.23e+4`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-1.23e+4\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative sign and negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `-1.23e-4`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-1.23e-4\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   `NaN`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected value\",\n\t\t\targs: args{\n\t\t\t\ts:   `tru`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"tru\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr {\n\t\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t\t}\n\t\t\t\tif got1 != tt.want1 {\n\t\t\t\t\tt.Errorf(\"parseValue() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseValue_JSON(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts: `{\"key\": \"value\"}`,\n\t\t\t},\n\t\t\twant:    `{\"key\":\"value\"}`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts: `[\"value1\", \"value2\"]`,\n\t\t\t},\n\t\t\twant:    `[\"value1\",\"value2\"]`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"value\"`,\n\t\t\t},\n\t\t\twant:    `\"value\"`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts: `true`,\n\t\t\t},\n\t\t\twant:    `true`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts: `false`,\n\t\t\t},\n\t\t\twant:    `false`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts: `null`,\n\t\t\t},\n\t\t\twant:    `null`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts: `123`,\n\t\t\t},\n\t\t\twant:    `123`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with decimal\",\n\t\t\targs: args{\n\t\t\t\ts: `123.456`,\n\t\t\t},\n\t\t\twant:    `123.456`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with exponent\",\n\t\t\targs: args{\n\t\t\t\ts: `1.23e+4`,\n\t\t\t},\n\t\t\twant:    `1.23e+4`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts: `1.23e-4`,\n\t\t\t},\n\t\t\twant:    `1.23e-4`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative sign\",\n\t\t\targs: args{\n\t\t\t\ts: `-123`,\n\t\t\t},\n\t\t\twant:    `-123`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative sign and decimal\",\n\t\t\targs: args{\n\t\t\t\ts: `-123.456`,\n\t\t\t},\n\t\t\twant:    `-123.456`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative sign and exponent\",\n\t\t\targs: args{\n\t\t\t\ts: `-1.23e+4`,\n\t\t\t},\n\t\t\twant:    `-1.23e+4`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative sign and negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts: `-1.23e-4`,\n\t\t\t},\n\t\t\twant:    `-1.23e-4`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts: `NaN`,\n\t\t\t},\n\t\t\twant:    `NaN`,\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, _, err := parseValue(tt.args.s, c, 0)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr {\n\t\t\t\tb, err := json.Marshal(got)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"json.Marshal() error = %v\", err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif string(b) != tt.want {\n\t\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", string(b), tt.want)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}",
    "2ff1850ae86de1ccc21484979242f638": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quotes and other characters\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"\\\\\\\\\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\\\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped closing quote and other characters\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"\\\\\\\\\\\\\"`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2ff24b4095c848855256487499af5870": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Get(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttype want struct {\n\t\twant *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant want\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.Get(tt.args.keys...); !reflect.DeepEqual(got, tt.want.want) {\n\t\t\t\tt.Errorf(\"Value.Get() = %v, want %v\", got, tt.want.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2ff422ba8ebbc2fbda9512c1f666199b": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGet(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant *Value\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.Get(tt.args.keys...); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Get() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "303ad9d4dc410347d2cbd3bf7c648fec": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_getKV(t *testing.T) {\n\ttype args struct {\n\t\to *Object\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant *kv\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.o.getKV(); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Object.getKV() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "303b207c74ac5ea4ce5afbb436c3bd7f": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestType_String(t *testing.T) {\n\ttype args struct {\n\t\tt Type\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"TestType_String_Object\",\n\t\t\targs: args{t: TypeObject},\n\t\t\twant: \"object\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_Array\",\n\t\t\targs: args{t: TypeArray},\n\t\t\twant: \"array\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_String\",\n\t\t\targs: args{t: TypeString},\n\t\t\twant: \"string\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_Number\",\n\t\t\targs: args{t: TypeNumber},\n\t\t\twant: \"number\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_True\",\n\t\t\targs: args{t: TypeTrue},\n\t\t\twant: \"true\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_False\",\n\t\t\targs: args{t: TypeFalse},\n\t\t\twant: \"false\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_Null\",\n\t\t\targs: args{t: TypeNull},\n\t\t\twant: \"null\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.t.String(); got != tt.want {\n\t\t\t\tt.Errorf(\"Type.String() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "3054603d186f99fd6bc0c1c19a1e5682": "package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u006\"},\n\t\t\twant: \"\\\\u0061\\\\u006\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\\\\\ \\\\/\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\x\\\\u006\"},\n\t\t\twant: \"\\\"hello\\\" \\\\world\\\\ /\\\\b\\\\f\\\\n\\\\r\\\\tabcüòÅ\\\\x\\\\u006\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "3081f2b7867988b78d42025b66c8cccd": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"single digit\",\n\t\t\targs: args{\n\t\t\t\ts: \"1\",\n\t\t\t},\n\t\t\twantNs:  \"1\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple digits\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"decimal number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative number\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"positive number\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential number\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential number with negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e-4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zeros\",\n\t\t\targs: args{\n\t\t\t\ts: \"00123\",\n\t\t\t},\n\t\t\twantNs:  \"00123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with trailing zeros\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.00\",\n\t\t\t},\n\t\t\twantNs:  \"123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading plus sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading minus sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading space\",\n\t\t\targs: args{\n\t\t\t\ts: \" 123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" 123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number with trailing space\",\n\t\t\targs: args{\n\t\t\t\ts: \"123 \",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \" \",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character\",\n\t\t\targs: args{\n\t\t\t\ts: \"123a\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at the beginning\",\n\t\t\targs: args{\n\t\t\t\ts: \"a123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"a123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at the beginning 2\",\n\t\t\targs: args{\n\t\t\t\ts: \"1a23\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"1a23\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}",
    "30a6bbea29b047461f96d6422567f1ed": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetInt(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant int\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.GetInt(tt.args.keys...); got != tt.want {\n\t\t\t\tt.Errorf(\"Value.GetInt() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "31708e9592fc730726c6da06f0a4e763": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetObject(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant *Object\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.GetObject(tt.args.keys...); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"GetObject() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "333e884dc25e2d7b7f3d4f1c2e529dc0": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped string with multiple escapes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: ``,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with no quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `hello`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\\\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   `hello\"`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote and other characters\",\n\t\t\targs: args{\n\t\t\t\ts: `\\\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   `hello\\\\\"world\"`,\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "33bbc286c9451caee7ebaaf46dcc21c3": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObjectReset(t *testing.T) {\n\ttype args struct {\n\t\to *Object\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant *Object\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.o.reset(); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Object.reset() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "34b7165e20b8f325f1cd12eb03dfd9f7": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueInt(t *testing.T) {\n\ttype args struct {\n\t\tv *Value\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    int\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := tt.args.v.Int()\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Value.Int() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Value.Int() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "34e720be16f6ed3adf8118013d3b1dfe": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\" \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_JSONUnmarshal(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    map[string]interface{}\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    map[string]interface{}{},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    map[string]interface{}{\"key1\": \"value1\", \"key2\": \"value2\"},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    map[string]interface{}{\"key1\": map[string]interface{}{\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    map[string]interface{}{\"key\\\"1\": \"value1\"},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif tt.wantErr {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tvar wantJSON map[string]interface{}\n\t\t\tif err := json.Unmarshal([]byte(tt.args.s), \u0026wantJSON); err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got.o.toMap(), wantJSON) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got.o.toMap(), wantJSON)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc (o Object) toMap() map[string]interface{} {\n\tm := make(map[string]interface{})\n\tfor _, kv := range o.kvs {\n\t\tif kv.v.t == TypeObject {\n\t\t\tm[kv.k] = kv.v.o.toMap()\n\t\t} else if kv.v.t == TypeArray {\n\t\t\ta := make([]interface{}, len(kv.v.a))\n\t\t\tfor i, v := range kv.v.a {\n\t\t\t\tif v.t == TypeObject {\n\t\t\t\t\ta[i] = v.o.toMap()\n\t\t\t\t} else {\n\t\t\t\t\ta[i] = v.s\n\t\t\t\t}\n\t\t\t}\n\t\t\tm[kv.k] = a\n\t\t} else {\n\t\t\tm[kv.k] = kv.v.s\n\t\t}\n\t}\n\treturn m\n}",
    "352054701a05c0ea76f056039ee028d9": "package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u006\"},\n\t\t\twant: \"\\\\u0061\\\\u006\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\\\\\ \\\\/\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\x\\\\u006\"},\n\t\t\twant: \"\\\"hello\\\" \\\\world\\\\ /\\\\b\\\\f\\\\n\\\\r\\tabcüòÅ\\\\x\\\\u006\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "36b8bc01cb6a97aac3ef6a838c4f1a2d": "package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u006\"},\n\t\t\twant: \"\\\\u0061\\\\u006\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\\\\\ \\\\/\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\x\\\\u006\"},\n\t\t\twant: \"\\\"hello\\\" \\\\world\\\\ /\\\\b\\\\f\\\\n\\\\r\\\\tabcüòÅ\\\\x\\\\u006\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "387bddf6b1481bddeded9525ddd43a5d": "package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061hello\\\\u0062 world\"},\n\t\t\twant: \"ahello b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01hello\\\\uD83D\\\\uDE02 world\"},\n\t\t\twant: \"üòÅhelloüòÇ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061hello\\\\u world\"},\n\t\t\twant: \"\\\\u0061hello\\\\u world\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\\\\\ \\\\/test\\\\/ \\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\u0062\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\"},\n\t\t\twant: \"\\\"hello\\\" \\\\world\\\\ /test/ \\b\\f\\n\\r\\ta büòÅüòÇ\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "39322df48baace138a017c3d3bc1d3b5": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetArray(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant []*Value\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.GetArray(tt.args.keys...); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.GetArray() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "3a0ad62efe4f25d6536920f0034c4190": "package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete unicode escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u006\"},\n\t\t\twant: \"\\\\u0061\\\\u006\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE\",\n\t\t},\n\t\t{\n\t\t\tname: \"mixed escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\/ \\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\x\"},\n\t\t\twant: \"\\\"hello\\\" \\\\world/ \\b\\f\\n\\r\\tabcüòÅ\\\\x\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "3a398eada6bb87a5c52c84d718887602": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Object(t *testing.T) {\n\ttype args struct {\n\t\tv *Value\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Object\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := tt.args.v.Object()\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Value.Object() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.Object() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "3aaf7a1aae8189f0ac66ba79a7f3d3ae": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\tv   *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"marshal null\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNull},\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal true\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeTrue},\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal false\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeFalse},\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeString, s: \"hello\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal number\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t},\n\t\t\twant: []byte(\"123\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal raw string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: typeRawString, s: \"hello\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal array\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeArray, a: []*Value{{t: TypeString, s: \"hello\"}, {t: TypeNumber, s: \"123\"}}},\n\t\t\t},\n\t\t\twant: []byte(\"[\\\"hello\\\",123]\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal object\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"name\", v: \u0026Value{t: TypeString, s: \"John Doe\"}}, {k: \"age\", v: \u0026Value{t: TypeNumber, s: \"30\"}}}}},\n\t\t\t},\n\t\t\twant: []byte(`{\"name\":\"John Doe\",\"age\":30}`),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.v.MarshalTo(tt.args.dst); !bytesEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc bytesEqual(a, b []byte) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "3b184aa717383a10e0642287c3ad0201": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"single element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,3]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[[1,2],[3,4]]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"4\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with trailing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \",\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"array with missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1,2\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"array with invalid value\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,a]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"a]\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseArray() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "3c43fd358c0d29f9399e5e3093638908": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWS(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no whitespace\",\n\t\t\targs: args{s: \"abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace\",\n\t\t\targs: args{s: \"  abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailing whitespace\",\n\t\t\targs: args{s: \"abc  \"},\n\t\t\twant: \"abc  \",\n\t\t},\n\t\t{\n\t\t\tname: \"whitespace in the middle\",\n\t\t\targs: args{s: \"abc  def\"},\n\t\t\twant: \"abc  def\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple whitespace\",\n\t\t\targs: args{s: \"  abc  def  \"},\n\t\t\twant: \"abc  def  \",\n\t\t},\n\t\t{\n\t\t\tname: \"special characters\",\n\t\t\targs: args{s: \"  abc\\tdef  \"},\n\t\t\twant: \"abc\\tdef  \",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWS(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWS() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "3c5d58b5438759a28be54d5c21c2f82c": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueArray(t *testing.T) {\n\ttype args struct {\n\t\tv *Value\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    []*Value\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := tt.args.v.Array()\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Value.Array() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.Array() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "3c85e974218694a7de9cb13fa4be2f63": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttype want struct {\n\t\tv   *Value\n\t\ttail string\n\t\terr  error\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant want\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  fmt.Errorf(\"cannot parse empty string\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"{}\",\n\t\t\t\terr:  fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{t: TypeObject, o: Object{}},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{t: TypeArray, a: []*Value{}},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"hello\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{t: typeRawString, s: \"hello\"},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   \"true\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueTrue,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   \"false\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueFalse,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   \"null\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueNull,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   \"123\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   \"NaN\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"NaN\"},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotV, gotTail, gotErr := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif gotErr != nil \u0026\u0026 tt.want.err == nil {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, want nil\", gotErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotErr == nil \u0026\u0026 tt.want.err != nil {\n\t\t\t\tt.Errorf(\"parseValue() error = nil, want %v\", tt.want.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotErr != nil \u0026\u0026 tt.want.err != nil {\n\t\t\t\tif gotErr.Error() != tt.want.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue() error = %v, want %v\", gotErr, tt.want.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(gotV, tt.want.v) {\n\t\t\t\tt.Errorf(\"parseValue() gotV = %v, want %v\", gotV, tt.want.v)\n\t\t\t}\n\t\t\tif gotTail != tt.want.tail {\n\t\t\t\tt.Errorf(\"parseValue() gotTail = %v, want %v\", gotTail, tt.want.tail)\n\t\t\t}\n\t\t})\n\t}\n}",
    "3d1a0785dcf3d2378895c989662c217c": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetInt(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant int\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.GetInt(tt.args.keys...); got != tt.want {\n\t\t\t\tt.Errorf(\"Value.GetInt() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "3d2d4a89f500c5677c5352bea33edf13": "```go\npackage fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": {\"nested_key1\": \"nested_value1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n",
    "3d6e3f3ce2b90894ed5585626a6d5265": "package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n)\n\nfunc TestEscapeString(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\ts   string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\ts:   \"\",\n\t\t\t},\n\t\t\twant: []byte(`\"\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\ts:   \"hello\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"string with special characters\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\ts:   \"hello, world!\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello, world!\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped characters\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\ts:   `\"\\t\\r\\n\"`,\n\t\t\t},\n\t\t\twant: []byte(`\"\\\\t\\\\r\\\\n\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"string with unicode characters\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\ts:   \"‰Ω†Â•Ω‰∏ñÁïå\",\n\t\t\t},\n\t\t\twant: []byte(`\"‰Ω†Â•Ω‰∏ñÁïå\"`),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := escapeString(tt.args.dst, tt.args.s); !bytesEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"escapeString() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc bytesEqual(a, b []byte) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "3d8f6ad0ab0bfb926e53c4a95ced9ccd": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"single element array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[1]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[1,2,3]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[[1,2],[3,4]]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"4\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with whitespace\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[ 1 , 2 , 3 ]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[1,2,3\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1,2,3\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[1 2,3]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1 2,3]\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected end of array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[1,2,\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1,2,\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseArray() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "3f31a54f585efbbec2a16c87a8cbe8e0": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"single element array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"hello\"]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"hello\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"hello\", \"world\", 123]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"hello\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"world\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[[\"hello\", \"world\"], 123]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"hello\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"world\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:   `[1, 2, 3`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `[1, 2, 3`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:   `[1 2, 3]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `[1 2, 3]`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseArray() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseArray_JSON(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    interface{}\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts: \"[]\",\n\t\t\t},\n\t\t\twant:    []interface{}{},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"single element array\",\n\t\t\targs: args{\n\t\t\t\ts: `[\"hello\"]`,\n\t\t\t},\n\t\t\twant:    []interface{}{\"hello\"},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element array\",\n\t\t\targs: args{\n\t\t\t\ts: `[\"hello\", \"world\", 123]`,\n\t\t\t},\n\t\t\twant:    []interface{}{\"hello\", \"world\", 123},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts: `[[\"hello\", \"world\"], 123]`,\n\t\t\t},\n\t\t\twant:    []interface{}{[]interface{}{\"hello\", \"world\"}, 123},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, _, err := parseArray(tt.args.s, c, 0)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got.a, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got.a, tt.want)\n\t\t\t}\n\t\t\tvar want []interface{}\n\t\t\tif err := json.Unmarshal([]byte(tt.args.s), \u0026want); err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got.a, want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got.a, want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "3f357661c008ff56cdc0f9cfad225fac": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueBool(t *testing.T) {\n\ttype args struct {\n\t\tv *Value\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    bool\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := tt.args.v.Bool()\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Value.Bool() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Value.Bool() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "3f7572e75236edb893fcc23f31599964": "```go\npackage fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n",
    "40a195db240c45247c569f188288dc15": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\"world\\\\\\\"\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quotes and other characters\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"\\\\\\\\\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\\\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped closing quote and other characters\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: ``,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "40bce8756653a7f7b2a826f9d1e70a02": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with invalid key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_JSON(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_JSON_Unmarshal(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    map[string]interface{}\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    map[string]interface{}{},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    map[string]interface{}{\"key1\": \"value1\", \"key2\": \"value2\"},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    map[string]interface{}{\"key1\": map[string]interface{}{\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    map[string]interface{}{\"key\\\"1\": \"value1\"},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif tt.wantErr {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tvar unmarshaled map[string]interface{}\n\t\t\tif err := json.Unmarshal(got.StringBytes(), \u0026unmarshaled); err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(unmarshaled, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", unmarshaled, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "41702ffcac5eb63c344593da8804a2ae": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escaped strings\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"test\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\\\\\\\"test\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: ``,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"no quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `hello`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "418c69497f59b9f493827f62e95a9c11": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetBool(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant bool\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.GetBool(tt.args.keys...); got != tt.want {\n\t\t\t\tt.Errorf(\"Value.GetBool() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "41eed9330e6f62c05d39e701011084a6": "```go\npackage fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"single digit\",\n\t\t\targs: args{\n\t\t\t\ts: \"1\",\n\t\t\t},\n\t\t\twantNs:  \"1\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple digits\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative number\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"decimal number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential number\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential number with negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e-4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"inf\",\n\t\t\t},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"INF\",\n\t\t\targs: args{\n\t\t\t\ts: \"INF\",\n\t\t\t},\n\t\t\twantNs:  \"INF\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"nan\",\n\t\t\t},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NAN\",\n\t\t\targs: args{\n\t\t\t\ts: \"NAN\",\n\t\t\t},\n\t\t\twantNs:  \"NAN\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with trailing whitespace\",\n\t\t\targs: args{\n\t\t\t\ts: \"123 \",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \" \",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading whitespace\",\n\t\t\targs: args{\n\t\t\t\ts: \" 123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" 123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character\",\n\t\t\targs: args{\n\t\t\t\ts: \"123a\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start\",\n\t\t\targs: args{\n\t\t\t\ts: \"a123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"a123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 2\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 3\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123+\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"-123+\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 4\",\n\t\t\targs: args{\n\t\t\t\ts: \"-+123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"-+123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 5\",\n\t\t\targs: args{\n\t\t\t\ts: \"123-\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 6\",\n\t\t\targs: args{\n\t\t\t\ts: \"123+\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 7\",\n\t\t\targs: args{\n\t\t\t\ts: \"123e\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"e\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 8\",\n\t\t\targs: args{\n\t\t\t\ts: \"123E\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"E\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 9\",\n\t\t\targs: args{\n\t\t\t\ts: \"123-\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 10\",\n\t\t\targs: args{\n\t\t\t\ts: \"123+\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 11\",\n\t\t\targs: args{\n\t\t\t\ts: \"123e\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"e\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 12\",\n\t\t\targs: args{\n\t\t\t\ts: \"123E\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"E\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 13\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \".\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 14\",\n\t\t\targs: args{\n\t\t\t\ts: \"123-\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 15\",\n\t\t\targs: args{\n\t\t\t\ts: \"123+\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 16\",\n\t\t\targs: args{\n\t\t\t\ts: \"123e\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"e\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 17\",\n\t\t\targs: args{\n\t\t\t\ts: \"123E\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"E\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 18\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \".\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 19\",\n\t\t\targs: args{\n\t\t\t\ts: \"123-\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 20\",\n\t\t\targs: args{\n\t\t\t\ts: \"123+\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 21\",\n\t\t\targs: args{\n\t\t\t\ts: \"123e\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"e\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 22\",\n\t\t\targs: args{\n\t\t\t\ts: \"123E\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"E\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 23\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \".\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 24\",\n\t\t\targs: args{\n\t\t\t\ts: \"123-\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 25\",\n\t\t\targs: args{\n\t\t\t\ts: \"123+\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 26\",\n\t\t\targs: args{\n\t\t\t\ts: \"123e\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"e\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 27\",\n\t\t\targs: args{\n\t\t\t\ts: \"123E\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"E\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 28\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \".\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 29\",\n\t\t\targs: args{\n\t\t\t\ts: \"123-\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 30\",\n\t\t\targs: args{\n\t\t\t\ts: \"123+\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 31\",\n\t\t\targs: args{\n\t\t\t\ts: \"123e\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"e\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 32\",\n\t\t\targs: args{\n\t\t\t\ts: \"123E\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"E\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 33\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \".\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 34\",\n\t\t\targs: args{\n\t\t\t\ts: \"123-\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 35\",\n\t\t\targs: args{\n\t\t\t\ts: \"123+\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 36\",\n\t\t\targs: args{\n\t\t\t\ts: \"123e\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"e\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 37\",\n\t\t\targs: args{\n\t\t\t\ts: \"123E\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"E\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 38\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \".\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 39\",\n\t\t\targs: args{\n\t\t\t\ts: \"123-\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 40\",\n\t\t\targs: args{\n\t\t\t\ts: \"123+\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 41\",\n\t\t\targs: args{\n\t\t\t\ts: \"123e\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"e\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 42\",\n\t\t\targs: args{\n\t\t\t\ts: \"123E\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"E\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 43\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \".\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 44\",\n\t\t\targs: args{\n\t\t\t\ts: \"123-\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 45\",\n\t\t\targs: args{\n\t\t\t\ts: \"123+\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 46\",\n\t\t\targs: args{\n\t\t\t\ts: \"123e\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"e\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 47\",\n\t\t\targs: args{\n\t\t\t\ts: \"123E\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"E\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 48\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \".\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 49\",\n\t\t\targs: args{\n\t\t\t\ts: \"123-\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 50\",\n\t\t\targs: args{\n\t\t\t\ts: \"123+\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 51\",\n\t\t\targs: args{\n\t\t\t\ts: \"123e\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"e\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 52\",\n\t\t\targs: args{\n\t\t\t\ts: \"123E\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"E\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 53\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \".\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 54\",\n\t\t\targs: args{\n\t\t\t\ts: \"123-\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 55\",\n\t\t\targs: args{\n\t\t\t\ts: \"123+\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 56\",\n\t\t\targs: args{\n\t\t\t\ts: \"123e\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"e\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 57\",\n\t\t\targs: args{\n\t\t\t\ts: \"123E\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"E\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 58\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \".\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 59\",\n\t\t\targs: args{\n\t\t\t\ts: \"123-\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 60\",\n\t\t\targs: args{\n\t\t\t\ts: \"123+\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 61\",\n\t\t\targs: args{\n\t\t\t\ts: \"123e\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"e\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 62\",\n\t\t\targs: args{\n\t\t\t\ts: \"123E\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"E\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 63\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \".\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 64\",\n\t\t\targs: args{\n\t\t\t\ts: \"123-\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 65\",\n\t\t\targs: args{\n\t\t\t\ts: \"123+\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 66\",\n\t\t\targs: args{\n\t\t\t\ts: \"123e\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"e\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 67\",\n\t\t\targs: args{\n\t\t\t\ts: \"123E\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"E\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 68\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \".\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 69\",\n\t\t\targs: args{\n\t\t\t\ts: \"123-\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 70\",\n\t\t\targs: args{\n\t\t\t\ts: \"123+\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 71\",\n\t\t\targs: args{\n\t\t\t\ts: \"123e\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"e\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 72\",\n\t\t\targs: args{\n\t\t\t\ts: \"123E\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"E\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 73\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \".\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 74\",\n\t\t\targs: args{\n\t\t\t\ts: \"123-\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 75\",\n\t\t\targs: args{\n\t\t\t\ts: \"123+\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 76\",\n\t\t\targs: args{\n\t\t\t\ts: \"123e\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"e\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 77\",\n\t\t\targs: args{\n\t\t\t\ts: \"123E\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"E\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 78\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \".\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 79\",\n\t\t\targs: args{\n\t\t\t\ts: \"123-\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 80\",\n\t\t\targs: args{\n\t\t\t\ts: \"123+\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 81\",\n\t\t\targs: args{\n\t\t\t\ts: \"123e\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"e\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 82\",\n\t\t\targs: args{\n\t\t\t\ts: \"123E\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"E\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 83\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \".\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 84\",\n\t\t\targs: args{\n\t\t\t\ts: \"123-\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 85\",\n\t\t\targs: args{\n\t\t\t\ts: \"123+\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 86\",\n\t\t\targs: args{\n\t\t\t\ts: \"123e\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"e\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 87\",\n\t\t\targs: args{\n\t\t\t\ts: \"123E\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"E\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 88\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \".\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 89\",\n\t\t\targs: args{\n\t\t\t\ts: \"123-\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 90\",\n\t\t\targs: args{\n\t\t\t\ts: \"123+\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 91\",\n\t\t\targs: args{\n\t\t\t\ts: \"123e\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"e\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 92\",\n\t\t\targs: args{\n\t\t\t\ts: \"123E\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"E\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 93\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \".\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 94\",\n\t\t\targs: args{\n\t\t\t\ts: \"123-\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 95\",\n\t\t\targs: args{\n\t\t\t\ts: \"123+\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 96\",\n\t\t\targs: args{\n\t\t\t\ts: \"123e\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"e\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 97\",\n\t\t\targs: args{\n\t\t\t\ts: \"123E\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"E\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 98\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \".\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 99\",\n\t\t\targs: args{\n\t\t\t\ts: \"123-\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 100\",\n\t\t\targs: args{\n\t\t\t\ts: \"123+\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 101\",\n\t\t\targs: args{\n\t\t\t\ts: \"123e\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"e\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 102\",\n\t\t\targs: args{\n\t\t\t\ts: \"123E\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"E\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 103\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \".\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 104\",\n\t\t\targs: args{\n\t\t\t\ts: \"123-\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 105\",\n\t\t\targs: args{\n\t\t\t\ts: \"123+\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 106\",\n\t\t\targs: args{\n\t\t\t\ts: \"123e\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"e\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 107\",\n\t\t\targs: args{\n\t\t\t\ts: \"123E\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"E\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 108\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \".\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 109\",\n\t\t\targs: args{\n\t\t\t\ts: \"123-\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 110\",\n\t\t\targs: args{\n\t\t\t\ts: \"123+\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 111\",\n\t\t\targs: args{\n\t\t\t\ts: \"123e\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"e\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 112\",\n\t\t\targs: args{\n\t\t\t\ts: \"123E\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"E\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 113\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \".\",\n\t\t\twantErr",
    "42a4581e9bcb47c9cae323e224321838": "package fastjson\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\tv   *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"marshal null\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNull},\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal true\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeTrue},\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal false\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeFalse},\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeString, s: \"hello\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal number\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t},\n\t\t\twant: []byte(\"123\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal raw string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: typeRawString, s: \"hello\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal array\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{t: TypeString, s: \"hello\"},\n\t\t\t\t\t\t{t: TypeNumber, s: \"123\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"[\\\"hello\\\",123]\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal object\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{k: \"name\", v: \u0026Value{t: TypeString, s: \"John Doe\"}},\n\t\t\t\t\t\t\t{k: \"age\", v: \u0026Value{t: TypeNumber, s: \"30\"}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`{\"name\":\"John Doe\",\"age\":30}`),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.v.MarshalTo(tt.args.dst); !bytes.Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "4317dd94c9c81cdfc7394fab018fe2c2": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"single digit\",\n\t\t\targs: args{\n\t\t\t\ts: \"1\",\n\t\t\t},\n\t\t\twantNs:  \"1\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple digits\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative number\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"positive number\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with decimal\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with exponent\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with exponent and sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e-4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"inf\",\n\t\t\t},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"INF\",\n\t\t\targs: args{\n\t\t\t\ts: \"INF\",\n\t\t\t},\n\t\t\twantNs:  \"INF\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"nan\",\n\t\t\t},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NAN\",\n\t\t\targs: args{\n\t\t\t\ts: \"NAN\",\n\t\t\t},\n\t\t\twantNs:  \"NAN\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char\",\n\t\t\targs: args{\n\t\t\t\ts: \"123a\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at start\",\n\t\t\targs: args{\n\t\t\t\ts: \"a123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"a123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char after sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"-a123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"-a123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char after sign 2\",\n\t\t\targs: args{\n\t\t\t\ts: \"+a123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+a123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char after inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"inf123\",\n\t\t\t},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"123\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char after nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"nan123\",\n\t\t\t},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"123\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}",
    "438cdd38c430e24205d861b12ce862a1": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\"world\\\\\\\"\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quotes and other characters\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"\\\\\\\\\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\\\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: ``,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with no quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `hello`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "43f05169bea4b18464c3beff0572b019": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantKey string\n\t\twantVal string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twantKey: \"\",\n\t\t\twantVal: \"hello\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twantKey: \"\",\n\t\t\twantVal: `hello\"world`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"!\"`,\n\t\t\t},\n\t\t\twantKey: \"\",\n\t\t\twantVal: `hello\"world\"`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twantKey: \"\",\n\t\t\twantVal: \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: ``,\n\t\t\t},\n\t\t\twantKey: \"\",\n\t\t\twantVal: \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with leading and trailing spaces\",\n\t\t\targs: args{\n\t\t\t\ts: `\" hello \"`,\n\t\t\t},\n\t\t\twantKey: \"\",\n\t\t\twantVal: \" hello \",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotKey, gotVal, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotKey != tt.wantKey {\n\t\t\t\tt.Errorf(\"parseRawString() gotKey = %v, want %v\", gotKey, tt.wantKey)\n\t\t\t}\n\t\t\tif gotVal != tt.wantVal {\n\t\t\t\tt.Errorf(\"parseRawString() gotVal = %v, want %v\", gotVal, tt.wantVal)\n\t\t\t}\n\t\t})\n\t}\n}",
    "446abaebeeef376ebc93226303f531ed": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": {\"key2\": \"value2\"}, \"key3\": \"value3\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid key\",\n\t\t\targs: args{\n\t\t\t\ts:   `{key1: \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{key1: \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_JSON(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": {\"key2\": \"value2\"}, \"key3\": \"value3\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_JSON_Compare(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": {\"key2\": \"value2\"}, \"key3\": \"value3\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tvar want map[string]interface{}\n\t\t\tif err := json.Unmarshal([]byte(tt.args.s), \u0026want); err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got.o.kvs, want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got.o.kvs, want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "45e9f90038c7ac1a7282335fc1180fe8": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_getKV(t *testing.T) {\n\ttype args struct {\n\t\to *Object\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant *kv\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.o.getKV(); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Object.getKV() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "46016ef0a20258ffb65f7446c875b298": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts: \"null\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts: \"true\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts: \"false\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello\\\"\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts: \"[1,2,3]\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts: `{\"key1\": \"value1\", \"key2\": 2}`,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested object\",\n\t\t\targs: args{\n\t\t\t\ts: `{\"key1\": {\"key2\": \"value2\"}}`,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts: `{\"key1\": [1, 2, 3]}`,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid json\",\n\t\t\targs: args{\n\t\t\t\ts: \"{\",\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tp := \u0026Parser{}\n\t\t\tgot, err := p.Parse(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Parse() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr {\n\t\t\t\tif !compareValues(got, tt.want) {\n\t\t\t\t\tt.Errorf(\"Parse() = %v, want %v\", got, tt.want)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeNull:\n\t\treturn true\n\tcase TypeTrue:\n\t\treturn true\n\tcase TypeFalse:\n\t\treturn true\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !compareValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !compareValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc TestParse_InvalidJSON(t *testing.T) {\n\tp := \u0026Parser{}\n\t_, err := p.Parse(\"{\")\n\tif err == nil {\n\t\tt.Errorf(\"Parse() should have returned an error for invalid JSON\")\n\t}\n}\n\nfunc TestParse_UnescapedString(t *testing.T) {\n\tp := \u0026Parser{}\n\ts := `\"hello\\nworld\"`\n\tv, err := p.Parse(s)\n\tif err != nil {\n\t\tt.Errorf(\"Parse() error = %v\", err)\n\t\treturn\n\t}\n\tif v.t != TypeString {\n\t\tt.Errorf(\"Parse() got type %v, want %v\", v.t, TypeString)\n\t}\n\tif v.s != \"hello\\nworld\" {\n\t\tt.Errorf(\"Parse() got string %v, want %v\", v.s, \"hello\\nworld\")\n\t}\n}\n\nfunc TestParse_LargeJSON(t *testing.T) {\n\t// Create a large JSON string with nested objects and arrays\n\tvar largeJSON string\n\tfor i := 0; i \u003c 1000; i++ {\n\t\tlargeJSON += fmt.Sprintf(`{\"key%d\": [\"value%d\", %d, {\"nested_key%d\": \"nested_value%d\"}]}`, i, i, i, i, i)\n\t\tif i \u003c 999 {\n\t\t\tlargeJSON += \",\"\n\t\t}\n\t}\n\tlargeJSON = \"[\" + largeJSON + \"]\"\n\n\t// Parse the large JSON string\n\tp := \u0026Parser{}\n\tv, err := p.Parse(largeJSON)\n\tif err != nil {\n\t\tt.Errorf(\"Parse() error = %v\", err)\n\t\treturn\n\t}\n\n\t// Verify the parsed JSON\n\tif v.t != TypeArray {\n\t\tt.Errorf(\"Parse() got type %v, want %v\", v.t, TypeArray)\n\t}\n\tif len(v.a) != 1000 {\n\t\tt.Errorf(\"Parse() got array length %v, want %v\", len(v.a), 1000)\n\t}\n\n\t// Check the first element of the array\n\tfirstElement := v.a[0]\n\tif firstElement.t != TypeObject {\n\t\tt.Errorf(\"Parse() got first element type %v, want %v\", firstElement.t, TypeObject)\n\t}\n\tif len(firstElement.o.kvs) != 1 {\n\t\tt.Errorf(\"Parse() got first element object length %v, want %v\", len(firstElement.o.kvs), 1)\n\t}\n\tif firstElement.o.kvs[0].k != \"key0\" {\n\t\tt.Errorf(\"Parse() got first element key %v, want %v\", firstElement.o.kvs[0].k, \"key0\")\n\t}\n\tif firstElement.o.kvs[0].v.t != TypeArray {\n\t\tt.Errorf(\"Parse() got first element value type %v, want %v\", firstElement.o.kvs[0].v.t, TypeArray)\n\t}\n\tif len(firstElement.o.kvs[0].v.a) != 3 {\n\t\tt.Errorf(\"Parse() got first element value array length %v, want %v\", len(firstElement.o.kvs[0].v.a), 3)\n\t}\n\tif firstElement.o.kvs[0].v.a[0].t != TypeString {\n\t\tt.Errorf(\"Parse() got first element value array first element type %v, want %v\", firstElement.o.kvs[0].v.a[0].t, TypeString)\n\t}\n\tif firstElement.o.kvs[0].v.a[0].s != \"value0\" {\n\t\tt.Errorf(\"Parse() got first element value array first element string %v, want %v\", firstElement.o.kvs[0].v.a[0].s, \"value0\")\n\t}\n\tif firstElement.o.kvs[0].v.a[1].t != TypeNumber {\n\t\tt.Errorf(\"Parse() got first element value array second element type %v, want %v\", firstElement.o.kvs[0].v.a[1].t, TypeNumber)\n\t}\n\tif firstElement.o.kvs[0].v.a[1].s != \"0\" {\n\t\tt.Errorf(\"Parse() got first element value array second element string %v, want %v\", firstElement.o.kvs[0].v.a[1].s, \"0\")\n\t}\n\tif firstElement.o.kvs[0].v.a[2].t != TypeObject {\n\t\tt.Errorf(\"Parse() got first element value array third element type %v, want %v\", firstElement.o.kvs[0].v.a[2].t, TypeObject)\n\t}\n\tif len(firstElement.o.kvs[0].v.a[2].o.kvs) != 1 {\n\t\tt.Errorf(\"Parse() got first element value array third element object length %v, want %v\", len(firstElement.o.kvs[0].v.a[2].o.kvs), 1)\n\t}\n\tif firstElement.o.kvs[0].v.a[2].o.kvs[0].k != \"nested_key0\" {\n\t\tt.Errorf(\"Parse() got first element value array third element key %v, want %v\", firstElement.o.kvs[0].v.a[2].o.kvs[0].k, \"nested_key0\")\n\t}\n\tif firstElement.o.kvs[0].v.a[2].o.kvs[0].v.t != TypeString {\n\t\tt.Errorf(\"Parse() got first element value array third element value type %v, want %v\", firstElement.o.kvs[0].v.a[2].o.kvs[0].v.t, TypeString)\n\t}\n\tif firstElement.o.kvs[0].v.a[2].o.kvs[0].v.s != \"nested_value0\" {\n\t\tt.Errorf(\"Parse() got first element value array third element value string %v, want %v\", firstElement.o.kvs[0].v.a[2].o.kvs[0].v.s, \"nested_value0\")\n\t}\n}\n\nfunc TestParse_CompareWithStdlib(t *testing.T) {\n\ttests := []string{\n\t\t`{\"key1\": \"value1\", \"key2\": 2}`,\n\t\t`[1, 2, 3]`,\n\t\t`{\"key1\": {\"key2\": \"value2\"}}`,\n\t\t`{\"key1\": [1, 2, 3]}`,\n\t\t`{\"key1\": true, \"key2\": false}`,\n\t\t`{\"key1\": null, \"key2\": 123}`,\n\t}\n\n\tfor _, testJSON := range tests {\n\t\tt.Run(testJSON, func(t *testing.T) {\n\t\t\t// Parse with fastjson\n\t\t\tp := \u0026Parser{}\n\t\t\tfastjsonValue, err := p.Parse(testJSON)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"fastjson.Parse() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Parse with standard library\n\t\t\tvar stdlibValue interface{}\n\t\t\terr = json.Unmarshal([]byte(testJSON), \u0026stdlibValue)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Compare the results\n\t\t\tif !compareFastjsonAndStdlib(fastjsonValue, stdlibValue) {\n\t\t\t\tt.Errorf(\"fastjson.Parse() and json.Unmarshal() results do not match for JSON: %s\", testJSON)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareFastjsonAndStdlib(fastjsonValue *Value, stdlibValue interface{}) bool {\n\tswitch stdlibValue := stdlibValue.(type) {\n\tcase nil:\n\t\treturn fastjsonValue.t == TypeNull\n\tcase bool:\n\t\tif stdlibValue {\n\t\t\treturn fastjsonValue.t == TypeTrue\n\t\t} else {\n\t\t\treturn fastjsonValue.t == TypeFalse\n\t\t}\n\tcase string:\n\t\treturn fastjsonValue.t == TypeString \u0026\u0026 fastjsonValue.s == stdlibValue\n\tcase float64:\n\t\treturn fastjsonValue.t == TypeNumber \u0026\u0026 fastjsonValue.s == fmt.Sprintf(\"%f\", stdlibValue)\n\tcase []interface{}:\n\t\tif fastjsonValue.t != TypeArray || len(fastjsonValue.a) != len(stdlibValue) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range fastjsonValue.a {\n\t\t\tif !compareFastjsonAndStdlib(fastjsonValue.a[i], stdlibValue[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase map[string]interface{}:\n\t\tif fastjsonValue.t != TypeObject || len(fastjsonValue.o.kvs) != len(stdlibValue) {\n\t\t\treturn false\n\t\t}\n\t\tfor k, v := range stdlibValue {\n\t\t\tfound := false\n\t\t\tfor _, kv := range fastjsonValue.o.kvs {\n\t\t\t\tif kv.k == k {\n\t\t\t\t\tfound = true\n\t\t\t\t\tif !compareFastjsonAndStdlib(kv.v, v) {\n\t\t\t\t\t\treturn false\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !found {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}",
    "474587a46759d9c9af305ffe6abc10cf": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_unescapeKeys(t *testing.T) {\n\ttype args struct {\n\t\to *Object\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\ttt.args.o.unescapeKeys()\n\t\t\tif got := tt.args.o.keysUnescaped; got != tt.want {\n\t\t\t\tt.Errorf(\"Object.unescapeKeys() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "4778417afe75368a35b2b6f4f35fc985": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseArray() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "47a7a73c5d932bf8413c1aa7692b5419": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"{}\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: nil,\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"hello\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   \"true\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueTrue,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   \"false\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueFalse,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   \"null\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueNull,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   \"123\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   \"NaN\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseValue() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseValue_JSON(t *testing.T) {\n\ttype testCase struct {\n\t\tjson string\n\t\twant string\n\t}\n\ttestCases := []testCase{\n\t\t{\n\t\t\tjson: `{\"a\": 1, \"b\": \"2\", \"c\": true, \"d\": false, \"e\": null, \"f\": [1, 2, 3], \"g\": {\"h\": 4, \"i\": \"5\"}}`,\n\t\t\twant: `{\"a\":1,\"b\":\"2\",\"c\":true,\"d\":false,\"e\":null,\"f\":[1,2,3],\"g\":{\"h\":4,\"i\":\"5\"}}`,\n\t\t},\n\t\t{\n\t\t\tjson: `[1, 2, 3, \"4\", true, false, null, {\"a\": 5, \"b\": \"6\"}]`,\n\t\t\twant: `[1,2,3,\"4\",true,false,null,{\"a\":5,\"b\":\"6\"}]`,\n\t\t},\n\t\t{\n\t\t\tjson: `123`,\n\t\t\twant: `123`,\n\t\t},\n\t\t{\n\t\t\tjson: `\"hello\"`,\n\t\t\twant: `\"hello\"`,\n\t\t},\n\t\t{\n\t\t\tjson: `true`,\n\t\t\twant: `true`,\n\t\t},\n\t\t{\n\t\t\tjson: `false`,\n\t\t\twant: `false`,\n\t\t},\n\t\t{\n\t\t\tjson: `null`,\n\t\t\twant: `null`,\n\t\t},\n\t\t{\n\t\t\tjson: `NaN`,\n\t\t\twant: `NaN`,\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.json, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tv, _, err := parseValue(tc.json, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"parseValue() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgot, err := json.Marshal(v)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"json.Marshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif string(got) != tc.want {\n\t\t\t\tt.Errorf(\"parseValue() got = %s, want %s\", string(got), tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "47b28de27696c7d835e66559172d7cdc": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\tv   *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"marshal raw string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: typeRawString, s: \"test\"},\n\t\t\t},\n\t\t\twant: []byte(`\"test\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal object\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{t: TypeString, s: \"value\"}}}}},\n\t\t\t},\n\t\t\twant: []byte(`{\"key\":\"value\"}`),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal array\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeArray, a: []*Value{{t: TypeString, s: \"value1\"}, {t: TypeString, s: \"value2\"}}},\n\t\t\t},\n\t\t\twant: []byte(`[\"value1\",\"value2\"]`),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeString, s: \"test\"},\n\t\t\t},\n\t\t\twant: []byte(`\"test\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal number\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t},\n\t\t\twant: []byte(`123`),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal true\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeTrue},\n\t\t\t},\n\t\t\twant: []byte(`true`),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal false\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeFalse},\n\t\t\t},\n\t\t\twant: []byte(`false`),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal null\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNull},\n\t\t\t},\n\t\t\twant: []byte(`null`),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.v.MarshalTo(tt.args.dst); !bytesEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc bytesEqual(a, b []byte) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "482458ac461af40cdb53b92e922369b7": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\"world\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\\\\\\\"\",\n\t\t\twant1:   \"!\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped backslash\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\\world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\\world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: ``,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with no quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `hello`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "48320e961bd2d8c9a3735fa076ff65ef": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestType_String(t *testing.T) {\n\ttype args struct {\n\t\tt Type\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"TestType_String_Object\",\n\t\t\targs: args{t: TypeObject},\n\t\t\twant: \"object\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_Array\",\n\t\t\targs: args{t: TypeArray},\n\t\t\twant: \"array\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_String\",\n\t\t\targs: args{t: TypeString},\n\t\t\twant: \"string\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_Number\",\n\t\t\targs: args{t: TypeNumber},\n\t\t\twant: \"number\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_True\",\n\t\t\targs: args{t: TypeTrue},\n\t\t\twant: \"true\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_False\",\n\t\t\targs: args{t: TypeFalse},\n\t\t\twant: \"false\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_Null\",\n\t\t\targs: args{t: TypeNull},\n\t\t\twant: \"null\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.t.String(); got != tt.want {\n\t\t\t\tt.Errorf(\"Type.String() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "48615e4e0f80b59be18ffb71c44492a6": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"{}\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\": \"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"value1\", \"value2\"]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"value\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"value\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   `true`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueTrue,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   `false`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueFalse,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   `null`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueNull,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with decimal\",\n\t\t\targs: args{\n\t\t\t\ts:   `123.456`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e+4`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e-4`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"1.23e-4\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `-123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative sign and decimal\",\n\t\t\targs: args{\n\t\t\t\ts:   `-123.456`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-123.456\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative sign and exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `-1.23e+4`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-1.23e+4\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative sign and negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `-1.23e-4`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-1.23e-4\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   `NaN`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected value\",\n\t\t\targs: args{\n\t\t\t\ts:   `abc`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `abc`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseValue() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseValue_JSON(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   `null`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `null`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   `true`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `true`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   `false`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `false`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `123`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with decimal\",\n\t\t\targs: args{\n\t\t\t\ts:   `123.456`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `123.456`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e+4`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `1.23e+4`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e-4`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `1.23e-4`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `-123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `-123`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative sign and decimal\",\n\t\t\targs: args{\n\t\t\t\ts:   `-123.456`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `-123.456`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative sign and exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `-1.23e+4`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `-1.23e+4`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative sign and negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `-1.23e-4`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `-1.23e-4`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"value\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `\"value\"`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\": \"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `{\"key\":\"value\"}`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"value1\", \"value2\"]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `[\"value1\",\"value2\"]`,\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err == nil {\n\t\t\t\tb, err := json.Marshal(got)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"parseValue() error = %v\", err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif string(b) != tt.want {\n\t\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", string(b), tt.want)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}",
    "487b4d87b952e68219b21d44a1371cea": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"single element array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"hello\"]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt:  TypeString,\n\t\t\t\t\t\ts: \"hello\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"hello\", \"world\", 123]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt:  TypeString,\n\t\t\t\t\t\ts: \"hello\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt:  TypeString,\n\t\t\t\t\t\ts: \"world\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt:  TypeNumber,\n\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[[\"hello\", \"world\"], 123]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt:  TypeString,\n\t\t\t\t\t\t\t\ts: \"hello\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt:  TypeString,\n\t\t\t\t\t\t\t\ts: \"world\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt:  TypeNumber,\n\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:   `[1, 2, 3`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `[1, 2, 3`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:   `[1 2, 3]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `[1 2, 3]`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseArray() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "48c9e62e37da97e070e59a6c5e30e526": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_parseObject_with_escaped_chars(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped value\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value\\\\\\\"1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\\\"1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key and value\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value\\\\\\\"1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\\\"1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_parseObject_with_unicode_chars(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"object with unicode key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\u00e91\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key√©1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with unicode value\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value\\u00e91\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value√©1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with unicode key and value\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\u00e91\": \"value\\u00e91\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key√©1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value√©1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_parseObject_with_invalid_json(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"object with invalid key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\", \"key3\": \"value3`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": \"value2\", \"key3\": \"value3`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with invalid value\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\", \"key3\": value3}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": \"value2\", \"key3\": value3}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with invalid json\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\", \"key3\": \"value3\"`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": \"value2\", \"key3\": \"value3\"`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_parseObject_with_large_object(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"large object\",\n\t\t\targs: args{\n\t\t\t\ts:    generateLargeJSONObject(1000),\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc generateLargeJSONObject(numKeys int) string {\n\tvar obj map[string]interface{}\n\tobj = make(map[string]interface{})\n\tfor i := 0; i \u003c numKeys; i++ {\n\t\tobj[fmt.Sprintf(\"key%d\", i)] = fmt.Sprintf(\"value%d\", i)\n\t}\n\tjsonBytes, _ := json.Marshal(obj)\n\treturn string(jsonBytes)\n}",
    "48d318ea87ed8fe26689b887bc8fd3c8": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no whitespace\",\n\t\t\targs: args{s: \"hello\"},\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace\",\n\t\t\targs: args{s: \"  hello\"},\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailing whitespace\",\n\t\t\targs: args{s: \"hello  \"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"whitespace in the middle\",\n\t\t\targs: args{s: \"hello  world\"},\n\t\t\twant: \"world\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple whitespace\",\n\t\t\targs: args{s: \"  hello  world  \"},\n\t\t\twant: \"world\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading and trailing whitespace\",\n\t\t\targs: args{s: \"  hello  world  \"},\n\t\t\twant: \"world\",\n\t\t},\n\t\t{\n\t\t\tname: \"all whitespace\",\n\t\t\targs: args{s: \"  \"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"mixed whitespace\",\n\t\t\targs: args{s: \" \\t\\n\\rhello\\t\\n\\r \"},\n\t\t\twant: \"hello\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "49c1fd950447c90d34f273d87ba7c002": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": {\"nested_key1\": \"nested_value1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nested_key1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nested_value1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_Unmarshal(t *testing.T) {\n\ttype testObject struct {\n\t\tKey1 string `json:\"key1\"`\n\t\tKey2 string `json:\"key2\"`\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\tjsonStr string\n\t\twant    testObject\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"simple object\",\n\t\t\tjsonStr: `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\twant: testObject{\n\t\t\t\tKey1: \"value1\",\n\t\t\t\tKey2: \"value2\",\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"object with nested object\",\n\t\t\tjsonStr: `{\"key1\": {\"nested_key1\": \"nested_value1\"}, \"key2\": \"value2\"}`,\n\t\t\twant: testObject{\n\t\t\t\tKey1: `{\"nested_key1\": \"nested_value1\"}`,\n\t\t\t\tKey2: \"value2\",\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"object with escaped key\",\n\t\t\tjsonStr: `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\twant: testObject{\n\t\t\t\tKey1: \"value1\",\n\t\t\t\tKey2: \"\",\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tv, _, err := parseObject(tt.jsonStr, c, 0)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif tt.wantErr {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgot := testObject{}\n\t\t\terr = json.Unmarshal(v.MarshalTo(nil), \u0026got)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "4b129ab98d5c4c731411a79d4a5f508e": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no whitespace\",\n\t\t\targs: args{s: \"abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace\",\n\t\t\targs: args{s: \"  abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailing whitespace\",\n\t\t\targs: args{s: \"abc  \"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"whitespace in the middle\",\n\t\t\targs: args{s: \"a bc\"},\n\t\t\twant: \"bc\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple whitespace\",\n\t\t\targs: args{s: \"  a  b  c  \"},\n\t\t\twant: \"b  c  \",\n\t\t},\n\t\t{\n\t\t\tname: \"all whitespace\",\n\t\t\targs: args{s: \"   \"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"mixed whitespace\",\n\t\t\targs: args{s: \"\\t\\n abc \\r\\n\"},\n\t\t\twant: \"abc \\r\\n\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "4b87cd4d52570dab9666b264f36b07db": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestType_String(t *testing.T) {\n\ttype args struct {\n\t\tt Type\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"TestType_String_Object\",\n\t\t\targs: args{t: TypeObject},\n\t\t\twant: \"object\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_Array\",\n\t\t\targs: args{t: TypeArray},\n\t\t\twant: \"array\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_String\",\n\t\t\targs: args{t: TypeString},\n\t\t\twant: \"string\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_Number\",\n\t\t\targs: args{t: TypeNumber},\n\t\t\twant: \"number\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_True\",\n\t\t\targs: args{t: TypeTrue},\n\t\t\twant: \"true\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_False\",\n\t\t\targs: args{t: TypeFalse},\n\t\t\twant: \"false\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_Null\",\n\t\t\targs: args{t: TypeNull},\n\t\t\twant: \"null\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.t.String(); got != tt.want {\n\t\t\t\tt.Errorf(\"Type.String() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "4bfd353ce394104c3e5e7330f2d8c37e": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\\\\\\\"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"\\\\\\\\\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\\\\\\\"\\\\\\\\\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: ``,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with no quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `hello`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "4cdd623a302712e4419ad2c3a2c97876": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escaped strings\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"test\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\\\\\\\"test\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: ``,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with no quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `hello`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "4d0122a553f10d32bc49513bf0d9a989": "package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u006\"},\n\t\t\twant: \"\\\\u0061\\\\u006\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\\\\\ \\\\/\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\x\\\\u006\"},\n\t\t\twant: \"\\\"hello\\\" \\\\world\\\\ /\\\\b\\\\f\\\\n\\\\r\\\\tabcüòÅ\\\\x\\\\u006\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "4f4491cb7c5cc7f58615a05c592dd536": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth + 1,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"{}\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\": \"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"value1\", \"value2\"]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"value\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"value\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   `true`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueTrue,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   `false`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueFalse,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   `null`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueNull,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with decimal\",\n\t\t\targs: args{\n\t\t\t\ts:   `123.456`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e+4`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e-4`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"1.23e-4\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `-123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with positive sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `+123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"+123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zeros\",\n\t\t\targs: args{\n\t\t\t\ts:   `00123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"00123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with trailing zeros\",\n\t\t\targs: args{\n\t\t\t\ts:   `123.00`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123.00\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   `NaN`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with Infinity\",\n\t\t\targs: args{\n\t\t\t\ts:   `Infinity`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"Infinity\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseValue() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseValue_JSON(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth + 1,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\": \"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `{\"key\":\"value\"}`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"value1\", \"value2\"]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `[\"value1\",\"value2\"]`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"value\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `\"value\"`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   `true`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `true`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   `false`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `false`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   `null`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `null`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `123`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with decimal\",\n\t\t\targs: args{\n\t\t\t\ts:   `123.456`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `123.456`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e+4`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `1.23e+4`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e-4`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `1.23e-4`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `-123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `-123`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with positive sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `+123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `+123`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zeros\",\n\t\t\targs: args{\n\t\t\t\ts:   `00123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `00123`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with trailing zeros\",\n\t\t\targs: args{\n\t\t\t\ts:   `123.00`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `123.00`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   `NaN`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `NaN`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with Infinity\",\n\t\t\targs: args{\n\t\t\t\ts:   `Infinity`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err == nil {\n\t\t\t\tb, err := json.Marshal(got)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"json.Marshal() error = %v\", err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif string(b) != tt.want {\n\t\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", string(b), tt.want)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}",
    "4fc89e3a630b8e550765596372d584cd": "package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u006\"},\n\t\t\twant: \"\\\\u0061\\\\u006\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\\\\\ \\\\/\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\x\\\\u006\"},\n\t\t\twant: \"\\\"hello\\\" \\\\world\\\\ /\\\\b\\\\f\\\\n\\\\r\\tabcüòÅ\\\\x\\\\u006\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "503f3922e45e669920f6725150e5602b": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts: \"null\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts: \"true\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts: \"false\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello\\\"\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts: \"[1,2,3]\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts: `{\"key1\": \"value1\", \"key2\": 2}`,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested object\",\n\t\t\targs: args{\n\t\t\t\ts: `{\"key1\": {\"key2\": \"value2\"}}`,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts: `{\"key1\": [1, 2, 3]}`,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tp := \u0026Parser{}\n\t\t\tgot, err := p.Parse(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Parse() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr {\n\t\t\t\tif !compareValues(got, tt.want) {\n\t\t\t\t\tt.Errorf(\"Parse() = %v, want %v\", got, tt.want)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeNull:\n\t\treturn true\n\tcase TypeTrue:\n\t\treturn true\n\tcase TypeFalse:\n\t\treturn true\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !compareValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !compareValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}",
    "507ed88071a072bb161e39e02811a740": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no whitespace\",\n\t\t\targs: args{s: \"abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace\",\n\t\t\targs: args{s: \"  abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailing whitespace\",\n\t\t\targs: args{s: \"abc  \"},\n\t\t\twant: \"abc  \",\n\t\t},\n\t\t{\n\t\t\tname: \"leading and trailing whitespace\",\n\t\t\targs: args{s: \"  abc  \"},\n\t\t\twant: \"abc  \",\n\t\t},\n\t\t{\n\t\t\tname: \"whitespace in the middle\",\n\t\t\targs: args{s: \"a bc\"},\n\t\t\twant: \"bc\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple whitespace\",\n\t\t\targs: args{s: \"  a  b  c  \"},\n\t\t\twant: \"a  b  c  \",\n\t\t},\n\t\t{\n\t\t\tname: \"newline\",\n\t\t\targs: args{s: \"\\n abc\"},\n\t\t\twant: \" abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"carriage return\",\n\t\t\targs: args{s: \"\\r abc\"},\n\t\t\twant: \" abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"tab\",\n\t\t\targs: args{s: \"\\t abc\"},\n\t\t\twant: \" abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"mixed whitespace\",\n\t\t\targs: args{s: \"\\n\\t\\r abc\"},\n\t\t\twant: \" abc\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "51623eafceb80d06c6bf0fcefe4a047b": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"single element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,3]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[[1,2],[3,4]]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"4\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with whitespace\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[ 1 , 2 , 3 ]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,3\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1,2,3\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1 2,3]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1 2,3]\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseArray() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "51deb49920dfc6e510077a17df92cc0a": "```go\npackage fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttype want struct {\n\t\tv   *Value\n\t\ttail string\n\t\terr  error\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant want\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  fmt.Errorf(\"cannot parse empty string\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"{}\",\n\t\t\t\terr:  fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\": \"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"value1\", \"value2\"]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:",
    "51eb580ec9a46535500e7d56e243aafa": "```go\npackage fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u world\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00zz\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00zz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 2\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00z\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00z\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 3\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 4\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 5\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 6\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 7\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u006\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u006\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 8\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064\"},\n\t\t\twant: \"abcd\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 9\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00645\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00645\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 10\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u006456\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u006456\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 11\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064567\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064567\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 12\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00645678\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00645678\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 13\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u006456789\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u006456789\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 14\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064567890\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064567890\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 15\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00645678901\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00645678901\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 16\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u006456789012\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u006456789012\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 17\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064567890123\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064567890123\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 18\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00645678901234\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00645678901234\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 19\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u006456789012345\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u006456789012345\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 20\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064567890123456\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064567890123456\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 21\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00645678901234567\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00645678901234567\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 22\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u006456789012345678\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u006456789012345678\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 23\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064567890123456789\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064567890123456789\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 24\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00645678901234567890\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00645678901234567890\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 25\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u006456789012345678901\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u006456789012345678901\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 26\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064567890123456789012\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064567890123456789012\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 27\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00645678901234567890123\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00645678901234567890123\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 28\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u006456789012345678901234\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u006456789012345678901234\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 29\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064567890123456789012345\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064567890123456789012345\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 30\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00645678901234567890123456\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00645678901234567890123456\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 31\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u006456789012345678901234567\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u006456789012345678901234567\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 32\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064567890123456789012345678\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064567890123456789012345678\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 33\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00645678901234567890123456789\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00645678901234567890123456789\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 34\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u006456789012345678901234567890\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u006456789012345678901234567890\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 35\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064567890123456789012345678901\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064567890123456789012345678901\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 36\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00645678901234567890123456789012\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00645678901234567890123456789012\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 37\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u006456789012345678901234567890123\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u006456789012345678901234567890123\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 38\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064567890123456789012345678901234\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064567890123456789012345678901234\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 39\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00645678901234567890123456789012345\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00645678901234567890123456789012345\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 40\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u006456789012345678901234567890123456\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u006456789012345678901234567890123456\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 41\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064567890123456789012345678901234567\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064567890123456789012345678901234567\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 42\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00645678901234567890123456789012345678\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00645678901234567890123456789012345678\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 43\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u006456789012345678901234567890123456789\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u006456789012345678901234567890123456789\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 44\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064567890123456789012345678901234567890\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064567890123456789012345678901234567890\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 45\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00645678901234567890123456789012345678901\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00645678901234567890123456789012345678901\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 46\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u006456789012345678901234567890123456789012\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u006456789012345678901234567890123456789012\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 47\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064567890123456789012345678901234567890123\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064567890123456789012345678901234567890123\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 48\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00645678901234567890123456789012345678901234\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00645678901234567890123456789012345678901234\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 49\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u006456789012345678901234567890123456789012345\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u006456789012345678901234567890123456789012345\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 50\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064567890123456789012345678901234567890123456\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064567890123456789012345678901234567890123456\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 51\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00645678901234567890123456789012345678901234567\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00645678901234567890123456789012345678901234567\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 52\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u006456789012345678901234567890123456789012345678\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u006456789012345678901234567890123456789012345678\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 53\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064567890123456789012345678901234567890123456789\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064567890123456789012345678901234567890123456789\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 54\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00645678901234567890123456789012345678901234567890\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00645678901234567890123456789012345678901234567890\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 55\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u006456789012345678901234567890123456789012345678901\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u006456789012345678901234567890123456789012345678901\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 56\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064567890123456789012345678901234567890123456789012\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064567890123456789012345678901234567890123456789012\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 57\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00645678901234567890123456789012345678901234567890123\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00645678901234567890123456789012345678901234567890123\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 58\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u006456789012345678901234567890123456789012345678901234\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u006456789012345678901234567890123456789012345678901234\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 59\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064567890123456789012345678901234567890123456789012345\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064567890123456789012345678901234567890123456789012345\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 60\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00645678901234567890123456789012345678901234567890123456\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00645678901234",
    "5247ae134bd05d190a83b85d60a407ce": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth + 1,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"{}\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\": \"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"value1\", \"value2\"]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"value\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"value\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   `true`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueTrue,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   `false`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueFalse,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   `null`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueNull,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   `NaN`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseValue() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseValue_JSONUnmarshal(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    interface{}\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts: `{\"key\": \"value\"}`,\n\t\t\t},\n\t\t\twant:    map[string]interface{}{\"key\": \"value\"},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts: `[\"value1\", \"value2\"]`,\n\t\t\t},\n\t\t\twant:    []interface{}{\"value1\", \"value2\"},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"value\"`,\n\t\t\t},\n\t\t\twant:    \"value\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts: `true`,\n\t\t\t},\n\t\t\twant:    true,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts: `false`,\n\t\t\t},\n\t\t\twant:    false,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts: `null`,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts: `123`,\n\t\t\t},\n\t\t\twant:    123,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts: `NaN`,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tv, _, err := parseValue(tt.args.s, c, 0)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif tt.wantErr {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tvar got interface{}\n\t\t\tif err := json.Unmarshal(v.MarshalTo(nil), \u0026got); err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "526d23c85d09e89c801d9123b00e9a9b": "package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u006\"},\n\t\t\twant: \"\\\\u0061\\\\u006\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\\\\\ \\\\/\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\x\\\\u006\"},\n\t\t\twant: \"\\\"hello\\\" \\\\world\\\\ /\\\\b\\\\f\\\\n\\\\r\\\\tabcüòÅ\\\\x\\\\u006\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "528a2d825a6aee6a7ac7a372fbecd8b5": "package fastjson\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\tv   *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNull},\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeTrue},\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeFalse},\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeString, s: \"hello\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: typeRawString, s: \"hello\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t},\n\t\t\twant: []byte(\"123\"),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeArray, a: []*Value{{t: TypeString, s: \"hello\"}, {t: TypeNumber, s: \"123\"}}},\n\t\t\t},\n\t\t\twant: []byte(\"[\\\"hello\\\",123]\"),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}}, {k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}}}}},\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":\"value1\",\"key2\":123}`),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.v.MarshalTo(tt.args.dst); !bytes.Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "52b69c67d9b989e8d08cb882093db87e": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueGet(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttype want struct {\n\t\twant *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant want\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.Get(tt.args.keys...); !reflect.DeepEqual(got, tt.want.want) {\n\t\t\t\tt.Errorf(\"Value.Get() = %v, want %v\", got, tt.want.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "52d2cdb7fd59ff3333585b77492b3dac": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nested_key1\": \"nested_value1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nested_key1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nested_value1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\" \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   ` \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with unexpected end\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   ``,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_JSON(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nested_key1\": \"nested_value1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nested_key1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nested_value1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != \"\" {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, \"\")\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_JSON_Compare(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nested_key1\": \"nested_value1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tvar want map[string]interface{}\n\t\t\tif err := json.Unmarshal([]byte(tt.args.s), \u0026want); err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got.o.kvs, want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got.o.kvs, want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "52f0859c0121dc670dfa3c6394572777": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestString(t *testing.T) {\n\ttype args struct {\n\t\tt Type\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"TestString_Object\",\n\t\t\targs: args{t: TypeObject},\n\t\t\twant: \"object\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestString_Array\",\n\t\t\targs: args{t: TypeArray},\n\t\t\twant: \"array\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestString_String\",\n\t\t\targs: args{t: TypeString},\n\t\t\twant: \"string\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestString_Number\",\n\t\t\targs: args{t: TypeNumber},\n\t\t\twant: \"number\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestString_True\",\n\t\t\targs: args{t: TypeTrue},\n\t\t\twant: \"true\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestString_False\",\n\t\t\targs: args{t: TypeFalse},\n\t\t\twant: \"false\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestString_Null\",\n\t\t\targs: args{t: TypeNull},\n\t\t\twant: \"null\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.t.String(); got != tt.want {\n\t\t\t\tt.Errorf(\"String() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "53998db868a67109c659274b129aa427": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantV   *Value\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"single element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,3]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[[1,2],[3,4]]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"4\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV:   nil,\n\t\t\twantS:   \"[1,2\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1 2]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV:   nil,\n\t\t\twantS:   \"[1 2]\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid array value\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,a]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV:   nil,\n\t\t\twantS:   \"[1,2,a]\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotV, gotS, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(gotV, tt.wantV) {\n\t\t\t\tt.Errorf(\"parseArray() gotV = %v, wantV %v\", gotV, tt.wantV)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseArray() gotS = %v, wantS %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}",
    "53b23725d802bd896fea42c9c410de4c": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth + 1,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"{}\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\": \"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"value1\", \"value2\"]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"value\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"value\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   `true`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueTrue,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   `false`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueFalse,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   `null`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueNull,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with decimal\",\n\t\t\targs: args{\n\t\t\t\ts:   `123.456`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e+4`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e-4`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"1.23e-4\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `-123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with positive sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `+123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"+123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zero\",\n\t\t\targs: args{\n\t\t\t\ts:   `0123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"0123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with trailing zero\",\n\t\t\targs: args{\n\t\t\t\ts:   `123.0`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123.0\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   `NaN`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with Infinity\",\n\t\t\targs: args{\n\t\t\t\ts:   `Infinity`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"Infinity\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative Infinity\",\n\t\t\targs: args{\n\t\t\t\ts:   `-Infinity`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-Infinity\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseValue() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseValue_JSON(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\": \"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `{\"key\":\"value\"}`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"value1\", \"value2\"]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `[\"value1\",\"value2\"]`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"value\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `\"value\"`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   `true`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `true`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   `false`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `false`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   `null`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `null`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `123`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with decimal\",\n\t\t\targs: args{\n\t\t\t\ts:   `123.456`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `123.456`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e+4`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `1.23e+4`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e-4`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `1.23e-4`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `-123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `-123`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with positive sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `+123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `+123`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zero\",\n\t\t\targs: args{\n\t\t\t\ts:   `0123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `0123`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with trailing zero\",\n\t\t\targs: args{\n\t\t\t\ts:   `123.0`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `123.0`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   `NaN`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `NaN`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with Infinity\",\n\t\t\targs: args{\n\t\t\t\ts:   `Infinity`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `Infinity`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative Infinity\",\n\t\t\targs: args{\n\t\t\t\ts:   `-Infinity`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `-Infinity`,\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err == nil {\n\t\t\t\tb, err := json.Marshal(got)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"json.Marshal() error = %v\", err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif string(b) != tt.want {\n\t\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", string(b), tt.want)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}",
    "54d21dbd2f396078b3efb6b6942aa1c4": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped string with multiple escapes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\"\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"\\\\\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\\\\\\\"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote and other escapes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"\\\\\\\\\\\\\"\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\\\\\\\"\\\\\\\\\\\\\\\"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: ``,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with no quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `hello`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "55ab33cd70885a9d7bec39d7c6952a4f": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttype want struct {\n\t\tv   *Value\n\t\ttail string\n\t\terr  error\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant want\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  fmt.Errorf(\"cannot parse empty string\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"{}\",\n\t\t\t\terr:  fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\": \"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"value1\", \"value2\"]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"value\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeString,\n\t\t\t\t\ts: \"value\",\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   `true`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueTrue,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   `false`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueFalse,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   `null`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueNull,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"123\",\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   `NaN`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"NaN\",\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"invalid value\",\n\t\t\targs: args{\n\t\t\t\ts:   `invalid`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: `invalid`,\n\t\t\t\terr:  fmt.Errorf(\"unexpected value found: %q\", \"invalid\"),\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotV, gotTail, gotErr := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (gotErr == nil) != (tt.want.err == nil) {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", gotErr, tt.want.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotErr != nil \u0026\u0026 tt.want.err != nil {\n\t\t\t\tif gotErr.Error() != tt.want.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", gotErr, tt.want.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(gotV, tt.want.v) {\n\t\t\t\tt.Errorf(\"parseValue() gotV = %v, want %v\", gotV, tt.want.v)\n\t\t\t}\n\t\t\tif gotTail != tt.want.tail {\n\t\t\t\tt.Errorf(\"parseValue() gotTail = %v, want %v\", gotTail, tt.want.tail)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseValue_JSONMarshal(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\": \"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: `{\"key\":\"value\"}`,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"value1\", \"value2\"]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: `[\"value1\",\"value2\"]`,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"value\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: `\"value\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   `true`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: `true`,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   `false`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: `false`,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   `null`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: `null`,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: `123`,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   `NaN`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: `NaN`,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotV, _, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"parseValue() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgot, err := json.Marshal(gotV)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"json.Marshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif string(got) != tt.want {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", string(got), tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "55ae7eb91da475c49df165ec95632208": "package fastjson\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\tv   *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNull},\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeTrue},\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeFalse},\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeString, s: \"hello\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: typeRawString, s: \"hello\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t},\n\t\t\twant: []byte(\"123\"),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{t: TypeString, s: \"hello\"},\n\t\t\t\t\t\t{t: TypeNumber, s: \"123\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"[\\\"hello\\\",123]\"),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":\"value1\",\"key2\":123}`),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.v.MarshalTo(tt.args.dst); !bytes.Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "55c709ffad8143534ddeaf41a1e7bd19": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"simple integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"float\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential notation\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative exponential notation\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e-4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"inf\",\n\t\t\t},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"nan\",\n\t\t\t},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123a\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and trailing character\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+123a\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and trailing character\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and trailing character\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+123a\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and trailing character\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and trailing character\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+123a\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and trailing character\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and trailing character\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+123a\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and trailing character\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}",
    "567dc1a07a611eae451a61af6d9ce469": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCacheGetValue(t *testing.T) {\n\tt.Run(\"EmptyCache\", func(t *testing.T) {\n\t\tc := \u0026cache{}\n\t\tv := c.getValue()\n\t\tif v == nil {\n\t\t\tt.Error(\"getValue() returned nil for empty cache\")\n\t\t}\n\t})\n\n\tt.Run(\"NonEmptyCache\", func(t *testing.T) {\n\t\tc := \u0026cache{vs: []Value{{t: TypeNull}}}\n\t\tv := c.getValue()\n\t\tif v == nil {\n\t\t\tt.Error(\"getValue() returned nil for non-empty cache\")\n\t\t}\n\t\tif v.t != TypeNull {\n\t\t\tt.Errorf(\"getValue() returned incorrect value type: got %v, want %v\", v.t, TypeNull)\n\t\t}\n\t})\n}",
    "569adecc916ae3f07b25462da44a89f4": "package fastjson\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\tv   *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNull},\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeTrue},\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeFalse},\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeString, s: \"hello\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: typeRawString, s: \"hello\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t},\n\t\t\twant: []byte(\"123\"),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{t: TypeString, s: \"hello\"},\n\t\t\t\t\t\t{t: TypeNumber, s: \"123\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`[\"hello\",123]`),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{k: \"name\", v: \u0026Value{t: TypeString, s: \"John Doe\"}},\n\t\t\t\t\t\t\t{k: \"age\", v: \u0026Value{t: TypeNumber, s: \"30\"}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`{\"name\":\"John Doe\",\"age\":30}`),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.v.MarshalTo(tt.args.dst); !bytes.Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "569ceb1896d923fc26f5c3de368f3449": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no whitespace\",\n\t\t\targs: args{s: \"abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace\",\n\t\t\targs: args{s: \"  abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailing whitespace\",\n\t\t\targs: args{s: \"abc  \"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"whitespace in the middle\",\n\t\t\targs: args{s: \"a bc\"},\n\t\t\twant: \"bc\",\n\t\t},\n\t\t{\n\t\t\tname: \"all whitespace\",\n\t\t\targs: args{s: \"   \"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"mixed whitespace\",\n\t\t\targs: args{s: \" \\t\\n\\r abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading and trailing whitespace\",\n\t\t\targs: args{s: \"  abc  \"},\n\t\t\twant: \"abc\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "56d6cf5f0d301863de996118db5b3f31": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\\\\\\\"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"\\\\\\\\\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\\\\\\\"\\\\\\\\\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: ``,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with leading and trailing spaces\",\n\t\t\targs: args{\n\t\t\t\ts: ` \"hello\" `,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \" \",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "5839b963b0f00d47ba1ea71416983cae": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts: \"null\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts: \"true\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts: \"false\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello\\\"\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts: \"[1,2,3]\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts: `{\"key1\": \"value1\", \"key2\": 2}`,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tp := \u0026Parser{}\n\t\t\tgot, err := p.Parse(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Parse() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr \u0026\u0026 !compareValue(got, tt.want) {\n\t\t\t\tt.Errorf(\"Parse() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValue(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeNull:\n\t\treturn true\n\tcase TypeTrue:\n\t\treturn true\n\tcase TypeFalse:\n\t\treturn true\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !compareValue(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !compareValue(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}",
    "5871d8de5bda10f9c2f0957142902f82": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"{}\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\": \"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"value1\", \"value2\"]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"value\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"value\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   `true`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueTrue,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   `false`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueFalse,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   `null`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueNull,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   `NaN`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseValue() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseValue_JSONMarshal(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\": \"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `{\"key\":\"value\"}`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"value1\", \"value2\"]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `[\"value1\",\"value2\"]`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"value\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `\"value\"`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   `true`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `true`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   `false`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `false`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   `null`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `null`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `123`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   `NaN`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `NaN`,\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tb, err := json.Marshal(got)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"json.Marshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif string(b) != tt.want {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", string(b), tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "58c7405e774342bc9822664969457783": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quotes and other escapes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"\\\\\\\\\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\\\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with extra closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   `\"`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: ``,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with no quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `hello`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "58c88278ce1d66a2a2e9a8ffad165b22": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_JSON(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_JSON_Compare(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tvar want map[string]interface{}\n\t\t\tif err := json.Unmarshal([]byte(tt.args.s), \u0026want); err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got.o.kvs, want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got.o.kvs, want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "5918e72973e48fabd54b0b57cef2017c": "```go\npackage fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 2\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\ux\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\ux\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 3\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 4\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 5\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 6\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 7\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 8\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 9\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 10\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 11\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 12\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 13\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 14\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 15\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 16\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 17\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 18\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 19\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 20\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 21\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 22\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 23\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 24\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 25\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 26\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 27\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 28\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 29\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 30\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 31\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 32\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789012\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789012\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 33\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890123\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890123\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 34\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901234\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901234\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 35\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789012345\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789012345\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 36\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890123456\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890123456\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 37\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901234567\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901234567\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 38\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789012345678\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789012345678\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 39\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890123456789\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890123456789\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 40\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901234567890\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901234567890\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 41\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789012345678901\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789012345678901\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 42\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890123456789012\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890123456789012\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 43\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901234567890123\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901234567890123\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 44\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789012345678901234\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789012345678901234\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 45\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890123456789012345\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890123456789012345\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 46\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901234567890123456\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901234567890123456\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 47\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789012345678901234567\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789012345678901234567\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 48\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890123456789012345678\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890123456789012345678\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 49\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901234567890123456789\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901234567890123456789\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 50\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789012345678901234567890\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789012345678901234567890\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 51\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890123456789012345678901\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890123456789012345678901\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 52\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901234567890123456789012\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901234567890123456789012\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 53\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789012345678901234567890123\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789012345678901234567890123\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 54\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890123456789012345678901234\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890123456789012345678901234\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 55\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901234567890123456789012345\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901234567890123456789012345\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 56\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789012345678901234567890123456\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789012345678901234567890123456\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 57\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890123456789012345678901234567\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890123456789012345678901234567\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 58\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901234567890123456789012345678\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901234567890123456789012345678\",\n\t\t},\n\t\t",
    "59947fc5320ff2dac77bc86ecff32065": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escaped strings\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\"`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped backslash\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\\\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped backslash and quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\\\\\\\"\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "59b8e71ef0b4aca2099db261e7678633": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_InvalidJSON(t *testing.T) {\n\ttests := []string{\n\t\t\"{\",\n\t\t\"}\",\n\t\t\"{\\\"key1\\\":\",\n\t\t\"{\\\"key1\\\": value1}\",\n\t\t\"{\\\"key1\\\": \\\"value1\\\",\",\n\t\t\"{\\\"key1\\\": \\\"value1\\\", \\\"key2\\\":\",\n\t}\n\tfor _, s := range tests {\n\t\tt.Run(s, func(t *testing.T) {\n\t\t\t_, _, err := parseObject(s, \u0026cache{}, 0)\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"parseObject() should have returned an error for invalid JSON: %s\", s)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_CompareWithJSONDecoder(t *testing.T) {\n\ttests := []string{\n\t\t`{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t`{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t`{\"key\\\\\\\"1\": \"value1\"}`,\n\t}\n\tfor _, s := range tests {\n\t\tt.Run(s, func(t *testing.T) {\n\t\t\tvar want map[string]interface{}\n\t\t\tif err := json.Unmarshal([]byte(s), \u0026want); err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgot, _, err := parseObject(s, \u0026cache{}, 0)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"parseObject() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got.o.ToMap(), want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got.o.ToMap(), want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "5babdb3951265dc321e891198b96edd4": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestHasSpecialChars(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with double quote\",\n\t\t\targs: args{s: \"hello\\\"world\"},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with backslash\",\n\t\t\targs: args{s: \"hello\\\\world\"},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with control character\",\n\t\t\targs: args{s: \"hello\\x01world\"},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with no special characters\",\n\t\t\targs: args{s: \"helloworld\"},\n\t\t\twant: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := hasSpecialChars(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"hasSpecialChars() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "5cd64ad2aa4560244f16feafbdcdc631": "```go\npackage fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_JSON(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_JSON_Unmarshal(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    map[string]interface{}\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    map[string]interface{}{},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    map[string]interface{}{\"key1\": \"value1\", \"key2\": \"value2\"},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    map[string]interface{}{\"key1\": map[string]interface{}{\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    map[string]interface{}{\"key\\\"1\": \"value1\"},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr",
    "5d423fabd7fd94b752240bfb62492b92": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetArray(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant []*Value\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.GetArray(tt.args.keys...); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"GetArray() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "5d50de60db0396b2d0bd0253f72fb162": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"{}\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\": \"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"value1\", \"value2\"]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"value\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"value\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   `true`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueTrue,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   `false`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueFalse,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   `null`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueNull,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with decimal\",\n\t\t\targs: args{\n\t\t\t\ts:   `123.456`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e+4`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   `NaN`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseValue() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseValue_Invalid(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"invalid object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid true\",\n\t\t\targs: args{\n\t\t\t\ts:   `tru`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid false\",\n\t\t\targs: args{\n\t\t\t\ts:   `fals`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid null\",\n\t\t\targs: args{\n\t\t\t\ts:   `nul`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123.`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t_, _, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseValue_Marshal(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\": \"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `{\"key\":\"value\"}`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"value1\", \"value2\"]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `[\"value1\",\"value2\"]`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"value\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `\"value\"`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   `true`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `true`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   `false`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `false`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   `null`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `null`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `123`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with decimal\",\n\t\t\targs: args{\n\t\t\t\ts:   `123.456`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `123.456`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e+4`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `1.23e+4`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   `NaN`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `NaN`,\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tb, err := json.Marshal(got)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"json.Marshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif string(b) != tt.want {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", string(b), tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "5d9ba318f485a038f98ce79add0f925e": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"single digit\",\n\t\t\targs: args{\n\t\t\t\ts: \"1\",\n\t\t\t},\n\t\t\twantNs:  \"1\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple digits\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"decimal number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative number\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential number\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential number with lowercase e\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e-4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"inf\",\n\t\t\t},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"nan\",\n\t\t\t},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123a\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"-inf\",\n\t\t\t},\n\t\t\twantNs:  \"-inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"-nan\",\n\t\t\t},\n\t\t\twantNs:  \"-nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}",
    "5da18abcb95e96380f9c8fd275d622fd": "package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u006\"},\n\t\t\twant: \"\\\\u0061\\\\u006\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\\\\\ \\\\/test\\\\/ \\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\"hello\\\" \\\\world\\\\ /test/ \\b\\f\\n\\r\\t abcüòÅ\\\\xhello\\\\x world\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "5ec1cf68f235fec45dbd1b9bba550fd2": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u world\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u world\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\\\\\ \\\\/\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\x\\\\u world\"},\n\t\t\twant: \"\\\"hello\\\" \\\\world\\\\ /\\\\b\\\\f\\\\n\\\\r\\tabcüòÅ\\\\x\\\\u world\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "5f00dfe65b2cd06b1edd54aff1a38985": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestType_String(t *testing.T) {\n\ttype args struct {\n\t\tt Type\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"TestType_String_Object\",\n\t\t\targs: args{t: TypeObject},\n\t\t\twant: \"object\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_Array\",\n\t\t\targs: args{t: TypeArray},\n\t\t\twant: \"array\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_String\",\n\t\t\targs: args{t: TypeString},\n\t\t\twant: \"string\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_Number\",\n\t\t\targs: args{t: TypeNumber},\n\t\t\twant: \"number\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_True\",\n\t\t\targs: args{t: TypeTrue},\n\t\t\twant: \"true\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_False\",\n\t\t\targs: args{t: TypeFalse},\n\t\t\twant: \"false\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_Null\",\n\t\t\targs: args{t: TypeNull},\n\t\t\twant: \"null\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.t.String(); got != tt.want {\n\t\t\t\tt.Errorf(\"Type.String() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "5f2d638daec8a7a43d52ea4a7cee1688": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Type(t *testing.T) {\n\ttype args struct {\n\t\tv *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant Type\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.v.Type(); got != tt.want {\n\t\t\t\tt.Errorf(\"Value.Type() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "5f7e1b408299a5feceba48dcfcc3c3e6": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quotes and other characters\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"!\\t\\n\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"!\\t\\n\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: ``,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with no quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `hello`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "60373dd5eb43b7806c0c2d73a68b5a1f": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttype want struct {\n\t\tv   *Value\n\t\ttail string\n\t\terr  error\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant want\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  fmt.Errorf(\"cannot parse empty string\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"{}\",\n\t\t\t\terr:  fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{t: TypeObject, o: Object{}},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{t: TypeArray, a: []*Value{}},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"hello\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{t: typeRawString, s: \"hello\"},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   \"true\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueTrue,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   \"false\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueFalse,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   \"null\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueNull,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   \"123\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   \"NaN\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"NaN\"},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotV, gotTail, gotErr := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif gotErr != nil \u0026\u0026 tt.want.err == nil {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, want nil\", gotErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotErr == nil \u0026\u0026 tt.want.err != nil {\n\t\t\t\tt.Errorf(\"parseValue() error = nil, want %v\", tt.want.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotErr != nil \u0026\u0026 tt.want.err != nil {\n\t\t\t\tif gotErr.Error() != tt.want.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue() error = %v, want %v\", gotErr, tt.want.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(gotV, tt.want.v) {\n\t\t\t\tt.Errorf(\"parseValue() gotV = %v, want %v\", gotV, tt.want.v)\n\t\t\t}\n\t\t\tif gotTail != tt.want.tail {\n\t\t\t\tt.Errorf(\"parseValue() gotTail = %v, want %v\", gotTail, tt.want.tail)\n\t\t\t}\n\t\t})\n\t}\n}",
    "61b554d4a71f6eec4c4a774e11524106": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_Unmarshal(t *testing.T) {\n\ttype testObject struct {\n\t\tKey1 string `json:\"key1\"`\n\t\tKey2 string `json:\"key2\"`\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\tjsonStr string\n\t\twant    testObject\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"simple object\",\n\t\t\tjsonStr: `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\twant: testObject{\n\t\t\t\tKey1: \"value1\",\n\t\t\t\tKey2: \"value2\",\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"object with nested object\",\n\t\t\tjsonStr: `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\twant: testObject{\n\t\t\t\tKey1: `{\"nestedKey1\": \"nestedValue1\"}`,\n\t\t\t\tKey2: \"value2\",\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"object with escaped key\",\n\t\t\tjsonStr: `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\twant: testObject{\n\t\t\t\tKey1: \"value1\",\n\t\t\t\tKey2: \"\",\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tvar got testObject\n\t\t\tc := \u0026cache{}\n\t\t\tv, _, err := parseObject(tt.jsonStr, c, 0)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err == nil {\n\t\t\t\terr = json.Unmarshal(v.MarshalTo(nil), \u0026got)\n\t\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}",
    "61c8116723a685d16e3b316f3a1002d9": "package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u006\"},\n\t\t\twant: \"\\\\u0061\\\\u006\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\\\\\ \\\\/\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\x\\\\u006\"},\n\t\t\twant: \"\\\"hello\\\" \\\\world\\\\ /\\\\b\\\\f\\\\n\\\\r\\\\tabcüòÅ\\\\x\\\\u006\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "61fabe52f811641e8d99fbb89579e7fe": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"{}\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: nil,\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"hello\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   \"true\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueTrue,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   \"false\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueFalse,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   \"null\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueNull,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   \"123\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\ts:   \"NaN\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseValue() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "621369ec062ba27fe0667dfb122818cd": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetObject(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant *Object\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.GetObject(tt.args.keys...); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"GetObject() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "63402e102f86c86928aec807fb0479ab": "```go\npackage fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"simple integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"float\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential notation\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential notation with negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e-4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"inf\",\n\t\t\t},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"Inf\",\n\t\t\t},\n\t\t\twantNs:  \"Inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inF\",\n\t\t\targs: args{\n\t\t\t\ts: \"inF\",\n\t\t\t},\n\t\t\twantNs:  \"inF\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"nan\",\n\t\t\t},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"Nan\",\n\t\t\t},\n\t\t\twantNs:  \"Nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nAn\",\n\t\t\targs: args{\n\t\t\t\ts: \"nAn\",\n\t\t\t},\n\t\t\twantNs:  \"nAn\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123a\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{",
    "638aa3553dd719f069b9f6dffc648994": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_reset(t *testing.T) {\n\ttype args struct {\n\t\to *Object\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant *Object\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.o.reset(); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Object.reset() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "63cc792ba38391a1dc1494e0e4f7ffab": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\" \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_JSON(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_JSON_Compare(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tvar want map[string]interface{}\n\t\t\tif err := json.Unmarshal([]byte(tt.args.s), \u0026want); err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got.o.kvs, want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got.o.kvs, want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "63d456ce66116ca7c6f98bdfaf7cb763": "```go\npackage fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"single digit\",\n\t\t\targs: args{\n\t\t\t\ts: \"1\",\n\t\t\t},\n\t\t\twantNs:  \"1\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple digits\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"decimal number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential number\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative number\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"positive number\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"inf\",\n\t\t\t},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"nan\",\n\t\t\t},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123a\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"123inf\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"inf\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"123nan\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"nan\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with inf at the beginning\",\n\t\t\targs: args{\n\t\t\t\ts: \"inf123\",\n\t\t\t},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"123\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with nan at the beginning\",\n\t\t\targs: args{\n\t\t\t\ts: \"nan123\",\n\t\t\t},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"123\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with inf at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" inf123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" inf123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with nan at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" nan123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" nan123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with inf at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" inf123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" inf123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with nan at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" nan123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" nan123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with inf at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" inf123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" inf123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with nan at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" nan123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" nan123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with inf at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" inf123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" inf123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with nan at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" nan123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" nan123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with inf at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" inf123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" inf123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with nan at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" nan123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" nan123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with inf at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" inf123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" inf123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with nan at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" nan123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" nan123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with inf at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" inf123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" inf123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with nan at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" nan123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" nan123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with inf at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" inf123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" inf123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with nan at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" nan123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" nan123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with inf at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" inf123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" inf123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with nan at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" nan123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" nan123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with inf at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" inf123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" inf123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with nan at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" nan123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" nan123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with inf at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" inf123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" inf123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with nan at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" nan123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" nan123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with inf at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" inf123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" inf123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with nan at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" nan123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" nan123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with inf at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" inf123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" inf123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with nan at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" nan123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" nan123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with inf at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" inf123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" inf123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with nan at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" nan123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" nan123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with inf at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" inf123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" inf123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with nan at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" nan123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" nan123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with inf at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" inf123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" inf123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with nan at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" nan123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" nan123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with inf at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" inf123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" inf123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with nan at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" nan123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" nan123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with inf at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" inf123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" inf123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with nan at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" nan123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" nan123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with inf at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" inf123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" inf123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with nan at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" nan123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" nan123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with inf at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" inf123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" inf123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with nan at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" nan123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" nan123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with inf at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" inf123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" inf123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with nan at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" nan123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" nan123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with inf at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" inf123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" inf123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with nan at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" nan123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" nan123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with inf at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" inf123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" inf123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with nan at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" nan123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" nan123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with inf at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" inf123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" inf123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with nan at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" nan123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" nan123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with inf at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" inf123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" inf123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with nan at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" nan123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" nan123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with inf at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" inf123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" inf123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with nan at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" nan123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" nan123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with inf at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" inf123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" inf123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with nan at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" nan123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" nan123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with inf at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" inf123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" inf123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with nan at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" nan123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" nan123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with inf at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" inf123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" inf123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with nan at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" nan123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" nan123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with inf at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" inf123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" inf123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with nan at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" nan123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" nan123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with inf at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" inf123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" inf123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with nan at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" nan123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" nan123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with inf at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" inf123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" inf123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with nan at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" nan123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" nan123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with inf at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" inf123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" inf123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with nan at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" nan123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" nan123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with inf at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" inf123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" inf123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with nan at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" nan123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" nan123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with inf at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" inf123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" inf123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with nan at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" nan123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" nan123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with inf at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" inf123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" inf123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with nan at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" nan123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" nan123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with inf at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" inf123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" inf123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with nan at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" nan123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" nan123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with inf at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" inf123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" inf123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with nan at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" nan123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" nan123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with inf at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" inf123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" inf123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with nan at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" nan123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" nan123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with inf at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" inf123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" inf123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with nan at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" nan123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" nan123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with inf at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" inf123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" inf123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with nan at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" nan123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" nan123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with inf at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" inf123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" inf123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with nan at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" nan123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" nan123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with inf at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" inf123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" inf123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with nan at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" nan123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" nan123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with inf at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" inf123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" inf123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with nan at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" nan123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" nan123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with inf at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" inf123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" inf123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with nan at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" nan123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" nan123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with inf at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" inf123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" inf123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with nan at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" nan123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" nan123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with inf at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" inf123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" inf123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with nan at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" nan123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" nan123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with inf at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" inf123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" inf123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with nan at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" nan123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" nan123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with inf at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" inf123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" inf123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with nan at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" nan123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" nan123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with inf at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" inf123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" inf123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with nan at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" nan123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" nan123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with inf at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" inf123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" inf123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with nan at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" nan123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" nan123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with inf at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" inf123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" inf123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with nan at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" nan123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" nan123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with inf at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" inf123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" inf123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with nan at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" nan123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" nan123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with inf at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" inf123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" inf123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with nan at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" nan123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" nan123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with inf at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" inf123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" inf123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with nan at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" nan123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" nan123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with inf at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" inf123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" inf123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with nan at the beginning with space\",\n\t\t\targs: args{\n\t\t\t\ts: \" nan123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" nan123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with inf at the beginning with space\",\n\t\t\targs",
    "6430a06526b6fe0eb984404080988e8a": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escaped strings\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"test\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\\\\\\\"test\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: ``,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"no quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `hello`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "645caff14b02a94bc8655b0b42b8bae0": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped string with multiple escapes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\"world\\\\\"\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: ``,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with no quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `hello`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote\",\n\t\t\targs: args{\n\t\t\t\ts: `hello\\\\\"world`,\n\t\t\t},\n\t\t\twant:    `hello\\\\\"world`,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "649e83338fd51e1621a05feef82da083": "package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u world\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u world\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\\\\\ \\\\/\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\x\\\\u world\"},\n\t\t\twant: \"\\\"hello\\\" \\\\world\\\\ /\\\\b\\\\f\\\\n\\\\r\\tabcüòÅ\\\\x\\\\u world\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "6548e1529105cef09542af737bec500c": "```go\npackage fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttype want struct {\n\t\tv   *Value\n\t\ttail string\n\t\terr  error\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant want\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  fmt.Errorf(\"cannot parse empty string\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"{}\",\n\t\t\t\terr:  fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\": \"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"value1\", \"value2\"]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"value\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeString,\n\t\t\t\t\ts: \"value\",\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   `true`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueTrue,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   `false`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueFalse,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   `null`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueNull,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"123\",\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   `NaN`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"NaN\",\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"invalid value\",\n\t\t\targs: args{\n\t\t\t\ts:   `invalid`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: `invalid`,\n\t\t\t\terr:  fmt.Errorf(\"unexpected value found: %q\", \"invalid\"),\n\t\t\t},\n",
    "65d4ee93a3ee3af7d8087f02220faf12": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_getKV(t *testing.T) {\n\ttype args struct {\n\t\to *Object\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant *kv\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.o.getKV(); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Object.getKV() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "65fc2fe3ed6e0aadf459c8a6722c7911": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCacheGetValue(t *testing.T) {\n\tt.Run(\"empty cache\", func(t *testing.T) {\n\t\tc := \u0026cache{}\n\t\tv := c.getValue()\n\t\tif v == nil {\n\t\t\tt.Error(\"getValue() returned nil for empty cache\")\n\t\t}\n\t})\n\n\tt.Run(\"non-empty cache\", func(t *testing.T) {\n\t\tc := \u0026cache{vs: []Value{{t: TypeNull}}}\n\t\tv := c.getValue()\n\t\tif v == nil {\n\t\t\tt.Error(\"getValue() returned nil for non-empty cache\")\n\t\t}\n\t\tif v.t != TypeNull {\n\t\t\tt.Errorf(\"getValue() returned unexpected value type: got %v, want %v\", v.t, TypeNull)\n\t\t}\n\t})\n}",
    "667c7903ac2f443de1f8b57d78b53346": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttype want struct {\n\t\tv   *Value\n\t\ttail string\n\t\terr  error\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant want\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  fmt.Errorf(\"cannot parse empty string\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"{}\",\n\t\t\t\terr:  fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{ \\\"key\\\": \\\"value\\\" }\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[ \\\"value1\\\", \\\"value2\\\" ]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\\\"value\\\"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeString,\n\t\t\t\t\ts: \"value\",\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   \"true\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueTrue,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   \"false\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueFalse,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   \"null\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueNull,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   \"123\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"123\",\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   \"NaN\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"NaN\",\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotV, gotTail, gotErr := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif gotErr != nil \u0026\u0026 tt.want.err == nil {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, want nil\", gotErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotErr == nil \u0026\u0026 tt.want.err != nil {\n\t\t\t\tt.Errorf(\"parseValue() error = nil, want %v\", tt.want.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotErr != nil \u0026\u0026 tt.want.err != nil {\n\t\t\t\tif gotErr.Error() != tt.want.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue() error = %v, want %v\", gotErr, tt.want.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(gotV, tt.want.v) {\n\t\t\t\tt.Errorf(\"parseValue() gotV = %v, want %v\", gotV, tt.want.v)\n\t\t\t}\n\t\t\tif gotTail != tt.want.tail {\n\t\t\t\tt.Errorf(\"parseValue() gotTail = %v, want %v\", gotTail, tt.want.tail)\n\t\t\t}\n\t\t})\n\t}\n}",
    "668a856045bb7eb8bad1930a3275cef9": "```go\npackage fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u world\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00xx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00xx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 2\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uxxxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uxxxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 3\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00x\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00x\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 4\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\ux\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\ux\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 5\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 6\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 7\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 8\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u000\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 9\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0000\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 10\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00000\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 11\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u000000\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 12\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0000000\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 13\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00000000\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 14\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u000000000\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 15\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0000000000\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 16\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00000000000\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 17\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u000000000000\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 18\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0000000000000\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 19\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00000000000000\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 20\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u000000000000000\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 21\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0000000000000000\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 22\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00000000000000000\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 23\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u000000000000000000\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 24\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0000000000000000000\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 25\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00000000000000000000\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 26\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u000000000000000000000\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 27\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0000000000000000000000\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 28\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00000000000000000000000\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 29\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u000000000000000000000000\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 30\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0000000000000000000000000\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 31\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00000000000000000000000000\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 32\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u000000000000000000000000000\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 33\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0000000000000000000000000000\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 34\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00000000000000000000000000000\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 35\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u000000000000000000000000000000\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u000000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 36\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0000000000000000000000000000000\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0000000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 37\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00000000000000000000000000000000\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00000000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 38\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u000000000000000000000000000000000\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u000000000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 39\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0000000000000000000000000000000000\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0000000000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 40\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00000000000000000000000000000000000\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00000000000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 41\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u000000000000000000000000000000000000\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u000000000000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 42\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0000000000000000000000000000000000000\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0000000000000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 43\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00000000000000000000000000000000000000\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00000000000000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 44\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u000000000000000000000000000000000000000\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u000000000000000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 45\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0000000000000000000000000000000000000000\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0000000000000000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 46\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00000000000000000000000000000000000000000\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00000000000000000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 47\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u000000000000000000000000000000000000000000\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u000000000000000000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 48\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0000000000000000000000000000000000000000000\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0000000000000000000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 49\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00000000000000000000000000000000000000000000\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00000000000000000000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 50\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u000000000000000000000000000000000000000000000\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u000000000000000000000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 51\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0000000000000000000000000000000000000000000000\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0000000000000000000000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 52\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00000000000000000000000000000000000000000000000\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00000000000000000000000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 53\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u000000000000000000000000000000000000000000000000\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u000000000000000000000000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 54\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0000000000000000000000000000000000000000000000000\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0000000000000000000000000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 55\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00000000000000000000000000000000000000000000000000\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00000000000000000000000000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 56\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u000000000000000000000000000000000000000000000000000\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u000000000000000000000000000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 57\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0000000000000000000000000000000000000000000000000000\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0000000000000000000000000000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 58\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00000000000000000000000000000000000000000000000000000\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00000000000000000000000000000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 59\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u000000000000000000000000000000000000000000000000000000\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u000000000000000000000000000000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 60\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0000000000000000000000000000000000000000000000000000000\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0000000000000000000000000000000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 61\",\n\t\t\t",
    "6731289aaef77b8400d83d46dbc76417": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestHasSpecialChars(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with double quote\",\n\t\t\targs: args{s: \"hello\\\"world\"},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with backslash\",\n\t\t\targs: args{s: \"hello\\\\world\"},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with control character\",\n\t\t\targs: args{s: \"hello\\x01world\"},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string without special characters\",\n\t\t\targs: args{s: \"helloworld\"},\n\t\t\twant: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := hasSpecialChars(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"hasSpecialChars() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "67b025a3b6f0c6ae2fda197859e96ab1": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth + 1,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"{}\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\": \"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"value1\", \"value2\"]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"value\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"value\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   `true`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueTrue,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   `false`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueFalse,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   `null`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueNull,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with decimal\",\n\t\t\targs: args{\n\t\t\t\ts:   `123.456`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e+4`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e-4`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"1.23e-4\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `-123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zero\",\n\t\t\targs: args{\n\t\t\t\ts:   `0123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"0123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with trailing zero\",\n\t\t\targs: args{\n\t\t\t\ts:   `123.0`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123.0\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   `NaN`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseValue() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseValue_Invalid(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"invalid object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid true\",\n\t\t\targs: args{\n\t\t\t\ts:   `tru`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid false\",\n\t\t\targs: args{\n\t\t\t\ts:   `fals`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid null\",\n\t\t\targs: args{\n\t\t\t\ts:   `nul`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123.`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e-`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with negative sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `-`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading zero\",\n\t\t\targs: args{\n\t\t\t\ts:   `0.`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing zero\",\n\t\t\targs: args{\n\t\t\t\ts:   `.0`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   `Na`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t_, _, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseValue_JSON(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\": \"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"value1\", \"value2\"]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"value\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   `true`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   `false`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   `null`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with decimal\",\n\t\t\targs: args{\n\t\t\t\ts:   `123.456`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e+4`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e-4`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `-123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zero\",\n\t\t\targs: args{\n\t\t\t\ts:   `0123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with trailing zero\",\n\t\t\targs: args{\n\t\t\t\ts:   `123.0`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   `NaN`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, _, err := parseValue(tt.args.s, c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif tt.wantErr {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tvar want interface{}\n\t\t\tif err := json.Unmarshal([]byte(tt.args.s), \u0026want); err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, want) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "6804e2a188450095521d19251089a3cd": "package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u006\"},\n\t\t\twant: \"\\\\u0061\\\\u006\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\\\\\ \\\\/test\\\\/ \\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\"hello\\\" \\\\world\\\\ /test/ \\b\\f\\n\\r\\t abcüòÅ\\\\xhello\\\\x world\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "682443aef2bd906bc6223297b5892cb3": "package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u world\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u world\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\\\\\ \\\\/\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\x\\\\u world\"},\n\t\t\twant: \"\\\"hello\\\" \\\\world\\\\ /\\\\b\\\\f\\\\n\\\\r\\tabcüòÅ\\\\x\\\\u world\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "687b07e488e0a192515ad3f89d12c2ca": "package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u006\"},\n\t\t\twant: \"\\\\u0061\\\\u006\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u006zg\"},\n\t\t\twant: \"\\\\u0061\\\\u006zg\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\u006zg\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\u006zg\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with incomplete hex\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\u006\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\u006\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex and incomplete hex\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\u006zg\\\\u006\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\u006zg\\\\u006\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex and incomplete hex and invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\u006zg\\\\u006\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\u006zg\\\\u006\\\\xhello\\\\x world\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_SurrogatePair(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tinput string\n\t\twant  string\n\t}{\n\t\t{\n\t\t\tname:  \"valid surrogate pair\",\n\t\t\tinput: \"\\\\uD83D\\\\uDE01\",\n\t\t\twant:  \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname:  \"invalid surrogate pair - missing second part\",\n\t\t\tinput: \"\\\\uD83D\",\n\t\t\twant:  \"\\\\uD83D\",\n\t\t},\n\t\t{\n\t\t\tname:  \"invalid surrogate pair - invalid second part\",\n\t\t\tinput: \"\\\\uD83D\\\\u0000\",\n\t\t\twant:  \"\\\\uD83D\\\\u0000\",\n\t\t},\n\t\t{\n\t\t\tname:  \"invalid surrogate pair - missing backslash before second part\",\n\t\t\tinput: \"\\\\uD83DuDE01\",\n\t\t\twant:  \"\\\\uD83DuDE01\",\n\t\t},\n\t\t{\n\t\t\tname:  \"valid surrogate pair with surrounding text\",\n\t\t\tinput: \"Hello \\\\uD83D\\\\uDE01 world\",\n\t\t\twant:  \"Hello üòÅ world\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.input); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_InvalidEscapeSequences(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tinput string\n\t\twant  string\n\t}{\n\t\t{\n\t\t\tname:  \"invalid escape sequence - single character\",\n\t\t\tinput: \"\\\\x\",\n\t\t\twant:  \"\\\\x\",\n\t\t},\n\t\t{\n\t\t\tname:  \"invalid escape sequence - multiple characters\",\n\t\t\tinput: \"\\\\xyz\",\n\t\t\twant:  \"\\\\xyz\",\n\t\t},\n\t\t{\n\t\t\tname:  \"invalid escape sequence - incomplete unicode\",\n\t\t\tinput: \"\\\\u006\",\n\t\t\twant:  \"\\\\u006\",\n\t\t},\n\t\t{\n\t\t\tname:  \"invalid escape sequence - invalid unicode hex\",\n\t\t\tinput: \"\\\\u006z\",\n\t\t\twant:  \"\\\\u006z\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.input); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_Unicode(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tinput string\n\t\twant  string\n\t}{\n\t\t{\n\t\t\tname:  \"valid unicode escape sequence\",\n\t\t\tinput: \"\\\\u0061\",\n\t\t\twant:  \"a\",\n\t\t},\n\t\t{\n\t\t\tname:  \"valid unicode escape sequence with surrounding text\",\n\t\t\tinput: \"Hello \\\\u0061 world\",\n\t\t\twant:  \"Hello a world\",\n\t\t},\n\t\t{\n\t\t\tname:  \"valid unicode escape sequence with multiple characters\",\n\t\t\tinput: \"\\\\u0061\\\\u0062\\\\u0063\",\n\t\t\twant:  \"abc\",\n\t\t},\n\t\t{\n\t\t\tname:  \"valid unicode escape sequence with multiple characters and surrounding text\",\n\t\t\tinput: \"Hello \\\\u0061\\\\u0062\\\\u0063 world\",\n\t\t\twant:  \"Hello abc world\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.input); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_EscapedCharacters(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tinput string\n\t\twant  string\n\t}{\n\t\t{\n\t\t\tname:  \"escaped quote\",\n\t\t\tinput: \"\\\\\\\"\",\n\t\t\twant:  \"\\\"\",\n\t\t},\n\t\t{\n\t\t\tname:  \"escaped backslash\",\n\t\t\tinput: \"\\\\\\\\\",\n\t\t\twant:  \"\\\\\",\n\t\t},\n\t\t{\n\t\t\tname:  \"escaped forward slash\",\n\t\t\tinput: \"\\\\/\",\n\t\t\twant:  \"/\",\n\t\t},\n\t\t{\n\t\t\tname:  \"escaped backspace\",\n\t\t\tinput: \"\\\\b\",\n\t\t\twant:  \"\\b\",\n\t\t},\n\t\t{\n\t\t\tname:  \"escaped form feed\",\n\t\t\tinput: \"\\\\f\",\n\t\t\twant:  \"\\f\",\n\t\t},\n\t\t{\n\t\t\tname:  \"escaped newline\",\n\t\t\tinput: \"\\\\n\",\n\t\t\twant:  \"\\n\",\n\t\t},\n\t\t{\n\t\t\tname:  \"escaped carriage return\",\n\t\t\tinput: \"\\\\r\",\n\t\t\twant:  \"\\r\",\n\t\t},\n\t\t{\n\t\t\tname:  \"escaped tab\",\n\t\t\tinput: \"\\\\t\",\n\t\t\twant:  \"\\t\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.input); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_MultipleEscapeSequences(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tinput string\n\t\twant  string\n\t}{\n\t\t{\n\t\t\tname:  \"multiple escaped characters\",\n\t\t\tinput: \"\\\\\\\"\\\\b\\\\f\\\\n\\\\r\\\\t\",\n\t\t\twant:  \"\\\"\\b\\f\\n\\r\\t\",\n\t\t},\n\t\t{\n\t\t\tname:  \"multiple escaped characters with surrounding text\",\n\t\t\tinput: \"Hello \\\\\\\"\\\\b\\\\f\\\\n\\\\r\\\\t world\",\n\t\t\twant:  \"Hello \\\"\\b\\f\\n\\r\\t world\",\n\t\t},\n\t\t{\n\t\t\tname:  \"multiple escaped characters with unicode\",\n\t\t\tinput: \"\\\\u0061\\\\\\\"\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0062\",\n\t\t\twant:  \"a\\\"\\b\\f\\n\\r\\tb\",\n\t\t},\n\t\t{\n\t\t\tname:  \"multiple escaped characters with unicode and surrounding text\",\n\t\t\tinput: \"Hello \\\\u0061\\\\\\\"\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0062 world\",\n\t\t\twant:  \"Hello a\\\"\\b\\f\\n\\r\\tb world\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.input); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_Performance(t *testing.T) {\n\t// Create a large string with many escape sequences\n\tinput := \"\"\n\tfor i := 0; i \u003c 10000; i++ {\n\t\tinput += \"\\\\\\\"\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\"\n\t}\n\n\t// Time the unescapeStringBestEffort function\n\tt.Logf(\"unescapeStringBestEffort(%d characters):\", len(input))\n\tt.Logf(\"Start time: %v\", time.Now())\n\tunescapeStringBestEffort(input)\n\tt.Logf(\"End time: %v\", time.Now())\n}",
    "68808cd021a8ac028c0531f9704bfc29": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_getKV(t *testing.T) {\n\ttype args struct {\n\t\to *Object\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant *kv\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.o.getKV(); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Object.getKV() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "68fecac4233379e0ee0add4e25802abc": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"single element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,3]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[[1,2],[3,4]]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"4\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with string\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[\\\"hello\\\", \\\"world\\\"]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"hello\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"world\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with object\",\n\t\t\targs: args{\n\t\t\t\ts:    `[{\"key1\": \"value1\"}, {\"key2\": \"value2\"}]`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1,2\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1 2]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1 2]\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid value\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,invalid]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1,2,invalid]\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseArray() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "691a36d7ea06c6aa770c81bab56634b6": "```go\npackage fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\x\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\x\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\ux\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\ux\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 2\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0x\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0x\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 3\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 4\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 5\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 6\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 7\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 8\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 9\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 10\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 11\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 12\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 13\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 14\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 15\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 16\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 17\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 18\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 19\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 20\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 21\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 22\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 23\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 24\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 25\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 26\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 27\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 28\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 29\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 30\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 31\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 32\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 33\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 34\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 35\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789012\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789012\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 36\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890123\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890123\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 37\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901234\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901234\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 38\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789012345\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789012345\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 39\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890123456\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890123456\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 40\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901234567\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901234567\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 41\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789012345678\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789012345678\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 42\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890123456789\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890123456789\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 43\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901234567890\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901234567890\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 44\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789012345678901\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789012345678901\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 45\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890123456789012\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890123456789012\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 46\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901234567890123\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901234567890123\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 47\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789012345678901234\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789012345678901234\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 48\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890123456789012345\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890123456789012345\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 49\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901234567890123456\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901234567890123456\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 50\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789012345678901234567\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789012345678901234567\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 51\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890123456789012345678\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890123456789012345678\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 52\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901234567890123456789\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901234567890123456789\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 53\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789012345678901234567890\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789012345678901234567890\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 54\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890123456789012345678901\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890123456789012345678901\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 55\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901234567890123456789012\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901234567890123456789012\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 56\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789012345678901234567890123\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789012345678901234567890123\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 57\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890123456789012345678901234\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123456789012345678901234567890123456789012345678901234\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 58\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901234567890123456789012345\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1234567890123456789012345678901234567890123456789012345\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 59\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901234567890123456789012345678901234567890123456\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u12345678901",
    "6978245fc46d5f25aaf2c8cac4473f73": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"simple integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"float\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential notation\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential notation with negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e-4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"inf\",\n\t\t\t},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"Inf\",\n\t\t\t},\n\t\t\twantNs:  \"Inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inF\",\n\t\t\targs: args{\n\t\t\t\ts: \"inF\",\n\t\t\t},\n\t\t\twantNs:  \"inF\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"nan\",\n\t\t\t},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"Nan\",\n\t\t\t},\n\t\t\twantNs:  \"Nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nAn\",\n\t\t\targs: args{\n\t\t\t\ts: \"nAn\",\n\t\t\t},\n\t\t\twantNs:  \"nAn\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123a\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"-123a\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and trailing character\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+123a\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and trailing character\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"-123a\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}",
    "69e14af1a1cf177e765068338ea97f04": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestValueBool(t *testing.T) {\n\ttype args struct {\n\t\tv *Value\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    bool\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeTrue,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant:    true,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeFalse,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant:    false,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeNull,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant:    false,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant:    false,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant:    false,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeString,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant:    false,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant:    false,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := tt.args.v.Bool()\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Value.Bool() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Value.Bool() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "6aca4cb03aca002182ddf53b78161961": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestHasSpecialChars(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with double quote\",\n\t\t\targs: args{s: \"hello\\\"world\"},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with backslash\",\n\t\t\targs: args{s: \"hello\\\\world\"},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with control character\",\n\t\t\targs: args{s: \"hello\\x01world\"},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string without special characters\",\n\t\t\targs: args{s: \"helloworld\"},\n\t\t\twant: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := hasSpecialChars(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"hasSpecialChars() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "6b4af14a43e831b21c655ba7bacce0d5": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\tv   *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"marshal string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeString, s: \"hello\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal number\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t},\n\t\t\twant: []byte(\"123\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal true\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeTrue},\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal false\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeFalse},\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal null\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNull},\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal object\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":\"value1\",\"key2\":123}`),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal array\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{t: TypeString, s: \"value1\"},\n\t\t\t\t\t\t{t: TypeNumber, s: \"123\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`[\"value1\",123]`),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal raw string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: typeRawString, s: \"hello\"},\n\t\t\t},\n\t\t\twant: []byte(`\"hello\"`),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.v.MarshalTo(tt.args.dst); !bytesEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc bytesEqual(a, b []byte) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "6b82b35fcceba03b7e2a861d1ca8a1bc": "```go\npackage fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{\\\"a\\\":1}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"{\\\"a\\\":1}\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{\\\"a\\\":1}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"a\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[1,2,3]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"hello\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   \"true\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueTrue,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   \"false\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueFalse,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   \"null\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueNull,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   \"123\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   \"NaN\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseValue() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseValue_Marshal(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{\\\"a\\\":1}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    \"{\\\"a\\\":1}\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[1,2,3]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    \"[1,2,3]\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"hello\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `\"hello\"`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   \"true\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t",
    "6d3a5822e00fab03ff2f1d46789bc3de": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\"world\\\\\\\"\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quotes and other characters\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"\\\\\\\\\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\\\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: ``,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with no quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `hello`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "6d42cc491bb7931af5168fb29d450757": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"simple integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple float\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.45\",\n\t\t\t},\n\t\t\twantNs:  \"123.45\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative number\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential notation\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential notation with minus sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e-4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"inf\",\n\t\t\t},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"Inf\",\n\t\t\t},\n\t\t\twantNs:  \"Inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twantNs:  \"NaN\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"nan\",\n\t\t\t},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123a\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"-123a\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"-inf\",\n\t\t\t},\n\t\t\twantNs:  \"-inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"-nan\",\n\t\t\t},\n\t\t\twantNs:  \"-nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}",
    "6d5a8b1708e96dcfd891f4e6f778b2eb": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"simple integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"float\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential notation\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential notation with negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e-4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading whitespace\",\n\t\t\targs: args{\n\t\t\t\ts: \" 123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" 123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing whitespace\",\n\t\t\targs: args{\n\t\t\t\ts: \"123 \",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \" \",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid character\",\n\t\t\targs: args{\n\t\t\t\ts: \"123a\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"inf\",\n\t\t\t},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"Inf\",\n\t\t\t},\n\t\t\twantNs:  \"Inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inF\",\n\t\t\targs: args{\n\t\t\t\ts: \"inF\",\n\t\t\t},\n\t\t\twantNs:  \"in\",\n\t\t\twantS:   \"F\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"nan\",\n\t\t\t},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"Nan\",\n\t\t\t},\n\t\t\twantNs:  \"Nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nAn\",\n\t\t\targs: args{\n\t\t\t\ts: \"nAn\",\n\t\t\t},\n\t\t\twantNs:  \"n\",\n\t\t\twantS:   \"An\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}",
    "6da65682ce259312ae9b4cdb1e73416a": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"simple integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"float\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential notation\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential notation with negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e-4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"inf\",\n\t\t\t},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"Inf\",\n\t\t\t},\n\t\t\twantNs:  \"Inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inF\",\n\t\t\targs: args{\n\t\t\t\ts: \"inF\",\n\t\t\t},\n\t\t\twantNs:  \"inF\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"nan\",\n\t\t\t},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"Nan\",\n\t\t\t},\n\t\t\twantNs:  \"Nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nAn\",\n\t\t\targs: args{\n\t\t\t\ts: \"nAn\",\n\t\t\t},\n\t\t\twantNs:  \"nAn\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123a\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+123a\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and trailing characters 2\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123a\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+123a\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}",
    "6db00f06325b618d849dc56822ae75ec": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"{}\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\": \"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"value1\", \"value2\"]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"value\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"value\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   `true`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueTrue,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   `false`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueFalse,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   `null`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueNull,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   `NaN`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseValue() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseValue_Invalid(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"invalid object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid true\",\n\t\t\targs: args{\n\t\t\t\ts:   `tru`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid false\",\n\t\t\targs: args{\n\t\t\t\ts:   `fals`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid null\",\n\t\t\targs: args{\n\t\t\t\ts:   `nul`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123a`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t_, _, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseValue_Marshal(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\": \"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `{\"key\":\"value\"}`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"value1\", \"value2\"]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `[\"value1\",\"value2\"]`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"value\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `\"value\"`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   `true`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `true`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   `false`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `false`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   `null`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `null`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `123`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   `NaN`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `NaN`,\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tb, err := json.Marshal(got)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"json.Marshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif string(b) != tt.want {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", string(b), tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "6df0d4e5d8c2ff606085628a104b67b6": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"simple integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"float\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential notation\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential notation with negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e-4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"inf\",\n\t\t\t},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"Inf\",\n\t\t\t},\n\t\t\twantNs:  \"Inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inF\",\n\t\t\targs: args{\n\t\t\t\ts: \"inF\",\n\t\t\t},\n\t\t\twantNs:  \"inF\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"nan\",\n\t\t\t},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twantNs:  \"NaN\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nAn\",\n\t\t\targs: args{\n\t\t\t\ts: \"nAn\",\n\t\t\t},\n\t\t\twantNs:  \"nAn\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char\",\n\t\t\targs: args{\n\t\t\t\ts: \"123a\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at start\",\n\t\t\targs: args{\n\t\t\t\ts: \"a123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"a123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char after sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"-a123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"-a123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char after sign 2\",\n\t\t\targs: args{\n\t\t\t\ts: \"+a123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+a123\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}",
    "6e33d0d62a23a8721caad8b3e9af809d": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no whitespace\",\n\t\t\targs: args{s: \"abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace\",\n\t\t\targs: args{s: \"  abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailing whitespace\",\n\t\t\targs: args{s: \"abc  \"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading and trailing whitespace\",\n\t\t\targs: args{s: \"  abc  \"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"whitespace in the middle\",\n\t\t\targs: args{s: \"a bc\"},\n\t\t\twant: \"bc\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple whitespace\",\n\t\t\targs: args{s: \"  a  b  c  \"},\n\t\t\twant: \"b  c  \",\n\t\t},\n\t\t{\n\t\t\tname: \"newline\",\n\t\t\targs: args{s: \"\\n abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"carriage return\",\n\t\t\targs: args{s: \"\\r abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"tab\",\n\t\t\targs: args{s: \"\\t abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"mixed whitespace\",\n\t\t\targs: args{s: \" \\n\\t\\r abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "6e8502e4888bb33c5d31d62ffdb69b41": "```go\npackage fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u006\"},\n\t\t\twant: \"\\\\u0061\\\\u006\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u006zg\"},\n\t\t\twant: \"\\\\u0061\\\\u006zg\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\u006zg\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\u006zg\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with incomplete hex\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\u006\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\u006\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\u006zg\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\u006zg\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with incomplete hex\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\u006\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\u006\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\u006zg\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\u006zg\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with incomplete hex\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\u006\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\u006\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\u006zg\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\u006zg\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with incomplete hex\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\u006\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\u006\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\u006zg\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\u006zg\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with incomplete hex\",\n",
    "6f19aa110e6aa422ecee615bd3adb1ca": "package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u world\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u world\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\\\\\ \\\\/\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\x\\\\u world\"},\n\t\t\twant: \"\\\"hello\\\" \\\\world\\\\ /\\\\b\\\\f\\\\n\\\\r\\tabcüòÅ\\\\x\\\\u world\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "6f44ad38d1750d682e4dc5ccc8c22331": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "6f51b309595c1399dbabe55956e4e70a": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\"world\\\\\\\"\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote at the end\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"world\\\"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "6fab218b3923aaaeb15f025f2a5a7e40": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\"world\\\\\\\"\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote at the end\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote at the beginning\",\n\t\t\targs: args{\n\t\t\t\ts: `\\\\\"hello\"`,\n\t\t\t},\n\t\t\twant:    `\\`,\n\t\t\twant1:   `\"hello\"`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote in the middle\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: ``,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with no quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `hello`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "6fd24ebeaee11084b0c385bb63aecac6": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"single element array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[1]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[1,2,3]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[[1,2],[3,4]]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"4\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with string\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"hello\", \"world\"]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"hello\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"world\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with object\",\n\t\t\targs: args{\n\t\t\t\ts:   `[{\"key1\": \"value1\"}, {\"key2\": \"value2\"}]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[1,2\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1,2\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[1 2]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1 2]\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseArray() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseArray_JSON(t *testing.T) {\n\ttype testCase struct {\n\t\tjson string\n\t\twant []interface{}\n\t}\n\ttestCases := []testCase{\n\t\t{\n\t\t\tjson: \"[]\",\n\t\t\twant: []interface{}{},\n\t\t},\n\t\t{\n\t\t\tjson: \"[1,2,3]\",\n\t\t\twant: []interface{}{1, 2, 3},\n\t\t},\n\t\t{\n\t\t\tjson: `[\"hello\", \"world\"]`,\n\t\t\twant: []interface{}{\"hello\", \"world\"},\n\t\t},\n\t\t{\n\t\t\tjson: `[{\"key1\": \"value1\"}, {\"key2\": \"value2\"}]`,\n\t\t\twant: []interface{}{\n\t\t\t\tmap[string]interface{}{\"key1\": \"value1\"},\n\t\t\t\tmap[string]interface{}{\"key2\": \"value2\"},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.json, func(t *testing.T) {\n\t\t\tvar got []interface{}\n\t\t\tif err := json.Unmarshal([]byte(tc.json), \u0026got); err != nil {\n\t\t\t\tt.Fatalf(\"json.Unmarshal failed: %v\", err)\n\t\t\t}\n\t\t\tc := \u0026cache{}\n\t\t\tv, _, err := parseArray(tc.json, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"parseArray failed: %v\", err)\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(v.a, got) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", v.a, got)\n\t\t\t}\n\t\t})\n\t}\n}",
    "7058efd0c56b597cc2d9223ff1700ad9": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObjectVisit(t *testing.T) {\n\ttype args struct {\n\t\to *Object\n\t\tf func(key []byte, v *Value)\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\ttt.args.o.Visit(tt.args.f)\n\t\t})\n\t}\n}",
    "706865992798e2e97cf456a24af456c3": "```go\npackage fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\uxyz\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\uxyz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 2\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uxyz\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uxyz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 3\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064\\\\uxyz\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064\\\\uxyz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 4\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064\\\\u0065\\\\uxyz\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064\\\\u0065\\\\uxyz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 5\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064\\\\u0065\\\\u0066\\\\uxyz\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064\\\\u0065\\\\u0066\\\\uxyz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 6\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064\\\\u0065\\\\u0066\\\\u0067\\\\uxyz\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064\\\\u0065\\\\u0066\\\\u0067\\\\uxyz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 7\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064\\\\u0065\\\\u0066\\\\u0067\\\\u0068\\\\uxyz\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064\\\\u0065\\\\u0066\\\\u0067\\\\u0068\\\\uxyz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 8\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064\\\\u0065\\\\u0066\\\\u0067\\\\u0068\\\\u0069\\\\uxyz\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064\\\\u0065\\\\u0066\\\\u0067\\\\u0068\\\\u0069\\\\uxyz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 9\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064\\\\u0065\\\\u0066\\\\u0067\\\\u0068\\\\u0069\\\\u006a\\\\uxyz\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064\\\\u0065\\\\u0066\\\\u0067\\\\u0068\\\\u0069\\\\u006a\\\\uxyz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 10\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064\\\\u0065\\\\u0066\\\\u0067\\\\u0068\\\\u0069\\\\u006a\\\\u006b\\\\uxyz\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064\\\\u0065\\\\u0066\\\\u0067\\\\u0068\\\\u0069\\\\u006a\\\\u006b\\\\uxyz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 11\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064\\\\u0065\\\\u0066\\\\u0067\\\\u0068\\\\u0069\\\\u006a\\\\u006b\\\\u006c\\\\uxyz\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064\\\\u0065\\\\u0066\\\\u0067\\\\u0068\\\\u0069\\\\u006a\\\\u006b\\\\u006c\\\\uxyz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 12\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064\\\\u0065\\\\u0066\\\\u0067\\\\u0068\\\\u0069\\\\u006a\\\\u006b\\\\u006c\\\\u006d\\\\uxyz\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064\\\\u0065\\\\u0066\\\\u0067\\\\u0068\\\\u0069\\\\u006a\\\\u006b\\\\u006c\\\\u006d\\\\uxyz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 13\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064\\\\u0065\\\\u0066\\\\u0067\\\\u0068\\\\u0069\\\\u006a\\\\u006b\\\\u006c\\\\u006d\\\\u006e\\\\uxyz\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064\\\\u0065\\\\u0066\\\\u0067\\\\u0068\\\\u0069\\\\u006a\\\\u006b\\\\u006c\\\\u006d\\\\u006e\\\\uxyz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 14\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064\\\\u0065\\\\u0066\\\\u0067\\\\u0068\\\\u0069\\\\u006a\\\\u006b\\\\u006c\\\\u006d\\\\u006e\\\\u006f\\\\uxyz\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064\\\\u0065\\\\u0066\\\\u0067\\\\u0068\\\\u0069\\\\u006a\\\\u006b\\\\u006c\\\\u006d\\\\u006e\\\\u006f\\\\uxyz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 15\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064\\\\u0065\\\\u0066\\\\u0067\\\\u0068\\\\u0069\\\\u006a\\\\u006b\\\\u006c\\\\u006d\\\\u006e\\\\u006f\\\\u0070\\\\uxyz\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064\\\\u0065\\\\u0066\\\\u0067\\\\u0068\\\\u0069\\\\u006a\\\\u006b\\\\u006c\\\\u006d\\\\u006e\\\\u006f\\\\u0070\\\\uxyz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 16\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064\\\\u0065\\\\u0066\\\\u0067\\\\u0068\\\\u0069\\\\u006a\\\\u006b\\\\u006c\\\\u006d\\\\u006e\\\\u006f\\\\u0070\\\\u0071\\\\uxyz\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064\\\\u0065\\\\u0066\\\\u0067\\\\u0068\\\\u0069\\\\u006a\\\\u006b\\\\u006c\\\\u006d\\\\u006e\\\\u006f\\\\u0070\\\\u0071\\\\uxyz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 17\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064\\\\u0065\\\\u0066\\\\u0067\\\\u0068\\\\u0069\\\\u006a\\\\u006b\\\\u006c\\\\u006d\\\\u006e\\\\u006f\\\\u0070\\\\u0071\\\\u0072\\\\uxyz\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064\\\\u0065\\\\u0066\\\\u0067\\\\u0068\\\\u0069\\\\u006a\\\\u006b\\\\u006c\\\\u006d\\\\u006e\\\\u006f\\\\u0070\\\\u0071\\\\u0072\\\\uxyz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 18\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064\\\\u0065\\\\u0066\\\\u0067\\\\u0068\\\\u0069\\\\u006a\\\\u006b\\\\u006c\\\\u006d\\\\u006e\\\\u006f\\\\u0070\\\\u0071\\\\u0072\\\\u0073\\\\uxyz\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064\\\\u0065\\\\u0066\\\\u0067\\\\u0068\\\\u0069\\\\u006a\\\\u006b\\\\u006c\\\\u006d\\\\u006e\\\\u006f\\\\u0070\\\\u0071\\\\u0072\\\\u0073\\\\uxyz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 19\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064\\\\u0065\\\\u0066\\\\u0067\\\\u0068\\\\u0069\\\\u006a\\\\u006b\\\\u006c\\\\u006d\\\\u006e\\\\u006f\\\\u0070\\\\u0071\\\\u0072\\\\u0073\\\\u0074\\\\uxyz\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064\\\\u0065\\\\u0066\\\\u0067\\\\u0068\\\\u0069\\\\u006a\\\\u006b\\\\u006c\\\\u006d\\\\u006e\\\\u006f\\\\u0070\\\\u0071\\\\u0072\\\\u0073\\\\u0074\\\\uxyz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 20\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064\\\\u0065\\\\u0066\\\\u0067\\\\u0068\\\\u0069\\\\u006a\\\\u006b\\\\u006c\\\\u006d\\\\u006e\\\\u006f\\\\u0070\\\\u0071\\\\u0072\\\\u0073\\\\u0074\\\\u0075\\\\uxyz\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064\\\\u0065\\\\u0066\\\\u0067\\\\u0068\\\\u0069\\\\u006a\\\\u006b\\\\u006c\\\\u006d\\\\u006e\\\\u006f\\\\u0070\\\\u0071\\\\u0072\\\\u0073\\\\u0074\\\\u0075\\\\uxyz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 21\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064\\\\u0065\\\\u0066\\\\u0067\\\\u0068\\\\u0069\\\\u006a\\\\u006b\\\\u006c\\\\u006d\\\\u006e\\\\u006f\\\\u0070\\\\u0071\\\\u0072\\\\u0073\\\\u0074\\\\u0075\\\\u0076\\\\uxyz\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064\\\\u0065\\\\u0066\\\\u0067\\\\u0068\\\\u0069\\\\u006a\\\\u006b\\\\u006c\\\\u006d\\\\u006e\\\\u006f\\\\u0070\\\\u0071\\\\u0072\\\\u0073\\\\u0074\\\\u0075\\\\u0076\\\\uxyz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 22\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064\\\\u0065\\\\u0066\\\\u0067\\\\u0068\\\\u0069\\\\u006a\\\\u006b\\\\u006c\\\\u006d\\\\u006e\\\\u006f\\\\u0070\\\\u0071\\\\u0072\\\\u0073\\\\u0074\\\\u0075\\\\u0076\\\\u0077\\\\uxyz\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064\\\\u0065\\\\u0066\\\\u0067\\\\u0068\\\\u0069\\\\u006a\\\\u006b\\\\u006c\\\\u006d\\\\u006e\\\\u006f\\\\u0070\\\\u0071\\\\u0072\\\\u0073\\\\u0074\\\\u0075\\\\u0076\\\\u0077\\\\uxyz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 23\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064\\\\u0065\\\\u0066\\\\u0067\\\\u0068\\\\u0069\\\\u006a\\\\u006b\\\\u006c\\\\u006d\\\\u006e\\\\u006f\\\\u0070\\\\u0071\\\\u0072\\\\u0073\\\\u0074\\\\u0075\\\\u0076\\\\u0077\\\\u0078\\\\uxyz\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064\\\\u0065\\\\u0066\\\\u0067\\\\u0068\\\\u0069\\\\u006a\\\\u006b\\\\u006c\\\\u006d\\\\u006e\\\\u006f\\\\u0070\\\\u0071\\\\u0072\\\\u0073\\\\u0074\\\\u0075\\\\u0076\\\\u0077\\\\u0078\\\\uxyz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 24\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064\\\\u0065\\\\u0066\\\\u0067\\\\u0068\\\\u0069\\\\u006a\\\\u006b\\\\u006c\\\\u006d\\\\u006e\\\\u006f\\\\u0070\\\\u0071\\\\u0072\\\\u0073\\\\u0074\\\\u0075\\\\u0076\\\\u0077\\\\u0078\\\\u0079\\\\uxyz\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064\\\\u0065\\\\u0066\\\\u0067\\\\u0068\\\\u0069\\\\u006a\\\\u006b\\\\u006c\\\\u006d\\\\u006e\\\\u006f\\\\u0070\\\\u0071\\\\u0072\\\\u0073\\\\u0074\\\\u0075\\\\u0076\\\\u0077\\\\u0078\\\\u0079\\\\uxyz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 25\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064\\\\u0065\\\\u0066\\\\u0067\\\\u0068\\\\u0069\\\\u006a\\\\u006b\\\\u006c\\\\u006d\\\\u006e\\\\u006f\\\\u0070\\\\u0071\\\\u0072\\\\u0073\\\\u0074\\\\u0075\\\\u0076\\\\u0077\\\\u0078\\\\u0079\\\\u007a\\\\uxyz\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064\\\\u0065\\\\u0066\\\\u0067\\\\u0068\\\\u0069\\\\u006a\\\\u006b\\\\u006c\\\\u006d\\\\u006e\\\\u006f\\\\u0070\\\\u0071\\\\u0072\\\\u0073\\\\u0074\\\\u0075\\\\u0076\\\\u0077\\\\u0078\\\\u0079\\\\u007a\\\\uxyz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 26\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064\\\\u0065\\\\u0066\\\\u0067\\\\u0068\\\\u0069\\\\u006a\\\\u006b\\\\u006c\\\\u006d\\\\u006e\\\\u006f\\\\u0070\\\\u0071\\\\u0072\\\\u0073\\\\u0074\\\\u0075\\\\u0076\\\\u0077\\\\u0078\\\\u0079\\\\u007a\\\\u0041\\\\uxyz\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064\\\\u0065\\\\u0066\\\\u0067\\\\u0068\\\\u0069\\\\u006a\\\\u006b\\\\u006c\\\\u006d\\\\u006e\\\\u006f\\\\u0070\\\\u0071\\\\u0072\\\\u0073\\\\u0074\\\\u0075\\\\u0076\\\\u0077\\\\u0078\\\\u0079\\\\u007a\\\\u0041\\\\uxyz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 27\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064\\\\u0065\\\\u0066\\\\u0067\\\\u0068\\\\u0069\\\\u006a\\\\u006b\\\\u006c\\\\u006d\\\\u006e\\\\u006f\\\\u0070\\\\u0071\\\\u0072\\\\u0073\\\\u0074\\\\u0075\\\\u0076\\\\u0077\\\\u0078\\\\u0079\\\\u007a\\\\u0041\\\\u0042\\\\uxyz\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064\\\\u0065\\\\u0066\\\\u0067\\\\u0068\\\\u0069\\\\u006a\\\\u006b\\\\u006c\\\\u006d\\\\u006e\\\\u006f\\\\u0070\\\\u0071\\\\u0072\\\\u0073\\\\u0074\\\\u0075\\\\u0076\\\\u0077\\\\u0078\\\\u0079\\\\u007a\\\\u0041\\\\u0042\\\\uxyz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 28\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064\\\\u0065\\\\u0066\\\\u0067\\\\u0068\\\\u0069\\\\u006a\\\\u006b\\\\u006c\\\\u006d\\\\u006e\\\\u006f\\\\u0070\\\\u0071\\\\u0072\\\\u0073\\\\u0074\\\\u0075\\\\u0076\\\\u0077\\\\u0078\\\\u0079\\\\u007a\\\\u0041\\\\u0042\\\\u0043\\\\uxyz\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064\\\\u0065\\\\u0066\\\\u0067\\\\u0068\\\\u0069\\\\u006a\\\\u006b\\\\u006c\\\\u006d\\\\u006e\\\\u006f\\\\u0070\\\\u0071\\\\u0072\\\\u0073\\\\u0074\\\\u0075\\\\u0076\\\\u0077\\\\u0078\\\\u0079\\\\u007a\\\\u0041\\\\u0042\\\\u0043\\\\uxyz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 29\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064\\\\u0065\\\\u0066\\\\u0067\\\\u0068\\\\u0069\\\\u006a\\\\u006b\\\\u006c\\\\u006d\\\\u006e\\\\u006f\\\\u0070\\\\u0071\\\\u0072\\\\u0073\\\\u0074\\\\u0075\\\\u0076\\\\u0077\\\\u0078\\\\u0079\\\\u007a\\\\u0041\\\\u0042\\\\u0043\\\\u0044\\\\uxyz\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064\\\\u0065\\\\u0066\\\\u0067\\\\u0068\\\\u0069\\\\u006a\\\\u006b\\\\u006c\\\\u006d\\\\u006e\\\\u006f\\\\u0070\\\\u0071\\\\u0072\\\\u0073\\\\u0074\\\\u0075\\\\u0076\\\\u0077\\\\u0078\\\\u0079\\\\u007a\\\\u0041\\\\u0042\\\\u0043\\\\u0044\\\\uxyz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 30\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064\\\\u0065\\\\u0066\\\\u0067\\\\u0068\\\\u0069\\\\u006a\\\\u006b\\\\u006c\\\\u006d\\\\u006e\\\\u006f\\\\u0070\\\\u0071\\\\u0072\\\\u0073\\\\u0074\\\\u0075\\\\u0076\\\\u0077\\\\u0078\\\\u0079\\\\u007a\\\\u0041\\\\u0042\\\\u0043\\\\u0044\\\\u0045\\\\uxyz\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064\\\\u0065\\\\u0066\\\\u0067\\\\u0068\\\\u0069\\\\u006a\\\\u006b\\\\u006c\\\\u006d\\\\u006e\\\\u006f\\\\u0070\\\\u0071\\\\u0072\\\\u0073\\\\u0074\\\\u0075\\\\u0076\\\\u0077\\\\u0078\\\\u0079\\\\u007a\\\\u0041\\\\u0042\\\\u0043\\\\u0044\\\\u0045\\\\uxyz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 31\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064\\\\u0065\\\\u0066\\\\u0067\\\\u0068\\\\u0069\\\\u006a\\\\u006b\\\\u006c\\\\u006d\\\\u006e\\\\u006f\\\\u0070\\\\u0071\\\\u0072\\\\u0073\\\\u0074\\\\u0075\\\\u0076\\\\u0077\\\\u0078\\\\u0079\\\\u007a\\\\u0041\\\\u0042\\\\u0043\\\\u0044\\\\u0045\\\\u0046\\\\uxyz\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064\\\\u0065\\\\u0066\\\\u0067\\\\u0068\\\\u0069\\\\u006a\\\\u006b\\\\u006c\\\\u006d\\\\u006e\\\\u006f\\\\u0070\\\\u0071\\\\u0072\\\\u0073\\\\u0074\\\\u0075\\\\u0076\\\\u0077\\\\u0078\\\\u0079\\\\u007a\\\\u0041\\\\u0042\\\\u0043\\\\u0044\\\\u0045\\\\u0046\\\\ux",
    "706e5a0147669f36804cbc0a3f095f5e": "package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped b\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped f\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped n\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped r\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped t\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped u with valid unicode\",\n\t\t\targs: args{s: \"\\\\u0061hello\\\\u0062 world\"},\n\t\t\twant: \"ahello b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped u with invalid unicode\",\n\t\t\targs: args{s: \"\\\\u0061hello\\\\u0062 world\"},\n\t\t\twant: \"ahello b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped u with surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01hello\\\\uD83D\\\\uDE02 world\"},\n\t\t\twant: \"üòÅhelloüòÇ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped u with incomplete surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01hello\\\\uD83D world\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01hello\\\\uD83D world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped u with invalid surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01hello\\\\u0062 world\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01hello b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"unknown escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\/ \\\\u0061\\\\u0062\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\"},\n\t\t\twant: \"\\\"hello\\\" \\\\world/ abüòÅüòÇ\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "70a38a44496c23ee87fb465becf29b01": "package fastjson\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\tv   *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"marshal null\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNull},\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal true\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeTrue},\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal false\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeFalse},\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal number\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t},\n\t\t\twant: []byte(\"123\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeString, s: \"hello world\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello world\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal raw string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: typeRawString, s: \"hello world\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello world\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal array\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeString, s: \"hello\"},\n\t\t\t\t}},\n\t\t\t},\n\t\t\twant: []byte(\"[1,\\\"hello\\\"]\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal object\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeNumber, s: \"1\"}},\n\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"hello\"}},\n\t\t\t\t}}},\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":1,\"key2\":\"hello\"}`),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.v.MarshalTo(tt.args.dst); !bytes.Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "71635dd415056a10080843df1cfc642f": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no whitespace\",\n\t\t\targs: args{s: \"abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace\",\n\t\t\targs: args{s: \"  abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailing whitespace\",\n\t\t\targs: args{s: \"abc  \"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading and trailing whitespace\",\n\t\t\targs: args{s: \"  abc  \"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"whitespace in the middle\",\n\t\t\targs: args{s: \"a bc\"},\n\t\t\twant: \"bc\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple whitespace\",\n\t\t\targs: args{s: \"  a  b  c  \"},\n\t\t\twant: \"b  c  \",\n\t\t},\n\t\t{\n\t\t\tname: \"all whitespace\",\n\t\t\targs: args{s: \"   \"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"mixed whitespace\",\n\t\t\targs: args{s: \" \\t\\r\\n abc \\t\\r\\n\"},\n\t\t\twant: \"abc \\t\\r\\n\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "7230092514433d8801df7477caa09618": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantKey string\n\t\twantRem string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"simple key\",\n\t\t\targs:    args{s: `\"key\"`},\n\t\t\twantKey: \"key\",\n\t\t\twantRem: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"key with spaces\",\n\t\t\targs:    args{s: `\"key with spaces\"`},\n\t\t\twantKey: \"key with spaces\",\n\t\t\twantRem: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"key with escaped characters\",\n\t\t\targs:    args{s: `\"key\\\\\"with\\\\\"escaped\\\\\"characters\"`},\n\t\t\twantKey: \"key\\\\\\\"with\\\\\\\"escaped\\\\\\\"characters\",\n\t\t\twantRem: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"key with missing closing quote\",\n\t\t\targs:    args{s: `\"key`},\n\t\t\twantKey: \"\",\n\t\t\twantRem: \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"empty key\",\n\t\t\targs:    args{s: `\"\"`},\n\t\t\twantKey: \"\",\n\t\t\twantRem: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"key with leading and trailing spaces\",\n\t\t\targs:    args{s: `\"  key  \"`},\n\t\t\twantKey: \"  key  \",\n\t\t\twantRem: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"key with leading and trailing spaces and escaped characters\",\n\t\t\targs:    args{s: `\"  key\\\\\"with\\\\\"escaped\\\\\"characters  \"`},\n\t\t\twantKey: \"  key\\\\\\\"with\\\\\\\"escaped\\\\\\\"characters  \",\n\t\t\twantRem: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotKey, gotRem, err := parseRawKey(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawKey() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotKey != tt.wantKey {\n\t\t\t\tt.Errorf(\"parseRawKey() gotKey = %v, want %v\", gotKey, tt.wantKey)\n\t\t\t}\n\t\t\tif gotRem != tt.wantRem {\n\t\t\t\tt.Errorf(\"parseRawKey() gotRem = %v, want %v\", gotRem, tt.wantRem)\n\t\t\t}\n\t\t})\n\t}\n}",
    "724994c4227fea1f6874c6180fbf74e8": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nested_key1\": \"nested_value1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nested_key1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nested_value1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_JSON(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nested_key1\": \"nested_value1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nested_key1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nested_value1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_JSON_CompareWithStdlib(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nested_key1\": \"nested_value1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tvar want map[string]interface{}\n\t\t\tif err := json.Unmarshal([]byte(tt.args.s), \u0026want); err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got.o.kvs, want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got.o.kvs, want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "728d133d01cc468ecfd0317cc4c69179": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t\t{\n\t\t\tname: \"Parse null\",\n\t\t\targs: args{\n\t\t\t\ts: \"null\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Parse true\",\n\t\t\targs: args{\n\t\t\t\ts: \"true\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Parse false\",\n\t\t\targs: args{\n\t\t\t\ts: \"false\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Parse string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello\\\"\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Parse number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Parse object\",\n\t\t\targs: args{\n\t\t\t\ts: `{\"key1\": \"value1\", \"key2\": 123}`,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Parse array\",\n\t\t\targs: args{\n\t\t\t\ts: `[\"value1\", 123]`,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Parse invalid JSON\",\n\t\t\targs: args{\n\t\t\t\ts: `{`,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tp := \u0026Parser{}\n\t\t\tgot, err := p.Parse(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Parse() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr {\n\t\t\t\tif !compareValues(got, tt.want) {\n\t\t\t\t\tt.Errorf(\"Parse() = %v, want %v\", got, tt.want)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeNull:\n\t\treturn true\n\tcase TypeTrue:\n\t\treturn true\n\tcase TypeFalse:\n\t\treturn true\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !compareValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !compareValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc TestParse_CompareWithStdlib(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t}{\n\t\t{\n\t\t\tname: \"Parse null\",\n\t\t\targs: args{\n\t\t\t\ts: \"null\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"Parse true\",\n\t\t\targs: args{\n\t\t\t\ts: \"true\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"Parse false\",\n\t\t\targs: args{\n\t\t\t\ts: \"false\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"Parse string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello\\\"\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"Parse number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"Parse object\",\n\t\t\targs: args{\n\t\t\t\ts: `{\"key1\": \"value1\", \"key2\": 123}`,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"Parse array\",\n\t\t\targs: args{\n\t\t\t\ts: `[\"value1\", 123]`,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tp := \u0026Parser{}\n\t\t\tgot, err := p.Parse(tt.args.s)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Parse() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tvar want interface{}\n\t\t\tif err := json.Unmarshal([]byte(tt.args.s), \u0026want); err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !compareValuesWithStdlib(got, want) {\n\t\t\t\tt.Errorf(\"Parse() = %v, want %v\", got, want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValuesWithStdlib(v *Value, want interface{}) bool {\n\tswitch want := want.(type) {\n\tcase nil:\n\t\treturn v.t == TypeNull\n\tcase bool:\n\t\tif want {\n\t\t\treturn v.t == TypeTrue\n\t\t} else {\n\t\t\treturn v.t == TypeFalse\n\t\t}\n\tcase string:\n\t\treturn v.t == TypeString \u0026\u0026 v.s == want\n\tcase float64:\n\t\treturn v.t == TypeNumber \u0026\u0026 v.s == fmt.Sprintf(\"%f\", want)\n\tcase []interface{}:\n\t\tif v.t != TypeArray {\n\t\t\treturn false\n\t\t}\n\t\tif len(v.a) != len(want) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v.a {\n\t\t\tif !compareValuesWithStdlib(v.a[i], want[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase map[string]interface{}:\n\t\tif v.t != TypeObject {\n\t\t\treturn false\n\t\t}\n\t\tif len(v.o.kvs) != len(want) {\n\t\t\treturn false\n\t\t}\n\t\tfor k, v2 := range want {\n\t\t\tfor i := range v.o.kvs {\n\t\t\t\tif v.o.kvs[i].k == k {\n\t\t\t\t\tif !compareValuesWithStdlib(v.o.kvs[i].v, v2) {\n\t\t\t\t\t\treturn false\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}",
    "73637f7e1e8efbc7668ced1b35bb1c13": "package fastjson\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\tv   *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"marshal null\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNull},\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal true\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeTrue},\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal false\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeFalse},\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeString, s: \"hello\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal number\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t},\n\t\t\twant: []byte(\"123\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal raw string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: typeRawString, s: \"hello\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal array\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{t: TypeString, s: \"hello\"},\n\t\t\t\t\t\t{t: TypeNumber, s: \"123\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"[\\\"hello\\\",123]\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal object\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{k: \"name\", v: \u0026Value{t: TypeString, s: \"John Doe\"}},\n\t\t\t\t\t\t\t{k: \"age\", v: \u0026Value{t: TypeNumber, s: \"30\"}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`{\"name\":\"John Doe\",\"age\":30}`),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.v.MarshalTo(tt.args.dst); !bytes.Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "73e81573c1097aa5d3bc8873077efe2d": "package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u006\"},\n\t\t\twant: \"\\\\u0061\\\\u006\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\\\\\ \\\\/\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\x\\\\u006\"},\n\t\t\twant: \"\\\"hello\\\" \\\\world\\\\ /\\\\b\\\\f\\\\n\\\\r\\tabcüòÅ\\\\x\\\\u006\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "73e9cfe5e08926c7976321a2a9cd9a45": "```go\npackage fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"{}\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\": \"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"value1\", \"value2\"]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"value\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"value\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   `true`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueTrue,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   `false`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueFalse,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   `null`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueNull,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with decimal\",\n\t\t\targs: args{\n\t\t\t\ts:   `123.456`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e+4`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e-4`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"1.23e-4\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `-123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zero\",\n\t\t\targs: args{\n\t\t\t\ts:   `0123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"0123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with trailing zero\",\n\t\t\targs: args{\n\t\t\t\ts:   `123.0`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123.0\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   `NaN`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with Infinity\",\n\t\t\targs: args{\n\t\t\t\ts:   `Infinity`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"Infinity\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative Infinity\",\n\t\t\targs: args{\n\t\t\t\ts:   `-Infinity`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-Infinity\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123.456.789`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123.456.789\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e+4.5`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e+4.5\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e-4.5`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e-4.5\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading zero\",\n\t\t\targs: args{\n\t\t\t\ts:   `00123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"00123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing zero\",\n\t\t\targs: args{\n\t\t\t\ts:   `123.00`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123.00\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading dot\",\n\t\t\targs: args{\n\t\t\t\ts:   `.123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \".123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing dot\",\n\t\t\targs: args{\n\t\t\t\ts:   `123.`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123.\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with multiple dots\",\n\t\t\targs: args{\n\t\t\t\ts:   `123.456.789`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123.456.789\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with multiple exponents\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e+4e+5`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e+4e+5\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with multiple signs\",\n\t\t\targs: args{\n\t\t\t\ts:   `-123-+456`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"-123-+456\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `+123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"+123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing plus sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `123+`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123+\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `-123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing minus sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `123-`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123-\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading space\",\n\t\t\targs: args{\n\t\t\t\ts:   ` 123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \" 123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing space\",\n\t\t\targs: args{\n\t\t\t\ts:   `123 `,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123 \",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading comma\",\n\t\t\targs: args{\n\t\t\t\ts:   `,123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \",123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing comma\",\n\t\t\targs: args{\n\t\t\t\ts:   `123,`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123,\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading colon\",\n\t\t\targs: args{\n\t\t\t\ts:   `:123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \":123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing colon\",\n\t\t\targs: args{\n\t\t\t\ts:   `123:`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123:\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading bracket\",\n\t\t\targs: args{\n\t\t\t\ts:   `[123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:   `123]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123]\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading brace\",\n\t\t\targs: args{\n\t\t\t\ts:   `{123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"{123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing brace\",\n\t\t\targs: args{\n\t\t\t\ts:   `123}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123}\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading quote\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `\"123`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing quote\",\n\t\t\targs: args{\n\t\t\t\ts:   `123\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123\\\"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading slash\",\n\t\t\targs: args{\n\t\t\t\ts:   `/123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"/123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing slash\",\n\t\t\targs: args{\n\t\t\t\ts:   `123/`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123/\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading backslash\",\n\t\t\targs: args{\n\t\t\t\ts:   `\\123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `\\123`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing backslash\",\n\t\t\targs: args{\n\t\t\t\ts:   `123\\`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123\\\\\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading question mark\",\n\t\t\targs: args{\n\t\t\t\ts:   `?123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"?123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing question mark\",\n\t\t\targs: args{\n\t\t\t\ts:   `123?`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123?\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading exclamation mark\",\n\t\t\targs: args{\n\t\t\t\ts:   `!123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"!123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing exclamation mark\",\n\t\t\targs: args{\n\t\t\t\ts:   `123!`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123!\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading at sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `@123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"@123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing at sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `123@`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123@\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading hash sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `#123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"#123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing hash sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `123#`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123#\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading dollar sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `$123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"$123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing dollar sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `123$`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123$\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading percent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `%123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"%123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing percent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `123%`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123%\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading caret sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `^123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"^123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing caret sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `123^`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123^\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading ampersand sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `\u0026123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\u0026123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing ampersand sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `123\u0026`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123\u0026\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading asterisk sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `*123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"*123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing asterisk sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `123*`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123*\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading parenthesis\",\n\t\t\targs: args{\n\t\t\t\ts:   `(123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"(123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing parenthesis\",\n\t\t\targs: args{\n\t\t\t\ts:   `123)`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123)\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading underscore\",\n\t\t\targs: args{\n\t\t\t\ts:   `_123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"_123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing underscore\",\n\t\t\targs: args{\n\t\t\t\ts:   `123_`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123_\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading hyphen\",\n\t\t\targs: args{\n\t\t\t\ts:   `-123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing hyphen\",\n\t\t\targs: args{\n\t\t\t\ts:   `123-`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123-\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `+123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"+123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing plus sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `123+`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123+\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading equal sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `=123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"=123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing equal sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `123=`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123=\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading less than sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `\u003c123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\u003c123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing less than sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `123\u003c`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123\u003c\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading greater than sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `\u003e123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\u003e123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing greater than sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `123\u003e`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123\u003e\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading pipe sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `|123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"|123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing pipe sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `123|`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123|\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading semicolon\",\n\t\t\targs: args{\n\t\t\t\ts:   `;123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \";123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing semicolon\",\n\t\t\targs: args{\n\t\t\t\ts:   `123;`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123;\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading single quote\",\n\t\t\targs: args{\n\t\t\t\ts:   `'123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"'123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing single quote\",\n\t\t\targs: args{\n\t\t\t\ts:   `123'`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123'\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading double quote\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `\"123`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing double quote\",\n\t\t\targs: args{\n\t\t\t\ts:   `123\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123\\\"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading backtick\",\n\t\t\targs: args{\n\t\t\t\ts:   \"`123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"`123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing backtick\",\n\t\t\targs: args{\n\t\t\t\ts:   `123` + \"`\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123\" + \"`\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading tilde\",\n\t\t\targs: args{\n\t\t\t\ts:   `~123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `~123`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing tilde\",\n\t\t\targs: args{\n\t\t\t\ts:   `123~`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123~\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr {\n\t\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t\t}\n\t\t\t\tif got1 != tt.want1 {\n\t\t\t\t\tt.Errorf(\"parseValue() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseValue_JSON(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\": \"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `{\"key\":\"value\"}`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"value1\", \"value2\"]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `[\"value1\",\"value2\"]`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"value\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `\"value\"`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   `true`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `true`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   `false`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `false`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\t",
    "7401629604b0f70bcbc19d96baaedff5": "package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u006\"},\n\t\t\twant: \"\\\\u0061\\\\u006\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\\\\\ \\\\/\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\x\\\\u006\"},\n\t\t\twant: \"\\\"hello\\\" \\\\world\\\\ /\\\\b\\\\f\\\\n\\\\r\\\\tabcüòÅ\\\\x\\\\u006\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "74d7cae76125b8d48ca978cf0f627552": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no whitespace\",\n\t\t\targs: args{s: \"abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace\",\n\t\t\targs: args{s: \"  abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailing whitespace\",\n\t\t\targs: args{s: \"abc  \"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading and trailing whitespace\",\n\t\t\targs: args{s: \"  abc  \"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"whitespace in the middle\",\n\t\t\targs: args{s: \"a bc\"},\n\t\t\twant: \"bc\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple whitespace\",\n\t\t\targs: args{s: \"  a  b  c  \"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"newline\",\n\t\t\targs: args{s: \"\\n abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"tab\",\n\t\t\targs: args{s: \"\\tabc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"carriage return\",\n\t\t\targs: args{s: \"\\r abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"all whitespace\",\n\t\t\targs: args{s: \"  \\n\\t\\r  \"},\n\t\t\twant: \"\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "753a7a1e99cdb1733921791f2452aeb5": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"single element array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"hello\"]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"hello\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"hello\", \"world\", 123]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"hello\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"world\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[[\"hello\", \"world\"], 123]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"hello\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"world\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:   `[1, 2, 3`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `[1, 2, 3`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:   `[1 2, 3]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `[1 2, 3]`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseArray() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "75777daeca0c7bd8df52b21d1b780eff": "```go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\tv   *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"marshal null\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNull},\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal true\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeTrue},\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal false\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeFalse},\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal number\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t},\n\t\t\twant: []byte(\"123\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeString, s: \"hello world\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello world\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal raw string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: type",
    "7687ecf07cfcfde6c5776872c4fb9d33": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttype want struct {\n\t\tv   *Value\n\t\ttail string\n\t\terr  error\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant want\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  fmt.Errorf(\"cannot parse empty string\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"{}\",\n\t\t\t\terr:  fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\": \"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"value1\", \"value2\"]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"value\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeString,\n\t\t\t\t\ts: \"value\",\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   `true`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueTrue,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   `false`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueFalse,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   `null`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueNull,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"123\",\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   `NaN`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"NaN\",\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotV, gotTail, gotErr := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (gotErr == nil) != (tt.want.err == nil) {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", gotErr, tt.want.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotErr != nil \u0026\u0026 tt.want.err != nil {\n\t\t\t\tif gotErr.Error() != tt.want.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", gotErr, tt.want.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(gotV, tt.want.v) {\n\t\t\t\tt.Errorf(\"parseValue() gotV = %v, want %v\", gotV, tt.want.v)\n\t\t\t}\n\t\t\tif gotTail != tt.want.tail {\n\t\t\t\tt.Errorf(\"parseValue() gotTail = %v, want %v\", gotTail, tt.want.tail)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseValue_JSON(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttype want struct {\n\t\tv   *Value\n\t\terr  error\n\t\twant string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant want\n\t}{\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts: `{\"key\": \"value\"}`,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\terr:  nil,\n\t\t\t\twant: `{\"key\":\"value\"}`,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts: `[\"value1\", \"value2\"]`,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\terr:  nil,\n\t\t\t\twant: `[\"value1\",\"value2\"]`,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"value\"`,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\terr:  nil,\n\t\t\t\twant: `\"value\"`,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts: `true`,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\terr:  nil,\n\t\t\t\twant: `true`,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts: `false`,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\terr:  nil,\n\t\t\t\twant: `false`,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts: `null`,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\terr:  nil,\n\t\t\t\twant: `null`,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts: `123`,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\terr:  nil,\n\t\t\t\twant: `123`,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts: `NaN`,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\terr:  nil,\n\t\t\t\twant: `NaN`,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgotV, _, gotErr := parseValue(tt.args.s, c, 0)\n\t\t\tif (gotErr == nil) != (tt.want.err == nil) {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", gotErr, tt.want.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotErr != nil \u0026\u0026 tt.want.err != nil {\n\t\t\t\tif gotErr.Error() != tt.want.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", gotErr, tt.want.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\tif gotV != nil {\n\t\t\t\tb, err := json.Marshal(gotV)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"parseValue() json.Marshal() error = %v\", err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif string(b) != tt.want.want {\n\t\t\t\t\tt.Errorf(\"parseValue() gotV = %v, want %v\", string(b), tt.want.want)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}",
    "76c88dee15d18184fd5aae3fde728d6e": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quotes and other characters\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"\\\\\\\\\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\\\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: ``,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with no quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `hello`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "76f5fd995e906a4073d48604a7268b3e": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttype want struct {\n\t\tv   *Value\n\t\ttail string\n\t\terr  error\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant want\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  fmt.Errorf(\"cannot parse empty string\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"{}\",\n\t\t\t\terr:  fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{t: TypeObject, o: Object{}},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{t: TypeArray, a: []*Value{}},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"hello\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{t: typeRawString, s: \"hello\"},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   \"true\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueTrue,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   \"false\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueFalse,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   \"null\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueNull,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   \"123\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   \"NaN\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"NaN\"},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotV, gotTail, gotErr := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif gotErr != nil \u0026\u0026 tt.want.err == nil {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, want nil\", gotErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotErr == nil \u0026\u0026 tt.want.err != nil {\n\t\t\t\tt.Errorf(\"parseValue() error = nil, want %v\", tt.want.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotErr != nil \u0026\u0026 tt.want.err != nil {\n\t\t\t\tif gotErr.Error() != tt.want.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue() error = %v, want %v\", gotErr, tt.want.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(gotV, tt.want.v) {\n\t\t\t\tt.Errorf(\"parseValue() gotV = %v, want %v\", gotV, tt.want.v)\n\t\t\t}\n\t\t\tif gotTail != tt.want.tail {\n\t\t\t\tt.Errorf(\"parseValue() gotTail = %v, want %v\", gotTail, tt.want.tail)\n\t\t\t}\n\t\t})\n\t}\n}",
    "77bce0e6590e4b18937b930f84c13ca1": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped string with multiple escapes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\"\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: ``,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with no quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `hello`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote\",\n\t\t\targs: args{\n\t\t\t\ts: `hello\\\\\"world`,\n\t\t\t},\n\t\t\twant:    `hello\\\\\"world`,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "782108c696836cbdae2916bc481df792": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"single element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,3]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[[1,2],[3,4]]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"4\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with string\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[\\\"hello\\\", \\\"world\\\"]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"hello\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"world\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[{ \\\"key\\\": \\\"value\\\" }, { \\\"key2\\\": \\\"value2\\\" }]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1 2]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \" 2]\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"array with missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseArray() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "786947ac52c4718b1416b399695b5978": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"single element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,3]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[[1,2],[3,4]]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"4\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with string\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[\\\"hello\\\", \\\"world\\\"]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"hello\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"world\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with object\",\n\t\t\targs: args{\n\t\t\t\ts:    `[{\"key1\": \"value1\"}, {\"key2\": \"value2\"}]`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1,2\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1 2]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1 2]\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid value\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1,2,\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseArray() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "798be09ae942c932c643af314a791107": "```go\npackage fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 2\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 3\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 4\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\u\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\u\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 5\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\u123\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\u123\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 6\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 7\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u123\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u123\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 8\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 9\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\u\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\u\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 10\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\u123\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\u123\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 11\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\u\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\u\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 12\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\u123\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\u123\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 13\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 14\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\u\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\u\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 15\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\u123\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\u123\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 16\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\u\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\u\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 17\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\u123\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\u123\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 18\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 19\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\u\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\u\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 20\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\u123\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\u123\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 21\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\u\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\u\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 22\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\u123\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\u123\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 23\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 24\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\u\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\u\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 25\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\u123\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\u123\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 26\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\u\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\u\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 27\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\u123\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\u123\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 28\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 29\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\u\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\u\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 30\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\u123\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\u123\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 31\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\u\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\u\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 32\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\u123\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\u123\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 33\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 34\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\u\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\u\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 35\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\u123\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\u123\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 36\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\u\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\u\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 37\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\u123\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\u123\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 38\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 39\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\u\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\u\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 40\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\u123\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\u123\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 41\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\u\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\u\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 42\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\u123\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\u123\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 43\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 44\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\u\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\u\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 45\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\u123\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\u123\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 46\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\u\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\u\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 47\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE01\\\\u123\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\uD",
    "79d8078e796dcbcc4dd823f358ec52aa": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"single element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,3]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[[1,2],[3,4]]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"4\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with string\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[\\\"hello\\\", \\\"world\\\"]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"hello\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"world\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[{\\\"key1\\\": 1}, {\\\"key2\\\": 2}]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1,2\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1 2]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1 2]\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid value\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,invalid]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1,2,invalid]\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseArray() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "7a92821e0adc82cb85ceea8247358d8a": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nested_key1\": \"nested_value1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nested_key1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nested_value1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\" \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "7ae139e99d6004412db527f5cec86730": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantKey string\n\t\twantRem string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"simple key\",\n\t\t\targs:    args{s: `\"key\"`},\n\t\t\twantKey: \"key\",\n\t\t\twantRem: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"key with spaces\",\n\t\t\targs:    args{s: `\"key with spaces\"`},\n\t\t\twantKey: \"key with spaces\",\n\t\t\twantRem: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"key with special characters\",\n\t\t\targs:    args{s: `\"key\\\\\"with\\\\\"special\\\\\"characters\"`},\n\t\t\twantKey: \"key\\\\\\\"with\\\\\\\"special\\\\\\\"characters\",\n\t\t\twantRem: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"key with escaped quotes\",\n\t\t\targs:    args{s: `\"key\\\\\"with\\\\\"escaped\\\\\"quotes\"`},\n\t\t\twantKey: \"key\\\\\\\"with\\\\\\\"escaped\\\\\\\"quotes\",\n\t\t\twantRem: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"missing closing quote\",\n\t\t\targs:    args{s: `\"key`},\n\t\t\twantKey: \"key\",\n\t\t\twantRem: \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"empty key\",\n\t\t\targs:    args{s: `\"\"`},\n\t\t\twantKey: \"\",\n\t\t\twantRem: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"key with escaped backslash\",\n\t\t\targs:    args{s: `\"key\\\\\\\\\"`},\n\t\t\twantKey: \"key\\\\\\\\\",\n\t\t\twantRem: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotKey, gotRem, err := parseRawKey(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawKey() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotKey != tt.wantKey {\n\t\t\t\tt.Errorf(\"parseRawKey() gotKey = %v, want %v\", gotKey, tt.wantKey)\n\t\t\t}\n\t\t\tif gotRem != tt.wantRem {\n\t\t\t\tt.Errorf(\"parseRawKey() gotRem = %v, want %v\", gotRem, tt.wantRem)\n\t\t\t}\n\t\t})\n\t}\n}",
    "7b0eb03b9c3c5c2a59058e32333f3f39": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantKey string\n\t\twantTail string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"simple key\",\n\t\t\targs:    args{s: `\"key\"`},\n\t\t\twantKey: \"key\",\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"key with spaces\",\n\t\t\targs:    args{s: `\"key with spaces\"`},\n\t\t\twantKey: \"key with spaces\",\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"key with special characters\",\n\t\t\targs:    args{s: `\"key\\\\\"with\\\\\"special\\\\\"characters\"`},\n\t\t\twantKey: \"key\\\\\\\"with\\\\\\\"special\\\\\\\"characters\",\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"key with escaped quotes\",\n\t\t\targs:    args{s: `\"key\\\\\"\"`},\n\t\t\twantKey: \"key\\\"\",\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"missing closing quote\",\n\t\t\targs:    args{s: `\"key`},\n\t\t\twantKey: \"key\",\n\t\t\twantTail: \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"empty key\",\n\t\t\targs:    args{s: `\"\"`},\n\t\t\twantKey: \"\",\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"key with escaped backslash\",\n\t\t\targs:    args{s: `\"key\\\\\\\\\"`},\n\t\t\twantKey: \"key\\\\\",\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"key with escaped forward slash\",\n\t\t\targs:    args{s: `\"key\\\\/\"`},\n\t\t\twantKey: \"key/\",\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"key with escaped b\",\n\t\t\targs:    args{s: `\"key\\\\b\"`},\n\t\t\twantKey: \"key\\b\",\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"key with escaped f\",\n\t\t\targs:    args{s: `\"key\\\\f\"`},\n\t\t\twantKey: \"key\\f\",\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"key with escaped n\",\n\t\t\targs:    args{s: `\"key\\\\n\"`},\n\t\t\twantKey: \"key\\n\",\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"key with escaped r\",\n\t\t\targs:    args{s: `\"key\\\\r\"`},\n\t\t\twantKey: \"key\\r\",\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"key with escaped t\",\n\t\t\targs:    args{s: `\"key\\\\t\"`},\n\t\t\twantKey: \"key\\t\",\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"key with escaped u\",\n\t\t\targs:    args{s: `\"key\\\\u0020\"`},\n\t\t\twantKey: \"key \",\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotKey, gotTail, err := parseRawKey(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawKey() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotKey != tt.wantKey {\n\t\t\t\tt.Errorf(\"parseRawKey() gotKey = %v, want %v\", gotKey, tt.wantKey)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseRawKey() gotTail = %v, want %v\", gotTail, tt.wantTail)\n\t\t\t}\n\t\t})\n\t}\n}",
    "7be990ce79cb1a8b124a128d9ab3387a": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped backslashes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\\world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped control characters\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\b\\\\f\\\\n\\\\r\\\\tworld\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\b\\f\\n\\r\\tworld\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with extra closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\"`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "7c09caf0ea87aa843bac1becd45191fc": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{\\\"a\\\": 1}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"{\\\"a\\\": 1}\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{\\\"a\\\": 1}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"a\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[1, 2, 3]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\\\"hello\\\"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   \"true\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueTrue,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   \"false\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueFalse,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   \"null\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueNull,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   \"123\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   \"NaN\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseValue() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseValue_JSON(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    interface{}\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts: \"{\\\"a\\\": 1}\",\n\t\t\t},\n\t\t\twant:    map[string]interface{}{\"a\": float64(1)},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts: \"[1, 2, 3]\",\n\t\t\t},\n\t\t\twant:    []interface{}{float64(1), float64(2), float64(3)},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello\\\"\",\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts: \"true\",\n\t\t\t},\n\t\t\twant:    true,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts: \"false\",\n\t\t\t},\n\t\t\twant:    false,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts: \"null\",\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant:    float64(123),\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twant:    json.Number(\"NaN\"),\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, _, err := parseValue(tt.args.s, c, 0)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got.Interface(), tt.want) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got.Interface(), tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "7ca549d288828fbe5328bbd86e0db62a": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escaped strings\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: ``,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with no quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `hello`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "7dad3b1c46ec53aac2f667a5953c1862": "```go\npackage fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\uxyz\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\uxyz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 2\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064\\\\u0065\\\\u0066\\\\u0067\\\\u0068\\\\u0069\\\\u006a\\\\u006b\\\\u006c\\\\u006d\\\\u006e\\\\u006f\\\\u0070\\\\u0071\\\\u0072\\\\u0073\\\\u0074\\\\u0075\\\\u0076\\\\u0077\\\\u0078\\\\u0079\\\\u007a\\\\u0080\\\\u0081\\\\u0082\\\\u0083\\\\u0084\\\\u0085\\\\u0086\\\\u0087\\\\u0088\\\\u0089\\\\u008a\\\\u008b\\\\u008c\\\\u008d\\\\u008e\\\\u008f\\\\u0090\\\\u0091\\\\u0092\\\\u0093\\\\u0094\\\\u0095\\\\u0096\\\\u0097\\\\u0098\\\\u0099\\\\u009a\\\\u009b\\\\u009c\\\\u009d\\\\u009e\\\\u009f\\\\u00a0\\\\u00a1\\\\u00a2\\\\u00a3\\\\u00a4\\\\u00a5\\\\u00a6\\\\u00a7\\\\u00a8\\\\u00a9\\\\u00aa\\\\u00ab\\\\u00ac\\\\u00ad\\\\u00ae\\\\u00af\\\\u00b0\\\\u00b1\\\\u00b2\\\\u00b3\\\\u00b4\\\\u00b5\\\\u00b6\\\\u00b7\\\\u00b8\\\\u00b9\\\\u00ba\\\\u00bb\\\\u00bc\\\\u00bd\\\\u00be\\\\u00bf\\\\u00c0\\\\u00c1\\\\u00c2\\\\u00c3\\\\u00c4\\\\u00c5\\\\u00c6\\\\u00c7\\\\u00c8\\\\u00c9\\\\u00ca\\\\u00cb\\\\u00cc\\\\u00cd\\\\u00ce\\\\u00cf\\\\u00d0\\\\u00d1\\\\u00d2\\\\u00d3\\\\u00d4\\\\u00d5\\\\u00d6\\\\u00d7\\\\u00d8\\\\u00d9\\\\u00da\\\\u00db\\\\u00dc\\\\u00dd\\\\u00de\\\\u00df\\\\u00e0\\\\u00e1\\\\u00e2\\\\u00e3\\\\u00e4\\\\u00e5\\\\u00e6\\\\u00e7\\\\u00e8\\\\u00e9\\\\u00ea\\\\u00eb\\\\u00ec\\\\u00ed\\\\u00ee\\\\u00ef\\\\u00f0\\\\u00f1\\\\u00f2\\\\u00f3\\\\u00f4\\\\u00f5\\\\u00f6\\\\u00f7\\\\u00f8\\\\u00f9\\\\u00fa\\\\u00fb\\\\u00fc\\\\u00fd\\\\u00fe\\\\u00ff\\\\u0100\\\\u0101\\\\u0102\\\\u0103\\\\u0104\\\\u0105\\\\u0106\\\\u0107\\\\u0108\\\\u0109\\\\u010a\\\\u010b\\\\u010c\\\\u010d\\\\u010e\\\\u010f\\\\u0110\\\\u0111\\\\u0112\\\\u0113\\\\u0114\\\\u0115\\\\u0116\\\\u0117\\\\u0118\\\\u0119\\\\u011a\\\\u011b\\\\u011c\\\\u011d\\\\u011e\\\\u011f\\\\u0120\\\\u0121\\\\u0122\\\\u0123\\\\u0124\\\\u0125\\\\u0126\\\\u0127\\\\u0128\\\\u0129\\\\u012a\\\\u012b\\\\u012c\\\\u012d\\\\u012e\\\\u012f\\\\u0130\\\\u0131\\\\u0132\\\\u0133\\\\u0134\\\\u0135\\\\u0136\\\\u0137\\\\u0138\\\\u0139\\\\u013a\\\\u013b\\\\u013c\\\\u013d\\\\u013e\\\\u013f\\\\u0140\\\\u0141\\\\u0142\\\\u0143\\\\u0144\\\\u0145\\\\u0146\\\\u0147\\\\u0148\\\\u0149\\\\u014a\\\\u014b\\\\u014c\\\\u014d\\\\u014e\\\\u014f\\\\u0150\\\\u0151\\\\u0152\\\\u0153\\\\u0154\\\\u0155\\\\u0156\\\\u0157\\\\u0158\\\\u0159\\\\u015a\\\\u015b\\\\u015c\\\\u015d\\\\u015e\\\\u015f\\\\u0160\\\\u0161\\\\u0162\\\\u0163\\\\u0164\\\\u0165\\\\u0166\\\\u0167\\\\u0168\\\\u0169\\\\u016a\\\\u016b\\\\u016c\\\\u016d\\\\u016e\\\\u016f\\\\u0170\\\\u0171\\\\u0172\\\\u0173\\\\u0174\\\\u0175\\\\u0176\\\\u0177\\\\u0178\\\\u0179\\\\u017a\\\\u017b\\\\u017c\\\\u017d\\\\u017e\\\\u017f\\\\u0180\\\\u0181\\\\u0182\\\\u0183\\\\u0184\\\\u0185\\\\u0186\\\\u0187\\\\u0188\\\\u0189\\\\u018a\\\\u018b\\\\u018c\\\\u018d\\\\u018e\\\\u018f\\\\u0190\\\\u0191\\\\u0192\\\\u0193\\\\u0194\\\\u0195\\\\u0196\\\\u0197\\\\u0198\\\\u0199\\\\u019a\\\\u019b\\\\u019c\\\\u019d\\\\u019e\\\\u019f\\\\u01a0\\\\u01a1\\\\u01a2\\\\u01a3\\\\u01a4\\\\u01a5\\\\u01a6\\\\u01a7\\\\u01a8\\\\u01a9\\\\u01aa\\\\u01ab\\\\u01ac\\\\u01ad\\\\u01ae\\\\u01af\\\\u01b0\\\\u01b1\\\\u01b2\\\\u01b3\\\\u01b4\\\\u01b5\\\\u01b6\\\\u01b7\\\\u01b8\\\\u01b9\\\\u01ba\\\\u01bb\\\\u01bc\\\\u01bd\\\\u01be\\\\u01bf\\\\u01c0\\\\u01c1\\\\u01c2\\\\u01c3\\\\u01c4\\\\u01c5\\\\u01c6\\\\u01c7\\\\u01c8\\\\u01c9\\\\u01ca\\\\u01cb\\\\u01cc\\\\u01cd\\\\u01ce\\\\u01cf\\\\u01d0\\\\u01d1\\\\u01d2\\\\u01d3\\\\u01d4\\\\u01d5\\\\u01d6\\\\u01d7\\\\u01d8\\\\u01d9\\\\u01da\\\\u01db\\\\u01dc\\\\u01dd\\\\u01de\\\\u01df\\\\u01e0\\\\u01e1\\\\u01e2\\\\u01e3\\\\u01e4\\\\u01e5\\\\u01e6\\\\u01e7\\\\u01e8\\\\u01e9\\\\u01ea\\\\u01eb\\\\u01ec\\\\u01ed\\\\u01ee\\\\u01ef\\\\u01f0\\\\u01f1\\\\u01f2\\\\u01f3\\\\u01f4\\\\u01f5\\\\u01f6\\\\u01f7\\\\u01f8\\\\u01f9\\\\u01fa\\\\u01fb\\\\u01fc\\\\u01fd\\\\u01fe\\\\u01ff\\\\u0200\\\\u0201\\\\u0202\\\\u0203\\\\u0204\\\\u0205\\\\u0206\\\\u0207\\\\u0208\\\\u0209\\\\u020a\\\\u020b\\\\u020c\\\\u020d\\\\u020e\\\\u020f\\\\u0210\\\\u0211\\\\u0212\\\\u0213\\\\u0214\\\\u0215\\\\u0216\\\\u0217\\\\u0218\\\\u0219\\\\u021a\\\\u021b\\\\u021c\\\\u021d\\\\u021e\\\\u021f\\\\u0220\\\\u0221\\\\u0222\\\\u0223\\\\u0224\\\\u0225\\\\u0226\\\\u0227\\\\u0228\\\\u0229\\\\u022a\\\\u022b\\\\u022c\\\\u022d\\\\u022e\\\\u022f\\\\u0230\\\\u0231\\\\u0232\\\\u0233\\\\u0234\\\\u0235\\\\u0236\\\\u0237\\\\u0238\\\\u0239\\\\u023a\\\\u023b\\\\u023c\\\\u023d\\\\u023e\\\\u023f\\\\u0240\\\\u0241\\\\u0242\\\\u0243\\\\u0244\\\\u0245\\\\u0246\\\\u0247\\\\u0248\\\\u0249\\\\u024a\\\\u024b\\\\u024c\\\\u024d\\\\u024e\\\\u024f\\\\u0250\\\\u0251\\\\u0252\\\\u0253\\\\u0254\\\\u0255\\\\u0256\\\\u0257\\\\u0258\\\\u0259\\\\u025a\\\\u025b\\\\u025c\\\\u025d\\\\u025e\\\\u025f\\\\u0260\\\\u0261\\\\u0262\\\\u0263\\\\u0264\\\\u0265\\\\u0266\\\\u0267\\\\u0268\\\\u0269\\\\u026a\\\\u026b\\\\u026c\\\\u026d\\\\u026e\\\\u026f\\\\u0270\\\\u0271\\\\u0272\\\\u0273\\\\u0274\\\\u0275\\\\u0276\\\\u0277\\\\u0278\\\\u0279\\\\u027a\\\\u027b\\\\u027c\\\\u027d\\\\u027e\\\\u027f\\\\u0280\\\\u0281\\\\u0282\\\\u0283\\\\u0284\\\\u0285\\\\u0286\\\\u0287\\\\u0288\\\\u0289\\\\u028a\\\\u028b\\\\u028c\\\\u028d\\\\u028e\\\\u028f\\\\u0290\\\\u0291\\\\u0292\\\\u0293\\\\u0294\\\\u0295\\\\u0296\\\\u0297\\\\u0298\\\\u0299\\\\u029a\\\\u029b\\\\u029c\\\\u029d\\\\u029e\\\\u029f\\\\u02a0\\\\u02a1\\\\u02a2\\\\u02a3\\\\u02a4\\\\u02a5\\\\u02a6\\\\u02a7\\\\u02a8\\\\u02a9\\\\u02aa\\\\u02ab\\\\u02ac\\\\u02ad\\\\u02ae\\\\u02af\\\\u02b0\\\\u02b1\\\\u02b2\\\\u02b3\\\\u02b4\\\\u02b5\\\\u02b6\\\\u02b7\\\\u02b8\\\\u02b9\\\\u02ba\\\\u02bb\\\\u02bc\\\\u02bd\\\\u02be\\\\u02bf\\\\u02c0\\\\u02c1\\\\u02c2\\\\u02c3\\\\u02c4\\\\u02c5\\\\u02c6\\\\u02c7\\\\u02c8\\\\u02c9\\\\u02ca\\\\u02cb\\\\u02cc\\\\u02cd\\\\u02ce\\\\u02cf\\\\u02d0\\\\u02d1\\\\u02d2\\\\u02d3\\\\u02d4\\\\u02d5\\\\u02d6\\\\u02d7\\\\u02d8\\\\u02d9\\\\u02da\\\\u02db\\\\u02dc\\\\u02dd\\\\u02de\\\\u02df\\\\u02e0\\\\u02e1\\\\u02e2\\\\u02e3\\\\u02e4\\\\u02e5\\\\u02e6\\\\u02e7\\\\u02e8\\\\u02e9\\\\u02ea\\\\u02eb\\\\u02ec\\\\u02ed\\\\u02ee\\\\u02ef\\\\u02f0\\\\u02f1\\\\u02f2\\\\u02f3\\\\u02f4\\\\u02f5\\\\u02f6\\\\u02f7\\\\u02f8\\\\u02f9\\\\u02fa\\\\u02fb\\\\u02fc\\\\u02fd\\\\u02fe\\\\u02ff\\\\u0300\\\\u0301\\\\u0302\\\\u0303\\\\u0304\\\\u0305\\\\u0306\\\\u0307\\\\u0308\\\\u0309\\\\u030a\\\\u030b\\\\u030c\\\\u030d\\\\u030e\\\\u030f\\\\u0310\\\\u0311\\\\u0312\\\\u0313\\\\u0314\\\\u0315\\\\u0316\\\\u0317\\\\u0318\\\\u0319\\\\u031a\\\\u031b\\\\u031c\\\\u031d\\\\u031e\\\\u031f\\\\u0320\\\\u0321\\\\u0322\\\\u0323\\\\u0324\\\\u0325\\\\u0326\\\\u0327\\\\u0328\\\\u0329\\\\u032a\\\\u032b\\\\u032c\\\\u032d\\\\u032e\\\\u032f\\\\u0330\\\\u0331\\\\u0332\\\\u0333\\\\u0334\\\\u0335\\\\u0336\\\\u0337\\\\u0338\\\\u0339\\\\u033a\\\\u033b\\\\u033c\\\\u033d\\\\u033e\\\\u033f\\\\u0340\\\\u0341\\\\u0342\\\\u0343\\\\u0344\\\\u0345\\\\u0346\\\\u0347\\\\u0348\\\\u0349\\\\u034a\\\\u034b\\\\u034c\\\\u034d\\\\u034e\\\\u034f\\\\u0350\\\\u0351\\\\u0352\\\\u0353\\\\u0354\\\\u0355\\\\u0356\\\\u0357\\\\u0358\\\\u0359\\\\u035a\\\\u035b\\\\u035c\\\\u035d\\\\u035e\\\\u035f\\\\u0360\\\\u0361\\\\u0362\\\\u0363\\\\u0364\\\\u0365\\\\u0366\\\\u0367\\\\u0368\\\\u0369\\\\u036a\\\\u036b\\\\u036c\\\\u036d\\\\u036e\\\\u036f\\\\u0370\\\\u0371\\\\u0372\\\\u0373\\\\u0374\\\\u0375\\\\u0376\\\\u0377\\\\u0378\\\\u0379\\\\u037a\\\\u037b\\\\u037c\\\\u037d\\\\u037e\\\\u037f\\\\u0380\\\\u0381\\\\u0382\\\\u0383\\\\u0384\\\\u0385\\\\u0386\\\\u0387\\\\u0388\\\\u0389\\\\u038a\\\\u038b\\\\u038c\\\\u038d\\\\u038e\\\\u038f\\\\u0390\\\\u0391\\\\u0392\\\\u0393\\\\u0394\\\\u0395\\\\u0396\\\\u0397\\\\u0398\\\\u0399\\\\u039a\\\\u039b\\\\u039c\\\\u039d\\\\u039e\\\\u039f\\\\u03a0\\\\u03a1\\\\u03a2\\\\u03a3\\\\u03a4\\\\u03a5\\\\u03a6\\\\u03a7\\\\u03a8\\\\u03a9\\\\u03aa\\\\u03ab\\\\u03ac\\\\u03ad\\\\u03ae\\\\u03af\\\\u03b0\\\\u03b1\\\\u03b2\\\\u03b3\\\\u03b4\\\\u03b5\\\\u03b6\\\\u03b7\\\\u03b8\\\\u03b9\\\\u03ba\\\\u03bb\\\\u03bc\\\\u03bd\\\\u03be\\\\u03bf\\\\u03c0\\\\u03c1\\\\u03c2\\\\u03c3\\\\u03c4\\\\u03c5\\\\u03c6\\\\u03c7\\\\u03c8\\\\u03c9\\\\u03ca\\\\u03cb\\\\u03cc\\\\u03cd\\\\u03ce\\\\u03cf\\\\u03d0\\\\u03d1\\\\u03d2\\\\u03d3\\\\u03d4\\\\u03d5\\\\u03d6\\\\u03d7\\\\u03d8\\\\u03d9\\\\u03da\\\\u03db\\\\u03dc\\\\u03dd\\\\u03de\\\\u03df\\\\u03e0\\\\u03e1\\\\u03e2\\\\u03e3\\\\u03e4\\\\u03e5\\\\u03e6\\\\u03e7\\\\u03e8\\\\u03e9\\\\u03ea\\\\u03eb\\\\u03ec\\\\u03ed\\\\u03ee\\\\u03ef\\\\u03f0\\\\u03f1\\\\u03f2\\\\u03f3\\\\u03f4\\\\u03f5\\\\u03f6\\\\u03f7\\\\u03f8\\\\u03f9\\\\u03fa\\\\u03fb\\\\u03fc\\\\u03fd\\\\u03fe\\\\u03ff\\\\u0400\\\\u0401\\\\u0402\\\\u0403\\\\u0404\\\\u0405\\\\u0406\\\\u0407\\\\u0408\\\\u0409\\\\u040a\\\\u040b\\\\u040c\\\\u040d\\\\u040e\\\\u040f\\\\u0410\\\\u0411\\\\u0412\\\\u0413\\\\u0414\\\\u0415\\\\u0416\\\\u0417\\\\u0418\\\\u0419\\\\u041a\\\\u041b\\\\u041c\\\\u041d\\\\u041e\\\\u041f\\\\u0420\\\\u0421\\\\u0422\\\\u0423\\\\u0424\\\\u0425\\\\u0426\\\\u0427\\\\u0428\\\\u0429\\\\u042a\\\\u042b\\\\u042c\\\\u042d\\\\u042e\\\\u042f\\\\u0430\\\\u0431\\\\u0432\\\\u0433\\\\u0434\\\\u0435\\\\u0436\\\\u0437\\\\u0438\\\\u0439\\\\u043a\\\\u043b\\\\u043c\\\\u043d\\\\u043e\\\\u043f\\\\u0440\\\\u0441\\\\u0442\\\\u0443\\\\u0444\\\\u0445\\\\u0446\\\\u0447\\\\u0448\\\\u0449\\\\u044a\\\\u044b\\\\u044c\\\\u044d\\\\u044e\\\\u044f\\\\u0450\\\\u0451\\\\u0452\\\\u0453\\\\u0454\\\\u0455\\\\u0456\\\\u0457\\\\u0458\\\\u0459\\\\u045a\\\\u045b\\\\u045c\\\\u045d\\\\u045e\\\\u045f\\\\u0460\\\\u0461\\\\u0462\\\\u0463\\\\u0464\\\\u0465\\\\u0466\\\\u0467\\\\u0468\\\\u0469\\\\u046a\\\\u046b\\\\u046c\\\\u046d\\\\u046e\\\\u046f\\\\u0470\\\\u0471\\\\u0472\\\\u0473\\\\u0474\\\\u0475\\\\u0476\\\\u0477\\\\u0478\\\\u0479\\\\u047a\\\\u047b\\\\u047c\\\\u047d\\\\u047e\\\\u047f\\\\u0480\\\\u0481\\\\u0482\\\\u0483\\\\u0484\\\\u0485\\\\u0486\\\\u0487\\\\u0488\\\\u0489\\\\u048a\\\\u048b\\\\u048c\\\\u048d\\\\u048e\\\\u048f\\\\u0490\\\\u0491\\\\u0492\\\\u0493\\\\u0494\\\\u0495\\\\u0496\\\\u0497\\\\u0498\\\\u0499\\\\u049a\\\\u049b\\\\u049c\\\\u049d\\\\u049e\\\\u049f\\\\u04a0\\\\u04a1\\\\u04a2\\\\u04a3\\\\u04a4\\\\u04a5\\\\u04a6\\\\u04a7\\\\u04a8\\\\u04a9\\\\u04aa\\\\u04ab\\\\u04ac\\\\u04ad\\\\u04ae\\\\u04af\\\\u04b0\\\\u04b1\\\\u04b2\\\\u04b3\\\\u04b4\\\\u04b5\\\\u04b6\\\\u04b7\\\\u04b8\\\\u04b9\\\\u04ba\\\\u04bb\\\\u04bc\\\\u04bd\\\\u04be\\\\u04bf\\\\u04c0\\\\u04c1\\\\u04c2\\\\u04c3\\\\u04c4\\\\u04c5\\\\u04c6\\\\u04c7\\\\u04c8\\\\u04c9\\\\u04ca\\\\u04cb\\\\u04cc\\\\u04cd\\\\u04ce\\\\u04cf\\\\u04d0\\\\u04d1\\\\u04d2\\\\u04d3\\\\u04d4\\\\u04d5\\\\u04d6\\\\u04d7\\\\u04d8\\\\u04d9\\\\u04da\\\\u04db\\\\u04dc\\\\u04dd\\\\u04de\\\\u04df\\\\u04e0\\\\u04e1\\\\u04e2\\\\u04e3\\\\u04e4\\\\u04e5\\\\u04e6\\\\u04e7\\\\u04e8\\\\u04e9\\\\u04ea\\\\u04eb\\\\u04ec\\\\u04ed\\\\u04ee\\\\u04ef\\\\u04f0\\\\u04f1\\\\u04f2\\\\u04f3\\\\u04f4\\\\u04f5\\\\u04f6\\\\u04f7\\\\u04f8\\\\u04f9\\\\u04fa\\\\u04fb\\\\u04fc\\\\u04fd\\\\u04fe\\\\u04ff\\\\u0500\\\\u0501\\\\u0502\\\\u0503\\\\u0504\\\\u0505\\\\u0506\\\\u0507\\\\u0508\\\\u0509\\\\u050a\\\\u050b\\\\u050c\\\\u050d\\\\u050e\\\\u050f\\\\u0510\\\\u0511\\\\u0512\\\\u0513\\\\u0514\\\\u0515\\\\u0516\\\\u0517\\\\u0518\\\\u0519\\\\u051a\\\\u051b\\\\u051c\\\\u051d\\\\u051e\\\\u051f\\\\u0520\\\\u0521\\\\u0522\\\\u0523\\\\u0524\\\\u0525\\\\u0526\\\\u0527\\\\u0528\\\\u0529\\\\u052a\\\\u052b\\\\u052c\\\\u052d\\\\u052e\\\\u052f\\\\u0530\\\\u0531\\\\u0532\\\\u0533\\\\u0534\\\\u0535\\\\u0536\\\\u0537\\\\u0538\\\\u0539\\\\u053a\\\\u053b\\\\u053c\\\\u053d\\\\u053e\\\\u053f\\\\u0540\\\\u0541\\\\u0542\\\\u0543\\\\u0544\\\\u0545\\\\u0546\\\\u0547\\\\u0548\\\\u0549\\\\u054a\\\\u054b\\\\u054c\\\\u054d\\\\u054e\\\\u054f\\\\u0550\\\\u0551\\\\u0552\\\\u0553\\\\u0554\\\\u0555\\\\u0556\\\\u0557\\\\u0558\\\\u0559\\\\u055a\\\\u055b\\\\u055c\\\\u055d\\\\u055e\\\\u055",
    "7db1f88e3c96395375451e83de16c5b6": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"single digit\",\n\t\t\targs: args{\n\t\t\t\ts: \"1\",\n\t\t\t},\n\t\t\twantNs:  \"1\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple digits\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative number\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"decimal number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential number\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential number with negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e-4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"inf\",\n\t\t\t},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"Inf\",\n\t\t\t},\n\t\t\twantNs:  \"Inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inF\",\n\t\t\targs: args{\n\t\t\t\ts: \"inF\",\n\t\t\t},\n\t\t\twantNs:  \"inF\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"nan\",\n\t\t\t},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"Nan\",\n\t\t\t},\n\t\t\twantNs:  \"Nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nAn\",\n\t\t\targs: args{\n\t\t\t\ts: \"nAn\",\n\t\t\t},\n\t\t\twantNs:  \"nAn\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with trailing whitespace\",\n\t\t\targs: args{\n\t\t\t\ts: \"123 \",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \" \",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading whitespace\",\n\t\t\targs: args{\n\t\t\t\ts: \" 123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" 123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character\",\n\t\t\targs: args{\n\t\t\t\ts: \"123a\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning\",\n\t\t\targs: args{\n\t\t\t\ts: \"a123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"a123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 2\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 3\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"-123a\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 4\",\n\t\t\targs: args{\n\t\t\t\ts: \"-a123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"-a123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 5\",\n\t\t\targs: args{\n\t\t\t\ts: \"+a123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+a123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 6\",\n\t\t\targs: args{\n\t\t\t\ts: \"123+\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 7\",\n\t\t\targs: args{\n\t\t\t\ts: \"123-\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 8\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \".\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 9\",\n\t\t\targs: args{\n\t\t\t\ts: \"123e\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"e\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 10\",\n\t\t\targs: args{\n\t\t\t\ts: \"123E\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"E\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 11\",\n\t\t\targs: args{\n\t\t\t\ts: \"123-\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 12\",\n\t\t\targs: args{\n\t\t\t\ts: \"123+\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 13\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \".\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 14\",\n\t\t\targs: args{\n\t\t\t\ts: \"123e\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"e\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 15\",\n\t\t\targs: args{\n\t\t\t\ts: \"123E\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"E\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 16\",\n\t\t\targs: args{\n\t\t\t\ts: \"123-\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 17\",\n\t\t\targs: args{\n\t\t\t\ts: \"123+\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 18\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \".\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 19\",\n\t\t\targs: args{\n\t\t\t\ts: \"123e\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"e\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 20\",\n\t\t\targs: args{\n\t\t\t\ts: \"123E\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"E\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 21\",\n\t\t\targs: args{\n\t\t\t\ts: \"123-\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 22\",\n\t\t\targs: args{\n\t\t\t\ts: \"123+\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 23\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \".\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 24\",\n\t\t\targs: args{\n\t\t\t\ts: \"123e\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"e\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 25\",\n\t\t\targs: args{\n\t\t\t\ts: \"123E\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"E\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 26\",\n\t\t\targs: args{\n\t\t\t\ts: \"123-\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 27\",\n\t\t\targs: args{\n\t\t\t\ts: \"123+\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 28\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \".\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 29\",\n\t\t\targs: args{\n\t\t\t\ts: \"123e\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"e\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 30\",\n\t\t\targs: args{\n\t\t\t\ts: \"123E\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"E\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 31\",\n\t\t\targs: args{\n\t\t\t\ts: \"123-\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 32\",\n\t\t\targs: args{\n\t\t\t\ts: \"123+\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 33\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \".\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 34\",\n\t\t\targs: args{\n\t\t\t\ts: \"123e\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"e\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 35\",\n\t\t\targs: args{\n\t\t\t\ts: \"123E\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"E\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 36\",\n\t\t\targs: args{\n\t\t\t\ts: \"123-\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 37\",\n\t\t\targs: args{\n\t\t\t\ts: \"123+\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 38\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \".\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 39\",\n\t\t\targs: args{\n\t\t\t\ts: \"123e\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"e\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 40\",\n\t\t\targs: args{\n\t\t\t\ts: \"123E\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"E\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 41\",\n\t\t\targs: args{\n\t\t\t\ts: \"123-\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 42\",\n\t\t\targs: args{\n\t\t\t\ts: \"123+\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 43\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \".\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 44\",\n\t\t\targs: args{\n\t\t\t\ts: \"123e\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"e\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 45\",\n\t\t\targs: args{\n\t\t\t\ts: \"123E\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"E\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 46\",\n\t\t\targs: args{\n\t\t\t\ts: \"123-\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 47\",\n\t\t\targs: args{\n\t\t\t\ts: \"123+\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 48\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \".\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 49\",\n\t\t\targs: args{\n\t\t\t\ts: \"123e\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"e\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 50\",\n\t\t\targs: args{\n\t\t\t\ts: \"123E\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"E\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 51\",\n\t\t\targs: args{\n\t\t\t\ts: \"123-\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 52\",\n\t\t\targs: args{\n\t\t\t\ts: \"123+\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 53\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \".\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 54\",\n\t\t\targs: args{\n\t\t\t\ts: \"123e\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"e\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 55\",\n\t\t\targs: args{\n\t\t\t\ts: \"123E\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"E\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 56\",\n\t\t\targs: args{\n\t\t\t\ts: \"123-\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 57\",\n\t\t\targs: args{\n\t\t\t\ts: \"123+\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 58\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \".\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 59\",\n\t\t\targs: args{\n\t\t\t\ts: \"123e\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"e\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 60\",\n\t\t\targs: args{\n\t\t\t\ts: \"123E\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"E\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 61\",\n\t\t\targs: args{\n\t\t\t\ts: \"123-\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 62\",\n\t\t\targs: args{\n\t\t\t\ts: \"123+\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 63\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \".\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 64\",\n\t\t\targs: args{\n\t\t\t\ts: \"123e\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"e\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 65\",\n\t\t\targs: args{\n\t\t\t\ts: \"123E\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"E\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 66\",\n\t\t\targs: args{\n\t\t\t\ts: \"123-\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 67\",\n\t\t\targs: args{\n\t\t\t\ts: \"123+\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 68\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \".\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 69\",\n\t\t\targs: args{\n\t\t\t\ts: \"123e\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"e\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 70\",\n\t\t\targs: args{\n\t\t\t\ts: \"123E\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"E\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 71\",\n\t\t\targs: args{\n\t\t\t\ts: \"123-\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 72\",\n\t\t\targs: args{\n\t\t\t\ts: \"123+\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 73\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \".\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 74\",\n\t\t\targs: args{\n\t\t\t\ts: \"123e\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"e\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 75\",\n\t\t\targs: args{\n\t\t\t\ts: \"123E\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"E\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 76\",\n\t\t\targs: args{\n\t\t\t\ts: \"123-\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 77\",\n\t\t\targs: args{\n\t\t\t\ts: \"123+\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 78\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \".\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 79\",\n\t\t\targs: args{\n\t\t\t\ts: \"123e\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"e\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 80\",\n\t\t\targs: args{\n\t\t\t\ts: \"123E\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"E\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 81\",\n\t\t\targs: args{\n\t\t\t\ts: \"123-\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 82\",\n\t\t\targs: args{\n\t\t\t\ts: \"123+\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 83\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \".\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 84\",\n\t\t\targs: args{\n\t\t\t\ts: \"123e\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"e\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 85\",\n\t\t\targs: args{\n\t\t\t\ts: \"123E\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"E\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 86\",\n\t\t\targs: args{\n\t\t\t\ts: \"123-\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 87\",\n\t\t\targs: args{\n\t\t\t\ts: \"123+\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 88\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \".\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 89\",\n\t\t\targs: args{\n\t\t\t\ts: \"123e\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"e\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 90\",\n\t\t\targs: args{\n\t\t\t\ts: \"123E\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"E\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 91\",\n\t\t\targs: args{\n\t\t\t\ts: \"123-\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 92\",\n\t\t\targs: args{\n\t\t\t\ts: \"123+\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 93\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \".\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 94\",\n\t\t\targs: args{\n\t\t\t\ts: \"123e\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"e\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 95\",\n\t\t\targs: args{\n\t\t\t\ts: \"123E\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"E\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 96\",\n\t\t\targs: args{\n\t\t\t\ts: \"123-\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 97\",\n\t\t\targs: args{\n\t\t\t\ts: \"123+\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 98\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \".\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 99\",\n\t\t\targs: args{\n\t\t\t\ts: \"123e\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"e\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 100\",\n\t\t\targs: args{\n\t\t\t\ts: \"123E\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"E\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}",
    "7dcd4b2020590e522e3b8a940cc501f3": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no whitespace\",\n\t\t\targs: args{s: \"abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace\",\n\t\t\targs: args{s: \"  abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailing whitespace\",\n\t\t\targs: args{s: \"abc  \"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading and trailing whitespace\",\n\t\t\targs: args{s: \"  abc  \"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"whitespace in the middle\",\n\t\t\targs: args{s: \"a bc\"},\n\t\t\twant: \"bc\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple whitespace\",\n\t\t\targs: args{s: \"  a  b  c  \"},\n\t\t\twant: \"b  c\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading and trailing whitespace with special characters\",\n\t\t\targs: args{s: \"  \\t\\n\\r abc \\t\\n\\r  \"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"whitespace with special characters\",\n\t\t\targs: args{s: \"  \\t\\n\\r abc \\t\\n\\r  \"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"all whitespace\",\n\t\t\targs: args{s: \"  \\t\\n\\r  \"},\n\t\t\twant: \"\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "7dd7034a21a9529c961f608a308225ae": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_JSON(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_JSON_Unmarshal(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    map[string]interface{}\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    map[string]interface{}{},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    map[string]interface{}{\"key1\": \"value1\", \"key2\": \"value2\"},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    map[string]interface{}{\"key1\": map[string]interface{}{\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    map[string]interface{}{\"key\\\"1\": \"value1\"},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif tt.wantErr {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tvar unmarshaled map[string]interface{}\n\t\t\tif err := json.Unmarshal(got.MarshalTo(nil), \u0026unmarshaled); err != nil {\n\t\t\t\tt.Errorf(\"parseObject() unmarshal error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(unmarshaled, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", unmarshaled, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "7e8e562ef2d27c182d546cf4c9a07086": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetArray(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant []*Value\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.GetArray(tt.args.keys...); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.GetArray() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "7f4ba0b171c71cd762dba9c2e617f4ff": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetUint(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant uint\n\t}{\n\t\t{\n\t\t\tname: \"empty keys\",\n\t\t\tv:    \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\targs: args{keys: nil},\n\t\t\twant: 123,\n\t\t},\n\t\t{\n\t\t\tname: \"single key\",\n\t\t\tv:    \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{t: TypeNumber, s: \"123\"}}}}},\n\t\t\targs: args{keys: []string{\"key\"}},\n\t\t\twant: 123,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple keys\",\n\t\t\tv:    \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key1\", v: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}}}}}}}}},\n\t\t\targs: args{keys: []string{\"key1\", \"key2\"}},\n\t\t\twant: 123,\n\t\t},\n\t\t{\n\t\t\tname: \"array index\",\n\t\t\tv:    \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"123\"}}},\n\t\t\targs: args{keys: []string{\"0\"}},\n\t\t\twant: 123,\n\t\t},\n\t\t{\n\t\t\tname: \"non-existing key\",\n\t\t\tv:    \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{t: TypeNumber, s: \"123\"}}}}},\n\t\t\targs: args{keys: []string{\"key2\"}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid value type\",\n\t\t\tv:    \u0026Value{t: TypeString, s: \"123\"},\n\t\t\targs: args{keys: []string{\"key\"}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"nil value\",\n\t\t\tv:    nil,\n\t\t\targs: args{keys: []string{\"key\"}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"overflow\",\n\t\t\tv:    \u0026Value{t: TypeNumber, s: \"18446744073709551616\"},\n\t\t\targs: args{keys: nil},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.GetUint(tt.args.keys...); got != tt.want {\n\t\t\t\tt.Errorf(\"Value.GetUint() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "7f60f1b39103ded7daa1b75a4ee76a2d": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"{}\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\": \"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"value1\", \"value2\"]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"value\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"value\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   `true`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueTrue,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   `false`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueFalse,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   `null`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueNull,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with decimal\",\n\t\t\targs: args{\n\t\t\t\ts:   `123.456`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e+4`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e-4`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"1.23e-4\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `-123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative sign and decimal\",\n\t\t\targs: args{\n\t\t\t\ts:   `-123.456`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-123.456\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative sign and exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `-1.23e+4`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-1.23e+4\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative sign and negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `-1.23e-4`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-1.23e-4\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   `NaN`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseValue() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseValue_JSON(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\": \"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `{\"key\":\"value\"}`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"value1\", \"value2\"]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `[\"value1\",\"value2\"]`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"value\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `\"value\"`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   `true`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `true`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   `false`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `false`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   `null`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `null`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `123`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with decimal\",\n\t\t\targs: args{\n\t\t\t\ts:   `123.456`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `123.456`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e+4`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `1.23e+4`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e-4`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `1.23e-4`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `-123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `-123`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative sign and decimal\",\n\t\t\targs: args{\n\t\t\t\ts:   `-123.456`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `-123.456`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative sign and exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `-1.23e+4`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `-1.23e+4`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative sign and negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `-1.23e-4`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `-1.23e-4`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   `NaN`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `NaN`,\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tb, err := json.Marshal(got)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"json.Marshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif string(b) != tt.want {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", string(b), tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "807d013abe86474680c99a8397c44ef9": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueGet(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant *Value\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.Get(tt.args.keys...); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.Get() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "80eb4c1412d255ee46292aae604c32df": "```go\npackage fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"simple integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"float\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential notation\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential notation with negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e-4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"inf\",\n\t\t\t},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"Inf\",\n\t\t\t},\n\t\t\twantNs:  \"Inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inF\",\n\t\t\targs: args{\n\t\t\t\ts: \"inF\",\n\t\t\t},\n\t\t\twantNs:  \"inF\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"nan\",\n\t\t\t},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twantNs:  \"NaN\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nAn\",\n\t\t\targs: args{\n\t\t\t\ts: \"nAn\",\n\t\t\t},\n\t\t\twantNs:  \"nAn\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123a\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"-inf\",\n\t\t\t},\n\t\t\twantNs:  \"-inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"-nan\",\n\t\t\t},\n\t\t\twantNs:  \"-nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"-inf\",\n\t\t\t},\n\t\t\twantNs:  \"-inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"-nan\",\n\t\t\t},\n\t\t\twantNs:  \"-nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number",
    "813b6cc65bfab253187227574002ee26": "package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n)\n\nfunc TestValue_Get(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant *Value\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.Get(tt.args.keys...); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.Get() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValue_Get_Nil(t *testing.T) {\n\tv := (*Value)(nil)\n\tif got := v.Get(\"foo\"); got != nil {\n\t\tt.Errorf(\"Value.Get() = %v, want nil\", got)\n\t}\n}\n\nfunc TestValue_Get_NonExistingKey(t *testing.T) {\n\tv := \u0026Value{\n\t\tt: TypeObject,\n\t\to: Object{\n\t\t\tkvs: []kv{\n\t\t\t\t{k: \"foo\", v: \u0026Value{t: TypeString, s: \"bar\"}},\n\t\t\t},\n\t\t},\n\t}\n\tif got := v.Get(\"baz\"); got != nil {\n\t\tt.Errorf(\"Value.Get() = %v, want nil\", got)\n\t}\n}\n\nfunc TestValue_Get_Object(t *testing.T) {\n\tv := \u0026Value{\n\t\tt: TypeObject,\n\t\to: Object{\n\t\t\tkvs: []kv{\n\t\t\t\t{k: \"foo\", v: \u0026Value{t: TypeString, s: \"bar\"}},\n\t\t\t},\n\t\t},\n\t}\n\twant := \u0026Value{t: TypeString, s: \"bar\"}\n\tif got := v.Get(\"foo\"); !reflect.DeepEqual(got, want) {\n\t\tt.Errorf(\"Value.Get() = %v, want %v\", got, want)\n\t}\n}\n\nfunc TestValue_Get_Array(t *testing.T) {\n\tv := \u0026Value{\n\t\tt: TypeArray,\n\t\ta: []*Value{\n\t\t\t{t: TypeString, s: \"foo\"},\n\t\t\t{t: TypeString, s: \"bar\"},\n\t\t},\n\t}\n\twant := \u0026Value{t: TypeString, s: \"bar\"}\n\tif got := v.Get(\"1\"); !reflect.DeepEqual(got, want) {\n\t\tt.Errorf(\"Value.Get() = %v, want %v\", got, want)\n\t}\n}\n\nfunc TestValue_Get_Array_InvalidIndex(t *testing.T) {\n\tv := \u0026Value{\n\t\tt: TypeArray,\n\t\ta: []*Value{\n\t\t\t{t: TypeString, s: \"foo\"},\n\t\t\t{t: TypeString, s: \"bar\"},\n\t\t},\n\t}\n\tif got := v.Get(\"2\"); got != nil {\n\t\tt.Errorf(\"Value.Get() = %v, want nil\", got)\n\t}\n}\n\nfunc TestValue_Get_Array_NegativeIndex(t *testing.T) {\n\tv := \u0026Value{\n\t\tt: TypeArray,\n\t\ta: []*Value{\n\t\t\t{t: TypeString, s: \"foo\"},\n\t\t\t{t: TypeString, s: \"bar\"},\n\t\t},\n\t}\n\tif got := v.Get(\"-1\"); got != nil {\n\t\tt.Errorf(\"Value.Get() = %v, want nil\", got)\n\t}\n}\n\nfunc TestValue_Get_Nested(t *testing.T) {\n\tv := \u0026Value{\n\t\tt: TypeObject,\n\t\to: Object{\n\t\t\tkvs: []kv{\n\t\t\t\t{k: \"foo\", v: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{k: \"bar\", v: \u0026Value{t: TypeString, s: \"baz\"}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\t},\n\t\t},\n\t}\n\twant := \u0026Value{t: TypeString, s: \"baz\"}\n\tif got := v.Get(\"foo\", \"bar\"); !reflect.DeepEqual(got, want) {\n\t\tt.Errorf(\"Value.Get() = %v, want %v\", got, want)\n\t}\n}\n\nfunc TestValue_Get_Nested_Array(t *testing.T) {\n\tv := \u0026Value{\n\t\tt: TypeObject,\n\t\to: Object{\n\t\t\tkvs: []kv{\n\t\t\t\t{k: \"foo\", v: \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{t: TypeString, s: \"bar\"},\n\t\t\t\t\t\t{t: TypeString, s: \"baz\"},\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\t},\n\t\t},\n\t}\n\twant := \u0026Value{t: TypeString, s: \"baz\"}\n\tif got := v.Get(\"foo\", \"1\"); !reflect.DeepEqual(got, want) {\n\t\tt.Errorf(\"Value.Get() = %v, want %v\", got, want)\n\t}\n}\n\nfunc TestValue_Get_Nested_NonExistingKey(t *testing.T) {\n\tv := \u0026Value{\n\t\tt: TypeObject,\n\t\to: Object{\n\t\t\tkvs: []kv{\n\t\t\t\t{k: \"foo\", v: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{k: \"bar\", v: \u0026Value{t: TypeString, s: \"baz\"}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\t},\n\t\t},\n\t}\n\tif got := v.Get(\"foo\", \"qux\"); got != nil {\n\t\tt.Errorf(\"Value.Get() = %v, want nil\", got)\n\t}\n}\n\nfunc TestValue_Get_Nested_Array_InvalidIndex(t *testing.T) {\n\tv := \u0026Value{\n\t\tt: TypeObject,\n\t\to: Object{\n\t\t\tkvs: []kv{\n\t\t\t\t{k: \"foo\", v: \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{t: TypeString, s: \"bar\"},\n\t\t\t\t\t\t{t: TypeString, s: \"baz\"},\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\t},\n\t\t},\n\t}\n\tif got := v.Get(\"foo\", \"2\"); got != nil {\n\t\tt.Errorf(\"Value.Get() = %v, want nil\", got)\n\t}\n}\n\nfunc TestValue_Get_Nested_Array_NegativeIndex(t *testing.T) {\n\tv := \u0026Value{\n\t\tt: TypeObject,\n\t\to: Object{\n\t\t\tkvs: []kv{\n\t\t\t\t{k: \"foo\", v: \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{t: TypeString, s: \"bar\"},\n\t\t\t\t\t\t{t: TypeString, s: \"baz\"},\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\t},\n\t\t},\n\t}\n\tif got := v.Get(\"foo\", \"-1\"); got != nil {\n\t\tt.Errorf(\"Value.Get() = %v, want nil\", got)\n\t}\n}\n\nfunc TestValue_Get_InvalidType(t *testing.T) {\n\tv := \u0026Value{\n\t\tt: TypeString,\n\t\ts: \"foo\",\n\t}\n\tif got := v.Get(\"bar\"); got != nil {\n\t\tt.Errorf(\"Value.Get() = %v, want nil\", got)\n\t}\n}",
    "8177a350d4c4cce2597cc004623711f5": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\"world\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped backslashes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\\world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: ``,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with leading and trailing spaces\",\n\t\t\targs: args{\n\t\t\t\ts: ` \"hello\" `,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \" \",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "829f3bee55cc6c18e8df104328bf5e2b": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\"world\\\\\\\"\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote at the beginning\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\\\\\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"\\\"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote at the end\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote in the middle\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote and other characters\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"123\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"123\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: ``,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with no quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `hello`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "8357f5d24e1cdb9aefc22a135c1b9466": "package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u006\"},\n\t\t\twant: \"\\\\u0061\\\\u006\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\\\\\ \\\\/\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\x\\\\u006\"},\n\t\t\twant: \"\\\"hello\\\" \\\\world\\\\ /\\\\b\\\\f\\\\n\\\\r\\tabcüòÅ\\\\x\\\\u006\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "846b5a8936b60cdcefab9152a8a78e08": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"empty string\",\n\t\t\targs:    args{s: \"\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"single digit\",\n\t\t\targs:    args{s: \"1\"},\n\t\t\twantNs:  \"1\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"multiple digits\",\n\t\t\targs:    args{s: \"123\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"decimal number\",\n\t\t\targs:    args{s: \"123.456\"},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"negative number\",\n\t\t\targs:    args{s: \"-123\"},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"exponential number\",\n\t\t\targs:    args{s: \"1.23e+4\"},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"exponential number with lowercase e\",\n\t\t\targs:    args{s: \"1.23e-4\"},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading zeros\",\n\t\t\targs:    args{s: \"00123\"},\n\t\t\twantNs:  \"00123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with trailing zeros\",\n\t\t\targs:    args{s: \"123.00\"},\n\t\t\twantNs:  \"123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign\",\n\t\t\targs:    args{s: \"+123\"},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading space\",\n\t\t\targs:    args{s: \" 123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" 123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with trailing space\",\n\t\t\targs:    args{s: \"123 \"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \" \",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with invalid character\",\n\t\t\targs:    args{s: \"123a\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"inf\",\n\t\t\targs:    args{s: \"inf\"},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"inf with leading space\",\n\t\t\targs:    args{s: \" inf\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" inf\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"inf with trailing space\",\n\t\t\targs:    args{s: \"inf \"},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \" \",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"inf with invalid character\",\n\t\t\targs:    args{s: \"infx\"},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"x\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"nan\",\n\t\t\targs:    args{s: \"nan\"},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"nan with leading space\",\n\t\t\targs:    args{s: \" nan\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" nan\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"nan with trailing space\",\n\t\t\targs:    args{s: \"nan \"},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \" \",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"nan with invalid character\",\n\t\t\targs:    args{s: \"nanx\"},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"x\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}",
    "85860e752a54f3e60b619400d8ea0e22": "```go\npackage fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"simple integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"float\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential notation\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential notation with negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e-4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"inf\",\n\t\t\t},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"Inf\",\n\t\t\t},\n\t\t\twantNs:  \"Inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twantNs:  \"NaN\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"nan\",\n\t\t\t},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123a\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus and trailing plus\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123+\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus and trailing minus\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123-\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus and trailing minus\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123-\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus and trailing plus\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123+\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus and trailing plus\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123+\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus and trailing minus\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123-\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus and trailing minus\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123-\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus and trailing plus\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123+\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus and trailing minus\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123-\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus and trailing plus\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123+\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus and trailing minus\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123-\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus and trailing plus\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123+\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus and trailing minus\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123-\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus and trailing plus\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123+\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus and trailing minus\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123-\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus and trailing plus\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123+\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus and trailing minus\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123-\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus and trailing plus\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123+\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus and trailing minus\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123-\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus and trailing plus\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123+\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus and trailing minus\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123-\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus and trailing plus\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123+\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus and trailing minus\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123-\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus and trailing plus\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123+\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus and trailing minus\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123-\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus and trailing plus\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123+\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus and trailing minus\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123-\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus and trailing plus\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123+\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus and trailing minus\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123-\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus and trailing plus\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123+\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus and trailing minus\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123-\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus and trailing plus\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123+\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus and trailing minus\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123-\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus and trailing plus\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123+\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus and trailing minus\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123-\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus and trailing plus\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123+\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus and trailing minus\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123-\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus and trailing plus\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123+\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus and trailing minus\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123-\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus and trailing plus\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123+\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus and trailing minus\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123-\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus and trailing plus\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123+\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus and trailing minus\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123-\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus and trailing plus\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123+\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus and trailing minus\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123-\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus and trailing plus\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123+\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus and trailing minus\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123-\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus and trailing plus\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123+\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus and trailing minus\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123-\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus and trailing plus\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123+\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus and trailing minus\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123-\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus and trailing plus\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123+\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus and trailing minus\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123-\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus and trailing plus\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123+\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus and trailing minus\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123-\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus and trailing plus\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123+\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus and trailing minus\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123-\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus and trailing plus\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123+\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus and trailing minus\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123-\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus and trailing plus\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123+\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus and trailing minus\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123-\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus and trailing plus\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123+\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus and trailing minus\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123-\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus and trailing plus\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123+\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus and trailing minus\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123-\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus and trailing plus\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123+\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus and trailing minus\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123-\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus and trailing plus\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123+\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus and trailing minus\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123-\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus and trailing plus\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123+\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus and trailing minus\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123-\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus and trailing plus\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123+\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus and trailing minus\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123-\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus and trailing plus\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123+\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus and trailing minus\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123-\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus and trailing plus\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123+\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus and trailing minus\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123-\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus and trailing plus\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123+\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus and trailing minus\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123-\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus and trailing plus\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123+\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus and trailing minus\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123-\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus and trailing plus\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123+\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus and trailing minus\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123-\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus and trailing plus\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123+\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus and trailing minus\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123-\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus and trailing plus\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123+\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus and trailing minus\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123-\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus and trailing plus\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123+\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus and trailing minus\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123-\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus and trailing plus\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123+\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus and trailing minus\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123-\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus and trailing plus\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123+\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus and trailing minus\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123-\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus and trailing plus\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123+\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus and trailing minus\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123-\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus and trailing plus\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123+\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus and trailing minus\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123-\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus and trailing plus\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123+\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus and trailing minus\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123-\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus and trailing plus\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123+\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus and trailing minus\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123-\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus and trailing plus\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123+\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus and trailing minus\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123-\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus and trailing plus\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123+\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus and trailing minus\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123-\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus and trailing plus\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123+\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus and trailing minus\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123-\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus and trailing plus\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123+\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus and trailing minus\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123-\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus and trailing plus\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123+\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus and trailing minus\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123-\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus and trailing plus\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123+\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus and trailing minus\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123-\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus and trailing plus\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123+\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus and trailing minus\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123-\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus and trailing plus\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123+\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus and trailing minus\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123-\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t",
    "867153df9b6a69ea618b77a3fc27945c": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"simple integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple float\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative number\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with exponent\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with exponent and sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e-4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zeros\",\n\t\t\targs: args{\n\t\t\t\ts: \"00123\",\n\t\t\t},\n\t\t\twantNs:  \"00123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with trailing zeros\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.00\",\n\t\t\t},\n\t\t\twantNs:  \"123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading plus sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"inf\",\n\t\t\t},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"Inf\",\n\t\t\t},\n\t\t\twantNs:  \"Inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inF\",\n\t\t\targs: args{\n\t\t\t\ts: \"inF\",\n\t\t\t},\n\t\t\twantNs:  \"inF\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"nan\",\n\t\t\t},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"Nan\",\n\t\t\t},\n\t\t\twantNs:  \"Nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nAn\",\n\t\t\targs: args{\n\t\t\t\ts: \"nAn\",\n\t\t\t},\n\t\t\twantNs:  \"nAn\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character\",\n\t\t\targs: args{\n\t\t\t\ts: \"123a\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start\",\n\t\t\targs: args{\n\t\t\t\ts: \"a123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"a123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 2\",\n\t\t\targs: args{\n\t\t\t\ts: \"a\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 3\",\n\t\t\targs: args{\n\t\t\t\ts: \"+a\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+a\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 4\",\n\t\t\targs: args{\n\t\t\t\ts: \"-a\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"-a\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}",
    "8717eb40e7c5b1502a86c46aec6f0a2f": "package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u006\"},\n\t\t\twant: \"\\\\u0061\\\\u006\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\\\\\ \\\\/\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\x\\\\u006\"},\n\t\t\twant: \"\\\"hello\\\" \\\\world\\\\ /\\\\b\\\\f\\\\n\\\\r\\\\t abcüòÅ\\\\x\\\\u006\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "871e93cc734c52c098de30486d1c84ef": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetFloat64(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.GetFloat64(tt.args.keys...); got != tt.want {\n\t\t\t\tt.Errorf(\"Value.GetFloat64() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "880ea0b271ad5f9e12e05cf9dcf137a3": "package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u006\"},\n\t\t\twant: \"\\\\u0061\\\\u006\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\\\\\ \\\\/\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\x\\\\u006\"},\n\t\t\twant: \"\\\"hello\\\" \\\\world\\\\ /\\\\b\\\\f\\\\n\\\\r\\\\tabcüòÅ\\\\x\\\\u006\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "88843da73a4c0686070c97ea98d37280": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"single element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,3]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[[1,2],[3,4]]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"4\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with whitespace\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[ 1 , 2 , 3 ]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,3\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1,2,3\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1 2,3]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1 2,3]\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected end of array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1,2,\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseArray() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "88b3d88545e7b71fef3f2ddd387f7e6d": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\"world\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"\",\n\t\t\twant1:   \"!\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped backslashes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\\world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with no quotes\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with leading quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello world\"`,\n\t\t\t},\n\t\t\twant:    \"hello world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "88bc848125f2ad9eae9f374f797cdd6d": "package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u world\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u world\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\/ \\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"\\\"hello\\\" \\\\world/ \\b\\f\\n\\r\\tabcüòÅ\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "8a73b2899763b71a1e7be8fdde02f4a4": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"simple integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple float\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative number\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with exponent\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with exponent and sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e-4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zeros\",\n\t\t\targs: args{\n\t\t\t\ts: \"00123\",\n\t\t\t},\n\t\t\twantNs:  \"00123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with trailing zeros\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.00\",\n\t\t\t},\n\t\t\twantNs:  \"123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading plus sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading minus sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading space\",\n\t\t\targs: args{\n\t\t\t\ts: \" 123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" 123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number with trailing space\",\n\t\t\targs: args{\n\t\t\t\ts: \"123 \",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \" \",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading and trailing spaces\",\n\t\t\targs: args{\n\t\t\t\ts: \" 123 \",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" 123 \",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character\",\n\t\t\targs: args{\n\t\t\t\ts: \"123a\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning\",\n\t\t\targs: args{\n\t\t\t\ts: \"a123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"a123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 2\",\n\t\t\targs: args{\n\t\t\t\ts: \"a-123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"a-123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 3\",\n\t\t\targs: args{\n\t\t\t\ts: \"a+123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"a+123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 4\",\n\t\t\targs: args{\n\t\t\t\ts: \"a.123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"a.123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 5\",\n\t\t\targs: args{\n\t\t\t\ts: \"a123.456\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"a123.456\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 6\",\n\t\t\targs: args{\n\t\t\t\ts: \"a123e+4\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"a123e+4\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 7\",\n\t\t\targs: args{\n\t\t\t\ts: \"a123e-4\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"a123e-4\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 8\",\n\t\t\targs: args{\n\t\t\t\ts: \"a00123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"a00123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 9\",\n\t\t\targs: args{\n\t\t\t\ts: \"a123.00\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"a123.00\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 10\",\n\t\t\targs: args{\n\t\t\t\ts: \"a+123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"a+123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 11\",\n\t\t\targs: args{\n\t\t\t\ts: \"a-123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"a-123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"inf\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"inf\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"Inf\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"Inf\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inF\",\n\t\t\targs: args{\n\t\t\t\ts: \"inF\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"inF\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"in\",\n\t\t\targs: args{\n\t\t\t\ts: \"in\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"in\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"nan\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"nan\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"Nan\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"Nan\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nAn\",\n\t\t\targs: args{\n\t\t\t\ts: \"nAn\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"nAn\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"na\",\n\t\t\targs: args{\n\t\t\t\ts: \"na\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"na\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"inf with leading space\",\n\t\t\targs: args{\n\t\t\t\ts: \" inf\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" inf\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"inf with trailing space\",\n\t\t\targs: args{\n\t\t\t\ts: \"inf \",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"inf \",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"inf with leading and trailing spaces\",\n\t\t\targs: args{\n\t\t\t\ts: \" inf \",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" inf \",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"inf with leading character\",\n\t\t\targs: args{\n\t\t\t\ts: \"a inf\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"a inf\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"inf with trailing character\",\n\t\t\targs: args{\n\t\t\t\ts: \"inf a\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"inf a\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"inf with leading and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"a inf a\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"a inf a\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"nan with leading space\",\n\t\t\targs: args{\n\t\t\t\ts: \" nan\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" nan\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"nan with trailing space\",\n\t\t\targs: args{\n\t\t\t\ts: \"nan \",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"nan \",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"nan with leading and trailing spaces\",\n\t\t\targs: args{\n\t\t\t\ts: \" nan \",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" nan \",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"nan with leading character\",\n\t\t\targs: args{\n\t\t\t\ts: \"a nan\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"a nan\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"nan with trailing character\",\n\t\t\targs: args{\n\t\t\t\ts: \"nan a\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"nan a\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"nan with leading and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"a nan a\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"a nan a\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"inf with leading minus sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"-inf\",\n\t\t\t},\n\t\t\twantNs:  \"-\",\n\t\t\twantS:   \"inf\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inf with leading plus sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+\",\n\t\t\twantS:   \"inf\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nan with leading minus sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"-nan\",\n\t\t\t},\n\t\t\twantNs:  \"-\",\n\t\t\twantS:   \"nan\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nan with leading plus sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+\",\n\t\t\twantS:   \"nan\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif len(tt.args.s) == 0 {\n\t\t\t\tt.Errorf(\"TestParseRawNumber() len(s) == 0\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}",
    "8a92d6cf40fb9967c46b22a97cd7d74c": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no whitespace\",\n\t\t\targs: args{s: \"abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace\",\n\t\t\targs: args{s: \" \\t\\n abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailing whitespace\",\n\t\t\targs: args{s: \"abc \\t\\n\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"whitespace in the middle\",\n\t\t\targs: args{s: \"a \\t\\n b c\"},\n\t\t\twant: \"b c\",\n\t\t},\n\t\t{\n\t\t\tname: \"all whitespace\",\n\t\t\targs: args{s: \" \\t\\n\"},\n\t\t\twant: \"\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "8bd5ac54a8d97cb3498cac05c38ebb21": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"single digit\",\n\t\t\targs: args{\n\t\t\t\ts: \"1\",\n\t\t\t},\n\t\t\twantNs:  \"1\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple digits\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative number\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"decimal number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential number\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential number with negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e-4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"inf\",\n\t\t\t},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"Inf\",\n\t\t\t},\n\t\t\twantNs:  \"Inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inF\",\n\t\t\targs: args{\n\t\t\t\ts: \"inF\",\n\t\t\t},\n\t\t\twantNs:  \"inF\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"nan\",\n\t\t\t},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"Nan\",\n\t\t\t},\n\t\t\twantNs:  \"Nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nAn\",\n\t\t\targs: args{\n\t\t\t\ts: \"nAn\",\n\t\t\t},\n\t\t\twantNs:  \"nAn\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with trailing whitespace\",\n\t\t\targs: args{\n\t\t\t\ts: \"123 \",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \" \",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading whitespace\",\n\t\t\targs: args{\n\t\t\t\ts: \" 123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" 123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character\",\n\t\t\targs: args{\n\t\t\t\ts: \"123a\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start\",\n\t\t\targs: args{\n\t\t\t\ts: \"a123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"a123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 2\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 3\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 4\",\n\t\t\targs: args{\n\t\t\t\ts: \"-a123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"-a123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at start 5\",\n\t\t\targs: args{\n\t\t\t\ts: \"+a123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+a123\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}",
    "8cebbaf56eed54ae7ac1f41dc7bca55a": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quotes and other characters\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"\\\\\\\\\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\\\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: ``,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with no quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `hello`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "8e7a2d1d824892a379375c34369f029f": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "8eae25ac5e53288751b9137800585cf9": "```go\npackage fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth + 1,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"{}\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\": \"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"value1\", \"value2\"]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"value\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"value\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   `true`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueTrue,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   `false`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueFalse,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   `null`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueNull,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with decimal\",\n\t\t\targs: args{\n\t\t\t\ts:   `123.456`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e+4`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e-4`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"1.23e-4\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `-123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative sign and decimal\",\n\t\t\targs: args{\n\t\t\t\ts:   `-123.456`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-123.456\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative sign and exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `-1.23e+4`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-1.23e+4\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative sign and negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `-1.23e-4`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-1.23e-4\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   `NaN`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseValue() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseValue_Invalid(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"invalid true\",\n\t\t\targs: args{\n\t\t\t\ts:   `tru`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid false\",\n\t\t\targs: args{\n\t\t\t\ts:   `fals`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid null\",\n\t\t\targs: args{\n\t\t\t\ts:   `nul`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123a`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with decimal\",\n\t\t\targs: args{\n\t\t\t\ts:   `123.456a`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e+4a`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e-4a`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with negative sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `-123a`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with negative sign and decimal\",\n\t\t\targs: args{\n\t\t\t\ts:   `-123.456a`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with negative sign and exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `-1.23e+4a`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with negative sign and negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `-1.23e-4a`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt",
    "8f3577abc1e9b4953cc10e31b104475d": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no whitespace\",\n\t\t\targs: args{s: \"abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace\",\n\t\t\targs: args{s: \"  abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailing whitespace\",\n\t\t\targs: args{s: \"abc  \"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"whitespace in the middle\",\n\t\t\targs: args{s: \"a bc\"},\n\t\t\twant: \"bc\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple whitespace\",\n\t\t\targs: args{s: \"  a  b  c  \"},\n\t\t\twant: \"a  b  c\",\n\t\t},\n\t\t{\n\t\t\tname: \"newline\",\n\t\t\targs: args{s: \"\\nabc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"tab\",\n\t\t\targs: args{s: \"\\tabc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"carriage return\",\n\t\t\targs: args{s: \"\\rabc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "8f686768662947d3b2eeeb2bfd5865e5": "package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u006\"},\n\t\t\twant: \"\\\\u0061\\\\u006\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\\\\\ \\\\/\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\x\\\\u006\"},\n\t\t\twant: \"\\\"hello\\\" \\\\world\\\\ /\\\\b\\\\f\\\\n\\\\r\\\\t abcüòÅ\\\\x\\\\u006\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "9077a4076d664e3c106ffc6a35892930": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"empty string\",\n\t\t\targs:    args{s: \"\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"simple integer\",\n\t\t\targs:    args{s: \"123\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"negative integer\",\n\t\t\targs:    args{s: \"-123\"},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"float\",\n\t\t\targs:    args{s: \"123.456\"},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"exponential notation\",\n\t\t\targs:    args{s: \"1.23e+4\"},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"exponential notation with negative exponent\",\n\t\t\targs:    args{s: \"1.23e-4\"},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"inf\",\n\t\t\targs:    args{s: \"inf\"},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"Inf\",\n\t\t\targs:    args{s: \"Inf\"},\n\t\t\twantNs:  \"Inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"inF\",\n\t\t\targs:    args{s: \"inF\"},\n\t\t\twantNs:  \"inF\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"NaN\",\n\t\t\targs:    args{s: \"NaN\"},\n\t\t\twantNs:  \"NaN\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"nan\",\n\t\t\targs:    args{s: \"nan\"},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"nAn\",\n\t\t\targs:    args{s: \"nAn\"},\n\t\t\twantNs:  \"nAn\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number\",\n\t\t\targs:    args{s: \"123a\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading plus sign\",\n\t\t\targs:    args{s: \"+123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading minus sign\",\n\t\t\targs:    args{s: \"-123a\"},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading minus sign and inf\",\n\t\t\targs:    args{s: \"-inf\"},\n\t\t\twantNs:  \"-inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading minus sign and nan\",\n\t\t\targs:    args{s: \"-nan\"},\n\t\t\twantNs:  \"-nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading plus sign and inf\",\n\t\t\targs:    args{s: \"+inf\"},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading plus sign and nan\",\n\t\t\targs:    args{s: \"+nan\"},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}",
    "90accc99b0223bbeeeeba3f4b5a0306c": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObjectReset(t *testing.T) {\n\ttype args struct {\n\t\to *Object\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant *Object\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.o.reset(); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Object.reset() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "927442f535b7e4a37d3a499635756263": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no whitespace\",\n\t\t\targs: args{s: \"abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace\",\n\t\t\targs: args{s: \"  abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailing whitespace\",\n\t\t\targs: args{s: \"abc  \"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading and trailing whitespace\",\n\t\t\targs: args{s: \"  abc  \"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"whitespace in the middle\",\n\t\t\targs: args{s: \"a bc\"},\n\t\t\twant: \"bc\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple whitespace\",\n\t\t\targs: args{s: \"  a  b  c  \"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"newline\",\n\t\t\targs: args{s: \"\\n abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"tab\",\n\t\t\targs: args{s: \"\\tabc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"carriage return\",\n\t\t\targs: args{s: \"\\r abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"all whitespace\",\n\t\t\targs: args{s: \"  \\n\\t\\r  \"},\n\t\t\twant: \"\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "931de4c9bc95fb1424329131cacd818c": "package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u world\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u world\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\\\\\ \\\\/\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\x\\\\u world\"},\n\t\t\twant: \"\\\"hello\\\" \\\\world\\\\ /\\\\b\\\\f\\\\n\\\\r\\\\t abcüòÅ\\\\x\\\\u world\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "944cf59ea2ceb697831d45af4347d2e0": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\"world\\\\\\\"\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quotes and other characters\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"\\\\\\\\\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\\\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped closing quote and other characters\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped closing quote and other characters 2\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"\\\\\\\\\\\\\"`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "95389a6837d9eb3a84111077fcf4a879": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"single digit\",\n\t\t\targs: args{\n\t\t\t\ts: \"1\",\n\t\t\t},\n\t\t\twantNs:  \"1\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple digits\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative number\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"decimal number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential number\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential number with negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e-4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zeros\",\n\t\t\targs: args{\n\t\t\t\ts: \"00123\",\n\t\t\t},\n\t\t\twantNs:  \"00123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with trailing zeros\",\n\t\t\targs: args{\n\t\t\t\ts: \"12300\",\n\t\t\t},\n\t\t\twantNs:  \"12300\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading plus sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading minus sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading space\",\n\t\t\targs: args{\n\t\t\t\ts: \" 123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" 123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number with trailing space\",\n\t\t\targs: args{\n\t\t\t\ts: \"123 \",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \" \",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with internal space\",\n\t\t\targs: args{\n\t\t\t\ts: \"12 3\",\n\t\t\t},\n\t\t\twantNs:  \"12\",\n\t\t\twantS:   \" 3\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character\",\n\t\t\targs: args{\n\t\t\t\ts: \"123a\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with NaN\",\n\t\t\targs: args{\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twantNs:  \"NaN\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with NaN in uppercase\",\n\t\t\targs: args{\n\t\t\t\ts: \"NAN\",\n\t\t\t},\n\t\t\twantNs:  \"NAN\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with NaN followed by other characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"NaN123\",\n\t\t\t},\n\t\t\twantNs:  \"NaN\",\n\t\t\twantS:   \"123\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with NaN in lowercase\",\n\t\t\targs: args{\n\t\t\t\ts: \"nan\",\n\t\t\t},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with NaN in lowercase followed by other characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"nan123\",\n\t\t\t},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"123\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid NaN\",\n\t\t\targs: args{\n\t\t\t\ts: \"Na\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"Na\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}",
    "962a6598fdf73728f2ed67799af5edd1": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts: \"null\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts: \"true\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts: \"false\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello\\\"\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts: \"[1,2,3]\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts: `{\"key1\": \"value1\", \"key2\": 2}`,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested object\",\n\t\t\targs: args{\n\t\t\t\ts: `{\"key1\": {\"key2\": \"value2\"}}`,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts: `{\"key1\": [1,2,3]}`,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid json\",\n\t\t\targs: args{\n\t\t\t\ts: `{`,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tp := \u0026Parser{}\n\t\t\tgot, err := p.Parse(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Parse() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr \u0026\u0026 !compareValue(got, tt.want) {\n\t\t\t\tt.Errorf(\"Parse() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValue(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeNull:\n\t\treturn true\n\tcase TypeTrue:\n\t\treturn true\n\tcase TypeFalse:\n\t\treturn true\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !compareValue(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !compareValue(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc TestParse_InvalidJSON(t *testing.T) {\n\tp := \u0026Parser{}\n\t_, err := p.Parse(\"{\")\n\tif err == nil {\n\t\tt.Errorf(\"Parse() should have returned an error for invalid JSON\")\n\t}\n}\n\nfunc TestParse_UnescapedString(t *testing.T) {\n\tp := \u0026Parser{}\n\t_, err := p.Parse(`{\"key\": \"value\\n\"}`)\n\tif err != nil {\n\t\tt.Errorf(\"Parse() should have parsed the unescaped string: %v\", err)\n\t}\n}\n\nfunc TestParse_LargeJSON(t *testing.T) {\n\t// Create a large JSON string\n\tvar largeJSON string\n\tfor i := 0; i \u003c 10000; i++ {\n\t\tlargeJSON += fmt.Sprintf(`{\"key%d\": \"value%d\"}`, i, i)\n\t\tif i \u003c 9999 {\n\t\t\tlargeJSON += \",\"\n\t\t}\n\t}\n\tlargeJSON = \"[\" + largeJSON + \"]\"\n\n\t// Parse the large JSON string\n\tp := \u0026Parser{}\n\t_, err := p.Parse(largeJSON)\n\tif err != nil {\n\t\tt.Errorf(\"Parse() should have parsed the large JSON string: %v\", err)\n\t}\n}\n\nfunc TestParse_CompareWithStdlib(t *testing.T) {\n\ttype TestData struct {\n\t\tJSON string\n\t}\n\n\ttestData := []TestData{\n\t\t{\n\t\t\tJSON: `{\"key1\": \"value1\", \"key2\": 2}`,\n\t\t},\n\t\t{\n\t\t\tJSON: `{\"key1\": {\"key2\": \"value2\"}}`,\n\t\t},\n\t\t{\n\t\t\tJSON: `{\"key1\": [1,2,3]}`,\n\t\t},\n\t\t{\n\t\t\tJSON: `[1,2,3]`,\n\t\t},\n\t\t{\n\t\t\tJSON: `{\"key1\": \"value1\", \"key2\": [1,2,3]}`,\n\t\t},\n\t}\n\n\tfor _, td := range testData {\n\t\tt.Run(td.JSON, func(t *testing.T) {\n\t\t\t// Parse with fastjson\n\t\t\tp := \u0026Parser{}\n\t\t\tv, err := p.Parse(td.JSON)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"fastjson.Parse() error: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Parse with standard library\n\t\t\tvar stdlibValue interface{}\n\t\t\terr = json.Unmarshal([]byte(td.JSON), \u0026stdlibValue)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Compare the results\n\t\t\tif !compareValueWithStdlib(v, stdlibValue) {\n\t\t\t\tt.Errorf(\"fastjson.Parse() and json.Unmarshal() results do not match\")\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValueWithStdlib(v *Value, stdlibValue interface{}) bool {\n\tswitch stdlibValue.(type) {\n\tcase nil:\n\t\treturn v.t == TypeNull\n\tcase bool:\n\t\treturn (v.t == TypeTrue \u0026\u0026 stdlibValue.(bool)) || (v.t == TypeFalse \u0026\u0026 !stdlibValue.(bool))\n\tcase float64:\n\t\treturn v.t == TypeNumber \u0026\u0026 v.s == fmt.Sprintf(\"%v\", stdlibValue)\n\tcase string:\n\t\treturn v.t == TypeString \u0026\u0026 v.s == stdlibValue.(string)\n\tcase []interface{}:\n\t\tif v.t != TypeArray {\n\t\t\treturn false\n\t\t}\n\t\tif len(v.a) != len(stdlibValue.([]interface{})) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v.a {\n\t\t\tif !compareValueWithStdlib(v.a[i], stdlibValue.([]interface{})[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase map[string]interface{}:\n\t\tif v.t != TypeObject {\n\t\t\treturn false\n\t\t}\n\t\tif len(v.o.kvs) != len(stdlibValue.(map[string]interface{})) {\n\t\t\treturn false\n\t\t}\n\t\tfor k, stdlibValue := range stdlibValue.(map[string]interface{}) {\n\t\t\tfor _, kv := range v.o.kvs {\n\t\t\t\tif kv.k == k {\n\t\t\t\t\tif !compareValueWithStdlib(kv.v, stdlibValue) {\n\t\t\t\t\t\treturn false\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}",
    "973c84c52e171785247ca35616aa1d1f": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWS(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"single whitespace\",\n\t\t\targs: args{s: \" \"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple whitespaces\",\n\t\t\targs: args{s: \"   \"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace\",\n\t\t\targs: args{s: \"  hello\"},\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailing whitespace\",\n\t\t\targs: args{s: \"hello  \"},\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading and trailing whitespace\",\n\t\t\targs: args{s: \"  hello  \"},\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"no whitespace\",\n\t\t\targs: args{s: \"hello\"},\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"single character\",\n\t\t\targs: args{s: \"a\"},\n\t\t\twant: \"a\",\n\t\t},\n\t\t{\n\t\t\tname: \"special character\",\n\t\t\targs: args{s: \"!\"},\n\t\t\twant: \"!\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWS(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWS() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "97f2c7add671ebe3902cf2bb0b7a7f33": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_JSON(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_JSON_Compare(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tvar want map[string]interface{}\n\t\t\tif err := json.Unmarshal([]byte(tt.args.s), \u0026want); err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got.o.kvs, want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got.o.kvs, want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "988e774d0c9bbf8ebec69401aa6197ef": "package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u world\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u world\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\\\\\ \\\\/\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\x\\\\u world\"},\n\t\t\twant: \"\\\"hello\\\" \\\\world\\\\ /\\\\b\\\\f\\\\n\\\\r\\tabcüòÅ\\\\x\\\\u world\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "98c795bf1798c0c906aef3710ac7839f": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestHasSpecialChars(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with no special characters\",\n\t\t\targs: args{s: \"abcdefg\"},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with special character '\\\\'\",\n\t\t\targs: args{s: \"abc\\\\defg\"},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with special character '\u003c' \",\n\t\t\targs: args{s: \"abc\u003cdefg\"},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with special character '\u003e' \",\n\t\t\targs: args{s: \"abc\u003edefg\"},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with special character '\\\"' \",\n\t\t\targs: args{s: \"abc\\\"defg\"},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with special character '/' \",\n\t\t\targs: args{s: \"abc/defg\"},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with special character ':' \",\n\t\t\targs: args{s: \"abc:defg\"},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with special character ',' \",\n\t\t\targs: args{s: \"abc,defg\"},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with special character '[' \",\n\t\t\targs: args{s: \"abc[defg\"},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with special character ']' \",\n\t\t\targs: args{s: \"abc]defg\"},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with special character '{' \",\n\t\t\targs: args{s: \"abc{defg\"},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with special character '}' \",\n\t\t\targs: args{s: \"abc}defg\"},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with special character ' ' \",\n\t\t\targs: args{s: \"abc defg\"},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with special character '\\t' \",\n\t\t\targs: args{s: \"abc\\tdefg\"},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with special character '\\n' \",\n\t\t\targs: args{s: \"abc\\ndefg\"},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with special character '\\r' \",\n\t\t\targs: args{s: \"abc\\rdefg\"},\n\t\t\twant: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := hasSpecialChars(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"hasSpecialChars() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "9914998199e4809edead0dd3661441c4": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\"`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with leading and trailing spaces\",\n\t\t\targs: args{\n\t\t\t\ts: `\"  hello  \"`,\n\t\t\t},\n\t\t\twant:    \"  hello  \",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped backslash\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\\world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "99f957235d301b83e920e28e6e699f3b": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"single element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,3]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[[1,2],[3,4]]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"4\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1,2\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid array value\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,a]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1,2,a]\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1 2]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1 2]\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseArray() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "9a400049bc667439078b6f295edaa514": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"single element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,3]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[[1,2],[3,4]]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"4\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with whitespace\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[ 1 , 2 , 3 ]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1,2\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1 2]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1 2]\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected end of array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1,\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseArray() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "9b380eec8fa2e09aba0eeacd0f8da3ef": "package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u006\"},\n\t\t\twant: \"\\\\u0061\\\\u006\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\\\\\ \\\\/\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\x\\\\u006\"},\n\t\t\twant: \"\\\"hello\\\" \\\\world\\\\ /\\\\b\\\\f\\\\n\\\\r\\\\tabcüòÅ\\\\x\\\\u006\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "9c63bb399dab302f6903eab6bf141443": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCacheGetValue(t *testing.T) {\n\tt.Run(\"EmptyCache\", func(t *testing.T) {\n\t\tc := \u0026cache{}\n\t\tv := c.getValue()\n\t\tif v == nil {\n\t\t\tt.Error(\"Expected non-nil value, got nil\")\n\t\t}\n\t})\n\n\tt.Run(\"NonEmptyCache\", func(t *testing.T) {\n\t\tc := \u0026cache{\n\t\t\tvs: []Value{{t: TypeNull}},\n\t\t}\n\t\tv := c.getValue()\n\t\tif v == nil {\n\t\t\tt.Error(\"Expected non-nil value, got nil\")\n\t\t}\n\t\tif v.t != TypeNull {\n\t\t\tt.Errorf(\"Expected value type %v, got %v\", TypeNull, v.t)\n\t\t}\n\t})\n\n\tt.Run(\"CacheWithCapacity\", func(t *testing.T) {\n\t\tc := \u0026cache{\n\t\t\tvs: make([]Value, 0, 10),\n\t\t}\n\t\tv := c.getValue()\n\t\tif v == nil {\n\t\t\tt.Error(\"Expected non-nil value, got nil\")\n\t\t}\n\t\tif len(c.vs) != 1 {\n\t\t\tt.Errorf(\"Expected cache length to be 1, got %d\", len(c.vs))\n\t\t}\n\t})\n}",
    "9d1c733b765c6e5bb2e318b7bf7b1f1d": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetFloat64(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.GetFloat64(tt.args.keys...); got != tt.want {\n\t\t\t\tt.Errorf(\"Value.GetFloat64() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "9d722c9775b36fd5ffebc9644db7afd5": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantKey string\n\t\twantTail string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"simple key\",\n\t\t\targs:    args{s: `\"key\"`},\n\t\t\twantKey: \"key\",\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"key with spaces\",\n\t\t\targs:    args{s: `\"key with spaces\"`},\n\t\t\twantKey: \"key with spaces\",\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"key with special characters\",\n\t\t\targs:    args{s: `\"key\\\\\"with\\\\\"special\\\\\"characters\"`},\n\t\t\twantKey: \"key\\\\\\\"with\\\\\\\"special\\\\\\\"characters\",\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"missing closing quote\",\n\t\t\targs:    args{s: `\"key`},\n\t\t\twantKey: \"\",\n\t\t\twantTail: \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"escaped quote\",\n\t\t\targs:    args{s: `\"key\\\\\"\"`},\n\t\t\twantKey: \"key\\\"\",\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"escaped backslash\",\n\t\t\targs:    args{s: `\"key\\\\\\\\\"`},\n\t\t\twantKey: \"key\\\\\",\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotKey, gotTail, err := parseRawKey(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawKey() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotKey != tt.wantKey {\n\t\t\t\tt.Errorf(\"parseRawKey() gotKey = %v, want %v\", gotKey, tt.wantKey)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseRawKey() gotTail = %v, want %v\", gotTail, tt.wantTail)\n\t\t\t}\n\t\t})\n\t}\n}",
    "9ded4cbbfb091b99193517a3125351b6": "package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\x\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\x\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\ux\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\ux\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\ux\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\ux\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with incomplete hex\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\u\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\u\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "9e07e1684a9175571829fc4b6c2848ae": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGet(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant *Value\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.Get(tt.args.keys...); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Get() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "9e0ed56369c9670fc81d5c33642bb3d0": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWS(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no whitespace\",\n\t\t\targs: args{s: \"abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace\",\n\t\t\targs: args{s: \"  abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailing whitespace\",\n\t\t\targs: args{s: \"abc  \"},\n\t\t\twant: \"abc  \",\n\t\t},\n\t\t{\n\t\t\tname: \"leading and trailing whitespace\",\n\t\t\targs: args{s: \"  abc  \"},\n\t\t\twant: \"abc  \",\n\t\t},\n\t\t{\n\t\t\tname: \"internal whitespace\",\n\t\t\targs: args{s: \"a bc\"},\n\t\t\twant: \"a bc\",\n\t\t},\n\t\t{\n\t\t\tname: \"mixed whitespace\",\n\t\t\targs: args{s: \"  a  bc  \"},\n\t\t\twant: \"a  bc  \",\n\t\t},\n\t\t{\n\t\t\tname: \"non-whitespace character\",\n\t\t\targs: args{s: \"a!bc\"},\n\t\t\twant: \"a!bc\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWS(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWS() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "9e524aa14aefac4ab3ed67beab293c90": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no whitespace\",\n\t\t\targs: args{s: \"hello\"},\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace\",\n\t\t\targs: args{s: \"  hello\"},\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailing whitespace\",\n\t\t\targs: args{s: \"hello  \"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading and trailing whitespace\",\n\t\t\targs: args{s: \"  hello  \"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"whitespace in the middle\",\n\t\t\targs: args{s: \"hello  world\"},\n\t\t\twant: \"world\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple whitespace\",\n\t\t\targs: args{s: \"  hello  world  \"},\n\t\t\twant: \"world\",\n\t\t},\n\t\t{\n\t\t\tname: \"newline\",\n\t\t\targs: args{s: \"\\nhello\"},\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"tab\",\n\t\t\targs: args{s: \"\\thello\"},\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"carriage return\",\n\t\t\targs: args{s: \"\\rhello\"},\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"mixed whitespace\",\n\t\t\targs: args{s: \" \\t\\n\\rhello\"},\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"all whitespace\",\n\t\t\targs: args{s: \" \\t\\n\\r\"},\n\t\t\twant: \"\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "9ecd12b15090c9fb41c1b44b254548bd": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escaped strings\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"again\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\\\\\\\"again\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\"`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with spaces\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello world\"`,\n\t\t\t},\n\t\t\twant:    \"hello world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with special characters\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\tworld\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\tworld\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "9f53176c39cd51e97ea861dcb0f5391f": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth + 1,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"{}\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\": \"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"value1\", \"value2\"]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"value\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"value\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   `true`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueTrue,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   `false`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueFalse,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   `null`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueNull,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   `NaN`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected value\",\n\t\t\targs: args{\n\t\t\t\ts:   `abc`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `abc`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseValue() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseValue_JSON(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    interface{}\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts: `{\"key\": \"value\"}`,\n\t\t\t},\n\t\t\twant:    map[string]interface{}{\"key\": \"value\"},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts: `[\"value1\", \"value2\"]`,\n\t\t\t},\n\t\t\twant:    []interface{}{\"value1\", \"value2\"},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"value\"`,\n\t\t\t},\n\t\t\twant:    \"value\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts: `true`,\n\t\t\t},\n\t\t\twant:    true,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts: `false`,\n\t\t\t},\n\t\t\twant:    false,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts: `null`,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts: `123`,\n\t\t\t},\n\t\t\twant:    float64(123),\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts: `NaN`,\n\t\t\t},\n\t\t\twant:    json.Number(\"NaN\"),\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, _, err := parseValue(tt.args.s, c, 0)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got.Interface(), tt.want) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got.Interface(), tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "9f91440c10436878372c66e4c407c431": "package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n)\n\nfunc TestEscapeString(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\ts   string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\ts:   \"\",\n\t\t\t},\n\t\t\twant: []byte(`\"\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\ts:   \"hello\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"string with special characters\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\ts:   \"hello, world!\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello, world!\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped characters\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\ts:   `\"\\t\\r\\n\"`,\n\t\t\t},\n\t\t\twant: []byte(`\"\\\\t\\\\r\\\\n\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"string with unicode characters\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\ts:   \"‰Ω†Â•Ω‰∏ñÁïå\",\n\t\t\t},\n\t\t\twant: []byte(`\"‰Ω†Â•Ω‰∏ñÁïå\"`),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := escapeString(tt.args.dst, tt.args.s); !bytesEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"escapeString() = %v, want %v\", string(got), string(tt.want))\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc bytesEqual(a, b []byte) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "9fedd9038220768c2bac39e510f99dc1": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCacheGetValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\t// Test empty cache\n\tv := c.getValue()\n\tif v == nil {\n\t\tt.Error(\"getValue() returned nil for empty cache\")\n\t}\n\n\t// Test appending to cache\n\tv = c.getValue()\n\tif v == nil {\n\t\tt.Error(\"getValue() returned nil after appending\")\n\t}\n\n\t// Test capacity handling\n\tc.vs = make([]Value, 10)\n\tv = c.getValue()\n\tif v == nil {\n\t\tt.Error(\"getValue() returned nil after setting capacity\")\n\t}\n}",
    "a0373d3677e79e645b6cf3ae1430e524": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"single element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,3]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[[1,2],[3,4]]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"4\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with whitespace\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[ 1 , 2 , 3 ]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,3\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1,2,3\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1 2,3]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1 2,3]\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected end of array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1,2,\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseArray() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a0be294fe6b017709180cd40c5a0fee5": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetFloat64(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.GetFloat64(tt.args.keys...); got != tt.want {\n\t\t\t\tt.Errorf(\"Value.GetFloat64() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a182a5363911766a168f3e7aaec2dfd7": "package fastjson\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\tv   *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNull},\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeTrue},\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeFalse},\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeString, s: \"hello\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t},\n\t\t\twant: []byte(\"123\"),\n\t\t},\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: typeRawString, s: \"hello\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{t: TypeString, s: \"hello\"},\n\t\t\t\t\t\t{t: TypeNumber, s: \"123\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`[\"hello\",123]`),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{k: \"name\", v: \u0026Value{t: TypeString, s: \"John Doe\"}},\n\t\t\t\t\t\t\t{k: \"age\", v: \u0026Value{t: TypeNumber, s: \"30\"}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`{\"name\":\"John Doe\",\"age\":30}`),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.v.MarshalTo(tt.args.dst); !bytes.Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a1999ce8c66e2667b511eb94b5a41394": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"simple integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"float\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential notation\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential notation with lowercase e\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e-4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"inf\",\n\t\t\t},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"INF\",\n\t\t\targs: args{\n\t\t\t\ts: \"INF\",\n\t\t\t},\n\t\t\twantNs:  \"INF\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"nan\",\n\t\t\t},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NAN\",\n\t\t\targs: args{\n\t\t\t\ts: \"NAN\",\n\t\t\t},\n\t\t\twantNs:  \"NAN\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123a\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"-inf\",\n\t\t\t},\n\t\t\twantNs:  \"-inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"-nan\",\n\t\t\t},\n\t\t\twantNs:  \"-nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a1df8c3e567b7b354393345c6fe5b1af": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueGet(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant *Value\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.Get(tt.args.keys...); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.Get() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a235cfa8a800f97d978cf0010f204605": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth + 1,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"{}\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\": \"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"value1\", \"value2\"]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"value\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"value\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   `true`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueTrue,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   `false`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueFalse,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   `null`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueNull,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with decimal\",\n\t\t\targs: args{\n\t\t\t\ts:   `123.456`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e+4`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e-4`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"1.23e-4\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `-123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative sign and decimal\",\n\t\t\targs: args{\n\t\t\t\ts:   `-123.456`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-123.456\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative sign and exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `-1.23e+4`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-1.23e+4\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative sign and negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `-1.23e-4`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-1.23e-4\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   `NaN`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected value\",\n\t\t\targs: args{\n\t\t\t\ts:   `tru`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"tru\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseValue() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseValue_JSON(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    interface{}\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts: `{\"key\": \"value\"}`,\n\t\t\t},\n\t\t\twant:    map[string]interface{}{\"key\": \"value\"},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts: `[\"value1\", \"value2\"]`,\n\t\t\t},\n\t\t\twant:    []interface{}{\"value1\", \"value2\"},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"value\"`,\n\t\t\t},\n\t\t\twant:    \"value\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts: `true`,\n\t\t\t},\n\t\t\twant:    true,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts: `false`,\n\t\t\t},\n\t\t\twant:    false,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts: `null`,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts: `123`,\n\t\t\t},\n\t\t\twant:    float64(123),\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with decimal\",\n\t\t\targs: args{\n\t\t\t\ts: `123.456`,\n\t\t\t},\n\t\t\twant:    float64(123.456),\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with exponent\",\n\t\t\targs: args{\n\t\t\t\ts: `1.23e+4`,\n\t\t\t},\n\t\t\twant:    float64(1.23e+4),\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts: `1.23e-4`,\n\t\t\t},\n\t\t\twant:    float64(1.23e-4),\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative sign\",\n\t\t\targs: args{\n\t\t\t\ts: `-123`,\n\t\t\t},\n\t\t\twant:    float64(-123),\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative sign and decimal\",\n\t\t\targs: args{\n\t\t\t\ts: `-123.456`,\n\t\t\t},\n\t\t\twant:    float64(-123.456),\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative sign and exponent\",\n\t\t\targs: args{\n\t\t\t\ts: `-1.23e+4`,\n\t\t\t},\n\t\t\twant:    float64(-1.23e+4),\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative sign and negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts: `-1.23e-4`,\n\t\t\t},\n\t\t\twant:    float64(-1.23e-4),\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts: `NaN`,\n\t\t\t},\n\t\t\twant:    json.Number(\"NaN\"),\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, _, err := parseValue(tt.args.s, c, 0)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got.Interface(), tt.want) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got.Interface(), tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseValue_Error(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth + 1,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid true\",\n\t\t\targs: args{\n\t\t\t\ts:   `tru`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid false\",\n\t\t\targs: args{\n\t\t\t\ts:   `fals`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid null\",\n\t\t\targs: args{\n\t\t\t\ts:   `nul`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123.`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t_, _, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t})\n\t}\n}",
    "a25d25f02f8b86580274389aa74aef8f": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth + 1,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"{}\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\": \"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"value1\", \"value2\"]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"value\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"value\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   `true`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueTrue,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   `false`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueFalse,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   `null`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueNull,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   `NaN`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected value\",\n\t\t\targs: args{\n\t\t\t\ts:   `abc`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `abc`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseValue() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseValue_JSON(t *testing.T) {\n\ttype testCase struct {\n\t\tinput string\n\t\twant  string\n\t}\n\ttestCases := []testCase{\n\t\t{\n\t\t\tinput: `{\"key\": \"value\"}`,\n\t\t\twant:  `{\"key\":\"value\"}`,\n\t\t},\n\t\t{\n\t\t\tinput: `[\"value1\", \"value2\"]`,\n\t\t\twant:  `[\"value1\",\"value2\"]`,\n\t\t},\n\t\t{\n\t\t\tinput: `\"value\"`,\n\t\t\twant:  `\"value\"`,\n\t\t},\n\t\t{\n\t\t\tinput: `true`,\n\t\t\twant:  `true`,\n\t\t},\n\t\t{\n\t\t\tinput: `false`,\n\t\t\twant:  `false`,\n\t\t},\n\t\t{\n\t\t\tinput: `null`,\n\t\t\twant:  `null`,\n\t\t},\n\t\t{\n\t\t\tinput: `123`,\n\t\t\twant:  `123`,\n\t\t},\n\t\t{\n\t\t\tinput: `NaN`,\n\t\t\twant:  `NaN`,\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.input, func(t *testing.T) {\n\t\t\tv, _, err := parseValue(tc.input, \u0026cache{}, 0)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"parseValue() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tb, err := json.Marshal(v)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"json.Marshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif string(b) != tc.want {\n\t\t\t\tt.Errorf(\"parseValue() got = %s, want %s\", string(b), tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a26b80d5cf03fc8984eb5057109c119c": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttype want struct {\n\t\tv   *Value\n\t\ttail string\n\t\terr  error\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant want\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  fmt.Errorf(\"cannot parse empty string\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"{}\",\n\t\t\t\terr:  fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{t: TypeObject, o: Object{}},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{t: TypeArray, a: []*Value{}},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"hello\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{t: typeRawString, s: \"hello\"},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   \"true\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueTrue,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   \"false\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueFalse,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   \"null\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueNull,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   \"123\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\ts:   \"NaN\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"NaN\"},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotV, gotTail, gotErr := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif gotErr != nil \u0026\u0026 tt.want.err == nil {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, want nil\", gotErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotErr == nil \u0026\u0026 tt.want.err != nil {\n\t\t\t\tt.Errorf(\"parseValue() error = nil, want %v\", tt.want.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotErr != nil \u0026\u0026 tt.want.err != nil {\n\t\t\t\tif gotErr.Error() != tt.want.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue() error = %v, want %v\", gotErr, tt.want.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(gotV, tt.want.v) {\n\t\t\t\tt.Errorf(\"parseValue() gotV = %v, want %v\", gotV, tt.want.v)\n\t\t\t}\n\t\t\tif gotTail != tt.want.tail {\n\t\t\t\tt.Errorf(\"parseValue() gotTail = %v, want %v\", gotTail, tt.want.tail)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a26ff4e2909ed2e5edc90ee00447e0ab": "package fastjson\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\tv   *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNull},\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeTrue},\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeFalse},\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeString, s: \"hello\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: typeRawString, s: \"hello\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t},\n\t\t\twant: []byte(\"123\"),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{t: TypeString, s: \"hello\"},\n\t\t\t\t\t\t{t: TypeNumber, s: \"123\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`[\"hello\",123]`),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{k: \"name\", v: \u0026Value{t: TypeString, s: \"John Doe\"}},\n\t\t\t\t\t\t\t{k: \"age\", v: \u0026Value{t: TypeNumber, s: \"30\"}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`{\"name\":\"John Doe\",\"age\":30}`),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.v.MarshalTo(tt.args.dst); !bytes.Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a2c3d304cfd86c61fd58859dae8a49a4": "package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u006\"},\n\t\t\twant: \"\\\\u0061\\\\u006\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\\\\\ \\\\/\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\x\\\\u006\"},\n\t\t\twant: \"\\\"hello\\\" \\\\world\\\\ /\\\\b\\\\f\\\\n\\\\r\\\\tabcüòÅ\\\\x\\\\u006\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a2f4f8f4570d0c7dbc3af7e259d2ec73": "```go\npackage fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 2\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u123\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 3\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 4\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\u\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\u\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 5\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\u123\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\u123\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 6\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 7\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u123\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u123\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 8\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 9\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\\\\u\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\\\\u\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 10\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\\\\u1234\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\\\\u1234\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 11\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\\\\u1234\\\\u\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\\\\u1234\\\\u\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 12\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\\\\u1234\\\\u1234\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\\\\u1234\\\\u1234\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 13\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\\\\u1234\\\\u1234\\\\u\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\\\\u1234\\\\u1234\\\\u\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 14\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\\\\u1234\\\\u1234\\\\u1234\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\\\\u1234\\\\u1234\\\\u1234\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 15\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 16\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 17\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 18\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 19\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 20\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 21\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 22\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 23\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 24\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 25\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 26\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 27\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 28\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 29\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 30\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 31\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 32\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 33\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 34\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 35\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 36\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 37\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 38\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 39\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 40\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 41\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence 42\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u1234\\\\u",
    "a31ab6e2a85edb4433203a49ee3c665e": "package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u world\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u world\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\\\\\ \\\\/test\\\\/\"},\n\t\t\twant: \"\\\"hello\\\" \\\\world\\\\ /test/\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a33528d332979ee2e87754f0c86d20ab": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"single element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,3]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[[1,2],[3,4]]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"4\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with string elements\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[\\\"hello\\\",\\\"world\\\"]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"hello\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"world\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1,2\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"array with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1 2]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1 2]\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseArray() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a3df68aeb767bb59890390b17452dac4": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_JSONUnmarshal(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    map[string]interface{}\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    map[string]interface{}{},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    map[string]interface{}{\"key1\": \"value1\", \"key2\": \"value2\"},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    map[string]interface{}{\"key1\": map[string]interface{}{\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    map[string]interface{}{\"key\\\"1\": \"value1\"},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif tt.wantErr {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tvar want map[string]interface{}\n\t\t\tif err := json.Unmarshal([]byte(tt.args.s), \u0026want); err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got.o.ToMap(), want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got.o.ToMap(), want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a3e48b7e8794256346743472b05097d3": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello world\",\n\t\t\t},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\\\\"hello\\\\\\\"\",\n\t\t\t},\n\t\t\twant: \"\\\"hello\\\"\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\\\\\hello\\\\\\\\\",\n\t\t\t},\n\t\t\twant: \"\\\\hello\\\\\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\/hello\\\\/\",\n\t\t\t},\n\t\t\twant: \"/hello/\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\bhello\\\\b\",\n\t\t\t},\n\t\t\twant: \"\\bhello\\b\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\fhello\\\\f\",\n\t\t\t},\n\t\t\twant: \"\\fhello\\f\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\nhello\\\\n\",\n\t\t\t},\n\t\t\twant: \"\\nhello\\n\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\rhello\\\\r\",\n\t\t\t},\n\t\t\twant: \"\\rhello\\r\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\thello\\\\t\",\n\t\t\t},\n\t\t\twant: \"\\thello\\t\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\u0061hello\\\\u0062\",\n\t\t\t},\n\t\t\twant: \"ahello\\x62\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\xhello\\\\x\",\n\t\t\t},\n\t\t\twant: \"\\\\xhello\\\\x\",\n\t\t},\n\t\t{\n\t\t\tname: \"surrogate pair\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\uD83D\\\\uDE01\",\n\t\t\t},\n\t\t\twant: \"\\U0001F601\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\\\\\ \\\\/test\\\\/\",\n\t\t\t},\n\t\t\twant: \"\\\"hello\\\" \\\\world\\\\ /test/\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a4fba82f647f277618decc132ad6bbbd": "package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u006\"},\n\t\t\twant: \"\\\\u0061\\\\u006\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\\\\\ \\\\/\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\x\\\\u006\"},\n\t\t\twant: \"\\\"hello\\\" \\\\world\\\\ /\\\\b\\\\f\\\\n\\\\r\\\\tabcüòÅ\\\\x\\\\u006\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a5b8556bdc21d1ed32652816cb936193": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\tv   *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.v.MarshalTo(tt.args.dst); !bytes.Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a5e01f7b9aa5ec2f7147d5827f47b853": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestType_String(t *testing.T) {\n\ttype args struct {\n\t\tt Type\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"TestType_String_Object\",\n\t\t\targs: args{t: TypeObject},\n\t\t\twant: \"object\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_Array\",\n\t\t\targs: args{t: TypeArray},\n\t\t\twant: \"array\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_String\",\n\t\t\targs: args{t: TypeString},\n\t\t\twant: \"string\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_Number\",\n\t\t\targs: args{t: TypeNumber},\n\t\t\twant: \"number\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_True\",\n\t\t\targs: args{t: TypeTrue},\n\t\t\twant: \"true\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_False\",\n\t\t\targs: args{t: TypeFalse},\n\t\t\twant: \"false\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_Null\",\n\t\t\targs: args{t: TypeNull},\n\t\t\twant: \"null\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.t.String(); got != tt.want {\n\t\t\t\tt.Errorf(\"Type.String() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a5e6d71fa8c194773dae5aec918f7650": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_JSON(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_JSON_Compare(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tvar want map[string]interface{}\n\t\t\tif err := json.Unmarshal([]byte(tt.args.s), \u0026want); err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got.o.kvs, want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got.o.kvs, want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a68b8acf83004d4b6f250b3f0d6d4899": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_JSONUnmarshal(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    map[string]interface{}\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    map[string]interface{}{},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    map[string]interface{}{\"key1\": \"value1\", \"key2\": \"value2\"},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    map[string]interface{}{\"key1\": map[string]interface{}{\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    map[string]interface{}{\"key\\\"1\": \"value1\"},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got.Type() != TypeObject {\n\t\t\t\tt.Errorf(\"parseObject() got.Type() = %v, want %v\", got.Type(), TypeObject)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tvar want map[string]interface{}\n\t\t\tif err := json.Unmarshal([]byte(tt.args.s), \u0026want); err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got.Object().ToMap(), want) {\n\t\t\t\tt.Errorf(\"parseObject() got.Object().ToMap() = %v, want %v\", got.Object().ToMap(), want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a70e42d00ffb9791be3db5ccdfec5efc": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\tv   *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"RawString\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: typeRawString, s: \"test\"},\n\t\t\t},\n\t\t\twant: []byte(`\"test\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"Object\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{t: TypeString, s: \"value\"}}}}},\n\t\t\t},\n\t\t\twant: []byte(`{\"key\":\"value\"}`),\n\t\t},\n\t\t{\n\t\t\tname: \"Array\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeArray, a: []*Value{{t: TypeString, s: \"value1\"}, {t: TypeString, s: \"value2\"}}},\n\t\t\t},\n\t\t\twant: []byte(`[\"value1\",\"value2\"]`),\n\t\t},\n\t\t{\n\t\t\tname: \"String\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeString, s: \"test\"},\n\t\t\t},\n\t\t\twant: []byte(`\"test\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"Number\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t},\n\t\t\twant: []byte(`123`),\n\t\t},\n\t\t{\n\t\t\tname: \"True\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeTrue},\n\t\t\t},\n\t\t\twant: []byte(`true`),\n\t\t},\n\t\t{\n\t\t\tname: \"False\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeFalse},\n\t\t\t},\n\t\t\twant: []byte(`false`),\n\t\t},\n\t\t{\n\t\t\tname: \"Null\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNull},\n\t\t\t},\n\t\t\twant: []byte(`null`),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.v.MarshalTo(tt.args.dst); !bytesEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc bytesEqual(a, b []byte) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "a811fb62916e790dd566077bd6a35109": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestType_String(t *testing.T) {\n\ttype args struct {\n\t\tt Type\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"TestType_String_Object\",\n\t\t\targs: args{t: TypeObject},\n\t\t\twant: \"object\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_Array\",\n\t\t\targs: args{t: TypeArray},\n\t\t\twant: \"array\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_String\",\n\t\t\targs: args{t: TypeString},\n\t\t\twant: \"string\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_Number\",\n\t\t\targs: args{t: TypeNumber},\n\t\t\twant: \"number\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_True\",\n\t\t\targs: args{t: TypeTrue},\n\t\t\twant: \"true\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_False\",\n\t\t\targs: args{t: TypeFalse},\n\t\t\twant: \"false\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_Null\",\n\t\t\targs: args{t: TypeNull},\n\t\t\twant: \"null\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.t.String(); got != tt.want {\n\t\t\t\tt.Errorf(\"Type.String() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a9e232b93b484e6e3469207334efc237": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCacheGetValue(t *testing.T) {\n\ttype args struct {\n\t\tc *cache\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant *Value\n\t}{\n\t\t{\n\t\t\tname: \"empty cache\",\n\t\t\targs: args{\n\t\t\t\tc: \u0026cache{},\n\t\t\t},\n\t\t\twant: \u0026Value{},\n\t\t},\n\t\t{\n\t\t\tname: \"non-empty cache\",\n\t\t\targs: args{\n\t\t\t\tc: \u0026cache{\n\t\t\t\t\tvs: []Value{\n\t\t\t\t\t\t{t: TypeString, s: \"test\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: \u0026Value{t: TypeString, s: \"test\"},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.c.getValue(); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"cache.getValue() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "aa6b9126a55855fa7d61ff927be5d07b": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_unescapeKeys(t *testing.T) {\n\ttype args struct {\n\t\to *Object\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\ttt.args.o.unescapeKeys()\n\t\t\tif got := tt.args.o.keysUnescaped; got != tt.want {\n\t\t\t\tt.Errorf(\"Object.unescapeKeys() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "aadbb8a32afe4362ea210a5afd1631b3": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Get(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttype want struct {\n\t\twant *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant want\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.Get(tt.args.keys...); !reflect.DeepEqual(got, tt.want.want) {\n\t\t\t\tt.Errorf(\"Value.Get() = %v, want %v\", got, tt.want.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "ab7254c63d697a2098f1843de7716d02": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetFloat64(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.GetFloat64(tt.args.keys...); got != tt.want {\n\t\t\t\tt.Errorf(\"Value.GetFloat64() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "abaa0a9b4a1101f0ffe6fbdd0d47f13e": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no whitespace\",\n\t\t\targs: args{s: \"abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace\",\n\t\t\targs: args{s: \"  abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailing whitespace\",\n\t\t\targs: args{s: \"abc  \"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading and trailing whitespace\",\n\t\t\targs: args{s: \"  abc  \"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"whitespace in the middle\",\n\t\t\targs: args{s: \"a bc\"},\n\t\t\twant: \"bc\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple whitespace\",\n\t\t\targs: args{s: \"  a  b  c  \"},\n\t\t\twant: \"a  b  c\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading newline\",\n\t\t\targs: args{s: \"\\n abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading tab\",\n\t\t\targs: args{s: \"\\t abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading carriage return\",\n\t\t\targs: args{s: \"\\r abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading and trailing newline\",\n\t\t\targs: args{s: \"\\n abc \\n\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading and trailing tab\",\n\t\t\targs: args{s: \"\\t abc \\t\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading and trailing carriage return\",\n\t\t\targs: args{s: \"\\r abc \\r\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"all whitespace\",\n\t\t\targs: args{s: \"  \\n\\t\\r  \"},\n\t\t\twant: \"\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "abc7cd4d914a92eeb50b3ac0d0168973": "```go\npackage fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"simple integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"float number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential number\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential number with negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e-4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"inf\",\n\t\t\t},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"INF\",\n\t\t\targs: args{\n\t\t\t\ts: \"INF\",\n\t\t\t},\n\t\t\twantNs:  \"INF\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"nan\",\n\t\t\t},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NAN\",\n\t\t\targs: args{\n\t\t\t\ts: \"NAN\",\n\t\t\t},\n\t\t\twantNs:  \"NAN\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace\",\n\t\t\targs: args{\n\t\t\t\ts: \" 123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" 123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"trailing whitespace\",\n\t\t\targs: args{\n\t\t\t\ts: \"123 \",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \" \",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"leading and trailing",
    "abf55f53ceb89bc55eca47b43f24c5c4": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\"`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\" \"value1\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_JSON(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != \"\" {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, \"\")\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_JSON_Compare(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tvar want map[string]interface{}\n\t\t\tif err := json.Unmarshal([]byte(tt.args.s), \u0026want); err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got.o.kvs, want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got.o.kvs, want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "ac3e7c0295a352264e9924a302df5bfd": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantKey string\n\t\twantTail string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"simple key\",\n\t\t\targs:    args{s: `\"key\"`},\n\t\t\twantKey: \"key\",\n\t\t\twantTail: `\"`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"key with spaces\",\n\t\t\targs:    args{s: `\"key with spaces\"`},\n\t\t\twantKey: \"key with spaces\",\n\t\t\twantTail: `\"`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"key with special characters\",\n\t\t\targs:    args{s: `\"key\\\\\"with\\\\\"special\\\\\"characters\"`},\n\t\t\twantKey: \"key\\\\\\\"with\\\\\\\"special\\\\\\\"characters\",\n\t\t\twantTail: `\"`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"missing closing quote\",\n\t\t\targs:    args{s: `\"key`},\n\t\t\twantKey: \"key\",\n\t\t\twantTail: \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"empty key\",\n\t\t\targs:    args{s: `\"\"`},\n\t\t\twantKey: \"\",\n\t\t\twantTail: `\"`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"escaped quote\",\n\t\t\targs:    args{s: `\"key\\\\\"\"`},\n\t\t\twantKey: \"key\\\"\",\n\t\t\twantTail: `\"`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"escaped backslash\",\n\t\t\targs:    args{s: `\"key\\\\\\\\\"`},\n\t\t\twantKey: \"key\\\\\",\n\t\t\twantTail: `\"`,\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotKey, gotTail, err := parseRawKey(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawKey() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotKey != tt.wantKey {\n\t\t\t\tt.Errorf(\"parseRawKey() gotKey = %v, want %v\", gotKey, tt.wantKey)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseRawKey() gotTail = %v, want %v\", gotTail, tt.wantTail)\n\t\t\t}\n\t\t})\n\t}\n}",
    "ac7b78a14ebcaa3e2da32258ce951a82": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"empty string\",\n\t\t\targs:    args{s: \"\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"single digit\",\n\t\t\targs:    args{s: \"1\"},\n\t\t\twantNs:  \"1\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"multiple digits\",\n\t\t\targs:    args{s: \"123\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"negative number\",\n\t\t\targs:    args{s: \"-123\"},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"decimal number\",\n\t\t\targs:    args{s: \"123.456\"},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"exponential number\",\n\t\t\targs:    args{s: \"1.23e+4\"},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading zeros\",\n\t\t\targs:    args{s: \"00123\"},\n\t\t\twantNs:  \"00123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with trailing zeros\",\n\t\t\targs:    args{s: \"123.00\"},\n\t\t\twantNs:  \"123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign\",\n\t\t\targs:    args{s: \"+123\"},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with trailing non-numeric character\",\n\t\t\targs:    args{s: \"123a\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading non-numeric character\",\n\t\t\targs:    args{s: \"a123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"a123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with embedded non-numeric character\",\n\t\t\targs:    args{s: \"123a456\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a456\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}",
    "adf277bf36616eaa81aa73858644bb63": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestType_String(t *testing.T) {\n\ttype args struct {\n\t\tt Type\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"TestType_String_Object\",\n\t\t\targs: args{t: TypeObject},\n\t\t\twant: \"object\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_Array\",\n\t\t\targs: args{t: TypeArray},\n\t\t\twant: \"array\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_String\",\n\t\t\targs: args{t: TypeString},\n\t\t\twant: \"string\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_Number\",\n\t\t\targs: args{t: TypeNumber},\n\t\t\twant: \"number\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_True\",\n\t\t\targs: args{t: TypeTrue},\n\t\t\twant: \"true\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_False\",\n\t\t\targs: args{t: TypeFalse},\n\t\t\twant: \"false\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_Null\",\n\t\t\targs: args{t: TypeNull},\n\t\t\twant: \"null\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.t.String(); got != tt.want {\n\t\t\t\tt.Errorf(\"Type.String() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "ae0b572cc88c22817952f3cafbbcef57": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{\\\"a\\\": 1}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"{\\\"a\\\": 1}\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{\\\"a\\\": 1}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"a\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[1, 2, 3]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"hello\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   \"true\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueTrue,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   \"false\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueFalse,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   \"null\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueNull,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   \"123\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   \"NaN\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseValue() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseValue_Invalid(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"invalid object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{a: 1}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[1, 2, 3\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"hello`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid true\",\n\t\t\targs: args{\n\t\t\t\ts:   \"tru\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid false\",\n\t\t\targs: args{\n\t\t\t\ts:   \"fals\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid null\",\n\t\t\targs: args{\n\t\t\t\ts:   \"nul\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number\",\n\t\t\targs: args{\n\t\t\t\ts:   \"123a\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t_, _, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseValue_JSON(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"a\": 1, \"b\": \"hello\", \"c\": true, \"d\": false, \"e\": null, \"f\": [1, 2, 3], \"g\": {\"h\": 4}}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `{\"a\":1,\"b\":\"hello\",\"c\":true,\"d\":false,\"e\":null,\"f\":[1,2,3],\"g\":{\"h\":4}}`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[1, \"hello\", true, false, null, [1, 2, 3], {\"h\": 4}]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `[1,\"hello\",true,false,null,[1,2,3],{\"h\":4}]`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"hello\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `\"hello\"`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   \"true\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    \"true\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   \"false\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    \"false\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   \"null\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    \"null\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   \"123\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    \"123\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   \"NaN\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    \"NaN\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err == nil {\n\t\t\t\tb, err := json.Marshal(got)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"json.Marshal() error = %v\", err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif string(b) != tt.want {\n\t\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", string(b), tt.want)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}",
    "ae4d8039b488babc11d0ff7d99cdce09": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_getKV(t *testing.T) {\n\ttype args struct {\n\t\to *Object\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant *kv\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.o.getKV(); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Object.getKV() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "ae9123f503428ba5692e3ea27ac17461": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\"world\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quotes and other characters\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"\\\\\\\\\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\\\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped closing quote and other characters\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"\\\\\\\\\\\\\"`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "ae9693e983789f3217631b97120308a1": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"single digit\",\n\t\t\targs: args{\n\t\t\t\ts: \"1\",\n\t\t\t},\n\t\t\twantNs:  \"1\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple digits\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative number\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"positive number\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"decimal number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponent number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123e456\",\n\t\t\t},\n\t\t\twantNs:  \"123e456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponent number with sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"123e+456\",\n\t\t\t},\n\t\t\twantNs:  \"123e+456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"inf\",\n\t\t\t},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"nan\",\n\t\t\t},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char\",\n\t\t\targs: args{\n\t\t\t\ts: \"123a\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"123a\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at start\",\n\t\t\targs: args{\n\t\t\t\ts: \"a123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"a123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at start 2\",\n\t\t\targs: args{\n\t\t\t\ts: \"a-123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"a-123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at start 3\",\n\t\t\targs: args{\n\t\t\t\ts: \"a+123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"a+123\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}",
    "af10a7f04b7057fbe477a26022125bc6": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escaped string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: ``,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with no quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `hello`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\\\\\"hello\\\\\"\"`,\n\t\t\t},\n\t\t\twant:    `\"hello\"`,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote and other characters\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\\\\\"hello\\\\\"world\\\\\"\"`,\n\t\t\t},\n\t\t\twant:    `\"hello\"world\"`,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "afef6c05b46268a259be59a5a9fca661": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\tv   *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"marshal null\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNull},\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal true\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeTrue},\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal false\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeFalse},\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal number\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t},\n\t\t\twant: []byte(\"123\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeString, s: \"hello\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal raw string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: typeRawString, s: \"hello\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal array\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t\t{t: TypeString, s: \"hello\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"[1,\\\"hello\\\"]\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal object\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeNumber, s: \"1\"}},\n\t\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"hello\"}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":1,\"key2\":\"hello\"}`),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.v.MarshalTo(tt.args.dst); !bytesEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc bytesEqual(a, b []byte) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "b04b74319d940f0635ec6c3ab0c4f8db": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"single element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,3]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[[1,2],[3,4]]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"4\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with string elements\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[\\\"hello\\\",\\\"world\\\"]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"hello\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"world\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with invalid element\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \",\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"array with missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseArray() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b0b5fd686ad16fef8e8d59f74a9f67c4": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Get(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant *Value\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.Get(tt.args.keys...); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.Get() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b19489aa7c40cead98db30a214543112": "```go\npackage fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"single digit\",\n\t\t\targs: args{\n\t\t\t\ts: \"1\",\n\t\t\t},\n\t\t\twantNs:  \"1\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple digits\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative number\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"decimal number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential number\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential number with negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e-4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"inf\",\n\t\t\t},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"Inf\",\n\t\t\t},\n\t\t\twantNs:  \"Inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inF\",\n\t\t\targs: args{\n\t\t\t\ts: \"inF\",\n\t\t\t},\n\t\t\twantNs:  \"inF\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twantNs:  \"NaN\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"nan\",\n\t\t\t},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nAn\",\n\t\t\targs: args{\n\t\t\t\ts: \"nAn\",\n\t\t\t},\n\t\t\twantNs:  \"nAn\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with trailing whitespace\",\n\t\t\targs: args{\n\t\t\t\ts: \"123 \",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \" \",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading whitespace\",\n\t\t\targs: args{\n\t\t\t\ts: \" 123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" 123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character\",\n\t\t\targs: args{\n\t\t\t\ts: \"123a\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning\",\n\t\t\targs: args{\n\t\t\t\ts: \"a123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"a123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 2\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid character at beginning 3\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"-123a\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt",
    "b23f165790dec92592a71e74e8fd8fd3": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"single element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,3]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[[1,2],[3,4]]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"4\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1,2\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1 2]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1 2]\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseArray() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b274ce25e34f5619bedd4d1f51c52eb9": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"single element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,3]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[[1,2],[3,4]]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"4\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with string elements\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[\\\"hello\\\",\\\"world\\\"]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"hello\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"world\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with invalid element\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1,2,\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"array with missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1,2\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseArray() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b2c1c16f19f788e01adcb94f55cad0b0": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_JSONUnmarshal(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    map[string]interface{}\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    map[string]interface{}{},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    map[string]interface{}{\"key1\": \"value1\", \"key2\": \"value2\"},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    map[string]interface{}{\"key1\": map[string]interface{}{\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    map[string]interface{}{\"key\\\"1\": \"value1\"},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != nil {\n\t\t\t\tvar gotMap map[string]interface{}\n\t\t\t\tif err := json.Unmarshal(got.MarshalTo(nil), \u0026gotMap); err != nil {\n\t\t\t\t\tt.Errorf(\"parseObject() unmarshal error = %v\", err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif !reflect.DeepEqual(gotMap, tt.want) {\n\t\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", gotMap, tt.want)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}",
    "b2cf84a6aeb0b423ad46a2a92b4babdf": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\tv   *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"marshal null\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNull},\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal true\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeTrue},\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal false\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeFalse},\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal number\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t},\n\t\t\twant: []byte(\"123\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeString, s: \"hello world\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello world\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal raw string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: typeRawString, s: \"hello world\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello world\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal array\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeString, s: \"hello\"}}},\n\t\t\t},\n\t\t\twant: []byte(\"[1,\\\"hello\\\"]\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal object\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key1\", v: \u0026Value{t: TypeNumber, s: \"1\"}}, {k: \"key2\", v: \u0026Value{t: TypeString, s: \"hello\"}}}},\n\t\t\t},\n\t\t\twant: []byte(\"{\\\"key1\\\":1,\\\"key2\\\":\\\"hello\\\"}\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.v.MarshalTo(tt.args.dst); !bytesEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc bytesEqual(a, b []byte) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "b450486b468a9852733fdb3976569a3c": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetFloat64(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.GetFloat64(tt.args.keys...); got != tt.want {\n\t\t\t\tt.Errorf(\"Value.GetFloat64() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b514df76d6af14fc4f444c942cde5ac8": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"single space\",\n\t\t\targs: args{s: \" \"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple spaces\",\n\t\t\targs: args{s: \"   \"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading spaces\",\n\t\t\targs: args{s: \"  hello\"},\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailing spaces\",\n\t\t\targs: args{s: \"hello  \"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading and trailing spaces\",\n\t\t\targs: args{s: \"  hello  \"},\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"spaces and other whitespace\",\n\t\t\targs: args{s: \" \\t\\n\\rhello\\n\\r\\t \"},\n\t\t\twant: \"hello\\n\\r\\t \",\n\t\t},\n\t\t{\n\t\t\tname: \"no whitespace\",\n\t\t\targs: args{s: \"hello\"},\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"whitespace in the middle\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"world\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b5ba9e305ed271a13086bb75c92eeb74": "```go\npackage fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"{}\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\": \"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"value1\", \"value2\"]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"value\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"value\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   `true`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueTrue,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   `false`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueFalse,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   `null`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueNull,\n",
    "b649516c92ed84646401f9a0c8be1b42": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueGet(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant *Value\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.Get(tt.args.keys...); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.Get() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b677050dbcec629c8d29f82e2c3f2fd6": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Type(t *testing.T) {\n\ttype args struct {\n\t\tv *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant Type\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.v.Type(); got != tt.want {\n\t\t\t\tt.Errorf(\"Value.Type() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b702b7f64b16cbf5e64694750a7a6b86": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantKey string\n\t\twantRem string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"empty string\",\n\t\t\targs:    args{s: \"\"},\n\t\t\twantKey: \"\",\n\t\t\twantRem: \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"missing closing quote\",\n\t\t\targs:    args{s: `\"key`},\n\t\t\twantKey: \"\",\n\t\t\twantRem: \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"simple key\",\n\t\t\targs:    args{s: `\"key\"`},\n\t\t\twantKey: \"key\",\n\t\t\twantRem: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"key with escape sequence\",\n\t\t\targs:    args{s: `\"key\\\\\"\"`},\n\t\t\twantKey: \"key\\\"\",\n\t\t\twantRem: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"key with space\",\n\t\t\targs:    args{s: `\"key with space\"`},\n\t\t\twantKey: \"key with space\",\n\t\t\twantRem: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"key with special characters\",\n\t\t\targs:    args{s: `\"key:with:special:characters\"`},\n\t\t\twantKey: \"key:with:special:characters\",\n\t\t\twantRem: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotKey, gotRem, err := parseRawKey(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawKey() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotKey != tt.wantKey {\n\t\t\t\tt.Errorf(\"parseRawKey() gotKey = %v, want %v\", gotKey, tt.wantKey)\n\t\t\t}\n\t\t\tif gotRem != tt.wantRem {\n\t\t\t\tt.Errorf(\"parseRawKey() gotRem = %v, want %v\", gotRem, tt.wantRem)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b77435e569aff9b55cf6558a968f476c": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\"world\\\\\\\"\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"!\\\"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped backslash\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\\world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with no quotes\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with leading quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello world\"`,\n\t\t\t},\n\t\t\twant:    \"hello world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b7a19dad9f8dc44de63625c70135f9cb": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"simple integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"float\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential notation\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential notation with negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e-4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"inf\",\n\t\t\t},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"Inf\",\n\t\t\t},\n\t\t\twantNs:  \"Inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inF\",\n\t\t\targs: args{\n\t\t\t\ts: \"inF\",\n\t\t\t},\n\t\t\twantNs:  \"inF\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"nan\",\n\t\t\t},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"Nan\",\n\t\t\t},\n\t\t\twantNs:  \"Nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nAn\",\n\t\t\targs: args{\n\t\t\t\ts: \"nAn\",\n\t\t\t},\n\t\t\twantNs:  \"nAn\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char\",\n\t\t\targs: args{\n\t\t\t\ts: \"123a\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning\",\n\t\t\targs: args{\n\t\t\t\ts: \"a123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"a123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 2\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 3\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"-123a\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 4\",\n\t\t\targs: args{\n\t\t\t\ts: \"-a123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"-a123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 5\",\n\t\t\targs: args{\n\t\t\t\ts: \"+a123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+a123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 6\",\n\t\t\targs: args{\n\t\t\t\ts: \"123+\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 7\",\n\t\t\targs: args{\n\t\t\t\ts: \"123-\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 8\",\n\t\t\targs: args{\n\t\t\t\ts: \"123e\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"e\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 9\",\n\t\t\targs: args{\n\t\t\t\ts: \"123E\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"E\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 10\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \".\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 11\",\n\t\t\targs: args{\n\t\t\t\ts: \"123-\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 12\",\n\t\t\targs: args{\n\t\t\t\ts: \"123+\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 13\",\n\t\t\targs: args{\n\t\t\t\ts: \"123e\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"e\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 14\",\n\t\t\targs: args{\n\t\t\t\ts: \"123E\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"E\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 15\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \".\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 16\",\n\t\t\targs: args{\n\t\t\t\ts: \"123-\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 17\",\n\t\t\targs: args{\n\t\t\t\ts: \"123+\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 18\",\n\t\t\targs: args{\n\t\t\t\ts: \"123e\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"e\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 19\",\n\t\t\targs: args{\n\t\t\t\ts: \"123E\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"E\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 20\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \".\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 21\",\n\t\t\targs: args{\n\t\t\t\ts: \"123-\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 22\",\n\t\t\targs: args{\n\t\t\t\ts: \"123+\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 23\",\n\t\t\targs: args{\n\t\t\t\ts: \"123e\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"e\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 24\",\n\t\t\targs: args{\n\t\t\t\ts: \"123E\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"E\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 25\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \".\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 26\",\n\t\t\targs: args{\n\t\t\t\ts: \"123-\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 27\",\n\t\t\targs: args{\n\t\t\t\ts: \"123+\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 28\",\n\t\t\targs: args{\n\t\t\t\ts: \"123e\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"e\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 29\",\n\t\t\targs: args{\n\t\t\t\ts: \"123E\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"E\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 30\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \".\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 31\",\n\t\t\targs: args{\n\t\t\t\ts: \"123-\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 32\",\n\t\t\targs: args{\n\t\t\t\ts: \"123+\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 33\",\n\t\t\targs: args{\n\t\t\t\ts: \"123e\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"e\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 34\",\n\t\t\targs: args{\n\t\t\t\ts: \"123E\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"E\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 35\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \".\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 36\",\n\t\t\targs: args{\n\t\t\t\ts: \"123-\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 37\",\n\t\t\targs: args{\n\t\t\t\ts: \"123+\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 38\",\n\t\t\targs: args{\n\t\t\t\ts: \"123e\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"e\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 39\",\n\t\t\targs: args{\n\t\t\t\ts: \"123E\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"E\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 40\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \".\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 41\",\n\t\t\targs: args{\n\t\t\t\ts: \"123-\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 42\",\n\t\t\targs: args{\n\t\t\t\ts: \"123+\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 43\",\n\t\t\targs: args{\n\t\t\t\ts: \"123e\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"e\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 44\",\n\t\t\targs: args{\n\t\t\t\ts: \"123E\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"E\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 45\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \".\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 46\",\n\t\t\targs: args{\n\t\t\t\ts: \"123-\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 47\",\n\t\t\targs: args{\n\t\t\t\ts: \"123+\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 48\",\n\t\t\targs: args{\n\t\t\t\ts: \"123e\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"e\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 49\",\n\t\t\targs: args{\n\t\t\t\ts: \"123E\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"E\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 50\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \".\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 51\",\n\t\t\targs: args{\n\t\t\t\ts: \"123-\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 52\",\n\t\t\targs: args{\n\t\t\t\ts: \"123+\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 53\",\n\t\t\targs: args{\n\t\t\t\ts: \"123e\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"e\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 54\",\n\t\t\targs: args{\n\t\t\t\ts: \"123E\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"E\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 55\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \".\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 56\",\n\t\t\targs: args{\n\t\t\t\ts: \"123-\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 57\",\n\t\t\targs: args{\n\t\t\t\ts: \"123+\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 58\",\n\t\t\targs: args{\n\t\t\t\ts: \"123e\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"e\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 59\",\n\t\t\targs: args{\n\t\t\t\ts: \"123E\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"E\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 60\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \".\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 61\",\n\t\t\targs: args{\n\t\t\t\ts: \"123-\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 62\",\n\t\t\targs: args{\n\t\t\t\ts: \"123+\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 63\",\n\t\t\targs: args{\n\t\t\t\ts: \"123e\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"e\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 64\",\n\t\t\targs: args{\n\t\t\t\ts: \"123E\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"E\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 65\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \".\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 66\",\n\t\t\targs: args{\n\t\t\t\ts: \"123-\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 67\",\n\t\t\targs: args{\n\t\t\t\ts: \"123+\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 68\",\n\t\t\targs: args{\n\t\t\t\ts: \"123e\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"e\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 69\",\n\t\t\targs: args{\n\t\t\t\ts: \"123E\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"E\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 70\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \".\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 71\",\n\t\t\targs: args{\n\t\t\t\ts: \"123-\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 72\",\n\t\t\targs: args{\n\t\t\t\ts: \"123+\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 73\",\n\t\t\targs: args{\n\t\t\t\ts: \"123e\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"e\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 74\",\n\t\t\targs: args{\n\t\t\t\ts: \"123E\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"E\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 75\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \".\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 76\",\n\t\t\targs: args{\n\t\t\t\ts: \"123-\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 77\",\n\t\t\targs: args{\n\t\t\t\ts: \"123+\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 78\",\n\t\t\targs: args{\n\t\t\t\ts: \"123e\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"e\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 79\",\n\t\t\targs: args{\n\t\t\t\ts: \"123E\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"E\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 80\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \".\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 81\",\n\t\t\targs: args{\n\t\t\t\ts: \"123-\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 82\",\n\t\t\targs: args{\n\t\t\t\ts: \"123+\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 83\",\n\t\t\targs: args{\n\t\t\t\ts: \"123e\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"e\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 84\",\n\t\t\targs: args{\n\t\t\t\ts: \"123E\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"E\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 85\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \".\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 86\",\n\t\t\targs: args{\n\t\t\t\ts: \"123-\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 87\",\n\t\t\targs: args{\n\t\t\t\ts: \"123+\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 88\",\n\t\t\targs: args{\n\t\t\t\ts: \"123e\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"e\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 89\",\n\t\t\targs: args{\n\t\t\t\ts: \"123E\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"E\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 90\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \".\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 91\",\n\t\t\targs: args{\n\t\t\t\ts: \"123-\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 92\",\n\t\t\targs: args{\n\t\t\t\ts: \"123+\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 93\",\n\t\t\targs: args{\n\t\t\t\ts: \"123e\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"e\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 94\",\n\t\t\targs: args{\n\t\t\t\ts: \"123E\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"E\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 95\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \".\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 96\",\n\t\t\targs: args{\n\t\t\t\ts: \"123-\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 97\",\n\t\t\targs: args{\n\t\t\t\ts: \"123+\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 98\",\n\t\t\targs: args{\n\t\t\t\ts: \"123e\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"e\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 99\",\n\t\t\targs: args{\n\t\t\t\ts: \"123E\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"E\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning 100\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \".\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b820683300c14c36357582b48bac4df3": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\"`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with leading and trailing spaces\",\n\t\t\targs: args{\n\t\t\t\ts: `\"  hello  \"`,\n\t\t\t},\n\t\t\twant:    \"  hello  \",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped backslash\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\\world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b9027e608afcd64bdeefc42196d68462": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\tv   *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"MarshalTo_RawString\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: typeRawString, s: \"test\"},\n\t\t\t},\n\t\t\twant: []byte(`\"test\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"MarshalTo_Object\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{t: TypeString, s: \"value\"}}}}},\n\t\t\t},\n\t\t\twant: []byte(`{\"key\":\"value\"}`),\n\t\t},\n\t\t{\n\t\t\tname: \"MarshalTo_Array\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeArray, a: []*Value{{t: TypeString, s: \"value1\"}, {t: TypeString, s: \"value2\"}}},\n\t\t\t},\n\t\t\twant: []byte(`[\"value1\",\"value2\"]`),\n\t\t},\n\t\t{\n\t\t\tname: \"MarshalTo_String\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeString, s: \"test\"},\n\t\t\t},\n\t\t\twant: []byte(`\"test\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"MarshalTo_Number\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t},\n\t\t\twant: []byte(`123`),\n\t\t},\n\t\t{\n\t\t\tname: \"MarshalTo_True\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeTrue},\n\t\t\t},\n\t\t\twant: []byte(`true`),\n\t\t},\n\t\t{\n\t\t\tname: \"MarshalTo_False\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeFalse},\n\t\t\t},\n\t\t\twant: []byte(`null`),\n\t\t},\n\t\t{\n\t\t\tname: \"MarshalTo_Null\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNull},\n\t\t\t},\n\t\t\twant: []byte(`null`),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.v.MarshalTo(tt.args.dst); !bytesEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc bytesEqual(a, b []byte) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "b94c8a675ca01c0e5705f4898a327a1f": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"single element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,3]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[[1,2],[3,4]]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"4\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1,2\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1 2]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1 2]\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseArray() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b986d4c589f56a16c52eb378505a2e52": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestType_String(t *testing.T) {\n\ttype args struct {\n\t\tt Type\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"TestType_String_Object\",\n\t\t\targs: args{t: TypeObject},\n\t\t\twant: \"object\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_Array\",\n\t\t\targs: args{t: TypeArray},\n\t\t\twant: \"array\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_String\",\n\t\t\targs: args{t: TypeString},\n\t\t\twant: \"string\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_Number\",\n\t\t\targs: args{t: TypeNumber},\n\t\t\twant: \"number\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_True\",\n\t\t\targs: args{t: TypeTrue},\n\t\t\twant: \"true\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_False\",\n\t\t\targs: args{t: TypeFalse},\n\t\t\twant: \"false\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_Null\",\n\t\t\targs: args{t: TypeNull},\n\t\t\twant: \"null\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.t.String(); got != tt.want {\n\t\t\t\tt.Errorf(\"Type.String() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "bae59786f5c861d477ca897b14a101e7": "package fastjson\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\tv   *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNull},\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeTrue},\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeFalse},\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeString, s: \"hello\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t},\n\t\t\twant: []byte(\"123\"),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{t: TypeString, s: \"a\"},\n\t\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"[\\\"a\\\",1]\"),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{k: \"a\", v: \u0026Value{t: TypeString, s: \"b\"}},\n\t\t\t\t\t\t\t{k: \"c\", v: \u0026Value{t: TypeNumber, s: \"2\"}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`{\"a\":\"b\",\"c\":2}`),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.v.MarshalTo(tt.args.dst); !bytes.Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "bae6aaeb6d2dde466a9d225e8b25689e": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\tv   *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"test raw string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: typeRawString, s: \"hello world\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello world\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"test object\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}}, {k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}}}},\n\t\t\t},\n\t\t\twant: []byte(\"{\\\"key1\\\":\\\"value1\\\",\\\"key2\\\":123}\"),\n\t\t},\n\t\t{\n\t\t\tname: \"test array\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeArray, a: []*Value{{t: TypeString, s: \"value1\"}, {t: TypeNumber, s: \"123\"}}},\n\t\t\t},\n\t\t\twant: []byte(\"[\\\"value1\\\",123]\"),\n\t\t},\n\t\t{\n\t\t\tname: \"test string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeString, s: \"hello world\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello world\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"test number\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t},\n\t\t\twant: []byte(\"123\"),\n\t\t},\n\t\t{\n\t\t\tname: \"test true\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeTrue},\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"test false\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeFalse},\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"test null\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNull},\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.v.MarshalTo(tt.args.dst); !bytesEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc bytesEqual(a, b []byte) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "bba33bd45299023ca8b7a83a78d12329": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"single element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,3]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[[1,2],[3,4]]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"4\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with string\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[\\\"hello\\\", \\\"world\\\"]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"hello\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"world\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1,2\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"array with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1 2]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1 2]\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseArray() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "bbd4aacd501b5510c301e28e2c99a7a2": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetStringBytes(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.GetStringBytes(tt.args.keys...); !bytesEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.GetStringBytes() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc bytesEqual(a, b []byte) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "bbe3e673670e6d1a8100b95f3f3b6604": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_InvalidJSON(t *testing.T) {\n\ttests := []string{\n\t\t\"{\",\n\t\t\"}\",\n\t\t\"{\\\"key1\\\":\",\n\t\t\"{\\\"key1\\\": \\\"value1\",\n\t\t\"{\\\"key1\\\": \\\"value1\\\",\",\n\t\t\"{\\\"key1\\\": \\\"value1\\\", \\\"key2\\\":\",\n\t\t\"{\\\"key1\\\": \\\"value1\\\", \\\"key2\\\": \\\"value2\",\n\t}\n\tfor _, s := range tests {\n\t\tt.Run(s, func(t *testing.T) {\n\t\t\t_, _, err := parseObject(s, \u0026cache{}, 0)\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"parseObject() expected error for invalid JSON: %s\", s)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_EscapedKeys(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  string\n\t}{\n\t\t{`{\"key\\\\\"1\": \"value1\"}`, `{\"key\\\"1\": \"value1\"}`},\n\t\t{`{\"key\\\\/1\": \"value1\"}`, `{\"key/1\": \"value1\"}`},\n\t\t{`{\"key\\\\u0031\": \"value1\"}`, `{\"key1\": \"value1\"}`},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tv, _, err := parseObject(tt.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"parseObject() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgot, err := json.Marshal(v)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"json.Marshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif string(got) != tt.want {\n\t\t\t\tt.Errorf(\"parseObject() got = %s, want %s\", string(got), tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "bc32bb4bd7cd7c280d27c80f1da62f5b": "```go\npackage fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"simple integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"float\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential notation\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential notation with negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e-4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"inf\",\n\t\t\t},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"Inf\",\n\t\t\t},\n\t\t\twantNs:  \"Inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inF\",\n\t\t\targs: args{\n\t\t\t\ts: \"inF\",\n\t\t\t},\n\t\t\twantNs:  \"inF\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"nan\",\n\t\t\t},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twantNs:  \"NaN\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nAn\",\n\t\t\targs: args{\n\t\t\t\ts: \"nAn\",\n\t\t\t},\n\t\t\twantNs:  \"nAn\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123a\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"123inf\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"inf\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"123nan\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"nan\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with inf and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"123infabc\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"infabc\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with nan and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"123nanabc\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"nanabc\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with inf and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"123infa\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"infa\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with nan and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"123na\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"na\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with inf and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"123in\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"in\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with nan and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"123n\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"n\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with inf and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"123inf\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"inf\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with nan and trailing characters\",\n\t\t\targs: args{\n\t\t\t\t",
    "bc5d285469a1c0d8fc4ef44b5183d6ea": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[]\",\n\t\t\t\tc:    \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"single element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1]\",\n\t\t\t\tc:    \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,3]\",\n\t\t\t\tc:    \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[[1,2],[3,4]]\",\n\t\t\t\tc:    \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"4\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with string\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[\\\"hello\\\", \\\"world\\\"]\",\n\t\t\t\tc:    \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"hello\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"world\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with object\",\n\t\t\targs: args{\n\t\t\t\ts:    `[{\"key1\": \"value1\"}, {\"key2\": \"value2\"}]`,\n\t\t\t\tc:    \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2\",\n\t\t\t\tc:    \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1,2\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1 2]\",\n\t\t\t\tc:    \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1 2]\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid value\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,invalid]\",\n\t\t\t\tc:    \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1,2,invalid]\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseArray() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseArray_JSON(t *testing.T) {\n\ttype testCase struct {\n\t\tjson string\n\t\twant []interface{}\n\t}\n\ttestCases := []testCase{\n\t\t{\n\t\t\tjson: \"[]\",\n\t\t\twant: []interface{}{},\n\t\t},\n\t\t{\n\t\t\tjson: \"[1,2,3]\",\n\t\t\twant: []interface{}{1, 2, 3},\n\t\t},\n\t\t{\n\t\t\tjson: `[\"hello\", \"world\"]`,\n\t\t\twant: []interface{}{\"hello\", \"world\"},\n\t\t},\n\t\t{\n\t\t\tjson: `[{\"key1\": \"value1\"}, {\"key2\": \"value2\"}]`,\n\t\t\twant: []interface{}{\n\t\t\t\tmap[string]interface{}{\"key1\": \"value1\"},\n\t\t\t\tmap[string]interface{}{\"key2\": \"value2\"},\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.json, func(t *testing.T) {\n\t\t\tc := \u0026cache{vs: make([]Value, 0)}\n\t\t\tv, _, err := parseArray(tc.json, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"parseArray() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tvar got []interface{}\n\t\t\tif err := json.Unmarshal([]byte(v.MarshalTo(nil)), \u0026got); err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !reflect.DeepEqual(got, tc.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "bd08cdc2e23161062627047e003b8850": "package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u world\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u world\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\\\\\ \\\\/test\\\\/\"},\n\t\t\twant: \"\\\"hello\\\" \\\\world\\\\ /test/\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "bd43f4fafcaeeba798c3f402040ffc31": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\"},\n\t\t\twant: \"\\\\u0061\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\"},\n\t\t\twant: \"\\\\uD83D\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "be3fef38b753fb00b2dd27df1c22fb9f": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestType_String(t *testing.T) {\n\ttype args struct {\n\t\tt Type\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"TestType_String_Object\",\n\t\t\targs: args{t: TypeObject},\n\t\t\twant: \"object\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_Array\",\n\t\t\targs: args{t: TypeArray},\n\t\t\twant: \"array\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_String\",\n\t\t\targs: args{t: TypeString},\n\t\t\twant: \"string\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_Number\",\n\t\t\targs: args{t: TypeNumber},\n\t\t\twant: \"number\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_True\",\n\t\t\targs: args{t: TypeTrue},\n\t\t\twant: \"true\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_False\",\n\t\t\targs: args{t: TypeFalse},\n\t\t\twant: \"false\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_Null\",\n\t\t\targs: args{t: TypeNull},\n\t\t\twant: \"null\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.t.String(); got != tt.want {\n\t\t\t\tt.Errorf(\"Type.String() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "bfd9bf47990529b6e2f1fe69b5593909": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestHasSpecialChars(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with double quote\",\n\t\t\targs: args{s: \"hello\\\"world\"},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with backslash\",\n\t\t\targs: args{s: \"hello\\\\world\"},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with control character\",\n\t\t\targs: args{s: \"hello\\x01world\"},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with no special characters\",\n\t\t\targs: args{s: \"helloworld\"},\n\t\t\twant: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := hasSpecialChars(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"hasSpecialChars() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "bfff9a81256b0c60aeeaa312fc7ea322": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"single element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,3]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[[1,2],[3,4]]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"4\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with whitespace\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[ 1 , 2 , 3 ]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,3\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1,2,3\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1 2,3]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1 2,3]\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid array value\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,a]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1,2,a]\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseArray() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c0874c7164c921c92d5c73b5e96f2adc": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"simple integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"float\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential notation\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential notation with lowercase e\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e-4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"inf\",\n\t\t\t},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"Inf\",\n\t\t\t},\n\t\t\twantNs:  \"Inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twantNs:  \"NaN\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"nan\",\n\t\t\t},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123a\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"-123a\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"-inf\",\n\t\t\t},\n\t\t\twantNs:  \"-inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"-nan\",\n\t\t\t},\n\t\t\twantNs:  \"-nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c139b8b840fd95c233cf58a5b0b8e307": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped string with multiple escapes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\"world\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\\\\\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: ``,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with no quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `hello`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c2da5751cd2c5398838167b28b6919cf": "package fastjson\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\tv   *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"String\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeString, s: \"hello\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"Number\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t},\n\t\t\twant: []byte(\"123\"),\n\t\t},\n\t\t{\n\t\t\tname: \"True\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeTrue},\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"False\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeFalse},\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"Null\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNull},\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"RawString\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: typeRawString, s: \"hello\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"Array\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{t: TypeString, s: \"hello\"},\n\t\t\t\t\t\t{t: TypeNumber, s: \"123\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"[\\\"hello\\\",123]\"),\n\t\t},\n\t\t{\n\t\t\tname: \"Object\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":\"value1\",\"key2\":123}`),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.v.MarshalTo(tt.args.dst); !bytes.Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c32a429bd8165819c0e2efc39c6b825a": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\\\\\\\"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"\\\\\\\\\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\\\\\\\"\\\\\\\\\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: ``,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with no quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `hello`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c3af1e47e08002ea2a66ba4555dc8b2c": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetStringBytes(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.GetStringBytes(tt.args.keys...); !bytesEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.GetStringBytes() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc bytesEqual(a, b []byte) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "c3ca300ea3ef3c2d58924dcfd3e7b4d8": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\"},\n\t\t\twant: \"\\\\u0061\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\\\\\ \\\\/\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\xhello\\\\x world\\\\u0061\"},\n\t\t\twant: \"\\\"hello\\\" \\\\world\\\\ /\\\\b\\\\f\\\\n\\\\r\\tabcüòÅ\\\\xhello\\\\x worlda\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c3d3743fdc801655ec63135d7bb59672": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCacheGetValue(t *testing.T) {\n\tt.Run(\"EmptyCache\", func(t *testing.T) {\n\t\tc := \u0026cache{}\n\t\tv := c.getValue()\n\t\tif v == nil {\n\t\t\tt.Error(\"getValue() returned nil for empty cache\")\n\t\t}\n\t})\n\n\tt.Run(\"NonEmptyCache\", func(t *testing.T) {\n\t\tc := \u0026cache{vs: []Value{{t: TypeString, s: \"test\"}}}\n\t\tv := c.getValue()\n\t\tif v == nil {\n\t\t\tt.Error(\"getValue() returned nil for non-empty cache\")\n\t\t}\n\t\tif v.t != TypeString || v.s != \"test\" {\n\t\t\tt.Errorf(\"getValue() returned unexpected value: %v\", v)\n\t\t}\n\t})\n}",
    "c3f9de78bc4ab5f2c224c68fe6a512d2": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetObject(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant *Object\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.GetObject(tt.args.keys...); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"GetObject() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c41fada46f28a36a945f14b1dabf43f8": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no whitespace\",\n\t\t\targs: args{s: \"hello\"},\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace\",\n\t\t\targs: args{s: \"  hello\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailing whitespace\",\n\t\t\targs: args{s: \"hello  \"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"whitespace in the middle\",\n\t\t\targs: args{s: \"hello  world\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple whitespace\",\n\t\t\targs: args{s: \"  hello  world  \"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"newline\",\n\t\t\targs: args{s: \"\\nhello\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"tab\",\n\t\t\targs: args{s: \"\\thello\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"carriage return\",\n\t\t\targs: args{s: \"\\rhello\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"mixed whitespace\",\n\t\t\targs: args{s: \" \\t\\n\\rhello\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"whitespace and non-whitespace\",\n\t\t\targs: args{s: \" \\t\\n\\rhello world\"},\n\t\t\twant: \"\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c4ca0fa3d11b72162681fabfbab58d61": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCacheGetValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\t// Test empty cache\n\tv := c.getValue()\n\tif v == nil {\n\t\tt.Error(\"getValue() returned nil for empty cache\")\n\t}\n\n\t// Test non-empty cache\n\tc.vs = append(c.vs, Value{})\n\tv = c.getValue()\n\tif v == nil {\n\t\tt.Error(\"getValue() returned nil for non-empty cache\")\n\t}\n\n\t// Test capacity handling\n\tc.vs = make([]Value, 10)\n\tc.vs = c.vs[:5]\n\tv = c.getValue()\n\tif v == nil {\n\t\tt.Error(\"getValue() returned nil for cache with capacity \u003e length\")\n\t}\n}",
    "c5586c4ceae5d3f167bcc3ee23c33dbe": "```go\npackage fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"simple integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"float\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential notation\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential notation with negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e-4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"inf\",\n\t\t\t},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"Inf\",\n\t\t\t},\n\t\t\twantNs:  \"Inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inF\",\n\t\t\targs: args{\n\t\t\t\ts: \"inF\",\n\t\t\t},\n\t\t\twantNs:  \"inF\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"nan\",\n\t\t\t},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"Nan\",\n\t\t\t},\n\t\t\twantNs:  \"Nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nAn\",\n\t\t\targs: args{\n\t\t\t\ts: \"nAn\",\n\t\t\t},\n\t\t\twantNs:  \"nAn\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123a\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"-inf\",\n\t\t\t},\n\t\t\twantNs:  \"-inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"-nan\",\n\t\t\t},\n\t\t\twantNs:  \"-nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number",
    "c55ae409893aa760b6837960ae6d3139": "package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u006\"},\n\t\t\twant: \"\\\\u0061\\\\u006\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\\\\\ \\\\/\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\x\\\\u006\"},\n\t\t\twant: \"\\\"hello\\\" \\\\world\\\\ /\\\\b\\\\f\\\\n\\\\r\\\\tabcüòÅ\\\\x\\\\u006\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c5cb7d728cb8fdc34f85c406b961cc9e": "```go\npackage fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u006\"},\n\t\t\twant: \"\\\\u0061\\\\u006\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u006zg\"},\n\t\t\twant: \"\\\\u0061\\\\u006zg\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\u006zg\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\u006zg\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with incomplete hex\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\u006\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\u006\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex and incomplete hex\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\u006zg\\\\u006\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\u006zg\\\\u006\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex and incomplete hex and invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\u006zg\\\\u006\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\u006zg\\\\u006\\\\xhello\\\\x world\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_SurrogatePair(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\u006zg\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\u006zg\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with incomplete hex\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\u006\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\u006\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex and incomplete hex\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\u006zg\\\\u006\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\u006zg\\\\u006\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex and incomplete hex and invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\u006zg\\\\u006\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\u006zg\\\\u006\\\\xhello\\\\x world\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_InvalidEscapeSequence(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u006\"},\n\t\t\twant: \"\\\\u0061\\\\u006\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u006zg\"},\n\t\t\twant: \"\\\\u0061\\\\u006zg\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\u006zg\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\u006zg\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with incomplete hex\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\u006\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\u006\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex and incomplete hex\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\u006zg\\\\u006\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\u006zg\\\\u006\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex and incomplete hex and invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\u006zg\\\\u006\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\u006zg\\\\u006\\\\xhello\\\\x world\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_Unicode(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u006zg\"},\n\t\t\twant: \"\\\\u0061\\\\u006zg\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with incomplete hex\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u006\"},\n\t\t\twant: \"\\\\u0061\\\\u006\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_BasicEscapeSequences(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_NoEscapeSequences(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_SurrogatePair_InvalidHex(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\u006zg\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\u006zg\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex and incomplete hex\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\u006zg\\\\u006\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\u006zg\\\\u006\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex and incomplete hex and invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\u006zg\\\\u006\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\u006zg\\\\u006\\\\xhello\\\\x world\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_SurrogatePair_IncompleteHex(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"escaped surrogate pair with incomplete hex\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\u006\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\u006\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex and incomplete hex\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\u006zg\\\\u006\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\u006zg\\\\u006\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex and incomplete hex and invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\u006zg\\\\u006\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\u006zg\\\\u006\\\\xhello\\\\x world\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_Unicode_InvalidHex(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u006zg\"},\n\t\t\twant: \"\\\\u0061\\\\u006zg\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_Unicode_IncompleteHex(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"escaped unicode with incomplete hex\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u006\"},\n\t\t\twant: \"\\\\u0061\\\\u006\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_InvalidEscapeSequence_Multiple(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x\\\\x",
    "c5cdd5f26f85c8b4f71fd4ad327b5a2e": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_reset(t *testing.T) {\n\ttype args struct {\n\t\to *Object\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant *Object\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.o.reset(); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Object.reset() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c6faba2bbfc994b9485296bddc91361b": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_JSON(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_JSON_Compare(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tvar want map[string]interface{}\n\t\t\tif err := json.Unmarshal([]byte(tt.args.s), \u0026want); err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got.Object(), want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got.Object(), want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c764ce35ca14ae6a72207278122d0d5b": "package fastjson\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\tv   *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNull},\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeTrue},\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeFalse},\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeString, s: \"hello\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t},\n\t\t\twant: []byte(\"123\"),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{t: TypeString, s: \"hello\"},\n\t\t\t\t\t\t{t: TypeNumber, s: \"123\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"[\\\"hello\\\",123]\"),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{k: \"name\", v: \u0026Value{t: TypeString, s: \"John Doe\"}},\n\t\t\t\t\t\t\t{k: \"age\", v: \u0026Value{t: TypeNumber, s: \"30\"}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`{\"name\":\"John Doe\",\"age\":30}`),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.v.MarshalTo(tt.args.dst); !bytes.Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c7df6ab3486acf816f4a9b764f6a03d8": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\"world\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quotes and other characters\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"\\\\\\\\\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\\\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped closing quote and other characters\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"\\\\\\\\\\\\\"`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped closing quote and other characters\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"\\\\\\\\\\\\\"\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\\\\\"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c8009aa53c1b79da028713d43677a10e": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"single element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,3]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[[1,2],[3,4]]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"4\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with string\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[\\\"hello\\\", \\\"world\\\"]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"hello\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"world\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with object\",\n\t\t\targs: args{\n\t\t\t\ts:    `[{\"name\": \"John\", \"age\": 30}, {\"name\": \"Jane\", \"age\": 25}]`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tk: \"name\",\n\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\ts: \"John\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tk: \"age\",\n\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\t\ts: \"30\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tk: \"name\",\n\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\ts: \"Jane\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tk: \"age\",\n\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\t\ts: \"25\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1,2\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1 2]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1 2]\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected end of array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1,\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseArray() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseArray_JSON(t *testing.T) {\n\ttype testCase struct {\n\t\tjson string\n\t\twant []interface{}\n\t}\n\ttestCases := []testCase{\n\t\t{\n\t\t\tjson: \"[]\",\n\t\t\twant: []interface{}{},\n\t\t},\n\t\t{\n\t\t\tjson: \"[1,2,3]\",\n\t\t\twant: []interface{}{1, 2, 3},\n\t\t},\n\t\t{\n\t\t\tjson: `[\"hello\", \"world\"]`,\n\t\t\twant: []interface{}{\"hello\", \"world\"},\n\t\t},\n\t\t{\n\t\t\tjson: `[{\"name\": \"John\", \"age\": 30}, {\"name\": \"Jane\", \"age\": 25}]`,\n\t\t\twant: []interface{}{\n\t\t\t\tmap[string]interface{}{\"name\": \"John\", \"age\": 30},\n\t\t\t\tmap[string]interface{}{\"name\": \"Jane\", \"age\": 25},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.json, func(t *testing.T) {\n\t\t\tvar got []interface{}\n\t\t\tif err := json.Unmarshal([]byte(tc.json), \u0026got); err != nil {\n\t\t\t\tt.Fatalf(\"json.Unmarshal failed: %v\", err)\n\t\t\t}\n\t\t\tc := \u0026cache{}\n\t\t\tv, _, err := parseArray(tc.json, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"parseArray failed: %v\", err)\n\t\t\t}\n\t\t\tif len(v.a) != len(tc.want) {\n\t\t\t\tt.Errorf(\"parseArray() got length %d, want %d\", len(v.a), len(tc.want))\n\t\t\t\treturn\n\t\t\t}\n\t\t\tfor i, want := range tc.want {\n\t\t\t\tswitch want.(type) {\n\t\t\t\tcase int:\n\t\t\t\t\tif v.a[i].t != TypeNumber {\n\t\t\t\t\t\tt.Errorf(\"parseArray() got type %v, want %v\", v.a[i].t, TypeNumber)\n\t\t\t\t\t}\n\t\t\t\t\tif got, err := v.a[i].Int(); err != nil {\n\t\t\t\t\t\tt.Errorf(\"parseArray() got error %v\", err)\n\t\t\t\t\t} else if got != want.(int) {\n\t\t\t\t\t\tt.Errorf(\"parseArray() got %d, want %d\", got, want.(int))\n\t\t\t\t\t}\n\t\t\t\tcase string:\n\t\t\t\t\tif v.a[i].t != TypeString {\n\t\t\t\t\t\tt.Errorf(\"parseArray() got type %v, want %v\", v.a[i].t, TypeString)\n\t\t\t\t\t}\n\t\t\t\t\tif v.a[i].s != want.(string) {\n\t\t\t\t\t\tt.Errorf(\"parseArray() got %s, want %s\", v.a[i].s, want.(string))\n\t\t\t\t\t}\n\t\t\t\tcase map[string]interface{}:\n\t\t\t\t\tif v.a[i].t != TypeObject {\n\t\t\t\t\t\tt.Errorf(\"parseArray() got type %v, want %v\", v.a[i].t, TypeObject)\n\t\t\t\t\t}\n\t\t\t\t\tfor k, w := range want.(map[string]interface{}) {\n\t\t\t\t\t\tif v.a[i].o.kvs[i].k != k {\n\t\t\t\t\t\t\tt.Errorf(\"parseArray() got key %s, want %s\", v.a[i].o.kvs[i].k, k)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tswitch w.(type) {\n\t\t\t\t\t\tcase int:\n\t\t\t\t\t\t\tif v.a[i].o.kvs[i].v.t != TypeNumber {\n\t\t\t\t\t\t\t\tt.Errorf(\"parseArray() got type %v, want %v\", v.a[i].o.kvs[i].v.t, TypeNumber)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif got, err := v.a[i].o.kvs[i].v.Int(); err != nil {\n\t\t\t\t\t\t\t\tt.Errorf(\"parseArray() got error %v\", err)\n\t\t\t\t\t\t\t} else if got != w.(int) {\n\t\t\t\t\t\t\t\tt.Errorf(\"parseArray() got %d, want %d\", got, w.(int))\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tcase string:\n\t\t\t\t\t\t\tif v.a[i].o.kvs[i].v.t != TypeString {\n\t\t\t\t\t\t\t\tt.Errorf(\"parseArray() got type %v, want %v\", v.a[i].o.kvs[i].v.t, TypeString)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif v.a[i].o.kvs[i].v.s != w.(string) {\n\t\t\t\t\t\t\t\tt.Errorf(\"parseArray() got %s, want %s\", v.a[i].o.kvs[i].v.s, w.(string))\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tt.Errorf(\"parseArray() unsupported type %T\", w)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tt.Errorf(\"parseArray() unsupported type %T\", want)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}",
    "c80f450b5ed4b0fa2ce024b7f69bb8fc": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_JSONUnmarshal(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_JSONUnmarshal_Compare(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t\tvar wantJSON map[string]interface{}\n\t\t\tif err := json.Unmarshal([]byte(tt.args.s), \u0026wantJSON); err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tvar gotJSON map[string]interface{}\n\t\t\tif err := json.Unmarshal(got.MarshalTo(nil), \u0026gotJSON); err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(gotJSON, wantJSON) {\n\t\t\t\tt.Errorf(\"parseObject() gotJSON = %v, wantJSON %v\", gotJSON, wantJSON)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c862c57bfd6664eb3772ddfd9cc5ec8c": "package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u world\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u world\",\n\t\t},\n\t\t{\n\t\t\tname: \"mixed escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\/ \\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\"hello\\\" \\\\world/ \\b\\f\\n\\r\\tabcüòÅ\\\\xhello\\\\x world\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c89109383f77829fd96d34eb2ecc83ef": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\tv   *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"RawString\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: typeRawString, s: \"test\"},\n\t\t\t},\n\t\t\twant: []byte(`\"test\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"Object\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{t: TypeString, s: \"value\"}}}}},\n\t\t\t},\n\t\t\twant: []byte(`{\"key\":\"value\"}`),\n\t\t},\n\t\t{\n\t\t\tname: \"Array\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeArray, a: []*Value{{t: TypeString, s: \"value1\"}, {t: TypeString, s: \"value2\"}}},\n\t\t\t},\n\t\t\twant: []byte(`[\"value1\",\"value2\"]`),\n\t\t},\n\t\t{\n\t\t\tname: \"String\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeString, s: \"test\"},\n\t\t\t},\n\t\t\twant: []byte(`\"test\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"Number\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t},\n\t\t\twant: []byte(`123`),\n\t\t},\n\t\t{\n\t\t\tname: \"True\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeTrue},\n\t\t\t},\n\t\t\twant: []byte(`true`),\n\t\t},\n\t\t{\n\t\t\tname: \"False\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeFalse},\n\t\t\t},\n\t\t\twant: []byte(`false`),\n\t\t},\n\t\t{\n\t\t\tname: \"Null\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNull},\n\t\t\t},\n\t\t\twant: []byte(`null`),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.v.MarshalTo(tt.args.dst); !bytesEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc bytesEqual(a, b []byte) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "c9f4acd3cb04b2ed994e2e7099cc5b41": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestString(t *testing.T) {\n\ttype args struct {\n\t\tt Type\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"TestString_Object\",\n\t\t\targs: args{t: TypeObject},\n\t\t\twant: \"object\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestString_Array\",\n\t\t\targs: args{t: TypeArray},\n\t\t\twant: \"array\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestString_String\",\n\t\t\targs: args{t: TypeString},\n\t\t\twant: \"string\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestString_Number\",\n\t\t\targs: args{t: TypeNumber},\n\t\t\twant: \"number\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestString_True\",\n\t\t\targs: args{t: TypeTrue},\n\t\t\twant: \"true\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestString_False\",\n\t\t\targs: args{t: TypeFalse},\n\t\t\twant: \"false\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestString_Null\",\n\t\t\targs: args{t: TypeNull},\n\t\t\twant: \"null\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.t.String(); got != tt.want {\n\t\t\t\tt.Errorf(\"String() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "cac4f04680835dd843013cfc1b730880": "package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n)\n\nfunc TestEscapeString(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\ts   string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\ts:   \"\",\n\t\t\t},\n\t\t\twant: []byte(`\"\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\ts:   \"hello\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"string with special characters\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\ts:   \"hello, world!\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello, world!\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped characters\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\ts:   `\"\\t\\r\\n\"`,\n\t\t\t},\n\t\t\twant: []byte(`\"\\\\t\\\\r\\\\n\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"string with unicode characters\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\ts:   \"‰Ω†Â•Ω‰∏ñÁïå\",\n\t\t\t},\n\t\t\twant: []byte(`\"‰Ω†Â•Ω‰∏ñÁïå\"`),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := escapeString(tt.args.dst, tt.args.s); !bytesEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"escapeString() = %v, want %v\", string(got), string(tt.want))\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc bytesEqual(a, b []byte) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "cb85710523cfb04cdcdf04451f7449d2": "```go\npackage fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\"world\\\\\\\"\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote at the end\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by closing quote and more\",\n\t\t\targs: args{\n\t\t\t\ts",
    "cb8b337a5da945f53db16b6db1e7cef5": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantKey string\n\t\twantTail string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"simple key\",\n\t\t\targs:    args{s: `\"simple_key\"`},\n\t\t\twantKey: \"simple_key\",\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"key with spaces\",\n\t\t\targs:    args{s: `\"key with spaces\"`},\n\t\t\twantKey: \"key with spaces\",\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"key with special characters\",\n\t\t\targs:    args{s: `\"key with special characters\"`},\n\t\t\twantKey: \"key with special characters\",\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"key with escaped characters\",\n\t\t\targs:    args{s: `\"key\\\\\"with\\\\\"escaped\\\\\"characters\"`},\n\t\t\twantKey: \"key\\\\\\\"with\\\\\\\"escaped\\\\\\\"characters\",\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"missing closing quote\",\n\t\t\targs:    args{s: `\"missing closing quote`},\n\t\t\twantKey: \"\",\n\t\t\twantTail: \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"empty key\",\n\t\t\targs:    args{s: `\"\"`},\n\t\t\twantKey: \"\",\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"key with leading and trailing spaces\",\n\t\t\targs:    args{s: `\"  key with spaces  \"`},\n\t\t\twantKey: \"  key with spaces  \",\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotKey, gotTail, err := parseRawKey(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawKey() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotKey != tt.wantKey {\n\t\t\t\tt.Errorf(\"parseRawKey() gotKey = %v, want %v\", gotKey, tt.wantKey)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseRawKey() gotTail = %v, want %v\", gotTail, tt.wantTail)\n\t\t\t}\n\t\t})\n\t}\n}",
    "cbef8bb22fee92b10afa87f54f0a53b0": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"{}\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\": \"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"value1\", \"value2\"]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"value\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"value\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   `true`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueTrue,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   `false`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueFalse,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   `null`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueNull,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with decimal\",\n\t\t\targs: args{\n\t\t\t\ts:   `123.456`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e+4`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e-4`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"1.23e-4\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseValue() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseValue_InvalidJSON(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"invalid object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid true\",\n\t\t\targs: args{\n\t\t\t\ts:   `tr`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid false\",\n\t\t\targs: args{\n\t\t\t\ts:   `fa`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid null\",\n\t\t\targs: args{\n\t\t\t\ts:   `nu`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123.`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t_, _, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseValue_MarshalUnmarshal(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\": \"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"value1\", \"value2\"]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"value\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   `true`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   `false`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   `null`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tb, err := json.Marshal(got)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"json.Marshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tvar v Value\n\t\t\terr = json.Unmarshal(b, \u0026v)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, \u0026v) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, \u0026v)\n\t\t\t}\n\t\t})\n\t}\n}",
    "cc2ca3ffb95a189c0927b89f2ea28794": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\"world\\\\\\\"\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote at the end\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: ``,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with no quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `hello`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "cc89c1bed9800d39da5e4dc1a0fd47ba": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"simple integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"float\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential notation\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential notation with negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e-4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"inf\",\n\t\t\t},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"Inf\",\n\t\t\t},\n\t\t\twantNs:  \"Inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inF\",\n\t\t\targs: args{\n\t\t\t\ts: \"inF\",\n\t\t\t},\n\t\t\twantNs:  \"inF\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"nan\",\n\t\t\t},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"Nan\",\n\t\t\t},\n\t\t\twantNs:  \"Nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nAn\",\n\t\t\targs: args{\n\t\t\t\ts: \"nAn\",\n\t\t\t},\n\t\t\twantNs:  \"nAn\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char\",\n\t\t\targs: args{\n\t\t\t\ts: \"123a\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning\",\n\t\t\targs: args{\n\t\t\t\ts: \"a123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"a123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char after sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"-a123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"-a123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char after sign 2\",\n\t\t\targs: args{\n\t\t\t\ts: \"+a123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+a123\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}",
    "cd096a26bec96244813fa324ca0118d3": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth + 1,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"{}\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\": \"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"value1\", \"value2\"]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"value\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"value\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   `true`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueTrue,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   `false`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueFalse,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   `null`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueNull,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   `NaN`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid value\",\n\t\t\targs: args{\n\t\t\t\ts:   `invalid`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `invalid`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseValue() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseValue_JSON(t *testing.T) {\n\ttype testCase struct {\n\t\tinput string\n\t\twant  *Value\n\t}\n\ttestCases := []testCase{\n\t\t{\n\t\t\tinput: `{\"key1\": \"value1\", \"key2\": 123, \"key3\": true, \"key4\": [1, 2, 3], \"key5\": {\"nestedKey\": \"nestedValue\"}}`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\tv: valueTrue,\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key4\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key5\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tinput: `[1, 2, 3, \"string\", {\"nestedKey\": \"nestedValue\"}]`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"string\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tk: \"nestedKey\",\n\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\ts: \"nestedValue\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tinput: `null`,\n\t\t\twant:  valueNull,\n\t\t},\n\t\t{\n\t\t\tinput: `true`,\n\t\t\twant:  valueTrue,\n\t\t},\n\t\t{\n\t\t\tinput: `false`,\n\t\t\twant:  valueFalse,\n\t\t},\n\t\t{\n\t\t\tinput: `\"string\"`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"string\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tinput: `123`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tinput: `123.456`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tinput: `-123`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tinput: `-123.456`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-123.456\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tinput: `1.23e+10`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"1.23e+10\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tinput: `1.23e-10`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"1.23e-10\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tinput: `NaN`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tinput: `Infinity`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"Infinity\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tinput: `-Infinity`,\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-Infinity\",\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.input, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"parseValue() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tc.want) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseValue_CompareWithJSON(t *testing.T) {\n\ttype testCase struct {\n\t\tinput string\n\t}\n\ttestCases := []testCase{\n\t\t{\n\t\t\tinput: `{\"key1\": \"value1\", \"key2\": 123, \"key3\": true, \"key4\": [1, 2, 3], \"key5\": {\"nestedKey\": \"nestedValue\"}}`,\n\t\t},\n\t\t{\n\t\t\tinput: `[1, 2, 3, \"string\", {\"nestedKey\": \"nestedValue\"}]`,\n\t\t},\n\t\t{\n\t\t\tinput: `null`,\n\t\t},\n\t\t{\n\t\t\tinput: `true`,\n\t\t},\n\t\t{\n\t\t\tinput: `false`,\n\t\t},\n\t\t{\n\t\t\tinput: `\"string\"`,\n\t\t},\n\t\t{\n\t\t\tinput: `123`,\n\t\t},\n\t\t{\n\t\t\tinput: `123.456`,\n\t\t},\n\t\t{\n\t\t\tinput: `-123`,\n\t\t},\n\t\t{\n\t\t\tinput: `-123.456`,\n\t\t},\n\t\t{\n\t\t\tinput: `1.23e+10`,\n\t\t},\n\t\t{\n\t\t\tinput: `1.23e-10`,\n\t\t},\n\t\t{\n\t\t\tinput: `NaN`,\n\t\t},\n\t\t{\n\t\t\tinput: `Infinity`,\n\t\t},\n\t\t{\n\t\t\tinput: `-Infinity`,\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.input, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"parseValue() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tvar want interface{}\n\t\t\tif err := json.Unmarshal([]byte(tc.input), \u0026want); err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got.String(), fmt.Sprintf(\"%v\", want)) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got.String(), fmt.Sprintf(\"%v\", want))\n\t\t\t}\n\t\t})\n\t}\n}",
    "cd09872ff98ed51df9fc60253203ac1c": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\\\\\\\"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"\\\\\\\\\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\\\\\\\"\\\\\\\\\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: ``,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with no quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `hello`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "cd6cb6e8218d1f8c8539694471a3eebe": "package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u world\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u world\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\\\\\ \\\\/\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\x\\\\u world\"},\n\t\t\twant: \"\\\"hello\\\" \\\\world\\\\ /\\\\b\\\\f\\\\n\\\\r\\tabcüòÅ\\\\x\\\\u world\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "ce19768ad4ca3977d0976120357c68d6": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no whitespace\",\n\t\t\targs: args{s: \"abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace\",\n\t\t\targs: args{s: \"  abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailing whitespace\",\n\t\t\targs: args{s: \"abc  \"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading and trailing whitespace\",\n\t\t\targs: args{s: \"  abc  \"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"whitespace in the middle\",\n\t\t\targs: args{s: \"a bc\"},\n\t\t\twant: \"bc\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple whitespace\",\n\t\t\targs: args{s: \"  a  b  c  \"},\n\t\t\twant: \"b  c  \",\n\t\t},\n\t\t{\n\t\t\tname: \"carriage return\",\n\t\t\targs: args{s: \"\\r abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"carriage return in the middle\",\n\t\t\targs: args{s: \"a\\rbc\"},\n\t\t\twant: \"bc\",\n\t\t},\n\t\t{\n\t\t\tname: \"carriage return at the end\",\n\t\t\targs: args{s: \"abc\\r\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"line feed\",\n\t\t\targs: args{s: \"\\n abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"line feed in the middle\",\n\t\t\targs: args{s: \"a\\nbc\"},\n\t\t\twant: \"bc\",\n\t\t},\n\t\t{\n\t\t\tname: \"line feed at the end\",\n\t\t\targs: args{s: \"abc\\n\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"tab\",\n\t\t\targs: args{s: \"\\t abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"tab in the middle\",\n\t\t\targs: args{s: \"a\\tbc\"},\n\t\t\twant: \"bc\",\n\t\t},\n\t\t{\n\t\t\tname: \"tab at the end\",\n\t\t\targs: args{s: \"abc\\t\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"mixed whitespace\",\n\t\t\targs: args{s: \"\\r\\n\\t abc \\t\\n\\r\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "ce393aeae9568082d69d7a6c00ded17e": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth + 1,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"{}\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: nil,\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"hello\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   \"true\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueTrue,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   \"false\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueFalse,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   \"null\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueNull,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   \"123\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   \"NaN\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseValue() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "cee6ab93546cb62c80fb31265cc0b0c3": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"simple integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"float\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential notation\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential notation with negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e-4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"inf\",\n\t\t\t},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"Inf\",\n\t\t\t},\n\t\t\twantNs:  \"Inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inF\",\n\t\t\targs: args{\n\t\t\t\ts: \"inF\",\n\t\t\t},\n\t\t\twantNs:  \"inF\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"nan\",\n\t\t\t},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"Nan\",\n\t\t\t},\n\t\t\twantNs:  \"Nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nAn\",\n\t\t\targs: args{\n\t\t\t\ts: \"nAn\",\n\t\t\t},\n\t\t\twantNs:  \"nAn\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char\",\n\t\t\targs: args{\n\t\t\t\ts: \"123a\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning\",\n\t\t\targs: args{\n\t\t\t\ts: \"a123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"a123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char after sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"-a123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"-a123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char after sign 2\",\n\t\t\targs: args{\n\t\t\t\ts: \"+a123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+a123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char after sign 3\",\n\t\t\targs: args{\n\t\t\t\ts: \"-a\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"-a\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char after sign 4\",\n\t\t\targs: args{\n\t\t\t\ts: \"+a\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+a\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char after sign 5\",\n\t\t\targs: args{\n\t\t\t\ts: \"-+\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"-+\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char after sign 6\",\n\t\t\targs: args{\n\t\t\t\ts: \"+-\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+-\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}",
    "cf569eccca807a583e3e1abb4542ed42": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\"world\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\"`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with leading and trailing spaces\",\n\t\t\targs: args{\n\t\t\t\ts: `\"  hello  \"`,\n\t\t\t},\n\t\t\twant:    \"  hello  \",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped backslash\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\\world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "cfc916037e0bc9ef8c3ad68cd5ccc315": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueGet(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant *Value\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.Get(tt.args.keys...); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.Get() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "d022cd027712a505cb7c482afa838bb6": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{\\\"a\\\":1}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"{\\\"a\\\":1}\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{\\\"a\\\":1}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"a\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[1,2,3]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"hello\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   \"true\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueTrue,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   \"false\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueFalse,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   \"null\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueNull,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   \"123\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   \"NaN\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseValue() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseValue_Unmarshal(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    interface{}\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts: \"{\\\"a\\\":1}\",\n\t\t\t},\n\t\t\twant:    map[string]interface{}{\"a\": 1.0},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts: \"[1,2,3]\",\n\t\t\t},\n\t\t\twant:    []interface{}{1.0, 2.0, 3.0},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts: \"true\",\n\t\t\t},\n\t\t\twant:    true,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts: \"false\",\n\t\t\t},\n\t\t\twant:    false,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts: \"null\",\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant:    123.0,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv, _, err := parseValue(tt.args.s, \u0026cache{}, 0)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif tt.wantErr {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tvar got interface{}\n\t\t\tif err := json.Unmarshal(v.MarshalTo(nil), \u0026got); err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "d08a0b4bda078a33a560fef033579209": "```go\npackage fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u world\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00xx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u00xx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 2\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uxxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uxxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 3\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0xxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0xxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 4\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1xxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u1xxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 5\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u2xxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u2xxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 6\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u3xxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u3xxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 7\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u4xxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u4xxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 8\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u5xxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u5xxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 9\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u6xxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u6xxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 10\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u7xxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u7xxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 11\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u8xxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u8xxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 12\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u9xxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u9xxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 13\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uaxxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uaxxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 14\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\ubxxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\ubxxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 15\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\ucxxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\ucxxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 16\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\udxxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\udxxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 17\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uexxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uexxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 18\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\ufxxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\ufxxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 19\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\ugxxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\ugxxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 20\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uhxxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uhxxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 21\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uixxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uixxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 22\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\ujxxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\ujxxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 23\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\ukxxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\ukxxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 24\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\ulxxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\ulxxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 25\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\umxxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\umxxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 26\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\unxxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\unxxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 27\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uoxxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uoxxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 28\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\upxxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\upxxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 29\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uqxxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uqxxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 30\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\urxxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\urxxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 31\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\usxxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\usxxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 32\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\utxxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\utxxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 33\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uvxxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uvxxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 34\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uwxxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uwxxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 35\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\uxxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\uxxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 36\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\u0xxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\u0xxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 37\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\u1xxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\u1xxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 38\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\u2xxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\u2xxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 39\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\u3xxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\u3xxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 40\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\u4xxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\u4xxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 41\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\u5xxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\u5xxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 42\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\u6xxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\u6xxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 43\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\u7xxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\u7xxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 44\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\u8xxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\u8xxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 45\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\u9xxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\u9xxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 46\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\uaxxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\uaxxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 47\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\ubxxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\ubxxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 48\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\ucxxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\ucxxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 49\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\udxxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\udxxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 50\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\uexxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\uexxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 51\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\ufxxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\ufxxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 52\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\ugxxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\ugxxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 53\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\uhxxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\uhxxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 54\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\uixxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\uixxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 55\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\ujxxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\ujxxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 56\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\ukxxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\ukxxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 57\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\ulxxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\ulxxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 58\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\umxxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\umxxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 59\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\unxxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\unxxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 60\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\uoxxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\uoxxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 61\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\upxxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\upxxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 62\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\uqxxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\uqxxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 63\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\urxxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\urxxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 64\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\usxxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\usxxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 65\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\utxxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\utxxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 66\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\uvxxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\uvxxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 67\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\uwxxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\uwxxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 68\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\uxxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\uxxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 69\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\u0xxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\u0xxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 70\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\u1xxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\u1xxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 71\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\u2xxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\u2xxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 72\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\u3xxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\u3xxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 73\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\u4xxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\u4xxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 74\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\u5xxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\u5xxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 75\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\u6xxx\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\u0061\\\\u0062\\\\u0063\\\\u6xxx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex 76\",\n\t\t\targs: args{s: \"\\\\u",
    "d17936696f61395fe3f9b52667ef3ece": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no whitespace\",\n\t\t\targs: args{s: \"abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace\",\n\t\t\targs: args{s: \"  abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailing whitespace\",\n\t\t\targs: args{s: \"abc  \"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading and trailing whitespace\",\n\t\t\targs: args{s: \"  abc  \"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"whitespace in the middle\",\n\t\t\targs: args{s: \"a bc\"},\n\t\t\twant: \"bc\",\n\t\t},\n\t\t{\n\t\t\tname: \"all whitespace\",\n\t\t\targs: args{s: \"   \"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"mixed whitespace\",\n\t\t\targs: args{s: \" \\t\\n\\r abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "d19552cb4a85b8bdc7ee59d416f1defb": "package fastjson\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\tv   *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"marshal null\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNull},\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal true\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeTrue},\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal false\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeFalse},\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal number\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t},\n\t\t\twant: []byte(\"123\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeString, s: \"hello world\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello world\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal raw string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: typeRawString, s: \"hello world\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello world\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal array\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t\t{t: TypeString, s: \"hello\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"[1,\\\"hello\\\"]\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal object\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeNumber, s: \"1\"}},\n\t\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"hello\"}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":1,\"key2\":\"hello\"}`),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.v.MarshalTo(tt.args.dst); !bytes.Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "d1c42aa0ff9a668dfcf23c9f797c946e": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_JSON(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_JSON_CompareWithStdlib(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tvar want map[string]interface{}\n\t\t\tif err := json.Unmarshal([]byte(tt.args.s), \u0026want); err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got.o.kvs, want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got.o.kvs, want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "d2756c18d2278ae148d9b3426eb9553b": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "d37f73f2514549345a227ae9b96d41ee": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantKey string\n\t\twantTail string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"simple key\",\n\t\t\targs:    args{s: `\"key\"`},\n\t\t\twantKey: \"key\",\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"key with space\",\n\t\t\targs:    args{s: `\"key with space\"`},\n\t\t\twantKey: \"key with space\",\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"key with escape sequence\",\n\t\t\targs:    args{s: `\"key\\\\\"with\\\\\"escape\\\\\"sequence\"`},\n\t\t\twantKey: \"key\\\\\\\"with\\\\\\\"escape\\\\\\\"sequence\",\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"missing closing quote\",\n\t\t\targs:    args{s: `\"key`},\n\t\t\twantKey: \"key\",\n\t\t\twantTail: \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"empty key\",\n\t\t\targs:    args{s: `\"\"`},\n\t\t\twantKey: \"\",\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotKey, gotTail, err := parseRawKey(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawKey() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotKey != tt.wantKey {\n\t\t\t\tt.Errorf(\"parseRawKey() gotKey = %v, want %v\", gotKey, tt.wantKey)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseRawKey() gotTail = %v, want %v\", gotTail, tt.wantTail)\n\t\t\t}\n\t\t})\n\t}\n}",
    "d384e78a0455b8094e0cc981c2bfffd0": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_unescapeKeys(t *testing.T) {\n\ttype args struct {\n\t\to *Object\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant *Object\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\ttt.args.o.unescapeKeys()\n\t\t\tif got := tt.args.o; !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Object.unescapeKeys() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "d4399876666ac672c67f3ad25ddf2cf4": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth + 1,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"{}\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\": \"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"value1\", \"value2\"]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"value\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"value\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   `true`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueTrue,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   `false`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueFalse,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   `null`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueNull,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   `NaN`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected value\",\n\t\t\targs: args{\n\t\t\t\ts:   `123true`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `123true`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseValue() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseValue_MarshalJSON(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    string\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"object\",\n\t\t\ts:    `{\"key\": \"value\"}`,\n\t\t\twant: `{\"key\":\"value\"}`,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\ts:    `[\"value1\", \"value2\"]`,\n\t\t\twant: `[\"value1\",\"value2\"]`,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\ts:    `\"value\"`,\n\t\t\twant: `\"value\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\ts:    `true`,\n\t\t\twant: `true`,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\ts:    `false`,\n\t\t\twant: `false`,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\ts:    `null`,\n\t\t\twant: `null`,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\ts:    `123`,\n\t\t\twant: `123`,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\ts:    `NaN`,\n\t\t\twant: `\"NaN\"`,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tv, _, err := parseValue(tt.s, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"parseValue() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgot, err := json.Marshal(v)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"json.Marshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif string(got) != tt.want {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", string(got), tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "d4b604f7b013fd7cbb085e5d0f4c170d": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"simple integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple float\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative float\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123.456\",\n\t\t\t},\n\t\t\twantNs:  \"-123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"float with exponent\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"float with negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e-4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"inf\",\n\t\t\t},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"Inf\",\n\t\t\t},\n\t\t\twantNs:  \"Inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inF\",\n\t\t\targs: args{\n\t\t\t\ts: \"inF\",\n\t\t\t},\n\t\t\twantNs:  \"inF\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"nan\",\n\t\t\t},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"Nan\",\n\t\t\t},\n\t\t\twantNs:  \"Nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nAn\",\n\t\t\targs: args{\n\t\t\t\ts: \"nAn\",\n\t\t\t},\n\t\t\twantNs:  \"nAn\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char\",\n\t\t\targs: args{\n\t\t\t\ts: \"123a\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"123a\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at start\",\n\t\t\targs: args{\n\t\t\t\ts: \"a123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"a123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at start 2\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at start 3\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"-123a\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at start 4\",\n\t\t\targs: args{\n\t\t\t\ts: \"-a123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"-a123\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}",
    "d5afcbd21334131754f319a21296c8e1": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"single element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,3]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[[1,2],[3,4]]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"4\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with string\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[\\\"hello\\\", \\\"world\\\"]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"hello\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"world\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with object\",\n\t\t\targs: args{\n\t\t\t\ts:    `[{\"name\": \"John\", \"age\": 30}, {\"name\": \"Jane\", \"age\": 25}]`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tk: \"name\",\n\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\ts: \"John\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tk: \"age\",\n\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\t\ts: \"30\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tk: \"name\",\n\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\ts: \"Jane\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tk: \"age\",\n\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\t\ts: \"25\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,3,\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1,2,3,\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,3\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1,2,3\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseArray() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseArray_JSON(t *testing.T) {\n\ttype testCase struct {\n\t\tjson string\n\t\twant []interface{}\n\t}\n\ttestCases := []testCase{\n\t\t{\n\t\t\tjson: \"[]\",\n\t\t\twant: []interface{}{},\n\t\t},\n\t\t{\n\t\t\tjson: \"[1,2,3]\",\n\t\t\twant: []interface{}{1, 2, 3},\n\t\t},\n\t\t{\n\t\t\tjson: `[\"hello\", \"world\"]`,\n\t\t\twant: []interface{}{\"hello\", \"world\"},\n\t\t},\n\t\t{\n\t\t\tjson: `[{\"name\": \"John\", \"age\": 30}, {\"name\": \"Jane\", \"age\": 25}]`,\n\t\t\twant: []interface{}{\n\t\t\t\tmap[string]interface{}{\"name\": \"John\", \"age\": 30},\n\t\t\t\tmap[string]interface{}{\"name\": \"Jane\", \"age\": 25},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.json, func(t *testing.T) {\n\t\t\tvar got []interface{}\n\t\t\tif err := json.Unmarshal([]byte(tc.json), \u0026got); err != nil {\n\t\t\t\tt.Fatalf(\"json.Unmarshal failed: %v\", err)\n\t\t\t}\n\t\t\tc := \u0026cache{}\n\t\t\tv, _, err := parseArray(tc.json, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"parseArray failed: %v\", err)\n\t\t\t}\n\t\t\tif len(v.a) != len(tc.want) {\n\t\t\t\tt.Errorf(\"parseArray length mismatch: got %d, want %d\", len(v.a), len(tc.want))\n\t\t\t\treturn\n\t\t\t}\n\t\t\tfor i, want := range tc.want {\n\t\t\t\tswitch want.(type) {\n\t\t\t\tcase int:\n\t\t\t\t\tif v.a[i].t != TypeNumber {\n\t\t\t\t\t\tt.Errorf(\"parseArray type mismatch: got %v, want %v\", v.a[i].t, TypeNumber)\n\t\t\t\t\t}\n\t\t\t\t\tif v.a[i].s != fmt.Sprintf(\"%d\", want) {\n\t\t\t\t\t\tt.Errorf(\"parseArray value mismatch: got %v, want %v\", v.a[i].s, want)\n\t\t\t\t\t}\n\t\t\t\tcase string:\n\t\t\t\t\tif v.a[i].t != TypeString {\n\t\t\t\t\t\tt.Errorf(\"parseArray type mismatch: got %v, want %v\", v.a[i].t, TypeString)\n\t\t\t\t\t}\n\t\t\t\t\tif v.a[i].s != want {\n\t\t\t\t\t\tt.Errorf(\"parseArray value mismatch: got %v, want %v\", v.a[i].s, want)\n\t\t\t\t\t}\n\t\t\t\tcase map[string]interface{}:\n\t\t\t\t\tif v.a[i].t != TypeObject {\n\t\t\t\t\t\tt.Errorf(\"parseArray type mismatch: got %v, want %v\", v.a[i].t, TypeObject)\n\t\t\t\t\t}\n\t\t\t\t\tfor k, w := range want.(map[string]interface{}) {\n\t\t\t\t\t\tif v.a[i].o.kvs[k].v.t != TypeNumber \u0026\u0026 v.a[i].o.kvs[k].v.t != TypeString {\n\t\t\t\t\t\t\tt.Errorf(\"parseArray object type mismatch: got %v, want %v\", v.a[i].o.kvs[k].v.t, TypeNumber)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif v.a[i].o.kvs[k].v.s != fmt.Sprintf(\"%v\", w) {\n\t\t\t\t\t\t\tt.Errorf(\"parseArray object value mismatch: got %v, want %v\", v.a[i].o.kvs[k].v.s, w)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tt.Errorf(\"parseArray unsupported type: %T\", want)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}",
    "d6b58a3300f6f0aa3be4fdc50d3224d9": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueStringBytes(t *testing.T) {\n\ttype args struct {\n\t\tv *Value\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    []byte\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := tt.args.v.StringBytes()\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Value.StringBytes() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr \u0026\u0026 !bytes.Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.StringBytes() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "d82823f69afa030b585520cf90bdf567": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestType_String(t *testing.T) {\n\ttype args struct {\n\t\tt Type\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"TypeObject\",\n\t\t\targs: args{t: TypeObject},\n\t\t\twant: \"object\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeArray\",\n\t\t\targs: args{t: TypeArray},\n\t\t\twant: \"array\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeString\",\n\t\t\targs: args{t: TypeString},\n\t\t\twant: \"string\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeNumber\",\n\t\t\targs: args{t: TypeNumber},\n\t\t\twant: \"number\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeTrue\",\n\t\t\targs: args{t: TypeTrue},\n\t\t\twant: \"true\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeFalse\",\n\t\t\targs: args{t: TypeFalse},\n\t\t\twant: \"false\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeNull\",\n\t\t\targs: args{t: TypeNull},\n\t\t\twant: \"null\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.t.String(); got != tt.want {\n\t\t\t\tt.Errorf(\"Type.String() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "db61f8c8bafafa3f785b8278370ea805": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\"world\\\\\\\"\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote at the end\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote at the beginning\",\n\t\t\targs: args{\n\t\t\t\ts: `\\\\\"hello\"`,\n\t\t\t},\n\t\t\twant:    `\\`,\n\t\t\twant1:   `\"hello\"`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote in the middle\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with no quotes\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "dc8534c514a95ac790249388b3fb0c86": "```go\npackage fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"simple integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"float number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential number\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential number with negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e-4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"inf\",\n\t\t\t},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"Inf\",\n\t\t\t},\n\t\t\twantNs:  \"Inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inF\",\n\t\t\targs: args{\n\t\t\t\ts: \"inF\",\n\t\t\t},\n\t\t\twantNs:  \"inF\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"nan\",\n\t\t\t},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twantNs:  \"NaN\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nAn\",\n\t\t\targs: args{\n\t\t\t\ts: \"nAn\",\n\t\t\t},\n\t\t\twantNs:  \"nAn\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123a\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"-inf\",\n\t\t\t},\n\t\t\twantNs:  \"-inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"-nan\",\n\t\t\t},\n\t\t\twantNs:  \"-nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid",
    "dc8ba8ea3d6e15a7873c4367652b2c60": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no whitespace\",\n\t\t\targs: args{s: \"abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace\",\n\t\t\targs: args{s: \"  abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailing whitespace\",\n\t\t\targs: args{s: \"abc  \"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"whitespace in the middle\",\n\t\t\targs: args{s: \"a bc\"},\n\t\t\twant: \"bc\",\n\t\t},\n\t\t{\n\t\t\tname: \"all whitespace\",\n\t\t\targs: args{s: \"   \"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"mixed whitespace\",\n\t\t\targs: args{s: \"\\t\\n abc \\r  \"},\n\t\t\twant: \"abc\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "dca2d006634fa60407c962b9f0af8fda": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_JSONUnmarshal(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_JSONUnmarshal_Compare(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\n\t\t\tvar wantJSON map[string]interface{}\n\t\t\tif err := json.Unmarshal([]byte(tt.args.s), \u0026wantJSON); err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tvar gotJSON map[string]interface{}\n\t\t\tif err := json.Unmarshal(got.StringBytes(), \u0026gotJSON); err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !reflect.DeepEqual(gotJSON, wantJSON) {\n\t\t\t\tt.Errorf(\"parseObject() gotJSON = %v, wantJSON %v\", gotJSON, wantJSON)\n\t\t\t}\n\t\t})\n\t}\n}",
    "dd219a2aa44bcb66c6744f5b2ba36ce9": "package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello world\",\n\t\t\t},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\\\\"hello\\\\\\\"\",\n\t\t\t},\n\t\t\twant: \"\\\"hello\\\"\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\\\\\hello\\\\\\\\\",\n\t\t\t},\n\t\t\twant: \"\\\\hello\\\\\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\/hello\\\\/\",\n\t\t\t},\n\t\t\twant: \"/hello/\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\bhello\\\\b\",\n\t\t\t},\n\t\t\twant: \"\\bhello\\b\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\fhello\\\\f\",\n\t\t\t},\n\t\t\twant: \"\\fhello\\f\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\nhello\\\\n\",\n\t\t\t},\n\t\t\twant: \"\\nhello\\n\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\rhello\\\\r\",\n\t\t\t},\n\t\t\twant: \"\\rhello\\r\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\thello\\\\t\",\n\t\t\t},\n\t\t\twant: \"\\thello\\t\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\u0061hello\\\\u0062\",\n\t\t\t},\n\t\t\twant: \"ahello b\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\uD83D\\\\uDE01hello\",\n\t\t\t},\n\t\t\twant: \"üòÅhello\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\xhello\",\n\t\t\t},\n\t\t\twant: \"\\\\xhello\",\n\t\t},\n\t\t{\n\t\t\tname: \"short unicode escape sequence\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\u006\",\n\t\t\t},\n\t\t\twant: \"\\\\u006\",\n\t\t},\n\t\t{\n\t\t\tname: \"short surrogate pair escape sequence\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\uD83D\\\\uDE\",\n\t\t\t},\n\t\t\twant: \"\\\\uD83D\\\\uDE\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\\\\\ \\\\/test\\\\/\",\n\t\t\t},\n\t\t\twant: \"\\\"hello\\\" \\\\world\\\\ /test/\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "dde25cf643e56e97e53ca4ead8c2e7f0": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"empty string\",\n\t\t\targs:    args{s: \"\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"single digit\",\n\t\t\targs:    args{s: \"1\"},\n\t\t\twantNs:  \"1\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"multiple digits\",\n\t\t\targs:    args{s: \"123\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"decimal number\",\n\t\t\targs:    args{s: \"123.456\"},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"negative number\",\n\t\t\targs:    args{s: \"-123\"},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"positive number\",\n\t\t\targs:    args{s: \"+123\"},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"exponential number\",\n\t\t\targs:    args{s: \"1.23e+4\"},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"exponential number with lowercase e\",\n\t\t\targs:    args{s: \"1.23e-4\"},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"inf\",\n\t\t\targs:    args{s: \"inf\"},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"INF\",\n\t\t\targs:    args{s: \"INF\"},\n\t\t\twantNs:  \"INF\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"nan\",\n\t\t\targs:    args{s: \"nan\"},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"NAN\",\n\t\t\targs:    args{s: \"NAN\"},\n\t\t\twantNs:  \"NAN\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number\",\n\t\t\targs:    args{s: \"123a\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading plus sign\",\n\t\t\targs:    args{s: \"+123a\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+123a\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading minus sign\",\n\t\t\targs:    args{s: \"-123a\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"-123a\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading plus sign and trailing whitespace\",\n\t\t\targs:    args{s: \"+123 \"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+123 \",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading minus sign and trailing whitespace\",\n\t\t\targs:    args{s: \"-123 \"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"-123 \",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}",
    "de1d09d9d4effb17d78a1263560aee71": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no whitespace\",\n\t\t\targs: args{s: \"abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace\",\n\t\t\targs: args{s: \"  abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailing whitespace\",\n\t\t\targs: args{s: \"abc  \"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading and trailing whitespace\",\n\t\t\targs: args{s: \"  abc  \"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"whitespace in the middle\",\n\t\t\targs: args{s: \"a bc\"},\n\t\t\twant: \"bc\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple whitespace\",\n\t\t\targs: args{s: \"  a  b  c  \"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"newline whitespace\",\n\t\t\targs: args{s: \"\\n abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"tab whitespace\",\n\t\t\targs: args{s: \"\\t abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"carriage return whitespace\",\n\t\t\targs: args{s: \"\\r abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"all whitespace\",\n\t\t\targs: args{s: \"  \\n\\t\\r  \"},\n\t\t\twant: \"\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "df4c44fc41f3659b59dbb32405ad0613": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetBool(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant bool\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.GetBool(tt.args.keys...); got != tt.want {\n\t\t\t\tt.Errorf(\"Value.GetBool() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e08540605cae6ed9a666d3cee7b412f7": "package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello world\"},\n\t\t\twant: \"\\\\hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello world\"},\n\t\t\twant: \"/hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello world\"},\n\t\t\twant: \"\\bhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello world\"},\n\t\t\twant: \"\\fhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello world\"},\n\t\t\twant: \"\\nhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello world\"},\n\t\t\twant: \"\\rhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello world\"},\n\t\t\twant: \"\\thello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061hello world\"},\n\t\t\twant: \"ahello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01hello world\"},\n\t\t\twant: \"üòÅhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello world\"},\n\t\t\twant: \"\\\\xhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"short escape sequence\",\n\t\t\targs: args{s: \"\\\\uhello world\"},\n\t\t\twant: \"\\\\uhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\u0061hello world\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01ahello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\n\\\\u0061\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"\\\"hello\\\" \\\\world\\naüòÅ\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e0c44423b42e12e4986c689637048fc2": "package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u006\"},\n\t\t\twant: \"\\\\u0061\\\\u006\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\\\\\ \\\\/\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\x\\\\u006\"},\n\t\t\twant: \"\\\"hello\\\" \\\\world\\\\ /\\\\b\\\\f\\\\n\\\\r\\\\tabcüòÅ\\\\x\\\\u006\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e21671345d404e178d58a9be757c585b": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"single element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,3]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[[1,2],[3,4]]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"4\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with string elements\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[\\\"hello\\\",\\\"world\\\"]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"hello\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"world\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1,2\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"array with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1 2]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1 2]\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseArray() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e23f2363915a7f8671a8500fbf19be5d": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\tv   *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"marshal null\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNull},\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal true\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeTrue},\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal false\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeFalse},\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal number\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t},\n\t\t\twant: []byte(\"123\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeString, s: \"hello world\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello world\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal raw string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: typeRawString, s: \"hello world\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello world\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal array\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t\t{t: TypeString, s: \"hello\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"[1,\\\"hello\\\"]\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal object\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{k: \"name\", v: \u0026Value{t: TypeString, s: \"John Doe\"}},\n\t\t\t\t\t\t\t{k: \"age\", v: \u0026Value{t: TypeNumber, s: \"30\"}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`{\"name\":\"John Doe\",\"age\":30}`),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.v.MarshalTo(tt.args.dst); !bytesEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc bytesEqual(a, b []byte) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "e29ea33cab5b9f9fb4523fdea62a7bfd": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"simple integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"float\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential notation\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential notation with negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e-4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"inf\",\n\t\t\t},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"nan\",\n\t\t\t},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123a\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and invalid character\",\n\t\t\targs: args{\n\t\t\t\ts: \"-a123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"-a123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and invalid character\",\n\t\t\targs: args{\n\t\t\t\ts: \"+a123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+a123\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e2f1c5765c1a8aba24c0ebf5d434d945": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e310404b1d11354d4286fbf82a7a9788": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_JSONUnmarshal(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_JSONUnmarshal_Compare(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t\tvar jsonUnmarshaled map[string]interface{}\n\t\t\terr = json.Unmarshal([]byte(tt.args.s), \u0026jsonUnmarshaled)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e32f3799b5fb1bcda0719fd195661530": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061hello\\\\u world\"},\n\t\t\twant: \"\\\\u0061hello\\\\u world\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\\\\\ \\\\/test\\\\/\"},\n\t\t\twant: \"\\\"hello\\\" \\\\world\\\\ /test/\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e367c07855bfa56e25589782286ec8b7": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped string with multiple escapes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\"world\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\\\\\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: ``,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with no quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `hello`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e3b625c10b9083a177ee75bf2554ab5a": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"single element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,3]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[[1,2],[3,4]]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"4\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1,2\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1 2]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1 2]\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseArray() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e3eb0620aefa4f7a91429e17a5df1d87": "```go\npackage fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u world\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u world\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\\\\\ \\\\/test\\\\/ \\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\x\"},\n\t\t\twant: \"\\\"hello\\\" \\\\world\\\\ /test/ \\b\\f\\n\\r\\tabcüòÅ\\\\x\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_SurrogatePair(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"valid surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\"},\n\t\t\twant: \"\\\\uD83D\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE02\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE02\",\n\t\t},\n\t\t{\n\t\t\tname: \"surrogate pair with invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\xDE01\"},\n\t\t\twant: \"\\\\uD83D\\\\xDE01\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_InvalidEscapeSequence(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u world\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u world\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence with surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\xDE01\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\uD83D\\\\xDE01\\\\xhello\\\\x world\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_Unicode(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"valid unicode escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid unicode escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u world\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u world\",\n\t\t},\n\t\t{\n\t\t\tname: \"unicode escape sequence with surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"üòÅabc\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_Performance(t *testing.T) {\n\ts := \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\\\\\ \\\\/test\\\\/ \\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\x\"\n\tfor i := 0; i \u003c 10000; i++ {\n\t\tunescapeStringBestEffort(s)\n\t}\n}\n\nfunc BenchmarkUnescapeStringBestEffort(b *testing.B) {\n\ts := \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\\\\\ \\\\/test\\\\/ \\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\x\"\n\tb.ResetTimer()\n\tfor i := 0; i \u003c b.N; i++ {\n\t\tunescapeStringBestEffort(s)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_SurrogatePair_Performance(t *testing.T) {\n\ts := \"\\\\uD83D\\\\uDE01\"\n\tfor i := 0; i \u003c 10000; i++ {\n\t\tunescapeStringBestEffort(s)\n\t}\n}\n\nfunc BenchmarkUnescapeStringBestEffort_SurrogatePair(b *testing.B) {\n\ts := \"\\\\uD83D\\\\uDE01\"\n\tb.ResetTimer()\n\tfor i := 0; i \u003c b.N; i++ {\n\t\tunescapeStringBestEffort(s)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_InvalidEscapeSequence_Performance(t *testing.T) {\n\ts := \"\\\\xhello\\\\x world\"\n\tfor i := 0; i \u003c 10000; i++ {\n\t\tunescapeStringBestEffort(s)\n\t}\n}\n\nfunc BenchmarkUnescapeStringBestEffort_InvalidEscapeSequence(b *testing.B) {\n\ts := \"\\\\xhello\\\\x world\"\n\tb.ResetTimer()\n\tfor i := 0; i \u003c b.N; i++ {\n\t\tunescapeStringBestEffort(s)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_Unicode_Performance(t *testing.T) {\n\ts := \"\\\\u0061\\\\u0062\\\\u0063\"\n\tfor i := 0; i \u003c 10000; i++ {\n\t\tunescapeStringBestEffort(s)\n\t}\n}\n\nfunc BenchmarkUnescapeStringBestEffort_Unicode(b *testing.B) {\n\ts := \"\\\\u0061\\\\u0062\\\\u0063\"\n\tb.ResetTimer()\n\tfor i := 0; i \u003c b.N; i++ {\n\t\tunescapeStringBestEffort(s)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_MultipleEscapeSequences_Performance(t *testing.T) {\n\ts := \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\\\\\ \\\\/test\\\\/ \\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\x\"\n\tfor i := 0; i \u003c 10000; i++ {\n\t\tunescapeStringBestEffort(s)\n\t}\n}\n\nfunc BenchmarkUnescapeStringBestEffort_MultipleEscapeSequences(b *testing.B) {\n\ts := \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\\\\\ \\\\/test\\\\/ \\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\x\"\n\tb.ResetTimer()\n\tfor i := 0; i \u003c b.N; i++ {\n\t\tunescapeStringBestEffort(s)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_LargeString_Performance(t *testing.T) {\n\ts := \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\\\\\ \\\\/test\\\\/ \\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\x\"\n\tfor i := 0; i \u003c 10000; i++ {\n\t\ts += s\n\t}\n\tfor i := 0; i \u003c 100; i++ {\n\t\tunescapeStringBestEffort(s)\n\t}\n}\n\nfunc BenchmarkUnescapeStringBestEffort_LargeString(b *testing.B) {\n\ts := \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\\\\\ \\\\/test\\\\/ \\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\x\"\n\tfor i := 0; i \u003c 10000; i++ {\n\t\ts += s\n\t}\n\tb.ResetTimer()\n\tfor i := 0; i \u003c b.N; i++ {\n\t\tunescapeStringBestEffort(s)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_EscapeSequenceAtBeginning(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"escaped quote at beginning\",\n\t\t\targs: args{s: \"\\\\\\\"hello world\"},\n\t\t\twant: \"\\\"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslash at beginning\",\n\t\t\targs: args{s: \"\\\\\\\\hello world\"},\n\t\t\twant: \"\\\\hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slash at beginning\",\n\t\t\targs: args{s: \"\\\\/hello world\"},\n\t\t\twant: \"/hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace at beginning\",\n\t\t\targs: args{s: \"\\\\bhello world\"},\n\t\t\twant: \"\\bhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed at beginning\",\n\t\t\targs: args{s: \"\\\\fhello world\"},\n\t\t\twant: \"\\fhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline at beginning\",\n\t\t\targs: args{s: \"\\\\nhello world\"},\n\t\t\twant: \"\\nhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return at beginning\",\n\t\t\targs: args{s: \"\\\\rhello world\"},\n\t\t\twant: \"\\rhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab at beginning\",\n\t\t\targs: args{s: \"\\\\thello world\"},\n\t\t\twant: \"\\thello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode at beginning\",\n\t\t\targs: args{s: \"\\\\u0061hello world\"},\n\t\t\twant: \"ahello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair at beginning\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01hello world\"},\n\t\t\twant: \"üòÅhello world\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_EscapeSequenceAtEnd(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"escaped quote at end\",\n\t\t\targs: args{s: \"hello world\\\\\\\"\"},\n\t\t\twant: \"hello world\\\"\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslash at end\",\n\t\t\targs: args{s: \"hello world\\\\\\\\\"},\n\t\t\twant: \"hello world\\\\\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slash at end\",\n\t\t\targs: args{s: \"hello world\\\\/\"},\n\t\t\twant: \"hello world/\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace at end\",\n\t\t\targs: args{s: \"hello world\\\\b\"},\n\t\t\twant: \"hello world\\b\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed at end\",\n\t\t\targs: args{s: \"hello world\\\\f\"},\n\t\t\twant: \"hello world\\f\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline at end\",\n\t\t\targs: args{s: \"hello world\\\\n\"},\n\t\t\twant: \"hello world\\n\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return at end\",\n\t\t\targs: args{s: \"hello world\\\\r\"},\n\t\t\twant: \"hello world\\r\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab at end\",\n\t\t\targs: args{s: \"hello world\\\\t\"},\n\t\t\twant: \"hello world\\t\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode at end\",\n\t\t\targs: args{s: \"hello world\\\\u0061\"},\n\t\t\twant: \"hello worlda\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair at end\",\n\t\t\targs: args{s: \"hello world\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"hello worldüòÅ\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_EscapeSequenceInMiddle(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"escaped quote in middle\",\n\t\t\targs: args{s: \"hello \\\\\\\"world\"},\n\t\t\twant: \"hello \\\"world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslash in middle\",\n\t\t\targs: args{s: \"hello \\\\\\\\world\"},\n\t\t\twant: \"hello \\\\world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slash in middle\",\n\t\t\targs: args{s: \"hello \\\\/world\"},\n\t\t\twant: \"hello /world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace in middle\",\n\t\t\targs: args{s: \"hello \\\\bworld\"},\n\t\t\twant: \"hello \\bworld\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed in middle\",\n\t\t\targs: args{s: \"hello \\\\fworld\"},\n\t\t\twant: \"hello \\fworld\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline in middle\",\n\t\t\targs: args{s: \"hello \\\\nworld\"},\n\t\t\twant: \"hello \\nworld\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return in middle\",\n\t\t\targs: args{s: \"hello \\\\rworld\"},\n\t\t\twant: \"hello \\rworld\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab in middle\",\n\t\t\targs: args{s: \"hello \\\\tworld\"},\n\t\t\twant: \"hello \\tworld\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode in middle\",\n\t\t\targs: args{s: \"hello \\\\u0061world\"},\n\t\t\twant: \"hello aworld\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair in middle\",\n\t\t\targs: args{s: \"hello \\\\uD83D\\\\uDE01world\"},\n\t\t\twant: \"hello üòÅworld\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_EscapeSequenceWithSpecialCharacters(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"escaped quote with special characters\",\n\t\t\targs: args{s: \"\\\\\\\"hello world!@#$%^\u0026*()_+-={}[]|\\\\:;'\u003c\u003e,.?/\"},\n\t\t\twant: \"\\\"hello world!@#$%^\u0026*()_+-={}[]|\\\\:;'\u003c\u003e,.?/\"},\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslash with special characters\",\n\t\t\targs: args{s: \"\\\\\\\\hello world!@#$%^\u0026*()_+-={}[]|\\\\:;'\u003c\u003e,.?/\"},\n\t\t\twant: \"\\\\hello world!@#$%^\u0026*()_+-={}[]|\\\\:;'\u003c\u003e,.?/\"},\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slash with special characters\",\n\t\t\targs: args{s: \"\\\\/hello world!@#$%^\u0026*()_+-={}[]|\\\\:;'\u003c\u003e,.?/\"},\n\t\t\twant: \"/hello world!@#$%^\u0026*()_+-={}[]|\\\\:;'\u003c\u003e,.?/\"},\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace with special characters\",\n\t\t\targs: args{s: \"\\\\bhello world!@#$%^\u0026*()_+-={}[]|\\\\:;'\u003c\u003e,.?/\"},\n\t\t\twant: \"\\bhello world!@#$%^\u0026*()_+-={}[]|\\\\:;'\u003c\u003e,.?/\"},\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed with special characters\",\n\t\t\targs: args{s: \"\\\\fhello world!@#$%^\u0026*()_+-={}[]|\\\\:;'\u003c\u003e,.?/\"},\n\t\t\twant: \"\\fhello world!@#$%^\u0026*()_+-={}[]|\\\\:;'\u003c\u003e,.?/\"},\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline with special characters\",\n\t\t\targs: args{s: \"\\\\nhello world!@#$%^\u0026*()_+-={}[]|\\\\:;'\u003c\u003e,.?/\"},\n\t\t\twant: \"\\nhello world!@#$%^\u0026*()_+-={}[]|\\\\:;'\u003c\u003e,.?/\"},\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return with special characters\",\n\t\t\targs: args{s: \"\\\\rhello world!@#$%^\u0026*()_+-={}[]|\\\\:;'\u003c\u003e,.?/\"},\n\t\t\twant: \"\\rhello world!@#$%^\u0026*()_+-={}[]|\\\\:;'\u003c\u003e,.?/\"},\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab with special characters\",\n\t\t\targs: args{s: \"\\\\thello world!@#$%^\u0026*()_+-={}[]|\\\\:;'\u003c\u003e,.?/\"},\n\t\t\twant: \"\\thello world!@#$%^\u0026*()_+-={}[]|\\\\:;'\u003c\u003e,.?/\"},\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with special characters\",\n\t\t\targs: args{s: \"\\\\u0061hello world!@#$%^\u0026*()_+-={}[]|\\\\:;'\u003c\u003e,.?/\"},\n\t\t\twant: \"ahello world!@#$%^\u0026*()_+-={}[]|\\\\:;'\u003c\u003e,.?/\"},\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with special characters\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01hello world!@#$%^\u0026*()_+-={}[]|\\\\:;'\u003c\u003e,.?/\"},\n\t\t\twant: \"üòÅhello world!@#$%^\u0026*()_+-={}[]|\\\\:;'\u003c\u003e,.?/\"},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_EscapeSequenceWithControlCharacters(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"escaped quote with control characters\",\n\t\t\targs: args{s: \"\\\\\\\"hello world\\x07\\x08\\x09\\x0A\\x0B\\x0C\\x0D\\x1B\"},\n\t\t\twant: \"\\\"hello world\\x07\\x08\\x09\\x0A\\x0B\\x0C\\x0D\\x1B\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslash with control characters\",\n\t\t\targs: args{s: \"\\\\\\\\hello world\\x07\\x08\\x09\\x0A\\x0B\\x0C\\x0D\\x1B\"},\n\t\t\twant: \"\\\\hello world\\x07\\x08\\x09\\x0A\\x0B\\x0C\\x0D\\x1B\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slash with control characters\",\n\t\t\targs: args{s: \"\\\\/hello world\\x07\\x08\\x09\\x0A\\x0B\\x0C\\x0D\\x1B\"},\n\t\t\twant: \"/hello world\\x07\\x08\\x09\\x0A\\x0B\\x0C\\x0D\\x1B\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace with control characters\",\n\t\t\targs: args{s: \"\\\\bhello world\\x07\\x08\\x09\\x0A\\x0B\\x0C\\x0D\\x1B\"},\n\t\t\twant: \"\\bhello world\\x07\\x08\\x09\\x0A\\x0B\\x0C\\x0D\\x1B\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed with control characters\",\n\t\t\targs: args{s: \"\\\\fhello world\\x07\\x08\\x09\\x0A\\x0B\\x0C\\x0D\\x1B\"},\n\t\t\twant: \"\\fhello world\\x07\\x08\\x09\\x0A\\x0B\\x0C\\x0D\\x1B\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline with control characters\",\n\t\t\targs: args{s: \"\\\\nhello world\\x07\\x08\\x09\\x0A\\x0B\\x0C\\x0D\\x1B\"},\n\t\t\twant: \"\\nhello world\\x07\\x08\\x09\\x0A\\x0B\\x0C\\x0D\\x1B\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return with control characters\",\n\t\t\targs: args{s: \"\\\\rhello world\\x07\\x08\\x09\\x0A\\x0B\\x0C\\x0D\\x1B\"},\n\t\t\twant: \"\\rhello world\\x07\\x08\\x09\\x0A\\x0B\\x0C\\x0D\\x1B\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab with control characters\",\n\t\t\targs: args{s: \"\\\\thello world\\x07\\x08\\x09\\x0A\\x0B\\x0C\\x0D\\x1B\"},\n\t\t\twant: \"\\thello world\\x07\\x08\\x09\\x0A\\x0B\\x0C\\x0D\\x1B\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with control characters\",\n\t\t\targs: args{s: \"\\\\u0061hello world\\x07\\x08\\x09\\x0A\\x0B\\x0C\\x0D\\x1B\"},\n\t\t\twant: \"ahello world\\x07\\x08\\x09\\x0A\\x0B\\x0C\\x0D\\x1B\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with control characters\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01hello world\\x07\\x08\\x09\\x0A\\x0B\\x0C\\x0D\\x1B\"},\n\t\t\twant: \"üòÅhello world\\x07\\x08\\x09\\x0A\\x0B\\x0C\\x0D\\x1B\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_EscapeSequenceWithEscapedControlCharacters(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"escaped quote with escaped control characters\",\n\t\t\targs: args{s: \"\\\\\\\"hello world\\\\x07\\\\x08\\\\x09\\\\x0A\\\\x0B\\\\x0C\\\\x0D\\\\x1B\"},\n\t\t\twant: \"\\\"hello world\\x07\\x08\\x09\\x0A\\x0B\\x0C\\x0D\\x1B\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslash with escaped control characters\",\n\t\t\targs: args{s: \"\\\\\\\\hello world\\\\x07\\\\x08\\\\x09\\\\x0A\\\\x0B\\\\x0C\\\\x0D\\\\x1B\"},\n\t\t\twant: \"\\\\hello world\\x07\\x08\\x09\\x0A\\x0B\\x0C\\x0D\\x1B\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slash with escaped control characters\",\n\t\t\targs: args{s: \"\\\\/hello world\\\\x07\\\\x08\\\\x09\\\\x0A\\\\x0B\\\\x0C\\\\x0D\\\\x1B\"},\n\t\t\twant: \"/hello world\\x07\\x08\\x09\\x0A\\x0B\\x0C\\x0D\\x1B\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace with escaped control characters\",\n\t\t\targs: args{s: \"\\\\bhello world\\\\x07\\\\x08\\\\x09\\\\x0A\\\\x0B\\\\x0C\\\\x0D\\\\x1B\"},\n\t\t\twant: \"\\bhello world\\x07\\x08\\x09\\x0A\\x0B\\x0C\\x0D\\x1B\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed with escaped control characters\",\n\t\t\targs: args{s: \"\\\\fhello world\\\\x07\\\\x08\\\\x09\\\\x0A\\\\x0B\\\\x0C\\\\x0D\\\\x1B\"},\n\t\t\twant: \"\\fhello world\\x07\\x08\\x09\\x0A\\x0B\\x0C\\x0D\\x1B\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline with escaped control characters\",\n\t\t\targs: args{s: \"\\\\nhello world\\\\x07\\\\x08\\\\x09\\\\x0A\\\\x0B\\\\x0C\\\\x0D\\\\x1B\"},\n\t\t\twant: \"\\nhello world\\x07\\x08\\x09\\x0A\\x0B\\x0C\\x0D\\x1B\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return with escaped control characters\",\n\t\t\targs: args{s: \"\\\\rhello world\\\\x07\\\\x08\\\\x09\\\\x0A\\\\x0B\\\\x0C\\\\x0D\\\\x1B\"},\n\t\t\twant: \"\\rhello world\\x07\\x08\\x09\\x0A\\x0B\\x0C\\x0D\\x1B\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab with escaped control characters\",\n\t\t\targs: args{s: \"\\\\thello world\\\\x07\\\\x08\\\\x09\\\\x0A\\\\x0B\\\\x0C\\\\x0D\\\\x1B\"},\n\t\t\twant: \"\\thello world\\x07\\x08\\x09\\x0A\\x0B\\x0C\\x0D\\x1B\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with escaped control characters\",\n\t\t\targs: args{s: \"\\\\u0061hello world\\\\x07\\\\x08\\\\x09\\\\x0A\\\\x0B\\\\x0C\\\\x0D\\\\x1B\"},\n\t\t\twant: \"ahello world\\x07\\x08\\x09\\x0A\\x0B\\x0C\\x0D\\x1B\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with escaped control characters\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01hello world\\\\x07\\\\x08\\\\x09\\\\x0A\\\\x0B\\\\x0C\\\\x0D\\\\x1B\"},\n\t\t\twant: \"üòÅhello world\\x07\\x08\\x09\\x0A\\x0B\\x0C\\x0D\\x1B\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_EscapeSequenceWithEscapedSpecialCharacters(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"escaped quote with escaped special characters\",\n\t\t\targs: args{s: \"\\\\\\\"hello world\\\\!\\\\@\\\\#\\\\$\\\\%\\\\^\\\\\u0026\\\\*\\\\(\\\\)\\\\_\\\\+\\\\-\\\\=\\\\{\\\\}\\\\\\\\\\\\[\\\\\\\\\\\\]\\\\|\\\\:\\\\;\\\\'\\\\\u003c\\\\\u003e\\\\.\\\\,\\\\?\\\\/\"},\n\t\t\twant: \"\\\"hello world!@#$%^\u0026*()_+-={}[]|\\\\:;'\u003c\u003e,.?/\"},\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslash with escaped special characters\",\n\t\t\targs: args{s: \"\\\\\\\\hello world\\\\!\\\\@\\\\#\\\\$\\\\%\\\\^\\\\\u0026\\\\*\\\\(\\\\)\\\\_\\\\+\\\\-\\\\=\\\\{\\\\}\\\\\\\\\\\\[\\\\\\\\\\\\]\\\\|\\\\",
    "e3f590dbf2ba58be97e9c05ed05fbb1a": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestType_String(t *testing.T) {\n\ttype args struct {\n\t\tt Type\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"TestType_String_Object\",\n\t\t\targs: args{t: TypeObject},\n\t\t\twant: \"object\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_Array\",\n\t\t\targs: args{t: TypeArray},\n\t\t\twant: \"array\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_String\",\n\t\t\targs: args{t: TypeString},\n\t\t\twant: \"string\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_Number\",\n\t\t\targs: args{t: TypeNumber},\n\t\t\twant: \"number\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_True\",\n\t\t\targs: args{t: TypeTrue},\n\t\t\twant: \"true\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_False\",\n\t\t\targs: args{t: TypeFalse},\n\t\t\twant: \"false\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_Null\",\n\t\t\targs: args{t: TypeNull},\n\t\t\twant: \"null\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.t.String(); got != tt.want {\n\t\t\t\tt.Errorf(\"Type.String() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e51e94608dd11bf35b4e80233aad4416": "package fastjson\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\tv   *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNull},\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeTrue},\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeFalse},\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeString, s: \"hello\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t},\n\t\t\twant: []byte(\"123\"),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeArray, a: []*Value{{t: TypeString, s: \"hello\"}, {t: TypeNumber, s: \"123\"}}},\n\t\t\t},\n\t\t\twant: []byte(\"[\\\"hello\\\",123]\"),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}}, {k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}}}}},\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":\"value1\",\"key2\":123}`),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.v.MarshalTo(tt.args.dst); !bytes.Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e5485be886fbf998b404fd9392355eb6": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetFloat64(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.GetFloat64(tt.args.keys...); got != tt.want {\n\t\t\t\tt.Errorf(\"Value.GetFloat64() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e5859f88ecff2e15e312b6c54fde32c3": "package fastjson\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\tv   *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"RawString\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: typeRawString, s: \"hello world\"},\n\t\t\t},\n\t\t\twant: []byte(`\"hello world\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"Object\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}}, {k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}}}},\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":\"value1\",\"key2\":123}`),\n\t\t},\n\t\t{\n\t\t\tname: \"Array\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeArray, a: []*Value{{t: TypeString, s: \"value1\"}, {t: TypeNumber, s: \"123\"}}},\n\t\t\t},\n\t\t\twant: []byte(`[\"value1\",123]`),\n\t\t},\n\t\t{\n\t\t\tname: \"String\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeString, s: \"hello world\"},\n\t\t\t},\n\t\t\twant: []byte(`\"hello world\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"Number\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t},\n\t\t\twant: []byte(`123`),\n\t\t},\n\t\t{\n\t\t\tname: \"True\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeTrue},\n\t\t\t},\n\t\t\twant: []byte(`true`),\n\t\t},\n\t\t{\n\t\t\tname: \"False\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeFalse},\n\t\t\t},\n\t\t\twant: []byte(`false`),\n\t\t},\n\t\t{\n\t\t\tname: \"Null\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNull},\n\t\t\t},\n\t\t\twant: []byte(`null`),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.v.MarshalTo(tt.args.dst); !bytes.Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e59539ec2cf73eea40662f8b045e72c5": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObjectVisit(t *testing.T) {\n\ttype args struct {\n\t\to *Object\n\t\tf func(key []byte, v *Value)\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\ttt.args.o.Visit(tt.args.f)\n\t\t})\n\t}\n}",
    "e68dfded8d2b26a44da71ff5e78c83dd": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"empty string\",\n\t\t\targs:    args{s: \"\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"single digit\",\n\t\t\targs:    args{s: \"1\"},\n\t\t\twantNs:  \"1\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"multiple digits\",\n\t\t\targs:    args{s: \"123\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"negative number\",\n\t\t\targs:    args{s: \"-123\"},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"decimal number\",\n\t\t\targs:    args{s: \"123.456\"},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"exponential number\",\n\t\t\targs:    args{s: \"1.23e+4\"},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"exponential number with negative exponent\",\n\t\t\targs:    args{s: \"1.23e-4\"},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"inf\",\n\t\t\targs:    args{s: \"inf\"},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"INF\",\n\t\t\targs:    args{s: \"INF\"},\n\t\t\twantNs:  \"INF\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"nan\",\n\t\t\targs:    args{s: \"nan\"},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"NAN\",\n\t\t\targs:    args{s: \"NAN\"},\n\t\t\twantNs:  \"NAN\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading whitespace\",\n\t\t\targs:    args{s: \" 123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" 123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with trailing whitespace\",\n\t\t\targs:    args{s: \"123 \"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \" \",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading and trailing whitespace\",\n\t\t\targs:    args{s: \" 123 \"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \" \",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with invalid character\",\n\t\t\targs:    args{s: \"123a\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with invalid character at the beginning\",\n\t\t\targs:    args{s: \"a123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"a123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with invalid character at the beginning 2\",\n\t\t\targs:    args{s: \"+123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with invalid character at the beginning 3\",\n\t\t\targs:    args{s: \"-123a\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"-123a\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with invalid character at the beginning 4\",\n\t\t\targs:    args{s: \"-a123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"-a123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with invalid character at the beginning 5\",\n\t\t\targs:    args{s: \"+a123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+a123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with invalid character at the beginning 6\",\n\t\t\targs:    args{s: \"123+a\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with invalid character at the beginning 7\",\n\t\t\targs:    args{s: \"123-a\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with invalid character at the beginning 8\",\n\t\t\targs:    args{s: \"123+123\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+123\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with invalid character at the beginning 9\",\n\t\t\targs:    args{s: \"123-123\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-123\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with invalid character at the beginning 10\",\n\t\t\targs:    args{s: \"123-\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with invalid character at the beginning 11\",\n\t\t\targs:    args{s: \"123+\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with invalid character at the beginning 12\",\n\t\t\targs:    args{s: \"123e\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"e\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with invalid character at the beginning 13\",\n\t\t\targs:    args{s: \"123E\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"E\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with invalid character at the beginning 14\",\n\t\t\targs:    args{s: \"123.\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \".\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with invalid character at the beginning 15\",\n\t\t\targs:    args{s: \"123-inf\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-inf\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with invalid character at the beginning 16\",\n\t\t\targs:    args{s: \"123-nan\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-nan\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with invalid character at the beginning 17\",\n\t\t\targs:    args{s: \"123+inf\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+inf\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with invalid character at the beginning 18\",\n\t\t\targs:    args{s: \"123+nan\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+nan\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with invalid character at the beginning 19\",\n\t\t\targs:    args{s: \"123-INF\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-INF\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with invalid character at the beginning 20\",\n\t\t\targs:    args{s: \"123-NAN\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-NAN\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with invalid character at the beginning 21\",\n\t\t\targs:    args{s: \"123+INF\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+INF\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with invalid character at the beginning 22\",\n\t\t\targs:    args{s: \"123+NAN\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+NAN\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with invalid character at the beginning 23\",\n\t\t\targs:    args{s: \"123-in\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-in\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with invalid character at the beginning 24\",\n\t\t\targs:    args{s: \"123-na\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-na\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with invalid character at the beginning 25\",\n\t\t\targs:    args{s: \"123+in\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+in\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with invalid character at the beginning 26\",\n\t\t\targs:    args{s: \"123+na\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+na\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e6b2976f720156be6211fd77b2f75c07": "package fastjson\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\tv   *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"marshal string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeString, s: \"hello\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal number\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t},\n\t\t\twant: []byte(\"123\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal true\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeTrue},\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal false\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeFalse},\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal null\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNull},\n\t\t\t},\n\t\t\twant: []byte{},\n\t\t},\n\t\t{\n\t\t\tname: \"marshal object\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":\"value1\",\"key2\":123}`),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal array\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{t: TypeString, s: \"value1\"},\n\t\t\t\t\t\t{t: TypeNumber, s: \"123\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`[\"value1\",123]`),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal raw string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: typeRawString, s: \"hello\"},\n\t\t\t},\n\t\t\twant: []byte(`\"hello\"`),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.v.MarshalTo(tt.args.dst); !bytes.Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e6cb490bb2c0d83ed347c3d9f08ba14a": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWS(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no whitespace\",\n\t\t\targs: args{s: \"abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace\",\n\t\t\targs: args{s: \"  abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailing whitespace\",\n\t\t\targs: args{s: \"abc  \"},\n\t\t\twant: \"abc  \",\n\t\t},\n\t\t{\n\t\t\tname: \"leading and trailing whitespace\",\n\t\t\targs: args{s: \"  abc  \"},\n\t\t\twant: \"abc  \",\n\t\t},\n\t\t{\n\t\t\tname: \"internal whitespace\",\n\t\t\targs: args{s: \"a bc\"},\n\t\t\twant: \"a bc\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple whitespace\",\n\t\t\targs: args{s: \"  a  b  c  \"},\n\t\t\twant: \"a  b  c  \",\n\t\t},\n\t\t{\n\t\t\tname: \"special characters\",\n\t\t\targs: args{s: \"  a\\t\\nb\\rc  \"},\n\t\t\twant: \"a\\t\\nb\\rc  \",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWS(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWS() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e7400b10fb6d7115b93dba7c2dfd9129": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u006\"},\n\t\t\twant: \"\\\\u0061\\\\u006\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\\\\\ \\\\/\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\"hello\\\" \\\\world\\\\ /\\\\b\\\\f\\\\n\\\\r\\tabcüòÅ\\\\xhello\\\\x world\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e74702fd6fc7d1ac731ed0c5591cd278": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e7490200a8c15ff50bab2c7d5fde9cac": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escaped strings\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"test\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\\\\\\\"test\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: ``,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with no quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `hello`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e783a3e5d0076d408007be0cbdc07566": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObjectReset(t *testing.T) {\n\ttype args struct {\n\t\to *Object\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant *Object\n\t}{\n\t\t{\n\t\t\tname: \"Empty object\",\n\t\t\targs: args{\n\t\t\t\to: \u0026Object{},\n\t\t\t},\n\t\t\twant: \u0026Object{\n\t\t\t\tkvs:           nil,\n\t\t\t\tkeysUnescaped: false,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"Object with kvs\",\n\t\t\targs: args{\n\t\t\t\to: \u0026Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: true,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: \u0026Object{\n\t\t\t\tkvs:           nil,\n\t\t\t\tkeysUnescaped: false,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\ttt.args.o.reset()\n\t\t\tif !reflect.DeepEqual(tt.args.o, tt.want) {\n\t\t\t\tt.Errorf(\"Object.reset() = %v, want %v\", tt.args.o, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e7853b1995be2a7e0f2c932045cca477": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth + 1,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"{}\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{ \\\"key\\\": \\\"value\\\" }\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[ \\\"value1\\\", \\\"value2\\\" ]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\\\"value\\\"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"value\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   \"true\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueTrue,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   \"false\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueFalse,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   \"null\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueNull,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   \"123\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   \"NaN\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected value\",\n\t\t\targs: args{\n\t\t\t\ts:   \"invalid\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"invalid\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseValue() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseValue_JSON(t *testing.T) {\n\ttype testCase struct {\n\t\tinput string\n\t\twant  interface{}\n\t}\n\ttestCases := []testCase{\n\t\t{\n\t\t\tinput: `{\"key\": \"value\"}`,\n\t\t\twant:  map[string]interface{}{\"key\": \"value\"},\n\t\t},\n\t\t{\n\t\t\tinput: `[1, 2, 3]`,\n\t\t\twant:  []interface{}{1, 2, 3},\n\t\t},\n\t\t{\n\t\t\tinput: `\"string\"`,\n\t\t\twant:  \"string\",\n\t\t},\n\t\t{\n\t\t\tinput: `true`,\n\t\t\twant:  true,\n\t\t},\n\t\t{\n\t\t\tinput: `false`,\n\t\t\twant:  false,\n\t\t},\n\t\t{\n\t\t\tinput: `null`,\n\t\t\twant:  nil,\n\t\t},\n\t\t{\n\t\t\tinput: `123`,\n\t\t\twant:  123,\n\t\t},\n\t\t{\n\t\t\tinput: `123.456`,\n\t\t\twant:  123.456,\n\t\t},\n\t\t{\n\t\t\tinput: `-123`,\n\t\t\twant:  -123,\n\t\t},\n\t\t{\n\t\t\tinput: `-123.456`,\n\t\t\twant:  -123.456,\n\t\t},\n\t\t{\n\t\t\tinput: `1.23e+4`,\n\t\t\twant:  1.23e+4,\n\t\t},\n\t\t{\n\t\t\tinput: `1.23e-4`,\n\t\t\twant:  1.23e-4,\n\t\t},\n\t\t{\n\t\t\tinput: `NaN`,\n\t\t\twant:  json.Number(\"NaN\"),\n\t\t},\n\t\t{\n\t\t\tinput: `Infinity`,\n\t\t\twant:  json.Number(\"Infinity\"),\n\t\t},\n\t\t{\n\t\t\tinput: `-Infinity`,\n\t\t\twant:  json.Number(\"-Infinity\"),\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.input, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tv, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"parseValue() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgot, err := v.MarshalJSON()\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"v.MarshalJSON() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\twant, err := json.Marshal(tc.want)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"json.Marshal(tc.want) error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !bytes.Equal(got, want) {\n\t\t\t\tt.Errorf(\"parseValue() got = %s, want %s\", got, want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e83bb0b3a53e8c49660f6e11d35138f1": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_with_json_marshal(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    \"{}\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `{\"key1\":\"value1\",\"key2\":\"value2\"}`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `{\"key1\":{\"nestedKey1\":\"nestedValue1\"},\"key2\":\"value2\"}`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `{\"key\\\"1\":\"value1\"}`,\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgotBytes, err := json.Marshal(got)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"json.Marshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif string(gotBytes) != tt.want {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", string(gotBytes), tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e897c35ec322a812216cfd3f5ff03ffd": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetInt(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant int\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.GetInt(tt.args.keys...); got != tt.want {\n\t\t\t\tt.Errorf(\"Value.GetInt() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "ea1af124e3f14fce95ff74dac77cb87e": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_getKV(t *testing.T) {\n\ttype args struct {\n\t\to *Object\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant *kv\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.o.getKV(); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Object.getKV() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "eb071f816583aa7cfc1e96a4582d81f2": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"single digit\",\n\t\t\targs: args{\n\t\t\t\ts: \"1\",\n\t\t\t},\n\t\t\twantNs:  \"1\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple digits\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative number\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"decimal number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential number\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential number with negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e-4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"inf\",\n\t\t\t},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"INF\",\n\t\t\targs: args{\n\t\t\t\ts: \"INF\",\n\t\t\t},\n\t\t\twantNs:  \"INF\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"nan\",\n\t\t\t},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NAN\",\n\t\t\targs: args{\n\t\t\t\ts: \"NAN\",\n\t\t\t},\n\t\t\twantNs:  \"NAN\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123a\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and trailing plus sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123+\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and trailing minus sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123-\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}",
    "eb0bed6b248796ac2aa5e59b1e4f4066": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestString(t *testing.T) {\n\ttype args struct {\n\t\tt Type\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"TestString_Object\",\n\t\t\targs: args{t: TypeObject},\n\t\t\twant: \"object\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestString_Array\",\n\t\t\targs: args{t: TypeArray},\n\t\t\twant: \"array\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestString_String\",\n\t\t\targs: args{t: TypeString},\n\t\t\twant: \"string\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestString_Number\",\n\t\t\targs: args{t: TypeNumber},\n\t\t\twant: \"number\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestString_True\",\n\t\t\targs: args{t: TypeTrue},\n\t\t\twant: \"true\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestString_False\",\n\t\t\targs: args{t: TypeFalse},\n\t\t\twant: \"false\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestString_Null\",\n\t\t\targs: args{t: TypeNull},\n\t\t\twant: \"null\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.t.String(); got != tt.want {\n\t\t\t\tt.Errorf(\"String() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "eb2f7a09786ed520e3c0026730fb8e56": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\tv   *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"test raw string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: typeRawString, s: \"test\"},\n\t\t\t},\n\t\t\twant: []byte(`\"test\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"test object\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{t: TypeString, s: \"value\"}}}}},\n\t\t\t},\n\t\t\twant: []byte(`{\"key\":\"value\"}`),\n\t\t},\n\t\t{\n\t\t\tname: \"test array\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeArray, a: []*Value{{t: TypeString, s: \"value1\"}, {t: TypeString, s: \"value2\"}}},\n\t\t\t},\n\t\t\twant: []byte(`[\"value1\",\"value2\"]`),\n\t\t},\n\t\t{\n\t\t\tname: \"test string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeString, s: \"test\"},\n\t\t\t},\n\t\t\twant: []byte(`\"test\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"test number\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t},\n\t\t\twant: []byte(`123`),\n\t\t},\n\t\t{\n\t\t\tname: \"test true\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeTrue},\n\t\t\t},\n\t\t\twant: []byte(`true`),\n\t\t},\n\t\t{\n\t\t\tname: \"test false\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeFalse},\n\t\t\t},\n\t\t\twant: []byte(`false`),\n\t\t},\n\t\t{\n\t\t\tname: \"test null\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNull},\n\t\t\t},\n\t\t\twant: []byte(`null`),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.v.MarshalTo(tt.args.dst); !bytesEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc bytesEqual(a, b []byte) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "eb885289b7d2fd99a584dd8528e7a597": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quotes and other characters\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"\\\\\\\\\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\\\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with extra closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   `\"\"`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote at the beginning\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\\\\\"hello\"`,\n\t\t\t},\n\t\t\twant:    `\"hello`,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote at the end\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote in the middle\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by another quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   `\"`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by a backslash\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\\\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote followed by a backslash and a quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "ebf2cbcce69e6375a3f5bae521ef8b70": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"simple integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"float\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential notation\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential notation with negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e-4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"inf\",\n\t\t\t},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"Inf\",\n\t\t\t},\n\t\t\twantNs:  \"Inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inF\",\n\t\t\targs: args{\n\t\t\t\ts: \"inF\",\n\t\t\t},\n\t\t\twantNs:  \"inF\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"nan\",\n\t\t\t},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twantNs:  \"NaN\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nAn\",\n\t\t\targs: args{\n\t\t\t\ts: \"nAn\",\n\t\t\t},\n\t\t\twantNs:  \"nAn\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char\",\n\t\t\targs: args{\n\t\t\t\ts: \"123a\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning\",\n\t\t\targs: args{\n\t\t\t\ts: \"a123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"a123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char after sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"-a123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"-a123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char after sign 2\",\n\t\t\targs: args{\n\t\t\t\ts: \"+a123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+a123\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}",
    "ebf877e63e90ebbf0504c5ddb8afea58": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   \"null\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueNull,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   \"true\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueTrue,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   \"false\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueFalse,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"hello\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt:  typeRawString,\n\t\t\t\ts:  \"hello\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   \"123\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt:  TypeNumber,\n\t\t\t\ts:  \"123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\": \"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt:  typeRawString,\n\t\t\t\t\t\t\t\ts:  \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"value1\", \"value2\"]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt:  typeRawString,\n\t\t\t\t\t\ts:  \"value1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt:  typeRawString,\n\t\t\t\t\t\ts:  \"value2\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": {\"key2\": \"value\"}}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt:  typeRawString,\n\t\t\t\t\t\t\t\t\t\t\t\ts:  \"value\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": [\"value1\", \"value2\"]}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tt:  typeRawString,\n\t\t\t\t\t\t\t\t\t\ts:  \"value1\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tt:  typeRawString,\n\t\t\t\t\t\t\t\t\t\ts:  \"value2\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": {\"key2\": \"value\"}}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": {\"key2\": \"value\"}}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid json\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   `NaN`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt:  TypeNumber,\n\t\t\t\ts:  \"NaN\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseValue() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseValue_Marshal(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   \"null\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    \"null\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   \"true\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    \"true\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   \"false\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    \"false\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"hello\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `\"hello\"`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   \"123\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    \"123\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\": \"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `{\"key\":\"value\"}`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"value1\", \"value2\"]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `[\"value1\",\"value2\"]`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": {\"key2\": \"value\"}}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `{\"key1\":{\"key2\":\"value\"}}`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": [\"value1\", \"value2\"]}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `{\"key1\":[\"value1\",\"value2\"]}`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   `NaN`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `NaN`,\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tb, err := json.Marshal(got)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"json.Marshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif string(b) != tt.want {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", string(b), tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "ec026c231b0d836d21a262081a7a59a0": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetObject(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant *Object\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.GetObject(tt.args.keys...); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"GetObject() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "ecb9681ec50f26f5fdb26414aabd3121": "package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u world\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u world\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\\\\\ \\\\/test\\\\/ \\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"\\\"hello\\\" \\\\world\\\\ /test/ \\b\\f\\n\\r\\tabcüòÅ\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "ed2bbe5d8b0addacee0007eb6c33fdd0": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestType_String(t *testing.T) {\n\ttype args struct {\n\t\tt Type\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"TestType_String_Object\",\n\t\t\targs: args{t: TypeObject},\n\t\t\twant: \"object\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_Array\",\n\t\t\targs: args{t: TypeArray},\n\t\t\twant: \"array\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_String\",\n\t\t\targs: args{t: TypeString},\n\t\t\twant: \"string\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_Number\",\n\t\t\targs: args{t: TypeNumber},\n\t\t\twant: \"number\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_True\",\n\t\t\targs: args{t: TypeTrue},\n\t\t\twant: \"true\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_False\",\n\t\t\targs: args{t: TypeFalse},\n\t\t\twant: \"false\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_Null\",\n\t\t\targs: args{t: TypeNull},\n\t\t\twant: \"null\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.t.String(); got != tt.want {\n\t\t\t\tt.Errorf(\"Type.String() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "ed60335579948b7d973b557c9487f30f": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueUint64(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    uint64\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"valid uint64\",\n\t\t\targs: args{\n\t\t\t\ts: \"1234567890\",\n\t\t\t},\n\t\t\twant:    1234567890,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"valid uint64 with decimal\",\n\t\t\targs: args{\n\t\t\t\ts: \"1234567890.0\",\n\t\t\t},\n\t\t\twant:    1234567890,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid uint64\",\n\t\t\targs: args{\n\t\t\t\ts: \"1234567890.1\",\n\t\t\t},\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid uint64 with exponent\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23456789e+10\",\n\t\t\t},\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid uint64 with negative sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"-1234567890\",\n\t\t\t},\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid uint64 with string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"1234567890\\\"\",\n\t\t\t},\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv := \u0026Value{\n\t\t\t\ts: tt.args.s,\n\t\t\t\tt: TypeNumber,\n\t\t\t}\n\t\t\tgot, err := v.Uint64()\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Value.Uint64() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Value.Uint64() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "ed7f1f9db9ebf8c730e6dec6ab9e2901": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts: \"null\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts: \"true\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts: \"false\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello\\\"\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts: \"[1,2,3]\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts: `{\"key1\": \"value1\", \"key2\": 2}`,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested object\",\n\t\t\targs: args{\n\t\t\t\ts: `{\"key1\": {\"key2\": \"value2\"}}`,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts: `{\"key1\": [1, 2, 3]}`,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tp := \u0026Parser{}\n\t\t\tgot, err := p.Parse(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Parse() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr \u0026\u0026 !compareValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"Parse() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeNull:\n\t\treturn true\n\tcase TypeTrue:\n\t\treturn true\n\tcase TypeFalse:\n\t\treturn true\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !compareValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !compareValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc TestParse_InvalidJSON(t *testing.T) {\n\ttests := []string{\n\t\t\"{\",\n\t\t\"}\",\n\t\t\"[\",\n\t\t\"]\",\n\t\t\"1,\",\n\t\t\",2\",\n\t\t`\"hello`,\n\t\t`hello\"`,\n\t\t`{\"key1\": \"value1\", \"key2\": 2`,\n\t\t`{\"key1\": \"value1\", \"key2\": 2}`,\n\t}\n\tfor _, s := range tests {\n\t\tt.Run(fmt.Sprintf(\"invalid json: %s\", s), func(t *testing.T) {\n\t\t\tp := \u0026Parser{}\n\t\t\t_, err := p.Parse(s)\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"Parse(%s) should have returned an error\", s)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParse_CompareWithStdlib(t *testing.T) {\n\ttests := []string{\n\t\t`null`,\n\t\t`true`,\n\t\t`false`,\n\t\t`123`,\n\t\t`\"hello\"`,\n\t\t`[1,2,3]`,\n\t\t`{\"key1\": \"value1\", \"key2\": 2}`,\n\t\t`{\"key1\": {\"key2\": \"value2\"}}`,\n\t\t`{\"key1\": [1, 2, 3]}`,\n\t}\n\tfor _, s := range tests {\n\t\tt.Run(fmt.Sprintf(\"json: %s\", s), func(t *testing.T) {\n\t\t\tp := \u0026Parser{}\n\t\t\tgot, err := p.Parse(s)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Parse(%s) error = %v\", s, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tvar want interface{}\n\t\t\tif err := json.Unmarshal([]byte(s), \u0026want); err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal(%s) error = %v\", s, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !compareValuesWithStdlib(got, want) {\n\t\t\t\tt.Errorf(\"Parse(%s) = %v, want %v\", s, got, want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValuesWithStdlib(v *Value, want interface{}) bool {\n\tswitch want := want.(type) {\n\tcase nil:\n\t\treturn v.t == TypeNull\n\tcase bool:\n\t\tif want {\n\t\t\treturn v.t == TypeTrue\n\t\t} else {\n\t\t\treturn v.t == TypeFalse\n\t\t}\n\tcase float64:\n\t\treturn v.t == TypeNumber \u0026\u0026 v.s == fmt.Sprintf(\"%f\", want)\n\tcase string:\n\t\treturn v.t == TypeString \u0026\u0026 v.s == want\n\tcase []interface{}:\n\t\tif v.t != TypeArray || len(v.a) != len(want) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v.a {\n\t\t\tif !compareValuesWithStdlib(v.a[i], want[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase map[string]interface{}:\n\t\tif v.t != TypeObject || len(v.o.kvs) != len(want) {\n\t\t\treturn false\n\t\t}\n\t\tfor k, w := range want {\n\t\t\tfor _, kv := range v.o.kvs {\n\t\t\t\tif kv.k == k {\n\t\t\t\t\tif !compareValuesWithStdlib(kv.v, w) {\n\t\t\t\t\t\treturn false\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}",
    "edc73e729f5fb16c77ddb02f2d62c7f4": "package fastjson\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\tv   *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"marshal string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeString, s: \"hello\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal number\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t},\n\t\t\twant: []byte(\"123\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal true\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeTrue},\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal false\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeFalse},\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal null\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNull},\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal object\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":\"value1\",\"key2\":123}`),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal array\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{t: TypeString, s: \"value1\"},\n\t\t\t\t\t\t{t: TypeNumber, s: \"123\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`[\"value1\",123]`),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.v.MarshalTo(tt.args.dst); !bytes.Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "ee281fd673e0e5921d985e16d66274ec": "```go\npackage fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n",
    "efa4903c7248777618b60131d2acc577": "package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u006\"},\n\t\t\twant: \"\\\\u0061\\\\u006\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\\\\\ \\\\/\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\x\\\\u006\"},\n\t\t\twant: \"\\\"hello\\\" \\\\world\\\\ /\\\\b\\\\f\\\\n\\\\r\\\\tabcüòÅ\\\\x\\\\u006\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f05845715af1ed66ea29327c8a4a23ec": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCacheGetValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\t// Test case 1: Empty cache\n\tv1 := c.getValue()\n\tif len(c.vs) != 1 {\n\t\tt.Errorf(\"Expected cache to have 1 element, got %d\", len(c.vs))\n\t}\n\tif v1 != \u0026c.vs[0] {\n\t\tt.Errorf(\"Expected getValue to return the first element of the cache, got %p\", v1)\n\t}\n\n\t// Test case 2: Non-empty cache\n\tv2 := c.getValue()\n\tif len(c.vs) != 2 {\n\t\tt.Errorf(\"Expected cache to have 2 elements, got %d\", len(c.vs))\n\t}\n\tif v2 != \u0026c.vs[1] {\n\t\tt.Errorf(\"Expected getValue to return the second element of the cache, got %p\", v2)\n\t}\n}\n",
    "f0667afc84cf5da4eedaac8df46a195b": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_JSON(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_JSON_Compare(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tvar want map[string]interface{}\n\t\t\tif err := json.Unmarshal([]byte(tt.args.s), \u0026want); err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got.o.kvs, want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got.o.kvs, want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f090bde8d09c3c16eb0203495d317a50": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_JSONUnmarshal(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_JSONUnmarshal_Compare(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t\tvar wantJSON map[string]interface{}\n\t\t\tif err := json.Unmarshal([]byte(tt.args.s), \u0026wantJSON); err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tvar gotJSON map[string]interface{}\n\t\t\tif err := json.Unmarshal(got.MarshalTo(nil), \u0026gotJSON); err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(gotJSON, wantJSON) {\n\t\t\t\tt.Errorf(\"parseObject() gotJSON = %v, wantJSON %v\", gotJSON, wantJSON)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f131920ae34d0848f01ae4cda57a1695": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_getKV(t *testing.T) {\n\ttype args struct {\n\t\to *Object\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant *kv\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.o.getKV(); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Object.getKV() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f1d4a580fbdf8c143281df8713dc7b06": "```go\npackage fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth + 1,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"{}\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\": \"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"value1\", \"value2\"]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"value\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"value\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   `true`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueTrue,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   `false`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueFalse,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   `null`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueNull,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with decimal\",\n\t\t\targs: args{\n\t\t\t\ts:   `123.456`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e+4`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e-4`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"1.23e-4\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `-123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zero\",\n\t\t\targs: args{\n\t\t\t\ts:   `0123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"0123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with trailing zero\",\n\t\t\targs: args{\n\t\t\t\ts:   `123.0`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123.0\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   `NaN`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with Infinity\",\n\t\t\targs: args{\n\t\t\t\ts:   `Infinity`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"Infinity\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative Infinity\",\n\t\t\targs: args{\n\t\t\t\ts:   `-Infinity`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-Infinity\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123.456.789`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123.456.789\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e+4.5`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e+4.5\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e-4.5`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e-4.5\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with negative sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `-123.456.789`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"-123.456.789\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading zero\",\n\t\t\targs: args{\n\t\t\t\ts:   `00123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"00123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing zero\",\n\t\t\targs: args{\n\t\t\t\ts:   `123.00`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123.00\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading dot\",\n\t\t\targs: args{\n\t\t\t\ts:   `.123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \".123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing dot\",\n\t\t\targs: args{\n\t\t\t\ts:   `123.`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123.\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with multiple dots\",\n\t\t\targs: args{\n\t\t\t\ts:   `123.456.789`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123.456.789\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with multiple exponents\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e+4e+5`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"1.23e+4e+5\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with multiple negative signs\",\n\t\t\targs: args{\n\t\t\t\ts:   `--123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"--123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `+123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"+123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing plus sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `123+`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123+\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading space\",\n\t\t\targs: args{\n\t\t\t\ts:   ` 123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \" 123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing space\",\n\t\t\targs: args{\n\t\t\t\ts:   `123 `,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123 \",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading comma\",\n\t\t\targs: args{\n\t\t\t\ts:   `,123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \",123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing comma\",\n\t\t\targs: args{\n\t\t\t\ts:   `123,`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123,\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading colon\",\n\t\t\targs: args{\n\t\t\t\ts:   `:123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \":123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing colon\",\n\t\t\targs: args{\n\t\t\t\ts:   `123:`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123:\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading bracket\",\n\t\t\targs: args{\n\t\t\t\ts:   `[123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:   `123]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123]\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading brace\",\n\t\t\targs: args{\n\t\t\t\ts:   `{123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"{123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing brace\",\n\t\t\targs: args{\n\t\t\t\ts:   `123}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123}\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading quote\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `\"123`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing quote\",\n\t\t\targs: args{\n\t\t\t\ts:   `123\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123\\\"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading slash\",\n\t\t\targs: args{\n\t\t\t\ts:   `/123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"/123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing slash\",\n\t\t\targs: args{\n\t\t\t\ts:   `123/`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123/\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading backslash\",\n\t\t\targs: args{\n\t\t\t\ts:   `\\123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `\\123`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing backslash\",\n\t\t\targs: args{\n\t\t\t\ts:   `123\\`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123\\\\\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading question mark\",\n\t\t\targs: args{\n\t\t\t\ts:   `?123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"?123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing question mark\",\n\t\t\targs: args{\n\t\t\t\ts:   `123?`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123?\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading exclamation mark\",\n\t\t\targs: args{\n\t\t\t\ts:   `!123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"!123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing exclamation mark\",\n\t\t\targs: args{\n\t\t\t\ts:   `123!`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123!\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading at sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `@123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"@123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing at sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `123@`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123@\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading hash sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `#123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"#123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing hash sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `123#`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123#\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading dollar sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `$123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"$123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing dollar sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `123$`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123$\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading percent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `%123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"%123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing percent sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `123%`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123%\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading caret sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `^123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"^123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing caret sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `123^`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123^\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading ampersand sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `\u0026123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\u0026123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing ampersand sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `123\u0026`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123\u0026\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading asterisk sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `*123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"*123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing asterisk sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `123*`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123*\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading parenthesis\",\n\t\t\targs: args{\n\t\t\t\ts:   `(123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"(123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing parenthesis\",\n\t\t\targs: args{\n\t\t\t\ts:   `123)`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123)\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading hyphen\",\n\t\t\targs: args{\n\t\t\t\ts:   `-123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"-123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing hyphen\",\n\t\t\targs: args{\n\t\t\t\ts:   `123-`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123-\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading underscore\",\n\t\t\targs: args{\n\t\t\t\ts:   `_123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"_123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing underscore\",\n\t\t\targs: args{\n\t\t\t\ts:   `123_`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123_\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `+123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"+123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing plus sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `123+`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123+\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading equal sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `=123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"=123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing equal sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `123=`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123=\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading less than sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `\u003c123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\u003c123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing less than sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `123\u003c`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123\u003c\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading greater than sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `\u003e123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\u003e123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing greater than sign\",\n\t\t\targs: args{\n\t\t\t\ts:   `123\u003e`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123\u003e\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading question mark\",\n\t\t\targs: args{\n\t\t\t\ts:   `?123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"?123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing question mark\",\n\t\t\targs: args{\n\t\t\t\ts:   `123?`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123?\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading slash\",\n\t\t\targs: args{\n\t\t\t\ts:   `/123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"/123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing slash\",\n\t\t\targs: args{\n\t\t\t\ts:   `123/`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123/\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading backslash\",\n\t\t\targs: args{\n\t\t\t\ts:   `\\123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `\\123`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing backslash\",\n\t\t\targs: args{\n\t\t\t\ts:   `123\\`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123\\\\\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading pipe\",\n\t\t\targs: args{\n\t\t\t\ts:   `|123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"|123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing pipe\",\n\t\t\targs: args{\n\t\t\t\ts:   `123|`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123|\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading semicolon\",\n\t\t\targs: args{\n\t\t\t\ts:   `;123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \";123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing semicolon\",\n\t\t\targs: args{\n\t\t\t\ts:   `123;`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123;\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading double quote\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `\"123`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing double quote\",\n\t\t\targs: args{\n\t\t\t\ts:   `123\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123\\\"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading single quote\",\n\t\t\targs: args{\n\t\t\t\ts:   `'123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"'123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing single quote\",\n\t\t\targs: args{\n\t\t\t\ts:   `123'`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123'\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading double quote\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `\"123`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing double quote\",\n\t\t\targs: args{\n\t\t\t\ts:   `123\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123\\\"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading single quote\",\n\t\t\targs: args{\n\t\t\t\ts:   `'123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"'123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing single quote\",\n\t\t\targs: args{\n\t\t\t\ts:   `123'`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123'\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading backtick\",\n\t\t\targs: args{\n\t\t\t\ts:   \"`123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"`123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing backtick\",\n\t\t\targs: args{\n\t\t\t\ts:   `123` + \"`\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123`\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading tilde\",\n\t\t\targs: args{\n\t\t\t\ts:   `~123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"~123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing tilde\",\n\t\t\targs: args{\n\t\t\t\ts:   `123~`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123~\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading curly brace\",\n\t\t\targs: args{\n\t\t\t\ts:   `{123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant",
    "f1fe434c7c5c4eee4f1b5f499d63ef52": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth + 1,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"{}\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\": \"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"value1\", \"value2\"]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"value\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"value\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   `true`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueTrue,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   `false`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueFalse,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   `null`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueNull,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative number\",\n\t\t\targs: args{\n\t\t\t\ts:   `-123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"decimal number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123.456`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential number\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e+4`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123.456.789`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"123.456.789\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid value\",\n\t\t\targs: args{\n\t\t\t\ts:   `invalid`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"invalid\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseValue() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseValue_JSON(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    interface{}\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts: `null`,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts: `true`,\n\t\t\t},\n\t\t\twant:    true,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts: `false`,\n\t\t\t},\n\t\t\twant:    false,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts: `123`,\n\t\t\t},\n\t\t\twant:    123,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"value\"`,\n\t\t\t},\n\t\t\twant:    \"value\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts: `{\"key\": \"value\"}`,\n\t\t\t},\n\t\t\twant:    map[string]interface{}{\"key\": \"value\"},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts: `[\"value1\", \"value2\"]`,\n\t\t\t},\n\t\t\twant:    []interface{}{\"value1\", \"value2\"},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, _, err := parseValue(tt.args.s, c, 0)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got.MarshalTo(nil), tt.want) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got.MarshalTo(nil), tt.want)\n\t\t\t}\n\t\t\tvar wantJSON []byte\n\t\t\twantJSON, err = json.Marshal(tt.want)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"json.Marshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got.MarshalTo(nil), wantJSON) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got.MarshalTo(nil), wantJSON)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseValue_Error(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"invalid object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid true\",\n\t\t\targs: args{\n\t\t\t\ts:   `tru`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid false\",\n\t\t\targs: args{\n\t\t\t\ts:   `fals`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid null\",\n\t\t\targs: args{\n\t\t\t\ts:   `nul`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123.`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123e`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t_, _, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t})\n\t}\n}",
    "f23543cc8a2f20450756636e16c7ac84": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_getKV(t *testing.T) {\n\ttype args struct {\n\t\to *Object\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant *kv\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.o.getKV(); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Object.getKV() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f42b808694ac056f3434ca48d3a97f42": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"key2\": \"value2\"}, \"key3\": \"value3\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{key1: \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{key1: \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid value\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": value1, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": value1, \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_JSON(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"key2\": \"value2\"}, \"key3\": \"value3\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != \"\" {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, \"\")\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_JSON_Compare(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"key2\": \"value2\"}, \"key3\": \"value3\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tvar want map[string]interface{}\n\t\t\tif err := json.Unmarshal([]byte(tt.args.s), \u0026want); err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got.o.ToMap(), want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got.o.ToMap(), want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f43be1abf4b1b32657a9009cca3aa5f7": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\"world\\\\\\\"\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quotes and other characters\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"\\\\\\\\\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\\\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped closing quote and other characters\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped closing quote and other characters\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"\\\\\\\\\\\\\"`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f4bcb92947eb553e92ce8b89aba331e3": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\ux\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\ux\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\ux\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\ux\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with incomplete hex\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\u\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\u\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestUnescapeStringBestEffort_JSON(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\"hello\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\ux\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\ux\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\ux\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\ux\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with incomplete hex\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\u\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\u\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t// Use json.Unmarshal to unescape the string\n\t\t\tvar got interface{}\n\t\t\tif err := json.Unmarshal([]byte(\"\\\"\" + tt.args.s + \"\\\"\"), \u0026got); err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\t// Convert the unmarshaled value back to a string\n\t\t\tgotStr, ok := got.(string)\n\t\t\tif !ok {\n\t\t\t\tt.Errorf(\"json.Unmarshal() returned unexpected type: %T\", got)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotStr != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", gotStr, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestUnescapeStringBestEffort_strconv(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\"hello\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\ux\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\ux\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\ux\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\ux\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with incomplete hex\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\u\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\u\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t// Use strconv.Unquote to unescape the string\n\t\t\tgot, err := strconv.Unquote(\"\\\"\" + tt.args.s + \"\\\"\")\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"strconv.Unquote() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestUnescapeStringBestEffort_utf16(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\ux\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\ux\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with incomplete hex\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\u\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\u\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t// Use utf16.DecodeRune to unescape the string\n\t\t\tvar got []rune\n\t\t\tfor i := 0; i \u003c len(tt.args.s); i += 6 {\n\t\t\t\tif i+6 \u003e len(tt.args.s) {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tx, err := strconv.ParseUint(tt.args.s[i+2:i+6], 16, 16)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"strconv.ParseUint() error = %v\", err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif i+12 \u003e len(tt.args.s) {\n\t\t\t\t\tgot = append(got, rune(x))\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tx1, err := strconv.ParseUint(tt.args.s[i+8:i+12], 16, 16)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"strconv.ParseUint() error = %v\", err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tr := utf16.DecodeRune(rune(x), rune(x1))\n\t\t\t\tgot = append(got, r)\n\t\t\t}\n\t\t\tif string(got) != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", string(got), tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f4ec22d1a5a18bc89b39a41074f20a98": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"simple integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"float number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential number\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative exponential number\",\n\t\t\targs: args{\n\t\t\t\ts: \"-1.23e-4\",\n\t\t\t},\n\t\t\twantNs:  \"-1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"inf\",\n\t\t\t},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"Inf\",\n\t\t\t},\n\t\t\twantNs:  \"Inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inF\",\n\t\t\targs: args{\n\t\t\t\ts: \"inF\",\n\t\t\t},\n\t\t\twantNs:  \"inF\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"nan\",\n\t\t\t},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"Nan\",\n\t\t\t},\n\t\t\twantNs:  \"Nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nAn\",\n\t\t\targs: args{\n\t\t\t\ts: \"nAn\",\n\t\t\t},\n\t\t\twantNs:  \"nAn\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123a\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"-inf\",\n\t\t\t},\n\t\t\twantNs:  \"-inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"-nan\",\n\t\t\t},\n\t\t\twantNs:  \"-nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus and inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus and nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f507afd9a2e710907103163f30938768": "package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u world\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u00zz\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u00zz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDEzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDEzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with incomplete hex\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f52a9ba437685c8435afc8b5272bb656": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetInt(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant int\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.GetInt(tt.args.keys...); got != tt.want {\n\t\t\t\tt.Errorf(\"Value.GetInt() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f583068e21b7ee06f424a489cd2eb93d": "```",
    "f59ee05c8531a20d9be7e8f6127935d7": "package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"üòÅ\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u006\"},\n\t\t\twant: \"\\\\u0061\\\\u006\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\\\\\ \\\\/test\\\\/ \\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\"hello\\\" \\\\world\\\\ /test/ \\b\\f\\n\\r\\t abcüòÅ\\\\xhello\\\\x world\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f5e0639406a7ac149ef59ce46b9fd877": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_getKV(t *testing.T) {\n\ttype args struct {\n\t\to *Object\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant *kv\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.o.getKV(); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Object.getKV() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f61bfa80baef78dd9ee3035bba841ed5": "```go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no whitespace\",\n\t\t\targs: args{s: \"abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace\",\n\t\t\targs: args{s: \"  abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailing whitespace\",\n\t\t\targs: args{s: \"abc  \"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading and trailing whitespace\",\n\t\t\targs: args{s: \"  abc  \"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"whitespace in the middle\",\n\t\t\targs: args{s: \"a bc\"},\n\t\t\twant: \"bc\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple whitespace\",\n\t\t\targs: args{s: \"  a  b  c  \"},\n\t\t\twant: \"a  b  c\",\n\t\t},\n\t\t{\n\t\t\tname: \"newline\",\n\t\t\targs: args{s: \"\\n abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"tab\",\n\t\t\targs: args{s: \"\\tabc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"carriage return\",\n\t\t\targs:",
    "f625b903fe1f87df3db897c6edb4f6ae": "package fastjson\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\tv   *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"marshal null\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNull},\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal true\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeTrue},\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal false\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeFalse},\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeString, s: \"hello\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal raw string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: typeRawString, s: \"hello\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal number\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t},\n\t\t\twant: []byte(\"123\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal array\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{t: TypeString, s: \"hello\"},\n\t\t\t\t\t\t{t: TypeNumber, s: \"123\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"[\\\"hello\\\",123]\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal object\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{k: \"name\", v: \u0026Value{t: TypeString, s: \"John Doe\"}},\n\t\t\t\t\t\t\t{k: \"age\", v: \u0026Value{t: TypeNumber, s: \"30\"}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`{\"name\":\"John Doe\",\"age\":30}`),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.v.MarshalTo(tt.args.dst); !bytes.Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f6f799d652f95548df1454b0da524481": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\"world\\\\\\\"\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quotes and other characters\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"\\\\\\\\\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\\\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped closing quote and other characters\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped closing quote and other characters 2\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"\\\\\\\\\\\\\"`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f7174365718278f6c246af3c02df800c": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts: \"null\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts: \"true\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts: \"false\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello\\\"\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts: \"[1,2,3]\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts: `{\"key1\": \"value1\", \"key2\": 2}`,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested object\",\n\t\t\targs: args{\n\t\t\t\ts: `{\"key1\": {\"key2\": \"value2\"}}`,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts: `{\"key1\": [1, 2, 3]}`,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tp := \u0026Parser{}\n\t\t\tgot, err := p.Parse(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Parse() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr \u0026\u0026 !compareValue(got, tt.want) {\n\t\t\t\tt.Errorf(\"Parse() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValue(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeNull:\n\t\treturn true\n\tcase TypeTrue:\n\t\treturn true\n\tcase TypeFalse:\n\t\treturn true\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !compareValue(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !compareValue(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}",
    "f7c57cc5d4987c63433126e4c45ef159": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no whitespace\",\n\t\t\targs: args{s: \"abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace\",\n\t\t\targs: args{s: \"  abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailing whitespace\",\n\t\t\targs: args{s: \"abc  \"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"whitespace in the middle\",\n\t\t\targs: args{s: \"a bc\"},\n\t\t\twant: \"bc\",\n\t\t},\n\t\t{\n\t\t\tname: \"all whitespace\",\n\t\t\targs: args{s: \"   \"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"mixed whitespace\",\n\t\t\targs: args{s: \" \\t\\n\\r abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading and trailing whitespace\",\n\t\t\targs: args{s: \" \\t\\n\\r abc \\t\\n\\r\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f8928951972e02af89edabbec7377750": "```go\npackage fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestValueInt(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"valid int\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant:    123,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"valid negative int\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twant:    -123,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"valid large int\",\n\t\t\targs: args{\n\t\t\t\ts: \"9223372036854775807\",\n\t\t\t},\n\t\t\twant:    9223372036854775807,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid int\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid int - string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"123\\\"\",\n\t\t\t},\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid int - bool\",\n\t\t\targs: args{\n\t\t\t\ts: \"true\",\n\t\t\t},\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid int - null\",\n\t\t\targs: args{\n\t\t\t\ts: \"null\",\n\t\t\t},\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tp := NewParser()\n\t\t\tv, err := p.Parse(tt.args.s)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Parse() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgot, err := v.Int()\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Int() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Int() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValueInt_LargeInt(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"valid large int\",\n\t\t\targs: args{\n\t\t\t\ts: \"9223372036854775807\",\n\t\t\t},\n\t\t\twant:    9223372036854775807,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid large int\",\n\t\t\targs: args{\n\t\t\t\ts: \"9223372036854775808\",\n\t\t\t},\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tp := NewParser()\n\t\t\tv, err := p.Parse(tt.args.s)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Parse() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgot, err := v.Int()\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Int() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Int() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValueInt_JSON(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"valid int\",\n\t\t\targs: args{\n\t\t\t\ts: `{\"a\": 123}`,\n\t\t\t},\n\t\t\twant:    123,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"valid negative int\",\n\t\t\targs: args{\n\t\t\t\ts: `{\"a\": -123}`,\n\t\t\t},\n\t\t\twant:    -123,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"valid large int\",\n\t\t\targs: args{\n\t\t\t\ts: `{\"a\": 9223372036854775807}`,\n\t\t\t},\n\t\t\twant:    9223372036854775807,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid int\",\n\t\t\targs: args{\n\t\t\t\ts: `{\"a\": 123.456}`,\n\t\t\t},\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid int - string\",\n\t\t\targs: args{\n\t\t\t\ts: `{\"a\": \"123\"}`,\n\t\t\t},\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid int - bool\",\n\t\t\targs: args{\n\t\t\t\ts: `{\"a\": true}`,\n\t\t\t},\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid int - null\",\n\t\t\targs: args{\n\t\t\t\ts: `{\"a\": null}`,\n\t\t\t},\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tp := NewParser()\n\t\t\tv, err := p.Parse(tt.args.s)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Parse() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\to, err := v.Object()\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Object() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tv, err = o.Get(\"a\")\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Get() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgot, err := v.Int()\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Int() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Int() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValueInt_JSON_Array(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"valid int\",\n\t\t\targs: args{\n\t\t\t\ts: `[123]`,\n\t\t\t},\n\t\t\twant:    123,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"valid negative int\",\n\t\t\targs: args{\n\t\t\t\ts: `[-123]`,\n\t\t\t},\n\t\t\twant:    -123,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"valid large int\",\n\t\t\targs: args{\n\t\t\t\ts: `[9223372036854775807]`,\n\t\t\t},\n\t\t\twant:    9223372036854775807,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid int\",\n\t\t\targs: args{\n\t\t\t\ts: `[123.456]`,\n\t\t\t},\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid int - string\",\n\t\t\targs: args{\n\t\t\t\ts: `[\"123\"]`,\n\t\t\t},\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid int - bool\",\n\t\t\targs: args{\n\t\t\t\ts: `[true]`,\n\t\t\t},\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid int - null\",\n\t\t\targs: args{\n\t\t\t\ts: `[null]`,\n\t\t\t},\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tp := NewParser()\n\t\t\tv, err := p.Parse(tt.args.s)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Parse() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\ta, err := v.Array()\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Array() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tv = a[0]\n\t\t\tgot, err := v.Int()\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Int() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Int() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValueInt_JSON_Nested(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"valid int\",\n\t\t\targs: args{\n\t\t\t\ts: `{\"a\": {\"b\": 123}}`,\n\t\t\t},\n\t\t\twant:    123,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"valid negative int\",\n\t\t\targs: args{\n\t\t\t\ts: `{\"a\": {\"b\": -123}}`,\n\t\t\t},\n\t\t\twant:    -123,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"valid large int\",\n\t\t\targs: args{\n\t\t\t\ts: `{\"a\": {\"b\": 9223372036854775807}}`,\n\t\t\t},\n\t\t\twant:    9223372036854775807,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid int\",\n\t\t\targs: args{\n\t\t\t\ts: `{\"a\": {\"b\": 123.456}}`,\n\t\t\t},\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid int - string\",\n\t\t\targs: args{\n\t\t\t\ts: `{\"a\": {\"b\": \"123\"}}`,\n\t\t\t},\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid int - bool\",\n\t\t\targs: args{\n\t\t\t\ts: `{\"a\": {\"b\": true}}`,\n\t\t\t},\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid int - null\",\n\t\t\targs: args{\n\t\t\t\ts: `{\"a\": {\"b\": null}}`,\n\t\t\t},\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tp := NewParser()\n\t\t\tv, err := p.Parse(tt.args.s)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Parse() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\to, err := v.Object()\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Object() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tv, err = o.Get(\"a\")\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Get() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\to, err = v.Object()\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Object() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tv, err = o.Get(\"b\")\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Get() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgot, err := v.Int()\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Int() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Int() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValueInt_JSON_Array_Nested(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"valid int\",\n\t\t\targs: args{\n\t\t\t\ts: `[{\"a\": 123}]`,\n\t\t\t},\n\t\t\twant:    123,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"valid negative int\",\n\t\t\targs: args{\n\t\t\t\ts: `[{\"a\": -123}]`,\n\t\t\t},\n\t\t\twant:    -123,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"valid large int\",\n\t\t\targs: args{\n\t\t\t\ts: `[{\"a\": 9223372036854775807}]`,\n\t\t\t},\n\t\t\twant:    9223372036854775807,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid int\",\n\t\t\targs: args{\n\t\t\t\ts: `[{\"a\": 123.456}]`,\n\t\t\t},\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid int - string\",\n\t\t\targs: args{\n\t\t\t\ts: `[{\"a\": \"123\"}]`,\n\t\t\t},\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid int - bool\",\n\t\t\targs: args{\n\t\t\t\ts: `[{\"a\": true}]`,\n\t\t\t},\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid int - null\",\n\t\t\targs: args{\n\t\t\t\ts: `[{\"a\": null}]`,\n\t\t\t},\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tp := NewParser()\n\t\t\tv, err := p.Parse(tt.args.s)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Parse() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\ta, err := v.Array()\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Array() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tv = a[0]\n\t\t\to, err := v.Object()\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Object() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tv, err = o.Get(\"a\")\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Get() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgot, err := v.Int()\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Int() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Int() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValueInt_JSON_Array_Nested_Deep(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"valid int\",\n\t\t\targs: args{\n\t\t\t\ts: `[{\"a\": {\"b\": 123}}]`,\n\t\t\t},\n\t\t\twant:    123,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"valid negative int\",\n\t\t\targs: args{\n\t\t\t\ts: `[{\"a\": {\"b\": -123}}]`,\n\t\t\t},\n\t\t\twant:    -123,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"valid large int\",\n\t\t\targs: args{\n\t\t\t\ts: `[{\"a\": {\"b\": 9223372036854775807}}]`,\n\t\t\t},\n\t\t\twant:    9223372036854775807,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid int\",\n\t\t\targs: args{\n\t\t\t\ts: `[{\"a\": {\"b\": 123.456}}]`,\n\t\t\t},\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid int - string\",\n\t\t\targs: args{\n\t\t\t\ts: `[{\"a\": {\"b\": \"123\"}}]`,\n\t\t\t},\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid int - bool\",\n\t\t\targs: args{\n\t\t\t\ts: `[{\"a\": {\"b\": true}}]`,\n\t\t\t},\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid int - null\",\n\t\t\targs: args{\n\t\t\t\ts: `[{\"a\": {\"b\": null}}]`,\n\t\t\t},\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tp := NewParser()\n\t\t\tv, err := p.Parse(tt.args.s)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Parse() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\ta, err := v.Array()\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Array() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tv = a[0]\n\t\t\to, err := v.Object()\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Object() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tv, err = o.Get(\"a\")\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Get() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\to, err = v.Object()\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Object() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tv, err = o.Get(\"b\")\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Get() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgot, err := v.Int()\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Int() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Int() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValueInt_JSON_Array_Nested_Deep_With_Index(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"valid int\",\n\t\t\targs: args{\n\t\t\t\ts: `[{\"a\": [123]}]`,\n\t\t\t},\n\t\t\twant:    123,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"valid negative int\",\n\t\t\targs: args{\n\t\t\t\ts: `[{\"a\": [-123]}]`,\n\t\t\t},\n\t\t\twant:    -123,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"valid large int\",\n\t\t\targs: args{\n\t\t\t\ts: `[{\"a\": [9223372036854775807]}]`,\n\t\t\t},\n\t\t\twant:    9223372036854775807,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid int\",\n\t\t\targs: args{\n\t\t\t\ts: `[{\"a\": [123.456]}]`,\n\t\t\t},\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid int - string\",\n\t\t\targs: args{\n\t\t\t\ts: `[{\"a\": [\"123\"]}]`,\n\t\t\t},\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid int - bool\",\n\t\t\targs: args{\n\t\t\t\ts: `[{\"a\": [true]}]`,\n\t\t\t},\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid int - null\",\n\t\t\targs: args{\n\t\t\t\ts: `[{\"a\": [null]}]`,\n\t\t\t},\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tp := NewParser()\n\t\t\tv, err := p.Parse(tt.args.s)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Parse() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\ta, err := v.Array()\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Array() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tv = a[0]\n\t\t\to, err := v.Object()\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Object() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tv, err = o.Get(\"a\")\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Get() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\ta, err = v.Array()\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Array() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tv = a[0]\n\t\t\tgot, err := v.Int()\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Int() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Int() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValueInt_JSON_Array_Nested_Deep_With_Index_String(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"valid int\",\n\t\t\targs: args{\n\t\t\t\ts: `[{\"a\": [123, 456]}]`,\n\t\t\t},\n\t\t\twant:    123,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"valid negative int\",\n\t\t\targs: args{\n\t\t\t\ts: `[{\"a\": [-123, 456]}]`,\n\t\t\t},\n\t\t\twant:    -123,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"valid large int\",\n\t\t\targs: args{\n\t\t\t\ts: `[{\"a\": [9223372036854775807, 456]}]`,\n\t\t\t},\n\t\t\twant:    9223372036854775807,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid int\",\n\t\t\targs: args{\n\t\t\t\ts: `[{\"a\": [123.456, 456]}]`,\n\t\t\t},\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid int - string\",\n\t\t\targs: args{\n\t\t\t\ts: `[{\"a\": [\"123\", 456]}]`,\n\t\t\t},\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid int - bool\",\n\t\t\targs: args{\n\t\t\t\ts: `[{\"a\": [true, 456]}]`,\n\t\t\t},\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid int - null\",\n\t\t\targs: args{\n\t\t\t\ts: `[{\"a\": [null, 456]}]`,\n\t\t\t},\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tp := NewParser()\n\t\t\tv, err := p.Parse(tt.args.s)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Parse() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\ta, err := v.Array()\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Array() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tv = a[0]\n\t\t\to, err := v.Object()\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Object() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tv, err = o.Get(\"a\")\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Get() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\ta, err = v.Array()\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Array() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tv = a[0]\n\t\t\tgot, err := v.Int()\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Int() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Int() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValueInt_JSON_Array_Nested_Deep_With_Index_String_2(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"valid int\",\n\t\t\targs: args{\n\t\t\t\ts: `[{\"a\": [123, 456, 789]}]`,\n\t\t\t},\n\t\t\twant:    123,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"valid negative int\",\n\t\t\targs: args{\n\t\t\t\ts: `[{\"a\": [-123, 456, 789]}]`,\n\t\t\t},\n\t\t\twant:    -123,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"valid large int\",\n\t\t\targs: args{\n\t\t\t\ts: `[{\"a\": [9223372036854775807, 456, 789]}]`,\n\t\t\t},\n\t\t\twant:    9223372036854775807,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid int\",\n\t\t\targs: args{\n\t\t\t\ts: `[{\"a\": [123.456, 456, 789]}]`,\n\t\t\t},\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid int - string\",\n\t\t\targs: args{\n\t\t\t\ts: `[{\"a\": [\"123\", 456, 789]}]`,\n\t\t\t},\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid int - bool\",\n\t\t\targs: args{\n\t\t\t\ts: `[{\"a\": [true, 456, 789]}]`,\n\t\t\t},\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid int - null\",\n\t\t\targs: args{\n\t\t\t\ts: `[{\"a\": [null, 456, 789]}]`,\n\t\t\t},\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tp := NewParser()\n\t\t\tv, err := p.Parse(tt.args.s)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Parse() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\ta, err := v.Array()\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Array() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tv = a[0]\n\t\t\to, err := v.Object()\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Object() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tv, err = o.Get(\"a\")\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Get() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\ta, err = v.Array()\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Array() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tv = a[0]\n\t\t\tgot, err := v.Int()\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Int() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Int() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValueInt_JSON_Array_Nested_Deep_With_Index_String_3(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"valid int\",\n\t\t\targs: args{\n\t\t\t\ts: `[{\"a\": [123, 456, 789, 1011]}]`,\n\t\t\t},\n\t\t\twant:    123,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"valid negative int\",\n\t\t\targs: args{\n\t\t\t\ts: `[{\"a\": [-123, 456, 789, 1011]}]`,\n\t\t\t},\n\t\t\twant:    -123,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"valid large int\",\n\t\t\targs: args{\n\t\t\t\ts: `[{\"a\": [9223372036854775807, 456, 789, 1011]}]`,\n\t\t\t},\n\t\t\twant:    9223372036854775807,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid int\",\n\t\t\targs: args{\n\t\t\t\ts: `[{\"a\": [123.456, 456, 789, 1011]}]`,\n\t\t\t},\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid int - string\",\n\t\t\targs: args{\n\t\t\t\ts: `[{\"a\": [\"123\", 456, 789, 1011]}]`,\n\t\t\t},\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid int - bool\",\n\t\t\targs: args{\n\t\t\t\ts: `[{\"a\": [true, 456, 789, 1011]}]`,\n\t\t\t},\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid int - null\",\n\t\t\targs: args{\n\t\t\t\ts: `[{\"a\": [null, 456, 789, 1011]}]`,\n\t\t\t},\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tp := NewParser()\n\t\t\tv, err := p.Parse(tt.args.s)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Parse() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\ta, err := v.Array()\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Array() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tv = a[0]\n\t\t\to, err := v.Object()\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Object() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tv, err = o.Get(\"a\")\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Get() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\ta",
    "f8da9bdf20008c2b106a9e69d349e4ba": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped string with multiple escapes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\\\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: ``,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with no quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `hello`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\\\"hello\"`,\n\t\t\t},\n\t\t\twant:    `\\\"hello`,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote and closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\\\"hello\\\"`,\n\t\t\t},\n\t\t\twant:    `\\\"hello`,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f95819b73bedc0740878a7252e4ef62b": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestString(t *testing.T) {\n\ttype args struct {\n\t\tt Type\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"TestString_Object\",\n\t\t\targs: args{t: TypeObject},\n\t\t\twant: \"object\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestString_Array\",\n\t\t\targs: args{t: TypeArray},\n\t\t\twant: \"array\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestString_String\",\n\t\t\targs: args{t: TypeString},\n\t\t\twant: \"string\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestString_True\",\n\t\t\targs: args{t: TypeTrue},\n\t\t\twant: \"true\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestString_False\",\n\t\t\targs: args{t: TypeFalse},\n\t\t\twant: \"false\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestString_Null\",\n\t\t\targs: args{t: TypeNull},\n\t\t\twant: \"null\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.t.String(); got != tt.want {\n\t\t\t\tt.Errorf(\"String() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f9747230c68e23c0a3a3fc2165b2b8a6": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\tv   *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"marshal null\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNull},\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal true\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeTrue},\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal false\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeFalse},\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal number\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t},\n\t\t\twant: []byte(\"123\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeString, s: \"hello world\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello world\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal raw string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: typeRawString, s: \"hello world\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello world\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal array\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeString, s: \"hello\"},\n\t\t\t\t}},\n\t\t\t},\n\t\t\twant: []byte(\"[1,\\\"hello\\\"]\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal object\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeNumber, s: \"1\"}},\n\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"hello\"}},\n\t\t\t\t}}},\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":1,\"key2\":\"hello\"}`),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.v.MarshalTo(tt.args.dst); !bytesEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc bytesEqual(a, b []byte) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "f981bfe9171513de09c0681357443d27": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\"world\\\\\\\"\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\"`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with no quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `hello`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}",
    "fa1f625cfa6f647e389ef8b2e4a2b0f7": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_JSONUnmarshal(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    map[string]interface{}\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    map[string]interface{}{},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    map[string]interface{}{\"key1\": \"value1\", \"key2\": \"value2\"},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    map[string]interface{}{\"key1\": map[string]interface{}{\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    map[string]interface{}{\"key\\\"1\": \"value1\"},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif tt.wantErr {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tvar want map[string]interface{}\n\t\t\tif err := json.Unmarshal([]byte(tt.args.s), \u0026want); err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got.o.ToMap(), want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got.o.ToMap(), want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "fa43a2f1438e1f409b9dcf9d2fc25dc6": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_JSON(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_JSON_Compare(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tvar want map[string]interface{}\n\t\t\tif err := json.Unmarshal([]byte(tt.args.s), \u0026want); err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got.o.kvs, want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got.o.kvs, want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "fad2cd55a1437b3ce0da7feb21a2c28c": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\tv   *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"marshal null\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNull},\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal true\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeTrue},\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal false\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeFalse},\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal number\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t},\n\t\t\twant: []byte(\"123\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeString, s: \"hello world\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello world\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal raw string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: typeRawString, s: \"hello world\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello world\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal array\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t\t{t: TypeString, s: \"hello\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"[1,\\\"hello\\\"]\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal object\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{k: \"name\", v: \u0026Value{t: TypeString, s: \"John Doe\"}},\n\t\t\t\t\t\t\t{k: \"age\", v: \u0026Value{t: TypeNumber, s: \"30\"}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"{\\\"name\\\":\\\"John Doe\\\",\\\"age\\\":30}\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.v.MarshalTo(tt.args.dst); !bytesEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc bytesEqual(a, b []byte) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "fafe949e40ef0e679a1dce9f0ab14244": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_JSONUnmarshal(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    map[string]interface{}\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    map[string]interface{}{},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    map[string]interface{}{\"key1\": \"value1\", \"key2\": \"value2\"},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    map[string]interface{}{\"key1\": map[string]interface{}{\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    map[string]interface{}{\"key\\\"1\": \"value1\"},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif tt.wantErr {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tvar wantJSON map[string]interface{}\n\t\t\tif err := json.Unmarshal([]byte(tt.args.s), \u0026wantJSON); err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got.o.ToMap(), wantJSON) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got.o.ToMap(), wantJSON)\n\t\t\t}\n\t\t})\n\t}\n}",
    "fb729c9e664590824f43d00dd4575e18": "```go\npackage fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\"world\\\\\\\"\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n",
    "fb7e9ab90d925bed85b64d15b8032d26": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"single element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,3]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[[1,2],[3,4]]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"4\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with string elements\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[\\\"hello\\\",\\\"world\\\"]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"hello\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"world\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with invalid element\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \",\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"array with missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseArray() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseArray_JSON(t *testing.T) {\n\ttype testCase struct {\n\t\tjson string\n\t\twant []interface{}\n\t}\n\ttestCases := []testCase{\n\t\t{\n\t\t\tjson: \"[]\",\n\t\t\twant: []interface{}{},\n\t\t},\n\t\t{\n\t\t\tjson: \"[1,2,3]\",\n\t\t\twant: []interface{}{1, 2, 3},\n\t\t},\n\t\t{\n\t\t\tjson: `[\"hello\",\"world\"]`,\n\t\t\twant: []interface{}{\"hello\", \"world\"},\n\t\t},\n\t\t{\n\t\t\tjson: `[{\"key1\": \"value1\"}, {\"key2\": \"value2\"}]`,\n\t\t\twant: []interface{}{\n\t\t\t\tmap[string]interface{}{\"key1\": \"value1\"},\n\t\t\t\tmap[string]interface{}{\"key2\": \"value2\"},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tjson: `[[1,2],[3,4]]`,\n\t\t\twant: []interface{}{\n\t\t\t\t[]interface{}{1, 2},\n\t\t\t\t[]interface{}{3, 4},\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.json, func(t *testing.T) {\n\t\t\tvar c cache\n\t\t\tv, _, err := parseArray(tc.json, \u0026c, 0)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"parseArray() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tvar got []interface{}\n\t\t\tif err := json.Unmarshal(v.MarshalTo(nil), \u0026got); err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !reflect.DeepEqual(got, tc.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "fce70cc9e40ba2c400ed89f3e0ba423b": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetInt(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant int\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.GetInt(tt.args.keys...); got != tt.want {\n\t\t\t\tt.Errorf(\"Value.GetInt() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "feacaa5e88202caacf33cb33a02608a6": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"{}\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\": \"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"value1\", \"value2\"]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"value\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"value\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   `true`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueTrue,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   `false`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueFalse,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   `null`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueNull,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with decimal\",\n\t\t\targs: args{\n\t\t\t\ts:   `123.456`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e+4`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   `NaN`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected value\",\n\t\t\targs: args{\n\t\t\t\ts:   `tru`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"tru\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseValue() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseValue_JSON(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\": \"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `{\"key\":\"value\"}`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"value1\", \"value2\"]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `[\"value1\",\"value2\"]`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"value\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `\"value\"`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   `true`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `true`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   `false`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `false`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   `null`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `null`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `123`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with decimal\",\n\t\t\targs: args{\n\t\t\t\ts:   `123.456`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `123.456`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e+4`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `1.23e+4`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   `NaN`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `NaN`,\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err == nil {\n\t\t\t\tb, err := json.Marshal(got)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"json.Marshal() error = %v\", err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif string(b) != tt.want {\n\t\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", string(b), tt.want)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}",
    "ff29818ed9c5eb2e04b751c3ad5a474c": "package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"{}\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\": \"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"value1\", \"value2\"]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"value\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"value\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   `true`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueTrue,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   `false`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueFalse,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   `null`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueNull,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\ts:   `NaN`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseValue() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseValue_JSON(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts: `{\"key\": \"value\"}`,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts: `[\"value1\", \"value2\"]`,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"value\"`,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"value\",\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts: `true`,\n\t\t\t},\n\t\t\twant:    valueTrue,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts: `false`,\n\t\t\t},\n\t\t\twant:    valueFalse,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts: `null`,\n\t\t\t},\n\t\t\twant:    valueNull,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts: `123`,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\ts: `NaN`,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, _, err := parseValue(tt.args.s, c, 0)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseValue_JSON_CompareWithStdlib(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts: `{\"key\": \"value\"}`,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts: `[\"value1\", \"value2\"]`,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"value\"`,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts: `true`,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts: `false`,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts: `null`,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts: `123`,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\ts: `NaN`,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, _, err := parseValue(tt.args.s, c, 0)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tvar want interface{}\n\t\t\tif err := json.Unmarshal([]byte(tt.args.s), \u0026want); err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, want) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "ff2e64941735c4b5b5fb0f73d2564232": "package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetUint(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant uint\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.GetUint(tt.args.keys...); got != tt.want {\n\t\t\t\tt.Errorf(\"Value.GetUint() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "ff75975ea5cedab01a573834e62bf964": "package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"empty string\",\n\t\t\targs:    args{s: \"\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"single digit\",\n\t\t\targs:    args{s: \"1\"},\n\t\t\twantNs:  \"1\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"multiple digits\",\n\t\t\targs:    args{s: \"123\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"decimal number\",\n\t\t\targs:    args{s: \"123.456\"},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"negative number\",\n\t\t\targs:    args{s: \"-123\"},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"exponential number\",\n\t\t\targs:    args{s: \"1.23e+4\"},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"exponential number with lowercase e\",\n\t\t\targs:    args{s: \"1.23e-4\"},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading zeros\",\n\t\t\targs:    args{s: \"00123\"},\n\t\t\twantNs:  \"00123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with trailing zeros\",\n\t\t\targs:    args{s: \"123.00\"},\n\t\t\twantNs:  \"123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign\",\n\t\t\targs:    args{s: \"+123\"},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading minus sign\",\n\t\t\targs:    args{s: \"-123\"},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading space\",\n\t\t\targs:    args{s: \" 123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" 123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with trailing space\",\n\t\t\targs:    args{s: \"123 \"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \" \",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading comma\",\n\t\t\targs:    args{s: \",123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \",123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with trailing comma\",\n\t\t\targs:    args{s: \"123,\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \",\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading colon\",\n\t\t\targs:    args{s: \":123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \":123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with trailing colon\",\n\t\t\targs:    args{s: \"123:\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \":\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading semicolon\",\n\t\t\targs:    args{s: \";123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \";123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with trailing semicolon\",\n\t\t\targs:    args{s: \"123;\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \";\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading bracket\",\n\t\t\targs:    args{s: \"[123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"[123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with trailing bracket\",\n\t\t\targs:    args{s: \"123]\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"]\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading brace\",\n\t\t\targs:    args{s: \"{123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"{123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with trailing brace\",\n\t\t\targs:    args{s: \"123}\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"}\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading quote\",\n\t\t\targs:    args{s: \"\\\"123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\\\"123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with trailing quote\",\n\t\t\targs:    args{s: \"123\\\"\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\\\"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading slash\",\n\t\t\targs:    args{s: \"/123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"/123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with trailing slash\",\n\t\t\targs:    args{s: \"123/\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"/\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading backslash\",\n\t\t\targs:    args{s: \"\\\\123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\\\\123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with trailing backslash\",\n\t\t\targs:    args{s: \"123\\\\\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\\\\\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading question mark\",\n\t\t\targs:    args{s: \"?123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"?123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with trailing question mark\",\n\t\t\targs:    args{s: \"123?\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"?\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading exclamation mark\",\n\t\t\targs:    args{s: \"!123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"!123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with trailing exclamation mark\",\n\t\t\targs:    args{s: \"123!\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"!\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading at sign\",\n\t\t\targs:    args{s: \"@123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"@123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with trailing at sign\",\n\t\t\targs:    args{s: \"123@\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"@\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading hash sign\",\n\t\t\targs:    args{s: \"#123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"#123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with trailing hash sign\",\n\t\t\targs:    args{s: \"123#\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"#\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading dollar sign\",\n\t\t\targs:    args{s: \"$123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"$123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with trailing dollar sign\",\n\t\t\targs:    args{s: \"123$\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"$\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading percent sign\",\n\t\t\targs:    args{s: \"%123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"%123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with trailing percent sign\",\n\t\t\targs:    args{s: \"123%\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"%\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading caret sign\",\n\t\t\targs:    args{s: \"^123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"^123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with trailing caret sign\",\n\t\t\targs:    args{s: \"123^\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"^\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading ampersand sign\",\n\t\t\targs:    args{s: \"\u0026123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\u0026123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with trailing ampersand sign\",\n\t\t\targs:    args{s: \"123\u0026\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\u0026\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading asterisk sign\",\n\t\t\targs:    args{s: \"*123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"*123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with trailing asterisk sign\",\n\t\t\targs:    args{s: \"123*\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"*\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading parenthesis\",\n\t\t\targs:    args{s: \"(123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"(123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with trailing parenthesis\",\n\t\t\targs:    args{s: \"123)\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \")\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading underscore\",\n\t\t\targs:    args{s: \"_123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"_123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with trailing underscore\",\n\t\t\targs:    args{s: \"123_\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"_\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading hyphen\",\n\t\t\targs:    args{s: \"-123\"},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with trailing hyphen\",\n\t\t\targs:    args{s: \"123-\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign\",\n\t\t\targs:    args{s: \"+123\"},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with trailing plus sign\",\n\t\t\targs:    args{s: \"123+\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading equal sign\",\n\t\t\targs:    args{s: \"=123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"=123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with trailing equal sign\",\n\t\t\targs:    args{s: \"123=\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"=\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading less than sign\",\n\t\t\targs:    args{s: \"\u003c123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\u003c123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with trailing less than sign\",\n\t\t\targs:    args{s: \"123\u003c\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\u003c\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading greater than sign\",\n\t\t\targs:    args{s: \"\u003e123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\u003e123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with trailing greater than sign\",\n\t\t\targs:    args{s: \"123\u003e\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\u003e\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading slash\",\n\t\t\targs:    args{s: \"/123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"/123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with trailing slash\",\n\t\t\targs:    args{s: \"123/\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"/\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading backslash\",\n\t\t\targs:    args{s: \"\\\\123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\\\\123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with trailing backslash\",\n\t\t\targs:    args{s: \"123\\\\\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\\\\\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading pipe\",\n\t\t\targs:    args{s: \"|123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"|123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with trailing pipe\",\n\t\t\targs:    args{s: \"123|\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"|\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading double quote\",\n\t\t\targs:    args{s: \"\\\"123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\\\"123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with trailing double quote\",\n\t\t\targs:    args{s: \"123\\\"\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\\\"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading single quote\",\n\t\t\targs:    args{s: \"'123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"'123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with trailing single quote\",\n\t\t\targs:    args{s: \"123'\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"'\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading inf\",\n\t\t\targs:    args{s: \"inf123\"},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"123\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with trailing inf\",\n\t\t\targs:    args{s: \"123inf\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"inf\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading nan\",\n\t\t\targs:    args{s: \"nan123\"},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"123\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with trailing nan\",\n\t\t\targs:    args{s: \"123nan\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"nan\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading inf\",\n\t\t\targs:    args{s: \"inf\"},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading nan\",\n\t\t\targs:    args{s: \"nan\"},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}"
}