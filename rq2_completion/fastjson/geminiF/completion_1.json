{"00278ae3692fa09d9f958ad63beba116":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueExists(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant bool\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.Exists(tt.args.keys...); got != tt.want {\n\t\t\t\tt.Errorf(\"Value.Exists() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","0144670a849d18faf8a4f3ce07fa7a09":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObjectVisit(t *testing.T) {\n\ttype args struct {\n\t\to *Object\n\t\tf func(key []byte, v *Value)\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\ttt.args.o.Visit(tt.args.f)\n\t\t})\n\t}\n}","02a8269c4ee18a4fbb8c09411ab1841f":"```","030050b2471e57cd0d6c0d511578aae8":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWS(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no whitespace\",\n\t\t\targs: args{\n\t\t\t\ts: \"abc\",\n\t\t\t},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace\",\n\t\t\targs: args{\n\t\t\t\ts: \"  abc\",\n\t\t\t},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailing whitespace\",\n\t\t\targs: args{\n\t\t\t\ts: \"abc  \",\n\t\t\t},\n\t\t\twant: \"abc  \",\n\t\t},\n\t\t{\n\t\t\tname: \"internal whitespace\",\n\t\t\targs: args{\n\t\t\t\ts: \"a bc\",\n\t\t\t},\n\t\t\twant: \"a bc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading and trailing whitespace\",\n\t\t\targs: args{\n\t\t\t\ts: \"  abc  \",\n\t\t\t},\n\t\t\twant: \"abc  \",\n\t\t},\n\t\t{\n\t\t\tname: \"special characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"  \\t\\r\\n abc  \",\n\t\t\t},\n\t\t\twant: \" abc  \",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWS(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWS() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","030088fada765edfb609350d13c2384f":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple float\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative number\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123.456\",\n\t\t\t},\n\t\t\twantNs:  \"-123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with exponent\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with exponent E\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23E-4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23E-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"inf\",\n\t\t\t},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"INF\",\n\t\t\targs: args{\n\t\t\t\ts: \"INF\",\n\t\t\t},\n\t\t\twantNs:  \"INF\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"nan\",\n\t\t\t},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NAN\",\n\t\t\targs: args{\n\t\t\t\ts: \"NAN\",\n\t\t\t},\n\t\t\twantNs:  \"NAN\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123abc\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"abc\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with special characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.456!\",\n\t\t\t},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"!\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading whitespace\",\n\t\t\targs: args{\n\t\t\t\ts: \" 123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" 123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing whitespace\",\n\t\t\targs: args{\n\t\t\t\ts: \"123 \",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \" \",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading +\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading -\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading -, but with sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123-\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading +\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123+\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading + and trailing +\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123+\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading - and trailing -\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123-\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading - and trailing +\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123+\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading + and trailing -\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123-\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}","033289b6ad4a2cc3c8f2036ab17e5a0b":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[]\",\n\t\t\t\tc:    \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    \u0026Value{t: TypeArray, a: []*Value{}},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"single element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1]\",\n\t\t\t\tc:    \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    \u0026Value{t: TypeArray, a: []*Value{\u0026Value{t: TypeNumber, s: \"1\"}}},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,3]\",\n\t\t\t\tc:    \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    \u0026Value{t: TypeArray, a: []*Value{\u0026Value{t: TypeNumber, s: \"1\"}, \u0026Value{t: TypeNumber, s: \"2\"}, \u0026Value{t: TypeNumber, s: \"3\"}}},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[[1,2],[3,4]]\",\n\t\t\t\tc:    \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t\t\u0026Value{t: TypeArray, a: []*Value{\n\t\t\t\t\t\u0026Value{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t\u0026Value{t: TypeNumber, s: \"2\"},\n\t\t\t\t}},\n\t\t\t\t\u0026Value{t: TypeArray, a: []*Value{\n\t\t\t\t\t\u0026Value{t: TypeNumber, s: \"3\"},\n\t\t\t\t\t\u0026Value{t: TypeNumber, s: \"4\"},\n\t\t\t\t}},\n\t\t\t}},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with string\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[\\\"hello\\\", \\\"world\\\"]\",\n\t\t\t\tc:    \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t\t\u0026Value{t: TypeString, s: \"hello\"},\n\t\t\t\t\u0026Value{t: TypeString, s: \"world\"},\n\t\t\t}},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with invalid value\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,3,\",\n\t\t\t\tc:    \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1,2,3,\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"array with missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,3\",\n\t\t\t\tc:    \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1,2,3\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"array with unexpected end of array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,3\",\n\t\t\t\tc:    \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1,2,3\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseArray() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","033e68fd7e13f2d9c2f9e28af7b159b4":"package fastjson\n\nimport (\n\t\"testing\"\n\t\"strconv\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"abcdefg\"},\n\t\t\twant: \"abcdefg\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quote\",\n\t\t\targs: args{s: \"\\\\\\\"\"},\n\t\t\twant: \"\\\"\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslash\",\n\t\t\targs: args{s: \"\\\\\\\\\"},\n\t\t\twant: \"\\\\\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped slash\",\n\t\t\targs: args{s: \"\\\\/\"},\n\t\t\twant: \"/\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\b\"},\n\t\t\twant: \"\\b\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\f\"},\n\t\t\twant: \"\\f\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\n\"},\n\t\t\twant: \"\\n\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\r\"},\n\t\t\twant: \"\\r\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\t\"},\n\t\t\twant: \"\\t\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\"},\n\t\t\twant: \"a\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE00\"},\n\t\t\twant: string(utf16.DecodeRune(0xD83D, 0xDE00)),\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\u00\"},\n\t\t\twant: \"\\\\u00\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\uD83D\\\\uDE00\\\\u00\"},\n\t\t\twant: \"\\\"\\\\b\\f\\n\\r\\ta\" + string(utf16.DecodeRune(0xD83D, 0xDE00)) + \"\\\\u00\",\n\t\t},\n\t\t{\n\t\t\tname: \"escape sequence at the beginning\",\n\t\t\targs: args{s: \"\\\\\\\"abcdefg\"},\n\t\t\twant: \"\\\"abcdefg\",\n\t\t},\n\t\t{\n\t\t\tname: \"escape sequence at the end\",\n\t\t\targs: args{s: \"abcdefg\\\\\\\"\"},\n\t\t\twant: \"abcdefg\\\"\",\n\t\t},\n\t\t{\n\t\t\tname: \"escape sequence in the middle\",\n\t\t\targs: args{s: \"abc\\\\\\\"defg\"},\n\t\t\twant: \"abc\\\"defg\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with incomplete surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\u\"},\n\t\t\twant: \"\\\\uD83D\\\\u\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","038822c39cb85eb822913d7b1c215e0d":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantV  *Value\n\t\twantTail string\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV:  nil,\n\t\t\twantTail: \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twantV:  nil,\n\t\t\twantTail: \"{\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\": \"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"value1\", \"value2\"]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"value\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"value\",\n\t\t\t},\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   \"true\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV:  valueTrue,\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   \"false\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV:  valueFalse,\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   \"null\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV:  valueNull,\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   \"123\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   \"NaN\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected value\",\n\t\t\targs: args{\n\t\t\t\ts:   \"abc\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV:  nil,\n\t\t\twantTail: \"abc\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotV, gotTail, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(gotV, tt.wantV) {\n\t\t\t\tt.Errorf(\"parseValue() gotV = %v, want %v\", gotV, tt.wantV)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseValue() gotTail = %v, want %v\", gotTail, tt.wantTail)\n\t\t\t}\n\t\t})\n\t}\n}","04d0d806717ea36eb17f2b72144f32a0":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetBool(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttype want struct {\n\t\twant bool\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant want\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.GetBool(tt.args.keys...); got != tt.want.want {\n\t\t\t\tt.Errorf(\"Value.GetBool() = %v, want %v\", got, tt.want.want)\n\t\t\t}\n\t\t})\n\t}\n}","04d6e97909589953719868a25b6e57cd":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantKey string\n\t\twantTail string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"empty string\",\n\t\t\targs:    args{s: \"\"},\n\t\t\twantKey: \"\",\n\t\t\twantTail: \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"single quote\",\n\t\t\targs:    args{s: \"'\"},\n\t\t\twantKey: \"\",\n\t\t\twantTail: \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"missing closing quote\",\n\t\t\targs:    args{s: `\"key\"`},\n\t\t\twantKey: `\"key\"`,\n\t\t\twantTail: \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"simple key\",\n\t\t\targs:    args{s: `\"key\"`},\n\t\t\twantKey: `\"key\"`,\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"key with escape sequence\",\n\t\t\targs:    args{s: `\"key\\\\\"\"`},\n\t\t\twantKey: `\"key\\\\\"\"`,\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"key with space\",\n\t\t\targs:    args{s: `\"key with space\"`},\n\t\t\twantKey: `\"key with space\"`,\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"key with special characters\",\n\t\t\targs:    args{s: `\"key:with:special:chars\"`},\n\t\t\twantKey: `\"key:with:special:chars\"`,\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotKey, gotTail, err := parseRawKey(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawKey() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotKey != tt.wantKey {\n\t\t\t\tt.Errorf(\"parseRawKey() gotKey = %v, want %v\", gotKey, tt.wantKey)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseRawKey() gotTail = %v, want %v\", gotTail, tt.wantTail)\n\t\t\t}\n\t\t})\n\t}\n}","04dc8272468e903ebae88b5145747003":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_reset(t *testing.T) {\n\ttype args struct {\n\t\to *Object\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant *Object\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.o.reset(); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Object.reset() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","0579ad30148187ef9637d5bc4d216b67":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo_Null(t *testing.T) {\n\tv := \u0026Value{t: TypeNull}\n\tdst := []byte{}\n\tgot := v.MarshalTo(dst)\n\twant := []byte(\"null\")\n\tif !bytesEqual(got, want) {\n\t\tt.Errorf(\"got %v, want %v\", got, want)\n\t}\n}\n\nfunc TestValueMarshalTo_True(t *testing.T) {\n\tv := \u0026Value{t: TypeTrue}\n\tdst := []byte{}\n\tgot := v.MarshalTo(dst)\n\twant := []byte(\"true\")\n\tif !bytesEqual(got, want) {\n\t\tt.Errorf(\"got %v, want %v\", got, want)\n\t}\n}\n\nfunc TestValueMarshalTo_False(t *testing.T) {\n\tv := \u0026Value{t: TypeFalse}\n\tdst := []byte{}\n\tgot := v.MarshalTo(dst)\n\twant := []byte(\"false\")\n\tif !bytesEqual(got, want) {\n\t\tt.Errorf(\"got %v, want %v\", got, want)\n\t}\n}\n\nfunc TestValueMarshalTo_String(t *testing.T) {\n\tv := \u0026Value{t: TypeString, s: \"hello\"}\n\tdst := []byte{}\n\tgot := v.MarshalTo(dst)\n\twant := []byte(\"\\\"hello\\\"\")\n\tif !bytesEqual(got, want) {\n\t\tt.Errorf(\"got %v, want %v\", got, want)\n\t}\n}\n\nfunc TestValueMarshalTo_Number(t *testing.T) {\n\tv := \u0026Value{t: TypeNumber, s: \"123\"}\n\tdst := []byte{}\n\tgot := v.MarshalTo(dst)\n\twant := []byte(\"123\")\n\tif !bytesEqual(got, want) {\n\t\tt.Errorf(\"got %v, want %v\", got, want)\n\t}\n}\n\nfunc TestValueMarshalTo_RawString(t *testing.T) {\n\tv := \u0026Value{t: typeRawString, s: \"hello\"}\n\tdst := []byte{}\n\tgot := v.MarshalTo(dst)\n\twant := []byte(\"\\\"hello\\\"\")\n\tif !bytesEqual(got, want) {\n\t\tt.Errorf(\"got %v, want %v\", got, want)\n\t}\n}\n\nfunc TestValueMarshalTo_Array(t *testing.T) {\n\tv := \u0026Value{\n\t\tt: TypeArray,\n\t\ta: []*Value{\n\t\t\t{t: TypeString, s: \"hello\"},\n\t\t\t{t: TypeNumber, s: \"123\"},\n\t\t},\n\t}\n\tdst := []byte{}\n\tgot := v.MarshalTo(dst)\n\twant := []byte(\"[\\\"hello\\\",123]\")\n\tif !bytesEqual(got, want) {\n\t\tt.Errorf(\"got %v, want %v\", got, want)\n\t}\n}\n\nfunc TestValueMarshalTo_Object(t *testing.T) {\n\tv := \u0026Value{\n\t\tt: TypeObject,\n\t\to: Object{\n\t\t\tkvs: []kv{\n\t\t\t\t{k: \"name\", v: \u0026Value{t: TypeString, s: \"John Doe\"}},\n\t\t\t\t{k: \"age\", v: \u0026Value{t: TypeNumber, s: \"30\"}},\n\t\t\t},\n\t\t},\n\t}\n\tdst := []byte{}\n\tgot := v.MarshalTo(dst)\n\twant := []byte(`{\"name\":\"John Doe\",\"age\":30}`)\n\tif !bytesEqual(got, want) {\n\t\tt.Errorf(\"got %v, want %v\", got, want)\n\t}\n}\n\nfunc bytesEqual(a, b []byte) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","05d5d41f64663ccd061a86a2c50439e7":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"no closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\"world\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quote at the end\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quote with trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quote with multiple trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world123`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quote with space\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\" world\"`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quote with multiple spaces\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"  world\"`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quote with newline\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"\\nworld\"`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quote with tab\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"\\tworld\"`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quote with carriage return\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"\\rworld\"`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","05f386d6426b2ba51ab1618802020780":"package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello world\",\n\t\t\t},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quote\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello world\\\"\",\n\t\t\t},\n\t\t\twant: \"\\\"hello world\\\"\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslash\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\hello world\",\n\t\t\t},\n\t\t\twant: \"\\\\hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped slash\",\n\t\t\targs: args{\n\t\t\t\ts: \"/hello world\",\n\t\t\t},\n\t\t\twant: \"/hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\bhello world\",\n\t\t\t},\n\t\t\twant: \"\\bhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\fhello world\",\n\t\t\t},\n\t\t\twant: \"\\fhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\nhello world\",\n\t\t\t},\n\t\t\twant: \"\\nhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\rhello world\",\n\t\t\t},\n\t\t\twant: \"\\rhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\thello world\",\n\t\t\t},\n\t\t\twant: \"\\thello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\u0061hello world\",\n\t\t\t},\n\t\t\twant: \"ahello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode surrogate pair\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\uD83D\\\\uDE01hello world\",\n\t\t\t},\n\t\t\twant: \"😁hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid hex\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\u006xhello world\",\n\t\t\t},\n\t\t\twant: \"\\\\u006xhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with short sequence\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\u006hello world\",\n\t\t\t},\n\t\t\twant: \"\\\\u006hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode surrogate pair with short sequence\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\uD83D\\\\uDEhello world\",\n\t\t\t},\n\t\t\twant: \"\\\\uD83D\\\\uDEhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode surrogate pair with invalid hex\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\uD83D\\\\uDE0xhello world\",\n\t\t\t},\n\t\t\twant: \"\\\\uD83D\\\\uDE0xhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\\\\"\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\uD83D\\\\uDE01hello world\",\n\t\t\t},\n\t\t\twant: \"\\\"😁\\b\\f\\n\\r\\thello world\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc BenchmarkUnescapeStringBestEffort(b *testing.B) {\n\ts := \"\\\\\\\"\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\uD83D\\\\uDE01hello world\"\n\tfor i := 0; i \u003c b.N; i++ {\n\t\tunescapeStringBestEffort(s)\n\t}\n}","07b09c2d02a2a43bf3bdfe6d215f6090":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestValueInt(t *testing.T) {\n\ttype args struct {\n\t\tv *Value\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"ValidInt\",\n\t\t\targs: args{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"123\",\n\t\t\t\t},\n\t\t\t},\n\t\t\twant:    123,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"InvalidType\",\n\t\t\targs: args{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeString,\n\t\t\t\t\ts: \"abc\",\n\t\t\t\t},\n\t\t\t},\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"IntOverflow\",\n\t\t\targs: args{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"9223372036854775808\",\n\t\t\t\t},\n\t\t\t},\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := tt.args.v.Int()\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Value.Int() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Value.Int() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","0939d19a198a44e82a69f74a6213352e":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello\\\"\",\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quote\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello\\\\\\\"\",\n\t\t\t},\n\t\t\twant:    \"hello\\\"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello\\\\\\\"world\\\\\\\"\",\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quote in the middle\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello\\\\\\\"world\\\"\",\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello\",\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","09ab002c025559c976b4c2b3658e55f7":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"parse null\",\n\t\t\targs: args{\n\t\t\t\ts: \"null\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"parse true\",\n\t\t\targs: args{\n\t\t\t\ts: \"true\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"parse false\",\n\t\t\targs: args{\n\t\t\t\ts: \"false\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"parse string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt:  TypeString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"parse number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"parse object\",\n\t\t\targs: args{\n\t\t\t\ts: `{\"a\": 1, \"b\": \"2\"}`,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"a\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"b\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt:  TypeString,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"parse array\",\n\t\t\targs: args{\n\t\t\t\ts: `[1, \"2\", true]`,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt:  TypeString,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"parse invalid json\",\n\t\t\targs: args{\n\t\t\t\ts: `{`,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tp := \u0026Parser{}\n\t\t\tgot, err := p.Parse(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Parse() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr {\n\t\t\t\tif !compareValues(got, tt.want) {\n\t\t\t\t\tt.Errorf(\"Parse() = %v, want %v\", got, tt.want)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeNull:\n\t\treturn true\n\tcase TypeTrue:\n\t\treturn true\n\tcase TypeFalse:\n\t\treturn true\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, kv1 := range v1.o.kvs {\n\t\t\tkv2 := v2.o.kvs[i]\n\t\t\tif kv1.k != kv2.k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !compareValues(kv1.v, kv2.v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, v1 := range v1.a {\n\t\t\tif !compareValues(v1, v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\treturn false\n}","0a78ec200670858320d02e398f83adb6":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"single character string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"a\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"a\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\": \"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: \u0026Value{\n\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[1, 2, 3]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"hello world\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello world\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   `true`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueTrue,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   `false`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueFalse,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   `null`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueNull,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": {\"key2\": \"value\"}}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{\n\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{\n\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[1, [2, 3], 4]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeArray, a: []*Value{\n\t\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t\t}},\n\t\t\t\t\t{t: TypeNumber, s: \"4\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": {\"key2\": {\"key3\": \"value\"}}}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth - 1,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key3\": \"value\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   `NaN`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseValue() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","0ac5d665a06f3aea0c44fc787c1e6312":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","0b937229edec31861deb151c4b2bde02":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantV  *Value\n\t\twantS  string\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotV, gotS, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(gotV, tt.wantV) {\n\t\t\t\tt.Errorf(\"parseArray() gotV = %v, want %v\", gotV, tt.wantV)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseArray() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}","0caf733fa5305edee132705c431f4cb5":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestValueUint(t *testing.T) {\n\ttype args struct {\n\t\tv *Value\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    uint\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"Valid uint\",\n\t\t\targs: args{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"123\",\n\t\t\t\t},\n\t\t\t},\n\t\t\twant:    123,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Invalid type\",\n\t\t\targs: args{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeString,\n\t\t\t\t\ts: \"abc\",\n\t\t\t\t},\n\t\t\t},\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Out of range uint\",\n\t\t\targs: args{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"18446744073709551616\",\n\t\t\t\t},\n\t\t\t},\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := tt.args.v.Uint()\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Value.Uint() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Value.Uint() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","0cd53799171f8eab7a7786371d5f8f6a":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"empty string\",\n\t\t\targs:    args{s: \"\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"simple integer\",\n\t\t\targs:    args{s: \"123\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"simple float\",\n\t\t\targs:    args{s: \"123.45\"},\n\t\t\twantNs:  \"123.45\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"negative number\",\n\t\t\targs:    args{s: \"-123\"},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"exponential notation\",\n\t\t\targs:    args{s: \"1.23e+4\"},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"exponential notation with negative exponent\",\n\t\t\targs:    args{s: \"1.23e-4\"},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"inf\",\n\t\t\targs:    args{s: \"inf\"},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"nan\",\n\t\t\targs:    args{s: \"nan\"},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"unexpected char\",\n\t\t\targs:    args{s: \"123a\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"unexpected char at the beginning\",\n\t\t\targs:    args{s: \"a123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"a123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"unexpected char after minus sign\",\n\t\t\targs:    args{s: \"-a123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"-a123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"unexpected char after plus sign\",\n\t\t\targs:    args{s: \"+a123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+a123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid inf\",\n\t\t\targs:    args{s: \"in\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"in\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid nan\",\n\t\t\targs:    args{s: \"na\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"na\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}","0d8972029cfd570b7b6fadd35e2a9a42":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Type(t *testing.T) {\n\ttype args struct {\n\t\tv *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant Type\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.v.Type(); got != tt.want {\n\t\t\t\tt.Errorf(\"Value.Type() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","0dd52c43968564e6763558b0b79bfa78":"```go\npackage fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{\\\"a\\\":1}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"{\\\"a\\\":1}\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{\\\"a\\\":1}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"a\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: true,\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[1,2,3]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"hello\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   \"true\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueTrue,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   \"false\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueFalse,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   \"null\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueNull,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   \"123\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   \"NaN\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseValue() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_parseValue_invalid_input(t *testing.T) {\n\ttests := []string{\n\t\t\"truefalse\",\n\t\t\"nulltrue\",\n\t\t\"123true\",\n\t\t\"{\\\"a\\\":1,2}\",\n\t\t\"[1,2,3,\",\n\t\t`\"hello\",`,\n\t\t`\"\"`,\n\t}\n\tfor _, s := range tests {\n\t\tt.Run(s, func(t *testing.T) {\n\t\t\t_, _, err := parseValue(s, \u0026cache{}, 0)\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) should have returned an error\", s)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_parseValue_nested_objects(t *testing.T) {\n\ts := `{\"a\": {\"b\": 1, \"c\": 2}, \"d\": [3, 4, 5]}`\n\tc := \u0026cache{}\n\tv, _, err := parseValue(s, c, 0)\n\tif err != nil {\n\t\tt.Errorf(\"parseValue() error = %v\", err)\n\t\treturn\n\t}\n\n\tif v.t != TypeObject {\n\t\tt.Errorf(\"parseValue() got = %v, want %v\", v.t, TypeObject)\n\t}\n\n\t// Check the first object\n\tif len(v.o.kvs) != 2 {\n\t\tt.Errorf(\"parseValue() got = %v, want %v\", len(v.o.kvs), 2)\n\t}\n\n\t// Check the nested object\n\tif v.o.kvs[0].v.t != TypeObject {\n\t\tt.Errorf(\"parseValue() got = %v, want %v\", v.o.kvs[0].v.t, TypeObject)\n\t}\n\tif len(v.o.kvs[0].v.o.kvs) != 2 {\n\t\tt.Errorf(\"parseValue() got = %v, want %v\", len(v.o.kvs[0].v.o.kvs), 2)\n\t}\n\tif v.o.kvs[0].v.o.kvs[0].v.t != TypeNumber {\n\t\tt.Errorf(\"parseValue() got = %v, want %v\", v.o.kvs[0].v.o.kvs[0].v.t, TypeNumber)\n\t}\n\tif v.o.kvs[0].v.o.kvs[0].v.s != \"1\" {\n\t\tt.Errorf(\"parseValue() got = %v, want %v\", v.o.kvs[0","0e137cd85ee0d22389c92c89df6ce95f":"```go\npackage fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttype want struct {\n\t\tv   *Value\n\t\ts   string\n\t\terr error\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant want\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs:           nil,\n\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ts: \"\",\n\t\t\t\terr: nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"single key-value pair\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\": \"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ts: \"\",\n\t\t\t\terr: nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"multiple key-value pairs\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key2\",\n","0e2fc36867a75303a40fd010715ca652":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts: \"null\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts: \"true\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts: \"false\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"string\\\"\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt:  TypeString,\n\t\t\t\ts: \"string\",\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts: `{\"key\": \"value\"}`,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt:  TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts: `[\"value1\", \"value2\"]`,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt:  TypeString,\n\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt:  TypeString,\n\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tp := \u0026Parser{}\n\t\t\tgot, err := p.Parse(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Parse() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr \u0026\u0026 !compareValue(got, tt.want) {\n\t\t\t\tt.Errorf(\"Parse() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValue(got, want *Value) bool {\n\tif got == nil \u0026\u0026 want == nil {\n\t\treturn true\n\t}\n\tif got == nil || want == nil {\n\t\treturn false\n\t}\n\tif got.t != want.t {\n\t\treturn false\n\t}\n\tswitch got.t {\n\tcase TypeNull:\n\t\treturn true\n\tcase TypeTrue:\n\t\treturn true\n\tcase TypeFalse:\n\t\treturn true\n\tcase TypeString:\n\t\treturn got.s == want.s\n\tcase TypeNumber:\n\t\treturn got.s == want.s\n\tcase TypeObject:\n\t\tif len(got.o.kvs) != len(want.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range got.o.kvs {\n\t\t\tif got.o.kvs[i].k != want.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !compareValue(got.o.kvs[i].v, want.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeArray:\n\t\tif len(got.a) != len(want.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range got.a {\n\t\t\tif !compareValue(got.a[i], want.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc TestParse_InvalidJSON(t *testing.T) {\n\tp := \u0026Parser{}\n\t_, err := p.Parse(\"{\")\n\tif err == nil {\n\t\tt.Errorf(\"Parse() should have returned an error\")\n\t}\n\t_, err = p.Parse(\"[\")\n\tif err == nil {\n\t\tt.Errorf(\"Parse() should have returned an error\")\n\t}\n\t_, err = p.Parse(\"\\\"\")\n\tif err == nil {\n\t\tt.Errorf(\"Parse() should have returned an error\")\n\t}\n\t_, err = p.Parse(\"1\")\n\tif err == nil {\n\t\tt.Errorf(\"Parse() should have returned an error\")\n\t}\n\t_, err = p.Parse(\"true\")\n\tif err == nil {\n\t\tt.Errorf(\"Parse() should have returned an error\")\n\t}\n\t_, err = p.Parse(\"false\")\n\tif err == nil {\n\t\tt.Errorf(\"Parse() should have returned an error\")\n\t}\n\t_, err = p.Parse(\"null\")\n\tif err == nil {\n\t\tt.Errorf(\"Parse() should have returned an error\")\n\t}\n}\n\nfunc TestParse_TrailingCharacters(t *testing.T) {\n\tp := \u0026Parser{}\n\t_, err := p.Parse(\"null \")\n\tif err == nil {\n\t\tt.Errorf(\"Parse() should have returned an error\")\n\t}\n\t_, err = p.Parse(\"true \")\n\tif err == nil {\n\t\tt.Errorf(\"Parse() should have returned an error\")\n\t}\n\t_, err = p.Parse(\"false \")\n\tif err == nil {\n\t\tt.Errorf(\"Parse() should have returned an error\")\n\t}\n\t_, err = p.Parse(\"\\\"string\\\" \")\n\tif err == nil {\n\t\tt.Errorf(\"Parse() should have returned an error\")\n\t}\n\t_, err = p.Parse(\"123 \")\n\tif err == nil {\n\t\tt.Errorf(\"Parse() should have returned an error\")\n\t}\n\t_, err = p.Parse(`{\"key\": \"value\"} `)\n\tif err == nil {\n\t\tt.Errorf(\"Parse() should have returned an error\")\n\t}\n\t_, err = p.Parse(`[\"value1\", \"value2\"] `)\n\tif err == nil {\n\t\tt.Errorf(\"Parse() should have returned an error\")\n\t}\n}\n\nfunc TestParse_InvalidValueTypes(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tjson string\n\t}{\n\t\t{\n\t\t\tname: \"invalid object\",\n\t\t\tjson: `{ \"key\": \"value\", \"key2\": \"value2\" }`,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid array\",\n\t\t\tjson: `[ \"value1\", \"value2\", \"value3\", \"value4\" ]`,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tvar v interface{}\n\t\t\terr := json.Unmarshal([]byte(test.json), \u0026v)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() failed: %s\", err)\n\t\t\t}\n\t\t})\n\t}\n}","0e9eb289cd868b9e3366eb39a10000e2":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"single element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1, 2, 3]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[[1, 2], [3, 4]]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"4\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1, 2\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1, 2\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"array with invalid value\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1, 2, a]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1, 2, a]\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseArray() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseArray_JSONUnmarshal(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    interface{}\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts: \"[]\",\n\t\t\t},\n\t\t\twant:    []interface{}{},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"single element array\",\n\t\t\targs: args{\n\t\t\t\ts: \"[1]\",\n\t\t\t},\n\t\t\twant:    []interface{}{1},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element array\",\n\t\t\targs: args{\n\t\t\t\ts: \"[1, 2, 3]\",\n\t\t\t},\n\t\t\twant:    []interface{}{1, 2, 3},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts: \"[[1, 2], [3, 4]]\",\n\t\t\t},\n\t\t\twant:    [][]interface{}{{1, 2}, {3, 4}},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tv, _, err := parseArray(tt.args.s, c, 0)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tvar got interface{}\n\t\t\terr = json.Unmarshal(v.MarshalTo(nil), \u0026got)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","0f26a105e8a6525daf65d26615bb027c":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061hello\\\\u0062 world\"},\n\t\t\twant: \"ahello b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01hello\\\\uD83D\\\\uDE02 world\"},\n\t\t\twant: \"😁hello😂 world\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"short escape sequence\",\n\t\t\targs: args{s: \"\\\\uhello\\\\u world\"},\n\t\t\twant: \"\\\\uhello\\\\u world\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\\\\\ \\\\/\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\uD83D\\\\uDE01\\\\x\\\\u world\"},\n\t\t\twant: \"\\\"hello\\\" \\\\world\\\\ /\u0008\u000c\\n\\r\\ta😁\\\\x\\\\u world\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","0f616e71d39628a3904565c42de8b8bc":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCacheGetValue(t *testing.T) {\n\ttype args struct {\n\t\tc *cache\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant *Value\n\t}{\n\t\t{\n\t\t\tname: \"EmptyCache\",\n\t\t\targs: args{\n\t\t\t\tc: \u0026cache{},\n\t\t\t},\n\t\t\twant: \u0026Value{},\n\t\t},\n\t\t{\n\t\t\tname: \"NonEmptyCache\",\n\t\t\targs: args{\n\t\t\t\tc: \u0026cache{\n\t\t\t\t\tvs: []Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\ts: \"test\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.c.getValue(); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"cache.getValue() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","102240021d6c63d042cc29f0cf5c3c80":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_getKV(t *testing.T) {\n\ttype args struct {\n\t\to *Object\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant *kv\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.o.getKV(); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Object.getKV() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","10bbc6828a6fc03332fc16f5cfb25807":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"empty string\",\n\t\t\targs:    args{s: \"\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"simple integer\",\n\t\t\targs:    args{s: \"123\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"negative integer\",\n\t\t\targs:    args{s: \"-123\"},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"decimal number\",\n\t\t\targs:    args{s: \"123.456\"},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"exponential number\",\n\t\t\targs:    args{s: \"1.23e+4\"},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"exponential number with negative exponent\",\n\t\t\targs:    args{s: \"1.23e-4\"},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"inf\",\n\t\t\targs:    args{s: \"inf\"},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"inf with whitespace\",\n\t\t\targs:    args{s: \" inf\"},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"nan\",\n\t\t\targs:    args{s: \"nan\"},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"nan with whitespace\",\n\t\t\targs:    args{s: \" nan\"},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number\",\n\t\t\targs:    args{s: \"123abc\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"abc\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading whitespace\",\n\t\t\targs:    args{s: \" 123abc\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" 123abc\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with trailing whitespace\",\n\t\t\targs:    args{s: \"123abc \"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"abc \",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}","127578a71a6a36cc5701f713d549647a":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttype want struct {\n\t\tv   *Value\n\t\ts   string\n\t\terr error\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant want\n\t}{\n\t\t// TODO: Add test cases.\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{t: TypeObject, o: Object{}},\n\t\t\t\ts:   \"\",\n\t\t\t\terr: nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"single key-value pair\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\": \"value\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{t: TypeString, s: \"value\"}}}}},\n\t\t\t\ts:   \"\",\n\t\t\t\terr: nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"multiple key-value pairs\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}}, {k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}}}}},\n\t\t\t\ts:   \"\",\n\t\t\t\terr: nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"key2\": \"value2\"}}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key1\", v: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}}}}}}}},\n\t\t\t\ts:   \"\",\n\t\t\t\terr: nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\": \"value\"`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ts:   `{\"key\": \"value\"`,\n\t\t\t\terr: fmt.Errorf(\"missing '}'\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\" \"value\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ts:   `{\"key\" \"value\"}`,\n\t\t\t\terr: fmt.Errorf(\"missing ':' after object key\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ts:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\terr: fmt.Errorf(\"missing ',' after object value\"),\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotV, gotS, gotErr := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (gotErr == nil) != (tt.want.err == nil) {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", gotErr, tt.want.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotErr != nil \u0026\u0026 tt.want.err != nil {\n\t\t\t\tif gotErr.Error() != tt.want.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", gotErr, tt.want.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(gotV, tt.want.v) {\n\t\t\t\tt.Errorf(\"parseObject() gotV = %v, want %v\", gotV, tt.want.v)\n\t\t\t}\n\t\t\tif gotS != tt.want.s {\n\t\t\t\tt.Errorf(\"parseObject() gotS = %v, want %v\", gotS, tt.want.s)\n\t\t\t}\n\t\t})\n\t}\n}","131c5e909188ccddbdbc641839726007":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with one element\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,3]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with nested arrays\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[[1,2],[3,4]]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"4\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1,2\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"array with unexpected character after closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[]a\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[]a\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"array with missing comma after element\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1 2]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1 2]\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"array with invalid element\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1,\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseArray() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","13ac2e84e94bb35e0a1906d0f00aa5aa":"package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello world\",\n\t\t\t},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello world\\\"\",\n\t\t\t},\n\t\t\twant: \"\\\"hello world\\\"\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\hello world\",\n\t\t\t},\n\t\t\twant: \"\\\\hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{\n\t\t\t\ts: \"/hello world\",\n\t\t\t},\n\t\t\twant: \"/hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello\\\\bworld\",\n\t\t\t},\n\t\t\twant: \"hello\\bworld\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello\\\\fworld\",\n\t\t\t},\n\t\t\twant: \"hello\\fworld\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello\\\\nworld\",\n\t\t\t},\n\t\t\twant: \"hello\\nworld\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello\\\\rworld\",\n\t\t\t},\n\t\t\twant: \"hello\\rworld\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello\\\\tworld\",\n\t\t\t},\n\t\t\twant: \"hello\\tworld\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello\\\\u0020world\",\n\t\t\t},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello\\\\uD83D\\\\uDE01world\",\n\t\t\t},\n\t\t\twant: \"hello😊world\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello\\\\xworld\",\n\t\t\t},\n\t\t\twant: \"hello\\\\xworld\",\n\t\t},\n\t\t{\n\t\t\tname: \"short unicode escape sequence\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello\\\\uworld\",\n\t\t\t},\n\t\t\twant: \"hello\\\\uworld\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid surrogate pair\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello\\\\uD83D\\\\uworld\",\n\t\t\t},\n\t\t\twant: \"hello\\\\uD83D\\\\uworld\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","148ad80a180eea71a492d6b0b24097d2":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetStringBytes(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.GetStringBytes(tt.args.keys...); !bytes.Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.GetStringBytes() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","1490d6cb217dd451490dc28ee87e21f0":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"simple integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"float\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponent\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e-4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"inf\",\n\t\t\t},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"nan\",\n\t\t\t},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid char\",\n\t\t\targs: args{\n\t\t\t\ts: \"123a\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid char at start\",\n\t\t\targs: args{\n\t\t\t\ts: \"a123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"a123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid char after sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"-a123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"-a123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid char after sign 2\",\n\t\t\targs: args{\n\t\t\t\ts: \"+a123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+a123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"inf with trailing chars\",\n\t\t\targs: args{\n\t\t\t\ts: \"inf123\",\n\t\t\t},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"123\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nan with trailing chars\",\n\t\t\targs: args{\n\t\t\t\ts: \"nan123\",\n\t\t\t},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"123\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}","14c58917c9d82fa6db5387dd24350ac4":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttype want struct {\n\t\tv   *Value\n\t\ttail string\n\t\terr  error\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant want\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:    \"\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  fmt.Errorf(\"cannot parse empty string\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{\\\"a\\\": 1}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"{\\\"a\\\": 1}\",\n\t\t\t\terr:  fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{\\\"a\\\": 1}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"a\",\n\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1, 2, 3]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:    \"\\\"hello\\\"\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: typeRawString,\n\t\t\t\t\ts: \"hello\",\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:    \"true\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueTrue,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:    \"false\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueFalse,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:    \"null\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueNull,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:    \"123\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"123\",\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotV, gotTail, gotErr := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif !jsonEqual(t, gotErr, tt.want.err) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !jsonEqual(t, gotV, tt.want.v) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotTail != tt.want.tail {\n\t\t\t\tt.Errorf(\"parseValue() gotTail = %v, want %v\", gotTail, tt.want.tail)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc jsonEqual(t *testing.T, a, b interface{}) bool {\n\taJSON, err := json.Marshal(a)\n\tif err != nil {\n\t\tt.Errorf(\"json.Marshal(a) error: %v\", err)\n\t\treturn false\n\t}\n\tbJSON, err := json.Marshal(b)\n\tif err != nil {\n\t\tt.Errorf(\"json.Marshal(b) error: %v\", err)\n\t\treturn false\n\t}\n\treturn string(aJSON) == string(bJSON)\n}\n","14fbe10b0680f4221116e7b1870b9a89":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseArray() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","15857d05467c9fab2c5649930ceed954":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no whitespace\",\n\t\t\targs: args{s: \"abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace\",\n\t\t\targs: args{s: \"  abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailing whitespace\",\n\t\t\targs: args{s: \"abc  \"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"mixed whitespace\",\n\t\t\targs: args{s: \"  abc  \"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading and internal whitespace\",\n\t\t\targs: args{s: \"  a b c  \"},\n\t\t\twant: \"a b c  \",\n\t\t},\n\t\t{\n\t\t\tname: \"all whitespace\",\n\t\t\targs: args{s: \"   \"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading tab\",\n\t\t\targs: args{s: \"\\tabc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading newline\",\n\t\t\targs: args{s: \"\\nabc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading carriage return\",\n\t\t\targs: args{s: \"\\rabc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading control character\",\n\t\t\targs: args{s: \"\\x01abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"internal whitespace\",\n\t\t\targs: args{s: \"a b c\"},\n\t\t\twant: \"b c\",\n\t\t},\n\t\t{\n\t\t\tname: \"internal tab\",\n\t\t\targs: args{s: \"a\\tbc\"},\n\t\t\twant: \"bc\",\n\t\t},\n\t\t{\n\t\t\tname: \"internal newline\",\n\t\t\targs: args{s: \"a\\nbc\"},\n\t\t\twant: \"bc\",\n\t\t},\n\t\t{\n\t\t\tname: \"internal carriage return\",\n\t\t\targs: args{s: \"a\\rbc\"},\n\t\t\twant: \"bc\",\n\t\t},\n\t\t{\n\t\t\tname: \"internal control character\",\n\t\t\targs: args{s: \"a\\x01bc\"},\n\t\t\twant: \"bc\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","15a1bd9c4cb7d2c8250487d176211055":"package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061hello\\\\u0062 world\"},\n\t\t\twant: \"ahello b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01hello\\\\uD83D\\\\uDE02 world\"},\n\t\t\twant: \"😁hello😂 world\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\ world\"},\n\t\t\twant: \"\\\\xhello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete unicode escape sequence\",\n\t\t\targs: args{s: \"\\\\u006hello\\\\ world\"},\n\t\t\twant: \"\\\\u006hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE0hello\\\\ world\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE0hello\\\\ world\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","15d7ed731d71f30fb541c89324e4ba82":"```go\npackage fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantV   *Value\n\t\twantTail string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:    \"\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV:   nil,\n\t\t\twantTail: \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{\\\"a\\\":1}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twantV:   nil,\n\t\t\twantTail: \"{}\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{\\\"a\\\":1}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"a\",\n\t\t\t\t\t\t\tv: \u0026Value{\n","164ccc2a2be2f8e88436d7a4daedb07f":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttype want struct {\n\t\tv   *Value\n\t\ttail string\n\t\terr  error\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant want\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:    \"\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  fmt.Errorf(\"cannot parse empty string\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"{}\",\n\t\t\t\terr:  fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{ \\\"key\\\": \\\"value\\\" }\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1, 2, 3]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:    \"\\\"string\\\"\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeString,\n\t\t\t\t\ts: \"string\",\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:    \"true\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueTrue,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:    \"false\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueFalse,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:    \"null\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueNull,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:    \"123\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"123\",\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:    \"NaN\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"NaN\",\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected value\",\n\t\t\targs: args{\n\t\t\t\ts:    \"unexpected\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"unexpected\",\n\t\t\t\terr:  fmt.Errorf(\"unexpected value found: %q\", \"unexpected\"),\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotV, gotTail, gotErr := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif gotErr != nil \u0026\u0026 tt.want.err == nil {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, want nil\", gotErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotErr == nil \u0026\u0026 tt.want.err != nil {\n\t\t\t\tt.Errorf(\"parseValue() error = nil, want %v\", tt.want.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotErr != nil \u0026\u0026 tt.want.err != nil {\n\t\t\t\tif gotErr.Error() != tt.want.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue() error = %v, want %v\", gotErr, tt.want.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(gotV, tt.want.v) {\n\t\t\t\tt.Errorf(\"parseValue() gotV = %v, want %v\", gotV, tt.want.v)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotTail != tt.want.tail {\n\t\t\t\tt.Errorf(\"parseValue() gotTail = %v, want %v\", gotTail, tt.want.tail)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseValue_MarshalJSON(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{ \\\"key\\\": \\\"value\\\" }\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: `{\"key\":\"value\"}`,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1, 2, 3]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: `[1,2,3]`,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:    \"\\\"string\\\"\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: `\"string\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:    \"true\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: `true`,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:    \"false\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: `false`,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:    \"null\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: `null`,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:    \"123\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: `123`,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:    \"NaN\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: `\"NaN\"`,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotV, _, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"parseValue() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgot, err := json.Marshal(gotV)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"json.Marshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif string(got) != tt.want {\n\t\t\t\tt.Errorf(\"json.Marshal() got = %v, want %v\", string(got), tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","16723f2ffc32b29d413163cff8fbb420":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escaped strings\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"test\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"test\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: ``,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with no quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `hello`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","1776fcb07dc4d492159b07148dfcd15c":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGet(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant *Value\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.Get(tt.args.keys...); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Get() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","17b32a79b708d7306585f51b4a70cf38":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escape sequences\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with multiple escape sequences\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\"world\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote and other characters\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote and other characters\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped backslash\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\\world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped backslash and quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\\\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped backslash and quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\\\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: ``,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with no quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","19b178d5d315f1ee4a910530c85798c5":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"testing\"\n\t\"unicode/utf16\"\n\t\"strconv\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character\",\n\t\t\targs: args{s: \"\\\\u0061hello\\\\u0062 world\"},\n\t\t\twant: \"ahello b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01hello\\\\uD83D\\\\uDE02 world\"},\n\t\t\twant: \"😀hello😁 world\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"short escape sequence\",\n\t\t\targs: args{s: \"\\\\uhello world\"},\n\t\t\twant: \"\\\\uhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid second part\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01hello\\\\uD83D\\\\uDE world\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01hello\\\\uD83D\\\\uDE world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with missing second part\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01hello world\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped character with missing backslash\",\n\t\t\targs: args{s: \"hello\\\\ world\"},\n\t\t\twant: \"hello\\\\ world\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestUnescapeStringBestEffort_JSON(t *testing.T) {\n\ttype TestData struct {\n\t\tKey1 string `json:\"key1\"`\n\t\tKey2 string `json:\"key2\"`\n\t}\n\ttests := []struct {\n\t\tname   string\n\t\tinput  string\n\t\toutput string\n\t}{\n\t\t{\n\t\t\tname: \"basic\",\n\t\t\tinput: `{\"key1\":\"hello\\\\\" world\\\\\", \\\\\"key2\\\\\":\\\\\"world\\\\\"\"}`,\n\t\t\toutput: `{\"key1\":\"hello\\\" world\\\", \"key2\":\"world\"}`,\n\t\t},\n\t\t{\n\t\t\tname: \"unicode\",\n\t\t\tinput: `{\"key1\":\"hello\\\\u0061 world\\\\\", \\\\\"key2\\\\\":\\\\\"world\\\\u0062\\\\\"\"}`,\n\t\t\toutput: `{\"key1\":\"helloa world\", \"key2\":\"worldb\"}`,\n\t\t},\n\t\t{\n\t\t\tname: \"surrogate pair\",\n\t\t\tinput: `{\"key1\":\"hello\\\\uD83D\\\\uDE01 world\\\\\", \\\\\"key2\\\\\":\\\\\"world\\\\uD83D\\\\uDE02\\\\\"\"}`,\n\t\t\toutput: `{\"key1\":\"hello😀 world\", \"key2\":\"world😁\"}`,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\tinput: `{\"key1\":\"hello\\\\x world\\\\\", \\\\\"key2\\\\\":\\\\\"world\\\\x\\\\\"\"}`,\n\t\t\toutput: `{\"key1\":\"hello\\\\x world\\\\\", \"key2\":\"world\\\\x\\\\\"\"}`,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tvar data TestData\n\t\t\terr := json.Unmarshal([]byte(tt.input), \u0026data)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\texpected := TestData{\n\t\t\t\tKey1: unescapeStringBestEffort(data.Key1),\n\t\t\t\tKey2: unescapeStringBestEffort(data.Key2),\n\t\t\t}\n\t\t\tactualJSON, err := json.Marshal(expected)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"json.Marshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif string(actualJSON) != tt.output {\n\t\t\t\tt.Errorf(\"unescaped JSON: got %s, want %s\", string(actualJSON), tt.output)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestUnescapeStringBestEffort_SurrogatePair(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"valid surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"😀\",\n\t\t},\n\t\t{\n\t\t\tname: \"valid surrogate pair with extra characters\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01hello\"},\n\t\t\twant: \"😀hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid surrogate pair with extra characters\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDEhello\"},\n\t\t\twant: \"\\\\uD83D\\\\uDEhello\",\n\t\t},\n\t\t{\n\t\t\tname: \"missing second part\",\n\t\t\targs: args{s: \"\\\\uD83D\"},\n\t\t\twant: \"\\\\uD83D\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestUnescapeStringBestEffort_HexEscape(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"valid hex escape\",\n\t\t\targs: args{s: \"\\\\u0061\"},\n\t\t\twant: \"a\",\n\t\t},\n\t\t{\n\t\t\tname: \"valid hex escape with extra characters\",\n\t\t\targs: args{s: \"\\\\u0061hello\"},\n\t\t\twant: \"ahello\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid hex escape\",\n\t\t\targs: args{s: \"\\\\u006\"},\n\t\t\twant: \"\\\\u006\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid hex escape with extra characters\",\n\t\t\targs: args{s: \"\\\\u006hello\"},\n\t\t\twant: \"\\\\u006hello\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestUnescapeStringBestEffort_InvalidEscapeSequences(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"short escape sequence\",\n\t\t\targs: args{s: \"\\\\uhello world\"},\n\t\t\twant: \"\\\\uhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped character with missing backslash\",\n\t\t\targs: args{s: \"hello\\\\ world\"},\n\t\t\twant: \"hello\\\\ world\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestUnescapeStringBestEffort_Performance(t *testing.T) {\n\tescapedString := `{\"key1\":\"hello\\\\\" world\\\\\", \\\\\"key2\\\\\":\\\\\"world\\\\\"\"}`\n\tunescapedString := `{\"key1\":\"hello\\\" world\\\", \"key2\":\"world\"}`\n\tfor i := 0; i \u003c 10000; i++ {\n\t\tunescapeStringBestEffort(escapedString)\n\t}\n\tfor i := 0; i \u003c 10000; i++ {\n\t\tjson.Unmarshal([]byte(escapedString), nil)\n\t}\n}\n\nfunc BenchmarkUnescapeStringBestEffort(b *testing.B) {\n\tescapedString := `{\"key1\":\"hello\\\\\" world\\\\\", \\\\\"key2\\\\\":\\\\\"world\\\\\"\"}`\n\tfor i := 0; i \u003c b.N; i++ {\n\t\tunescapeStringBestEffort(escapedString)\n\t}\n}\n\nfunc BenchmarkJSONUnmarshal(b *testing.B) {\n\tescapedString := `{\"key1\":\"hello\\\\\" world\\\\\", \\\\\"key2\\\\\":\\\\\"world\\\\\"\"}`\n\tfor i := 0; i \u003c b.N; i++ {\n\t\tjson.Unmarshal([]byte(escapedString), nil)\n\t}\n}\n\nfunc BenchmarkUnescapeStringBestEffort_SurrogatePair(b *testing.B) {\n\tescapedString := `{\"key1\":\"hello\\\\uD83D\\\\uDE01 world\\\\\", \\\\\"key2\\\\\":\\\\\"world\\\\uD83D\\\\uDE02\\\\\"\"}`\n\tfor i := 0; i \u003c b.N; i++ {\n\t\tunescapeStringBestEffort(escapedString)\n\t}\n}\n\nfunc BenchmarkJSONUnmarshal_SurrogatePair(b *testing.B) {\n\tescapedString := `{\"key1\":\"hello\\\\uD83D\\\\uDE01 world\\\\\", \\\\\"key2\\\\\":\\\\\"world\\\\uD83D\\\\uDE02\\\\\"\"}`\n\tfor i := 0; i \u003c b.N; i++ {\n\t\tjson.Unmarshal([]byte(escapedString), nil)\n\t}\n}\n\nfunc BenchmarkUnescapeStringBestEffort_HexEscape(b *testing.B) {\n\tescapedString := `{\"key1\":\"hello\\\\u0061 world\\\\\", \\\\\"key2\\\\\":\\\\\"world\\\\u0062\\\\\"\"}`\n\tfor i := 0; i \u003c b.N; i++ {\n\t\tunescapeStringBestEffort(escapedString)\n\t}\n}\n\nfunc BenchmarkJSONUnmarshal_HexEscape(b *testing.B) {\n\tescapedString := `{\"key1\":\"hello\\\\u0061 world\\\\\", \\\\\"key2\\\\\":\\\\\"world\\\\u0062\\\\\"\"}`\n\tfor i := 0; i \u003c b.N; i++ {\n\t\tjson.Unmarshal([]byte(escapedString), nil)\n\t}\n}","19b3a5701e18b77f98195cf754c31c57":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\"world\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quotes and other characters\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\"world\\\\\"!\\t\\n\\r\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"!\\t\\n\\r\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quotes and unicode\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\"world\\\\\"\\u0061\\u0062\\u0063\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"abc\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with no opening quote\",\n\t\t\targs: args{\n\t\t\t\ts: `hello\"`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: ``,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","19cc1c015d27484dc43e312ff7b721be":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    \u0026Value{t: TypeArray, a: []*Value{}},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"single element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[\\\"test\\\"]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    \u0026Value{t: TypeArray, a: []*Value{\u0026Value{t: TypeString, s: \"test\"}}},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1, 2, 3]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    \u0026Value{t: TypeArray, a: []*Value{\u0026Value{t: TypeNumber, s: \"1\"}, \u0026Value{t: TypeNumber, s: \"2\"}, \u0026Value{t: TypeNumber, s: \"3\"}}},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[[1, 2], [3, 4]]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    \u0026Value{t: TypeArray, a: []*Value{\u0026Value{t: TypeArray, a: []*Value{\u0026Value{t: TypeNumber, s: \"1\"}, \u0026Value{t: TypeNumber, s: \"2\"}}}, \u0026Value{t: TypeArray, a: []*Value{\u0026Value{t: TypeNumber, s: \"3\"}, \u0026Value{t: TypeNumber, s: \"4\"}}}},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1, 2\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1, 2\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1 2]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1 2]\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseArray() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","1aa906ed44c98caf0327578912d5774d":"package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061hello\\\\u0062 world\"},\n\t\t\twant: \"ahello b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode surrogate\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01hello\\\\uD83D\\\\uDE02 world\"},\n\t\t\twant: \"😁hello😂 world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode\",\n\t\t\targs: args{s: \"\\\\u0061hello\\\\uINVALID world\"},\n\t\t\twant: \"\\\\uINVALID world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped too short unicode\",\n\t\t\targs: args{s: \"\\\\u0061hello\\\\u world\"},\n\t\t\twant: \"\\\\u world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unknown sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\uD83D\\\\uDE01\\\\uINVALID\\\\x\"},\n\t\t\twant: \"\\\"hello\\\" \\\\world\\b\\f\\n\\r\\ta😁\\\\uINVALID\\\\x\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","1b0cb5367fdb39bc465b2887e82894b3":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestString(t *testing.T) {\n\ttype args struct {\n\t\tt Type\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"TestString_TypeObject\",\n\t\t\targs: args{\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\twant: \"object\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestString_TypeArray\",\n\t\t\targs: args{\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\twant: \"array\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestString_TypeString\",\n\t\t\targs: args{\n\t\t\t\tt: TypeString,\n\t\t\t},\n\t\t\twant: \"string\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestString_TypeNumber\",\n\t\t\targs: args{\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\twant: \"number\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestString_TypeTrue\",\n\t\t\targs: args{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: \"true\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestString_TypeFalse\",\n\t\t\targs: args{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: \"false\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestString_TypeNull\",\n\t\t\targs: args{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: \"null\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.t.String(); got != tt.want {\n\t\t\t\tt.Errorf(\"String() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","1bca194f17562f1a6b2bfbc4f35dc226":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCacheGetValue(t *testing.T) {\n\tt.Run(\"EmptyCache\", func(t *testing.T) {\n\t\tc := \u0026cache{}\n\t\tv := c.getValue()\n\t\tif v == nil {\n\t\t\tt.Errorf(\"getValue() returned nil for empty cache\")\n\t\t}\n\t})\n\n\tt.Run(\"NonEmptyCache\", func(t *testing.T) {\n\t\tc := \u0026cache{vs: []Value{{t: TypeNull}}}\n\t\tv := c.getValue()\n\t\tif v == nil {\n\t\t\tt.Errorf(\"getValue() returned nil for non-empty cache\")\n\t\t}\n\t\tif v.t != TypeNull {\n\t\t\tt.Errorf(\"getValue() returned value with unexpected type: got %v, want %v\", v.t, TypeNull)\n\t\t}\n\t})\n\n\tt.Run(\"CapacityGreaterThanLength\", func(t *testing.T) {\n\t\tc := \u0026cache{vs: make([]Value, 1, 3)}\n\t\tv := c.getValue()\n\t\tif v == nil {\n\t\t\tt.Errorf(\"getValue() returned nil for cache with capacity \u003e length\")\n\t\t}\n\t\tif v.t != TypeNull {\n\t\t\tt.Errorf(\"getValue() returned value with unexpected type: got %v, want %v\", v.t, TypeNull)\n\t\t}\n\t\tif len(c.vs) != 2 {\n\t\t\tt.Errorf(\"getValue() did not extend the slice to length + 2\")\n\t\t}\n\t})\n}","1c00ead46802235ac5eed2c1d0ca0b65":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetStringBytes(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.GetStringBytes(tt.args.keys...); !bytes.Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.GetStringBytes() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","1c610a9276eeb78e756f2c509ddd525f":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: `\\\"hello world\\\"`},\n\t\t\twant: `\"hello world\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: `\\\\hello world`},\n\t\t\twant: `\\hello world`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: `\\/hello world`},\n\t\t\twant: `/hello world`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: `\\bhello world`},\n\t\t\twant: \"\\bhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: `\\fhello world`},\n\t\t\twant: \"\\fhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: `\\nhello world`},\n\t\t\twant: \"\\nhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: `\\rhello world`},\n\t\t\twant: \"\\rhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: `\\thello world`},\n\t\t\twant: \"\\thello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: `\\u0061hello world`},\n\t\t\twant: \"ahello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode surrogate\",\n\t\t\targs: args{s: `\\uD83D\\uDE01hello world`},\n\t\t\twant: \"😁hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: `\\xhello world`},\n\t\t\twant: `\\xhello world`,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: `\\\"hello\\\\world\\n\\t\\u0061\\uD83D\\uDE01\\\"`},\n\t\t\twant: `\"hello\\world\\n\\ta😁\"`,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestUnescapeStringBestEffort_JSON(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: `\\\"hello world\\\"`},\n\t\t\twant: `\"hello world\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: `\\\\hello world`},\n\t\t\twant: `\\hello world`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: `\\/hello world`},\n\t\t\twant: `/hello world`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: `\\bhello world`},\n\t\t\twant: \"\\bhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: `\\fhello world`},\n\t\t\twant: \"\\fhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: `\\nhello world`},\n\t\t\twant: \"\\nhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: `\\rhello world`},\n\t\t\twant: \"\\rhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: `\\thello world`},\n\t\t\twant: \"\\thello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: `\\u0061hello world`},\n\t\t\twant: \"ahello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode surrogate\",\n\t\t\targs: args{s: `\\uD83D\\uDE01hello world`},\n\t\t\twant: \"😁hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: `\\xhello world`},\n\t\t\twant: `\\xhello world`,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: `\\\"hello\\\\world\\n\\t\\u0061\\uD83D\\uDE01\\\"`},\n\t\t\twant: `\"hello\\world\\n\\ta😁\"`,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t// Parse the JSON string using the standard library\n\t\t\tvar parsed interface{}\n\t\t\terr := json.Unmarshal([]byte(`\"`+tt.args.s+`\"`), \u0026parsed)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Marshal the parsed JSON string back to a string\n\t\t\tmarshaled, err := json.Marshal(parsed)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"json.Marshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Compare the marshaled string to the expected string\n\t\t\tgot := string(marshaled)\n\t\t\tif got != `\"`+tt.want+`\"` {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, `\"`+tt.want+`\"`)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestUnescapeStringBestEffort_strconv(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: `\\u0061hello world`},\n\t\t\twant: \"ahello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode surrogate\",\n\t\t\targs: args{s: `\\uD83D\\uDE01hello world`},\n\t\t\twant: \"😁hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: `\\xhello world`},\n\t\t\twant: `\\xhello world`,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t// Parse the unicode escape sequence using strconv\n\t\t\tr, err := strconv.Unquote(`\"` + tt.args.s + `\"`)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"strconv.Unquote() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Compare the parsed string to the expected string\n\t\t\tgot := r\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestUnescapeStringBestEffort_utf16(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"escaped unicode surrogate\",\n\t\t\targs: args{s: `\\uD83D\\uDE01hello world`},\n\t\t\twant: \"😁hello world\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t// Parse the unicode surrogate escape sequence using utf16.DecodeRune\n\t\t\tvar runes []rune\n\t\t\tfor i := 0; i \u003c len(tt.args.s); i += 6 {\n\t\t\t\tif i+6 \u003e len(tt.args.s) {\n\t\t\t\t\trunes = append(runes, []rune(tt.args.s[i:])...)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tx, err := strconv.ParseUint(tt.args.s[i+2:i+6], 16, 15)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"strconv.ParseUint() error = %v\", err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tx1, err := strconv.ParseUint(tt.args.s[i+8:i+12], 16, 15)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"strconv.ParseUint() error = %v\", err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tr := utf16.DecodeRune(rune(x), rune(x1))\n\t\t\t\trunes = append(runes, r)\n\t\t\t}\n\n\t\t\t// Compare the parsed string to the expected string\n\t\t\tgot := string(runes)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","1ce43c5fa81158f58acaadeba7b8f216":"```go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestString(t *testing.T) {\n\ttype args struct {\n\t\tt Type\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"TestString_Object\",\n\t\t\targs: args{t: TypeObject},\n\t\t\twant: \"object\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestString_Array\",\n\t\t\targs: args{t: TypeArray},\n\t\t\twant: \"array\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestString_String\",\n\t\t\targs: args{t: TypeString},\n\t\t\twant: \"string\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestString_Number\",\n\t\t\targs: args{t: TypeNumber},\n\t\t\twant: \"number\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestString_True\",\n\t\t\targs: args{t: TypeTrue},\n\t\t\twant: \"true\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestString_False\",\n\t\t\targs: args{t: TypeFalse},\n\t\t\twant: \"false\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestString_Null\",\n\t\t\targs: args{t: TypeNull},\n\t\t\twant: \"null\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.","1d6102038107577e8f368fb5065b7559":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"valid number\",\n\t\t\targs:    args{s: \"123\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"valid number with decimal\",\n\t\t\targs:    args{s: \"123.456\"},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"valid number with exponent\",\n\t\t\targs:    args{s: \"1.23e+4\"},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"valid number with negative sign\",\n\t\t\targs:    args{s: \"-123\"},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"valid number with plus sign\",\n\t\t\targs:    args{s: \"+123\"},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading whitespace\",\n\t\t\targs:    args{s: \" 123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" 123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with trailing whitespace\",\n\t\t\targs:    args{s: \"123 \"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \" \",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with invalid character\",\n\t\t\targs:    args{s: \"123a\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with inf\",\n\t\t\targs:    args{s: \"inf\"},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading plus sign\",\n\t\t\targs:    args{s: \"+123a\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+123a\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading minus sign\",\n\t\t\targs:    args{s: \"-123a\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"-123a\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}","1dca8b16fd1f12843f54c38e028842d2":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetUint(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant uint\n\t}{\n\t\t// TODO: Add test cases.\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\tv:    \u0026Value{t: TypeObject, o: Object{kvs: nil}},\n\t\t\targs: args{keys: []string{\"a\"}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"non-existing key\",\n\t\t\tv:    \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"a\", v: \u0026Value{t: TypeNumber, s: \"1\"}}}}},\n\t\t\targs: args{keys: []string{\"b\"}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid value type\",\n\t\t\tv:    \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"a\", v: \u0026Value{t: TypeString, s: \"1\"}}}}},\n\t\t\targs: args{keys: []string{\"a\"}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"valid uint\",\n\t\t\tv:    \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"a\", v: \u0026Value{t: TypeNumber, s: \"1\"}}}}},\n\t\t\targs: args{keys: []string{\"a\"}},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"valid uint with large number\",\n\t\t\tv:    \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"a\", v: \u0026Value{t: TypeNumber, s: \"18446744073709551615\"}}}}},\n\t\t\targs: args{keys: []string{\"a\"}},\n\t\t\twant: 18446744073709551615,\n\t\t},\n\t\t{\n\t\t\tname: \"valid uint with negative number\",\n\t\t\tv:    \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"a\", v: \u0026Value{t: TypeNumber, s: \"-1\"}}}}},\n\t\t\targs: args{keys: []string{\"a\"}},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.GetUint(tt.args.keys...); got != tt.want {\n\t\t\t\tt.Errorf(\"Value.GetUint() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","1ea4de15947de5848d3c8cf899c4801a":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestString(t *testing.T) {\n\ttype args struct {\n\t\tt Type\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"TestString_TypeObject\",\n\t\t\targs: args{\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\twant: \"object\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestString_TypeArray\",\n\t\t\targs: args{\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\twant: \"array\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestString_TypeString\",\n\t\t\targs: args{\n\t\t\t\tt: TypeString,\n\t\t\t},\n\t\t\twant: \"string\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestString_TypeNumber\",\n\t\t\targs: args{\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\twant: \"number\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestString_TypeTrue\",\n\t\t\targs: args{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: \"true\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestString_TypeFalse\",\n\t\t\targs: args{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: \"false\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestString_TypeNull\",\n\t\t\targs: args{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: \"null\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.t.String(); got != tt.want {\n\t\t\t\tt.Errorf(\"String() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","1ef5dafc5651aab64d7c67dcd23d202e":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueGet(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttype want struct {\n\t\twant *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant want\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\tv:    \u0026Value{t: TypeObject, o: Object{}},\n\t\t\targs: args{keys: []string{\"foo\"}},\n\t\t\twant: want{want: nil},\n\t\t},\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\tv:    \u0026Value{t: TypeArray, a: []*Value{}},\n\t\t\targs: args{keys: []string{\"0\"}},\n\t\t\twant: want{want: nil},\n\t\t},\n\t\t{\n\t\t\tname: \"get object value\",\n\t\t\tv:    \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: TypeString, s: \"bar\"}}}}},\n\t\t\targs: args{keys: []string{\"foo\"}},\n\t\t\twant: want{want: \u0026Value{t: TypeString, s: \"bar\"}},\n\t\t},\n\t\t{\n\t\t\tname: \"get array value\",\n\t\t\tv:    \u0026Value{t: TypeArray, a: []*Value{{t: TypeString, s: \"bar\"}}},\n\t\t\targs: args{keys: []string{\"0\"}},\n\t\t\twant: want{want: \u0026Value{t: TypeString, s: \"bar\"}},\n\t\t},\n\t\t{\n\t\t\tname: \"get nested object value\",\n\t\t\tv:    \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"bar\", v: \u0026Value{t: TypeString, s: \"baz\"}}}}}}}}},\n\t\t\targs: args{keys: []string{\"foo\", \"bar\"}},\n\t\t\twant: want{want: \u0026Value{t: TypeString, s: \"baz\"}},\n\t\t},\n\t\t{\n\t\t\tname: \"get nested array value\",\n\t\t\tv:    \u0026Value{t: TypeArray, a: []*Value{{t: TypeArray, a: []*Value{{t: TypeString, s: \"baz\"}}}}},\n\t\t\targs: args{keys: []string{\"0\", \"0\"}},\n\t\t\twant: want{want: \u0026Value{t: TypeString, s: \"baz\"}},\n\t\t},\n\t\t{\n\t\t\tname: \"get non-existing key\",\n\t\t\tv:    \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: TypeString, s: \"bar\"}}}}},\n\t\t\targs: args{keys: []string{\"bar\"}},\n\t\t\twant: want{want: nil},\n\t\t},\n\t\t{\n\t\t\tname: \"get non-existing index\",\n\t\t\tv:    \u0026Value{t: TypeArray, a: []*Value{{t: TypeString, s: \"bar\"}}},\n\t\t\targs: args{keys: []string{\"1\"}},\n\t\t\twant: want{want: nil},\n\t\t},\n\t\t{\n\t\t\tname: \"get invalid index\",\n\t\t\tv:    \u0026Value{t: TypeArray, a: []*Value{{t: TypeString, s: \"bar\"}}},\n\t\t\targs: args{keys: []string{\"-1\"}},\n\t\t\twant: want{want: nil},\n\t\t},\n\t\t{\n\t\t\tname: \"get invalid index 2\",\n\t\t\tv:    \u0026Value{t: TypeArray, a: []*Value{{t: TypeString, s: \"bar\"}}},\n\t\t\targs: args{keys: []string{\"2\"}},\n\t\t\twant: want{want: nil},\n\t\t},\n\t\t{\n\t\t\tname: \"get invalid type\",\n\t\t\tv:    \u0026Value{t: TypeString, s: \"bar\"},\n\t\t\targs: args{keys: []string{\"0\"}},\n\t\t\twant: want{want: nil},\n\t\t},\n\t\t{\n\t\t\tname: \"nil value\",\n\t\t\tv:    nil,\n\t\t\targs: args{keys: []string{\"foo\"}},\n\t\t\twant: want{want: nil},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.Get(tt.args.keys...); !reflect.DeepEqual(got, tt.want.want) {\n\t\t\t\tt.Errorf(\"Value.Get() = %v, want %v\", got, tt.want.want)\n\t\t\t}\n\t\t})\n\t}\n}","2013af45e79fe47fbf01b0eaa4ee45fa":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"single element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,3]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[[1,2],[3,4]]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"4\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with string\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[\\\"hello\\\", \\\"world\\\"]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"hello\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"world\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with invalid value\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \",\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"array with missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1,2\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseArray() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","20b5c1c1a4dfaafd124f9ff342248bef":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"float\",\n\t\t\targs: args{\n\t\t\t\ts: \"12.34\",\n\t\t\t},\n\t\t\twantNs:  \"12.34\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential notation\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"positive infinity\",\n\t\t\targs: args{\n\t\t\t\ts: \"inf\",\n\t\t\t},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative infinity\",\n\t\t\targs: args{\n\t\t\t\ts: \"-inf\",\n\t\t\t},\n\t\t\twantNs:  \"-inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twantNs:  \"NaN\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123x\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"123x\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}","20bdc202f514624e2445ff26eb23a8bf":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_unescapeKeys(t *testing.T) {\n\ttype args struct {\n\t\to *Object\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant *Object\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\ttt.args.o.unescapeKeys()\n\t\t\tif !reflect.DeepEqual(tt.args.o, tt.want) {\n\t\t\t\tt.Errorf(\"Object.unescapeKeys() = %v, want %v\", tt.args.o, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","20c0b47d55f6f1274b8c35f08b22d4a0":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escaped strings\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"foo\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\\\\\\\"foo\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: ``,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with no quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `hello`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n","20c410e6014f42776532d2abe3f935ad":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"no escape\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello world\"`,\n\t\t\t},\n\t\t\twant:    \"hello world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello \\\"world\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello \\\"world\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslash\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello \\\\world!\"`,\n\t\t\t},\n\t\t\twant:    \"hello \\\\world!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello \\\\\\\"world\\\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello \\\\\\\"world\\\\\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello world`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: ``,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace\",\n\t\t\targs: args{\n\t\t\t\ts: ` \"hello world\"`,\n\t\t\t},\n\t\t\twant:    \"hello world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"trailing whitespace\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello world\" `,\n\t\t\t},\n\t\t\twant:    \"hello world\",\n\t\t\twant1:   \" \",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"leading and trailing whitespace\",\n\t\t\targs: args{\n\t\t\t\ts: ` \"hello world\" `,\n\t\t\t},\n\t\t\twant:    \"hello world\",\n\t\t\twant1:   \" \",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quote in the middle\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello \\\"world\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello \\\"world\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","20f4fca86896e8b2a8b5f24aff6e129d":"```go\npackage fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequence\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quote\",\n\t\t\targs: args{s: \"\\\\\\\"\"},\n\t\t\twant: \"\\\"\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslash\",\n\t\t\targs: args{s: \"\\\\\\\\\"},\n\t\t\twant: \"\\\\\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped slash\",\n\t\t\targs: args{s: \"\\\\/\"},\n\t\t\twant: \"/\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\b\"},\n\t\t\twant: \"\\b\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\f\"},\n\t\t\twant: \"\\f\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\n\"},\n\t\t\twant: \"\\n\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\r\"},\n\t\t\twant: \"\\r\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\t\"},\n\t\t\twant: \"\\t\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character\",\n\t\t\targs: args{s: \"\\\\u0061\"},\n\t\t\twant: \"a\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"😁\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence\",\n\t\t\targs: args{s: \"\\\\u00\"},\n\t\t\twant: \"\\\\u00\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence 2\",\n\t\t\targs: args{s: \"\\\\u000\"},\n\t\t\twant: \"\\\\u000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence 3\",\n\t\t\targs: args{s: \"\\\\u0000\"},\n\t\t\twant: \"\\\\u0000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence 4\",\n\t\t\targs: args{s: \"\\\\u00000\"},\n\t\t\twant: \"\\\\u00000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence 5\",\n\t\t\targs: args{s: \"\\\\u000000\"},\n\t\t\twant: \"\\\\u000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence 6\",\n\t\t\targs: args{s: \"\\\\u0000000\"},\n\t\t\twant: \"\\\\u0000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence 7\",\n\t\t\targs: args{s: \"\\\\u00000000\"},\n\t\t\twant: \"\\\\u00000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence 8\",\n\t\t\targs: args{s: \"\\\\u000000000\"},\n\t\t\twant: \"\\\\u000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence 9\",\n\t\t\targs: args{s: \"\\\\u0000000000\"},\n\t\t\twant: \"\\\\u0000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence 10\",\n\t\t\targs: args{s: \"\\\\u00000000000\"},\n\t\t\twant: \"\\\\u00000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence 11\",\n\t\t\targs: args{s: \"\\\\u000000000000\"},\n\t\t\twant: \"\\\\u000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence 12\",\n\t\t\targs: args{s: \"\\\\u0000000000000\"},\n\t\t\twant: \"\\\\u0000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence 13\",\n\t\t\targs: args{s: \"\\\\u00000000000000\"},\n\t\t\twant: \"\\\\u00000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence 14\",\n\t\t\targs: args{s: \"\\\\u000000000000000\"},\n\t\t\twant: \"\\\\u000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence 15\",\n\t\t\targs: args{s: \"\\\\u0000000000000000\"},\n\t\t\twant: \"\\\\u0000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence 16\",\n\t\t\targs: args{s: \"\\\\u00000000000000000\"},\n\t\t\twant: \"\\\\u00000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence 17\",\n\t\t\targs: args{s: \"\\\\u000000000000000000\"},\n\t\t\twant: \"\\\\u000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence 18\",\n\t\t\targs: args{s: \"\\\\u0000000000000000000\"},\n\t\t\twant: \"\\\\u0000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence 19\",\n\t\t\targs: args{s: \"\\\\u00000000000000000000\"},\n\t\t\twant: \"\\\\u00000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence 20\",\n\t\t\targs: args{s: \"\\\\u000000000000000000000\"},\n\t\t\twant: \"\\\\u000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence 21\",\n\t\t\targs: args{s: \"\\\\u0000000000000000000000\"},\n\t\t\twant: \"\\\\u0000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence 22\",\n\t\t\targs: args{s: \"\\\\u00000000000000000000000\"},\n\t\t\twant: \"\\\\u00000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence 23\",\n\t\t\targs: args{s: \"\\\\u000000000000000000000000\"},\n\t\t\twant: \"\\\\u000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence 24\",\n\t\t\targs: args{s: \"\\\\u0000000000000000000000000\"},\n\t\t\twant: \"\\\\u0000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence 25\",\n\t\t\targs: args{s: \"\\\\u00000000000000000000000000\"},\n\t\t\twant: \"\\\\u00000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence 26\",\n\t\t\targs: args{s: \"\\\\u000000000000000000000000000\"},\n\t\t\twant: \"\\\\u000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence 27\",\n\t\t\targs: args{s: \"\\\\u0000000000000000000000000000\"},\n\t\t\twant: \"\\\\u0000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence 28\",\n\t\t\targs: args{s: \"\\\\u00000000000000000000000000000\"},\n\t\t\twant: \"\\\\u00000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence 29\",\n\t\t\targs: args{s: \"\\\\u000000000000000000000000000000\"},\n\t\t\twant: \"\\\\u000000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence 30\",\n\t\t\targs: args{s: \"\\\\u0000000000000000000000000000000\"},\n\t\t\twant: \"\\\\u0000000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence 31\",\n\t\t\targs: args{s: \"\\\\u00000000000000000000000000000000\"},\n\t\t\twant: \"\\\\u00000000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence 32\",\n\t\t\targs: args{s: \"\\\\u000000000000000000000000000000000\"},\n\t\t\twant: \"\\\\u000000000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence 33\",\n\t\t\targs: args{s: \"\\\\u0000000000000000000000000000000000\"},\n\t\t\twant: \"\\\\u0000000000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence 34\",\n\t\t\targs: args{s: \"\\\\u00000000000000000000000000000000000\"},\n\t\t\twant: \"\\\\u00000000000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence 35\",\n\t\t\targs: args{s: \"\\\\u000000000000000000000000000000000000\"},\n\t\t\twant: \"\\\\u000000000000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence 36\",\n\t\t\targs: args{s: \"\\\\u0000000000000000000000000000000000000\"},\n\t\t\twant: \"\\\\u0000000000000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence 37\",\n\t\t\targs: args{s: \"\\\\u00000000000000000000000000000000000000\"},\n\t\t\twant: \"\\\\u00000000000000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence 38\",\n\t\t\targs: args{s: \"\\\\u000000000000000000000000000000000000000\"},\n\t\t\twant: \"\\\\u000000000000000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence 39\",\n\t\t\targs: args{s: \"\\\\u0000000000000000000000000000000000000000\"},\n\t\t\twant: \"\\\\u0000000000000000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence 40\",\n\t\t\targs: args{s: \"\\\\u00000000000000000000000000000000000000000\"},\n\t\t\twant: \"\\\\u00000000000000000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence 41\",\n\t\t\targs: args{s: \"\\\\u000000000000000000000000000000000000000000\"},\n\t\t\twant: \"\\\\u000000000000000000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence 42\",\n\t\t\targs: args{s: \"\\\\u0000000000000000000000000000000000000000000\"},\n\t\t\twant: \"\\\\u0000000000000000000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence 43\",\n\t\t\targs: args{s: \"\\\\u00000000000000000000000000000000000000000000\"},\n\t\t\twant: \"\\\\u00000000000000000000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence 44\",\n\t\t\targs: args{s: \"\\\\u000000000000000000000000000000000000000000000\"},\n\t\t\twant: \"\\\\u000000000000000000000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence 45\",\n\t\t\targs: args{s: \"\\\\u0000000000000000000000000000000000000000000000\"},\n\t\t\twant: \"\\\\u0000000000000000000000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence 46\",\n\t\t\targs: args{s: \"\\\\u00000000000000000000000000000000000000000000000\"},\n\t\t\twant: \"\\\\u00000000000000000000000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence 47\",\n\t\t\targs: args{s: \"\\\\u000000000000000000000000000000000000000000000000\"},\n\t\t\twant: \"\\\\u000000000000000000000000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence 48\",\n\t\t\targs: args{s: \"\\\\u0000000000000000000000000000000000000000000000000\"},\n\t\t\twant: \"\\\\u0000000000000000000000000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence 49\",\n\t\t\targs: args{s: \"\\\\u00000000000000000000000000000000000000000000000000\"},\n\t\t\twant: \"\\\\u00000000000000000000000000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence 50\",\n\t\t\targs: args{s: \"\\\\u000000000000000000000000000000000000000000000000000\"},\n\t\t\twant: \"\\\\u000000000000000000000000000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence 51\",\n\t\t\targs: args{s: \"\\\\u0000000000000000000000000000000000000000000000000000\"},\n\t\t\twant: \"\\\\u0000000000000000000000000000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence 52\",\n\t\t\targs: args{s: \"\\\\u00000000000000000000000000000000000000000000000000000\"},\n\t\t\twant: \"\\\\u00000000000000000000000000000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence 53\",\n\t\t\targs: args{s: \"\\\\u000000000000000000000000000000000000000000000000000000\"},\n\t\t\twant: \"\\\\u000000000000000000000000000000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence 54\",\n\t\t\targs: args{s: \"\\\\u0000000000000000000000000000000000000000000000000000000\"},\n\t\t\twant: \"\\\\u0000000000000000000000000000000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence 55\",\n\t\t\targs: args{s: \"\\\\u00000000000000000000000000000000000000000000000000000000\"},\n\t\t\twant: \"\\\\u00000000000000000000000000000000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence 56\",\n\t\t\targs: args{s: \"\\\\u000000000000000000000000000000000000000000000000000000000\"},\n\t\t\twant: \"\\\\u000000000000000000000000000000000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence 57\",\n\t\t\targs: args{s: \"\\\\u0000000000000000000000000000000000000000000000000000000000\"},\n\t\t\twant: \"\\\\u0000000000000000000000000000000000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence 58\",\n\t\t\targs: args{s: \"\\\\u00000000000000000000000000000000000000000000000000000000000\"},\n\t\t\twant: \"\\\\u00000000000000000000000000000000000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence 59\",\n\t\t\targs: args{s: \"\\\\u0000000000000000000000000000000000000000000000000000000000000\"},\n\t\t\twant: \"\\\\u0000000000000000000000000000000000000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence 60\",\n\t\t\targs: args{s: \"\\\\u00000000000000000000000000000000000000000000000000000000000000\"},\n\t\t\twant: \"\\\\u00000000000000000000000000000000000000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence 61\",\n\t\t\targs: args{s: \"\\\\u000000000000000000000000000000000000000000000000000000000000000\"},\n\t\t\twant: \"\\\\u000000000000000000000000000000000000000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence 62\",\n\t\t\targs: args{s: \"\\\\u0000000000000000000000000000000000000000000000000000000000000000\"},\n\t\t\twant: \"\\\\u0000000000000000000000000000000000000000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence 63\",\n\t\t\targs: args{s: \"\\\\u00000000000000000000000000000000000000000000000000000000000000000\"},\n\t\t\twant: \"\\\\u00000000000000000000000000000000000000000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence 64\",\n\t\t\targs: args{s: \"\\\\u000000000000000000000000000000000000000000000000000000000000000000\"},\n\t\t\twant: \"\\\\u000000000000000000000000000000000000000000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence 65\",\n\t\t\targs: args{s: \"\\\\u0000000000000000000000000000000000000000000000000000000000000000000\"},\n\t\t\twant: \"\\\\u0000000000000000000000000000000000000000000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence 66\",\n\t\t\targs: args{s: \"\\\\u00000000000000000000000000000000000000000000000000000000000000000000\"},\n\t\t\twant: \"\\\\u00000000000000000000000000000000000000000000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence 67\",\n\t\t\targs: args{s: \"\\\\u000000000000000000000000000000000000000000000000000000000000000000000\"},\n\t\t\twant: \"\\\\u000000000000000000000000000000000000000000000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence 68\",\n\t\t\targs: args{s: \"\\\\u0000000000000000000000000000000000000000000000000000000000000000000000\"},\n\t\t\twant: \"\\\\u0000000000000000000000000000000000000000000000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence 69\",\n\t\t\targs: args{s: \"\\\\u00000000000000000000000000000000000000000000000000000000000000000000000\"},\n\t\t\twant: \"\\\\u00000000000000000000000000000000000000000000000000000000000000000000000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode sequence 70\",\n\t\t\targs: args{s: \"\\\\u000000000000000000000000000000000000000000000000000000000000000000000000\"},\n\t\t\twant: \"\\\\u000000000000000000000000000000000000000000000000000000000000000000000000\",\n\t\t","2100dd028b870c5605e39b71dc4b7a32":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantV   *Value\n\t\twantTail string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:    \"\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV:   nil,\n\t\t\twantTail: \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"too deep nested JSON\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{\\\"a\\\":{\\\"b\\\":{\\\"c\\\":{\\\"d\\\":{\\\"e\\\":{\\\"f\\\":{\\\"g\\\":{\\\"h\\\":{\\\"i\\\":{\\\"j\\\":{\\\"k\\\":{\\\"l\\\":{\\\"m\\\":{\\\"n\\\":{\\\"o\\\":{\\\"p\\\":{\\\"q\\\":{\\\"r\\\":{\\\"s\\\":{\\\"t\\\":{\\\"u\\\":{\\\"v\\\":{\\\"w\\\":{\\\"x\\\":{\\\"y\\\":{\\\"z\\\":1}}}}}}}}}}}}}}}}}}}}}}}}}}}}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV:   nil,\n\t\t\twantTail: \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{\\\"a\\\":1,\\\"b\\\":\\\"2\\\",\\\"c\\\":[3,4],\\\"d\\\":{\\\"e\\\":5}}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"a\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"b\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: typeRawString,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"c\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\t\ts: \"4\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"d\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"e\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"5\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,3,4,5]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"4\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"5\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:    \"\\\"hello world\\\"\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello world\",\n\t\t\t},\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:    \"true\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV:   valueTrue,\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:    \"false\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV:   valueFalse,\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:    \"null\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV:   valueNull,\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:    \"1234567890\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"1234567890\",\n\t\t\t},\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with decimal\",\n\t\t\targs: args{\n\t\t\t\ts:    \"123.456\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with exponent\",\n\t\t\targs: args{\n\t\t\t\ts:    \"1.234e+5\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"1.234e+5\",\n\t\t\t},\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts:    \"1.234e-5\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"1.234e-5\",\n\t\t\t},\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative sign\",\n\t\t\targs: args{\n\t\t\t\ts:    \"-123\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with positive sign\",\n\t\t\targs: args{\n\t\t\t\ts:    \"+123\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"+123\",\n\t\t\t},\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:    \"NaN\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected value\",\n\t\t\targs: args{\n\t\t\t\ts:    \"trues\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV:   nil,\n\t\t\twantTail: \"trues\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected value 2\",\n\t\t\targs: args{\n\t\t\t\ts:    \"falses\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV:   nil,\n\t\t\twantTail: \"falses\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected value 3\",\n\t\t\targs: args{\n\t\t\t\ts:    \"nulls\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV:   nil,\n\t\t\twantTail: \"nulls\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected value 4\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV:   nil,\n\t\t\twantTail: \"{\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected value 5\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV:   nil,\n\t\t\twantTail: \"[\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected value 6\",\n\t\t\targs: args{\n\t\t\t\ts:    \"\\\"\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV:   nil,\n\t\t\twantTail: \"\\\"\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotV, gotTail, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(gotV, tt.wantV) {\n\t\t\t\tt.Errorf(\"parseValue() gotV = %v, want %v\", gotV, tt.wantV)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseValue() gotTail = %v, want %v\", gotTail, tt.wantTail)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_parseValue_depth(t *testing.T) {\n\tc := \u0026cache{}\n\ts := \"{\"\n\tfor i := 0; i \u003c MaxDepth+1; i++ {\n\t\ts += fmt.Sprintf(\"\\\"a%d\\\":\", i)\n\t\tif i \u003c MaxDepth {\n\t\t\ts += \"{\"\n\t\t} else {\n\t\t\ts += \"1\"\n\t\t}\n\t}\n\tfor i := 0; i \u003c MaxDepth; i++ {\n\t\ts += \"}\"\n\t}\n\t_, _, err := parseValue(s, c, 0)\n\tif err == nil {\n\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, true)\n\t}\n}\n\nfunc Test_parseValue_object(t *testing.T) {\n\tc := \u0026cache{}\n\ts := \"{\\\"a\\\":1,\\\"b\\\":\\\"2\\\",\\\"c\\\":[3,4],\\\"d\\\":{\\\"e\\\":5}}\"\n\tgotV, _, err := parseValue(s, c, 0)\n\tif err != nil {\n\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, false)\n\t}\n\twantV, err := json.Marshal(map[string]interface{}{\n\t\t\"a\": 1,\n\t\t\"b\": \"2\",\n\t\t\"c\": []interface{}{3, 4},\n\t\t\"d\": map[string]interface{}{\n\t\t\t\"e\": 5,\n\t\t},\n\t})\n\tif err != nil {\n\t\tt.Errorf(\"json.Marshal() error = %v, wantErr %v\", err, false)\n\t}\n\tif !reflect.DeepEqual(gotV.MarshalTo(nil), wantV) {\n\t\tt.Errorf(\"parseValue() gotV = %v, want %v\", gotV, wantV)\n\t}\n}\n\nfunc Test_parseValue_array(t *testing.T) {\n\tc := \u0026cache{}\n\ts := \"[1,2,3,4,5]\"\n\tgotV, _, err := parseValue(s, c, 0)\n\tif err != nil {\n\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, false)\n\t}\n\twantV, err := json.Marshal([]interface{}{1, 2, 3, 4, 5})\n\tif err != nil {\n\t\tt.Errorf(\"json.Marshal() error = %v, wantErr %v\", err, false)\n\t}\n\tif !reflect.DeepEqual(gotV.MarshalTo(nil), wantV) {\n\t\tt.Errorf(\"parseValue() gotV = %v, want %v\", gotV, wantV)\n\t}\n}\n\nfunc Test_parseValue_string(t *testing.T) {\n\tc := \u0026cache{}\n\ts := \"\\\"hello world\\\"\"\n\tgotV, _, err := parseValue(s, c, 0)\n\tif err != nil {\n\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, false)\n\t}\n\twantV, err := json.Marshal(\"hello world\")\n\tif err != nil {\n\t\tt.Errorf(\"json.Marshal() error = %v, wantErr %v\", err, false)\n\t}\n\tif !reflect.DeepEqual(gotV.MarshalTo(nil), wantV) {\n\t\tt.Errorf(\"parseValue() gotV = %v, want %v\", gotV, wantV)\n\t}\n}\n\nfunc Test_parseValue_true(t *testing.T) {\n\tc := \u0026cache{}\n\ts := \"true\"\n\tgotV, _, err := parseValue(s, c, 0)\n\tif err != nil {\n\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, false)\n\t}\n\twantV, err := json.Marshal(true)\n\tif err != nil {\n\t\tt.Errorf(\"json.Marshal() error = %v, wantErr %v\", err, false)\n\t}\n\tif !reflect.DeepEqual(gotV.MarshalTo(nil), wantV) {\n\t\tt.Errorf(\"parseValue() gotV = %v, want %v\", gotV, wantV)\n\t}\n}\n\nfunc Test_parseValue_false(t *testing.T) {\n\tc := \u0026cache{}\n\ts := \"false\"\n\tgotV, _, err := parseValue(s, c, 0)\n\tif err != nil {\n\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, false)\n\t}\n\twantV, err := json.Marshal(false)\n\tif err != nil {\n\t\tt.Errorf(\"json.Marshal() error = %v, wantErr %v\", err, false)\n\t}\n\tif !reflect.DeepEqual(gotV.MarshalTo(nil), wantV) {\n\t\tt.Errorf(\"parseValue() gotV = %v, want %v\", gotV, wantV)\n\t}\n}\n\nfunc Test_parseValue_null(t *testing.T) {\n\tc := \u0026cache{}\n\ts := \"null\"\n\tgotV, _, err := parseValue(s, c, 0)\n\tif err != nil {\n\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, false)\n\t}\n\twantV, err := json.Marshal(nil)\n\tif err != nil {\n\t\tt.Errorf(\"json.Marshal() error = %v, wantErr %v\", err, false)\n\t}\n\tif !reflect.DeepEqual(gotV.MarshalTo(nil), wantV) {\n\t\tt.Errorf(\"parseValue() gotV = %v, want %v\", gotV, wantV)\n\t}\n}\n\nfunc Test_parseValue_number(t *testing.T) {\n\tc := \u0026cache{}\n\ts := \"1234567890\"\n\tgotV, _, err := parseValue(s, c, 0)\n\tif err != nil {\n\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, false)\n\t}\n\twantV, err := json.Marshal(1234567890)\n\tif err != nil {\n\t\tt.Errorf(\"json.Marshal() error = %v, wantErr %v\", err, false)\n\t}\n\tif !reflect.DeepEqual(gotV.MarshalTo(nil), wantV) {\n\t\tt.Errorf(\"parseValue() gotV = %v, want %v\", gotV, wantV)\n\t}\n}\n\nfunc Test_parseValue_number_decimal(t *testing.T) {\n\tc := \u0026cache{}\n\ts := \"123.456\"\n\tgotV, _, err := parseValue(s, c, 0)\n\tif err != nil {\n\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, false)\n\t}\n\twantV, err := json.Marshal(123.456)\n\tif err != nil {\n\t\tt.Errorf(\"json.Marshal() error = %v, wantErr %v\", err, false)\n\t}\n\tif !reflect.DeepEqual(gotV.MarshalTo(nil), wantV) {\n\t\tt.Errorf(\"parseValue() gotV = %v, want %v\", gotV, wantV)\n\t}\n}\n\nfunc Test_parseValue_number_exponent(t *testing.T) {\n\tc := \u0026cache{}\n\ts := \"1.234e+5\"\n\tgotV, _, err := parseValue(s, c, 0)\n\tif err != nil {\n\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, false)\n\t}\n\twantV, err := json.Marshal(1.234e+5)\n\tif err != nil {\n\t\tt.Errorf(\"json.Marshal() error = %v, wantErr %v\", err, false)\n\t}\n\tif !reflect.DeepEqual(gotV.MarshalTo(nil), wantV) {\n\t\tt.Errorf(\"parseValue() gotV = %v, want %v\", gotV, wantV)\n\t}\n}\n\nfunc Test_parseValue_number_negative_exponent(t *testing.T) {\n\tc := \u0026cache{}\n\ts := \"1.234e-5\"\n\tgotV, _, err := parseValue(s, c, 0)\n\tif err != nil {\n\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, false)\n\t}\n\twantV, err := json.Marshal(1.234e-5)\n\tif err != nil {\n\t\tt.Errorf(\"json.Marshal() error = %v, wantErr %v\", err, false)\n\t}\n\tif !reflect.DeepEqual(gotV.MarshalTo(nil), wantV) {\n\t\tt.Errorf(\"parseValue() gotV = %v, want %v\", gotV, wantV)\n\t}\n}\n\nfunc Test_parseValue_number_negative_sign(t *testing.T) {\n\tc := \u0026cache{}\n\ts := \"-123\"\n\tgotV, _, err := parseValue(s, c, 0)\n\tif err != nil {\n\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, false)\n\t}\n\twantV, err := json.Marshal(-123)\n\tif err != nil {\n\t\tt.Errorf(\"json.Marshal() error = %v, wantErr %v\", err, false)\n\t}\n\tif !reflect.DeepEqual(gotV.MarshalTo(nil), wantV) {\n\t\tt.Errorf(\"parseValue() gotV = %v, want %v\", gotV, wantV)\n\t}\n}\n\nfunc Test_parseValue_number_positive_sign(t *testing.T) {\n\tc := \u0026cache{}\n\ts := \"+123\"\n\tgotV, _, err := parseValue(s, c, 0)\n\tif err != nil {\n\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, false)\n\t}\n\twantV, err := json.Marshal(123)\n\tif err != nil {\n\t\tt.Errorf(\"json.Marshal() error = %v, wantErr %v\", err, false)\n\t}\n\tif !reflect.DeepEqual(gotV.MarshalTo(nil), wantV) {\n\t\tt.Errorf(\"parseValue() gotV = %v, want %v\", gotV, wantV)\n\t}\n}\n\nfunc Test_parseValue_NaN(t *testing.T) {\n\tc := \u0026cache{}\n\ts := \"NaN\"\n\tgotV, _, err := parseValue(s, c, 0)\n\tif err != nil {\n\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, false)\n\t}\n\twantV, err := json.Marshal(float64(math.NaN()))\n\tif err != nil {\n\t\tt.Errorf(\"json.Marshal() error = %v, wantErr %v\", err, false)\n\t}\n\tif !reflect.DeepEqual(gotV.MarshalTo(nil), wantV) {\n\t\tt.Errorf(\"parseValue() gotV = %v, want %v\", gotV, wantV)\n\t}\n}","21563450aa831ddb46cebdbf589fe705":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestType_String(t *testing.T) {\n\ttype args struct {\n\t\tt Type\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"TestType_String_Object\",\n\t\t\targs: args{\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\twant: \"object\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_Array\",\n\t\t\targs: args{\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\twant: \"array\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_String\",\n\t\t\targs: args{\n\t\t\t\tt: TypeString,\n\t\t\t},\n\t\t\twant: \"string\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_Number\",\n\t\t\targs: args{\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\twant: \"number\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_True\",\n\t\t\targs: args{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: \"true\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_False\",\n\t\t\targs: args{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: \"false\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_Null\",\n\t\t\targs: args{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: \"null\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.t.String(); got != tt.want {\n\t\t\t\tt.Errorf(\"Type.String() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","219d017f87ef89c0155d62b9adcf69a1":"```go\npackage fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": {\"key2\": \"value2\"}, \"key3\": \"value3\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{\n\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}},\n\t\t\t\t\t\t{k: \"key3\", v: \u0026Value{t: TypeString, s: \"value3\"}},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: ","21c8b9ab6e61b74c9c277e147ee024f4":"```go\npackage fastjson\n\nimport (\n\t\"encoding/json\"\n","21fe26a1eb0ca3f4d414e14beec4b95b":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"RawString\",\n\t\t\tv: \u0026Value{\n\t\t\t\ts: \"test\",\n\t\t\t\tt: typeRawString,\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t},\n\t\t\twant: []byte(`\"test\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"Object\",\n\t\t\tv: \u0026Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":\"value1\",\"key2\":\"value2\"}`),\n\t\t},\n\t\t{\n\t\t\tname: \"Array\",\n\t\t\tv: \u0026Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t},\n\t\t\twant: []byte(`[\"value1\",\"value2\"]`),\n\t\t},\n\t\t{\n\t\t\tname: \"String\",\n\t\t\tv: \u0026Value{\n\t\t\t\ts: \"test\",\n\t\t\t\tt: TypeString,\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t},\n\t\t\twant: []byte(`\"test\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"Number\",\n\t\t\tv: \u0026Value{\n\t\t\t\ts: \"123\",\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t},\n\t\t\twant: []byte(`123`),\n\t\t},\n\t\t{\n\t\t\tname: \"True\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t},\n\t\t\twant: []byte(`true`),\n\t\t},\n\t\t{\n\t\t\tname: \"False\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t},\n\t\t\twant: []byte(`false`),\n\t\t},\n\t\t{\n\t\t\tname: \"Null\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t},\n\t\t\twant: []byte(`null`),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.MarshalTo(tt.args.dst); !bytesEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", string(got), string(tt.want))\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc bytesEqual(a, b []byte) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","240bda3681d592206cdcef8ff7978b96":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with one key-value pair\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\": \"value\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with multiple key-value pairs\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\", \"key3\": \"value3\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested objects\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"key2\": \"value2\"}, \"key3\": \"value3\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with invalid key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key: \"value\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key: \"value\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with invalid value\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\": value\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key\": value\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\": \"value\"`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key\": \"value\"`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\" \"value\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key\" \"value\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","2442be74b57fe2079b5eff0a2bc0c33a":"```go\npackage fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttype want struct {\n\t\tv   *Value\n\t\ttail string\n\t\terr  error\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant want\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  fmt.Errorf(\"cannot parse empty string\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"{}\",\n\t\t\t\terr:  fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{ \\\"key\\\": \\\"value\\\" }\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[1, 2, 3]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\\\"hello\\\"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeString,\n\t\t\t\t\ts: \"hello\",\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   \"true\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueTrue,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   \"false\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueFalse,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   \"null\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueNull,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n","2450389b1bc6ad67b7ef7b1235a62386":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escape sequence\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\tworld\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\tworld\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\"`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with multiple escape sequences\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with multiple escape sequences and leading spaces\",\n\t\t\targs: args{\n\t\t\t\ts: `  \"hello\\\\\"world\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with multiple escape sequences and trailing spaces\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"!\"  `,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"!\",\n\t\t\twant1:   \"  \",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","2476caea5205f813f94d185bcf37165b":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetUint64(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant uint64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.GetUint64(tt.args.keys...); got != tt.want {\n\t\t\t\tt.Errorf(\"Value.GetUint64() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","24aa5034a511785e1541e0d1a6b12b78":"```go\npackage fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestUint(t *testing.T) {\n\ttype args struct {\n\t\tv *Value\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    uint\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"valid uint\",\n\t\t\targs: args{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"12345\",\n\t\t\t\t},\n\t\t\t},\n\t\t\twant:    12345,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid uint\",\n\t\t\targs: args{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"18446744073709551616\", // larger than uint max value\n\t\t\t\t},\n\t\t\t},\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid type\",\n\t\t\targs: args{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeString,\n\t\t\t\t\ts: \"abc\",\n\t\t\t\t},\n\t\t\t},\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n","24e116bdb8eb228efbb3cb4d39692562":"```go\npackage fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {","24f6ab7fa227301c86006c63fd2bf228":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGet(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttype want struct {\n\t\twant *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant want\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.Get(tt.args.keys...); !reflect.DeepEqual(got, tt.want.want) {\n\t\t\t\tt.Errorf(\"Get() = %v, want %v\", got, tt.want.want)\n\t\t\t}\n\t\t})\n\t}\n}","2571a7638b76ad2d74e4411f384573ac":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"Parse null\",\n\t\t\targs: args{\n\t\t\t\ts: \"null\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Parse true\",\n\t\t\targs: args{\n\t\t\t\ts: \"true\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Parse false\",\n\t\t\targs: args{\n\t\t\t\ts: \"false\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Parse string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt:  TypeString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Parse number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Parse array\",\n\t\t\targs: args{\n\t\t\t\ts: `[1, 2, \"3\"]`,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Parse object\",\n\t\t\targs: args{\n\t\t\t\ts: `{\"key1\": 1, \"key2\": \"value2\"}`,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Parse invalid JSON\",\n\t\t\targs: args{\n\t\t\t\ts: `{`,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tp := \u0026Parser{}\n\t\t\tgot, err := p.Parse(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Parse() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr {\n\t\t\t\tif !json.Valid([]byte(tt.args.s)) {\n\t\t\t\t\tt.Errorf(\"Parse() got = %v, want %v\", got, tt.want)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif !compareValues(got, tt.want) {\n\t\t\t\t\tt.Errorf(\"Parse() got = %v, want %v\", got, tt.want)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(got, want *Value) bool {\n\tif got.t != want.t {\n\t\treturn false\n\t}\n\tswitch got.t {\n\tcase TypeNull:\n\t\treturn true\n\tcase TypeTrue:\n\t\treturn true\n\tcase TypeFalse:\n\t\treturn true\n\tcase TypeString:\n\t\treturn got.s == want.s\n\tcase TypeNumber:\n\t\treturn got.s == want.s\n\tcase TypeArray:\n\t\tif len(got.a) != len(want.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range got.a {\n\t\t\tif !compareValues(got.a[i], want.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeObject:\n\t\tif len(got.o.kvs) != len(want.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range got.o.kvs {\n\t\t\tif got.o.kvs[i].k != want.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !compareValues(got.o.kvs[i].v, want.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\treturn false\n}","2598149e38f0e0fe920438f700e84475":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttype want struct {\n\t\tv    *Value\n\t\ts    string\n\t\terr  error\n\t\twant string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant want\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:    \u0026Value{t: TypeObject, o: Object{}},\n\t\t\t\ts:    \"\",\n\t\t\t\terr:  nil,\n\t\t\t\twant: \"{}\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"object with one key-value pair\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\": \"value\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{t: TypeObject, o: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: \u0026Value{t: TypeString, s: \"value\"},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\t\ts:    \"\",\n\t\t\t\terr:  nil,\n\t\t\t\twant: `{\"key\":\"value\"}`,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"object with multiple key-value pairs\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{t: TypeObject, o: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{t: TypeString, s: \"value1\"},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{t: TypeString, s: \"value2\"},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\t\ts:    \"\",\n\t\t\t\terr:  nil,\n\t\t\t\twant: `{\"key1\":\"value1\",\"key2\":\"value2\"}`,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"key2\": \"value2\"}}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{t: TypeObject, o: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{t: TypeObject, o: Object{\n\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\t\t\tv: \u0026Value{t: TypeString, s: \"value2\"},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\t\ts:    \"\",\n\t\t\t\terr:  nil,\n\t\t\t\twant: `{\"key1\":{\"key2\":\"value2\"}}`,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested array\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": [\"value1\", \"value2\"]}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{t: TypeObject, o: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t\t\t\t\t\t{t: TypeString, s: \"value1\"},\n\t\t\t\t\t\t\t\t{t: TypeString, s: \"value2\"},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\t\ts:    \"\",\n\t\t\t\terr:  nil,\n\t\t\t\twant: `{\"key1\":[\"value1\",\"value2\"]}`,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:    nil,\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\terr:  \u0026ParseError{Message: \"missing '}'\"},\n\t\t\t\twant: `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:    nil,\n\t\t\t\ts:    `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\terr:  \u0026ParseError{Message: \"missing ':' after object key\"},\n\t\t\t\twant: `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:    nil,\n\t\t\t\ts:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\terr:  \u0026ParseError{Message: \"missing ',' after object value\"},\n\t\t\t\twant: `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"object with invalid key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2: \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:    nil,\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2: \"value2\"}`,\n\t\t\t\terr:  \u0026ParseError{Message: `cannot find opening '\"\" for object key`},\n\t\t\t\twant: `{\"key1\": \"value1\", \"key2: \"value2\"}`,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"object with invalid value\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:    nil,\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": value2\"}`,\n\t\t\t\terr:  \u0026ParseError{Message: \"cannot parse object value: unexpected end of JSON input\"},\n\t\t\t\twant: `{\"key1\": \"value1\", \"key2\": value2\"}`,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotV, gotS, gotErr := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (gotErr != nil \u0026\u0026 tt.want.err == nil) || (gotErr == nil \u0026\u0026 tt.want.err != nil) {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", gotErr, tt.want.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotErr != nil \u0026\u0026 tt.want.err != nil {\n\t\t\t\tif gotErr.Error() != tt.want.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", gotErr, tt.want.err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif gotV == nil \u0026\u0026 tt.want.v != nil || gotV != nil \u0026\u0026 tt.want.v == nil {\n\t\t\t\tt.Errorf(\"parseObject() gotV = %v, wantV %v\", gotV, tt.want.v)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotV != nil \u0026\u0026 tt.want.v != nil {\n\t\t\t\tif gotV.String() != tt.want.v.String() {\n\t\t\t\t\tt.Errorf(\"parseObject() gotV = %v, wantV %v\", gotV.String(), tt.want.v.String())\n\t\t\t\t}\n\t\t\t}\n\t\t\tif gotS != tt.want.s {\n\t\t\t\tt.Errorf(\"parseObject() gotS = %v, wantS %v\", gotS, tt.want.s)\n\t\t\t}\n\t\t})\n\t}\n}","25f24fcc36cc60aec68c7ede89d509c3":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"empty string\",\n\t\t\targs:    args{s: \"\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"simple integer\",\n\t\t\targs:    args{s: \"123\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"negative integer\",\n\t\t\targs:    args{s: \"-123\"},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"floating point number\",\n\t\t\targs:    args{s: \"123.456\"},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"exponential notation\",\n\t\t\targs:    args{s: \"1.23e+4\"},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"exponential notation with minus sign\",\n\t\t\targs:    args{s: \"1.23e-4\"},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"leading plus sign\",\n\t\t\targs:    args{s: \"+123\"},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"leading plus sign with floating point\",\n\t\t\targs:    args{s: \"+123.456\"},\n\t\t\twantNs:  \"+123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"leading plus sign with exponential notation\",\n\t\t\targs:    args{s: \"+1.23e+4\"},\n\t\t\twantNs:  \"+1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"inf\",\n\t\t\targs:    args{s: \"inf\"},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"Inf\",\n\t\t\targs:    args{s: \"Inf\"},\n\t\t\twantNs:  \"Inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"inF\",\n\t\t\targs:    args{s: \"inF\"},\n\t\t\twantNs:  \"inF\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"NaN\",\n\t\t\targs:    args{s: \"NaN\"},\n\t\t\twantNs:  \"NaN\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"nAn\",\n\t\t\targs:    args{s: \"nAn\"},\n\t\t\twantNs:  \"nAn\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"naN\",\n\t\t\targs:    args{s: \"naN\"},\n\t\t\twantNs:  \"naN\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number\",\n\t\t\targs:    args{s: \"123a\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number 2\",\n\t\t\targs:    args{s: \"123.456a\"},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number 3\",\n\t\t\targs:    args{s: \"123e+4a\"},\n\t\t\twantNs:  \"123e+4\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number 4\",\n\t\t\targs:    args{s: \"123e-4a\"},\n\t\t\twantNs:  \"123e-4\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number 5\",\n\t\t\targs:    args{s: \"+123a\"},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number 6\",\n\t\t\targs:    args{s: \"+123.456a\"},\n\t\t\twantNs:  \"+123.456\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number 7\",\n\t\t\targs:    args{s: \"+1.23e+4a\"},\n\t\t\twantNs:  \"+1.23e+4\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number 8\",\n\t\t\targs:    args{s: \"+1.23e-4a\"},\n\t\t\twantNs:  \"+1.23e-4\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number 9\",\n\t\t\targs:    args{s: \"inf123\"},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"123\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number 10\",\n\t\t\targs:    args{s: \"NaN123\"},\n\t\t\twantNs:  \"NaN\",\n\t\t\twantS:   \"123\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number 11\",\n\t\t\targs:    args{s: \"-inf123\"},\n\t\t\twantNs:  \"-inf\",\n\t\t\twantS:   \"123\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number 12\",\n\t\t\targs:    args{s: \"-NaN123\"},\n\t\t\twantNs:  \"-NaN\",\n\t\t\twantS:   \"123\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number 13\",\n\t\t\targs:    args{s: \"-+123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"-+123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number 14\",\n\t\t\targs:    args{s: \"++123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"++123\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}","2611c8b38fe13525416c8e88ca98ba23":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWS(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no whitespace\",\n\t\t\targs: args{s: \"abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace\",\n\t\t\targs: args{s: \"   abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailing whitespace\",\n\t\t\targs: args{s: \"abc   \"},\n\t\t\twant: \"abc   \",\n\t\t},\n\t\t{\n\t\t\tname: \"leading and trailing whitespace\",\n\t\t\targs: args{s: \"   abc   \"},\n\t\t\twant: \"abc   \",\n\t\t},\n\t\t{\n\t\t\tname: \"internal whitespace\",\n\t\t\targs: args{s: \"a bc\"},\n\t\t\twant: \"a bc\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple whitespace\",\n\t\t\targs: args{s: \"  a   b   c  \"},\n\t\t\twant: \"a   b   c  \",\n\t\t},\n\t\t{\n\t\t\tname: \"special characters\",\n\t\t\targs: args{s: \"  \\t\\r\\n  abc  \\t\\r\\n  \"},\n\t\t\twant: \"abc  \\t\\r\\n  \",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWS(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWS() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","26212585ff2cf80f2aa004def4351ae6":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestType_String(t *testing.T) {\n\ttype args struct {\n\t\tt Type\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"TypeObject\",\n\t\t\targs: args{t: TypeObject},\n\t\t\twant: \"object\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeArray\",\n\t\t\targs: args{t: TypeArray},\n\t\t\twant: \"array\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeString\",\n\t\t\targs: args{t: TypeString},\n\t\t\twant: \"string\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeNumber\",\n\t\t\targs: args{t: TypeNumber},\n\t\t\twant: \"number\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeTrue\",\n\t\t\targs: args{t: TypeTrue},\n\t\t\twant: \"true\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeFalse\",\n\t\t\targs: args{t: TypeFalse},\n\t\t\twant: \"false\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeNull\",\n\t\t\targs: args{t: TypeNull},\n\t\t\twant: \"null\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.t.String(); got != tt.want {\n\t\t\t\tt.Errorf(\"Type.String() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","264992c214c752cc47b58bbf20058423":"```go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args","26e7b14d9c8c2b77c7f3fa7a3edd517c":"```go\npackage fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttype want struct {\n\t\tv   *Value\n\t\ttail string\n\t\terr  error\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant want\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  fmt.Errorf(\"cannot parse empty string\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"too deep\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"{}\",\n\t\t\t\terr:  fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{ }\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{t: TypeObject},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[ ]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{t: TypeArray},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"hello\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{t: typeRawString, s: \"hello\"},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   \"true\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueTrue,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   \"false\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueFalse,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   \"null\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueNull,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   \"123\",\n\t\t\t\t","272c0c6a1e68be2b97a6035d445c2919":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"strconv\"\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello world\",\n\t\t\t},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\\\\"hello world\\\\\\\"\",\n\t\t\t},\n\t\t\twant: \"\\\"hello world\\\"\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\\\\\hello world\\\\\\\\\",\n\t\t\t},\n\t\t\twant: \"\\\\hello world\\\\\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\/hello world\\\\/\",\n\t\t\t},\n\t\t\twant: \"/hello world/\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\bhello world\\\\b\",\n\t\t\t},\n\t\t\twant: \"\\bhello world\\b\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\fhello world\\\\f\",\n\t\t\t},\n\t\t\twant: \"\\fhello world\\f\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\nhello world\\\\n\",\n\t\t\t},\n\t\t\twant: \"\\nhello world\\n\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\rhello world\\\\r\",\n\t\t\t},\n\t\t\twant: \"\\rhello world\\r\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\thello world\\\\t\",\n\t\t\t},\n\t\t\twant: \"\\thello world\\t\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\u0061hello world\\\\u0062\",\n\t\t\t},\n\t\t\twant: \"ahello worldb\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\uD83D\\\\uDE01hello world\\\\uD83D\\\\uDE02\",\n\t\t\t},\n\t\t\twant: \"😁hello world😂\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\xhello world\\\\x\",\n\t\t\t},\n\t\t\twant: \"\\\\xhello world\\\\x\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\u006hello world\\\\u\",\n\t\t\t},\n\t\t\twant: \"\\\\u006hello world\\\\u\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestUnescapeStringBestEffort_JSON(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\\\\\"hello world\\\\\"\"`,\n\t\t\t},\n\t\t\twant: `\"hello world\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\\\\\"\\\\\\\\hello world\\\\\\\\\\\\\"\"`,\n\t\t\t},\n\t\t\twant: `\"\\\\\\\\hello world\\\\\\\\\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\\\\\"hello world/\\\\\"\"`,\n\t\t\t},\n\t\t\twant: `\"hello world/\"`\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\\\\\"hello world\\\\b\\\\\"\"`,\n\t\t\t},\n\t\t\twant: `\"hello world\\b\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\\\\\"hello world\\\\f\\\\\"\"`,\n\t\t\t},\n\t\t\twant: `\"hello world\\f\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\\\\\"hello world\\\\n\\\\\"\"`,\n\t\t\t},\n\t\t\twant: `\"hello world\\n\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\\\\\"hello world\\\\r\\\\\"\"`,\n\t\t\t},\n\t\t\twant: `\"hello world\\r\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\\\\\"hello world\\\\t\\\\\"\"`,\n\t\t\t},\n\t\t\twant: `\"hello world\\t\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\\\\\"hello world\\\\u0061\\\\\"\"`,\n\t\t\t},\n\t\t\twant: `\"hello worlda\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\\\\\"hello world\\\\uD83D\\\\uDE01\\\\\"\"`,\n\t\t\t},\n\t\t\twant: `\"hello world😁\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with surrounding quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\\\\\"hello world\\\\uD83D\\\\uDE01\\\\\"\"`,\n\t\t\t},\n\t\t\twant: `\"hello world😁\"`,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := unescapeStringBestEffort(tt.args.s)\n\t\t\twant, err := json.Marshal(tt.want)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif string(got) != string(want) {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %q, want %q\", got, want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestUnescapeStringBestEffort_Numbers(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"escaped number\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\\\\\"123\\\\\"\"`,\n\t\t\t},\n\t\t\twant: `\"123\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped negative number\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\\\\\"-123\\\\\"\"`,\n\t\t\t},\n\t\t\twant: `\"-123\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped decimal number\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\\\\\"123.456\\\\\"\"`,\n\t\t\t},\n\t\t\twant: `\"123.456\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped exponential number\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\\\\\"1.23e+4\\\\\"\"`,\n\t\t\t},\n\t\t\twant: `\"1.23e+4\"`,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %q, want %q\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestUnescapeStringBestEffort_EscapedUnicode(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"escaped unicode character\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\\\\\"hello world\\\\u0061\\\\\"\"`,\n\t\t\t},\n\t\t\twant: `\"hello worlda\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with surrounding quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\\\\\"hello world\\\\u0061\\\\\"\"`,\n\t\t\t},\n\t\t\twant: `\"hello worlda\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with surrounding quotes and escapes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\\\\\"hello world\\\\\\\\u0061\\\\\\\\\\\\\"\"`,\n\t\t\t},\n\t\t\twant: `\"hello world\\\\u0061\\\\\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with surrounding quotes and escapes and numbers\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\\\\\"hello world\\\\\\\\u0061\\\\\\\\123\\\\\"\"`,\n\t\t\t},\n\t\t\twant: `\"hello world\\\\u0061\\\\123\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with surrounding quotes and escapes and numbers and special characters\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\\\\\"hello world\\\\\\\\u0061\\\\\\\\123\\\\/\\\\\"\"`,\n\t\t\t},\n\t\t\twant: `\"hello world\\\\u0061\\\\123/\"`,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %q, want %q\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestUnescapeStringBestEffort_InvalidEscapeSequences(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\\\\\"hello world\\\\x\\\\\"\"`,\n\t\t\t},\n\t\t\twant: `\"hello world\\\\x\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\\\\\"hello world\\\\u006\\\\\"\"`,\n\t\t\t},\n\t\t\twant: `\"hello world\\\\u006\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence with surrounding quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\\\\\"hello world\\\\u006\\\\\"\"`,\n\t\t\t},\n\t\t\twant: `\"hello world\\\\u006\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence with surrounding quotes and escapes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\\\\\"hello world\\\\\\\\u006\\\\\\\\\\\\\"\"`,\n\t\t\t},\n\t\t\twant: `\"hello world\\\\u006\\\\\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence with surrounding quotes and escapes and numbers\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\\\\\"hello world\\\\\\\\u006\\\\\\\\123\\\\\"\"`,\n\t\t\t},\n\t\t\twant: `\"hello world\\\\u006\\\\123\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence with surrounding quotes and escapes and numbers and special characters\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\\\\\"hello world\\\\\\\\u006\\\\\\\\123\\\\/\\\\\"\"`,\n\t\t\t},\n\t\t\twant: `\"hello world\\\\u006\\\\123/\"`,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %q, want %q\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestUnescapeStringBestEffort_EscapedSpecialCharacters(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"escaped special character\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\\\\\"hello world\\\\/\\\\\"\"`,\n\t\t\t},\n\t\t\twant: `\"hello world/\"`\n\t\t},\n\t\t{\n\t\t\tname: \"escaped special character with surrounding quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\\\\\"hello world\\\\/\\\\\"\"`,\n\t\t\t},\n\t\t\twant: `\"hello world/\"`\n\t\t},\n\t\t{\n\t\t\tname: \"escaped special character with surrounding quotes and escapes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\\\\\"hello world\\\\\\\\/\\\\\\\\\\\\\"\"`,\n\t\t\t},\n\t\t\twant: `\"hello world\\\\/\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped special character with surrounding quotes and escapes and numbers\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\\\\\"hello world\\\\\\\\/\\\\\\\\123\\\\\"\"`,\n\t\t\t},\n\t\t\twant: `\"hello world\\\\/123\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped special character with surrounding quotes and escapes and numbers and special characters\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\\\\\"hello world\\\\\\\\/\\\\\\\\123\\\\/\\\\\"\"`,\n\t\t\t},\n\t\t\twant: `\"hello world\\\\/123/\"`,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %q, want %q\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","27cd5aa55d8e553f006c9edbd010abf8":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestHasSpecialChars(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with double quote\",\n\t\t\targs: args{s: \"hello\\\"\"},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with backslash\",\n\t\t\targs: args{s: \"hello\\\\\"},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with control character\",\n\t\t\targs: args{s: \"hello\\x1f\"},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string without special characters\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := hasSpecialChars(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"hasSpecialChars() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","2806f695f214a4e8dff15db27c43a129":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"Empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Single key-value pair\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\": \"value\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple key-value pairs\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"key2\": \"value2\"}}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\": \"value\"`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key\": \"value\"`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\" \"value\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key\" \"value\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","297412639b832349e7f5ce6fcb4c4db4":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\"world\\\\\\\"\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\\\\\\\"\\\\\\\"\",\n\t\t\twant1:   \"!\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: ``,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped backslash\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\\world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\\world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped backslash and quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\\\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\\\\\\\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped backslash and quote and other chars\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\\\\\\\"world\\\\\"abc\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\\\\\\\\\"world\\\\\\\"abc\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped backslash and quote and other chars 2\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\\\\\\\"world\\\\\"abc\\\\\"def\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\\\\\\\\\"world\\\\\\\"abc\\\\\\\"def\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped backslash and quote and other chars 3\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\\\\\\\"world\\\\\"abc\\\\\"def\\\\\"ghi\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\\\\\\\\\"world\\\\\\\"abc\\\\\\\"def\\\\\\\"ghi\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","297a10288aca5d542180707ce840f7cb":"package fastjson\n\nimport \"testing\"\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no whitespace\",\n\t\t\targs: args{s: \"abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace\",\n\t\t\targs: args{s: \"  abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailing whitespace\",\n\t\t\targs: args{s: \"abc  \"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"whitespace in the middle\",\n\t\t\targs: args{s: \"a bc\"},\n\t\t\twant: \"bc\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple whitespace\",\n\t\t\targs: args{s: \"  a  bc  \"},\n\t\t\twant: \"bc\",\n\t\t},\n\t\t{\n\t\t\tname: \"whitespace with newline\",\n\t\t\targs: args{s: \"\\n abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"whitespace with tab\",\n\t\t\targs: args{s: \"\\t abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"whitespace with carriage return\",\n\t\t\targs: args{s: \"\\r abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"all whitespace\",\n\t\t\targs: args{s: \"  \\n \\t\\r  \"},\n\t\t\twant: \"\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","2ac68ec39b10b3df95bc31cb624004c3":"```go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"single element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,3]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[[1,2],[3,4]]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"4\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with whitespace\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[ 1 , 2 , 3 ]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1,2\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1 2]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1 2]\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected end of array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1,2\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid array value\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1,2,\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseArray(tt.args.s, tt.args.c,","2ad93eb098464d4bf66381bf823da026":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Get(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttype want struct {\n\t\tvalue *Value\n\t}\n\ttests := []struct {\n\t\tname  string\n\t\tv     *Value\n\t\targs  args\n\t\twant want\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.Get(tt.args.keys...); !reflect.DeepEqual(got, tt.want.value) {\n\t\t\t\tt.Errorf(\"Value.Get() = %v, want %v\", got, tt.want.value)\n\t\t\t}\n\t\t})\n\t}\n}","2ae0ecdcd56d387cccfbe4e2f5863e58":"```go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello world\",\n\t\t\t},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello world\\\"\",\n\t\t\t},\n\t\t\twant: \"\\\"hello world\\\"\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\hello world\",\n\t\t\t},\n\t\t\twant: \"\\\\hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{\n\t\t\t\ts: \"/hello world\",\n\t\t\t},\n\t\t\twant: \"/hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\bhello world\",\n\t\t\t},\n\t\t\twant: \"\\bhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\fhello world\",\n\t\t\t},\n\t\t\twant: \"\\fhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\nhello world\",\n\t\t\t},\n\t\t\twant: \"\\nhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\rhello world\",\n\t\t\t},\n\t\t\twant: \"\\rhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\thello world\",\n\t\t\t},\n\t\t\twant: \"\\thello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\u0061hello world\",\n\t\t\t},\n\t\t\twant: \"ahello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\uD83D\\\\uDE01hello world\",\n\t\t\t},\n\t\t\twant: \"😁hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\xhello world\",\n\t\t\t},\n\t\t\twant: \"\\\\xhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\u006hello world\",\n\t\t\t},\n\t\t\twant: \"\\\\u","2cb611f73ab55538a6a679daf9e960b9":"package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello world\",\n\t\t\t},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello world\\\"\",\n\t\t\t},\n\t\t\twant: \"\\\"hello world\\\"\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\hello world\",\n\t\t\t},\n\t\t\twant: \"\\\\hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{\n\t\t\t\ts: \"/hello world\",\n\t\t\t},\n\t\t\twant: \"/hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\bhello world\",\n\t\t\t},\n\t\t\twant: \"\\bhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\fhello world\",\n\t\t\t},\n\t\t\twant: \"\\fhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\nhello world\",\n\t\t\t},\n\t\t\twant: \"\\nhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\rhello world\",\n\t\t\t},\n\t\t\twant: \"\\rhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\thello world\",\n\t\t\t},\n\t\t\twant: \"\\thello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\u0061hello world\",\n\t\t\t},\n\t\t\twant: \"ahello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode surrogate pair\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\uD83D\\\\uDE01hello world\",\n\t\t\t},\n\t\t\twant: \"😁hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\xhello world\",\n\t\t\t},\n\t\t\twant: \"\\\\xhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete unicode escape sequence\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\u006hello world\",\n\t\t\t},\n\t\t\twant: \"\\\\u006hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete surrogate pair\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\uD83Dhello world\",\n\t\t\t},\n\t\t\twant: \"\\\\uD83Dhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\\\\"\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061hello world\\\\u0062\",\n\t\t\t},\n\t\t\twant: \"\\\"\\\\b\\f\\n\\r\\tahello worldb\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","2cbc97769b8869a07f477d36c29e51d9":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttype want struct {\n\t\tv   *Value\n\t\ttail string\n\t\terr  error\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant want\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  fmt.Errorf(\"cannot parse empty string\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"too deep\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"{}\",\n\t\t\t\terr:  fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\": \"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"value1\", \"value2\"]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"value\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeString,\n\t\t\t\t\ts: \"value\",\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   `true`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueTrue,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   `false`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueFalse,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   `null`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueNull,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"123\",\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   `NaN`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"NaN\",\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotV, gotTail, gotErr := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (gotErr != nil \u0026\u0026 tt.want.err == nil) || (gotErr == nil \u0026\u0026 tt.want.err != nil) {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", gotErr, tt.want.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotErr != nil \u0026\u0026 tt.want.err != nil {\n\t\t\t\tif gotErr.Error() != tt.want.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", gotErr, tt.want.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\tif gotTail != tt.want.tail {\n\t\t\t\tt.Errorf(\"parseValue() gotTail = %v, want %v\", gotTail, tt.want.tail)\n\t\t\t}\n\t\t\tif !compareValues(gotV, tt.want.v) {\n\t\t\t\tt.Errorf(\"parseValue() gotV = %v, want %v\", gotV, tt.want.v)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k || !compareValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !compareValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\tcase TypeString, TypeNumber:\n\t\tif v1.s != v2.s {\n\t\t\treturn false\n\t\t}\n\tcase TypeTrue, TypeFalse, TypeNull:\n\t\t// no need to compare anything\n\tdefault:\n\t\treturn false\n\t}\n\treturn true\n}","2cc3b709604c5951ce3e82ebc9f8d8ad":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           make([]kv, 0),\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": {\"key2\": \"value2\"}, \"key3\": \"value3\"}`,\n\t\t\t\tc:   \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{\n\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}},\n\t\t\t\t\t\t{k: \"key3\", v: \u0026Value{t: TypeString, s: \"value3\"}},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\"`,\n\t\t\t\tc:   \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\"`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\" \"value1\"}`,\n\t\t\t\tc:   \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_WithCache(t *testing.T) {\n\tc := \u0026cache{vs: make([]Value, 0)}\n\ts := `{\"key1\": \"value1\", \"key2\": {\"key3\": \"value3\", \"key4\": \"value4\"}}`\n\tv, _, err := parseObject(s, c, 0)\n\tif err != nil {\n\t\tt.Errorf(\"parseObject() error = %v\", err)\n\t}\n\t// Check that the cache is used for nested objects\n\tif len(c.vs) != 3 {\n\t\tt.Errorf(\"parseObject() expected 3 values in the cache, got %d\", len(c.vs))\n\t}\n\t// Check that the cache is reused for the same object\n\tv2, _, err := parseObject(s, c, 0)\n\tif err != nil {\n\t\tt.Errorf(\"parseObject() error = %v\", err)\n\t}\n\tif v != v2 {\n\t\tt.Errorf(\"parseObject() expected the same value object, got different objects\")\n\t}\n}\n\nfunc TestParseObject_WithEscapeSequences(t *testing.T) {\n\ts := `{\"key1\": \"value1\\\\\"escaped\\\\\"\", \"key2\": {\"key3\": \"\\\\\"escaped\\\\\"\"}}`\n\tc := \u0026cache{vs: make([]Value, 0)}\n\tv, _, err := parseObject(s, c, 0)\n\tif err != nil {\n\t\tt.Errorf(\"parseObject() error = %v\", err)\n\t}\n\t// Check that the escape sequences are correctly parsed\n\tif v.o.kvs[0].v.s != \"value1\\\"escaped\\\"\" {\n\t\tt.Errorf(\"parseObject() expected value1\\\"escaped\\\", got %s\", v.o.kvs[0].v.s)\n\t}\n\tif v.o.kvs[1].v.o.kvs[0].v.s != \"\\\"escaped\\\"\" {\n\t\tt.Errorf(\"parseObject() expected \\\"escaped\\\", got %s\", v.o.kvs[1].v.o.kvs[0].v.s)\n\t}\n}\n\nfunc TestParseObject_WithDepthLimit(t *testing.T) {\n\tc := \u0026cache{vs: make([]Value, 0)}\n\ts := `{\"key1\": {\"key2\": {\"key3\": \"value3\"}}} `\n\t// Set depth limit to 1\n\tv, _, err := parseObject(s, c, 1)\n\tif err == nil {\n\t\tt.Errorf(\"parseObject() expected an error, got nil\")\n\t}\n\t// Check that the parsing stopped at the specified depth\n\tif v.o.kvs[0].v.t != TypeObject {\n\t\tt.Errorf(\"parseObject() expected object, got %v\", v.o.kvs[0].v.t)\n\t}\n\tif v.o.kvs[0].v.o.Len() != 0 {\n\t\tt.Errorf(\"parseObject() expected empty object, got %v\", v.o.kvs[0].v.o.Len())\n\t}\n}\n\nfunc TestParseObject_InvalidJson(t *testing.T) {\n\ttests := []string{\n\t\t\"{\",\n\t\t\"}\",\n\t\t\"{,\",\n\t\t\"{\\\"key1\\\":\",\n\t\t\"{\\\"key1\\\": }\",\n\t\t\"{\\\"key1\\\": \\\"value1\\\" \",\n\t\t\"{\\\"key1\\\": \\\"value1\\\", }\",\n\t\t\"{\\\"key1\\\": \\\"value1\\\", \\\"key2\\\": }\",\n\t}\n\tfor _, s := range tests {\n\t\tt.Run(s, func(t *testing.T) {\n\t\t\tc := \u0026cache{vs: make([]Value, 0)}\n\t\t\t_, _, err := parseObject(s, c, 0)\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"parseObject() expected an error for invalid JSON: %s\", s)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_Benchmarks(t *testing.T) {\n\tc := \u0026cache{vs: make([]Value, 0)}\n\ts := `{\"key1\": \"value1\", \"key2\": {\"key3\": \"value3\", \"key4\": \"value4\"}, \"key5\": \"value5\"}`\n\tb := []byte(s)\n\tt.Run(\"ParseObject\", func(t *testing.T) {\n\t\tt.Run(\"SmallObject\", func(t *testing.T) {\n\t\t\tt.ResetTimer()\n\t\t\tfor i := 0; i \u003c 1000000; i++ {\n\t\t\t\t_, _, _ = parseObject(s, c, 0)\n\t\t\t}\n\t\t})\n\t\tt.Run(\"LargeObject\", func(t *testing.T) {\n\t\t\tt.ResetTimer()\n\t\t\tfor i := 0; i \u003c 100000; i++ {\n\t\t\t\t_, _, _ = parseObject(string(b), c, 0)\n\t\t\t}\n\t\t})\n\t})\n\tt.Run(\"Unmarshal\", func(t *testing.T) {\n\t\tt.Run(\"SmallObject\", func(t *testing.T) {\n\t\t\tt.ResetTimer()\n\t\t\tfor i := 0; i \u003c 1000000; i++ {\n\t\t\t\tvar v map[string]interface{}\n\t\t\t\t_ = json.Unmarshal([]byte(s), \u0026v)\n\t\t\t}\n\t\t})\n\t\tt.Run(\"LargeObject\", func(t *testing.T) {\n\t\t\tt.ResetTimer()\n\t\t\tfor i := 0; i \u003c 100000; i++ {\n\t\t\t\tvar v map[string]interface{}\n\t\t\t\t_ = json.Unmarshal(b, \u0026v)\n\t\t\t}\n\t\t})\n\t})\n}","2ceadea7d3d22fb61a883ee6a8978095":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"simple integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"float\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"scientific notation\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"scientific notation with negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e-4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"inf\",\n\t\t\t},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"Inf\",\n\t\t\t},\n\t\t\twantNs:  \"Inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inF\",\n\t\t\targs: args{\n\t\t\t\ts: \"inF\",\n\t\t\t},\n\t\t\twantNs:  \"inF\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"nan\",\n\t\t\t},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twantNs:  \"NaN\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nAn\",\n\t\t\targs: args{\n\t\t\t\ts: \"nAn\",\n\t\t\t},\n\t\t\twantNs:  \"nAn\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char\",\n\t\t\targs: args{\n\t\t\t\ts: \"123a\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at the beginning\",\n\t\t\targs: args{\n\t\t\t\ts: \"a123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"a123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char after sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"-a123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"-a123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char after sign (2)\",\n\t\t\targs: args{\n\t\t\t\ts: \"+a123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+a123\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}","2d5f2487d64d711a19307d18f38dabf3":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"empty string\",\n\t\t\targs:    args{s: \"\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"simple integer\",\n\t\t\targs:    args{s: \"123\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"negative integer\",\n\t\t\targs:    args{s: \"-123\"},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"float\",\n\t\t\targs:    args{s: \"123.456\"},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"exponential notation\",\n\t\t\targs:    args{s: \"1.23e+4\"},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"exponential notation with negative exponent\",\n\t\t\targs:    args{s: \"1.23e-4\"},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"inf\",\n\t\t\targs:    args{s: \"inf\"},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"INF\",\n\t\t\targs:    args{s: \"INF\"},\n\t\t\twantNs:  \"INF\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"InF\",\n\t\t\targs:    args{s: \"InF\"},\n\t\t\twantNs:  \"InF\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"nan\",\n\t\t\targs:    args{s: \"nan\"},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"NAN\",\n\t\t\targs:    args{s: \"NAN\"},\n\t\t\twantNs:  \"NAN\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"NaN\",\n\t\t\targs:    args{s: \"NaN\"},\n\t\t\twantNs:  \"NaN\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid start\",\n\t\t\targs:    args{s: \"a123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"a123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid middle\",\n\t\t\targs:    args{s: \"123a456\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a456\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid end\",\n\t\t\targs:    args{s: \"123a\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"special case: starting with -\",\n\t\t\targs:    args{s: \"-123\"},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"special case: starting with +\",\n\t\t\targs:    args{s: \"+123\"},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"special case: starting with - and length \u003c 3\",\n\t\t\targs:    args{s: \"-ab\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"-ab\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"special case: starting with + and length \u003c 3\",\n\t\t\targs:    args{s: \"+ab\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+ab\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}\n","2d6e38d353e304097ec83f3d45819f1d":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttype want struct {\n\t\tv   *Value\n\t\ts   string\n\t\terr error\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant want\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs:           nil,\n\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ts:   \"\",\n\t\t\t\terr: nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"single key-value pair\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\": \"value\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ts:   \"\",\n\t\t\t\terr: nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"multiple key-value pairs\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ts:   \"\",\n\t\t\t\terr: nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"key2\": \"value2\"}}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ts:   \"\",\n\t\t\t\terr: nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\": \"value\"`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ts:   `{\"key\": \"value\"`,\n\t\t\t\terr: fmt.Errorf(\"missing '}'\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"missing key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{:\"value\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ts:   `{:\"value\"}`,\n\t\t\t\terr: fmt.Errorf(`cannot find opening '\"\" for object key`),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\" \"value\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ts:   `{\"key\" \"value\"}`,\n\t\t\t\terr: fmt.Errorf(\"missing ':' after object key\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ts:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\terr: fmt.Errorf(\"missing ',' after object value\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected end of object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\": \"value`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ts:   `{\"key\": \"value`,\n\t\t\t\terr: fmt.Errorf(\"unexpected end of object\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"invalid key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\": \"value\", \"key2: \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ts:   `{\"key\": \"value\", \"key2: \"value2\"}`,\n\t\t\t\terr: fmt.Errorf(\"cannot parse object key: cannot parse key: missing closing quote\"),\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotV, gotS, gotErr := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif gotErr != nil \u0026\u0026 tt.want.err == nil {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, want nil\", gotErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotErr == nil \u0026\u0026 tt.want.err != nil {\n\t\t\t\tt.Errorf(\"parseObject() error = nil, want %v\", tt.want.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotErr != nil \u0026\u0026 tt.want.err != nil \u0026\u0026 gotErr.Error() != tt.want.err.Error() {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, want %v\", gotErr, tt.want.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(gotV, tt.want.v) {\n\t\t\t\tt.Errorf(\"parseObject() gotV = %v, want %v\", gotV, tt.want.v)\n\t\t\t}\n\t\t\tif gotS != tt.want.s {\n\t\t\t\tt.Errorf(\"parseObject() gotS = %v, want %v\", gotS, tt.want.s)\n\t\t\t}\n\t\t})\n\t}\n}","2df992bd75b18193a3fe156e4b85d482":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"simple integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"float\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponent\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e-4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"inf\",\n\t\t\t},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"nan\",\n\t\t\t},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123abc\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"abc\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number 2\",\n\t\t\targs: args{\n\t\t\t\ts: \"123+\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"123+\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number 3\",\n\t\t\targs: args{\n\t\t\t\ts: \"-+\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"-+\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}\n","2e1e87a1802ab10a8d0fff9413ec247c":"package fastjson\n\nimport (\n\t\"testing\"\n\t\"unicode/utf16\"\n\t\"strconv\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"😀\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\x\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\x\",\n\t\t},\n\t\t{\n\t\t\tname: \"too short escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\\\\\ \\\\/\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\x\"},\n\t\t\twant: \"\\\"hello\\\" \\\\world\\\\ /\\\\b\\\\f\\\\n\\\\r\\tabc😀\\\\x\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","2e2c86f97ac7952a6d612a1dfbcc2116":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t\t{\n\t\t\tname: \"ParseObject\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": 2}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"2\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"ParseArray\",\n\t\t\targs: args{\n\t\t\t\ts:   `[1, \"value2\", true]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeString, s: \"value2\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"ParseString\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"value3\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"value3\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"ParseTrue\",\n\t\t\targs: args{\n\t\t\t\ts:   \"true\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueTrue,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"ParseFalse\",\n\t\t\targs: args{\n\t\t\t\ts:   \"false\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueFalse,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"ParseNull\",\n\t\t\targs: args{\n\t\t\t\ts:   \"null\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueNull,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"ParseNumber\",\n\t\t\targs: args{\n\t\t\t\ts:   \"123.456\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"ParseInvalidJSON\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"{\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !json.Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseValue() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","2f909e3670e0008a815b20c6f7e8a3a7":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped string with multiple escapes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\"\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: ``,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"no quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `hello`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","2fa92d72de8793804a62897e8d2d73f2":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestType_String(t *testing.T) {\n\ttype args struct {\n\t\tt Type\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"TypeObject\",\n\t\t\targs: args{t: TypeObject},\n\t\t\twant: \"object\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeArray\",\n\t\t\targs: args{t: TypeArray},\n\t\t\twant: \"array\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeString\",\n\t\t\targs: args{t: TypeString},\n\t\t\twant: \"string\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeNumber\",\n\t\t\targs: args{t: TypeNumber},\n\t\t\twant: \"number\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeTrue\",\n\t\t\targs: args{t: TypeTrue},\n\t\t\twant: \"true\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeFalse\",\n\t\t\targs: args{t: TypeFalse},\n\t\t\twant: \"false\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeNull\",\n\t\t\targs: args{t: TypeNull},\n\t\t\twant: \"null\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.t.String(); got != tt.want {\n\t\t\t\tt.Errorf(\"Type.String() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","2fb0fc2eb32e058ac2dd842299b25569":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGet(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant *Value\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.Get(tt.args.keys...); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Get() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","2fe3ae84a715a014fd4df63781c671e4":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:    \"\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:    \"null\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueNull,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:    \"true\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueTrue,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:    \"false\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueFalse,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:    \"123\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:    `\"hello\"`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\": \"value\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: typeRawString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:    `[1, 2, 3]`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\": {\"nested_key\": \"value\"}}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nested_key\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: typeRawString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\": [1, 2, 3]}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\": {\"nested_key\": {\"deeply_nested_key\": \"value\"}}}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: MaxDepth - 1,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key\": {\"nested_key\": {\"deeply_nested_key\": \"value\"}}}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid json\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\": \"value`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key\": \"value`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid json 2\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\": \"value\", \"key2\": \"value2`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key\": \"value\", \"key2\": \"value2`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseValue() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseValue_NaN(t *testing.T) {\n\ts := \"nan\"\n\tc := \u0026cache{}\n\tv, tail, err := parseValue(s, c, 0)\n\tif err != nil {\n\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, nil)\n\t\treturn\n\t}\n\tif tail != \"\" {\n\t\tt.Errorf(\"parseValue() got1 = %v, want %v\", tail, \"\")\n\t}\n\tif v.t != TypeNumber {\n\t\tt.Errorf(\"parseValue() got = %v, want %v\", v.t, TypeNumber)\n\t}\n\tif v.s != \"nan\" {\n\t\tt.Errorf(\"parseValue() got = %v, want %v\", v.s, \"nan\")\n\t}\n}\n\nfunc TestParseValue_NegativeNumber(t *testing.T) {\n\ts := \"-123\"\n\tc := \u0026cache{}\n\tv, tail, err := parseValue(s, c, 0)\n\tif err != nil {\n\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, nil)\n\t\treturn\n\t}\n\tif tail != \"\" {\n\t\tt.Errorf(\"parseValue() got1 = %v, want %v\", tail, \"\")\n\t}\n\tif v.t != TypeNumber {\n\t\tt.Errorf(\"parseValue() got = %v, want %v\", v.t, TypeNumber)\n\t}\n\tif v.s != \"-123\" {\n\t\tt.Errorf(\"parseValue() got = %v, want %v\", v.s, \"-123\")\n\t}\n}\n\nfunc TestParseValue_FloatNumber(t *testing.T) {\n\ts := \"123.456\"\n\tc := \u0026cache{}\n\tv, tail, err := parseValue(s, c, 0)\n\tif err != nil {\n\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, nil)\n\t\treturn\n\t}\n\tif tail != \"\" {\n\t\tt.Errorf(\"parseValue() got1 = %v, want %v\", tail, \"\")\n\t}\n\tif v.t != TypeNumber {\n\t\tt.Errorf(\"parseValue() got = %v, want %v\", v.t, TypeNumber)\n\t}\n\tif v.s != \"123.456\" {\n\t\tt.Errorf(\"parseValue() got = %v, want %v\", v.s, \"123.456\")\n\t}\n}\n\nfunc TestParseValue_ExponentialNumber(t *testing.T) {\n\ts := \"1.23e+4\"\n\tc := \u0026cache{}\n\tv, tail, err := parseValue(s, c, 0)\n\tif err != nil {\n\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, nil)\n\t\treturn\n\t}\n\tif tail != \"\" {\n\t\tt.Errorf(\"parseValue() got1 = %v, want %v\", tail, \"\")\n\t}\n\tif v.t != TypeNumber {\n\t\tt.Errorf(\"parseValue() got = %v, want %v\", v.t, TypeNumber)\n\t}\n\tif v.s != \"1.23e+4\" {\n\t\tt.Errorf(\"parseValue() got = %v, want %v\", v.s, \"1.23e+4\")\n\t}\n}\n\nfunc TestParseValue_LargeNumber(t *testing.T) {\n\ts := \"999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999\"\n\tc := \u0026cache{}\n\tv, tail, err := parseValue(s, c, 0)\n\tif err != nil {\n\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, nil)\n\t\treturn\n\t}\n\tif tail != \"\" {\n\t\tt.Errorf(\"parseValue() got1 = %v, want %v\", tail, \"\")\n\t}\n\tif v.t != TypeNumber {\n\t\tt.Errorf(\"parseValue() got = %v, want %v\", v.t, TypeNumber)\n\t}\n\tif v.s != s {\n\t\tt.Errorf(\"parseValue() got = %v, want %v\", v.s, s)\n\t}\n}\n\nfunc TestParseValue_JSONMarshal(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:    \"null\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    \"null\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:    \"true\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    \"true\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:    \"false\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    \"false\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:    \"123\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    \"123\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:    `\"hello\"`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `\"hello\"`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\": \"value\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `{\"key\":\"value\"}`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:    `[1, 2, 3]`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `[1,2,3]`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\": {\"nested_key\": \"value\"}}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `{\"key\":{\"nested_key\":\"value\"}}`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\": [1, 2, 3]}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `{\"key\":[1,2,3]}`,\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err == nil {\n\t\t\t\tb, err := json.Marshal(got)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"json.Marshal() error = %v\", err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif string(b) != tt.want {\n\t\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", string(b), tt.want)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","2ff1850ae86de1ccc21484979242f638":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escaped string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\\\\\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: ``,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"no opening quote\",\n\t\t\targs: args{\n\t\t\t\ts: `hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\\\\\\\"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","2ff24b4095c848855256487499af5870":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueGet(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant *Value\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.Get(tt.args.keys...); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.Get() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","2ff422ba8ebbc2fbda9512c1f666199b":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGet(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttype want struct {\n\t\twant *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant want\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.Get(tt.args.keys...); !reflect.DeepEqual(got, tt.want.want) {\n\t\t\t\tt.Errorf(\"Get() = %v, want %v\", got, tt.want.want)\n\t\t\t}\n\t\t})\n\t}\n}","303ad9d4dc410347d2cbd3bf7c648fec":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_getKV(t *testing.T) {\n\ttype args struct {\n\t\to *Object\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant *kv\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.o.getKV(); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Object.getKV() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","303b207c74ac5ea4ce5afbb436c3bd7f":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestType_String(t *testing.T) {\n\ttype args struct {\n\t\tt Type\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"TestType_String_Object\",\n\t\t\targs: args{\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\twant: \"object\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_Array\",\n\t\t\targs: args{\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\twant: \"array\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_String\",\n\t\t\targs: args{\n\t\t\t\tt: TypeString,\n\t\t\t},\n\t\t\twant: \"string\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_Number\",\n\t\t\targs: args{\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\twant: \"number\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_True\",\n\t\t\targs: args{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: \"true\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_False\",\n\t\t\targs: args{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: \"false\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_Null\",\n\t\t\targs: args{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: \"null\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.t.String(); got != tt.want {\n\t\t\t\tt.Errorf(\"Type.String() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","3054603d186f99fd6bc0c1c19a1e5682":"package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"basic escape sequences\",\n\t\t\targs: args{s: \"hello\\\\\\\"world\\\\t\\\\n\\\\r\\\\b\\\\f\"},\n\t\t\twant: \"hello\\\"world\\t\\n\\r\\b\\f\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequences\",\n\t\t\targs: args{s: \"hello\\\\xworld\\\\y\"},\n\t\t\twant: \"hello\\\\xworld\\\\y\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode characters\",\n\t\t\targs: args{s: \"hello\\\\u0020world\\\\u00A0\"},\n\t\t\twant: \"hello world\\u00A0\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"hello\\\\uD83D\\\\uDE01world\"},\n\t\t\twant: \"hello😁world\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid surrogate pair\",\n\t\t\targs: args{s: \"hello\\\\uD83D\\\\u0001world\"},\n\t\t\twant: \"hello\\\\uD83D\\\\u0001world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode characters with invalid sequence\",\n\t\t\targs: args{s: \"hello\\\\u0020world\\\\u00A\\\\u0001\"},\n\t\t\twant: \"hello world\\\\u00A\\\\u0001\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_surrogatePair(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"😁\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with surrounding text\",\n\t\t\targs: args{s: \"hello\\\\uD83D\\\\uDE01world\"},\n\t\t\twant: \"hello😁world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid sequence\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\u0001\"},\n\t\t\twant: \"😁\\\\uD83D\\\\u0001\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_invalidEscapeSequence(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\x\"},\n\t\t\twant: \"\\\\x\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence with surrounding text\",\n\t\t\targs: args{s: \"hello\\\\xworld\"},\n\t\t\twant: \"hello\\\\xworld\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence with multiple characters\",\n\t\t\targs: args{s: \"\\\\xy\"},\n\t\t\twant: \"\\\\xy\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_incompleteUnicodeEscape(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"incomplete unicode escape\",\n\t\t\targs: args{s: \"\\\\u002\"},\n\t\t\twant: \"\\\\u002\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete unicode escape with surrounding text\",\n\t\t\targs: args{s: \"hello\\\\u002world\"},\n\t\t\twant: \"hello\\\\u002world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete unicode escape with multiple characters\",\n\t\t\targs: args{s: \"\\\\u0020world\\\\u00A\"},\n\t\t\twant: \"\\\\u0020world\\\\u00A\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_strconvParseUintError(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"invalid hex value\",\n\t\t\targs: args{s: \"\\\\u00zz\"},\n\t\t\twant: \"\\\\u00zz\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid hex value with surrounding text\",\n\t\t\targs: args{s: \"hello\\\\u00zzworld\"},\n\t\t\twant: \"hello\\\\u00zzworld\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid hex value with multiple characters\",\n\t\t\targs: args{s: \"\\\\u00zz\\\\u00aa\"},\n\t\t\twant: \"\\\\u00zz\\\\u00aa\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_escapedBackslash(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"escaped backslash\",\n\t\t\targs: args{s: \"\\\\\\\\\"},\n\t\t\twant: \"\\\\\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslash with surrounding text\",\n\t\t\targs: args{s: \"hello\\\\\\\\world\"},\n\t\t\twant: \"hello\\\\world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslash with multiple characters\",\n\t\t\targs: args{s: \"\\\\\\\\\\\\\\\\\"},\n\t\t\twant: \"\\\\\\\\\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_escapedQuote(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"escaped quote\",\n\t\t\targs: args{s: \"\\\\\\\"\"},\n\t\t\twant: \"\\\"\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quote with surrounding text\",\n\t\t\targs: args{s: \"hello\\\\\\\"world\"},\n\t\t\twant: \"hello\\\"world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quote with multiple characters\",\n\t\t\targs: args{s: \"\\\\\\\"\\\\\\\"\",\n\t\t\twant: \"\\\"\\\"\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","3081f2b7867988b78d42025b66c8cccd":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"empty string\",\n\t\t\targs:    args{s: \"\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"single digit\",\n\t\t\targs:    args{s: \"1\"},\n\t\t\twantNs:  \"1\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"multiple digits\",\n\t\t\targs:    args{s: \"123\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"negative number\",\n\t\t\targs:    args{s: \"-123\"},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with decimal\",\n\t\t\targs:    args{s: \"123.456\"},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with exponent\",\n\t\t\targs:    args{s: \"1.23e4\"},\n\t\t\twantNs:  \"1.23e4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with exponent and sign\",\n\t\t\targs:    args{s: \"1.23e+4\"},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with exponent and negative sign\",\n\t\t\targs:    args{s: \"1.23e-4\"},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading zeros\",\n\t\t\targs:    args{s: \"00123\"},\n\t\t\twantNs:  \"00123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign\",\n\t\t\targs:    args{s: \"+123\"},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with trailing characters\",\n\t\t\targs:    args{s: \"123abc\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"abc\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading characters\",\n\t\t\targs:    args{s: \"abc123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"abc123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number\",\n\t\t\targs:    args{s: \"123a\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}","30a6bbea29b047461f96d6422567f1ed":"```go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetInt(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttype want struct {\n\t\twant int\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant want\n\t}{\n\t\t{\n\t\t\tname: \"empty\",\n\t\t\tv:    \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\targs: args{keys: nil},\n\t\t\twant: want{want: 123},\n\t\t},\n\t\t{\n\t\t\tname: \"simple\",\n\t\t\tv:    \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\targs: args{keys: []string{\"a\"}},\n\t\t\twant: want{want: 0},\n\t\t},\n\t\t{\n\t\t\tname: \"int\",\n\t\t\tv:    \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\targs: args{keys: []string{\"a\", \"b\", \"1\"}},\n\t\t\twant: want{want: 0},\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tv:    \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"a\", v: \u0026Value{t: TypeNumber, s: \"123\"}}}}},\n\t\t\targs: args{keys: []string{\"a\"}},\n\t\t\twant: want{want: 123},\n\t\t},\n\t\t{\n\t\t\tname: \"object nested\",\n\t\t\tv:    \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"a\", v: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"b\", v: \u0026Value{t: TypeNumber, s: \"123\"}}}}}}}}},\n\t\t\targs: args{keys: []string{\"a\", \"b\"}},\n\t\t\twant: want{want: 123},\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tv:    \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"123\"}}},\n\t\t\targs: args{keys: []string{\"0\"}},\n\t\t\twant: want{want: 123},\n\t\t},\n\t\t{\n\t\t\tname: \"array nested\",\n\t\t\tv:    \u0026Value{t: TypeArray, a: []*Value{{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"123\"}}}}},\n\t\t\targs: args{keys: []string{\"0\", \"0\"}},\n\t\t\twant: want{want: 123},\n\t\t},\n\t\t{\n\t\t\tname: \"invalid type\",\n\t\t\tv:    \u0026Value{t: TypeString","31708e9592fc730726c6da06f0a4e763":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetObject(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttype want struct {\n\t\twant *Object\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant want\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.GetObject(tt.args.keys...); !reflect.DeepEqual(got, tt.want.want) {\n\t\t\t\tt.Errorf(\"GetObject() = %v, want %v\", got, tt.want.want)\n\t\t\t}\n\t\t})\n\t}\n}","333e884dc25e2d7b7f3d4f1c2e529dc0":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello\\\"\",\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello\\\\\\\"world\\\"\",\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello\\\\\\\"world\\\\\\\"!\\\"\",\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped backslashes\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello\\\\\\\\world\\\"\",\n\t\t\t},\n\t\t\twant:    \"hello\\\\world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with unclosed quote\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello\",\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with unclosed quote and escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello\\\\\\\"world\",\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote and unclosed quote\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello\\\\\\\"\",\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","33bbc286c9451caee7ebaaf46dcc21c3":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_reset(t *testing.T) {\n\ttype args struct {\n\t\to *Object\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant *Object\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.o.reset(); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Object.reset() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","34b7165e20b8f325f1cd12eb03dfd9f7":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueInt(t *testing.T) {\n\ttype args struct {\n\t\tv *Value\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    int\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := tt.args.v.Int()\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Value.Int() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Value.Int() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","34e720be16f6ed3adf8118013d3b1dfe":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttype want struct {\n\t\tv   *Value\n\t\ts   string\n\t\terr error\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant want\n\t}{\n\t\t{\n\t\t\tname: \"Empty Object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs:           nil,\n\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ts: \"\",\n\t\t\t\terr: nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"Simple Object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ts: \"\",\n\t\t\t\terr: nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"Object with Escaped Keys\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\\\\\\\"1\": \"value1\", \"key\\\\\\\"2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key\\\"2\",\n\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ts: \"\",\n\t\t\t\terr: nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"Nested Object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey1\",\n\t\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue1\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ts: \"\",\n\t\t\t\terr: nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"Missing Closing Brace\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\terr: fmt.Errorf(\"missing '}'\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"Missing Key\",\n\t\t\targs: args{\n\t\t\t\ts:   `{:\"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ts:   `{:\"value1\", \"key2\": \"value2\"}`,\n\t\t\t\terr: fmt.Errorf(`cannot find opening '\"\" for object key`),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"Missing Colon\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ts:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\terr: fmt.Errorf(\"missing ':' after object key\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"Invalid Key\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\terr: fmt.Errorf(\"missing '}'\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"Invalid Value\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": value1, \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ts:   `{\"key1\": value1, \"key2\": \"value2\"}`,\n\t\t\t\terr: fmt.Errorf(\"cannot parse object value: unexpected end of JSON input\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"Missing Comma\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ts:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\terr: fmt.Errorf(\"missing ',' after object value\"),\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotV, gotS, gotErr := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif gotErr != nil {\n\t\t\t\tif tt.want.err == nil {\n\t\t\t\t\tt.Errorf(\"parseObject() error = %v, want nil\", gotErr)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif !json.Valid([]byte(gotS)) {\n\t\t\t\t\tt.Errorf(\"parseObject() unexpected remaining string: %q, want valid json string\", gotS)\n\t\t\t\t}\n\t\t\t\tif gotErr.Error() != tt.want.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseObject() error = %v, want %v\", gotErr, tt.want.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\tif tt.want.err == nil \u0026\u0026 gotErr != nil {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, want nil\", gotErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotV != nil {\n\t\t\t\tif tt.want.v == nil {\n\t\t\t\t\tt.Errorf(\"parseObject() = %v, want nil\", gotV)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif !compareValues(gotV, tt.want.v) {\n\t\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", gotV, tt.want.v)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif tt.want.v != nil {\n\t\t\t\t\tt.Errorf(\"parseObject() = nil, want %v\", tt.want.v)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif gotS != tt.want.s {\n\t\t\t\tt.Errorf(\"parseObject() gotS = %q, want %q\", gotS, tt.want.s)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !compareValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !compareValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\tcase TypeString:\n\t\tif v1.s != v2.s {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","352054701a05c0ea76f056039ee028d9":"package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello world\",\n\t\t\t},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\\\\"hello\\\\\\\"\",\n\t\t\t},\n\t\t\twant: \"\\\"hello\\\"\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\\\\\hello\\\\\\\\\",\n\t\t\t},\n\t\t\twant: \"\\\\hello\\\\\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\/hello\\\\/\",\n\t\t\t},\n\t\t\twant: \"/hello/\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\bhello\\\\b\",\n\t\t\t},\n\t\t\twant: \"\\bhello\\b\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\fhello\\\\f\",\n\t\t\t},\n\t\t\twant: \"\\fhello\\f\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\nhello\\\\n\",\n\t\t\t},\n\t\t\twant: \"\\nhello\\n\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\rhello\\\\r\",\n\t\t\t},\n\t\t\twant: \"\\rhello\\r\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\thello\\\\t\",\n\t\t\t},\n\t\t\twant: \"\\thello\\t\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\u0061\\\\u0062\\\\u0063\",\n\t\t\t},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\uD83D\\\\uDE03\",\n\t\t\t},\n\t\t\twant: \"😂\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\xhello\\\\x\",\n\t\t\t},\n\t\t\twant: \"\\\\xhello\\\\x\",\n\t\t},\n\t\t{\n\t\t\tname: \"short unicode escape sequence\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\u006\",\n\t\t\t},\n\t\t\twant: \"\\\\u006\",\n\t\t},\n\t\t{\n\t\t\tname: \"short surrogate escape sequence\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\uD83D\",\n\t\t\t},\n\t\t\twant: \"\\\\uD83D\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid surrogate escape sequence\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\uD83D\\\\uDE0\",\n\t\t\t},\n\t\t\twant: \"\\\\uD83D\\\\uDE0\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\\\\"hello\\\\\\\"\\\\t\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE03\",\n\t\t\t},\n\t\t\twant: \"\\\"hello\\\"\\tabc😂\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","36b8bc01cb6a97aac3ef6a838c4f1a2d":"package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped control characters\",\n\t\t\targs: args{s: \"\\\\b\\\\f\\\\n\\\\r\\\\t\"},\n\t\t\twant: \"\\b\\f\\n\\r\\t\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode characters\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pairs\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"😀\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequences\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u\\\\x00\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u\\\\x00\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode characters with surrogate pairs\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\\\\u0064\\\\u0065\\\\u0066\"},\n\t\t\twant: \"abc😀def\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode characters with incomplete surrogate pairs\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"😀abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode characters with invalid surrogate pairs\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\uD83D\\\\uDE03\"},\n\t\t\twant: \"😀\\uD83D\\uDE02\\uD83D\\uDE03\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode characters with invalid surrogate pairs and incomplete surrogate pairs\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\\\\uD83D\\\\uDE03\\\\uD83D\"},\n\t\t\twant: \"😀\\uD83D\\uDE02\\uD83D\\uDE03\\uD83D\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","387bddf6b1481bddeded9525ddd43a5d":"package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quote\",\n\t\t\targs: args{s: \"\\\\\\\"\"},\n\t\t\twant: \"\\\"\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslash\",\n\t\t\targs: args{s: \"\\\\\\\\\"},\n\t\t\twant: \"\\\\\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped slash\",\n\t\t\targs: args{s: \"\\\\/\"},\n\t\t\twant: \"/\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\b\"},\n\t\t\twant: \"\\b\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\f\"},\n\t\t\twant: \"\\f\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\n\"},\n\t\t\twant: \"\\n\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\r\"},\n\t\t\twant: \"\\r\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\t\"},\n\t\t\twant: \"\\t\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character\",\n\t\t\targs: args{s: \"\\\\u0020\"},\n\t\t\twant: \" \",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE03\"},\n\t\t\twant: \"😂\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\u\"},\n\t\t\twant: \"\\\\u\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence 2\",\n\t\t\targs: args{s: \"\\\\u123\"},\n\t\t\twant: \"\\\\u123\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence 3\",\n\t\t\targs: args{s: \"\\\\uD83D\"},\n\t\t\twant: \"\\\\uD83D\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0020\\\\uD83D\\\\uDE03\\\\u\"},\n\t\t\twant: \"\\\"\\\\b\\f\\n\\r\\t 😂\\\\u\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","39322df48baace138a017c3d3bc1d3b5":"```go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetArray(t *testing.T) {\n\t","3a0ad62efe4f25d6536920f0034c4190":"```go\npackage fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"strconv\"\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello world\",\n\t\t\t},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\\\\"hello\\\\\\\"\",\n\t\t\t},\n\t\t\twant: \"\\\"hello\\\"\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\\\\\hello\\\\\\\\\",\n\t\t\t},\n\t\t\twant: \"\\\\hello\\\\\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\/hello\\\\/\",\n\t\t\t},\n\t\t\twant: \"/hello/\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\bhello\\\\b\",\n\t\t\t},\n\t\t\twant: \"\\bhello\\b\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\fhello\\\\f\",\n\t\t\t},\n\t\t\twant: \"\\fhello\\f\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\nhello\\\\n\",\n\t\t\t},\n\t\t\twant: \"\\nhello\\n\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\rhello\\\\r\",\n\t\t\t},\n\t\t\twant: \"\\rhello\\r\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\thello\\\\t\",\n\t\t\t},\n\t\t\twant: \"\\thello\\t\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\u00","3a398eada6bb87a5c52c84d718887602":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueObject(t *testing.T) {\n\ttype args struct {\n\t\tv *Value\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Object\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := tt.args.v.Object()\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Value.Object() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.Object() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","3aaf7a1aae8189f0ac66ba79a7f3d3ae":"package fastjson\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\tv   *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"RawString\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: typeRawString, s: \"test\"},\n\t\t\t},\n\t\t\twant: []byte(`\"test\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"Object\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{t: TypeString, s: \"value\"}}}}},\n\t\t\t},\n\t\t\twant: []byte(`{\"key\":\"value\"}`),\n\t\t},\n\t\t{\n\t\t\tname: \"Array\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeArray, a: []*Value{{t: TypeString, s: \"value1\"}, {t: TypeString, s: \"value2\"}}},\n\t\t\t},\n\t\t\twant: []byte(`[\"value1\",\"value2\"]`),\n\t\t},\n\t\t{\n\t\t\tname: \"String\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeString, s: \"test\"},\n\t\t\t},\n\t\t\twant: []byte(`\"test\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"Number\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t},\n\t\t\twant: []byte(`123`),\n\t\t},\n\t\t{\n\t\t\tname: \"True\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeTrue},\n\t\t\t},\n\t\t\twant: []byte(`true`),\n\t\t},\n\t\t{\n\t\t\tname: \"False\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeFalse},\n\t\t\t},\n\t\t\twant: []byte(`false`),\n\t\t},\n\t\t{\n\t\t\tname: \"Null\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNull},\n\t\t\t},\n\t\t\twant: []byte(`null`),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.v.MarshalTo(tt.args.dst); !bytes.Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","3b184aa717383a10e0642287c3ad0201":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttype want struct {\n\t\tv   *Value\n\t\ts   string\n\t\terr error\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant want\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{},\n\t\t\t\t},\n\t\t\t\ts:   \"\",\n\t\t\t\terr: nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"array with one element\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ts:   \"\",\n\t\t\t\terr: nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"array with multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,3]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ts:   \"\",\n\t\t\t\terr: nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"array with nested array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[[1,2],[3,4]]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\ts: \"4\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ts:   \"\",\n\t\t\t\terr: nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"array with missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ts:   \"[1,2\",\n\t\t\t\terr: fmt.Errorf(\"missing ']'\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"array with unexpected end of array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ts:   \"[1,2,\",\n\t\t\t\terr: fmt.Errorf(\"unexpected end of array\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"array with missing comma after value\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1 2]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ts:   \"[1 2]\",\n\t\t\t\terr: fmt.Errorf(\"missing ',' after array value\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"array with invalid value\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ts:   \"[1,2,\",\n\t\t\t\terr: fmt.Errorf(\"cannot parse array value: missing ']'\"),\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotV, gotS, gotErr := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif gotErr != nil \u0026\u0026 tt.want.err == nil {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", gotErr, tt.want.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotErr == nil \u0026\u0026 tt.want.err != nil {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", gotErr, tt.want.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotErr != nil \u0026\u0026 tt.want.err != nil \u0026\u0026 gotErr.Error() != tt.want.err.Error() {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", gotErr, tt.want.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(gotV, tt.want.v) {\n\t\t\t\tt.Errorf(\"parseArray() gotV = %v, want %v\", gotV, tt.want.v)\n\t\t\t}\n\t\t\tif gotS != tt.want.s {\n\t\t\t\tt.Errorf(\"parseArray() gotS = %v, want %v\", gotS, tt.want.s)\n\t\t\t}\n\t\t})\n\t}\n}","3c43fd358c0d29f9399e5e3093638908":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWS(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"Empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"Whitespace string\",\n\t\t\targs: args{s: \"  \\t\\n \"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"String with leading whitespace\",\n\t\t\targs: args{s: \"  hello\"},\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"String with trailing whitespace\",\n\t\t\targs: args{s: \"hello  \"},\n\t\t\twant: \"hello  \",\n\t\t},\n\t\t{\n\t\t\tname: \"String with whitespace in the middle\",\n\t\t\targs: args{s: \"hello  world\"},\n\t\t\twant: \"hello  world\",\n\t\t},\n\t\t{\n\t\t\tname: \"String with no whitespace\",\n\t\t\targs: args{s: \"hello\"},\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"String with non-whitespace character\",\n\t\t\targs: args{s: \"!\"},\n\t\t\twant: \"!\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWS(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWS() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","3c5d58b5438759a28be54d5c21c2f82c":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Array(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    []*Value\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tp := NewParser()\n\t\t\tv, err := p.Parse(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Parse() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgot, err := v.Array()\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Array() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Array() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","3c85e974218694a7de9cb13fa4be2f63":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantV   *Value\n\t\twantTail string\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t\t{\n\t\t\tname: \"parse object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": 2}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"2\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantTail: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname: \"parse array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[1, \"2\", true]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeString, s: \"2\"},\n\t\t\t\t\t{t: TypeTrue, s: \"true\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantTail: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname: \"parse string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"hello world\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello world\",\n\t\t\t},\n\t\t\twantTail: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname: \"parse number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantTail: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname: \"parse true\",\n\t\t\targs: args{\n\t\t\t\ts:   `true`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: valueTrue,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname: \"parse false\",\n\t\t\targs: args{\n\t\t\t\ts:   `false`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: valueFalse,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname: \"parse null\",\n\t\t\targs: args{\n\t\t\t\ts:   `null`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: valueNull,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname: \"parse empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   ``,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV:   nil,\n\t\t\twantTail: \"\",\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname: \"parse invalid json\",\n\t\t\targs: args{\n\t\t\t\ts:   `{`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV:   nil,\n\t\t\twantTail: \"{\",\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname: \"parse too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:     `{\"key1\": {\"key2\": {\"key3\": \"value3\"}}}`,\n\t\t\t\tc:     \u0026cache{},\n\t\t\t\tdepth: MaxDepth - 1,\n\t\t\t},\n\t\t\twantV:   nil,\n\t\t\twantTail: `{\"key1\": {\"key2\": {\"key3\": \"value3\"}}}`,\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotV, gotTail, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(gotV, tt.wantV) {\n\t\t\t\tt.Errorf(\"parseValue() gotV = %v, want %v\", gotV, tt.wantV)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseValue() gotTail = %v, want %v\", gotTail, tt.wantTail)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_parseValue_number(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantTail string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"parse integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"parse float\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"parse negative integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"parse negative float\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123.456\",\n\t\t\t},\n\t\t\twantNs:  \"-123.456\",\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"parse exponential\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"parse exponential with negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e-4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"parse invalid number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123+\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantTail: \"123+\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotTail, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotTail = %v, want %v\", gotTail, tt.wantTail)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseValue_withCache(t *testing.T) {\n\tc := \u0026cache{}\n\t// Allocate a few values in the cache\n\tfor i := 0; i \u003c 10; i++ {\n\t\tc.getValue()\n\t}\n\n\t// Parse a JSON string that will use values from the cache\n\ts := `{\"key1\": \"value1\", \"key2\": 2}`\n\tv, tail, err := parseValue(s, c, 0)\n\n\t// Check that the parsing was successful\n\tif err != nil {\n\t\tt.Errorf(\"parseValue() error = %v\", err)\n\t}\n\n\t// Check that the returned value is correct\n\tif v == nil {\n\t\tt.Errorf(\"parseValue() returned nil value\")\n\t}\n\n\t// Check that the tail is empty\n\tif tail != \"\" {\n\t\tt.Errorf(\"parseValue() returned non-empty tail: %s\", tail)\n\t}\n\n\t// Check that the cache has been used for the values\n\tif len(c.vs) != 10 {\n\t\tt.Errorf(\"parseValue() did not use the cache: expected %d values, got %d\", 10, len(c.vs))\n\t}\n\n\t// Check that the values in the cache are correct\n\texpectedValues := []Type{\n\t\tTypeObject,\n\t\tTypeString,\n\t\tTypeNumber,\n\t}\n\tfor i, value := range c.vs {\n\t\tif i \u003e= len(expectedValues) {\n\t\t\tbreak\n\t\t}\n\t\tif value.t != expectedValues[i] {\n\t\t\tt.Errorf(\"parseValue() cache value %d has unexpected type: %v, expected %v\", i, value.t, expectedValues[i])\n\t\t}\n\t}\n}\n\nfunc TestParseValue_NaN(t *testing.T) {\n\ts := `{\"key1\": \"value1\", \"key2\": NaN}`\n\tc := \u0026cache{}\n\tv, tail, err := parseValue(s, c, 0)\n\n\tif err != nil {\n\t\tt.Errorf(\"parseValue() error = %v\", err)\n\t}\n\n\tif v == nil {\n\t\tt.Errorf(\"parseValue() returned nil value\")\n\t}\n\n\tif tail != \"\" {\n\t\tt.Errorf(\"parseValue() returned non-empty tail: %s\", tail)\n\t}\n\n\tif len(c.vs) != 2 {\n\t\tt.Errorf(\"parseValue() did not use the cache: expected %d values, got %d\", 2, len(c.vs))\n\t}\n\n\tif c.vs[1].t != TypeNumber {\n\t\tt.Errorf(\"parseValue() cache value 1 has unexpected type: %v, expected %v\", c.vs[1].t, TypeNumber)\n\t}\n\n\tif c.vs[1].s != \"NaN\" {\n\t\tt.Errorf(\"parseValue() cache value 1 has unexpected string: %v, expected %v\", c.vs[1].s, \"NaN\")\n\t}\n}\n\nfunc TestParseValue_Unmarshal(t *testing.T) {\n\ts := `{\"key1\": \"value1\", \"key2\": 2}`\n\tc := \u0026cache{}\n\tv, _, err := parseValue(s, c, 0)\n\n\tif err != nil {\n\t\tt.Errorf(\"parseValue() error = %v\", err)\n\t}\n\n\tvar m map[string]interface{}\n\tif err := json.Unmarshal([]byte(v.MarshalTo(nil)), \u0026m); err != nil {\n\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t}\n\n\tif m[\"key1\"] != \"value1\" {\n\t\tt.Errorf(\"json.Unmarshal() key1 value mismatch: %v != %v\", m[\"key1\"], \"value1\")\n\t}\n\n\tif m[\"key2\"] != float64(2) {\n\t\tt.Errorf(\"json.Unmarshal() key2 value mismatch: %v != %v\", m[\"key2\"], float64(2))\n\t}\n}","3d1a0785dcf3d2378895c989662c217c":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetInt(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant int\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.GetInt(tt.args.keys...); got != tt.want {\n\t\t\t\tt.Errorf(\"Value.GetInt() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","3d2d4a89f500c5677c5352bea33edf13":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t\t{\n\t\t\tname: \"Empty Object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Simple Object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": 2}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"2\"}},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Nested Object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": [1, 2, 3]}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{k: \"nestedKey1\", v: \u0026Value{t: TypeString, s: \"nestedValue1\"}},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Invalid Object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_Marshal(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tjson string\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"Empty Object\",\n\t\t\tjson: \"{}\",\n\t\t\twant: \"{}\",\n\t\t},\n\t\t{\n\t\t\tname: \"Simple Object\",\n\t\t\tjson: `{\"key1\": \"value1\", \"key2\": 2}`,\n\t\t\twant: `{\"key1\":\"value1\",\"key2\":2}`,\n\t\t},\n\t\t{\n\t\t\tname: \"Nested Object\",\n\t\t\tjson: `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": [1, 2, 3]}`,\n\t\t\twant: `{\"key1\":{\"nestedKey1\":\"nestedValue1\"},\"key2\":[1,2,3]}`,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tvar obj map[string]interface{}\n\t\t\tif err := json.Unmarshal([]byte(tt.json), \u0026obj); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tc := \u0026cache{}\n\t\t\tv, _, err := parseObject(tt.json, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tgot := string(v.MarshalTo(nil))\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","3d6e3f3ce2b90894ed5585626a6d5265":"package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n)\n\nfunc TestEscapeString(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\ts   string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\ts:   \"\",\n\t\t\t},\n\t\t\twant: []byte(`\"\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\ts:   \"hello\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"string with special characters\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\ts:   \"hello, world!\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello, world!\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped characters\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\ts:   `\"\\/\\\\\"`,\n\t\t\t},\n\t\t\twant: []byte(`\"\\\\/\\\\\\\\\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"string with unicode characters\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\ts:   \"你好，世界！\",\n\t\t\t},\n\t\t\twant: []byte(`\"你好，世界！\"`),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := escapeString(tt.args.dst, tt.args.s); !bytesEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"escapeString() = %v, want %v\", string(got), string(tt.want))\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc bytesEqual(a, b []byte) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","3d8f6ad0ab0bfb926e53c4a95ced9ccd":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    \u0026Value{t: TypeArray, a: []*Value{}},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"single element array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[ \"hello\" ]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    \u0026Value{t: TypeArray, a: []*Value{{t: TypeString, s: \"hello\"}}},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[ 1, 2, 3 ]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[ [ 1, 2 ], [ 3, 4 ] ]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    \u0026Value{t: TypeArray, a: []*Value{{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}}}, {t: TypeArray, a: []*Value{{t: TypeNumber, s: \"3\"}, {t: TypeNumber, s: \"4\"}}}}},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:   `[ 1, 2, 3`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `[ 1, 2, 3`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected end of array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[ 1, 2, 3, `,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `[ 1, 2, 3, `,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:   `[ 1 2, 3 ]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `[ 1 2, 3 ]`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseArray() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","3f31a54f585efbbec2a16c87a8cbe8e0":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,3]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with nested array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[[1,2],[3,4]]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t\t\t\t{t: TypeNumber, s: \"4\"},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `[{\"a\":1,\"b\":2},{\"c\":3,\"d\":4}]`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t{k: \"a\", v: \u0026Value{t: TypeNumber, s: \"1\"}},\n\t\t\t\t\t\t\t\t{k: \"b\", v: \u0026Value{t: TypeNumber, s: \"2\"}},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t{k: \"c\", v: \u0026Value{t: TypeNumber, s: \"3\"}},\n\t\t\t\t\t\t\t\t{k: \"d\", v: \u0026Value{t: TypeNumber, s: \"4\"}},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1,2,\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1 2]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1 2]\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseArray() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseArray_JSONUnmarshal(t *testing.T) {\n\ttype TestData struct {\n\t\tA []int `json:\"a\"`\n\t\tB []string `json:\"b\"`\n\t\tC []map[string]interface{} `json:\"c\"`\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tjson string\n\t\twant *TestData\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\tjson: `{\"a\":[],\"b\":[],\"c\":[]}`,\n\t\t\twant: \u0026TestData{\n\t\t\t\tA: []int{},\n\t\t\t\tB: []string{},\n\t\t\t\tC: []map[string]interface{}{},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"simple array\",\n\t\t\tjson: `{\"a\":[1,2,3],\"b\":[\"a\",\"b\",\"c\"],\"c\":[{\"d\":1,\"e\":2},{\"f\":3,\"g\":4}]}`,\n\t\t\twant: \u0026TestData{\n\t\t\t\tA: []int{1, 2, 3},\n\t\t\t\tB: []string{\"a\", \"b\", \"c\"},\n\t\t\t\tC: []map[string]interface{}{\n\t\t\t\t\t{\"d\": 1, \"e\": 2},\n\t\t\t\t\t{\"f\": 3, \"g\": 4},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tvar got TestData\n\t\t\tc := \u0026cache{}\n\t\t\tv, _, err := parse(tt.json, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"parse() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err := json.Unmarshal(v.StringBytes(), \u0026got); err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(\u0026got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","3f357661c008ff56cdc0f9cfad225fac":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestValueBool(t *testing.T) {\n\ttype args struct {\n\t\tv *Value\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    bool\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"Bool_True\",\n\t\t\targs: args{\n\t\t\t\tv: \u0026Value{t: TypeTrue},\n\t\t\t},\n\t\t\twant:    true,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Bool_False\",\n\t\t\targs: args{\n\t\t\t\tv: \u0026Value{t: TypeFalse},\n\t\t\t},\n\t\t\twant:    false,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Bool_Invalid\",\n\t\t\targs: args{\n\t\t\t\tv: \u0026Value{t: TypeObject},\n\t\t\t},\n\t\t\twant:    false,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := tt.args.v.Bool()\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Value.Bool() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Value.Bool() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","3f7572e75236edb893fcc23f31599964":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"strconv\"\n\t\"strings\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello world\",\n\t\t\t},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\\\\"hello\\\\\\\"\",\n\t\t\t},\n\t\t\twant: \"\\\"hello\\\"\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\\\\\hello\\\\\\\\\",\n\t\t\t},\n\t\t\twant: \"\\\\hello\\\\\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\/hello\\\\/\",\n\t\t\t},\n\t\t\twant: \"/hello/\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\bhello\\\\b\",\n\t\t\t},\n\t\t\twant: \"\\bhello\\b\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\fhello\\\\f\",\n\t\t\t},\n\t\t\twant: \"\\fhello\\f\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\nhello\\\\n\",\n\t\t\t},\n\t\t\twant: \"\\nhello\\n\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\rhello\\\\r\",\n\t\t\t},\n\t\t\twant: \"\\rhello\\r\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\thello\\\\t\",\n\t\t\t},\n\t\t\twant: \"\\thello\\t\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\u0061hello\\\\u0062\",\n\t\t\t},\n\t\t\twant: \"ahello b\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\uD83D\\\\uDE01hello\\\\uD83D\\\\uDE02\",\n\t\t\t},\n\t\t\twant: \"😁hello😂\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\xhello\\\\x\",\n\t\t\t},\n\t\t\twant: \"\\\\xhello\\\\x\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\uhello\",\n\t\t\t},\n\t\t\twant: \"\\\\uhello\",\n\t\t},\n\t\t{\n\t\t\tname: \"mixed escape sequences\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\\\\"\\\\b\\\\u0061\\\\thello\\\\r\\\\\\\"\",\n\t\t\t},\n\t\t\twant: \"\\\" \\bahello\\t\\r\\\"\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestUnescapeStringBestEffort_JSON(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello world\"`,\n\t\t\t},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\\\\\\\"hello\\\\\"\"`,\n\t\t\t},\n\t\t\twant: \"\\\"hello\\\"\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\\\\\\\\hello\\\\\\\\\"`,\n\t\t\t},\n\t\t\twant: \"\\\\hello\\\\\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\\\\/hello\\\\/\"`,\n\t\t\t},\n\t\t\twant: \"/hello/\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\\\\bhello\\\\b\"`,\n\t\t\t},\n\t\t\twant: \"\\bhello\\b\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\\\\fhello\\\\f\"`,\n\t\t\t},\n\t\t\twant: \"\\fhello\\f\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\\\\nhello\\\\n\"`,\n\t\t\t},\n\t\t\twant: \"\\nhello\\n\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\\\\rhello\\\\r\"`,\n\t\t\t},\n\t\t\twant: \"\\rhello\\r\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\\\\thello\\\\t\"`,\n\t\t\t},\n\t\t\twant: \"\\thello\\t\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\\\\u0061hello\\\\u0062\"`,\n\t\t\t},\n\t\t\twant: \"ahello b\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\\\\uD83D\\\\uDE01hello\\\\uD83D\\\\uDE02\"`,\n\t\t\t},\n\t\t\twant: \"😁hello😂\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\\\\xhello\\\\x\"`,\n\t\t\t},\n\t\t\twant: \"\\\\xhello\\\\x\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\\\\uhello\"`,\n\t\t\t},\n\t\t\twant: \"\\\\uhello\",\n\t\t},\n\t\t{\n\t\t\tname: \"mixed escape sequences\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\\\\\\\"\\\\b\\\\u0061\\\\thello\\\\r\\\\\"\"`,\n\t\t\t},\n\t\t\twant: \"\\\" \\bahello\\t\\r\\\"\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t// Parse the JSON string to get the string value\n\t\t\tvar parsedValue interface{}\n\t\t\tif err := json.Unmarshal([]byte(tt.args.s), \u0026parsedValue); err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Check if the parsed value is a string\n\t\t\tstrValue, ok := parsedValue.(string)\n\t\t\tif !ok {\n\t\t\t\tt.Errorf(\"parsedValue is not a string, got: %T\", parsedValue)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Unescape the string using unescapeStringBestEffort\n\t\t\tunescaped := unescapeStringBestEffort(strValue)\n\n\t\t\t// Compare the unescaped string with the expected value\n\t\t\tif unescaped != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", unescaped, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestUnescapeStringBestEffort_Performance(t *testing.T) {\n\t// Create a large JSON string with many escape sequences\n\tvar jsonString string\n\tfor i := 0; i \u003c 10000; i++ {\n\t\tjsonString += `\"\\\\\" \\\\/ \\\\b \\\\f \\\\n \\\\r \\\\t \\\\u0061 \\\\uD83D\\\\uDE01 \"`\n\t}\n\n\t// Measure the performance of unescapeStringBestEffort\n\tt.Run(\"unescapeStringBestEffort\", func(t *testing.T) {\n\t\tt.Logf(\"unescapeStringBestEffort: %s\", jsonString)\n\t\tstart := time.Now()\n\t\tfor i := 0; i \u003c 100; i++ {\n\t\t\tunescapeStringBestEffort(jsonString)\n\t\t}\n\t\tt.Logf(\"Took %v to unescape\", time.Since(start))\n\t})\n\n\t// Measure the performance of the standard library's unmarshaler\n\tt.Run(\"json.Unmarshal\", func(t *testing.T) {\n\t\tt.Logf(\"json.Unmarshal: %s\", jsonString)\n\t\tstart := time.Now()\n\t\tfor i := 0; i \u003c 100; i++ {\n\t\t\tvar parsedValue interface{}\n\t\t\tif err := json.Unmarshal([]byte(jsonString), \u0026parsedValue); err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\t_, ok := parsedValue.(string)\n\t\t\tif !ok {\n\t\t\t\tt.Errorf(\"parsedValue is not a string, got: %T\", parsedValue)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tt.Logf(\"Took %v to unmarshal\", time.Since(start))\n\t})\n}","40a195db240c45247c569f188288dc15":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\"\\\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quote at beginning\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\\\\\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"\\\"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quote at end\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: ``,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","40bce8756653a7f7b2a826f9d1e70a02":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantV   *Value\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantS: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"single key-value pair\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\": \"value\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantS: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple key-value pairs\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantS: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"key2\": \"value2\"}, \"key3\": \"value3\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantS: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\": \"value\"`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV:  nil,\n\t\t\twantS:  `{\"key\": \"value\"`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing colon after key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\" \"value\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV:  nil,\n\t\t\twantS:  `{\"key\" \"value\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing comma after value\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV:  nil,\n\t\t\twantS:  `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected end of object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\": \"value`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV:  nil,\n\t\t\twantS:  `{\"key\": \"value`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotV, gotS, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(gotV, tt.wantV) {\n\t\t\t\tt.Errorf(\"parseObject() gotV = %v, want %v\", gotV, tt.wantV)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseObject() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}","41702ffcac5eb63c344593da8804a2ae":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"Simple String\",\n\t\t\targs: args{\n\t\t\t\ts: `\"Hello, world!\"`,\n\t\t\t},\n\t\t\twant:    \"Hello, world!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Escaped Quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"He said, \\\"Hello, world!\\\".\"`,\n\t\t\t},\n\t\t\twant:    \"He said, \\\"Hello, world!\\\"\",\n\t\t\twant1:   \".\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple Escaped Quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"He said, \\\"Hello, world!\\\" and she said, \\\"Good morning!\\\".\"`,\n\t\t\t},\n\t\t\twant:    \"He said, \\\"Hello, world!\\\" and she said, \\\"Good morning!\\\"\",\n\t\t\twant1:   \".\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Missing Closing Quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"Hello, world!`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Empty String\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\"`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"No Quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `Hello, world!`,\n\t\t\t},\n\t\t\twant:    \"Hello, world!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Quote at the Beginning\",\n\t\t\targs: args{\n\t\t\t\ts: `\"Hello, world!`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n","418c69497f59b9f493827f62e95a9c11":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetBool(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant bool\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.GetBool(tt.args.keys...); got != tt.want {\n\t\t\t\tt.Errorf(\"Value.GetBool() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","41eed9330e6f62c05d39e701011084a6":"```go\npackage fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"single digit\",\n\t\t\targs: args{\n\t\t\t\ts: \"1\",\n\t\t\t},\n\t\t\twantNs:  \"1\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple digits\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative number\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"decimal number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential number\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e+456\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e+456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential number with negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e-456\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e-456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"inf\",\n\t\t\t},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"nan\",\n\t\t\t},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123a\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number 2\",\n\t\t\targs: args{\n\t\t\t\ts: \"123+\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number 3\",\n\t\t\targs: args{\n\t\t\t\ts: \"123-\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number 4\",\n\t\t\targs: args{\n\t\t\t\ts: \"123e\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"e\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number 5\",\n\t\t\targs: args{\n\t\t\t\ts: \"123E\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"E\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number 6\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \".\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\t","42a4581e9bcb47c9cae323e224321838":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\tv   *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"marshal null\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNull},\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal true\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeTrue},\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal false\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeFalse},\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal number\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t},\n\t\t\twant: []byte(\"123\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeString, s: \"hello\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal raw string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: typeRawString, s: \"hello\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal empty array\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeArray, a: []*Value{}},\n\t\t\t},\n\t\t\twant: []byte(\"[]\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal array\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeString, s: \"hello\"}}},\n\t\t\t},\n\t\t\twant: []byte(\"[1,\\\"hello\\\"]\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal empty object\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeObject, o: Object{kvs: []kv{}}},\n\t\t\t},\n\t\t\twant: []byte(\"{}\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal object\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key1\", v: \u0026Value{t: TypeNumber, s: \"1\"}}, {k: \"key2\", v: \u0026Value{t: TypeString, s: \"hello\"}}}}},\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":1,\"key2\":\"hello\"}`),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.v.MarshalTo(tt.args.dst); !bytes.Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","4317dd94c9c81cdfc7394fab018fe2c2":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple float\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative float\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123.456\",\n\t\t\t},\n\t\t\twantNs:  \"-123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential notation\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential notation with negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e-4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"inf\",\n\t\t\t},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"Inf\",\n\t\t\t},\n\t\t\twantNs:  \"Inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inF\",\n\t\t\targs: args{\n\t\t\t\ts: \"inF\",\n\t\t\t},\n\t\t\twantNs:  \"inF\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"nan\",\n\t\t\t},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"Nan\",\n\t\t\t},\n\t\t\twantNs:  \"Nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nAn\",\n\t\t\targs: args{\n\t\t\t\ts: \"nAn\",\n\t\t\t},\n\t\t\twantNs:  \"nAn\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected character\",\n\t\t\targs: args{\n\t\t\t\ts: \"a123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"a123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"leading plus sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"leading plus sign followed by exponent\",\n\t\t\targs: args{\n\t\t\t\ts: \"+1.23e+4\",\n\t\t\t},\n\t\t\twantNs:  \"+1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"leading plus sign followed by inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"leading plus sign followed by nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}","438cdd38c430e24205d861b12ce862a1":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello world\"`,\n\t\t\t},\n\t\t\twant:    \"hello world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello \\\"world\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello \\\"world\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello \\\\\"world\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello \\\\\\\"world\\\\\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello world`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\"`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"no quotes\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello world\",\n\t\t\t},\n\t\t\twant:    \"hello world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","43f05169bea4b18464c3beff0572b019":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantKey string\n\t\twantVal string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello\\\"\",\n\t\t\t},\n\t\t\twantKey: \"hello\",\n\t\t\twantVal: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escape sequences\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello\\\\\\\"world\\\"\",\n\t\t\t},\n\t\t\twantKey: \"hello\\\"world\",\n\t\t\twantVal: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with multiple escape sequences\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello\\\\\\\"world\\\\\\\"\\\\\\\"\",\n\t\t\t},\n\t\t\twantKey: \"hello\\\"world\\\"\",\n\t\t\twantVal: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello\\\\\\\"world\\\"\",\n\t\t\t},\n\t\t\twantKey: \"hello\\\"world\",\n\t\t\twantVal: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped backslash\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello\\\\\\\\world\\\"\",\n\t\t\t},\n\t\t\twantKey: \"hello\\\\world\",\n\t\t\twantVal: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped slash\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello\\\\/world\\\"\",\n\t\t\t},\n\t\t\twantKey: \"hello/world\",\n\t\t\twantVal: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped b\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello\\\\bworld\\\"\",\n\t\t\t},\n\t\t\twantKey: \"hello\\bworld\",\n\t\t\twantVal: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped f\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello\\\\fworld\\\"\",\n\t\t\t},\n\t\t\twantKey: \"hello\\fworld\",\n\t\t\twantVal: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped n\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello\\\\nworld\\\"\",\n\t\t\t},\n\t\t\twantKey: \"hello\\nworld\",\n\t\t\twantVal: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped r\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello\\\\rworld\\\"\",\n\t\t\t},\n\t\t\twantKey: \"hello\\rworld\",\n\t\t\twantVal: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped t\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello\\\\tworld\\\"\",\n\t\t\t},\n\t\t\twantKey: \"hello\\tworld\",\n\t\t\twantVal: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped u\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello\\\\u0020world\\\"\",\n\t\t\t},\n\t\t\twantKey: \"hello world\",\n\t\t\twantVal: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello\",\n\t\t\t},\n\t\t\twantKey: \"\",\n\t\t\twantVal: \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twantKey: \"\",\n\t\t\twantVal: \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"no opening quote\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello\\\"\",\n\t\t\t},\n\t\t\twantKey: \"\",\n\t\t\twantVal: \"\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotKey, gotVal, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotKey != tt.wantKey {\n\t\t\t\tt.Errorf(\"parseRawString() gotKey = %v, want %v\", gotKey, tt.wantKey)\n\t\t\t}\n\t\t\tif gotVal != tt.wantVal {\n\t\t\t\tt.Errorf(\"parseRawString() gotVal = %v, want %v\", gotVal, tt.wantVal)\n\t\t\t}\n\t\t})\n\t}\n}","446abaebeeef376ebc93226303f531ed":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": {\"key2\": \"value2\"}, \"key3\": \"value3\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\\\\\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\\\"\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","45e9f90038c7ac1a7282335fc1180fe8":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_getKV(t *testing.T) {\n\ttype args struct {\n\t\to *Object\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant *kv\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.o.getKV(); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Object.getKV() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","46016ef0a20258ffb65f7446c875b298":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t\t{\n\t\t\tname: \"parse empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"parse null\",\n\t\t\targs: args{\n\t\t\t\ts: \"null\",\n\t\t\t},\n\t\t\twant:    \u0026Value{t: TypeNull},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"parse true\",\n\t\t\targs: args{\n\t\t\t\ts: \"true\",\n\t\t\t},\n\t\t\twant:    \u0026Value{t: TypeTrue},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"parse false\",\n\t\t\targs: args{\n\t\t\t\ts: \"false\",\n\t\t\t},\n\t\t\twant:    \u0026Value{t: TypeFalse},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"parse number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant:    \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"parse string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello\\\"\",\n\t\t\t},\n\t\t\twant:    \u0026Value{t: TypeString, s: \"hello\"},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"parse array\",\n\t\t\targs: args{\n\t\t\t\ts: \"[1,2,3]\",\n\t\t\t},\n\t\t\twant:    \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"parse object\",\n\t\t\targs: args{\n\t\t\t\ts: `{\"key1\": \"value1\", \"key2\": 2}`,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"2\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tp := \u0026Parser{}\n\t\t\tgot, err := p.Parse(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Parse() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr \u0026\u0026 !got.Equal(tt.want) {\n\t\t\t\tt.Errorf(\"Parse() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","474587a46759d9c9af305ffe6abc10cf":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_unescapeKeys(t *testing.T) {\n\ttype args struct {\n\t\to *Object\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\ttt.args.o.unescapeKeys()\n\t\t\tif got := tt.args.o.keysUnescaped; got != tt.want {\n\t\t\t\tt.Errorf(\"Object.unescapeKeys() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","4778417afe75368a35b2b6f4f35fc985":"```go\npackage fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantV   *Value\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t","47a7a73c5d932bf8413c1aa7692b5419":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttype want struct {\n\t\tv   *Value\n\t\ttail string\n\t\terr  error\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant want\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  fmt.Errorf(\"cannot parse empty string\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{\\\"a\\\":1}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"{\\n\\\"a\\\":1}\",\n\t\t\t\terr:  fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{\\\"a\\\":1}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"a\",\n\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[\\\"a\\\", 1]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: typeRawString,\n\t\t\t\t\t\t\ts: \"a\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\\\"a\\\"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{\n\t\t\t\t\tt: typeRawString,\n\t\t\t\t\ts: \"a\",\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   \"true\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueTrue,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   \"false\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueFalse,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   \"null\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueNull,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   \"1\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"1\",\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\ts:   \"NaN\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"NaN\",\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotV, gotTail, gotErr := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (gotErr == nil \u0026\u0026 tt.want.err != nil) || (gotErr != nil \u0026\u0026 tt.want.err == nil) || (gotErr != nil \u0026\u0026 tt.want.err != nil \u0026\u0026 gotErr.Error() != tt.want.err.Error()) {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", gotErr, tt.want.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(gotV, tt.want.v) {\n\t\t\t\tt.Errorf(\"parseValue() gotV = %v, want %v\", gotV, tt.want.v)\n\t\t\t}\n\t\t\tif gotTail != tt.want.tail {\n\t\t\t\tt.Errorf(\"parseValue() gotTail = %v, want %v\", gotTail, tt.want.tail)\n\t\t\t}\n\t\t})\n\t}\n}","47b28de27696c7d835e66559172d7cdc":"package fastjson\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\tv   *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNull},\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeTrue},\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeFalse},\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeString, s: \"hello\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t},\n\t\t\twant: []byte(\"123\"),\n\t\t},\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: typeRawString, s: \"hello world\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello world\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{t: TypeString, s: \"hello\"},\n\t\t\t\t\t\t{t: TypeNumber, s: \"123\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`[\"hello\",123]`),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{k: \"name\", v: \u0026Value{t: TypeString, s: \"John Doe\"}},\n\t\t\t\t\t\t\t{k: \"age\", v: \u0026Value{t: TypeNumber, s: \"30\"}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`{\"name\":\"John Doe\",\"age\":30}`),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.v.MarshalTo(tt.args.dst); !bytes.Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","482458ac461af40cdb53b92e922369b7":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escape sequences\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with multiple escape sequences\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\"world\\\\\"again\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\\\\\\\"again\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\\\\\\\"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with unescaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"world\\\"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","48320e961bd2d8c9a3735fa076ff65ef":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestType_String(t *testing.T) {\n\ttype args struct {\n\t\tt Type\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"TypeObject\",\n\t\t\targs: args{t: TypeObject},\n\t\t\twant: \"object\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeArray\",\n\t\t\targs: args{t: TypeArray},\n\t\t\twant: \"array\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeString\",\n\t\t\targs: args{t: TypeString},\n\t\t\twant: \"string\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeNumber\",\n\t\t\targs: args{t: TypeNumber},\n\t\t\twant: \"number\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeTrue\",\n\t\t\targs: args{t: TypeTrue},\n\t\t\twant: \"true\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeFalse\",\n\t\t\targs: args{t: TypeFalse},\n\t\t\twant: \"false\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeNull\",\n\t\t\targs: args{t: TypeNull},\n\t\t\twant: \"null\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.t.String(); got != tt.want {\n\t\t\t\tt.Errorf(\"Type.String() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","48615e4e0f80b59be18ffb71c44492a6":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttype want struct {\n\t\tv   *Value\n\t\ttail string\n\t\terr  error\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant want\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  fmt.Errorf(\"cannot parse empty string\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"{}\",\n\t\t\t\terr:  fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{t: TypeObject},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{t: TypeArray},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"hello\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{t: typeRawString, s: \"hello\"},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   \"true\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueTrue,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   \"false\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueFalse,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   \"null\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueNull,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   \"123\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   \"NaN\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"NaN\"},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotV, gotTail, gotErr := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif gotErr == nil \u0026\u0026 tt.want.err != nil {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", gotErr, tt.want.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotErr != nil \u0026\u0026 tt.want.err == nil {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr nil\", gotErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotErr != nil \u0026\u0026 tt.want.err != nil {\n\t\t\t\tif gotErr.Error() != tt.want.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", gotErr, tt.want.err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(gotV, tt.want.v) {\n\t\t\t\tt.Errorf(\"parseValue() gotV = %v, want %v\", gotV, tt.want.v)\n\t\t\t}\n\t\t\tif gotTail != tt.want.tail {\n\t\t\t\tt.Errorf(\"parseValue() gotTail = %v, want %v\", gotTail, tt.want.tail)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseValue_Integration(t *testing.T) {\n\ttype testCase struct {\n\t\tinput    string\n\t\twantType Type\n\t\twantJSON string\n\t}\n\n\ttestCases := []testCase{\n\t\t{\n\t\t\tinput:    `null`,\n\t\t\twantType: TypeNull,\n\t\t\twantJSON: `null`,\n\t\t},\n\t\t{\n\t\t\tinput:    `true`,\n\t\t\twantType: TypeTrue,\n\t\t\twantJSON: `true`,\n\t\t},\n\t\t{\n\t\t\tinput:    `false`,\n\t\t\twantType: TypeFalse,\n\t\t\twantJSON: `false`,\n\t\t},\n\t\t{\n\t\t\tinput:    `123`,\n\t\t\twantType: TypeNumber,\n\t\t\twantJSON: `123`,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"hello\"`,\n\t\t\twantType: TypeString,\n\t\t\twantJSON: `\"hello\"`,\n\t\t},\n\t\t{\n\t\t\tinput:    `[1, 2, 3]`,\n\t\t\twantType: TypeArray,\n\t\t\twantJSON: `[1,2,3]`,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"a\": 1, \"b\": \"2\"}`,\n\t\t\twantType: TypeObject,\n\t\t\twantJSON: `{\"a\":1,\"b\":\"2\"}`,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.input, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tv, _, err := parseValue(tc.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"parseValue failed: %v\", err)\n\t\t\t}\n\t\t\tif v.Type() != tc.wantType {\n\t\t\t\tt.Errorf(\"parseValue returned wrong type: got %v, want %v\", v.Type(), tc.wantType)\n\t\t\t}\n\t\t\tbytes, err := json.Marshal(v)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"Marshal failed: %v\", err)\n\t\t\t}\n\t\t\tif string(bytes) != tc.wantJSON {\n\t\t\t\tt.Errorf(\"parseValue returned wrong JSON: got %s, want %s\", string(bytes), tc.wantJSON)\n\t\t\t}\n\t\t})\n\t}\n}","487b4d87b952e68219b21d44a1371cea":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    \u0026Value{t: TypeArray, a: []*Value{}},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"single element array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"hello\"]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeString, s: \"hello\"},\n\t\t\t}},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"hello\", \"world\", 123, true]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeString, s: \"hello\"},\n\t\t\t\t{t: TypeString, s: \"world\"},\n\t\t\t\t{t: TypeNumber, s: \"123\"},\n\t\t\t\t{t: TypeTrue},\n\t\t\t}},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[[\"hello\", \"world\"], [123, true]]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeArray, a: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"hello\"},\n\t\t\t\t\t{t: TypeString, s: \"world\"},\n\t\t\t\t}},\n\t\t\t\t{t: TypeArray, a: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"123\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t}},\n\t\t\t}},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:   `[1, 2, 3`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `[1, 2, 3`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:   `[1 2, 3]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `[1 2, 3]`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid array value\",\n\t\t\targs: args{\n\t\t\t\ts:   `[1, 2, {`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `[1, 2, {`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr {\n\t\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t\t}\n\t\t\t\tif got1 != tt.want1 {\n\t\t\t\t\tt.Errorf(\"parseArray() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseArray_JSON(t *testing.T) {\n\ttype TestCase struct {\n\t\tInput  string\n\t\tOutput interface{}\n\t}\n\n\ttestCases := []TestCase{\n\t\t{\n\t\t\tInput:  `[]`,\n\t\t\tOutput: []interface{}{},\n\t\t},\n\t\t{\n\t\t\tInput:  `[\"hello\"]`,\n\t\t\tOutput: []interface{}{\"hello\"},\n\t\t},\n\t\t{\n\t\t\tInput:  `[\"hello\", \"world\", 123, true]`,\n\t\t\tOutput: []interface{}{\"hello\", \"world\", 123, true},\n\t\t},\n\t\t{\n\t\t\tInput:  `[[\"hello\", \"world\"], [123, true]]`,\n\t\t\tOutput: [][]interface{}{{\"hello\", \"world\"}, {123, true}},\n\t\t},\n\t}\n\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.Input, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, _, err := parseArray(testCase.Input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"parseArray() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tvar expected interface{}\n\t\t\tif err := json.Unmarshal([]byte(testCase.Input), \u0026expected); err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !reflect.DeepEqual(got.a, expected) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got.a, expected)\n\t\t\t}\n\t\t})\n\t}\n}","48c9e62e37da97e070e59a6c5e30e526":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t\t{\n\t\t\tname: \"Empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": 2}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"key2\": \"value2\"}, \"key3\": true}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Object with missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Object with missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\" \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Object with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","48d318ea87ed8fe26689b887bc8fd3c8":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no whitespace\",\n\t\t\targs: args{s: \"abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace\",\n\t\t\targs: args{s: \"   abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailing whitespace\",\n\t\t\targs: args{s: \"abc   \"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"internal whitespace\",\n\t\t\targs: args{s: \"  abc  \"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"mixed whitespace\",\n\t\t\targs: args{s: \" \\t\\n\\r abc \\t\\n\\r\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading and internal whitespace\",\n\t\t\targs: args{s: \" \\t\\n\\r abc  \\t\\n\\r\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading and trailing whitespace\",\n\t\t\targs: args{s: \" \\t\\n\\r abc \\t\\n\\r  \"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"all whitespace\",\n\t\t\targs: args{s: \" \\t\\n\\r\"},\n\t\t\twant: \"\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","49c1fd950447c90d34f273d87ba7c002":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": {\"key2\": \"value2\"}, \"key3\": \"value3\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{\n\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}},\n\t\t\t\t\t\t{k: \"key3\", v: \u0026Value{t: TypeString, s: \"value3\"}},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\" \"value1\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid key\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2: \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2: \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid value\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": value1, \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": value1, \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_parseObject_WithEscapedKeys(t *testing.T) {\n\tc := \u0026cache{}\n\ts := `{\"key\\\\\\\"1\": \"value1\", \"key2\": \"value2\", \"key\\\\\\\"3\": \"value3\"}`\n\tv, _, err := parseObject(s, c, 0)\n\tif err != nil {\n\t\tt.Fatalf(\"parseObject failed: %s\", err)\n\t}\n\n\tif v.t != TypeObject {\n\t\tt.Errorf(\"Expected TypeObject, got %d\", v.t)\n\t}\n\n\tif len(v.o.kvs) != 3 {\n\t\tt.Errorf(\"Expected 3 key-value pairs, got %d\", len(v.o.kvs))\n\t}\n\n\tif v.o.kvs[0].k != `key\"1` {\n\t\tt.Errorf(\"Expected key \\\"key\\\\\\\"1\\\", got %s\", v.o.kvs[0].k)\n\t}\n\n\tif v.o.kvs[1].k != `key2` {\n\t\tt.Errorf(\"Expected key \\\"key2\\\", got %s\", v.o.kvs[1].k)\n\t}\n\n\tif v.o.kvs[2].k != `key\"3` {\n\t\tt.Errorf(\"Expected key \\\"key\\\\\\\"3\\\", got %s\", v.o.kvs[2].k)\n\t}\n\n\tif !v.o.keysUnescaped {\n\t\tt.Errorf(\"Expected keysUnescaped to be true, got %t\", v.o.keysUnescaped)\n\t}\n}\n\nfunc Test_parseObject_WithEscapedValues(t *testing.T) {\n\tc := \u0026cache{}\n\ts := `{\"key1\": \"value\\\\\\\"1\", \"key2\": \"value2\", \"key3\": \"value\\\\\\\"3\"}`\n\tv, _, err := parseObject(s, c, 0)\n\tif err != nil {\n\t\tt.Fatalf(\"parseObject failed: %s\", err)\n\t}\n\n\tif v.t != TypeObject {\n\t\tt.Errorf(\"Expected TypeObject, got %d\", v.t)\n\t}\n\n\tif len(v.o.kvs) != 3 {\n\t\tt.Errorf(\"Expected 3 key-value pairs, got %d\", len(v.o.kvs))\n\t}\n\n\tif v.o.kvs[0].v.s != `value\"1` {\n\t\tt.Errorf(\"Expected value \\\"value\\\\\\\"1\\\", got %s\", v.o.kvs[0].v.s)\n\t}\n\n\tif v.o.kvs[1].v.s != `value2` {\n\t\tt.Errorf(\"Expected value \\\"value2\\\", got %s\", v.o.kvs[1].v.s)\n\t}\n\n\tif v.o.kvs[2].v.s != `value\"3` {\n\t\tt.Errorf(\"Expected value \\\"value\\\\\\\"3\\\", got %s\", v.o.kvs[2].v.s)\n\t}\n}\n\nfunc TestParseObject_benchmark(t *testing.T) {\n\tdata := []byte(`{\"key1\": \"value1\", \"key2\": \"value2\", \"key3\": \"value3\"}`)\n\tvar v Value\n\tt.Run(\"json.Unmarshal\", func(t *testing.T) {\n\t\tfor i := 0; i \u003c 100000; i++ {\n\t\t\tif err := json.Unmarshal(data, \u0026v); err != nil {\n\t\t\t\tt.Fatalf(\"json.Unmarshal failed: %s\", err)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"fastjson.Parse\", func(t *testing.T) {\n\t\tc := \u0026cache{}\n\t\tfor i := 0; i \u003c 100000; i++ {\n\t\t\tif _, _, err := parseObject(string(data), c, 0); err != nil {\n\t\t\t\tt.Fatalf(\"parseObject failed: %s\", err)\n\t\t\t}\n\t\t}\n\t})\n}\n","4b129ab98d5c4c731411a79d4a5f508e":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no whitespace\",\n\t\t\targs: args{s: \"abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace\",\n\t\t\targs: args{s: \"  abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailing whitespace\",\n\t\t\targs: args{s: \"abc  \"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"internal whitespace\",\n\t\t\targs: args{s: \"a bc\"},\n\t\t\twant: \"bc\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple whitespace\",\n\t\t\targs: args{s: \"  a  bc  \"},\n\t\t\twant: \"bc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading and trailing whitespace\",\n\t\t\targs: args{s: \"  abc  \"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"all whitespace\",\n\t\t\targs: args{s: \"   \"},\n\t\t\twant: \"\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","4b87cd4d52570dab9666b264f36b07db":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestType_String(t *testing.T) {\n\ttype args struct {\n\t\tt Type\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"TestType_String_Object\",\n\t\t\targs: args{t: TypeObject},\n\t\t\twant: \"object\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_Array\",\n\t\t\targs: args{t: TypeArray},\n\t\t\twant: \"array\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_String\",\n\t\t\targs: args{t: TypeString},\n\t\t\twant: \"string\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_Number\",\n\t\t\targs: args{t: TypeNumber},\n\t\t\twant: \"number\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_True\",\n\t\t\targs: args{t: TypeTrue},\n\t\t\twant: \"true\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_False\",\n\t\t\targs: args{t: TypeFalse},\n\t\t\twant: \"false\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_Null\",\n\t\t\targs: args{t: TypeNull},\n\t\t\twant: \"null\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.t.String(); got != tt.want {\n\t\t\t\tt.Errorf(\"Type.String() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","4bfd353ce394104c3e5e7330f2d8c37e":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\"world\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\"`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with spaces\",\n\t\t\targs: args{\n\t\t\t\ts: `\" hello world \"`,\n\t\t\t},\n\t\t\twant:    \" hello world \",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with special characters\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello world!@#$%^\u0026*()_+-={}[]\\:;'\u003c\u003e,.?/~\"`,\n\t\t\t},\n\t\t\twant:    \"hello world!@#$%^\u0026*()_+-={}[]\\\\:;'\u003c\u003e,.?/~\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped backslashes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t// Add more test cases as needed\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","4cdd623a302712e4419ad2c3a2c97876":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\"world\\\\\\\"\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"!\\\"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped backslash\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\\world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote at the beginning\",\n\t\t\targs: args{\n\t\t\t\ts: `\\\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","4d0122a553f10d32bc49513bf0d9a989":"```go\npackage fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"😁\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\ world\"},\n\t\t\twant: \"\\\\xhello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"short escape sequence\",\n\t\t\targs: args{s: \"\\\\u006\"},\n\t\t\twant: \"\\\\u006\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\/ \\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"\\\"hello\\\" \\\\world/ \\b\\f\\n\\r\\tabc😁\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n","4f4491cb7c5cc7f58615a05c592dd536":"```go\npackage fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttype want struct {\n\t\tv   *Value\n\t\ttail string\n\t\terr  error\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant want\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  fmt.Errorf(\"cannot parse empty string\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"{}\",\n\t\t\t\terr:  fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs:           nil,\n\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: nil,\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"hello\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: typeRawString,\n\t\t\t\t\ts: \"hello\",\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   \"true\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueTrue,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   \"false\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueFalse,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   \"null\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueNull,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   \"123\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"123\",\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\ts:   \"NaN\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"NaN\",\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotV, gotTail, gotErr := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (gotErr == nil) != (tt.want.err == nil) {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", gotErr, tt.want.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotErr != nil \u0026\u0026 tt.want.err != nil {\n\t\t\t\tif gotErr.Error() != tt.want.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", gotErr, tt.want.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(gotV, tt.want.v) {\n\t\t\t\tt.Errorf(\"parseValue() gotV = %v, want %v\", gotV, tt.want.v)\n\t\t\t}\n\t\t\tif gotTail != tt.want.tail {\n\t\t\t\tt.Errorf(\"parseValue() gotTail = %v, want %v\", gotTail, tt.want.tail)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseValue_JSON(t *testing.T) {\n\ttype TestCase struct {\n\t\tJSON string\n\t\tWant *Value\n\t}\n\ttestCases := []TestCase{\n\t\t{\n\t\t\tJSON: `{\"key1\": \"value1\", \"key2\": 123}`,\n\t\t\tWant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: typeRawString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tJSON: `[1, 2, \"three\"]`,\n\t\t\tWant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: typeRawString,\n\t\t\t\t\t\ts: \"three\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tJSON: `true`,\n\t\t\tWant: valueTrue,\n\t\t},\n\t\t{\n\t\t\tJSON: `false`,\n\t\t\tWant: valueFalse,\n\t\t},\n\t\t{\n\t\t\tJSON: `null`,\n\t\t\tWant: valueNull,\n\t\t},\n\t\t{\n\t\t\tJSON: `\"hello\"`,\n\t\t\tWant: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tJSON: `123`,\n\t\t\tWant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tJSON: `-123`,\n\t\t\tWant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tJSON: `123.456`,\n\t\t\tWant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tJSON: `1.23e+4`,\n\t\t\tWant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tJSON: `1.23e-4","4fc89e3a630b8e550765596372d584cd":"```go\npackage fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args","503f3922e45e669920f6725150e5602b":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts: \"null\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts: \"true\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts: \"false\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello\\\"\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts: \"[1,2,3]\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts: `{\"key1\": \"value1\", \"key2\": 2}`,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tp := \u0026Parser{}\n\t\t\tgot, err := p.Parse(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Parse() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr \u0026\u0026 !compareValues(got, tt.want) {\n\t\t\t\tt.Errorf(\"Parse() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeNull:\n\t\treturn true\n\tcase TypeTrue:\n\t\treturn true\n\tcase TypeFalse:\n\t\treturn true\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !compareValues(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !compareValues(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc TestParse_WithEscapedChars(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tinput   string\n\t\twant    string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"escaped quotes\",\n\t\t\tinput:   `{\"key1\": \"value1\\\\\\\"value2\", \"key2\": 2}`,\n\t\t\twant:    `{\"key1\": \"value1\\\"value2\", \"key2\": 2}`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"escaped backslash\",\n\t\t\tinput:   `{\"key1\": \"value1\\\\\\\\value2\", \"key2\": 2}`,\n\t\t\twant:    `{\"key1\": \"value1\\\\value2\", \"key2\": 2}`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"escaped forward slash\",\n\t\t\tinput:   `{\"key1\": \"value1\\\\/value2\", \"key2\": 2}`,\n\t\t\twant:    `{\"key1\": \"value1/value2\", \"key2\": 2}`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"escaped backspace\",\n\t\t\tinput:   `{\"key1\": \"value1\\\\bvalue2\", \"key2\": 2}`,\n\t\t\twant:    `{\"key1\": \"value1\\bvalue2\", \"key2\": 2}`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"escaped form feed\",\n\t\t\tinput:   `{\"key1\": \"value1\\\\fvalue2\", \"key2\": 2}`,\n\t\t\twant:    `{\"key1\": \"value1\\fvalue2\", \"key2\": 2}`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"escaped newline\",\n\t\t\tinput:   `{\"key1\": \"value1\\\\nvalue2\", \"key2\": 2}`,\n\t\t\twant:    `{\"key1\": \"value1\\nvalue2\", \"key2\": 2}`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"escaped carriage return\",\n\t\t\tinput:   `{\"key1\": \"value1\\\\rvalue2\", \"key2\": 2}`,\n\t\t\twant:    `{\"key1\": \"value1\\rvalue2\", \"key2\": 2}`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"escaped tab\",\n\t\t\tinput:   `{\"key1\": \"value1\\\\tvalue2\", \"key2\": 2}`,\n\t\t\twant:    `{\"key1\": \"value1\\tvalue2\", \"key2\": 2}`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"escaped unicode\",\n\t\t\tinput:   `{\"key1\": \"value1\\\\u0061value2\", \"key2\": 2}`,\n\t\t\twant:    `{\"key1\": \"value1avalue2\", \"key2\": 2}`,\n\t\t\twantErr: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tp := \u0026Parser{}\n\t\t\tgot, err := p.Parse(tt.input)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Parse() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr {\n\t\t\t\tmarshaled, err := json.Marshal(got)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"Marshal() error = %v\", err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif string(marshaled) != tt.want {\n\t\t\t\t\tt.Errorf(\"Parse() = %v, want %v\", string(marshaled), tt.want)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","507ed88071a072bb161e39e02811a740":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no whitespace\",\n\t\t\targs: args{\n\t\t\t\ts: \"abc\",\n\t\t\t},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace\",\n\t\t\targs: args{\n\t\t\t\ts: \"  abc\",\n\t\t\t},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailing whitespace\",\n\t\t\targs: args{\n\t\t\t\ts: \"abc  \",\n\t\t\t},\n\t\t\twant: \"abc  \",\n\t\t},\n\t\t{\n\t\t\tname: \"leading and trailing whitespace\",\n\t\t\targs: args{\n\t\t\t\ts: \"  abc  \",\n\t\t\t},\n\t\t\twant: \"abc  \",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple leading whitespaces\",\n\t\t\targs: args{\n\t\t\t\ts: \"   abc\",\n\t\t\t},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple trailing whitespaces\",\n\t\t\targs: args{\n\t\t\t\ts: \"abc   \",\n\t\t\t},\n\t\t\twant: \"abc   \",\n\t\t},\n\t\t{\n\t\t\tname: \"whitespace in the middle\",\n\t\t\targs: args{\n\t\t\t\ts: \"ab c\",\n\t\t\t},\n\t\t\twant: \"c\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple whitespaces in the middle\",\n\t\t\targs: args{\n\t\t\t\ts: \"ab  c\",\n\t\t\t},\n\t\t\twant: \"c\",\n\t\t},\n\t\t{\n\t\t\tname: \"whitespace at the beginning and in the middle\",\n\t\t\targs: args{\n\t\t\t\ts: \"  ab c\",\n\t\t\t},\n\t\t\twant: \"c\",\n\t\t},\n\t\t{\n\t\t\tname: \"whitespace at the end and in the middle\",\n\t\t\targs: args{\n\t\t\t\ts: \"ab c  \",\n\t\t\t},\n\t\t\twant: \"c  \",\n\t\t},\n\t\t{\n\t\t\tname: \"leading newline\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\n abc\",\n\t\t\t},\n\t\t\twant: \" abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading tab\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\tabc\",\n\t\t\t},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading carriage return\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\r abc\",\n\t\t\t},\n\t\t\twant: \" abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading and trailing newline\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\n abc \\n\",\n\t\t\t},\n\t\t\twant: \" abc \\n\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading and trailing tab\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\tabc\\t\",\n\t\t\t},\n\t\t\twant: \"abc\\t\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading and trailing carriage return\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\r abc \\r\",\n\t\t\t},\n\t\t\twant: \" abc \\r\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading newline and trailing tab\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\n abc\\t\",\n\t\t\t},\n\t\t\twant: \" abc\\t\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading tab and trailing newline\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\tabc\\n\",\n\t\t\t},\n\t\t\twant: \"abc\\n\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading carriage return and trailing tab\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\r abc\\t\",\n\t\t\t},\n\t\t\twant: \" abc\\t\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading tab and trailing carriage return\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\tabc\\r\",\n\t\t\t},\n\t\t\twant: \"abc\\r\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading newline and trailing carriage return\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\n abc\\r\",\n\t\t\t},\n\t\t\twant: \" abc\\r\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading carriage return and trailing newline\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\r abc\\n\",\n\t\t\t},\n\t\t\twant: \" abc\\n\",\n\t\t},\n\t\t{\n\t\t\tname: \"carriage return in the middle\",\n\t\t\targs: args{\n\t\t\t\ts: \"ab\\rc\",\n\t\t\t},\n\t\t\twant: \"c\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple carriage returns in the middle\",\n\t\t\targs: args{\n\t\t\t\ts: \"ab\\r\\rc\",\n\t\t\t},\n\t\t\twant: \"c\",\n\t\t},\n\t\t{\n\t\t\tname: \"newline in the middle\",\n\t\t\targs: args{\n\t\t\t\ts: \"ab\\nc\",\n\t\t\t},\n\t\t\twant: \"c\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple newlines in the middle\",\n\t\t\targs: args{\n\t\t\t\ts: \"ab\\n\\nc\",\n\t\t\t},\n\t\t\twant: \"c\",\n\t\t},\n\t\t{\n\t\t\tname: \"tab in the middle\",\n\t\t\targs: args{\n\t\t\t\ts: \"ab\\tc\",\n\t\t\t},\n\t\t\twant: \"c\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple tabs in the middle\",\n\t\t\targs: args{\n\t\t\t\ts: \"ab\\t\\tc\",\n\t\t\t},\n\t\t\twant: \"c\",\n\t\t},\n\t\t{\n\t\t\tname: \"mixed whitespace in the middle\",\n\t\t\targs: args{\n\t\t\t\ts: \"ab\\n\\t\\r c\",\n\t\t\t},\n\t\t\twant: \"c\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","51623eafceb80d06c6bf0fcefe4a047b":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with one element\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,3]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with nested array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[[1,2],[3,4]]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"4\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `[{\"a\":1},{\"b\":2}]`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tk: \"a\",\n\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tk: \"b\",\n\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1,2\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"array with invalid value\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,a]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1,2,a\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseArray() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseArray_Example(t *testing.T) {\n\tvar v *Value\n\tvar s string\n\tvar err error\n\tc := \u0026cache{}\n\tv, s, err = parseArray(`[1, 2, \"test\", true, false, null]`, c, 0)\n\tif err != nil {\n\t\tt.Errorf(\"parseArray() error = %v\", err)\n\t}\n\n\t// Convert the Value to JSON string\n\tb, err := json.MarshalIndent(v, \"\", \"  \")\n\tif err != nil {\n\t\tt.Errorf(\"json.MarshalIndent() error = %v\", err)\n\t}\n\tfmt.Println(string(b))\n\n\t// Example of how to access the values\n\tif len(v.a) != 6 {\n\t\tt.Errorf(\"incorrect length of array %v\", len(v.a))\n\t}\n\n\t// First element is a number\n\tif v.a[0].Type() != TypeNumber {\n\t\tt.Errorf(\"expected TypeNumber, got %v\", v.a[0].Type())\n\t}\n\n\t// Second element is a number\n\tif v.a[1].Type() != TypeNumber {\n\t\tt.Errorf(\"expected TypeNumber, got %v\", v.a[1].Type())\n\t}\n\n\t// Third element is a string\n\tif v.a[2].Type() != TypeString {\n\t\tt.Errorf(\"expected TypeString, got %v\", v.a[2].Type())\n\t}\n\n\t// Fourth element is a boolean (true)\n\tif v.a[3].Type() != TypeTrue {\n\t\tt.Errorf(\"expected TypeTrue, got %v\", v.a[3].Type())\n\t}\n\n\t// Fifth element is a boolean (false)\n\tif v.a[4].Type() != TypeFalse {\n\t\tt.Errorf(\"expected TypeFalse, got %v\", v.a[4].Type())\n\t}\n\n\t// Sixth element is a null\n\tif v.a[5].Type() != TypeNull {\n\t\tt.Errorf(\"expected TypeNull, got %v\", v.a[5].Type())\n\t}\n}","51deb49920dfc6e510077a17df92cc0a":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttype want struct {\n\t\tv   *Value\n\t\ttail string\n\t\terr  error\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant want\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  fmt.Errorf(\"cannot parse empty string\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"{}\",\n\t\t\t\terr:  fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\": \"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{k: \"key\", v: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"value1\", \"value2\"]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"value\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: typeRawString,\n\t\t\t\t\ts: \"value\",\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   \"true\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueTrue,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   \"false\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueFalse,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   \"null\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueNull,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   \"123\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"123\",\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   \"NaN\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"NaN\",\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected value\",\n\t\t\targs: args{\n\t\t\t\ts:   \"tru\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"tru\",\n\t\t\t\terr:  fmt.Errorf(\"unexpected value found: %q\", \"tru\"),\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotV, gotTail, gotErr := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (gotErr == nil) != (tt.want.err == nil) {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", gotErr, tt.want.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotErr != nil \u0026\u0026 tt.want.err != nil {\n\t\t\t\tif gotErr.Error() != tt.want.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", gotErr, tt.want.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(gotV, tt.want.v) {\n\t\t\t\tt.Errorf(\"parseValue() gotV = %v, want %v\", gotV, tt.want.v)\n\t\t\t}\n\t\t\tif gotTail != tt.want.tail {\n\t\t\t\tt.Errorf(\"parseValue() gotTail = %v, want %v\", gotTail, tt.want.tail)\n\t\t\t}\n\t\t})\n\t}\n}","51eb580ec9a46535500e7d56e243aafa":"package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello world\\\\\\\"\"},\n\t\t\twant: \"\\\"hello world\\\"\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello world\\\\\\\\\"},\n\t\t\twant: \"\\\\hello world\\\\\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello world\\\\/\"},\n\t\t\twant: \"/hello world/\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello world\\\\b\"},\n\t\t\twant: \"\\bhello world\\b\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello world\\\\f\"},\n\t\t\twant: \"\\fhello world\\f\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello world\\\\n\"},\n\t\t\twant: \"\\nhello world\\n\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello world\\\\r\"},\n\t\t\twant: \"\\rhello world\\r\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello world\\\\t\"},\n\t\t\twant: \"\\thello world\\t\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061hello world\\\\u0062\"},\n\t\t\twant: \"ahello worldb\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDC0Ahello world\\\\uD83D\\\\uDC0B\"},\n\t\t\twant: \"\\U0001F40Ahello world\\U0001F40B\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello world\\\\y\"},\n\t\t\twant: \"\\\\xhello world\\\\y\",\n\t\t},\n\t\t{\n\t\t\tname: \"short unicode escape sequence\",\n\t\t\targs: args{s: \"\\\\u006hello world\\\\u00\"},\n\t\t\twant: \"\\\\u006hello world\\\\u00\",\n\t\t},\n\t\t{\n\t\t\tname: \"short surrogate pair escape sequence\",\n\t\t\targs: args{s: \"\\\\uD83Dhello world\\\\uDC0B\"},\n\t\t\twant: \"\\\\uD83Dhello world\\\\uDC0B\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_unescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"basic escaping\",\n\t\t\targs: args{s: \"\\\\\\\"\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\uD83D\\\\uDC0A\\\\x\\\\y\\\\u006\"},\n\t\t\twant: \"\\\"\\\\b\\\\f\\\\n\\\\r\\\\t\\U0001F40A\\\\x\\\\y\\\\u006\",\n\t\t},\n\t\t{\n\t\t\tname: \"surrogate pair escaping\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDC0A\\\\uD83D\\\\uDC0B\"},\n\t\t\twant: \"\\U0001F40A\\U0001F40B\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete surrogate pair escaping\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDC0B\"},\n\t\t\twant: \"\\\\uD83D\\\\uDC0B\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequences\",\n\t\t\targs: args{s: \"\\\\x\\\\y\\\\u006\"},\n\t\t\twant: \"\\\\x\\\\y\\\\u006\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escaping\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_SurrogatePair(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"valid surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDC0A\"},\n\t\t\twant: \"\\U0001F40A\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDC0B\"},\n\t\t\twant: \"\\\\uD83D\\\\uDC0B\",\n\t\t},\n\t\t{\n\t\t\tname: \"missing second surrogate\",\n\t\t\targs: args{s: \"\\\\uD83D\"},\n\t\t\twant: \"\\\\uD83D\",\n\t\t},\n\t\t{\n\t\t\tname: \"missing first surrogate\",\n\t\t\targs: args{s: \"\\\\uDC0A\"},\n\t\t\twant: \"\\\\uDC0A\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_InvalidEscape(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"invalid unicode escape\",\n\t\t\targs: args{s: \"\\\\u006\"},\n\t\t\twant: \"\\\\u006\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid unicode escape with extra characters\",\n\t\t\targs: args{s: \"\\\\u006hello\"},\n\t\t\twant: \"\\\\u006hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\x\"},\n\t\t\twant: \"\\\\x\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence with extra characters\",\n\t\t\targs: args{s: \"\\\\xhello\"},\n\t\t\twant: \"\\\\xhello\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_ShortEscape(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"short unicode escape\",\n\t\t\targs: args{s: \"\\\\u006\"},\n\t\t\twant: \"\\\\u006\",\n\t\t},\n\t\t{\n\t\t\tname: \"short surrogate pair escape\",\n\t\t\targs: args{s: \"\\\\uD83D\"},\n\t\t\twant: \"\\\\uD83D\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_Performance(t *testing.T) {\n\t// Benchmark unescapeStringBestEffort against a large string with many escape sequences.\n\tstr := `\\\\\"\\\\\\\\\\\\/\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\uD83D\\\\uDC0A\\\\x\\\\y\\\\u006`\n\tfor i := 0; i \u003c 10000; i++ {\n\t\tstr += str\n\t}\n\n\tt.Run(\"benchmark\", func(t *testing.T) {\n\t\tt.Logf(\"String length: %d\", len(str))\n\t\tt.Logf(\"Running unescapeStringBestEffort...\")\n\t\tt.Logf(\"unescapeStringBestEffort time: %v\", func() {\n\t\t\tunescapeStringBestEffort(str)\n\t\t}())\n\t})\n}\n\nfunc Benchmark_unescapeStringBestEffort(b *testing.B) {\n\tstr := `\\\\\"\\\\\\\\\\\\/\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\uD83D\\\\uDC0A\\\\x\\\\y\\\\u006`\n\tfor i := 0; i \u003c 10000; i++ {\n\t\tstr += str\n\t}\n\tb.ResetTimer()\n\tfor i := 0; i \u003c b.N; i++ {\n\t\tunescapeStringBestEffort(str)\n\t}\n}","5247ae134bd05d190a83b85d60a407ce":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t\t{\n\t\t\tname: \"Parse null\",\n\t\t\targs: args{\n\t\t\t\ts:   \"null\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueNull,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Parse true\",\n\t\t\targs: args{\n\t\t\t\ts:   \"true\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueTrue,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Parse false\",\n\t\t\targs: args{\n\t\t\t\ts:   \"false\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueFalse,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Parse string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"hello world\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt:  typeRawString,\n\t\t\t\ts:  \"hello world\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Parse number\",\n\t\t\targs: args{\n\t\t\t\ts:   \"123\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt:  TypeNumber,\n\t\t\t\ts:  \"123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Parse object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\": \"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: \u0026Value{t: typeRawString, s: \"value\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Parse array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[1, 2, 3]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Parse empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Parse invalid JSON\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"{\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Parse too deep\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"a\": {\"b\": {\"c\": {\"d\": {\"e\": {\"f\": {\"g\": {\"h\": {\"i\": {\"j\": {\"k\": \"value\"}}}}}}}}}}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"a\": {\"b\": {\"c\": {\"d\": {\"e\": {\"f\": {\"g\": {\"h\": {\"i\": {\"j\": {\"k\": \"value\"}}}}}}}}}}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseValue() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_parseValue_with_cache(t *testing.T) {\n\tc := \u0026cache{}\n\ts := `{\"key1\": \"value1\", \"key2\": \"value2\"}`\n\tv, tail, err := parseValue(s, c, 0)\n\tif err != nil {\n\t\tt.Fatalf(\"parseValue() error = %v\", err)\n\t}\n\tif tail != \"\" {\n\t\tt.Errorf(\"parseValue() tail = %q, want %q\", tail, \"\")\n\t}\n\n\t// Check that the cache is used\n\ts = `{\"key3\": \"value3\", \"key4\": \"value4\"}`\n\tv2, tail, err := parseValue(s, c, 0)\n\tif err != nil {\n\t\tt.Fatalf(\"parseValue() error = %v\", err)\n\t}\n\tif tail != \"\" {\n\t\tt.Errorf(\"parseValue() tail = %q, want %q\", tail, \"\")\n\t}\n\n\t// Check that the values are different\n\tif reflect.DeepEqual(v, v2) {\n\t\tt.Errorf(\"parseValue() got = %v, want different values\", v)\n\t}\n}\n\nfunc Test_parseValue_with_empty_string(t *testing.T) {\n\tc := \u0026cache{}\n\ts := \"\"\n\tv, tail, err := parseValue(s, c, 0)\n\tif err == nil {\n\t\tt.Errorf(\"parseValue() error = %v, want error\", err)\n\t}\n\tif v != nil {\n\t\tt.Errorf(\"parseValue() got = %v, want nil\", v)\n\t}\n\tif tail != \"\" {\n\t\tt.Errorf(\"parseValue() tail = %q, want %q\", tail, \"\")\n\t}\n}\n\nfunc Test_parseValue_with_invalid_json(t *testing.T) {\n\tc := \u0026cache{}\n\ts := \"{\"\n\tv, tail, err := parseValue(s, c, 0)\n\tif err == nil {\n\t\tt.Errorf(\"parseValue() error = %v, want error\", err)\n\t}\n\tif v != nil {\n\t\tt.Errorf(\"parseValue() got = %v, want nil\", v)\n\t}\n\tif tail != \"{\" {\n\t\tt.Errorf(\"parseValue() tail = %q, want %q\", tail, \"{\")\n\t}\n}\n\nfunc Test_parseValue_with_max_depth(t *testing.T) {\n\tc := \u0026cache{}\n\ts := `{\"a\": {\"b\": {\"c\": {\"d\": {\"e\": {\"f\": {\"g\": {\"h\": {\"i\": {\"j\": {\"k\": \"value\"}}}}}}}}}}}`\n\tv, tail, err := parseValue(s, c, 0)\n\tif err == nil {\n\t\tt.Errorf(\"parseValue() error = %v, want error\", err)\n\t}\n\tif v != nil {\n\t\tt.Errorf(\"parseValue() got = %v, want nil\", v)\n\t}\n\tif tail != s {\n\t\tt.Errorf(\"parseValue() tail = %q, want %q\", tail, s)\n\t}\n}","526d23c85d09e89c801d9123b00e9a9b":"package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\"hello world\\\"\"},\n\t\t\twant: `\"hello world\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello world\"},\n\t\t\twant: `\\hello world`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello world\"},\n\t\t\twant: `/hello world`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello world\"},\n\t\t\twant: \"\\bhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello world\"},\n\t\t\twant: \"\\fhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello world\"},\n\t\t\twant: \"\\nhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello world\"},\n\t\t\twant: \"\\rhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello world\"},\n\t\t\twant: \"\\thello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061hello world\"},\n\t\t\twant: \"ahello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01hello world\"},\n\t\t\twant: \"😁hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello world\"},\n\t\t\twant: \"\\\\xhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"too short escape sequence\",\n\t\t\targs: args{s: \"\\\\uhello world\"},\n\t\t\twant: \"\\\\uhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\uD83D\\\\uDE01hello world\"},\n\t\t\twant: `\"\\b\\f\\n\\r\\ta😁hello world`,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","528a2d825a6aee6a7ac7a372fbecd8b5":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\tv   *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"marshal null\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNull},\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal true\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeTrue},\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal false\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeFalse},\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeString, s: \"test\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"test\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal raw string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: typeRawString, s: \"test\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"test\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal number\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t},\n\t\t\twant: []byte(\"123\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal array\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{t: TypeString, s: \"test1\"},\n\t\t\t\t\t\t{t: TypeString, s: \"test2\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"[\\\"test1\\\",\\\"test2\\\"]\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal object\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"{\\\"key1\\\":\\\"value1\\\",\\\"key2\\\":\\\"value2\\\"}\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.v.MarshalTo(tt.args.dst); !bytesEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc bytesEqual(a, b []byte) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","52b69c67d9b989e8d08cb882093db87e":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueGet(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant *Value\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.Get(tt.args.keys...); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.Get() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","52d2cdb7fd59ff3333585b77492b3dac":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": 2}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested objects\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": [1, 2, 3]}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped keys\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\\\\\": \\\"value1\\\", \\\"key2\\\\\\\": 2}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\\\"\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\\\"\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with invalid key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with invalid value\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": }`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": }`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\" \"value1\", \"key2\": 2}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\", \"key2\": 2}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\" \"key2\": 2}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": 2}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_UnescapedKeys(t *testing.T) {\n\ts := `{\"key1\\\\\": \"value1\", \"key2\\\\\\\": 2}`\n\tc := \u0026cache{}\n\tv, _, err := parseObject(s, c, 0)\n\tif err != nil {\n\t\tt.Errorf(\"parseObject() error = %v\", err)\n\t\treturn\n\t}\n\tif !v.o.keysUnescaped {\n\t\tt.Errorf(\"parseObject() keysUnescaped = %v, want %v\", v.o.keysUnescaped, true)\n\t}\n\tif v.o.kvs[0].k != \"key1\\\"\" {\n\t\tt.Errorf(\"parseObject() kvs[0].k = %v, want %v\", v.o.kvs[0].k, \"key1\\\"\")\n\t}\n\tif v.o.kvs[1].k != \"key2\\\"\" {\n\t\tt.Errorf(\"parseObject() kvs[1].k = %v, want %v\", v.o.kvs[1].k, \"key2\\\"\")\n\t}\n}\n\nfunc TestParseObject_LargeObject(t *testing.T) {\n\t// Generate a large object with 1000 key-value pairs\n\tdata := make(map[string]interface{}, 1000)\n\tfor i := 0; i \u003c 1000; i++ {\n\t\tdata[fmt.Sprintf(\"key%d\", i)] = fmt.Sprintf(\"value%d\", i)\n\t}\n\tjsonBytes, err := json.Marshal(data)\n\tif err != nil {\n\t\tt.Errorf(\"json.Marshal() error = %v\", err)\n\t\treturn\n\t}\n\ts := string(jsonBytes)\n\tc := \u0026cache{}\n\tv, _, err := parseObject(s, c, 0)\n\tif err != nil {\n\t\tt.Errorf(\"parseObject() error = %v\", err)\n\t\treturn\n\t}\n\tif len(v.o.kvs) != 1000 {\n\t\tt.Errorf(\"parseObject() len(v.o.kvs) = %v, want %v\", len(v.o.kvs), 1000)\n\t}\n}","52f0859c0121dc670dfa3c6394572777":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestType_String(t *testing.T) {\n\ttype args struct {\n\t\tt Type\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"TestObject\",\n\t\t\targs: args{t: TypeObject},\n\t\t\twant: \"object\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestArray\",\n\t\t\targs: args{t: TypeArray},\n\t\t\twant: \"array\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestString\",\n\t\t\targs: args{t: TypeString},\n\t\t\twant: \"string\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestNumber\",\n\t\t\targs: args{t: TypeNumber},\n\t\t\twant: \"number\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestTrue\",\n\t\t\targs: args{t: TypeTrue},\n\t\t\twant: \"true\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestFalse\",\n\t\t\targs: args{t: TypeFalse},\n\t\t\twant: \"false\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestNull\",\n\t\t\targs: args{t: TypeNull},\n\t\t\twant: \"null\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.t.String(); got != tt.want {\n\t\t\t\tt.Errorf(\"Type.String() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","53998db868a67109c659274b129aa427":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantV  *Value\n\t\twantS  string\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\twantS:  \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"single element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantS:  \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,3]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantS:  \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[[1,2],[3,4]]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"4\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantS:  \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with trailing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV:  nil,\n\t\t\twantS:  \",]\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"array with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1 2]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV:  nil,\n\t\t\twantS:  \" 2]\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"array with missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV:  nil,\n\t\t\twantS:  \"\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotV, gotS, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(gotV, tt.wantV) {\n\t\t\t\tt.Errorf(\"parseArray() gotV = %v, wantV %v\", gotV, tt.wantV)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseArray() gotS = %v, wantS %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}","53b23725d802bd896fea42c9c410de4c":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"too deep\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"{}\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"a\":1}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"a\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[1,2]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"hello\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   `true`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueTrue,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   `false`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueFalse,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   `null`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueNull,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   `NaN`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123.`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `123.`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseValue() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseValue_JSONMarshal(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tinput   string\n\t\twant    string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"object\",\n\t\t\tinput:   `{\"a\":1}`,\n\t\t\twant:    `{\"a\":1}`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"array\",\n\t\t\tinput:   `[1,2]`,\n\t\t\twant:    `[1,2]`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"string\",\n\t\t\tinput:   `\"hello\"`,\n\t\t\twant:    `\"hello\"`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"true\",\n\t\t\tinput:   `true`,\n\t\t\twant:    `true`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"false\",\n\t\t\tinput:   `false`,\n\t\t\twant:    `false`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"null\",\n\t\t\tinput:   `null`,\n\t\t\twant:    `null`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number\",\n\t\t\tinput:   `123`,\n\t\t\twant:    `123`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"NaN\",\n\t\t\tinput:   `NaN`,\n\t\t\twant:    `NaN`,\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv, _, err := parseValue(tt.input, \u0026cache{}, 0)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tgot, err := json.Marshal(v)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"json.Marshal() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif string(got) != tt.want {\n\t\t\t\tt.Errorf(\"json.Marshal() got = %v, want %v\", string(got), tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","54d21dbd2f396078b3efb6b6942aa1c4":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escaped strings\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\\\\\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: ``,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with no quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `hello`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","55ab33cd70885a9d7bec39d7c6952a4f":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttype want struct {\n\t\tv   *Value\n\t\ttail string\n\t\terr  error\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant want\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  fmt.Errorf(\"cannot parse empty string\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"{}\",\n\t\t\t\terr:  fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{ \\\"key\\\": \\\"value\\\" }\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[1, 2, 3]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\\\"hello world\\\"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeString,\n\t\t\t\t\ts: \"hello world\",\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   \"true\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueTrue,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   \"false\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueFalse,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   \"null\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueNull,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   \"123.456\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"123.456\",\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   \"NaN\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"NaN\",\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotV, gotTail, gotErr := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (gotErr == nil \u0026\u0026 tt.want.err != nil) || (gotErr != nil \u0026\u0026 tt.want.err == nil) {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", gotErr, tt.want.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotErr != nil \u0026\u0026 tt.want.err != nil {\n\t\t\t\tif gotErr.Error() != tt.want.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", gotErr, tt.want.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\tif gotTail != tt.want.tail {\n\t\t\t\tt.Errorf(\"parseValue() tail = %v, want %v\", gotTail, tt.want.tail)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !valueEqual(gotV, tt.want.v) {\n\t\t\t\tt.Errorf(\"parseValue() = %v, want %v\", gotV, tt.want.v)\n\t\t\t\treturn\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc valueEqual(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, kv1 := range v1.o.kvs {\n\t\t\tkv2 := v2.o.kvs[i]\n\t\t\tif kv1.k != kv2.k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !valueEqual(kv1.v, kv2.v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, a1 := range v1.a {\n\t\t\ta2 := v2.a[i]\n\t\t\tif !valueEqual(a1, a2) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeString, TypeNumber, TypeTrue, TypeFalse, TypeNull:\n\t\treturn v1.s == v2.s\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc TestParseValue_WithCache(t *testing.T) {\n\tc := \u0026cache{\n\t\tvs: make([]Value, 10),\n\t}\n\tfor i := 0; i \u003c 10; i++ {\n\t\tc.vs[i].t = TypeNull\n\t}\n\tv1, _, _ := parseValue(`\"hello\"`, c, 0)\n\tv2, _, _ := parseValue(`\"world\"`, c, 0)\n\tif v1.s == v2.s {\n\t\tt.Errorf(\"parseValue() with cache: got same value for different strings, want different values\")\n\t}\n\tv3, _, _ := parseValue(`\"hello\"`, c, 0)\n\tif v1.s != v3.s {\n\t\tt.Errorf(\"parseValue() with cache: got different value for the same string, want same values\")\n\t}\n}\n\nfunc TestParseValue_WithJSONUnmarshal(t *testing.T) {\n\ttype testStruct struct {\n\t\tKey string `json:\"key\"`\n\t}\n\ttestCases := []struct {\n\t\tname     string\n\t\tjson     string\n\t\twant     testStruct\n\t\twantErr  bool\n\t\twantType Type\n\t}{\n\t\t{\n\t\t\tname:     \"object\",\n\t\t\tjson:     `{\"key\": \"value\"}`,\n\t\t\twant:     testStruct{Key: \"value\"},\n\t\t\twantErr:  false,\n\t\t\twantType: TypeObject,\n\t\t},\n\t\t{\n\t\t\tname:     \"array\",\n\t\t\tjson:     `[\"value1\", \"value2\"]`,\n\t\t\twant:     testStruct{},\n\t\t\twantErr:  true,\n\t\t\twantType: TypeArray,\n\t\t},\n\t\t{\n\t\t\tname:     \"string\",\n\t\t\tjson:     `\"value\"`,\n\t\t\twant:     testStruct{},\n\t\t\twantErr:  true,\n\t\t\twantType: TypeString,\n\t\t},\n\t\t{\n\t\t\tname:     \"number\",\n\t\t\tjson:     `123`,\n\t\t\twant:     testStruct{},\n\t\t\twantErr:  true,\n\t\t\twantType: TypeNumber,\n\t\t},\n\t\t{\n\t\t\tname:     \"true\",\n\t\t\tjson:     `true`,\n\t\t\twant:     testStruct{},\n\t\t\twantErr:  true,\n\t\t\twantType: TypeTrue,\n\t\t},\n\t\t{\n\t\t\tname:     \"false\",\n\t\t\tjson:     `false`,\n\t\t\twant:     testStruct{},\n\t\t\twantErr:  true,\n\t\t\twantType: TypeFalse,\n\t\t},\n\t\t{\n\t\t\tname:     \"null\",\n\t\t\tjson:     `null`,\n\t\t\twant:     testStruct{},\n\t\t\twantErr:  true,\n\t\t\twantType: TypeNull,\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tv, _, err := parseValue(tc.json, c, 0)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif tc.wantErr {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif v.Type() != tc.wantType {\n\t\t\t\tt.Errorf(\"parseValue() type = %v, want %v\", v.Type(), tc.wantType)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif v.Type() == TypeObject {\n\t\t\t\tvar got testStruct\n\t\t\t\tif err := json.Unmarshal(v.MarshalTo(nil), \u0026got); err != nil {\n\t\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif got.Key != tc.want.Key {\n\t\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tc.want)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","55ae7eb91da475c49df165ec95632208":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\tv   *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"RawString\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: typeRawString, s: \"test\"},\n\t\t\t},\n\t\t\twant: []byte(`\"test\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"Object\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{t: TypeString, s: \"value\"}}}}, keysUnescaped: false},\n\t\t\t},\n\t\t\twant: []byte(`{\"key\":\"value\"}`),\n\t\t},\n\t\t{\n\t\t\tname: \"Array\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeArray, a: []*Value{{t: TypeString, s: \"value1\"}, {t: TypeString, s: \"value2\"}}},\n\t\t\t},\n\t\t\twant: []byte(`[\"value1\",\"value2\"]`),\n\t\t},\n\t\t{\n\t\t\tname: \"String\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeString, s: \"test\"},\n\t\t\t},\n\t\t\twant: []byte(`\"test\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"Number\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t},\n\t\t\twant: []byte(`123`),\n\t\t},\n\t\t{\n\t\t\tname: \"True\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeTrue},\n\t\t\t},\n\t\t\twant: []byte(`true`),\n\t\t},\n\t\t{\n\t\t\tname: \"False\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeFalse},\n\t\t\t},\n\t\t\twant: []byte(`false`),\n\t\t},\n\t\t{\n\t\t\tname: \"Null\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNull},\n\t\t\t},\n\t\t\twant: []byte(`null`),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.v.MarshalTo(tt.args.dst); !bytesEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc bytesEqual(a, b []byte) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","55c709ffad8143534ddeaf41a1e7bd19":"```go\npackage fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"simple integer\",\n\t\t\t","567dc1a07a611eae451a61af6d9ce469":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCacheGetValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\t// Test case 1: When capacity is greater than length\n\tc.vs = make([]Value, 10)\n\tv1 := c.getValue()\n\tif cap(c.vs) != 10 || len(c.vs) != 10 {\n\t\tt.Errorf(\"Expected capacity and length to be 10, got capacity: %d, length: %d\", cap(c.vs), len(c.vs))\n\t}\n\n\t// Test case 2: When capacity is equal to length\n\tc.vs = make([]Value, 10)\n\tc.vs = c.vs[:len(c.vs)]\n\tv2 := c.getValue()\n\tif cap(c.vs) != 10 || len(c.vs) != 11 {\n\t\tt.Errorf(\"Expected capacity to be 10 and length to be 11, got capacity: %d, length: %d\", cap(c.vs), len(c.vs))\n\t}\n\n\t// Ensure that the returned values are distinct\n\tif v1 == v2 {\n\t\tt.Errorf(\"Expected returned values to be distinct\")\n\t}\n}","569adecc916ae3f07b25462da44a89f4":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\tv   *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"marshal null\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNull},\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal true\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeTrue},\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal false\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeFalse},\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal number\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t},\n\t\t\twant: []byte(\"123\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeString, s: \"hello world\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello world\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal raw string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: typeRawString, s: \"hello world\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello world\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal array\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t\t{t: TypeString, s: \"hello\"},\n\t\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"[1,\\\"hello\\\",true]\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal object\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{k: \"name\", v: \u0026Value{t: TypeString, s: \"John Doe\"}},\n\t\t\t\t\t\t\t{k: \"age\", v: \u0026Value{t: TypeNumber, s: \"30\"}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`{\"name\":\"John Doe\",\"age\":30}`),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.v.MarshalTo(tt.args.dst); !bytesEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc bytesEqual(a, b []byte) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","569ceb1896d923fc26f5c3de368f3449":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no whitespace\",\n\t\t\targs: args{s: \"abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace\",\n\t\t\targs: args{s: \"  abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailing whitespace\",\n\t\t\targs: args{s: \"abc  \"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"whitespace in the middle\",\n\t\t\targs: args{s: \"a bc\"},\n\t\t\twant: \"bc\",\n\t\t},\n\t\t{\n\t\t\tname: \"all whitespace\",\n\t\t\targs: args{s: \"  \\t\\n\\r \"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"mixed whitespace\",\n\t\t\targs: args{s: \" \\t\\n\\r abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","56d6cf5f0d301863de996118db5b3f31":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello\\\"\",\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello\\\\\\\"\",\n\t\t\t},\n\t\t\twant:    \"hello\\\"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello\\\\\\\"world\\\\\\\"\",\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped backslash\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello\\\\\\\\\\\"\",\n\t\t\t},\n\t\t\twant:    \"hello\\\\\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello\\\\t\\\\n\\\\r\\\\b\\\\f\\\"\",\n\t\t\t},\n\t\t\twant:    \"hello\\t\\n\\r\\b\\f\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello\",\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with no opening quote\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello\\\"\",\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote at the beginning\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\\\\"hello\\\"\",\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","5839b963b0f00d47ba1ea71416983cae":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tp := \u0026Parser{}\n\t\t\tgot, err := p.Parse(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Parse() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Parse() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","5871d8de5bda10f9c2f0957142902f82":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"too deep\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"{}\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"a\":1}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"a\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[1,2,3]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"hello\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   `true`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueTrue,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   `false`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueFalse,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   `null`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueNull,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\ts:   `NaN`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseValue() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseValue_JSONMarshal(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"a\":1}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `{\"a\":1}`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[1,2,3]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `[1,2,3]`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"hello\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `\"hello\"`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   `true`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `true`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   `false`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `false`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   `null`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `null`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `123`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\ts:   `NaN`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `NaN`,\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err == nil {\n\t\t\t\tb, err := json.Marshal(got)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"json.Marshal() error = %v\", err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif string(b) != tt.want {\n\t\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", string(b), tt.want)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n","58c7405e774342bc9822664969457783":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escaped strings\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\\\\\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: ``,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"no quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `hello`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped backslash\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\\\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\\\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","58c88278ce1d66a2a2e9a8ffad165b22":"```go\npackage fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"single key-value pair\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\": \"value\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt:  TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple key-value pairs\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt:  TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt:  TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"key2\": \"value2\"}}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt:  TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\": \"value\"`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key\": \"value\"`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{:\"value\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{:\"value\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\" \"value\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key\" \"value\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.","5918e72973e48fabd54b0b57cef2017c":"package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello world\"},\n\t\t\twant: \"\\\\hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello world\"},\n\t\t\twant: \"/hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello world\"},\n\t\t\twant: \"\\bhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello world\"},\n\t\t\twant: \"\\fhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello world\"},\n\t\t\twant: \"\\nhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello world\"},\n\t\t\twant: \"\\rhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello world\"},\n\t\t\twant: \"\\thello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character\",\n\t\t\targs: args{s: \"\\\\u0061hello world\"},\n\t\t\twant: \"ahello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01hello world\"},\n\t\t\twant: \"😁hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello world\"},\n\t\t\twant: \"\\\\xhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"too short escape sequence\",\n\t\t\targs: args{s: \"\\\\u00hello world\"},\n\t\t\twant: \"\\\\u00hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\n\\\\t\\\\u0061\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"\\\"hello\\\" \\\\world\\n\\ta😁\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","59947fc5320ff2dac77bc86ecff32065":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped string with multiple escapes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\"world\\\\\"this\\\\\"is\\\\\"a\\\\\"test\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"this\\\"is\\\"a\\\"test\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped backslash\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\\\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped backslash and quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\\\\\\\"\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: ``,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with no quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `hello`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n","59b8e71ef0b4aca2099db261e7678633":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    \u0026Value{t: TypeObject, o: Object{}},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{t: TypeObject, o: Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}},\n\t\t\t\t},\n\t\t\t}},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": {\"key2\": \"value2\"}, \"key3\": \"value3\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{t: TypeObject, o: Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{\n\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\tv: \u0026Value{t: TypeObject, o: Object{\n\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t\t{k: \"key3\", v: \u0026Value{t: TypeString, s: \"value3\"}},\n\t\t\t\t},\n\t\t\t}},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\"`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing key\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", : \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", : \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","5babdb3951265dc321e891198b96edd4":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestHasSpecialChars(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with double quote\",\n\t\t\targs: args{s: \"hello\\\"\"},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with backslash\",\n\t\t\targs: args{s: \"hello\\\\\"},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with control character\",\n\t\t\targs: args{s: \"hello\\x1F\"},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with no special characters\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := hasSpecialChars(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"hasSpecialChars() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","5cd64ad2aa4560244f16feafbdcdc631":"```go\npackage fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n","5d423fabd7fd94b752240bfb62492b92":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetArray(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant []*Value\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\targs: args{keys: []string{}},\n\t\t\twant: []*Value{},\n\t\t},\n\t\t{\n\t\t\tname: \"get array element\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"foo\"},\n\t\t\t\t\t{t: TypeNumber, o: Object{kvs: []kv{{k: \"bar\", v: \u0026Value{t: TypeString, s: \"baz\"}}}}},\n\t\t\t\t},\n\t\t\t},\n\t\t\targs: args{keys: []string{\"0\"}},\n\t\t\twant: []*Value{\n\t\t\t\t{t: TypeString, s: \"foo\"},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"get nested array element\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"foo\"},\n\t\t\t\t\t{t: TypeObject, o: Object{kvs: []kv{{k: \"bar\", v: \u0026Value{t: TypeArray, a: []*Value{{t: TypeString, s: \"baz\"}}}}}}},\n\t\t\t\t},\n\t\t\t},\n\t\t\targs: args{keys: []string{\"1\", \"bar\", \"0\"}},\n\t\t\twant: []*Value{\n\t\t\t\t{t: TypeString, s: \"baz\"},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"get non-existing array element\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"foo\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\targs: args{keys: []string{\"1\"}},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"get array element by index string\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"foo\"},\n\t\t\t\t\t{t: TypeNumber, o: Object{kvs: []kv{{k: \"bar\", v: \u0026Value{t: TypeString, s: \"baz\"}}}}},\n\t\t\t\t},\n\t\t\t},\n\t\t\targs: args{keys: []string{\"0\"}},\n\t\t\twant: []*Value{\n\t\t\t\t{t: TypeString, s: \"foo\"},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"get array element by decimal index\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"foo\"},\n\t\t\t\t\t{t: TypeNumber, o: Object{kvs: []kv{{k: \"bar\", v: \u0026Value{t: TypeString, s: \"baz\"}}}}},\n\t\t\t\t},\n\t\t\t},\n\t\t\targs: args{keys: []string{\"0.0\"}},\n\t\t\twant: []*Value{\n\t\t\t\t{t: TypeString, s: \"foo\"},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"get array element by negative index\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"foo\"},\n\t\t\t\t\t{t: TypeNumber, o: Object{kvs: []kv{{k: \"bar\", v: \u0026Value{t: TypeString, s: \"baz\"}}}}},\n\t\t\t\t},\n\t\t\t},\n\t\t\targs: args{keys: []string{\"-1\"}},\n\t\t\twant: []*Value{\n\t\t\t\t{t: TypeNumber, o: Object{kvs: []kv{{k: \"bar\", v: \u0026Value{t: TypeString, s: \"baz\"}}}}},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"get array element by out-of-bounds index\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"foo\"},\n\t\t\t\t\t{t: TypeNumber, o: Object{kvs: []kv{{k: \"bar\", v: \u0026Value{t: TypeString, s: \"baz\"}}}}},\n\t\t\t\t},\n\t\t\t},\n\t\t\targs: args{keys: []string{\"2\"}},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"get array element by invalid index\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"foo\"},\n\t\t\t\t\t{t: TypeNumber, o: Object{kvs: []kv{{k: \"bar\", v: \u0026Value{t: TypeString, s: \"baz\"}}}}},\n\t\t\t\t},\n\t\t\t},\n\t\t\targs: args{keys: []string{\"a\"}},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"get array element from non-array value\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"foo\",\n\t\t\t},\n\t\t\targs: args{keys: []string{\"0\"}},\n\t\t\twant: nil,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.GetArray(tt.args.keys...); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"GetArray() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","5d50de60db0396b2d0bd0253f72fb162":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantV   *Value\n\t\twantTail string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:    \"\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV:   nil,\n\t\t\twantTail: \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"too deep\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{\\\"a\\\":{\\\"b\\\":{\\\"c\\\":{\\\"d\\\":{\\\"e\\\":{\\\"f\\\":{\\\"g\\\":{\\\"h\\\":{\\\"i\\\":{\\\"j\\\":{\\\"k\\\":{\\\"l\\\":{\\\"m\\\":{\\\"n\\\":{\\\"o\\\":{\\\"p\\\":{\\\"q\\\":{\\\"r\\\":{\\\"s\\\":{\\\"t\\\":{\\\"u\\\":{\\\"v\\\":{\\\"w\\\":{\\\"x\\\":{\\\"y\\\":{\\\"z\\\":[1,2,3]}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV:   nil,\n\t\t\twantTail: \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"a\":1,\"b\":\"2\",\"c\":[3,4,5],\"d\":{\"e\":6,\"f\":7}}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: func() *Value {\n\t\t\t\tv := \u0026Value{}\n\t\t\t\tv.t = TypeObject\n\t\t\t\tv.o.kvs = []kv{\n\t\t\t\t\t{k: \"a\", v: \u0026Value{t: TypeNumber, s: \"1\"}},\n\t\t\t\t\t{k: \"b\", v: \u0026Value{t: TypeString, s: \"2\"}},\n\t\t\t\t\t{k: \"c\", v: \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t\t\t{t: TypeNumber, s: \"4\"},\n\t\t\t\t\t\t{t: TypeNumber, s: \"5\"},\n\t\t\t\t\t}}},\n\t\t\t\t\t{k: \"d\", v: \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t\t\t{k: \"e\", v: \u0026Value{t: TypeNumber, s: \"6\"}},\n\t\t\t\t\t\t{k: \"f\", v: \u0026Value{t: TypeNumber, s: \"7\"}},\n\t\t\t\t\t}}}},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:    `[1,2,3,4,5]`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: func() *Value {\n\t\t\t\tv := \u0026Value{}\n\t\t\t\tv.t = TypeArray\n\t\t\t\tv.a = []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t\t{t: TypeNumber, s: \"4\"},\n\t\t\t\t\t{t: TypeNumber, s: \"5\"},\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:    `\"hello, world\"`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: func() *Value {\n\t\t\t\tv := \u0026Value{}\n\t\t\t\tv.t = TypeString\n\t\t\t\tv.s = \"hello, world\"\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:    `true`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV:   valueTrue,\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:    `false`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV:   valueFalse,\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:    `null`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV:   valueNull,\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:    `1234567890`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: func() *Value {\n\t\t\t\tv := \u0026Value{}\n\t\t\t\tv.t = TypeNumber\n\t\t\t\tv.s = \"1234567890\"\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with decimal\",\n\t\t\targs: args{\n\t\t\t\ts:    `123.456789`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: func() *Value {\n\t\t\t\tv := \u0026Value{}\n\t\t\t\tv.t = TypeNumber\n\t\t\t\tv.s = \"123.456789\"\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with exponent\",\n\t\t\targs: args{\n\t\t\t\ts:    `1.23456789e+10`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: func() *Value {\n\t\t\t\tv := \u0026Value{}\n\t\t\t\tv.t = TypeNumber\n\t\t\t\tv.s = \"1.23456789e+10\"\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts:    `1.23456789e-10`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: func() *Value {\n\t\t\t\tv := \u0026Value{}\n\t\t\t\tv.t = TypeNumber\n\t\t\t\tv.s = \"1.23456789e-10\"\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative sign\",\n\t\t\targs: args{\n\t\t\t\ts:    `-1234567890`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: func() *Value {\n\t\t\t\tv := \u0026Value{}\n\t\t\t\tv.t = TypeNumber\n\t\t\t\tv.s = \"-1234567890\"\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:    `NaN`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: func() *Value {\n\t\t\t\tv := \u0026Value{}\n\t\t\t\tv.t = TypeNumber\n\t\t\t\tv.s = \"NaN\"\n\t\t\t\treturn v\n\t\t\t}(),\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid JSON\",\n\t\t\targs: args{\n\t\t\t\ts:    `1234567890`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV:   nil,\n\t\t\twantTail: \"\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotV, gotTail, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr \u0026\u0026 !reflect.DeepEqual(gotV, tt.wantV) {\n\t\t\t\tt.Errorf(\"parseValue() = %v, want %v\", gotV, tt.wantV)\n\t\t\t}\n\t\t\tif !tt.wantErr \u0026\u0026 gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseValue() = %v, want %v\", gotTail, tt.wantTail)\n\t\t\t}\n\t\t\tif !tt.wantErr {\n\t\t\t\t// Check if the JSON can be marshalled back to the original string\n\t\t\t\tmarshalled, err := json.Marshal(gotV)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"parseValue() failed to marshal result: %v\", err)\n\t\t\t\t}\n\t\t\t\tif string(marshalled) != tt.args.s {\n\t\t\t\t\tt.Errorf(\"parseValue() marshalled result does not match original string: %s != %s\", string(marshalled), tt.args.s)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","5d9ba318f485a038f98ce79add0f925e":"```go\npackage fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"empty string\",\n\t\t\targs:    args{s: \"\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"simple number\",\n\t\t\targs:    args{s: \"123\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"negative number\",\n\t\t\targs:    args{s: \"-123\"},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"decimal number\",\n\t\t\targs:    args{s: \"123.456\"},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"exponential number\",\n\t\t\targs:    args{s: \"1.23e+4\"},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading zeros\",\n\t\t\targs:    args{s: \"00123\"},\n\t\t\twantNs:  \"00123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with trailing zeros\",\n\t\t\targs:    args{s: \"123.00\"},\n\t\t\twantNs:  \"123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign\",\n\t\t\targs:    args{s: \"+123\"},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with trailing plus sign\",\n\t\t\targs:    args{s: \"123+\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with trailing minus sign\",\n\t\t\targs:    args{s: \"123-\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with invalid character\",\n\t\t\targs:    args{s: \"123a\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with inf\",\n\t\t\targs:    args{s: \"123inf\"},\n\t\t\twantNs:  \"123inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with nan\",\n\t\t\targs:    args{s: \"123nan\"},\n\t\t\twantNs:  \"123nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with inf at the beginning\",\n\t\t\targs:    args{s: \"inf123\"},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"123\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with nan at the beginning\",\n\t\t\targs:    args{s: \"nan123\"},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"123\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with inf at the beginning with leading minus sign\",\n\t\t\targs:    args{s: \"-inf123\"},\n\t\t\twantNs:  \"-inf\",\n\t\t\twantS:   \"123\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with nan at the beginning with leading minus sign\",\n\t\t\targs:    args{s: \"-nan123\"},\n\t\t\twantNs:  \"-nan\",\n\t\t\twantS:   \"123\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with inf at the beginning with leading plus sign\",\n\t\t\targs:    args{s: \"+inf123\"},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"123\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with nan at the beginning with leading plus sign\",\n\t\t\targs:    args{s: \"+nan123\"},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"123\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading space\",\n\t\t\targs:    args{s: \" 123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" 123\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\t","5da18abcb95e96380f9c8fd275d622fd":"package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061hello\\\\u0062 world\"},\n\t\t\twant: \"ahello b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01hello world\"},\n\t\t\twant: \"😁hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\ world\"},\n\t\t\twant: \"\\\\xhello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"too short escape sequence\",\n\t\t\targs: args{s: \"\\\\u006hello world\"},\n\t\t\twant: \"\\\\u006hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\n\\\\u0061\\\\u0062\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"\\\"hello\\\" \\\\world\\na b😁\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","5ec1cf68f235fec45dbd1b9bba550fd2":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequence\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello world\",\n\t\t\t},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quote\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\\\\"\",\n\t\t\t},\n\t\t\twant: \"\\\"\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslash\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\\\\\\",\n\t\t\t},\n\t\t\twant: \"\\\\\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped slash\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\/\",\n\t\t\t},\n\t\t\twant: \"/\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped b\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\b\",\n\t\t\t},\n\t\t\twant: \"\\b\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped f\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\f\",\n\t\t\t},\n\t\t\twant: \"\\f\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped n\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\n\",\n\t\t\t},\n\t\t\twant: \"\\n\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped r\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\r\",\n\t\t\t},\n\t\t\twant: \"\\r\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped t\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\t\",\n\t\t\t},\n\t\t\twant: \"\\t\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped u with valid hex\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\u0061\",\n\t\t\t},\n\t\t\twant: \"a\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped u with invalid hex\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\u00xx\",\n\t\t\t},\n\t\t\twant: \"\\\\u00xx\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped u with surrogate pair\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\uD83D\\\\uDE01\",\n\t\t\t},\n\t\t\twant: \"😁\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped u with incomplete surrogate pair\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\uD83D\\\\uDE\",\n\t\t\t},\n\t\t\twant: \"\\\\uD83D\\\\uDE\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped u with invalid surrogate pair\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\uD83D\\\\u0001\",\n\t\t\t},\n\t\t\twant: \"\\\\uD83D\\\\u0001\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\\\\"\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\uD83D\\\\uDE01\",\n\t\t\t},\n\t\t\twant: \"\\\"\\\\b\\f\\n\\r\\t\\u0061😁\",\n\t\t},\n\t\t{\n\t\t\tname: \"unknown escape sequence\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\x\",\n\t\t\t},\n\t\t\twant: \"\\\\x\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestUnescapeStringBestEffort_JSON(t *testing.T) {\n\ttype testCase struct {\n\t\tinput  string\n\t\texpect string\n\t}\n\ttestCases := []testCase{\n\t\t{\n\t\t\tinput:  `{\"name\": \"John \\\\\"Doe\\\\\"\", \"age\": 30}`,\n\t\t\texpect: `{\"name\": \"John \\\"Doe\\\"\", \"age\": 30}`,\n\t\t},\n\t\t{\n\t\t\tinput:  `{\"message\": \"Hello, \\\\\"world\\\\\"! \\\\u00A0\\\\uD83D\\\\uDE01\\\\nThis is a \\\\\"test\\\\\" string.\"}`,\n\t\t\texpect: `{\"message\": \"Hello, \\\"world\\\"! \\uD83D\\uDE01\\nThis is a \\\"test\\\" string.\"}`,\n\t\t},\n\t}\n\tfor i, tc := range testCases {\n\t\tt.Run(string(i), func(t *testing.T) {\n\t\t\t// Parse the JSON input using the standard library.\n\t\t\tvar data interface{}\n\t\t\terr := json.Unmarshal([]byte(tc.input), \u0026data)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Error unmarshaling JSON: %s\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Parse the JSON input using fastjson and unescape the string using unescapeStringBestEffort.\n\t\t\tv, err := Parse(tc.input)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Error parsing JSON: %s\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tunescapedString := unescapeStringBestEffort(v.StringBytes())\n\n\t\t\t// Marshal the unescaped string back to JSON.\n\t\t\tmarshaledString, err := json.Marshal(unescapedString)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Error marshaling JSON: %s\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Compare the results.\n\t\t\tif string(marshaledString) != tc.expect {\n\t\t\t\tt.Errorf(\"Expected JSON: %s, got: %s\", tc.expect, string(marshaledString))\n\t\t\t}\n\t\t})\n\t}\n}","5f00dfe65b2cd06b1edd54aff1a38985":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestString(t *testing.T) {\n\ttype args struct {\n\t\tt Type\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"TypeObject\",\n\t\t\targs: args{t: TypeObject},\n\t\t\twant: \"object\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeArray\",\n\t\t\targs: args{t: TypeArray},\n\t\t\twant: \"array\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeString\",\n\t\t\targs: args{t: TypeString},\n\t\t\twant: \"string\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeNumber\",\n\t\t\targs: args{t: TypeNumber},\n\t\t\twant: \"number\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeTrue\",\n\t\t\targs: args{t: TypeTrue},\n\t\t\twant: \"true\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeFalse\",\n\t\t\targs: args{t: TypeFalse},\n\t\t\twant: \"false\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeNull\",\n\t\t\targs: args{t: TypeNull},\n\t\t\twant: \"null\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.t.String(); got != tt.want {\n\t\t\t\tt.Errorf(\"String() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","5f2d638daec8a7a43d52ea4a7cee1688":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Type(t *testing.T) {\n\ttype args struct {\n\t\tv *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant Type\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.v.Type(); got != tt.want {\n\t\t\t\tt.Errorf(\"Value.Type() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","5f7e1b408299a5feceba48dcfcc3c3e6":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello\\\"\",\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello\\\\\\\"world\\\"\",\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped string with multiple escapes\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello\\\\\\\\\\\"world\\\"\",\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello\",\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"\\\"\",\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with leading and trailing whitespace\",\n\t\t\targs: args{\n\t\t\t\ts: \"  \\\"hello\\\"  \",\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"  \",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","60373dd5eb43b7806c0c2d73a68b5a1f":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttype want struct {\n\t\tv   *Value\n\t\ttail string\n\t\terr  error\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant want\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  fmt.Errorf(\"cannot parse empty string\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"{}\",\n\t\t\t\terr:  fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{t: TypeObject, o: Object{}},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{t: TypeArray, a: []*Value{}},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"test\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{t: typeRawString, s: \"test\"},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   \"true\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueTrue,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   \"false\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueFalse,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   \"null\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueNull,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   \"123\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\ts:   \"NaN\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"NaN\"},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotV, gotTail, gotErr := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif gotErr != nil \u0026\u0026 tt.want.err == nil {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, want nil\", gotErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotErr == nil \u0026\u0026 tt.want.err != nil {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, want %v\", gotErr, tt.want.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotErr != nil \u0026\u0026 tt.want.err != nil {\n\t\t\t\tif gotErr.Error() != tt.want.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue() error = %v, want %v\", gotErr, tt.want.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\tif gotV != nil \u0026\u0026 tt.want.v == nil {\n\t\t\t\tt.Errorf(\"parseValue() gotV = %v, want nil\", gotV)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotV == nil \u0026\u0026 tt.want.v != nil {\n\t\t\t\tt.Errorf(\"parseValue() gotV = %v, want %v\", gotV, tt.want.v)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotV != nil \u0026\u0026 tt.want.v != nil {\n\t\t\t\tif gotV.t != tt.want.v.t {\n\t\t\t\t\tt.Errorf(\"parseValue() gotV.t = %v, want %v\", gotV.t, tt.want.v.t)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif gotV.o != tt.want.v.o {\n\t\t\t\t\tt.Errorf(\"parseValue() gotV.o = %v, want %v\", gotV.o, tt.want.v.o)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif gotV.a != tt.want.v.a {\n\t\t\t\t\tt.Errorf(\"parseValue() gotV.a = %v, want %v\", gotV.a, tt.want.v.a)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif gotV.s != tt.want.v.s {\n\t\t\t\t\tt.Errorf(\"parseValue() gotV.s = %v, want %v\", gotV.s, tt.want.v.s)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\tif gotTail != tt.want.tail {\n\t\t\t\tt.Errorf(\"parseValue() gotTail = %v, want %v\", gotTail, tt.want.tail)\n\t\t\t}\n\t\t})\n\t}\n}","61b554d4a71f6eec4c4a774e11524106":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantV   *Value\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey\": \"nestedValue\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV:   nil,\n\t\t\twantS:   `{\"key1\": \"value1`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\" \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV:   nil,\n\t\t\twantS:   `{\"key1\" \"value1\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV:   nil,\n\t\t\twantS:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotV, gotS, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(gotV, tt.wantV) {\n\t\t\t\tt.Errorf(\"parseObject() gotV = %v, want %v\", gotV, tt.wantV)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseObject() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_Unmarshal(t *testing.T) {\n\ttype MyStruct struct {\n\t\tKey1 string `json:\"key1\"`\n\t\tKey2 string `json:\"key2\"`\n\t}\n\ttests := []struct {\n\t\tname     string\n\t\tjsonStr  string\n\t\twantData MyStruct\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:    \"simple object\",\n\t\t\tjsonStr: `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantData: MyStruct{\n\t\t\t\tKey1: \"value1\",\n\t\t\t\tKey2: \"value2\",\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"nested object\",\n\t\t\tjsonStr: `{\"key1\": {\"nestedKey\": \"nestedValue\"}, \"key2\": \"value2\"}`,\n\t\t\twantData: MyStruct{\n\t\t\t\tKey1: `{\"nestedKey\": \"nestedValue\"}`,\n\t\t\t\tKey2: \"value2\",\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv, _, err := parseObject(tt.jsonStr, \u0026cache{}, 0)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif tt.wantErr {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tvar gotData MyStruct\n\t\t\tif err := json.Unmarshal(v.MarshalTo(nil), \u0026gotData); err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(gotData, tt.wantData) {\n\t\t\t\tt.Errorf(\"parseObject() gotData = %v, want %v\", gotData, tt.wantData)\n\t\t\t}\n\t\t})\n\t}\n}","61c8116723a685d16e3b316f3a1002d9":"```go\npackage fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"strconv\"\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"abcdefg\"},\n\t\t\twant: \"abcdefg\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\","61fabe52f811641e8d99fbb89579e7fe":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttype want struct {\n\t\tv   *Value\n\t\ttail string\n\t\terr  error\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant want\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  fmt.Errorf(\"cannot parse empty string\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"{}\",\n\t\t\t\terr:  fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"hello\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: typeRawString,\n\t\t\t\t\ts: \"hello\",\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   \"true\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueTrue,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   \"false\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueFalse,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   \"null\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueNull,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   \"123\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"123\",\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   \"NaN\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"NaN\",\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotV, gotTail, gotErr := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (gotErr == nil) != (tt.want.err == nil) {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", gotErr, tt.want.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotErr != nil \u0026\u0026 tt.want.err != nil {\n\t\t\t\tif gotErr.Error() != tt.want.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", gotErr, tt.want.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(gotV, tt.want.v) {\n\t\t\t\tt.Errorf(\"parseValue() gotV = %v, want %v\", gotV, tt.want.v)\n\t\t\t}\n\t\t\tif gotTail != tt.want.tail {\n\t\t\t\tt.Errorf(\"parseValue() gotTail = %v, want %v\", gotTail, tt.want.tail)\n\t\t\t}\n\t\t})\n\t}\n}\n","621369ec062ba27fe0667dfb122818cd":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetObject_Empty(t *testing.T) {\n\tv := \u0026Value{}\n\tif v.GetObject() != nil {\n\t\tt.Errorf(\"GetObject() should return nil for empty value\")\n\t}\n}\n\nfunc TestGetObject_InvalidType(t *testing.T) {\n\tv := \u0026Value{t: TypeArray}\n\tif v.GetObject() != nil {\n\t\tt.Errorf(\"GetObject() should return nil for invalid type\")\n\t}\n}\n\nfunc TestGetObject_ValidObject(t *testing.T) {\n\tv := \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}}, {k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"2\"}}}}}\n\tif v.GetObject() == nil {\n\t\tt.Errorf(\"GetObject() should not return nil for valid object\")\n\t}\n}\n\nfunc TestGetObject_NonExistingKey(t *testing.T) {\n\tv := \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}}, {k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"2\"}}}}}\n\tif v.GetObject(\"key3\") != nil {\n\t\tt.Errorf(\"GetObject() should return nil for non-existing key\")\n\t}\n}\n\nfunc TestGetObject_NestedObject(t *testing.T) {\n\tv := \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key1\", v: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}}}}}}}}}}\n\tobj := v.GetObject(\"key1\")\n\tif obj == nil {\n\t\tt.Errorf(\"GetObject() should not return nil for nested object\")\n\t}\n\tif obj.GetObject(\"key2\") == nil {\n\t\tt.Errorf(\"GetObject() should not return nil for nested key\")\n\t}\n}\n\nfunc TestGetObject_ArrayIndex(t *testing.T) {\n\tv := \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"0\", v: \u0026Value{t: TypeString, s: \"value1\"}}, {k: \"1\", v: \u0026Value{t: TypeNumber, s: \"2\"}}}}}\n\tobj := v.GetObject(\"0\")\n\tif obj == nil {\n\t\tt.Errorf(\"GetObject() should not return nil for array index\")\n\t}\n}\n\nfunc TestGetObject_InvalidArrayIndex(t *testing.T) {\n\tv := \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"0\", v: \u0026Value{t: TypeString, s: \"value1\"}}, {k: \"1\", v: \u0026Value{t: TypeNumber, s: \"2\"}}}}}\n\tif v.GetObject(\"2\") != nil {\n\t\tt.Errorf(\"GetObject() should return nil for invalid array index\")\n\t}\n}","63402e102f86c86928aec807fb0479ab":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"empty string\",\n\t\t\targs:    args{s: \"\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"simple integer\",\n\t\t\targs:    args{s: \"123\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"negative integer\",\n\t\t\targs:    args{s: \"-123\"},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"float\",\n\t\t\targs:    args{s: \"123.456\"},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"exponent\",\n\t\t\targs:    args{s: \"1.23e+4\"},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"inf\",\n\t\t\targs:    args{s: \"inf\"},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"nan\",\n\t\t\targs:    args{s: \"nan\"},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid character\",\n\t\t\targs:    args{s: \"123a\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"leading plus\",\n\t\t\targs:    args{s: \"+123\"},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"leading minus\",\n\t\t\targs:    args{s: \"-123\"},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid inf\",\n\t\t\targs:    args{s: \"in\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"in\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid nan\",\n\t\t\targs:    args{s: \"na\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"na\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}","638aa3553dd719f069b9f6dffc648994":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_reset(t *testing.T) {\n\ttype args struct {\n\t\to *Object\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant *Object\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.o.reset(); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Object.reset() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","63cc792ba38391a1dc1494e0e4f7ffab":"```go\npackage fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"key2\": \"value2\"}, \"key3\": \"value3\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\tc:    ","63d456ce66116ca7c6f98bdfaf7cb763":"```go\npackage fastjson\n\nimport (\n\t\"fmt\"\n\t\"","6430a06526b6fe0eb984404080988e8a":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"Simple String\",\n\t\t\targs: args{\n\t\t\t\ts: `\"simpleString\"`,\n\t\t\t},\n\t\t\twant:    \"simpleString\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"String with Escaped Quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"escaped\\\\\"quotes\"`,\n\t\t\t},\n\t\t\twant:    \"escaped\\\\\\\"quotes\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"String with Multiple Escaped Quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"multiple\\\\\\\"escaped\\\\\"quotes\"`,\n\t\t\t},\n\t\t\twant:    \"multiple\\\\\\\"escaped\\\\\\\"quotes\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"String with Unescaped Quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"unescaped\\\"quote\"`,\n\t\t\t},\n\t\t\twant:    \"unescaped\\\"\",\n\t\t\twant1:   \"quote\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"String with Missing Closing Quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"missingClosingQuote`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Empty String\",\n\t\t\targs: args{\n\t\t\t\ts: ``,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"String with Leading Quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"leadingQuote\"`,\n\t\t\t},\n\t\t\twant:    \"leadingQuote\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"String with Trailing Quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"trailingQuote\"`,\n\t\t\t},\n\t\t\twant:    \"trailingQuote\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"String with Spaces\",\n\t\t\targs: args{\n\t\t\t\ts: `\"string with spaces\"`,\n\t\t\t},\n\t\t\twant:    \"string with spaces\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"String with Special Characters\",\n\t\t\targs: args{\n\t\t\t\ts: `\"string with special characters: !@#$%^\u0026*()_+-=[]{};':\\\",./\u003c\u003e?|`,\n\t\t\t},\n\t\t\twant:    \"string with special characters: !@#$%^\u0026*()_+-=[]{};':\\\",./\u003c\u003e?|\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","645caff14b02a94bc8655b0b42b8bae0":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"simple string\"`,\n\t\t\t},\n\t\t\twant:    \"simple string\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"escaped \\\"string\\\"\"`,\n\t\t\t},\n\t\t\twant:    \"escaped \\\"string\\\"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escaped strings\",\n\t\t\targs: args{\n\t\t\t\ts: `\"escaped \\\\\"string\\\\\" with \\\\\\\"escaped\\\\\\\" quotes\"`,\n\t\t\t},\n\t\t\twant:    \"escaped \\\"string\\\" with \\\"escaped\\\" quotes\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"missing closing quote`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: ``,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","649e83338fd51e1621a05feef82da083":"package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequence\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quote\",\n\t\t\targs: args{s: \"\\\"hello world\\\"\"},\n\t\t\twant: `\"hello world\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslash\",\n\t\t\targs: args{s: \"\\\\hello world\"},\n\t\t\twant: \"\\\\hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped slash\",\n\t\t\targs: args{s: \"/hello world\"},\n\t\t\twant: \"/hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello world\"},\n\t\t\twant: \"\\bhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello world\"},\n\t\t\twant: \"\\fhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello world\"},\n\t\t\twant: \"\\nhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello world\"},\n\t\t\twant: \"\\rhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello world\"},\n\t\t\twant: \"\\thello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character\",\n\t\t\targs: args{s: \"\\\\u0061hello world\"},\n\t\t\twant: \"ahello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01hello world\"},\n\t\t\twant: \"😁hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\uhello world\"},\n\t\t\twant: \"\\\\uhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u006hello world\"},\n\t\t\twant: \"\\\\u006hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\uD83D\\\\uDE01hello world\"},\n\t\t\twant: `\"\\b\\f\\n\\r\\ta😁hello world`,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_surrogatePair(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"incomplete surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83Dhello world\"},\n\t\t\twant: \"\\\\uD83Dhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete surrogate pair 2\",\n\t\t\targs: args{s: \"\\\\uDE01hello world\"},\n\t\t\twant: \"\\\\uDE01hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\u0001hello world\"},\n\t\t\twant: \"\\\\uD83D\\\\u0001hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid surrogate pair 2\",\n\t\t\targs: args{s: \"\\\\u0001\\\\uDE01hello world\"},\n\t\t\twant: \"\\\\u0001\\\\uDE01hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"valid surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01hello world\"},\n\t\t\twant: \"😁hello world\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_unicodeEscape(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"invalid unicode escape\",\n\t\t\targs: args{s: \"\\\\u12345hello world\"},\n\t\t\twant: \"\\\\u12345hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid unicode escape 2\",\n\t\t\targs: args{s: \"\\\\uxyzhello world\"},\n\t\t\twant: \"\\\\uxyzhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"valid unicode escape\",\n\t\t\targs: args{s: \"\\\\u0061hello world\"},\n\t\t\twant: \"ahello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"valid unicode escape 2\",\n\t\t\targs: args{s: \"\\\\u0041hello world\"},\n\t\t\twant: \"Ahello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"valid unicode escape 3\",\n\t\t\targs: args{s: \"\\\\u41hello world\"},\n\t\t\twant: \"Ahello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"valid unicode escape 4\",\n\t\t\targs: args{s: \"\\\\u0000hello world\"},\n\t\t\twant: \"\\u0000hello world\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_basicEscape(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"escaped quote\",\n\t\t\targs: args{s: \"\\\\\\\"hello world\"},\n\t\t\twant: `\"hello world`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslash\",\n\t\t\targs: args{s: \"\\\\\\\\hello world\"},\n\t\t\twant: \"\\\\hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped slash\",\n\t\t\targs: args{s: \"\\\\/hello world\"},\n\t\t\twant: \"/hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello world\"},\n\t\t\twant: \"\\bhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello world\"},\n\t\t\twant: \"\\fhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello world\"},\n\t\t\twant: \"\\nhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello world\"},\n\t\t\twant: \"\\rhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello world\"},\n\t\t\twant: \"\\thello world\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_invalidEscape(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"invalid escape\",\n\t\t\targs: args{s: \"\\\\xhello world\"},\n\t\t\twant: \"\\\\xhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape 2\",\n\t\t\targs: args{s: \"\\\\zhello world\"},\n\t\t\twant: \"\\\\zhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape 3\",\n\t\t\targs: args{s: \"\\\\!hello world\"},\n\t\t\twant: \"\\\\!hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape 4\",\n\t\t\targs: args{s: \"\\\\?hello world\"},\n\t\t\twant: \"\\\\?hello world\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_multipleEscapes(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"multiple escapes\",\n\t\t\targs: args{s: \"\\\\\\\"\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061hello world\"},\n\t\t\twant: `\"\\b\\f\\n\\r\\tahello world`,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escapes 2\",\n\t\t\targs: args{s: \"\\\\\\\"\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\uD83D\\\\uDE01hello world\"},\n\t\t\twant: `\"\\b\\f\\n\\r\\ta😁hello world`,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_escapedControlCharacters(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"escaped bell character\",\n\t\t\targs: args{s: \"\\\\ahello world\"},\n\t\t\twant: \"\\ahello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace character\",\n\t\t\targs: args{s: \"\\\\bhello world\"},\n\t\t\twant: \"\\bhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return character\",\n\t\t\targs: args{s: \"\\\\rhello world\"},\n\t\t\twant: \"\\rhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed character\",\n\t\t\targs: args{s: \"\\\\fhello world\"},\n\t\t\twant: \"\\fhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped horizontal tab character\",\n\t\t\targs: args{s: \"\\\\thello world\"},\n\t\t\twant: \"\\thello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline character\",\n\t\t\targs: args{s: \"\\\\nhello world\"},\n\t\t\twant: \"\\nhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped vertical tab character\",\n\t\t\targs: args{s: \"\\\\vhello world\"},\n\t\t\twant: \"\\vhello world\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","6548e1529105cef09542af737bec500c":"```go\npackage fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"{}\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: nil,\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"test\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"test\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   \"true\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueTrue,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   \"false\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueFalse,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   \"null\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueNull,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   \"123\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   \"NaN\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseValue() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseValue_Invalid(t *testing.T) {\n\ttests := []string{\n\t\t\" \",\n\t\t\"  \",\n\t\t\"tru\",\n\t\t\"fal\",\n\t\t\"nul\",\n\t\t\"123e\",\n\t\t\"123.\",\n\t\t\"123.e\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e","65d4ee93a3ee3af7d8087f02220faf12":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_getKV(t *testing.T) {\n\ttype args struct {\n\t\to *Object\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant *kv\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.o.getKV(); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Object.getKV() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","65fc2fe3ed6e0aadf459c8a6722c7911":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCacheGetValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\t// Test that getValue appends a new Value to the slice and returns a pointer to it\n\tv1 := c.getValue()\n\tif len(c.vs) != 1 {\n\t\tt.Errorf(\"Expected length of vs to be 1, got %d\", len(c.vs))\n\t}\n\tif v1 == nil {\n\t\tt.Error(\"Expected getValue to return a non-nil pointer to Value\")\n\t}\n\n\t// Test that getValue returns a pointer to the existing Value\n\tv2 := c.getValue()\n\tif len(c.vs) != 2 {\n\t\tt.Errorf(\"Expected length of vs to be 2, got %d\", len(c.vs))\n\t}\n\tif v2 == nil {\n\t\tt.Error(\"Expected getValue to return a non-nil pointer to Value\")\n\t}\n\tif v1 == v2 {\n\t\tt.Error(\"Expected getValue to return different pointers to Value\")\n\t}\n}\n","667c7903ac2f443de1f8b57d78b53346":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue_Empty(t *testing.T) {\n\tc := \u0026cache{vs: make([]Value, 0)}\n\t_, _, err := parseValue(\"\", c, 0)\n\tif err == nil {\n\t\tt.Error(\"Expected error for empty string, got nil\")\n\t}\n}\n\nfunc TestParseValue_TooDeep(t *testing.T) {\n\tc := \u0026cache{vs: make([]Value, 0)}\n\t_, _, err := parseValue(\"{}\", c, MaxDepth)\n\tif err == nil {\n\t\tt.Error(\"Expected error for exceeding MaxDepth, got nil\")\n\t}\n}\n\nfunc TestParseValue_Object(t *testing.T) {\n\tc := \u0026cache{vs: make([]Value, 0)}\n\tv, tail, err := parseValue(\"{}\", c, 0)\n\tif err != nil {\n\t\tt.Errorf(\"Error parsing object: %s\", err)\n\t}\n\tif tail != \"\" {\n\t\tt.Errorf(\"Expected empty tail, got %q\", tail)\n\t}\n\tif v.Type() != TypeObject {\n\t\tt.Errorf(\"Expected TypeObject, got %v\", v.Type())\n\t}\n}\n\nfunc TestParseValue_Array(t *testing.T) {\n\tc := \u0026cache{vs: make([]Value, 0)}\n\tv, tail, err := parseValue(\"[]\", c, 0)\n\tif err != nil {\n\t\tt.Errorf(\"Error parsing array: %s\", err)\n\t}\n\tif tail != \"\" {\n\t\tt.Errorf(\"Expected empty tail, got %q\", tail)\n\t}\n\tif v.Type() != TypeArray {\n\t\tt.Errorf(\"Expected TypeArray, got %v\", v.Type())\n\t}\n}\n\nfunc TestParseValue_String(t *testing.T) {\n\tc := \u0026cache{vs: make([]Value, 0)}\n\tv, tail, err := parseValue(\"\\\"test\\\"\", c, 0)\n\tif err != nil {\n\t\tt.Errorf(\"Error parsing string: %s\", err)\n\t}\n\tif tail != \"\" {\n\t\tt.Errorf(\"Expected empty tail, got %q\", tail)\n\t}\n\tif v.Type() != TypeRawString {\n\t\tt.Errorf(\"Expected TypeString, got %v\", v.Type())\n\t}\n\tif v.s != \"test\" {\n\t\tt.Errorf(\"Expected string value 'test', got %q\", v.s)\n\t}\n}\n\nfunc TestParseValue_True(t *testing.T) {\n\tc := \u0026cache{vs: make([]Value, 0)}\n\tv, tail, err := parseValue(\"true\", c, 0)\n\tif err != nil {\n\t\tt.Errorf(\"Error parsing true: %s\", err)\n\t}\n\tif tail != \"\" {\n\t\tt.Errorf(\"Expected empty tail, got %q\", tail)\n\t}\n\tif v.Type() != TypeTrue {\n\t\tt.Errorf(\"Expected TypeTrue, got %v\", v.Type())\n\t}\n}\n\nfunc TestParseValue_False(t *testing.T) {\n\tc := \u0026cache{vs: make([]Value, 0)}\n\tv, tail, err := parseValue(\"false\", c, 0)\n\tif err != nil {\n\t\tt.Errorf(\"Error parsing false: %s\", err)\n\t}\n\tif tail != \"\" {\n\t\tt.Errorf(\"Expected empty tail, got %q\", tail)\n\t}\n\tif v.Type() != TypeFalse {\n\t\tt.Errorf(\"Expected TypeFalse, got %v\", v.Type())\n\t}\n}\n\nfunc TestParseValue_Null(t *testing.T) {\n\tc := \u0026cache{vs: make([]Value, 0)}\n\tv, tail, err := parseValue(\"null\", c, 0)\n\tif err != nil {\n\t\tt.Errorf(\"Error parsing null: %s\", err)\n\t}\n\tif tail != \"\" {\n\t\tt.Errorf(\"Expected empty tail, got %q\", tail)\n\t}\n\tif v.Type() != TypeNull {\n\t\tt.Errorf(\"Expected TypeNull, got %v\", v.Type())\n\t}\n}\n\nfunc TestParseValue_Number(t *testing.T) {\n\tc := \u0026cache{vs: make([]Value, 0)}\n\tv, tail, err := parseValue(\"123\", c, 0)\n\tif err != nil {\n\t\tt.Errorf(\"Error parsing number: %s\", err)\n\t}\n\tif tail != \"\" {\n\t\tt.Errorf(\"Expected empty tail, got %q\", tail)\n\t}\n\tif v.Type() != TypeNumber {\n\t\tt.Errorf(\"Expected TypeNumber, got %v\", v.Type())\n\t}\n\tif v.s != \"123\" {\n\t\tt.Errorf(\"Expected number value '123', got %q\", v.s)\n\t}\n}\n\nfunc TestParseValue_NaN(t *testing.T) {\n\tc := \u0026cache{vs: make([]Value, 0)}\n\tv, tail, err := parseValue(\"NaN\", c, 0)\n\tif err != nil {\n\t\tt.Errorf(\"Error parsing NaN: %s\", err)\n\t}\n\tif tail != \"\" {\n\t\tt.Errorf(\"Expected empty tail, got %q\", tail)\n\t}\n\tif v.Type() != TypeNumber {\n\t\tt.Errorf(\"Expected TypeNumber, got %v\", v.Type())\n\t}\n\tif v.s != \"NaN\" {\n\t\tt.Errorf(\"Expected NaN value 'NaN', got %q\", v.s)\n\t}\n}\n\nfunc TestParseValue_Invalid(t *testing.T) {\n\tc := \u0026cache{vs: make([]Value, 0)}\n\t_, _, err := parseValue(\"invalid\", c, 0)\n\tif err == nil {\n\t\tt.Error(\"Expected error for invalid value, got nil\")\n\t}\n}","668a856045bb7eb8bad1930a3275cef9":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello world\",\n\t\t\t},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\\\\"hello\\\\\\\"\",\n\t\t\t},\n\t\t\twant: \"\\\"hello\\\"\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\\\\\hello\\\\\\\\\",\n\t\t\t},\n\t\t\twant: \"\\\\hello\\\\\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\/hello\\\\/\",\n\t\t\t},\n\t\t\twant: \"/hello/\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\b\\\\f\\\\n\\\\r\\\\t\",\n\t\t\t},\n\t\t\twant: \"\\b\\f\\n\\r\\t\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\u0061\\\\u0062\\\\u0063\",\n\t\t\t},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\uD83D\\\\uDE01\",\n\t\t\t},\n\t\t\twant: \"😁\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\u0061\\\\u0062\\\\u\",\n\t\t\t},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence 2\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\uD83D\\\\uDE01\\\\\",\n\t\t\t},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\\\\\ \\\\/test\\\\/\",\n\t\t\t},\n\t\t\twant: \"\\\"hello\\\" \\\\world\\\\ /test/\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","6731289aaef77b8400d83d46dbc76417":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestHasSpecialChars(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with double quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"`,\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with backslash\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\\",\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with control character\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\x1f\",\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with normal characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"abc\",\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := hasSpecialChars(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"hasSpecialChars() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","67b025a3b6f0c6ae2fda197859e96ab1":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttype want struct {\n\t\tv   *Value\n\t\ttail string\n\t\terr  error\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant want\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  fmt.Errorf(\"cannot parse empty string\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"{}\",\n\t\t\t\terr:  fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs:           nil,\n\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: nil,\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"hello\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{\n\t\t\t\t\tt: typeRawString,\n\t\t\t\t\ts: \"hello\",\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   \"true\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueTrue,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   \"false\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueFalse,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   \"null\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueNull,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   \"123\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"123\",\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotV, gotTail, gotErr := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif gotErr != nil \u0026\u0026 tt.want.err == nil {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", gotErr, tt.want.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotErr == nil \u0026\u0026 tt.want.err != nil {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", gotErr, tt.want.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotErr != nil \u0026\u0026 tt.want.err != nil {\n\t\t\t\tif gotErr.Error() != tt.want.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", gotErr, tt.want.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(gotV, tt.want.v) {\n\t\t\t\tt.Errorf(\"parseValue() gotV = %v, want %v\", gotV, tt.want.v)\n\t\t\t}\n\t\t\tif gotTail != tt.want.tail {\n\t\t\t\tt.Errorf(\"parseValue() gotTail = %v, want %v\", gotTail, tt.want.tail)\n\t\t\t}\n\t\t})\n\t}\n}\n","6804e2a188450095521d19251089a3cd":"package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\"\",\n\t\t\twant: \"\\\"hello\\\"\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\\",\n\t\t\twant: \"\\\\hello\\\\\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/\",\n\t\t\twant: \"/hello/\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b\",\n\t\t\twant: \"\\bhello\\b\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f\",\n\t\t\twant: \"\\fhello\\f\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n\",\n\t\t\twant: \"\\nhello\\n\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r\",\n\t\t\twant: \"\\rhello\\r\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t\",\n\t\t\twant: \"\\thello\\t\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061hello\\\\u0062\",\n\t\t\twant: \"ahello b\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01hello\",\n\t\t\twant: \"😁hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\\",\n\t\t\twant: \"\\\\xhello\\\\\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u006\",\n\t\t\twant: \"\\\\u006\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\"\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\uD83D\\\\uDE01\",\n\t\t\twant: \"\\\"hello\\\"\\b\\f\\n\\r\\ta😁\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","682443aef2bd906bc6223297b5892cb3":"package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello world\"},\n\t\t\twant: \"\\\\hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello world\"},\n\t\t\twant: \"/hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello world\"},\n\t\t\twant: \"\\bhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello world\"},\n\t\t\twant: \"\\fhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello world\"},\n\t\t\twant: \"\\nhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello world\"},\n\t\t\twant: \"\\rhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello world\"},\n\t\t\twant: \"\\thello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061hello world\"},\n\t\t\twant: \"ahello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01hello world\"},\n\t\t\twant: \"😀hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello world\"},\n\t\t\twant: \"\\\\xhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u006hello world\"},\n\t\t\twant: \"\\\\u006hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" \\\\bworld\\\\t\\\\n\\\\r\\\\u0061\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"\\\"hello\\\" \\bworld\\t\\n\\ra😀\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","687b07e488e0a192515ad3f89d12c2ca":"package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063 world\"},\n\t\t\twant: \"abc world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode surrogate\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01 world\"},\n\t\t\twant: \"😁 world\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\ world\"},\n\t\t\twant: \"\\\\xhello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"short unicode escape sequence\",\n\t\t\targs: args{s: \"\\\\u006 world\"},\n\t\t\twant: \"\\\\u006 world\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid unicode escape sequence\",\n\t\t\targs: args{s: \"\\\\u006z world\"},\n\t\t\twant: \"\\\\u006z world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with trailing characters\",\n\t\t\targs: args{s: \"\\\\u0061hello\\\\u0062 world\"},\n\t\t\twant: \"ahello\\u0062 world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with trailing characters (surrogate)\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01hello\\\\uD83D\\\\uDE02 world\"},\n\t\t\twant: \"😁hello😂 world\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestUnescapeStringBestEffort_SurrogatePair(t *testing.T) {\n\t// Test cases with surrogate pairs, including invalid ones\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"valid surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"😁\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid surrogate pair (low surrogate first)\",\n\t\t\targs: args{s: \"\\\\uDE01\\\\uD83D\"},\n\t\t\twant: \"\\\\uDE01\\\\uD83D\", // Should be unchanged\n\t\t},\n\t\t{\n\t\t\tname: \"invalid surrogate pair (not a pair)\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE00\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE00\", // Should be unchanged\n\t\t},\n\t\t{\n\t\t\tname: \"valid surrogate pair with trailing characters\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01hello\\\\uD83D\\\\uDE02 world\"},\n\t\t\twant: \"😁hello😂 world\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid surrogate pair with trailing characters\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE00hello\\\\uD83D\\\\uDE01 world\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE00hello\\\\uD83D\\\\uDE01 world\",\n\t\t},\n\t\t{\n\t\t\tname: \"valid surrogate pair with missing second part\",\n\t\t\targs: args{s: \"\\\\uD83D\"},\n\t\t\twant: \"\\\\uD83D\", // Should be unchanged\n\t\t},\n\t\t{\n\t\t\tname: \"valid surrogate pair with missing second part and trailing characters\",\n\t\t\targs: args{s: \"\\\\uD83Dhello world\"},\n\t\t\twant: \"\\\\uD83Dhello world\", // Should be unchanged\n\t\t},\n\t\t{\n\t\t\tname: \"valid surrogate pair with missing first part\",\n\t\t\targs: args{s: \"\\\\uDE01\"},\n\t\t\twant: \"\\\\uDE01\", // Should be unchanged\n\t\t},\n\t\t{\n\t\t\tname: \"valid surrogate pair with missing first part and trailing characters\",\n\t\t\targs: args{s: \"\\\\uDE01hello world\"},\n\t\t\twant: \"\\\\uDE01hello world\", // Should be unchanged\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestUnescapeStringBestEffort_InvalidUnicode(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"invalid unicode sequence\",\n\t\t\targs: args{s: \"\\\\u006z\"},\n\t\t\twant: \"\\\\u006z\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid unicode sequence with trailing characters\",\n\t\t\targs: args{s: \"\\\\u006zhello world\"},\n\t\t\twant: \"\\\\u006zhello world\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestUnescapeStringBestEffort_MultipleEscapeSequences(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\\\\\ \\\\/\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\u0062\\\\u0063\\\\u0064\\\\u0065\\\\u0066\\\\u0067\\\\u0068\\\\u0069\\\\u006a\\\\u006b\\\\u006c\\\\u006d\\\\u006e\\\\u006f\\\\u0070\\\\u0071\\\\u0072\\\\u0073\\\\u0074\\\\u0075\\\\u0076\\\\u0077\\\\u0078\\\\u0079\\\\u007a\\\\/\"},\n\t\t\twant: \"\\\"hello\\\" \\\\world\\\\ /abcdefghijklmnopqrstuvwxyz/\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestUnescapeStringBestEffort_InvalidEscapeSequences(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello world\"},\n\t\t\twant: \"\\\\xhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple invalid escape sequences\",\n\t\t\targs: args{s: \"\\\\xhello\\\\yworld\\\\z\"},\n\t\t\twant: \"\\\\xhello\\\\yworld\\\\z\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestUnescapeStringBestEffort_UnicodeSurrogates(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"valid surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"😁\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid surrogate pair (low surrogate first)\",\n\t\t\targs: args{s: \"\\\\uDE01\\\\uD83D\"},\n\t\t\twant: \"\\\\uDE01\\\\uD83D\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid surrogate pair (not a pair)\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE00\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE00\",\n\t\t},\n\t\t{\n\t\t\tname: \"valid surrogate pair with trailing characters\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01hello\\\\uD83D\\\\uDE02 world\"},\n\t\t\twant: \"😁hello😂 world\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid surrogate pair with trailing characters\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE00hello\\\\uD83D\\\\uDE01 world\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE00hello\\\\uD83D\\\\uDE01 world\",\n\t\t},\n\t\t{\n\t\t\tname: \"valid surrogate pair with missing second part\",\n\t\t\targs: args{s: \"\\\\uD83D\"},\n\t\t\twant: \"\\\\uD83D\",\n\t\t},\n\t\t{\n\t\t\tname: \"valid surrogate pair with missing second part and trailing characters\",\n\t\t\targs: args{s: \"\\\\uD83Dhello world\"},\n\t\t\twant: \"\\\\uD83Dhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"valid surrogate pair with missing first part\",\n\t\t\targs: args{s: \"\\\\uDE01\"},\n\t\t\twant: \"\\\\uDE01\",\n\t\t},\n\t\t{\n\t\t\tname: \"valid surrogate pair with missing first part and trailing characters\",\n\t\t\targs: args{s: \"\\\\uDE01hello world\"},\n\t\t\twant: \"\\\\uDE01hello world\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestUnescapeStringBestEffort_EscapedSurrogates(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\u\\\\uD83D\\\\u\\\\uDE01\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with trailing characters\",\n\t\t\targs: args{s: \"\\\\u\\\\uD83D\\\\u\\\\uDE01hello\\\\u\\\\uD83D\\\\u\\\\uDE02 world\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01hello\\\\uD83D\\\\uDE02 world\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestUnescapeStringBestEffort_InvalidEscapeSequencesInSurrogates(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"invalid escape sequence in surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE01\\\\u0061\\\\u0062\\\\u0063\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence in surrogate pair (missing second part)\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"\\\\uD83D\\\\u0061\\\\u0062\\\\u0063\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence in surrogate pair (missing first part)\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\uDE01\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\uDE01\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestUnescapeStringBestEffort_EdgeCases(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"single backslash\",\n\t\t\targs: args{s: \"\\\\\"},\n\t\t\twant: \"\\\\\",\n\t\t},\n\t\t{\n\t\t\tname: \"backslash followed by non-escaped character\",\n\t\t\targs: args{s: \"\\\\a\"},\n\t\t\twant: \"\\\\a\",\n\t\t},\n\t\t{\n\t\t\tname: \"backslash followed by newline\",\n\t\t\targs: args{s: \"\\\\\\n\"},\n\t\t\twant: \"\\\\\\n\",\n\t\t},\n\t\t{\n\t\t\tname: \"backslash followed by carriage return\",\n\t\t\targs: args{s: \"\\\\\\r\"},\n\t\t\twant: \"\\\\\\r\",\n\t\t},\n\t\t{\n\t\t\tname: \"backslash followed by tab\",\n\t\t\targs: args{s: \"\\\\\\t\"},\n\t\t\twant: \"\\\\\\t\",\n\t\t},\n\t\t{\n\t\t\tname: \"backslash followed by unicode escape sequence\",\n\t\t\targs: args{s: \"\\\\\\\\u0061\"},\n\t\t\twant: \"\\\\\\\\u0061\",\n\t\t},\n\t\t{\n\t\t\tname: \"backslash followed by escaped backslash\",\n\t\t\targs: args{s: \"\\\\\\\\\\\\\"},\n\t\t\twant: \"\\\\\\\\\\\\\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestUnescapeStringBestEffort_Performance(t *testing.T) {\n\t// This test is designed to measure the performance of unescapeStringBestEffort.\n\t// It creates a large string with a high density of escape sequences and\n\t// measures the time it takes to unescape it.\n\tconst numEscapeSequences = 1000000\n\tconst stringLength = 10000000\n\n\t// Create a string with a high density of escape sequences.\n\tvar s string\n\tfor i := 0; i \u003c numEscapeSequences; i++ {\n\t\ts += \"\\\\\\\"\"\n\t}\n\tfor i := 0; i \u003c stringLength-len(s); i++ {\n\t\ts += \"a\"\n\t}\n\n\t// Measure the time it takes to unescape the string.\n\tstart := time.Now()\n\tunescapeStringBestEffort(s)\n\tduration := time.Since(start)\n\n\t// Print the time it took to unescape the string.\n\tt.Logf(\"Time to unescape string: %v\", duration)\n}\n","68808cd021a8ac028c0531f9704bfc29":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_getKV(t *testing.T) {\n\ttype args struct {\n\t\to *Object\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant *kv\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.o.getKV(); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Object.getKV() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","68fecac4233379e0ee0add4e25802abc":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"single element array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"hello\"]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"hello\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"hello\", \"world\", 123]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"hello\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"world\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[[\"hello\", \"world\"], 123]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"hello\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"world\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid array - missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:   `[`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid array - missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"hello\" \"world\"]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `\"hello\" \"world\"`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseArray() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","691a36d7ea06c6aa770c81bab56634b6":"```go\npackage fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"strconv\"\n\t\"strings\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello world\",\n\t\t\t},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quote\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\\\\"\",\n\t\t\t},\n\t\t\twant: \"\\\"\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslash\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\\\\\\",\n\t\t\t},\n\t\t\twant: \"\\\\\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped slash\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\/\",\n\t\t\t},\n\t\t\twant: \"/\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\b\",\n\t\t\t},\n\t\t\twant: \"\\b\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\f\",\n\t\t\t},\n\t\t\twant: \"\\f\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\n\",\n\t\t\t},\n\t\t\twant: \"\\n\",\n\t\t},","6978245fc46d5f25aaf2c8cac4473f73":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"single digit\",\n\t\t\targs: args{\n\t\t\t\ts: \"1\",\n\t\t\t},\n\t\t\twantNs:  \"1\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple digits\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"decimal\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23\",\n\t\t\t},\n\t\t\twantNs:  \"1.23\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponent\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponent lowercase\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e-4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"inf\",\n\t\t\t},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"Inf\",\n\t\t\t},\n\t\t\twantNs:  \"Inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inF\",\n\t\t\targs: args{\n\t\t\t\ts: \"inF\",\n\t\t\t},\n\t\t\twantNs:  \"inF\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"nan\",\n\t\t\t},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twantNs:  \"NaN\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nAn\",\n\t\t\targs: args{\n\t\t\t\ts: \"nAn\",\n\t\t\t},\n\t\t\twantNs:  \"nAn\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid start\",\n\t\t\targs: args{\n\t\t\t\ts: \"a123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"a123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid middle\",\n\t\t\targs: args{\n\t\t\t\ts: \"123a456\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a456\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid end\",\n\t\t\targs: args{\n\t\t\t\ts: \"123a\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}","69e14af1a1cf177e765068338ea97f04":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestValueBool(t *testing.T) {\n\ttype args struct {\n\t\tv *Value\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    bool\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"True\",\n\t\t\targs: args{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeTrue,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant:    true,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"False\",\n\t\t\targs: args{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeFalse,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant:    false,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Null\",\n\t\t\targs: args{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeNull,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant:    false,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Object\",\n\t\t\targs: args{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant:    false,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Array\",\n\t\t\targs: args{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant:    false,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"String\",\n\t\t\targs: args{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeString,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant:    false,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Number\",\n\t\t\targs: args{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant:    false,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := tt.args.v.Bool()\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Value.Bool() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Value.Bool() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","6aca4cb03aca002182ddf53b78161961":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestHasSpecialChars(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"has double quotes\",\n\t\t\targs: args{s: `\"test\"`},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"has backslash\",\n\t\t\targs: args{s: `\\test`},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"has control character\",\n\t\t\targs: args{s: \"\\x00test\"},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"no special characters\",\n\t\t\targs: args{s: \"test\"},\n\t\t\twant: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := hasSpecialChars(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"hasSpecialChars() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","6b4af14a43e831b21c655ba7bacce0d5":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\tv   *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"Marshal null\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNull},\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal true\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeTrue},\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal false\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeFalse},\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal number\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t},\n\t\t\twant: []byte(\"123\"),\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeString, s: \"hello world\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello world\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal raw string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: typeRawString, s: \"hello world\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello world\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal array\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeString, s: \"2\"}}},\n\t\t\t},\n\t\t\twant: []byte(\"[1,\\\"2\\\"]\"),\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal object\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeNumber, s: \"1\"}},\n\t\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"2\"}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":1,\"key2\":\"2\"}`),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.v.MarshalTo(tt.args.dst); !bytesEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc bytesEqual(a, b []byte) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","6b82b35fcceba03b7e2a861d1ca8a1bc":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttype want struct {\n\t\tv   *Value\n\t\ttail string\n\t\terr  error\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant want\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  fmt.Errorf(\"cannot parse empty string\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"{}\",\n\t\t\t\terr:  fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{t: TypeObject, o: Object{}},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{t: TypeArray, a: []*Value{}},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"test\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{t: typeRawString, s: \"test\"},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   \"true\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueTrue,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   \"false\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueFalse,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   \"null\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueNull,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   \"123\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\ts:   \"NaN\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"NaN\"},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotV, gotTail, gotErr := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif gotErr != nil {\n\t\t\t\tif tt.want.err == nil {\n\t\t\t\t\tt.Errorf(\"parseValue() error = %v, want nil\", gotErr)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif !strings.Contains(gotErr.Error(), tt.want.err.Error()) {\n\t\t\t\t\tt.Errorf(\"parseValue() error = %v, want %v\", gotErr, tt.want.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else if tt.want.err != nil {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, want %v\", gotErr, tt.want.err)\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(gotV, tt.want.v) {\n\t\t\t\tt.Errorf(\"parseValue() gotV = %v, want %v\", gotV, tt.want.v)\n\t\t\t}\n\t\t\tif gotTail != tt.want.tail {\n\t\t\t\tt.Errorf(\"parseValue() gotTail = %v, want %v\", gotTail, tt.want.tail)\n\t\t\t}\n\t\t})\n\t}\n}","6d3a5822e00fab03ff2f1d46789bc3de":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"simple string\",\n\t\t\targs:    args{s: \"\\\"hello world\\\"\"},\n\t\t\twant:    \"hello world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"escaped string\",\n\t\t\targs:    args{s: \"\\\"hello \\\\\\\"world\\\\\\\"\\\"\"},\n\t\t\twant:    \"hello \\\"world\\\"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"string with escaped backslash\",\n\t\t\targs:    args{s: \"\\\"hello \\\\\\\\world\\\\\\\"\\\"\"},\n\t\t\twant:    \"hello \\\\world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"missing closing quote\",\n\t\t\targs:    args{s: \"\\\"hello world\"},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"empty string\",\n\t\t\targs:    args{s: \"\"},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"string with no quotes\",\n\t\t\targs:    args{s: \"hello world\"},\n\t\t\twant:    \"hello world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","6d42cc491bb7931af5168fb29d450757":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"empty string\",\n\t\t\targs:    args{s: \"\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"simple integer\",\n\t\t\targs:    args{s: \"123\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"negative integer\",\n\t\t\targs:    args{s: \"-123\"},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"float\",\n\t\t\targs:    args{s: \"123.456\"},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"exponential\",\n\t\t\targs:    args{s: \"1.23e+4\"},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"exponential with negative exponent\",\n\t\t\targs:    args{s: \"1.23e-4\"},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"inf\",\n\t\t\targs:    args{s: \"inf\"},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"INF\",\n\t\t\targs:    args{s: \"INF\"},\n\t\t\twantNs:  \"INF\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"nan\",\n\t\t\targs:    args{s: \"nan\"},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"NAN\",\n\t\t\targs:    args{s: \"NAN\"},\n\t\t\twantNs:  \"NAN\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"leading whitespace\",\n\t\t\targs:    args{s: \" 123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" 123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"trailing whitespace\",\n\t\t\targs:    args{s: \"123 \"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \" \",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid char\",\n\t\t\targs:    args{s: \"123a\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid char at start\",\n\t\t\targs:    args{s: \"a123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"a123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid char at start 2\",\n\t\t\targs:    args{s: \"+123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid char at start 3\",\n\t\t\targs:    args{s: \"-123a\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"-123a\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}","6d5a8b1708e96dcfd891f4e6f778b2eb":"```go\npackage fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"single digit\",\n\t\t\targs: args{\n\t\t\t\ts: \"1\",\n\t\t\t},\n\t\t\twantNs:  \"1\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple digits\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"decimal number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative number\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential number\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zeros\",\n\t\t\targs: args{\n\t\t\t\ts: \"00123\",\n\t\t\t},\n\t\t\twantNs:  \"00123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with trailing zeros\",\n\t\t\targs: args{\n\t\t\t\ts: \"12300\",\n\t\t\t},\n\t\t\twantNs:  \"12300\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading plus sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with trailing plus sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"123+\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading minus sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with trailing minus sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"123-\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading space\",\n\t\t\targs: args{\n\t\t\t\ts: \" 123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" 123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number with trailing space\",\n\t\t\targs: args{\n\t\t\t\ts: \"123 \",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \" \",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading comma\",\n\t\t\targs: args{\n\t\t\t\ts: \",123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \",123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number with trailing comma\",\n\t\t\targs: args{\n\t\t\t\ts: \"123,\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \",\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading colon\",\n\t\t\targs: args{\n\t\t\t\ts: \":123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \":123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number with trailing colon\",\n\t\t\targs: args{\n\t\t\t\ts: \"123:\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \":\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading bracket\",\n\t\t\targs: args{\n\t\t\t\ts: \"[123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"[123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number with trailing bracket\",\n\t\t\targs: args{\n\t\t\t\ts: \"123]\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"]\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading quote\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\\\"123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number with trailing quote\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\\\"\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\\\"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading slash\",\n\t\t\targs: args{\n\t\t\t\ts: \"/123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"/123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number with trailing slash\",\n\t\t\targs: args{\n\t\t\t\ts: \"123/\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"/\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading backslash\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\\\\123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number with trailing backslash\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\\\\\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\\\\\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading question mark\",\n\t\t\targs: args{\n\t\t\t\ts: \"?123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"?123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number with trailing question mark\",\n\t\t\targs: args{\n\t\t\t\ts: \"123?\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"?\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading underscore\",\n\t\t\targs: args{\n\t\t\t\ts: \"_123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"_123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:","6da65682ce259312ae9b4cdb1e73416a":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"simple integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple float\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.45\",\n\t\t\t},\n\t\t\twantNs:  \"123.45\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative float\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123.45\",\n\t\t\t},\n\t\t\twantNs:  \"-123.45\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential notation\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential notation with minus\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e-4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"inf\",\n\t\t\t},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"nan\",\n\t\t\t},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char\",\n\t\t\targs: args{\n\t\t\t\ts: \"123a\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"123a\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at the beginning\",\n\t\t\targs: args{\n\t\t\t\ts: \"a123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"a123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char after number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.45a\",\n\t\t\t},\n\t\t\twantNs:  \"123.45\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}","6db00f06325b618d849dc56822ae75ec":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   \"null\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueNull,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   \"true\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueTrue,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   \"false\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueFalse,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"hello world\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt:  typeRawString,\n\t\t\t\ts:  \"hello world\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   \"123\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt:  TypeNumber,\n\t\t\t\ts:  \"123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt:  typeRawString,\n\t\t\t\t\t\t\t\ts:  \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt:  typeRawString,\n\t\t\t\t\t\t\t\ts:  \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"value1\", \"value2\", \"value3\"]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt:  typeRawString,\n\t\t\t\t\t\ts:  \"value1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt:  typeRawString,\n\t\t\t\t\t\ts:  \"value2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt:  typeRawString,\n\t\t\t\t\t\ts:  \"value3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": {\"key2\": \"value2\"}, \"key3\": \"value3\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt:  typeRawString,\n\t\t\t\t\t\t\t\t\t\t\t\ts:  \"value2\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt:  typeRawString,\n\t\t\t\t\t\t\t\ts:  \"value3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": [\"value1\", \"value2\"], \"key3\": \"value3\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tt:  typeRawString,\n\t\t\t\t\t\t\t\t\t\ts:  \"value1\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tt:  typeRawString,\n\t\t\t\t\t\t\t\t\t\ts:  \"value2\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt:  typeRawString,\n\t\t\t\t\t\t\t\ts:  \"value3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": {\"key2\": {\"key3\": \"value3\"}}, \"key4\": \"value4\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth - 1,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key2\": {\"key3\": \"value3\"}}, \"key4\": \"value4\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid json\",\n\t\t\targs: args{\n\t\t\t\ts:   `{key1: \"value1\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{key1: \"value1\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid json 2\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"value1\", value2]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `[\"value1\", value2]`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !compareValue(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseValue() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValue(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !compareValue(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !compareValue(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\tcase TypeString, TypeNumber, typeRawString:\n\t\tif v1.s != v2.s {\n\t\t\treturn false\n\t\t}\n\tcase TypeTrue, TypeFalse:\n\t\treturn true\n\tcase TypeNull:\n\t\treturn true\n\t}\n\treturn true\n}","6df0d4e5d8c2ff606085628a104b67b6":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"empty string\",\n\t\t\targs:    args{s: \"\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"simple number\",\n\t\t\targs:    args{s: \"123\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with decimal\",\n\t\t\targs:    args{s: \"123.456\"},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"negative number\",\n\t\t\targs:    args{s: \"-123\"},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with exponent\",\n\t\t\targs:    args{s: \"1.23e+4\"},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with exponent in uppercase\",\n\t\t\targs:    args{s: \"1.23E-4\"},\n\t\t\twantNs:  \"1.23E-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus\",\n\t\t\targs:    args{s: \"+123\"},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"inf\",\n\t\t\targs:    args{s: \"inf\"},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"nan\",\n\t\t\targs:    args{s: \"nan\"},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number\",\n\t\t\targs:    args{s: \"123a\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number 2\",\n\t\t\targs:    args{s: \"123.456.789\"},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \".789\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading plus\",\n\t\t\targs:    args{s: \"+123a\"},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading minus\",\n\t\t\targs:    args{s: \"-123a\"},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading plus and exponent\",\n\t\t\targs:    args{s: \"+123e+4a\"},\n\t\t\twantNs:  \"+123e+4\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading minus and exponent\",\n\t\t\targs:    args{s: \"-123e-4a\"},\n\t\t\twantNs:  \"-123e-4\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading plus and decimal\",\n\t\t\targs:    args{s: \"+123.456a\"},\n\t\t\twantNs:  \"+123.456\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading minus and decimal\",\n\t\t\targs:    args{s: \"-123.456a\"},\n\t\t\twantNs:  \"-123.456\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading plus and decimal and exponent\",\n\t\t\targs:    args{s: \"+123.456e+4a\"},\n\t\t\twantNs:  \"+123.456e+4\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading minus and decimal and exponent\",\n\t\t\targs:    args{s: \"-123.456e-4a\"},\n\t\t\twantNs:  \"-123.456e-4\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading plus and exponent and decimal\",\n\t\t\targs:    args{s: \"+123e+4.56a\"},\n\t\t\twantNs:  \"+123e+4\",\n\t\t\twantS:   \".56a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading minus and exponent and decimal\",\n\t\t\targs:    args{s: \"-123e-4.56a\"},\n\t\t\twantNs:  \"-123e-4\",\n\t\t\twantS:   \".56a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading plus and exponent and decimal\",\n\t\t\targs:    args{s: \"+123e+4.56a\"},\n\t\t\twantNs:  \"+123e+4\",\n\t\t\twantS:   \".56a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading minus and exponent and decimal\",\n\t\t\targs:    args{s: \"-123e-4.56a\"},\n\t\t\twantNs:  \"-123e-4\",\n\t\t\twantS:   \".56a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading plus and exponent and decimal\",\n\t\t\targs:    args{s: \"+123e+4.56a\"},\n\t\t\twantNs:  \"+123e+4\",\n\t\t\twantS:   \".56a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading minus and exponent and decimal\",\n\t\t\targs:    args{s: \"-123e-4.56a\"},\n\t\t\twantNs:  \"-123e-4\",\n\t\t\twantS:   \".56a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading plus and exponent and decimal\",\n\t\t\targs:    args{s: \"+123e+4.56a\"},\n\t\t\twantNs:  \"+123e+4\",\n\t\t\twantS:   \".56a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading minus and exponent and decimal\",\n\t\t\targs:    args{s: \"-123e-4.56a\"},\n\t\t\twantNs:  \"-123e-4\",\n\t\t\twantS:   \".56a\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}","6e33d0d62a23a8721caad8b3e9af809d":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no whitespace\",\n\t\t\targs: args{\n\t\t\t\ts: \"abc\",\n\t\t\t},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace\",\n\t\t\targs: args{\n\t\t\t\ts: \"  abc\",\n\t\t\t},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailing whitespace\",\n\t\t\targs: args{\n\t\t\t\ts: \"abc  \",\n\t\t\t},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"whitespace in the middle\",\n\t\t\targs: args{\n\t\t\t\ts: \"a bc\",\n\t\t\t},\n\t\t\twant: \"bc\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple whitespace\",\n\t\t\targs: args{\n\t\t\t\ts: \"  a  b  c  \",\n\t\t\t},\n\t\t\twant: \"b  c  \",\n\t\t},\n\t\t{\n\t\t\tname: \"leading and trailing whitespace\",\n\t\t\targs: args{\n\t\t\t\ts: \"  a b c  \",\n\t\t\t},\n\t\t\twant: \"a b c\",\n\t\t},\n\t\t{\n\t\t\tname: \"all whitespace\",\n\t\t\targs: args{\n\t\t\t\ts: \"   \",\n\t\t\t},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"tab whitespace\",\n\t\t\targs: args{\n\t\t\t\ts: \"a\\tb\",\n\t\t\t},\n\t\t\twant: \"b\",\n\t\t},\n\t\t{\n\t\t\tname: \"newline whitespace\",\n\t\t\targs: args{\n\t\t\t\ts: \"a\\nb\",\n\t\t\t},\n\t\t\twant: \"b\",\n\t\t},\n\t\t{\n\t\t\tname: \"carriage return whitespace\",\n\t\t\targs: args{\n\t\t\t\ts: \"a\\rb\",\n\t\t\t},\n\t\t\twant: \"b\",\n\t\t},\n\t\t{\n\t\t\tname: \"mixed whitespace\",\n\t\t\targs: args{\n\t\t\t\ts: \"  a\\t\\nb\\r c  \",\n\t\t\t},\n\t\t\twant: \"b\\r c\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","6e8502e4888bb33c5d31d62ffdb69b41":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"strconv\"\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello world\",\n\t\t\t},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello world\\\"\",\n\t\t\t},\n\t\t\twant: \"\\\"hello world\\\"\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\hello world\",\n\t\t\t},\n\t\t\twant: \"\\\\hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped slashes\",\n\t\t\targs: args{\n\t\t\t\ts: \"/hello world\",\n\t\t\t},\n\t\t\twant: \"/hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\bhello world\",\n\t\t\t},\n\t\t\twant: \"\\bhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\fhello world\",\n\t\t\t},\n\t\t\twant: \"\\fhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\nhello world\",\n\t\t\t},\n\t\t\twant: \"\\nhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\rhello world\",\n\t\t\t},\n\t\t\twant: \"\\rhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\thello world\",\n\t\t\t},\n\t\t\twant: \"\\thello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\u0061hello world\",\n\t\t\t},\n\t\t\twant: \"ahello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\uD83D\\\\uDE01hello world\",\n\t\t\t},\n\t\t\twant: \"😁hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\xhello world\",\n\t\t\t},\n\t\t\twant: \"\\\\xhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"short unicode escape sequence\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\u006hello world\",\n\t\t\t},\n\t\t\twant: \"\\\\u006hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\\\\"\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\uD83D\\\\uDE01hello world\",\n\t\t\t},\n\t\t\twant: \"\\\"😁hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064\\\\u0065\\\\u0066\\\\u0067\\\\u0068\\\\u0069\\\\u006a\\\\u006b\\\\u006c\\\\u006d\\\\u006e\\\\u006f\\\\u0070\\\\u0071\\\\u0072\\\\u0073\\\\u0074\\\\u0075\\\\u0076\\\\u0077\\\\u0078\\\\u0079\\\\u007a\\\\u0080\\\\u0081\\\\u0082\\\\u0083\\\\u0084\\\\u0085\\\\u0086\\\\u0087\\\\u0088\\\\u0089\\\\u008a\\\\u008b\\\\u008c\\\\u008d\\\\u008e\\\\u008f\\\\u0090\\\\u0091\\\\u0092\\\\u0093\\\\u0094\\\\u0095\\\\u0096\\\\u0097\\\\u0098\\\\u0099\\\\u009a\\\\u009b\\\\u009c\\\\u009d\\\\u009e\\\\u009f\\\\u00a0\\\\u00a1\\\\u00a2\\\\u00a3\\\\u00a4\\\\u00a5\\\\u00a6\\\\u00a7\\\\u00a8\\\\u00a9\\\\u00aa\\\\u00ab\\\\u00ac\\\\u00ad\\\\u00ae\\\\u00af\\\\u00b0\\\\u00b1\\\\u00b2\\\\u00b3\\\\u00b4\\\\u00b5\\\\u00b6\\\\u00b7\\\\u00b8\\\\u00b9\\\\u00ba\\\\u00bb\\\\u00bc\\\\u00bd\\\\u00be\\\\u00bf\\\\u00c0\\\\u00c1\\\\u00c2\\\\u00c3\\\\u00c4\\\\u00c5\\\\u00c6\\\\u00c7\\\\u00c8\\\\u00c9\\\\u00ca\\\\u00cb\\\\u00cc\\\\u00cd\\\\u00ce\\\\u00cf\\\\u00d0\\\\u00d1\\\\u00d2\\\\u00d3\\\\u00d4\\\\u00d5\\\\u00d6\\\\u00d7\\\\u00d8\\\\u00d9\\\\u00da\\\\u00db\\\\u00dc\\\\u00dd\\\\u00de\\\\u00df\\\\u00e0\\\\u00e1\\\\u00e2\\\\u00e3\\\\u00e4\\\\u00e5\\\\u00e6\\\\u00e7\\\\u00e8\\\\u00e9\\\\u00ea\\\\u00eb\\\\u00ec\\\\u00ed\\\\u00ee\\\\u00ef\\\\u00f0\\\\u00f1\\\\u00f2\\\\u00f3\\\\u00f4\\\\u00f5\\\\u00f6\\\\u00f7\\\\u00f8\\\\u00f9\\\\u00fa\\\\u00fb\\\\u00fc\\\\u00fd\\\\u00fe\\\\u00ff\",\n\t\t\t},\n\t\t\twant: \"abcdefghijklmnopqrstuvwxyzÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿ\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestUnescapeStringBestEffort_JSON(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello world\",\n\t\t\t},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello world\\\"\",\n\t\t\t},\n\t\t\twant: \"\\\"hello world\\\"\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\hello world\",\n\t\t\t},\n\t\t\twant: \"\\\\hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped slashes\",\n\t\t\targs: args{\n\t\t\t\ts: \"/hello world\",\n\t\t\t},\n\t\t\twant: \"/hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\bhello world\",\n\t\t\t},\n\t\t\twant: \"\\bhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\fhello world\",\n\t\t\t},\n\t\t\twant: \"\\fhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\nhello world\",\n\t\t\t},\n\t\t\twant: \"\\nhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\rhello world\",\n\t\t\t},\n\t\t\twant: \"\\rhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\thello world\",\n\t\t\t},\n\t\t\twant: \"\\thello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\u0061hello world\",\n\t\t\t},\n\t\t\twant: \"ahello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\uD83D\\\\uDE01hello world\",\n\t\t\t},\n\t\t\twant: \"😁hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\xhello world\",\n\t\t\t},\n\t\t\twant: \"\\\\xhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"short unicode escape sequence\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\u006hello world\",\n\t\t\t},\n\t\t\twant: \"\\\\u006hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\\\\"\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\uD83D\\\\uDE01hello world\",\n\t\t\t},\n\t\t\twant: \"\\\"😁hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064\\\\u0065\\\\u0066\\\\u0067\\\\u0068\\\\u0069\\\\u006a\\\\u006b\\\\u006c\\\\u006d\\\\u006e\\\\u006f\\\\u0070\\\\u0071\\\\u0072\\\\u0073\\\\u0074\\\\u0075\\\\u0076\\\\u0077\\\\u0078\\\\u0079\\\\u007a\\\\u0080\\\\u0081\\\\u0082\\\\u0083\\\\u0084\\\\u0085\\\\u0086\\\\u0087\\\\u0088\\\\u0089\\\\u008a\\\\u008b\\\\u008c\\\\u008d\\\\u008e\\\\u008f\\\\u0090\\\\u0091\\\\u0092\\\\u0093\\\\u0094\\\\u0095\\\\u0096\\\\u0097\\\\u0098\\\\u0099\\\\u009a\\\\u009b\\\\u009c\\\\u009d\\\\u009e\\\\u009f\\\\u00a0\\\\u00a1\\\\u00a2\\\\u00a3\\\\u00a4\\\\u00a5\\\\u00a6\\\\u00a7\\\\u00a8\\\\u00a9\\\\u00aa\\\\u00ab\\\\u00ac\\\\u00ad\\\\u00ae\\\\u00af\\\\u00b0\\\\u00b1\\\\u00b2\\\\u00b3\\\\u00b4\\\\u00b5\\\\u00b6\\\\u00b7\\\\u00b8\\\\u00b9\\\\u00ba\\\\u00bb\\\\u00bc\\\\u00bd\\\\u00be\\\\u00bf\\\\u00c0\\\\u00c1\\\\u00c2\\\\u00c3\\\\u00c4\\\\u00c5\\\\u00c6\\\\u00c7\\\\u00c8\\\\u00c9\\\\u00ca\\\\u00cb\\\\u00cc\\\\u00cd\\\\u00ce\\\\u00cf\\\\u00d0\\\\u00d1\\\\u00d2\\\\u00d3\\\\u00d4\\\\u00d5\\\\u00d6\\\\u00d7\\\\u00d8\\\\u00d9\\\\u00da\\\\u00db\\\\u00dc\\\\u00dd\\\\u00de\\\\u00df\\\\u00e0\\\\u00e1\\\\u00e2\\\\u00e3\\\\u00e4\\\\u00e5\\\\u00e6\\\\u00e7\\\\u00e8\\\\u00e9\\\\u00ea\\\\u00eb\\\\u00ec\\\\u00ed\\\\u00ee\\\\u00ef\\\\u00f0\\\\u00f1\\\\u00f2\\\\u00f3\\\\u00f4\\\\u00f5\\\\u00f6\\\\u00f7\\\\u00f8\\\\u00f9\\\\u00fa\\\\u00fb\\\\u00fc\\\\u00fd\\\\u00fe\\\\u00ff\",\n\t\t\t},\n\t\t\twant: \"abcdefghijklmnopqrstuvwxyzÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿ\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tvar value interface{}\n\t\t\tif err := json.Unmarshal([]byte(tt.args.s), \u0026value); err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t}\n\t\t\tif got, err := json.Marshal(value); err != nil {\n\t\t\t\tt.Errorf(\"json.Marshal() error = %v\", err)\n\t\t\t} else {\n\t\t\t\tif string(got) != tt.want {\n\t\t\t\t\tt.Errorf(\"json.Marshal() = %v, want %v\", string(got), tt.want)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestUnescapeStringBestEffort_Performance(t *testing.T) {\n\ts := `\"\\b\\f\\n\\r\\t\\u0061\\uD83D\\uDE01hello world\"`\n\tfor i := 0; i \u003c 100000; i++ {\n\t\tunescapeStringBestEffort(s)\n\t}\n}","6f19aa110e6aa422ecee615bd3adb1ca":"```go\npackage fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"abcdefg\"},\n\t\t\twant: \"abcdefg\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quote\",\n\t\t\targs: args{s: \"\\\\\\\"\"},\n\t\t\twant: \"\\\"\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslash\",\n\t\t\targs: args{s: \"\\\\\\\\\"},\n\t\t\twant: \"\\\\\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped slash\",\n\t\t\targs: args{s: \"\\\\/\"},\n\t\t\twant: \"/\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\b\"},\n\t\t\twant: \"\\b\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\f\"},\n\t\t\twant: \"\\f\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\n\"},\n\t\t\twant: \"\\n\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\r\"},\n\t\t\twant: \"\\r\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\t\"},\n\t\t\twant: \"\\t\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0020\"},\n\t\t\twant: \" \",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"😀\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\u\"},\n\t\t\twant: \"\\\\u\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence 2\",\n\t\t\targs: args{s: \"\\\\u00\"},\n\t\t\twant: \"\\\\u00\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence 3\",\n\t\t\targs: args{s: \"\\\\u000\"},\n\t\t\twant: \"\\\\u000\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence 4\",\n\t\t\targs: args{s: \"\\\\u0000\"},\n\t\t\twant: \"\\\\u0000\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence 5\",\n\t\t\targs: args{s: \"\\\\u00000\"},\n\t\t\twant: \"\\\\u00000\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence 6\",\n\t\t\targs: args{s: \"\\\\ux\"},\n\t\t\twant: \"\\\\ux\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence 7\",\n\t\t\targs: args{s: \"\\\\u00x\"},\n\t\t\twant: \"\\\\u00x\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence 8\",\n\t\t\targs: args{s: \"\\\\u000x\"},\n\t\t\twant: \"\\\\u000x\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence 9\",\n\t\t\targs: args{s: \"\\\\u0000x\"},\n\t\t\twant: \"\\\\u0000x\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence 10\",\n\t\t\targs: args{s: \"\\\\u00000x\"},\n\t\t\twant: \"\\\\u00000x\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0020\\\\uD83D\\\\uDE01\\\\u0000\\\\ux\"},\n\t\t\twant: \"\\\"\\\\b\\\\f\\\\n\\\\r\\\\t \\u0000\\\\ux\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_SurrogatePair(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tinput string\n\t\twant  string\n\t}{\n\t\t{\n\t\t\tname:  \"Valid surrogate pair\",\n\t\t\tinput: \"\\\\uD83D\\\\uDE01\",\n\t\t\twant:  \"😀\",\n\t\t},\n\t\t{\n\t\t\tname:  \"Invalid surrogate pair (missing high surrogate)\",\n\t\t\tinput: \"\\\\uDE01\",\n\t\t\twant:  \"\\\\uDE01\",\n\t\t},\n\t\t{\n\t\t\tname:  \"Invalid surrogate pair (missing low surrogate)\",\n\t\t\tinput: \"\\\\uD83D\",\n\t\t\twant:  \"\\\\uD83D\",\n\t\t},\n\t\t{\n\t\t\tname:  \"Invalid surrogate pair (high surrogate followed by non-surrogate)\",\n\t\t\tinput: \"\\\\uD83D\\\\u0041\",\n\t\t\twant:  \"\\\\uD83D\\\\u0041\",\n\t\t},\n\t\t{\n\t\t\tname:  \"Invalid surrogate pair (low surrogate followed by non-surrogate)\",\n\t\t\tinput: \"\\\\uDE01\\\\u0041\",\n\t\t\twant:  \"\\\\uDE01\\\\u0041\",\n\t\t},\n\t\t{\n\t\t\tname:  \"Invalid surrogate pair (high surrogate followed by invalid low surrogate)\",\n\t\t\tinput: \"\\\\uD83D\\\\uDC00\",\n\t\t\twant:  \"\\\\uD83D\\\\uDC00\",\n\t\t},\n\t\t{\n\t\t\tname:  \"Invalid surrogate pair (low surrogate followed by invalid high surrogate)\",\n\t\t\tinput: \"\\\\uDC00\\\\uD83D\",\n\t\t\twant:  \"\\\\uDC00\\\\uD83D\",\n\t\t},\n\t\t{\n\t\t\tname:  \"Valid surrogate pair followed by non-surrogate\",\n\t\t\tinput: \"\\\\uD83D\\\\uDE01\\\\u0041\",\n\t\t\twant:  \"😀A\",\n\t\t},\n\t\t{\n\t\t\tname:  \"Non-surrogate followed by valid surrogate pair\",\n\t\t\tinput: \"\\\\u0041\\\\uD83D\\\\uDE01\",\n\t\t\twant:  \"A😀\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := unescapeStringBestEffort(tt.input)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %q, want %q\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_ShortEscapeSequences(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tinput string\n\t\twant  string\n\t}{\n\t\t{\n\t\t\tname:  \"Short escape sequence (\\\\u)\",\n\t\t\tinput: \"\\\\u\",\n\t\t\twant:  \"\\\\u\",\n\t\t},\n\t\t{\n\t\t\tname:  \"Short escape sequence (\\\\u0)\",\n\t\t\tinput: \"\\\\u0\",\n\t\t\twant:  \"\\\\u0\",\n\t\t},\n\t\t{\n\t\t\tname:  \"Short escape sequence (\\\\u00)\",\n\t\t\tinput: \"\\\\u00\",\n\t\t\twant:  \"\\\\u00\",\n\t\t},\n\t\t{\n\t\t\tname:  \"Short escape sequence (\\\\u000)\",\n\t\t\tinput: \"\\\\u000\",\n\t\t\twant:  \"\\\\u000\",\n\t\t},\n\t\t{\n\t\t\tname:  \"Short escape sequence (\\\\u0000)\",\n\t\t\tinput: \"\\\\u0000\",\n\t\t\twant:  \"\\\\u0000\",\n\t\t},\n\t\t{\n\t\t\tname:  \"Short escape sequence (\\\\u00000)\",\n\t\t\tinput: \"\\\\u00000\",\n\t\t\twant:  \"\\\\u00000\",\n\t\t},\n\t\t{\n\t\t\tname:  \"Short escape sequence (\\\\u000000)\",\n\t\t\tinput: \"\\\\u000000\",\n\t\t\twant:  \"\\\\u000000\",\n\t\t},\n\t\t{\n\t\t\tname:  \"Short escape sequence (\\\\u0000000)\",\n\t\t\tinput: \"\\\\u0000000\",\n\t\t\twant:  \"\\\\u0000000\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := unescapeStringBestEffort(tt.input)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %q, want %q\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_InvalidHex(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tinput string\n\t\twant  string\n\t}{\n\t\t{\n\t\t\tname:  \"Invalid hex (\\\\u00x)\",\n\t\t\tinput: \"\\\\u00x\",\n\t\t\twant:  \"\\\\u00x\",\n\t\t},\n\t\t{\n\t\t\tname:  \"Invalid hex (\\\\u000x)\",\n\t\t\tinput: \"\\\\u000x\",\n\t\t\twant:  \"\\\\u000x\",\n\t\t},\n\t\t{\n\t\t\tname:  \"Invalid hex (\\\\u0000x)\",\n\t\t\tinput: \"\\\\u0000x\",\n\t\t\twant:  \"\\\\u0000x\",\n\t\t},\n\t\t{\n\t\t\tname:  \"Invalid hex (\\\\u00000x)\",\n\t\t\tinput: \"\\\\u00000x\",\n\t\t\twant:  \"\\\\u00000x\",\n\t\t},\n\t\t{\n\t\t\tname:  \"Invalid hex (\\\\u000000x)\",\n\t\t\tinput: \"\\\\u000000x\",\n\t\t\twant:  \"\\\\u000000x\",\n\t\t},\n\t\t{\n\t\t\tname:  \"Invalid hex (\\\\u0000000x)\",\n\t\t\tinput: \"\\\\u0000000x\",\n\t\t\twant:  \"\\\\u0000000x\",\n\t\t},\n\t\t{\n\t\t\tname:  \"Invalid hex (\\\\ux)\",\n\t\t\tinput: \"\\\\ux\",\n\t\t\twant:  \"\\\\ux\",\n\t\t},\n\t\t{\n\t\t\tname:  \"Invalid hex (\\\\u0x)\",\n\t\t\tinput: \"\\\\u0x\",\n\t\t\twant:  \"\\\\u0x\",\n\t\t},\n\t\t{\n\t\t\tname:  \"Invalid hex (\\\\u00x)\",\n\t\t\tinput: \"\\\\u00x\",\n\t\t\twant:  \"\\\\u00x\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := unescapeStringBestEffort(tt.input)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %q, want %q\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_InvalidSurrogatePair(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tinput string\n\t\twant  string\n\t}{\n\t\t{\n\t\t\tname:  \"Invalid surrogate pair (missing high surrogate)\",\n\t\t\tinput: \"\\\\uDE01\",\n\t\t\twant:  \"\\\\uDE01\",\n\t\t},\n\t\t{\n\t\t\tname:  \"Invalid surrogate pair (missing low surrogate)\",\n\t\t\tinput: \"\\\\uD83D\",\n\t\t\twant:  \"\\\\uD83D\",\n\t\t},\n\t\t{\n\t\t\tname:  \"Invalid surrogate pair (high surrogate followed by non-surrogate)\",\n\t\t\tinput: \"\\\\uD83D\\\\u0041\",\n\t\t\twant:  \"\\\\uD83D\\\\u0041\",\n\t\t},\n\t\t{\n\t\t\tname:  \"Invalid surrogate pair (low surrogate followed by non-surrogate)\",\n\t\t\tinput: \"\\\\uDE01\\\\u0041\",\n\t\t\twant:  \"\\\\uDE01\\\\u0041\",\n\t\t},\n\t\t{\n\t\t\tname:  \"Invalid surrogate pair (high surrogate followed by invalid low surrogate)\",\n\t\t\tinput: \"\\\\uD83D\\\\uDC00\",\n\t\t\twant:  \"\\\\uD83D\\\\uDC00\",\n\t\t},\n\t\t{\n\t\t\tname:  \"Invalid surrogate pair (low surrogate followed by invalid high surrogate)\",\n\t\t\tinput: \"\\\\uDC00\\\\uD83D\",\n\t\t\twant:  \"\\\\uDC00\\\\uD83D\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := unescapeStringBestEffort(tt.input)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %q, want %q\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_InvalidUnicode(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tinput string\n\t\twant  string\n\t}{\n\t\t{\n\t\t\tname:  \"Invalid unicode (\\\\u1111111)\",\n\t\t\tinput: \"\\\\u1111111\",\n\t\t\twant:  \"\\\\u1111111\",\n\t\t},\n\t\t{\n\t\t\tname:  \"Invalid unicode (\\\\uFFFFFFF)\",\n\t\t\tinput: \"\\\\uFFFFFFF\",\n\t\t\twant:  \"\\\\uFFFFFFF\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := unescapeStringBestEffort(tt.input)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %q, want %q\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_MultipleEscapes(t *testing.T) {\n\tinput := `\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u0020\\u002","6f44ad38d1750d682e4dc5ccc8c22331":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           make([]kv, 0),\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": 2}`,\n\t\t\t\tc:   \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested objects\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": {\"key2\": \"value2\"}, \"key3\": [1, 2, 3]}`,\n\t\t\t\tc:   \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1`,\n\t\t\t\tc:   \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing key\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": }`,\n\t\t\t\tc:   \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": }`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\" \"value1\", \"key2\": 2}`,\n\t\t\t\tc:   \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\", \"key2\": 2}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\" \"key2\": 2}`,\n\t\t\t\tc:   \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": 2}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with invalid key\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": 2, \"key3\": \"value3\"`,\n\t\t\t\tc:   \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": 2, \"key3\": \"value3\"`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_MarshalJSON(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    \"{}\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": 2}`,\n\t\t\t\tc:   \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `{\"key1\":\"value1\",\"key2\":2}`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested objects\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": {\"key2\": \"value2\"}, \"key3\": [1, 2, 3]}`,\n\t\t\t\tc:   \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `{\"key1\":{\"key2\":\"value2\"},\"key3\":[1,2,3]}`,\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdata, err := json.Marshal(got)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif string(data) != tt.want {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", string(data), tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","6f51b309595c1399dbabe55956e4e70a":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escape sequences\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with multiple escape sequences\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"again\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\\\\\\\"again\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\\\\\\\"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: ``,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with leading whitespace\",\n\t\t\targs: args{\n\t\t\t\ts: ` \"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with trailing whitespace\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\" `,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \" \",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with whitespace inside\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello world\"`,\n\t\t\t},\n\t\t\twant:    \"hello world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with leading and trailing whitespace\",\n\t\t\targs: args{\n\t\t\t\ts: ` \"hello world\" `,\n\t\t\t},\n\t\t\twant:    \"hello world\",\n\t\t\twant1:   \" \",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","6fab218b3923aaaeb15f025f2a5a7e40":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\"world\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\\\\\\\"\",\n\t\t\twant1:   \"!\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\"`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"no quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `hello`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes at the end\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","6fd24ebeaee11084b0c385bb63aecac6":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"single element array\",\n\t\t\targs: args{\n\t\t\t\ts:    `[\"test\"]`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"test\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element array\",\n\t\t\targs: args{\n\t\t\t\ts:    `[\"test1\", \"test2\", \"test3\"]`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"test1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"test2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"test3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts:    `[[\"test1\", \"test2\"], \"test3\"]`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"test1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"test2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"test3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid array\",\n\t\t\targs: args{\n\t\t\t\ts:    `[`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    `[\"test1\" \"test2\"]`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `[\"test1\" \"test2\"]`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected end of array\",\n\t\t\targs: args{\n\t\t\t\ts:    `[\"test1`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `[\"test1`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseArray() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","7058efd0c56b597cc2d9223ff1700ad9":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObjectVisit(t *testing.T) {\n\ttype args struct {\n\t\to *Object\n\t\tf func(key []byte, v *Value)\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\ttt.args.o.Visit(tt.args.f)\n\t\t})\n\t}\n}","706865992798e2e97cf456a24af456c3":"package fastjson\n\nimport (\n\t\"testing\"\n\t\"unicode/utf16\"\n\t\"strconv\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\"hello world\\\"\"},\n\t\t\twant: \"\\\"hello world\\\"\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\hello world\"},\n\t\t\twant: \"\\\\hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"/hello world\"},\n\t\t\twant: \"/hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello world\"},\n\t\t\twant: \"\\bhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello world\"},\n\t\t\twant: \"\\fhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello world\"},\n\t\t\twant: \"\\nhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello world\"},\n\t\t\twant: \"\\rhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello world\"},\n\t\t\twant: \"\\thello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061hello world\"},\n\t\t\twant: \"ahello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01hello world\"},\n\t\t\twant: \"😁hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello world\"},\n\t\t\twant: \"\\\\xhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"short escape sequence\",\n\t\t\targs: args{s: \"\\\\uhello world\"},\n\t\t\twant: \"\\\\uhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid second part\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uhello world\"},\n\t\t\twant: \"\\\\uD83D\\\\uhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\uD83D\\\\uDE01hello world\"},\n\t\t\twant: \"\\\"\\\\b\\f\\n\\r\\ta😁hello world\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","706e5a0147669f36804cbc0a3f095f5e":"package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\"hello world\\\"\"},\n\t\t\twant: \"\\\"hello world\\\"\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\hello world\"},\n\t\t\twant: \"\\\\hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"/hello world\"},\n\t\t\twant: \"/hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped b\",\n\t\t\targs: args{s: \"\\\\bhello world\"},\n\t\t\twant: \"\\bhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped f\",\n\t\t\targs: args{s: \"\\\\fhello world\"},\n\t\t\twant: \"\\fhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped n\",\n\t\t\targs: args{s: \"\\\\nhello world\"},\n\t\t\twant: \"\\nhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped r\",\n\t\t\targs: args{s: \"\\\\rhello world\"},\n\t\t\twant: \"\\rhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped t\",\n\t\t\targs: args{s: \"\\\\thello world\"},\n\t\t\twant: \"\\thello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped u with valid unicode\",\n\t\t\targs: args{s: \"\\\\u0061hello world\"},\n\t\t\twant: \"ahello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped u with invalid unicode\",\n\t\t\targs: args{s: \"\\\\u006zhello world\"},\n\t\t\twant: \"\\\\u006zhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped u with surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01hello world\"},\n\t\t\twant: \"😀hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped u with incomplete surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83Dhello world\"},\n\t\t\twant: \"\\\\uD83Dhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped u with invalid surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\u0061hello world\"},\n\t\t\twant: \"\\\\uD83D\\\\u0061hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped u with invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\uhello world\"},\n\t\t\twant: \"\\\\uhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\u0062\\\\uD83D\\\\uDE01hello world\"},\n\t\t\twant: \"\\\"\\\\f\\n\\r\\ta\\u0062😀hello world\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","70a38a44496c23ee87fb465becf29b01":"package fastjson\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\tv   *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"marshal string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeString, s: \"hello\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal number\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t},\n\t\t\twant: []byte(\"123\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal true\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeTrue},\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal false\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeFalse},\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal null\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNull},\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal object\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}}, {k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}}}},\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":\"value1\",\"key2\":123}`),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal array\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeArray, a: []*Value{{t: TypeString, s: \"value1\"}, {t: TypeNumber, s: \"123\"}}},\n\t\t\t},\n\t\t\twant: []byte(`[\"value1\",123]`),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal raw string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: typeRawString, s: \"hello world\"},\n\t\t\t},\n\t\t\twant: []byte(`\"hello world\"`),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.v.MarshalTo(tt.args.dst); !bytes.Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","71635dd415056a10080843df1cfc642f":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no whitespace\",\n\t\t\targs: args{\n\t\t\t\ts: \"abc\",\n\t\t\t},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace\",\n\t\t\targs: args{\n\t\t\t\ts: \"  abc\",\n\t\t\t},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailing whitespace\",\n\t\t\targs: args{\n\t\t\t\ts: \"abc  \",\n\t\t\t},\n\t\t\twant: \"abc  \",\n\t\t},\n\t\t{\n\t\t\tname: \"whitespace in the middle\",\n\t\t\targs: args{\n\t\t\t\ts: \"a bc\",\n\t\t\t},\n\t\t\twant: \"bc\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple whitespace\",\n\t\t\targs: args{\n\t\t\t\ts: \"   a b c  \",\n\t\t\t},\n\t\t\twant: \"a b c  \",\n\t\t},\n\t\t{\n\t\t\tname: \"mixed whitespace\",\n\t\t\targs: args{\n\t\t\t\ts: \" \\t\\r\\n abc \\t\\r\\n\",\n\t\t\t},\n\t\t\twant: \"abc \\t\\r\\n\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","7230092514433d8801df7477caa09618":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantKey string\n\t\twantRem string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"empty string\",\n\t\t\targs:    args{s: \"\"},\n\t\t\twantKey: \"\",\n\t\t\twantRem: \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"missing closing quote\",\n\t\t\targs:    args{s: `\"key`},\n\t\t\twantKey: \"\",\n\t\t\twantRem: \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"simple key\",\n\t\t\targs:    args{s: `\"key\"`},\n\t\t\twantKey: \"key\",\n\t\t\twantRem: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"key with spaces\",\n\t\t\targs:    args{s: `\"key with spaces\"`},\n\t\t\twantKey: \"key with spaces\",\n\t\t\twantRem: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"key with escape sequence\",\n\t\t\targs:    args{s: `\"key\\\\\"with\\\\\"escape\\\\\"sequences\"`},\n\t\t\twantKey: \"key\\\\\\\"with\\\\\\\"escape\\\\\\\"sequences\",\n\t\t\twantRem: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"key with escape sequence and remaining string\",\n\t\t\targs:    args{s: `\"key\\\\\"with\\\\\"escape\\\\\"sequences\" remaining`},\n\t\t\twantKey: \"key\\\\\\\"with\\\\\\\"escape\\\\\\\"sequences\",\n\t\t\twantRem: \" remaining\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotKey, gotRem, err := parseRawKey(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawKey() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotKey != tt.wantKey {\n\t\t\t\tt.Errorf(\"parseRawKey() gotKey = %v, want %v\", gotKey, tt.wantKey)\n\t\t\t}\n\t\t\tif gotRem != tt.wantRem {\n\t\t\t\tt.Errorf(\"parseRawKey() gotRem = %v, want %v\", gotRem, tt.wantRem)\n\t\t\t}\n\t\t})\n\t}\n}","724994c4227fea1f6874c6180fbf74e8":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttype want struct {\n\t\tv   *Value\n\t\ts   string\n\t\terr error\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant want\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs:           nil,\n\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ts: \"\",\n\t\t\t\terr: nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"single key-value pair\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\": \"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ts: \"\",\n\t\t\t\terr: nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"multiple key-value pairs\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ts: \"\",\n\t\t\t\terr: nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"nested objects\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": {\"key2\": \"value2\"}, \"key3\": \"value3\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value3\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ts: \"\",\n\t\t\t\terr: nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ts:   `{\"key1\": \"value1\"`,\n\t\t\t\terr: fmt.Errorf(\"missing '}'\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"missing key\",\n\t\t\targs: args{\n\t\t\t\ts:   `{:\"value1\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ts:   `{:\"value1\"}`,\n\t\t\t\terr: fmt.Errorf(`cannot find opening '\"\" for object key`),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"invalid key\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2: \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2: \"value2\"}`,\n\t\t\t\terr: fmt.Errorf(\"cannot parse object key: cannot parse raw string: invalid escape sequence: \\\\\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\" \"value1\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ts:   `{\"key1\" \"value1\"}`,\n\t\t\t\terr: fmt.Errorf(\"missing ':' after object key\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ts:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\terr: fmt.Errorf(\"missing ',' after object value\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected end of object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\",`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ts:   `{\"key1\": \"value1\",`,\n\t\t\t\terr: fmt.Errorf(\"unexpected end of object\"),\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, got2 := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif !reflect.DeepEqual(got, tt.want.v) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want.v)\n\t\t\t}\n\t\t\tif got1 != tt.want.s {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want.s)\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got2, tt.want.err) {\n\t\t\t\tt.Errorf(\"parseObject() got2 = %v, want %v\", got2, tt.want.err)\n\t\t\t}\n\t\t})\n\t}\n}","728d133d01cc468ecfd0317cc4c69179":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tp := \u0026Parser{}\n\t\t\tgot, err := p.Parse(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Parser.Parse() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Parser.Parse() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","73637f7e1e8efbc7668ced1b35bb1c13":"```go\npackage fastjson\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\tv   *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNull},\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeTrue},\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeFalse},\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeString, s: \"hello\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: typeRawString, s: \"hello\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t},\n\t\t\twant: []byte(\"123\"),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t\t{t: TypeString, s: \"2\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"[1,\\\"2\\\"]\"),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{k: \"a\", v: \u0026Value{t: TypeNumber, s:","73e81573c1097aa5d3bc8873077efe2d":"package fastjson\n\nimport (\n\t\"testing\"\n\t\"unicode/utf16\"\n\t\"strconv\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello world\\\\\\\"\"},\n\t\t\twant: \"\\\"hello world\\\"\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello world\\\\\\\\\"},\n\t\t\twant: \"\\\\hello world\\\\\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello world\\\\/\"},\n\t\t\twant: \"/hello world/\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes and quotes\",\n\t\t\targs: args{s: \"\\\\\\\"\\\\/hello world\\\\/\\\\\\\"\"},\n\t\t\twant: \"\\\"\\\\/hello world\\\\/\\\"\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped control characters\",\n\t\t\targs: args{s: \"\\\\b\\\\f\\\\n\\\\r\\\\t\"},\n\t\t\twant: \"\\b\\f\\n\\r\\t\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode characters\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064\"},\n\t\t\twant: \"abcd\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE03\"},\n\t\t\twant: \"😊\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode character\",\n\t\t\targs: args{s: \"\\\\u0000\"},\n\t\t\twant: \"\\\\u0000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\u0000\"},\n\t\t\twant: \"\\\\uD83D\\\\u0000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped incomplete unicode character\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped incomplete surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE03\\\\u\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE03\\\\u\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unknown escape sequence\",\n\t\t\targs: args{s: \"\\\\x\"},\n\t\t\twant: \"\\\\x\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","73e9cfe5e08926c7976321a2a9cd9a45":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{\\\"a\\\": 1}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"{\\\"a\\\": 1}\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{\\\"a\\\": 1}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"a\", v: \u0026Value{t: TypeNumber, s: \"1\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[1, 2, 3]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"hello\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   \"true\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueTrue,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   \"false\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueFalse,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   \"null\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueNull,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   \"123\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   \"NaN\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !compareValue(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseValue() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValue(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k || !compareValue(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !compareValue(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeString, TypeNumber, typeRawString:\n\t\treturn v1.s == v2.s\n\tcase TypeTrue, TypeFalse, TypeNull:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}","7401629604b0f70bcbc19d96baaedff5":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character\",\n\t\t\targs: args{s: \"\\\\u0061hello\\\\u0062 world\"},\n\t\t\twant: \"ahello b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01hello world\"},\n\t\t\twant: \"😁hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello world\"},\n\t\t\twant: \"\\\\xhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u006hello world\"},\n\t\t\twant: \"\\\\u006hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\\\\\ \\\\/this\\\\/ \\\\bthat\\\\b \\\\fthis\\\\f \\\\nthat\\\\n \\\\rthis\\\\r \\\\tthat\\\\t \\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"\\\"hello\\\" \\\\world\\\\ /this/ \\bthat\\b \\fthis\\f \\nthat\\n \\rthis\\r \\tthat\\t abc\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","74d7cae76125b8d48ca978cf0f627552":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no whitespace\",\n\t\t\targs: args{s: \"abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace\",\n\t\t\targs: args{s: \"  abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailing whitespace\",\n\t\t\targs: args{s: \"abc  \"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading and trailing whitespace\",\n\t\t\targs: args{s: \"  abc  \"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"whitespace in the middle\",\n\t\t\targs: args{s: \"a bc\"},\n\t\t\twant: \"bc\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple whitespace\",\n\t\t\targs: args{s: \"  a  b  c  \"},\n\t\t\twant: \"a  b  c\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading newline\",\n\t\t\targs: args{s: \"\\n abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailing newline\",\n\t\t\targs: args{s: \"abc \\n\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading tab\",\n\t\t\targs: args{s: \"\\t abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailing tab\",\n\t\t\targs: args{s: \"abc \\t\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading carriage return\",\n\t\t\targs: args{s: \"\\r abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailing carriage return\",\n\t\t\targs: args{s: \"abc \\r\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"all whitespace\",\n\t\t\targs: args{s: \"  \\n \\t \\r  \"},\n\t\t\twant: \"\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","753a7a1e99cdb1733921791f2452aeb5":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with one element\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[\\\"foo\\\"]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt:  TypeString,\n\t\t\t\t\t\ts: \"foo\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[\\\"foo\\\", \\\"bar\\\", 1, 2.0]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt:  TypeString,\n\t\t\t\t\t\ts: \"foo\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt:  TypeString,\n\t\t\t\t\t\ts: \"bar\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt:  TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt:  TypeNumber,\n\t\t\t\t\t\ts: \"2.0\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with nested array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[\\\"foo\\\", [\\\"bar\\\", 1], 2.0]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt:  TypeString,\n\t\t\t\t\t\ts: \"foo\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt:  TypeString,\n\t\t\t\t\t\t\t\ts: \"bar\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt:  TypeNumber,\n\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt:  TypeNumber,\n\t\t\t\t\t\ts: \"2.0\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[1, 2\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1, 2\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing comma after element\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[1 2]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1 2]\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseArray() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","75777daeca0c7bd8df52b21d1b780eff":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\tv   *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"Marshal Null\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNull},\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal True\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeTrue},\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal False\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeFalse},\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal String\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeString, s: \"hello\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal RawString\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: typeRawString, s: \"hello\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal Number\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t},\n\t\t\twant: []byte(\"123\"),\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal Array\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeString, s: \"hello\"}}},\n\t\t\t},\n\t\t\twant: []byte(\"[1,\\\"hello\\\"]\"),\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal Object\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{t: TypeString, s: \"value\"}}}}},\n\t\t\t},\n\t\t\twant: []byte(`{\"key\":\"value\"}`),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.v.MarshalTo(tt.args.dst); !bytesEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc bytesEqual(a, b []byte) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","7687ecf07cfcfde6c5776872c4fb9d33":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttype want struct {\n\t\tv   *Value\n\t\ttail string\n\t\terr  error\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant want\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  fmt.Errorf(\"cannot parse empty string\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"{}\",\n\t\t\t\terr:  fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{ \\\"key\\\": \\\"value\\\" }\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[ \\\"value1\\\", \\\"value2\\\" ]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\\\"value\\\"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeString,\n\t\t\t\t\ts: \"value\",\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   \"true\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueTrue,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   \"false\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueFalse,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   \"null\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueNull,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   \"123\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"123\",\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   \"NaN\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"NaN\",\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotV, gotTail, gotErr := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (gotErr == nil) != (tt.want.err == nil) {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", gotErr, tt.want.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotErr != nil \u0026\u0026 tt.want.err != nil {\n\t\t\t\tif gotErr.Error() != tt.want.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", gotErr, tt.want.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(gotV, tt.want.v) {\n\t\t\t\tt.Errorf(\"parseValue() gotV = %v, want %v\", gotV, tt.want.v)\n\t\t\t}\n\t\t\tif gotTail != tt.want.tail {\n\t\t\t\tt.Errorf(\"parseValue() gotTail = %v, want %v\", gotTail, tt.want.tail)\n\t\t\t}\n\t\t})\n\t}\n}","76c88dee15d18184fd5aae3fde728d6e":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"simple string\",\n\t\t\targs:    args{s: \"\\\"hello\\\"\"},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"escaped quote\",\n\t\t\targs:    args{s: \"\\\"hello\\\\\\\\\\\"\"},\n\t\t\twant:    \"hello\\\\\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"escaped quote with other content\",\n\t\t\targs:    args{s: \"\\\"hello\\\\\\\"world\\\\\\\"\"},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"missing closing quote\",\n\t\t\targs:    args{s: \"\\\"hello\"},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"empty string\",\n\t\t\targs:    args{s: \"\"},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"no quotes\",\n\t\t\targs:    args{s: \"hello\"},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"multiple quotes\",\n\t\t\targs:    args{s: \"\\\"hello\\\"\\\"world\\\"\"},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\\\"world\\\"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"escaped quote with multiple quotes\",\n\t\t\targs:    args{s: \"\\\"hello\\\\\\\"world\\\"\\\"\"},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","76f5fd995e906a4073d48604a7268b3e":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttype want struct {\n\t\tv   *Value\n\t\ttail string\n\t\terr  error\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant want\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  fmt.Errorf(\"cannot parse empty string\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{\\\"a\\\": 1}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"{\\\"a\\\": 1}\",\n\t\t\t\terr:  fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{\\\"a\\\": 1}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"a\",\n\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[1, 2, 3]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\\\"hello\\\"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: typeRawString,\n\t\t\t\t\ts: \"hello\",\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   \"true\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueTrue,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   \"false\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueFalse,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   \"null\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueNull,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   \"123\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"123\",\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\ts:   \"NaN\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"NaN\",\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected value\",\n\t\t\targs: args{\n\t\t\t\ts:   \"abc\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"abc\",\n\t\t\t\terr:  fmt.Errorf(\"unexpected value found: %q\", \"abc\"),\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotV, gotTail, gotErr := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif gotErr != nil {\n\t\t\t\tif tt.want.err == nil {\n\t\t\t\t\tt.Errorf(\"parseValue() error = %v, want nil\", gotErr)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif gotErr.Error() != tt.want.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue() error = %v, want %v\", gotErr, tt.want.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif tt.want.err != nil {\n\t\t\t\t\tt.Errorf(\"parseValue() error = nil, want %v\", tt.want.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(gotV, tt.want.v) {\n\t\t\t\tt.Errorf(\"parseValue() gotV = %v, want %v\", gotV, tt.want.v)\n\t\t\t}\n\t\t\tif gotTail != tt.want.tail {\n\t\t\t\tt.Errorf(\"parseValue() gotTail = %v, want %v\", gotTail, tt.want.tail)\n\t\t\t}\n\t\t})\n\t}\n}","77bce0e6590e4b18937b930f84c13ca1":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello\\\"\",\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"\\\\\\\"hello\\\\\\\"\\\"\",\n\t\t\t},\n\t\t\twant:    \"\\\"hello\\\"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello\\\\\\\"world\\\"\",\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello\\\\\\\"world\\\\\\\"\\\\\\\"\\\"\",\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"\\\"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped backslash\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello\\\\\\\\world\\\"\",\n\t\t\t},\n\t\t\twant:    \"hello\\\\world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello\",\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"no quotes\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","782108c696836cbdae2916bc481df792":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantV  *Value\n\t\twantS  string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"Empty Array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[]\",\n\t\t\t\tc:   \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{t: TypeArray, a: []*Value{}},\n\t\t\twantS: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Simple Array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[1,2,3]\",\n\t\t\t\tc:   \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t}},\n\t\t\twantS: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Nested Array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[[1,2],[3,4]]\",\n\t\t\t\tc:   \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeArray, a: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t}},\n\t\t\t\t{t: TypeArray, a: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t\t{t: TypeNumber, s: \"4\"},\n\t\t\t\t}},\n\t\t\t}},\n\t\t\twantS: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Array with String\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"hello\", \"world\"]`,\n\t\t\t\tc:   \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeString, s: \"hello\"},\n\t\t\t\t{t: TypeString, s: \"world\"},\n\t\t\t}},\n\t\t\twantS: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Array with Object\",\n\t\t\targs: args{\n\t\t\t\ts:   `[{\"key1\": \"value1\"}, {\"key2\": \"value2\"}]`,\n\t\t\t\tc:   \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeObject, o: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\t\t{t: TypeObject, o: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}},\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\t}},\n\t\t\twantS: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Invalid Array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[1,2,3\",\n\t\t\t\tc:   \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV:  nil,\n\t\t\twantS:  \"[1,2,3\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Missing Comma\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[1 2,3]\",\n\t\t\t\tc:   \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV:  nil,\n\t\t\twantS:  \"[1 2,3]\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotV, gotS, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(gotV, tt.wantV) {\n\t\t\t\tt.Errorf(\"parseArray() gotV = %v, want %v\", gotV, tt.wantV)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseArray() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}","786947ac52c4718b1416b399695b5978":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1  string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[]\",\n\t\t\t\tc:   \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\twant1:  \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with one element\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"hello\"]`,\n\t\t\t\tc:   \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt:  TypeString,\n\t\t\t\t\t\ts: \"hello\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:  \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"hello\", \"world\", 123, true]`,\n\t\t\t\tc:   \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt:  TypeString,\n\t\t\t\t\t\ts: \"hello\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt:  TypeString,\n\t\t\t\t\t\ts: \"world\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt:  TypeNumber,\n\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:  \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with nested arrays\",\n\t\t\targs: args{\n\t\t\t\ts:   `[[\"hello\", \"world\"], [123, true]]`,\n\t\t\t\tc:   \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt:  TypeString,\n\t\t\t\t\t\t\t\ts: \"hello\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt:  TypeString,\n\t\t\t\t\t\t\t\ts: \"world\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt:  TypeNumber,\n\t\t\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:  \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:   `[1, 2, 3`,\n\t\t\t\tc:   \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:  `[1, 2, 3`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"array with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:   `[1 2, 3]`,\n\t\t\t\tc:   \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:  `[1 2, 3]`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseArray() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","798be09ae942c932c643af314a791107":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE03\"},\n\t\t\twant: \"😄\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"short escape sequence\",\n\t\t\targs: args{s: \"\\\\uhello world\"},\n\t\t\twant: \"\\\\uhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE03\\\\u0061\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE03a\",\n\t\t},\n\t\t{\n\t\t\tname: \"mixed escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\/ \\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\u0062\\\\u0063\\\\uD83D\\\\uDE03\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\"hello\\\" \\\\world/ \\b\\f\\n\\r\\tabc😄\\\\xhello\\\\x world\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","79d8078e796dcbcc4dd823f358ec52aa":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"single element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,3]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with nested array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[[1,2],[3,4]]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"4\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `[{\"a\":1},{\"b\":2}]`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tk: \"a\",\n\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tk: \"b\",\n\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with invalid value\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \",\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"array with missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1,2\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseArray() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","7a92821e0adc82cb85ceea8247358d8a":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with single key-value pair\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\": \"value\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with multiple key-value pairs\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\", \"key3\": \"value3\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested objects\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nested_key1\": \"nested_value1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nested_key1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nested_value1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with invalid key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{key: \"value\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"key: \",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with invalid value\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\": value}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"value\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"value2\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with extra comma\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\", }`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n","7ae139e99d6004412db527f5cec86730":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantKey string\n\t\twantTail string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"empty\",\n\t\t\targs:    args{s: \"\"},\n\t\t\twantKey: \"\",\n\t\t\twantTail: \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"single_quote\",\n\t\t\targs:    args{s: \"'key'\"},\n\t\t\twantKey: \"\",\n\t\t\twantTail: \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"simple_key\",\n\t\t\targs:    args{s: \"\\\"key\\\"\"},\n\t\t\twantKey: \"key\",\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"escaped_key\",\n\t\t\targs:    args{s: \"\\\"key\\\\\\\"escaped\\\"\"},\n\t\t\twantKey: \"key\\\"escaped\",\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"key_with_tail\",\n\t\t\targs:    args{s: \"\\\"key\\\"tail\"},\n\t\t\twantKey: \"key\",\n\t\t\twantTail: \"tail\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"missing_closing_quote\",\n\t\t\targs:    args{s: \"\\\"key\"},\n\t\t\twantKey: \"\",\n\t\t\twantTail: \"\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotKey, gotTail, err := parseRawKey(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawKey() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotKey != tt.wantKey {\n\t\t\t\tt.Errorf(\"parseRawKey() gotKey = %v, want %v\", gotKey, tt.wantKey)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseRawKey() gotTail = %v, want %v\", gotTail, tt.wantTail)\n\t\t\t}\n\t\t})\n\t}\n}","7b0eb03b9c3c5c2a59058e32333f3f39":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantKey string\n\t\twantTail string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"simple key\",\n\t\t\targs:    args{s: `\"key\"`},\n\t\t\twantKey: \"key\",\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"key with spaces\",\n\t\t\targs:    args{s: `\"key with spaces\"`},\n\t\t\twantKey: \"key with spaces\",\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"key with special characters\",\n\t\t\targs:    args{s: `\"key\\twith\\nspecial\\rcharacters\"`},\n\t\t\twantKey: \"key\\twith\\nspecial\\rcharacters\",\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"key with escape sequence\",\n\t\t\targs:    args{s: `\"key\\\\\"with\\\\\"escape\\\\\"sequence\"`},\n\t\t\twantKey: \"key\\\\\\\"with\\\\\\\"escape\\\\\\\"sequence\",\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"missing closing quote\",\n\t\t\targs:    args{s: `\"key`},\n\t\t\twantKey: \"\",\n\t\t\twantTail: \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"empty key\",\n\t\t\targs:    args{s: `\"\"`},\n\t\t\twantKey: \"\",\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"key with leading and trailing spaces\",\n\t\t\targs:    args{s: `\"  key  \"`},\n\t\t\twantKey: \"  key  \",\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotKey, gotTail, err := parseRawKey(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawKey() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotKey != tt.wantKey {\n\t\t\t\tt.Errorf(\"parseRawKey() gotKey = %v, want %v\", gotKey, tt.wantKey)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseRawKey() gotTail = %v, want %v\", gotTail, tt.wantTail)\n\t\t\t}\n\t\t})\n\t}\n}","7be990ce79cb1a8b124a128d9ab3387a":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"Simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"simple\"`,\n\t\t\t},\n\t\t\twant:    \"simple\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"escaped\\\\\"quotes\"`,\n\t\t\t},\n\t\t\twant:    \"escaped\\\"quotes\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"multiple\\\\\\\\\"escaped\\\\\"quotes\"`,\n\t\t\t},\n\t\t\twant:    \"multiple\\\\\\\"escaped\\\"quotes\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"missing closing quote`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Empty string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\"`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"No quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `no quotes`,\n\t\t\t},\n\t\t\twant:    \"no quotes\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","7c09caf0ea87aa843bac1becd45191fc":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttype want struct {\n\t\tv   *Value\n\t\ttail string\n\t\terr  error\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant want\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  fmt.Errorf(\"cannot parse empty string\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"{}\",\n\t\t\t\terr:  fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{ \\\"key\\\": \\\"value\\\" }\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t\t\tt: typeRawString,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[1, 2, 3]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\\\"hello world\\\"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\ts: \"hello world\",\n\t\t\t\t\tt: typeRawString,\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   \"true\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueTrue,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   \"false\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueFalse,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   \"null\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueNull,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   \"123\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\ts: \"123\",\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\ts:   \"NaN\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\ts: \"NaN\",\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotV, gotTail, gotErr := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif gotErr != nil {\n\t\t\t\tif tt.want.err == nil {\n\t\t\t\t\tt.Errorf(\"parseValue() error = %v, want nil\", gotErr)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif gotErr.Error() != tt.want.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue() error = %v, want %v\", gotErr, tt.want.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else if tt.want.err != nil {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, want %v\", gotErr, tt.want.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(gotV, tt.want.v) {\n\t\t\t\tt.Errorf(\"parseValue() gotV = %v, want %v\", gotV, tt.want.v)\n\t\t\t}\n\t\t\tif gotTail != tt.want.tail {\n\t\t\t\tt.Errorf(\"parseValue() gotTail = %v, want %v\", gotTail, tt.want.tail)\n\t\t\t}\n\t\t})\n\t}\n}","7ca549d288828fbe5328bbd86e0db62a":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"Simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"String with escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"String with multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\"world\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"\",\n\t\t\twant1:   \"!\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"String with escaped backslashes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\\world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"String with escaped backslashes and quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\\\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Empty string\",\n\t\t\targs: args{\n\t\t\t\ts: ``,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"No quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `hello`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Quotes at the beginning and end\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\"`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Quotes in the middle\",\n\t\t\targs: args{\n\t\t\t\ts: `hello\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"world\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Escaped quote at the beginning\",\n\t\t\targs: args{\n\t\t\t\ts: `\\\\\"hello\"`,\n\t\t\t},\n\t\t\twant:    `\\\"hello`,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Escaped quote at the end\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Escaped quote in the middle\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"\",\n\t\t\twant1:   \"!\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","7dad3b1c46ec53aac2f667a5953c1862":"package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"😀\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x world\"},\n\t\t\twant: \"\\\\xhello\\\\x world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u006\"},\n\t\t\twant: \"\\\\u006\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex\",\n\t\t\targs: args{s: \"\\\\u00zz\"},\n\t\t\twant: \"\\\\u00zz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate with invalid hex\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDEzz\"},\n\t\t\twant: \"\\\\uD83D\\\\uDEzz\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","7db1f88e3c96395375451e83de16c5b6":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"valid integer\",\n\t\t\targs:    args{s: \"123\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"valid float\",\n\t\t\targs:    args{s: \"123.456\"},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"valid negative integer\",\n\t\t\targs:    args{s: \"-123\"},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"valid negative float\",\n\t\t\targs:    args{s: \"-123.456\"},\n\t\t\twantNs:  \"-123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"valid exponential\",\n\t\t\targs:    args{s: \"123e4\"},\n\t\t\twantNs:  \"123e4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"valid exponential with sign\",\n\t\t\targs:    args{s: \"123e+4\"},\n\t\t\twantNs:  \"123e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"valid exponential with negative sign\",\n\t\t\targs:    args{s: \"123e-4\"},\n\t\t\twantNs:  \"123e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"inf\",\n\t\t\targs:    args{s: \"inf\"},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"Inf\",\n\t\t\targs:    args{s: \"Inf\"},\n\t\t\twantNs:  \"Inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"NaN\",\n\t\t\targs:    args{s: \"NaN\"},\n\t\t\twantNs:  \"NaN\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"nan\",\n\t\t\targs:    args{s: \"nan\"},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number\",\n\t\t\targs:    args{s: \"123a\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading minus\",\n\t\t\targs:    args{s: \"-a\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"-a\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading plus\",\n\t\t\targs:    args{s: \"+a\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+a\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"empty string\",\n\t\t\targs:    args{s: \"\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}","7dcd4b2020590e522e3b8a940cc501f3":"package fastjson\n\nimport \"testing\"\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no leading whitespace\",\n\t\t\targs: args{s: \"abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading space\",\n\t\t\targs: args{s: \" abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading newline\",\n\t\t\targs: args{s: \"\\nabc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading tab\",\n\t\t\targs: args{s: \"\\tabc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading carriage return\",\n\t\t\targs: args{s: \"\\rabc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace and trailing whitespace\",\n\t\t\targs: args{s: \" \\tabc\\n \"},\n\t\t\twant: \"abc\\n \",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace and no trailing whitespace\",\n\t\t\targs: args{s: \" \\tabc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace and trailing whitespace\",\n\t\t\targs: args{s: \"\\t abc \\n\"},\n\t\t\twant: \"abc \\n\",\n\t\t},\n\t\t{\n\t\t\tname: \"all whitespace\",\n\t\t\targs: args{s: \" \\t\\n\\r \"},\n\t\t\twant: \"\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","7dd7034a21a9529c961f608a308225ae":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t\t{\n\t\t\tname: \"Empty object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Simple object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Nested object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": {\"key2\": \"value2\"}, \"key3\": \"value3\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\"`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\" \"value1\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Invalid key\",\n\t\t\targs: args{\n\t\t\t\ts:   `{key1: \"value1\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{key1: \"value1\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","7e8e562ef2d27c182d546cf4c9a07086":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetArray(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant []*Value\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.GetArray(tt.args.keys...); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"GetArray() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","7f4ba0b171c71cd762dba9c2e617f4ff":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetUint(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant uint\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.GetUint(tt.args.keys...); got != tt.want {\n\t\t\t\tt.Errorf(\"Value.GetUint() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","7f60f1b39103ded7daa1b75a4ee76a2d":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdep int\n\t}\n\ttype want struct {\n\t\tv   *Value\n\t\ttail string\n\t\terr  error\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant want\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdep: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  fmt.Errorf(\"cannot parse empty string\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdep: MaxDepth,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"{}\",\n\t\t\t\terr:  fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdep: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{t: TypeObject, o: Object{}},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdep: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{t: TypeArray, a: []*Value{}},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"hello\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdep: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{t: typeRawString, s: \"hello\"},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   \"true\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdep: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueTrue,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   \"false\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdep: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueFalse,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   \"null\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdep: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueNull,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   \"123\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdep: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"number with exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   \"1.23e+4\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdep: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"1.23e+4\"},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   \"1.23e-4\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdep: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"1.23e-4\"},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"number with decimal\",\n\t\t\targs: args{\n\t\t\t\ts:   \"1.23\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdep: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"1.23\"},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zero\",\n\t\t\targs: args{\n\t\t\t\ts:   \"0123\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdep: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"0123\"},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"number with trailing zero\",\n\t\t\targs: args{\n\t\t\t\ts:   \"1230\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdep: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"1230\"},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading plus sign\",\n\t\t\targs: args{\n\t\t\t\ts:   \"+123\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdep: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"+123\"},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading minus sign\",\n\t\t\targs: args{\n\t\t\t\ts:   \"-123\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdep: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"-123\"},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"number with NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   \"NaN\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdep: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"NaN\"},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotV, gotTail, gotErr := parseValue(tt.args.s, tt.args.c, tt.args.dep)\n\t\t\tif gotErr == nil \u0026\u0026 tt.want.err != nil {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", gotErr, tt.want.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotErr != nil \u0026\u0026 tt.want.err == nil {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", gotErr, tt.want.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotErr != nil \u0026\u0026 tt.want.err != nil {\n\t\t\t\tif gotErr.Error() != tt.want.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", gotErr, tt.want.err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(gotV, tt.want.v) {\n\t\t\t\tt.Errorf(\"parseValue() gotV = %v, want %v\", gotV, tt.want.v)\n\t\t\t}\n\t\t\tif gotTail != tt.want.tail {\n\t\t\t\tt.Errorf(\"parseValue() gotTail = %v, want %v\", gotTail, tt.want.tail)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseValue_Nested(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdep int\n\t}\n\ttype want struct {\n\t\tv   *Value\n\t\ttail string\n\t\terr  error\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant want\n\t}{\n\t\t{\n\t\t\tname: \"nested object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"a\": {\"b\": 1}}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdep: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"a\", v: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"b\", v: \u0026Value{t: TypeNumber, s: \"1\"}}}}}}}}},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"a\": [1, 2]}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdep: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"a\", v: \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}}}}}}},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotV, gotTail, gotErr := parseValue(tt.args.s, tt.args.c, tt.args.dep)\n\t\t\tif gotErr == nil \u0026\u0026 tt.want.err != nil {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", gotErr, tt.want.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotErr != nil \u0026\u0026 tt.want.err == nil {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", gotErr, tt.want.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotErr != nil \u0026\u0026 tt.want.err != nil {\n\t\t\t\tif gotErr.Error() != tt.want.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", gotErr, tt.want.err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(gotV, tt.want.v) {\n\t\t\t\tt.Errorf(\"parseValue() gotV = %v, want %v\", gotV, tt.want.v)\n\t\t\t}\n\t\t\tif gotTail != tt.want.tail {\n\t\t\t\tt.Errorf(\"parseValue() gotTail = %v, want %v\", gotTail, tt.want.tail)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseValue_Invalid(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdep int\n\t}\n\ttype want struct {\n\t\tv   *Value\n\t\ttail string\n\t\terr  error\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant want\n\t}{\n\t\t{\n\t\t\tname: \"invalid object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdep: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"{\",\n\t\t\t\terr:  fmt.Errorf(\"cannot parse object: unexpected end of JSON input\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"invalid array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdep: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"[\",\n\t\t\t\terr:  fmt.Errorf(\"cannot parse array: unexpected end of JSON input\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"invalid string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdep: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: `\"`,\n\t\t\t\terr:  fmt.Errorf(\"cannot parse string: unexpected end of JSON input\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"invalid true\",\n\t\t\targs: args{\n\t\t\t\ts:   \"tru\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdep: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"tru\",\n\t\t\t\terr:  fmt.Errorf(\"unexpected value found: \\\"tru\\\"\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"invalid false\",\n\t\t\targs: args{\n\t\t\t\ts:   \"fals\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdep: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"fals\",\n\t\t\t\terr:  fmt.Errorf(\"unexpected value found: \\\"fals\\\"\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"invalid null\",\n\t\t\targs: args{\n\t\t\t\ts:   \"nul\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdep: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"nul\",\n\t\t\t\terr:  fmt.Errorf(\"unexpected value found: \\\"nul\\\"\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number\",\n\t\t\targs: args{\n\t\t\t\ts:   \"123a\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdep: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"123a\",\n\t\t\t\terr:  fmt.Errorf(\"cannot parse raw number: unexpected character\"),\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotV, gotTail, gotErr := parseValue(tt.args.s, tt.args.c, tt.args.dep)\n\t\t\tif gotErr == nil \u0026\u0026 tt.want.err != nil {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", gotErr, tt.want.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotErr != nil \u0026\u0026 tt.want.err == nil {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", gotErr, tt.want.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotErr != nil \u0026\u0026 tt.want.err != nil {\n\t\t\t\tif gotErr.Error() != tt.want.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", gotErr, tt.want.err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(gotV, tt.want.v) {\n\t\t\t\tt.Errorf(\"parseValue() gotV = %v, want %v\", gotV, tt.want.v)\n\t\t\t}\n\t\t\tif gotTail != tt.want.tail {\n\t\t\t\tt.Errorf(\"parseValue() gotTail = %v, want %v\", gotTail, tt.want.tail)\n\t\t\t}\n\t\t})\n\t}\n}","807d013abe86474680c99a8397c44ef9":"```go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueGet(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n","80eb4c1412d255ee46292aae604c32df":"```go\npackage fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"empty string\",\n\t\t\targs:    args{s: \"\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"single digit\",\n\t\t\targs:    args{s: \"1\"},\n\t\t\twantNs:  \"1\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"multiple digits\",\n\t\t\targs:    args{s: \"123\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"negative number\",\n\t\t\targs:    args{s: \"-123\"},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"decimal number\",\n\t\t\targs:    args{s: \"123.456\"},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"exponential number\",\n\t\t\targs:    args{s: \"1.23e+456\"},\n\t\t\twantNs:  \"1.23e+456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"exponential number with lowercase e\",\n\t\t\targs:    args{s: \"1.23e-456\"},\n\t\t\twant","813b6cc65bfab253187227574002ee26":"```go\npackage fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n)\n\nfunc TestValueGet(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttype want struct {\n\t\twant *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant want\n\t}{\n\t\t// TODO: Add test","8177a350d4c4cce2597cc004623711f5":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escaped string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: ``,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with no quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `hello`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","829f3bee55cc6c18e8df104328bf5e2b":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"\",\n\t\t\twant1:   \"!\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: ``,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"no quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `hello`,\n\t\t\t},\n\t\t\twant:    `hello`,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","8357f5d24e1cdb9aefc22a135c1b9466":"package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello world\"},\n\t\t\twant: \"\\\\hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello world\"},\n\t\t\twant: \"/hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello world\"},\n\t\t\twant: \"\\bhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello world\"},\n\t\t\twant: \"\\fhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello world\"},\n\t\t\twant: \"\\nhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello world\"},\n\t\t\twant: \"\\rhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello world\"},\n\t\t\twant: \"\\thello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061hello world\"},\n\t\t\twant: \"ahello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01hello world\"},\n\t\t\twant: \"😁hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello world\"},\n\t\t\twant: \"\\\\xhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u006hello world\"},\n\t\t\twant: \"\\\\u006hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\n\\\\u0061\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"\\\"hello\\\" \\\\world\\na😁\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","846b5a8936b60cdcefab9152a8a78e08":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"empty string\",\n\t\t\targs:    args{s: \"\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"single digit\",\n\t\t\targs:    args{s: \"1\"},\n\t\t\twantNs:  \"1\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"multiple digits\",\n\t\t\targs:    args{s: \"123\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"decimal number\",\n\t\t\targs:    args{s: \"1.23\"},\n\t\t\twantNs:  \"1.23\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"negative number\",\n\t\t\targs:    args{s: \"-123\"},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"exponent number\",\n\t\t\targs:    args{s: \"1.23e+4\"},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"exponent number with minus sign\",\n\t\t\targs:    args{s: \"1.23e-4\"},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"inf\",\n\t\t\targs:    args{s: \"inf\"},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"inf with space\",\n\t\t\targs:    args{s: \" inf\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" inf\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"inf with extra chars\",\n\t\t\targs:    args{s: \"infx\"},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"x\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"nan\",\n\t\t\targs:    args{s: \"nan\"},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"nan with space\",\n\t\t\targs:    args{s: \" nan\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" nan\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"nan with extra chars\",\n\t\t\targs:    args{s: \"nanx\"},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"x\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"unexpected char\",\n\t\t\targs:    args{s: \"1a\"},\n\t\t\twantNs:  \"1\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"unexpected char at start\",\n\t\t\targs:    args{s: \"a1\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"a1\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"unexpected char with inf\",\n\t\t\targs:    args{s: \"infx\"},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"x\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"unexpected char with nan\",\n\t\t\targs:    args{s: \"nanx\"},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"x\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}","85860e752a54f3e60b619400d8ea0e22":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"simple number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative number\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with decimal\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with exponent\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with exponent and sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e-4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zero\",\n\t\t\targs: args{\n\t\t\t\ts: \"0123\",\n\t\t\t},\n\t\t\twantNs:  \"0123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading plus sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading minus sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with trailing whitespace\",\n\t\t\targs: args{\n\t\t\t\ts: \"123 \",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \" \",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading whitespace\",\n\t\t\targs: args{\n\t\t\t\ts: \" 123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" 123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number with whitespace in the middle\",\n\t\t\targs: args{\n\t\t\t\ts: \"123 456\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \" 456\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"inf\",\n\t\t\t},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with INF\",\n\t\t\targs: args{\n\t\t\t\ts: \"INF\",\n\t\t\t},\n\t\t\twantNs:  \"INF\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"nan\",\n\t\t\t},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with NAN\",\n\t\t\targs: args{\n\t\t\t\ts: \"NAN\",\n\t\t\t},\n\t\t\twantNs:  \"NAN\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid char\",\n\t\t\targs: args{\n\t\t\t\ts: \"123a\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid char at the beginning\",\n\t\t\targs: args{\n\t\t\t\ts: \"a123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"a123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid char at the beginning 2\",\n\t\t\targs: args{\n\t\t\t\ts: \" 123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" 123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid char at the beginning 3\",\n\t\t\targs: args{\n\t\t\t\ts: \"  123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"  123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid char at the beginning 4\",\n\t\t\targs: args{\n\t\t\t\ts: \"a123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"a123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid char at the beginning 5\",\n\t\t\targs: args{\n\t\t\t\ts: \"  123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"  123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid char at the beginning 6\",\n\t\t\targs: args{\n\t\t\t\ts: \"123+\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}","867153df9b6a69ea618b77a3fc27945c":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"float number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"scientific notation\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative scientific notation\",\n\t\t\targs: args{\n\t\t\t\ts: \"-1.23e-4\",\n\t\t\t},\n\t\t\twantNs:  \"-1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"inf\",\n\t\t\t},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"Inf\",\n\t\t\t},\n\t\t\twantNs:  \"Inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inF\",\n\t\t\targs: args{\n\t\t\t\ts: \"inF\",\n\t\t\t},\n\t\t\twantNs:  \"inF\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twantNs:  \"NaN\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"nan\",\n\t\t\t},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nAn\",\n\t\t\targs: args{\n\t\t\t\ts: \"nAn\",\n\t\t\t},\n\t\t\twantNs:  \"nAn\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123a\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"123inf\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"inf\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"123nan\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"nan\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"leading plus\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"leading minus\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"leading plus with inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"leading minus with inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"-inf\",\n\t\t\t},\n\t\t\twantNs:  \"-inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"leading plus with nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"+nan\",\n\t\t\t},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"leading minus with nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"-nan\",\n\t\t\t},\n\t\t\twantNs:  \"-nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}","8717eb40e7c5b1502a86c46aec6f0a2f":"package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061hello\\\\u0062 world\"},\n\t\t\twant: \"ahello b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDC0Ahello\\\\uD83D\\\\uDC08 world\"},\n\t\t\twant: \"👋hello👍 world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid unicode\",\n\t\t\targs: args{s: \"\\\\u0061hello\\\\uxyz world\"},\n\t\t\twant: \"\\\\u0061hello\\\\uxyz world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped short unicode\",\n\t\t\targs: args{s: \"\\\\u0061hello\\\\u world\"},\n\t\t\twant: \"\\\\u0061hello\\\\u world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid tail\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDC0Ahello\\\\uD83D\\\\u world\"},\n\t\t\twant: \"\\\\uD83D\\\\uDC0Ahello\\\\uD83D\\\\u world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped invalid surrogate pair\",\n\t\t\targs: args{s: \"\\\\u0061hello\\\\uD83D\\\\uDC0A world\"},\n\t\t\twant: \"\\\\u0061hello\\\\uD83D\\\\uDC0A world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unknown sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\ world\"},\n\t\t\twant: \"\\\\xhello\\\\ world\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","871e93cc734c52c098de30486d1c84ef":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetFloat64(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.GetFloat64(tt.args.keys...); got != tt.want {\n\t\t\t\tt.Errorf(\"Value.GetFloat64() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","880ea0b271ad5f9e12e05cf9dcf137a3":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello world\",\n\t\t\t},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello world\\\"\",\n\t\t\t},\n\t\t\twant: \"\\\"hello world\\\"\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\hello world\",\n\t\t\t},\n\t\t\twant: \"\\\\hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped slashes\",\n\t\t\targs: args{\n\t\t\t\ts: \"/hello world\",\n\t\t\t},\n\t\t\twant: \"/hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\bhello world\",\n\t\t\t},\n\t\t\twant: \"\\bhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\fhello world\",\n\t\t\t},\n\t\t\twant: \"\\fhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\nhello world\",\n\t\t\t},\n\t\t\twant: \"\\nhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\rhello world\",\n\t\t\t},\n\t\t\twant: \"\\rhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\thello world\",\n\t\t\t},\n\t\t\twant: \"\\thello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\u0061hello world\",\n\t\t\t},\n\t\t\twant: \"ahello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode surrogate\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\uD83D\\\\uDE01hello world\",\n\t\t\t},\n\t\t\twant: \"😁hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid sequence\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\u006hello world\",\n\t\t\t},\n\t\t\twant: \"\\\\u006hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode too short\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\uhello world\",\n\t\t\t},\n\t\t\twant: \"\\\\uhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode surrogate incomplete\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\uD83Dhello world\",\n\t\t\t},\n\t\t\twant: \"\\\\uD83Dhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode surrogate invalid\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\uD83D\\\\uDE0hello world\",\n\t\t\t},\n\t\t\twant: \"\\\\uD83D\\\\uDE0hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\\\\"\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\u0062\\\\uD83D\\\\uDE01hello world\",\n\t\t\t},\n\t\t\twant: \"\\\"\\\\b\\\\f\\\\n\\\\r\\\\ta\\u0062😁hello world\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","88843da73a4c0686070c97ea98d37280":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantV   *Value\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"single element array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[1]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[1,2,3]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with nested array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[[1,2],[3,4]]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"4\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[1,2\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV:   nil,\n\t\t\twantS:   \"[1,2\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"array with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[1 2]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV:   nil,\n\t\t\twantS:   \"[1 2]\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"array with invalid value\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[1,2,]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV:   nil,\n\t\t\twantS:   \"[1,2,\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotV, gotS, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(gotV, tt.wantV) {\n\t\t\t\tt.Errorf(\"parseArray() gotV = %v, wantV %v\", gotV, tt.wantV)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseArray() gotS = %v, wantS %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}","88b3d88545e7b71fef3f2ddd387f7e6d":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\"`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with whitespace\",\n\t\t\targs: args{\n\t\t\t\ts: `\" hello \"`,\n\t\t\t},\n\t\t\twant:    \" hello \",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","88bc848125f2ad9eae9f374f797cdd6d":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello world\",\n\t\t\t},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\\\\"hello\\\\\\\"\",\n\t\t\t},\n\t\t\twant: \"\\\"hello\\\"\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\\\\\hello\\\\\\\\\",\n\t\t\t},\n\t\t\twant: \"\\\\hello\\\\\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\/hello\\\\/\",\n\t\t\t},\n\t\t\twant: \"/hello/\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\bhello\\\\b\",\n\t\t\t},\n\t\t\twant: \"\\bhello\\b\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\fhello\\\\f\",\n\t\t\t},\n\t\t\twant: \"\\fhello\\f\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\nhello\\\\n\",\n\t\t\t},\n\t\t\twant: \"\\nhello\\n\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\rhello\\\\r\",\n\t\t\t},\n\t\t\twant: \"\\rhello\\r\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\thello\\\\t\",\n\t\t\t},\n\t\t\twant: \"\\thello\\t\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\u0061hello\\\\u0062\",\n\t\t\t},\n\t\t\twant: \"ahello b\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\uD83D\\\\uDE01hello\\\\uD83D\\\\uDE02\",\n\t\t\t},\n\t\t\twant: \"😁hello😂\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\xhello\\\\x\",\n\t\t\t},\n\t\t\twant: \"\\\\xhello\\\\x\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\u006\",\n\t\t\t},\n\t\t\twant: \"\\\\u006\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\\\\\ \\\\/test\\\\/\",\n\t\t\t},\n\t\t\twant: \"\\\"hello\\\" \\\\world\\\\ /test/\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","8a73b2899763b71a1e7be8fdde02f4a4":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"empty string\",\n\t\t\targs:    args{s: \"\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"single digit\",\n\t\t\targs:    args{s: \"1\"},\n\t\t\twantNs:  \"1\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"multiple digits\",\n\t\t\targs:    args{s: \"123\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"negative number\",\n\t\t\targs:    args{s: \"-123\"},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"decimal number\",\n\t\t\targs:    args{s: \"123.456\"},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"exponential number\",\n\t\t\targs:    args{s: \"1.23e+4\"},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"exponential number with negative exponent\",\n\t\t\targs:    args{s: \"1.23e-4\"},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading zeros\",\n\t\t\targs:    args{s: \"00123\"},\n\t\t\twantNs:  \"00123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with trailing zeros\",\n\t\t\targs:    args{s: \"12300\"},\n\t\t\twantNs:  \"12300\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading and trailing zeros\",\n\t\t\targs:    args{s: \"0012300\"},\n\t\t\twantNs:  \"0012300\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign\",\n\t\t\targs:    args{s: \"+123\"},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and trailing zeros\",\n\t\t\targs:    args{s: \"+12300\"},\n\t\t\twantNs:  \"+12300\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and decimal point\",\n\t\t\targs:    args{s: \"+123.456\"},\n\t\t\twantNs:  \"+123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and exponential notation\",\n\t\t\targs:    args{s: \"+1.23e+4\"},\n\t\t\twantNs:  \"+1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and negative exponential notation\",\n\t\t\targs:    args{s: \"+1.23e-4\"},\n\t\t\twantNs:  \"+1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading minus sign and trailing zeros\",\n\t\t\targs:    args{s: \"-12300\"},\n\t\t\twantNs:  \"-12300\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading minus sign and decimal point\",\n\t\t\targs:    args{s: \"-123.456\"},\n\t\t\twantNs:  \"-123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading minus sign and exponential notation\",\n\t\t\targs:    args{s: \"-1.23e+4\"},\n\t\t\twantNs:  \"-1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading minus sign and negative exponential notation\",\n\t\t\targs:    args{s: \"-1.23e-4\"},\n\t\t\twantNs:  \"-1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading and trailing whitespace\",\n\t\t\targs:    args{s: \" 123 \"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" 123 \",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading whitespace\",\n\t\t\targs:    args{s: \" 123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" 123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with trailing whitespace\",\n\t\t\targs:    args{s: \"123 \"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \" \",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with internal whitespace\",\n\t\t\targs:    args{s: \"12 3\"},\n\t\t\twantNs:  \"12\",\n\t\t\twantS:   \" 3\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with invalid character\",\n\t\t\targs:    args{s: \"123a\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign and invalid character\",\n\t\t\targs:    args{s: \"+123a\"},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading minus sign and invalid character\",\n\t\t\targs:    args{s: \"-123a\"},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with invalid character after decimal point\",\n\t\t\targs:    args{s: \"123.456a\"},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with invalid character after exponential notation\",\n\t\t\targs:    args{s: \"1.23e+4a\"},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with invalid character after negative exponential notation\",\n\t\t\targs:    args{s: \"1.23e-4a\"},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with inf\",\n\t\t\targs:    args{s: \"123inf\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"inf\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with inf uppercase\",\n\t\t\targs:    args{s: \"123INF\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"INF\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with nan\",\n\t\t\targs:    args{s: \"123nan\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"nan\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with nan uppercase\",\n\t\t\targs:    args{s: \"123NAN\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"NAN\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with inf at the beginning\",\n\t\t\targs:    args{s: \"inf123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"inf123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with inf uppercase at the beginning\",\n\t\t\targs:    args{s: \"INF123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"INF123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with nan at the beginning\",\n\t\t\targs:    args{s: \"nan123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"nan123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with nan uppercase at the beginning\",\n\t\t\targs:    args{s: \"NAN123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"NAN123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with inf with leading plus sign\",\n\t\t\targs:    args{s: \"+inf\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+inf\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with inf with leading minus sign\",\n\t\t\targs:    args{s: \"-inf\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"-inf\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with nan with leading plus sign\",\n\t\t\targs:    args{s: \"+nan\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+nan\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with nan with leading minus sign\",\n\t\t\targs:    args{s: \"-nan\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"-nan\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}","8a92d6cf40fb9967c46b22a97cd7d74c":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no whitespace\",\n\t\t\targs: args{\n\t\t\t\ts: \"abc\",\n\t\t\t},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace\",\n\t\t\targs: args{\n\t\t\t\ts: \" \\t\\n\\r abc\",\n\t\t\t},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailing whitespace\",\n\t\t\targs: args{\n\t\t\t\ts: \"abc \\t\\n\\r\",\n\t\t\t},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"whitespace in the middle\",\n\t\t\targs: args{\n\t\t\t\ts: \"a bc\",\n\t\t\t},\n\t\t\twant: \"bc\",\n\t\t},\n\t\t{\n\t\t\tname: \"all whitespace\",\n\t\t\targs: args{\n\t\t\t\ts: \" \\t\\n\\r\",\n\t\t\t},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"whitespace and non-whitespace\",\n\t\t\targs: args{\n\t\t\t\ts: \" \\t\\n\\rabc \\t\\n\\r\",\n\t\t\t},\n\t\t\twant: \"abc\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","8bd5ac54a8d97cb3498cac05c38ebb21":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"valid integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"valid float\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"valid negative integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"valid negative float\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123.456\",\n\t\t\t},\n\t\t\twantNs:  \"-123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"valid exponential notation\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"valid exponential notation with negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e-4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"valid inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"inf\",\n\t\t\t},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"valid Inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"Inf\",\n\t\t\t},\n\t\t\twantNs:  \"Inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"valid NaN\",\n\t\t\targs: args{\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twantNs:  \"NaN\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"valid nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"nan\",\n\t\t\t},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading space\",\n\t\t\targs: args{\n\t\t\t\ts: \" 123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" 123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing space\",\n\t\t\targs: args{\n\t\t\t\ts: \"123 \",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \" \",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid character\",\n\t\t\targs: args{\n\t\t\t\ts: \"123a\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid character at start\",\n\t\t\targs: args{\n\t\t\t\ts: \"a123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"a123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid character at start 2\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid character at start 3\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123+\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"-123+\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with invalid character after sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"-a123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"-a123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with multiple decimal points\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.45.67\",\n\t\t\t},\n\t\t\twantNs:  \"123.45\",\n\t\t\twantS:   \".67\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"valid number with decimal point after e\",\n\t\t\targs: args{\n\t\t\t\ts: \"123e+4.5\",\n\t\t\t},\n\t\t\twantNs:  \"123e+4\",\n\t\t\twantS:   \".5\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with multiple e\",\n\t\t\targs: args{\n\t\t\t\ts: \"123e+4e+5\",\n\t\t\t},\n\t\t\twantNs:  \"123e+4\",\n\t\t\twantS:   \"e+5\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}","8cebbaf56eed54ae7ac1f41dc7bca55a":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"simple string\",\n\t\t\targs:    args{s: \"\\\"hello\\\"\"},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"string with escaped quote\",\n\t\t\targs:    args{s: \"\\\"hello\\\\\\\\\\\"\"},\n\t\t\twant:    \"hello\\\\\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"string with multiple escaped quotes\",\n\t\t\targs:    args{s: \"\\\"hello\\\\\\\"world\\\\\\\"\\\"\"},\n\t\t\twant:    \"hello\\\"world\\\"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"string with escaped quote at the end\",\n\t\t\targs:    args{s: \"\\\"hello\\\\\\\"\"},\n\t\t\twant:    \"hello\\\\\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"string with escaped quote at the beginning\",\n\t\t\targs:    args{s: \"\\\\\\\"hello\\\"\"},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\\\"hello\\\"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"string with missing closing quote\",\n\t\t\targs:    args{s: \"\\\"hello\"},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"empty string\",\n\t\t\targs:    args{s: \"\"},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"string with no quotes\",\n\t\t\targs:    args{s: \"hello\"},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","8e7a2d1d824892a379375c34369f029f":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    \u0026Value{t: TypeObject, o: Object{}},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{t: TypeObject, o: Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}},\n\t\t\t\t},\n\t\t\t}},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"key2\": \"value2\"}, \"key3\": \"value3\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{t: TypeObject, o: Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeObject, o: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}},\n\t\t\t\t\t\t},\n\t\t\t\t\t}}},\n\t\t\t\t\t{k: \"key3\", v: \u0026Value{t: TypeString, s: \"value3\"}},\n\t\t\t\t},\n\t\t\t}},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested array\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": [\"value1\", \"value2\"], \"key3\": \"value3\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{t: TypeObject, o: Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t\t\t\t{t: TypeString, s: \"value1\"},\n\t\t\t\t\t\t{t: TypeString, s: \"value2\"},\n\t\t\t\t\t}}},\n\t\t\t\t\t{k: \"key3\", v: \u0026Value{t: TypeString, s: \"value3\"}},\n\t\t\t\t},\n\t\t\t}},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with invalid key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","8eae25ac5e53288751b9137800585cf9":"```go\npackage fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttype want struct {\n\t\tv   *Value\n\t\ttail string\n\t\terr  error\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant want\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  fmt.Errorf(\"cannot parse empty string\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"{\",\n\t\t\t\terr:  fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\": \"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{k: \"key\", v: \u0026Value{t: TypeString, s: \"value\"}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"value1\", \"value2\"]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{t: TypeString, s: \"value1\"},\n\t\t\t\t\t\t{t: TypeString, s: \"value2\"},\n\t\t\t\t\t},\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"value\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeString,\n\t\t\t\t\ts: \"value\",\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   `true`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueTrue,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n","8f3577abc1e9b4953cc10e31b104475d":"package fastjson\n\nimport \"testing\"\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no whitespace\",\n\t\t\targs: args{s: \"abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace\",\n\t\t\targs: args{s: \"  abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailing whitespace\",\n\t\t\targs: args{s: \"abc  \"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"whitespace in the middle\",\n\t\t\targs: args{s: \"a bc\"},\n\t\t\twant: \"bc\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple whitespace\",\n\t\t\targs: args{s: \"  a  b  c  \"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"newline\",\n\t\t\targs: args{s: \"\\n abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"tab\",\n\t\t\targs: args{s: \"\\tabc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"carriage return\",\n\t\t\targs: args{s: \"\\rabc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","8f686768662947d3b2eeeb2bfd5865e5":"package fastjson\n\nimport (\n\t\"testing\"\n\t\"unicode/utf16\"\n\t\"strconv\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello world\"},\n\t\t\twant: \"\\\\hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello world\"},\n\t\t\twant: \"/hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello world\"},\n\t\t\twant: \"\\bhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello world\"},\n\t\t\twant: \"\\fhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello world\"},\n\t\t\twant: \"\\nhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello world\"},\n\t\t\twant: \"\\rhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello world\"},\n\t\t\twant: \"\\thello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character\",\n\t\t\targs: args{s: \"\\\\u0061hello world\"},\n\t\t\twant: \"ahello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01hello world\"},\n\t\t\twant: \"😊hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello world\"},\n\t\t\twant: \"\\\\xhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\uhello world\"},\n\t\t\twant: \"\\\\uhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\n\\\\u0061\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"\\\"hello\\\" \\\\world\\na😊\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","9077a4076d664e3c106ffc6a35892930":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"empty string\",\n\t\t\targs:    args{s: \"\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"simple integer\",\n\t\t\targs:    args{s: \"123\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"negative integer\",\n\t\t\targs:    args{s: \"-123\"},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"decimal number\",\n\t\t\targs:    args{s: \"123.456\"},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"exponential number\",\n\t\t\targs:    args{s: \"1.23e+4\"},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"exponential number with minus\",\n\t\t\targs:    args{s: \"1.23e-4\"},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"inf\",\n\t\t\targs:    args{s: \"inf\"},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"Inf\",\n\t\t\targs:    args{s: \"Inf\"},\n\t\t\twantNs:  \"Inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"inF\",\n\t\t\targs:    args{s: \"inF\"},\n\t\t\twantNs:  \"inF\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"NaN\",\n\t\t\targs:    args{s: \"NaN\"},\n\t\t\twantNs:  \"NaN\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"nan\",\n\t\t\targs:    args{s: \"nan\"},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"nAn\",\n\t\t\targs:    args{s: \"nAn\"},\n\t\t\twantNs:  \"nAn\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"unexpected char\",\n\t\t\targs:    args{s: \"123a\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"unexpected char at beginning\",\n\t\t\targs:    args{s: \"a123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"a123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"unexpected char after minus\",\n\t\t\targs:    args{s: \"-a123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"-a123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"unexpected char after plus\",\n\t\t\targs:    args{s: \"+a123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+a123\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}","90accc99b0223bbeeeeba3f4b5a0306c":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_reset(t *testing.T) {\n\ttype args struct {\n\t\to *Object\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant *Object\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.o.reset(); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Object.reset() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","927442f535b7e4a37d3a499635756263":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no whitespace\",\n\t\t\targs: args{s: \"abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace\",\n\t\t\targs: args{s: \"  abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailing whitespace\",\n\t\t\targs: args{s: \"abc  \"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading and trailing whitespace\",\n\t\t\targs: args{s: \"  abc  \"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"whitespace in the middle\",\n\t\t\targs: args{s: \"a bc\"},\n\t\t\twant: \"bc\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple whitespace\",\n\t\t\targs: args{s: \"  a  bc  \"},\n\t\t\twant: \"bc\",\n\t\t},\n\t\t{\n\t\t\tname: \"all whitespace\",\n\t\t\targs: args{s: \"  \\t\\n\\r  \"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"newline\",\n\t\t\targs: args{s: \"\\n\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"carriage return\",\n\t\t\targs: args{s: \"\\r\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"tab\",\n\t\t\targs: args{s: \"\\t\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"space\",\n\t\t\targs: args{s: \" \"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading newline\",\n\t\t\targs: args{s: \"\\nab\"},\n\t\t\twant: \"ab\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailing newline\",\n\t\t\targs: args{s: \"ab\\n\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading carriage return\",\n\t\t\targs: args{s: \"\\rab\"},\n\t\t\twant: \"ab\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailing carriage return\",\n\t\t\targs: args{s: \"ab\\r\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading tab\",\n\t\t\targs: args{s: \"\\tab\"},\n\t\t\twant: \"ab\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailing tab\",\n\t\t\targs: args{s: \"ab\\t\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading space\",\n\t\t\targs: args{s: \" ab\"},\n\t\t\twant: \"ab\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailing space\",\n\t\t\targs: args{s: \"ab \"},\n\t\t\twant: \"\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","931de4c9bc95fb1424329131cacd818c":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"strconv\"\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello world\",\n\t\t\t},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"basic escape sequences\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\\\\"\\\\b\\\\f\\\\n\\\\r\\\\t\\\\/\",\n\t\t\t},\n\t\t\twant: \"\\\"\\\\b\\\\f\\\\n\\\\r\\\\t/\",\n\t\t},\n\t\t{\n\t\t\tname: \"unicode escape sequences\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064\",\n\t\t\t},\n\t\t\twant: \"abcd\",\n\t\t},\n\t\t{\n\t\t\tname: \"surrogate pair\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\uD83D\\\\uDE03\",\n\t\t\t},\n\t\t\twant: \"😄\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\u00\",\n\t\t\t},\n\t\t\twant: \"\\\\u00\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid surrogate pair\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\uD83D\\\\u0063\",\n\t\t\t},\n\t\t\twant: \"\\\\uD83D\\\\u0063\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslash\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\\\\\\",\n\t\t\t},\n\t\t\twant: \"\\\\\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quote\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\\\\"\",\n\t\t\t},\n\t\t\twant: \"\\\"\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slash\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\/\",\n\t\t\t},\n\t\t\twant: \"/\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\b\",\n\t\t\t},\n\t\t\twant: \"\\b\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\f\",\n\t\t\t},\n\t\t\twant: \"\\f\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\n\",\n\t\t\t},\n\t\t\twant: \"\\n\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\r\",\n\t\t\t},\n\t\t\twant: \"\\r\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\t\",\n\t\t\t},\n\t\t\twant: \"\\t\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestUnescapeStringBestEffort_JSON(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello world\\\"\",\n\t\t\t},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"\\\\\\\"hello\\\\\\\" world\\\"\",\n\t\t\t},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"unicode string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"\\\\u0061\\\\u0062\\\\u0063\\\\u0064\\\"\",\n\t\t\t},\n\t\t\twant: \"abcd\",\n\t\t},\n\t\t{\n\t\t\tname: \"surrogate pair\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"\\\\uD83D\\\\uDE03\\\"\",\n\t\t\t},\n\t\t\twant: \"😄\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"\\\\u00\\\"\",\n\t\t\t},\n\t\t\twant: \"\\\\u00\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid surrogate pair\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"\\\\uD83D\\\\u0063\\\"\",\n\t\t\t},\n\t\t\twant: \"\\\\uD83D\\\\u0063\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tvar v interface{}\n\t\t\tif err := json.Unmarshal([]byte(tt.args.s), \u0026v); err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgot := unescapeStringBestEffort(tt.args.s)\n\t\t\tif got != v {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, v)\n\t\t\t}\n\t\t})\n\t}\n}","944cf59ea2ceb697831d45af4347d2e0":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{s: `\"hello\"`},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quotes\",\n\t\t\targs: args{s: `\"hello\\\" world\"`},\n\t\t\twant:    \"hello\\\" world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with multiple escaped quotes\",\n\t\t\targs: args{s: `\"hello\\\\\\\" world\\\\\\\"\\\\\"`},\n\t\t\twant:    \"hello\\\\\\\" world\\\\\\\"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quotes and other characters\",\n\t\t\targs: args{s: `\"hello\\\\\\\" world\\\\\\\"\\\\\\\", this is a test\"`},\n\t\t\twant:    \"hello\\\\\\\" world\\\\\\\"\\\\\\\"\",\n\t\t\twant1:   \", this is a test\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{s: `\"hello`},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: `\"\"`},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with leading whitespace\",\n\t\t\targs: args{s: ` \"hello\"`},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with trailing whitespace\",\n\t\t\targs: args{s: `\"hello\" `},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \" \",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","95389a6837d9eb3a84111077fcf4a879":"```go\npackage fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"empty string\",\n\t\t\targs:    args{s: \"\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"single digit\",\n\t\t\targs","962a6598fdf73728f2ed67799af5edd1":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts: \"null\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts: \"true\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts: \"false\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello\\\"\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt:  TypeString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts: \"[1, 2, 3]\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts: `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt:  TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt:  TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tp := \u0026Parser{}\n\t\t\tgot, err := p.Parse(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Parse() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Parse() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParse_InvalidJSON(t *testing.T) {\n\ttests := []string{\n\t\t\"{\",\n\t\t\"}\",\n\t\t\"[\",\n\t\t\"]\",\n\t\t\"123,\",\n\t\t\"true,\",\n\t\t\"false,\",\n\t\t\"\\\"hello\\\"\",\n\t\t`{\"key1\": \"value1\", \"key2\": \"value2\"`,\n\t\t`{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t`{\"key1\": \"value1\", \"key2\": \"value2}`,\n\t\t`{\"key1\": \"value1\", \"key2\": \"value2\",`,\n\t\t`[1, 2, 3,`,\n\t\t`[1, 2, 3,`,\n\t\t`[1, 2, 3]`,\n\t\t`[1, 2, 3`,\n\t\t`[1, 2, 3,`,\n\t}\n\n\tfor _, s := range tests {\n\t\tt.Run(s, func(t *testing.T) {\n\t\t\tp := \u0026Parser{}\n\t\t\t_, err := p.Parse(s)\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"Parse(%q) should have returned an error\", s)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParse_EscapedString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"escaped string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"\\\\\\\"hello\\\\\\\"\",\n\t\t\t},\n\t\t\twant:    `\"hello\"`,\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tp := \u0026Parser{}\n\t\t\tgot, err := p.Parse(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Parse() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got.StringBytes(), []byte(tt.want)) {\n\t\t\t\tt.Errorf(\"Parse() = %v, want %v\", got.StringBytes(), []byte(tt.want))\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParse_CompareWithStandardLibrary(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts: \"null\",\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts: \"true\",\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts: \"false\",\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello\\\"\",\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts: \"[1, 2, 3]\",\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts: `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested object\",\n\t\t\targs: args{\n\t\t\t\ts: `{\"key1\": {\"key2\": \"value2\"}, \"key3\": \"value3\"}`,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts: `{\"key1\": [1, 2, 3], \"key2\": \"value2\"}`,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tp := \u0026Parser{}\n\t\t\tgot, err := p.Parse(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Parse() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tvar want interface{}\n\t\t\tif err := json.Unmarshal([]byte(tt.args.s), \u0026want); err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tgotJSON, err := json.Marshal(got)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"json.Marshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\twantJSON, err := json.Marshal(want)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"json.Marshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !reflect.DeepEqual(gotJSON, wantJSON) {\n\t\t\t\tt.Errorf(\"Parse() = %v, want %v\", string(gotJSON), string(wantJSON))\n\t\t\t}\n\t\t})\n\t}\n}","973c84c52e171785247ca35616aa1d1f":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWS(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"single whitespace\",\n\t\t\targs: args{s: \" \"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple whitespaces\",\n\t\t\targs: args{s: \"   \"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace\",\n\t\t\targs: args{s: \"  hello\"},\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailing whitespace\",\n\t\t\targs: args{s: \"hello  \"},\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading and trailing whitespace\",\n\t\t\targs: args{s: \"  hello  \"},\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"no whitespace\",\n\t\t\targs: args{s: \"hello\"},\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"single non-whitespace character\",\n\t\t\targs: args{s: \"a\"},\n\t\t\twant: \"a\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple non-whitespace characters\",\n\t\t\targs: args{s: \"abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"mixed whitespace and non-whitespace characters\",\n\t\t\targs: args{s: \"  hello world  \"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWS(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWS() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","97f2c7add671ebe3902cf2bb0b7a7f33":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested objects\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": {\"key2\": \"value2\"}, \"key3\": \"value3\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped keys\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\\\\\": \\\"value1\\\", \\\"key2\\\": \\\"value2\\\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\\\\\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_WithEscapedKeys(t *testing.T) {\n\ts := `{\"key1\\\\\": \"value1\", \"key2\\\": \\\"value2\", \"key3\\\\\": \"value3\"}`\n\tc := \u0026cache{}\n\tgot, _, err := parseObject(s, c, 0)\n\tif err != nil {\n\t\tt.Errorf(\"parseObject() error = %v\", err)\n\t\treturn\n\t}\n\texpected := \u0026Value{\n\t\tt: TypeObject,\n\t\to: Object{\n\t\t\tkvs: []kv{\n\t\t\t\t{\n\t\t\t\t\tk: \"key1\\\\\",\n\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tk: \"key2\\\"\",\n\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tk: \"key3\\\\\",\n\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeysUnescaped: false,\n\t\t},\n\t}\n\tif !reflect.DeepEqual(got, expected) {\n\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, expected)\n\t}\n}\n\nfunc TestParseObject_WithInvalidJson(t *testing.T) {\n\tinvalidJson := []string{\n\t\t\"{\",\n\t\t\"{}\",\n\t\t`{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t`{\"key1\": \"value1\", \"key2\": \"value2\", \"key3\": \"value3`,\n\t\t`{\"key1\": \"value1\", \"key2\": \"value2\", \"key3\": \"value3} \"`,\n\t}\n\tfor _, s := range invalidJson {\n\t\tt.Run(s, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\t_, _, err := parseObject(s, c, 0)\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"parseObject() expected error for invalid json: %s\", s)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_CompareWithStandardLibrary(t *testing.T) {\n\ttype TestData struct {\n\t\tKey1 string `json:\"key1\"`\n\t\tKey2 string `json:\"key2\"`\n\t}\n\tjsonStr := `{\"key1\": \"value1\", \"key2\": \"value2\"}`\n\n\t// Parse with fastjson\n\tc := \u0026cache{}\n\tv, _, err := parseObject(jsonStr, c, 0)\n\tif err != nil {\n\t\tt.Errorf(\"parseObject() error = %v\", err)\n\t\treturn\n\t}\n\n\t// Parse with standard library\n\tvar stdTestData TestData\n\terr = json.Unmarshal([]byte(jsonStr), \u0026stdTestData)\n\tif err != nil {\n\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\treturn\n\t}\n\n\t// Compare results\n\tif v.GetObject(\"key1\").GetStringBytes() != []byte(stdTestData.Key1) ||\n\t\tv.GetObject(\"key2\").GetStringBytes() != []byte(stdTestData.Key2) {\n\t\tt.Errorf(\"parseObject() result does not match standard library result\")\n\t}\n}","988e774d0c9bbf8ebec69401aa6197ef":"package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello world\\\\\\\"\"},\n\t\t\twant: \"\\\"hello world\\\"\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello world\\\\\\\\\"},\n\t\t\twant: \"\\\\hello world\\\\\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello world\\\\/\"},\n\t\t\twant: \"/hello world/\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello world\\\\b\"},\n\t\t\twant: \"\\bhello world\\b\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello world\\\\f\"},\n\t\t\twant: \"\\fhello world\\f\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello world\\\\n\"},\n\t\t\twant: \"\\nhello world\\n\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello world\\\\r\"},\n\t\t\twant: \"\\rhello world\\r\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello world\\\\t\"},\n\t\t\twant: \"\\thello world\\t\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character\",\n\t\t\targs: args{s: \"\\\\u0061hello world\\\\u0062\"},\n\t\t\twant: \"ahello worldb\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01hello world\"},\n\t\t\twant: \"😁hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello world\"},\n\t\t\twant: \"\\\\xhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\uhello world\"},\n\t\t\twant: \"\\\\uhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\tworld\\\\u0061\\\\\\\\\\\"\"},\n\t\t\twant: \"\\\"hello\\tworlda\\\\\\\"\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_surrogate(t *testing.T) {\n\t// Surrogate pairs are handled correctly\n\ts := `\\uD83D\\uDE01`\n\twant := \"😁\"\n\tif got := unescapeStringBestEffort(s); got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n\n\t// Incomplete surrogate pairs are handled correctly\n\ts = `\\uD83Dhello world`\n\twant = `\\uD83Dhello world`\n\tif got := unescapeStringBestEffort(s); got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n\n\t// Invalid surrogate pairs are handled correctly\n\ts = `\\uD83D\\u0000hello world`\n\twant = `\\uD83D\\u0000hello world`\n\tif got := unescapeStringBestEffort(s); got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n\n\t// Surrogate pairs with invalid escape sequences are handled correctly\n\ts = `\\uD83D\\x0000hello world`\n\twant = `\\uD83D\\x0000hello world`\n\tif got := unescapeStringBestEffort(s); got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_hex(t *testing.T) {\n\t// Hexadecimal escape sequences are handled correctly\n\ts := `\\u0061`\n\twant := \"a\"\n\tif got := unescapeStringBestEffort(s); got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n\n\t// Incomplete hexadecimal escape sequences are handled correctly\n\ts = `\\u006hello world`\n\twant = `\\u006hello world`\n\tif got := unescapeStringBestEffort(s); got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n\n\t// Invalid hexadecimal escape sequences are handled correctly\n\ts = `\\u00gghello world`\n\twant = `\\u00gghello world`\n\tif got := unescapeStringBestEffort(s); got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n\n\t// Hexadecimal escape sequences with invalid characters are handled correctly\n\ts = `\\u0061\\x00hello world`\n\twant = `\\u0061\\x00hello world`\n\tif got := unescapeStringBestEffort(s); got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_strconv(t *testing.T) {\n\t// Test strconv.ParseUint for invalid hexadecimal escape sequences\n\ts := `\\u00gg`\n\t_, err := strconv.ParseUint(s[2:6], 16, 16)\n\tif err == nil {\n\t\tt.Errorf(\"strconv.ParseUint() should have returned an error for invalid hexadecimal escape sequence\")\n\t}\n\n\t// Test strconv.ParseUint for valid hexadecimal escape sequences\n\ts = `\\u0061`\n\tx, err := strconv.ParseUint(s[2:6], 16, 16)\n\tif err != nil {\n\t\tt.Errorf(\"strconv.ParseUint() returned an error for valid hexadecimal escape sequence: %v\", err)\n\t}\n\tif x != 0x61 {\n\t\tt.Errorf(\"strconv.ParseUint() returned incorrect value: %v\", x)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_utf16(t *testing.T) {\n\t// Test utf16.IsSurrogate for valid surrogate characters\n\tr := rune(0xD83D)\n\tif !utf16.IsSurrogate(r) {\n\t\tt.Errorf(\"utf16.IsSurrogate() should have returned true for valid surrogate character\")\n\t}\n\n\t// Test utf16.IsSurrogate for invalid surrogate characters\n\tr = rune(0x0061)\n\tif utf16.IsSurrogate(r) {\n\t\tt.Errorf(\"utf16.IsSurrogate() should have returned false for invalid surrogate character\")\n\t}\n\n\t// Test utf16.DecodeRune for valid surrogate pairs\n\tr1 := rune(0xD83D)\n\tr2 := rune(0xDE01)\n\tr := utf16.DecodeRune(r1, r2)\n\tif r != 0x1F601 {\n\t\tt.Errorf(\"utf16.DecodeRune() returned incorrect value: %v\", r)\n\t}\n\n\t// Test utf16.DecodeRune for invalid surrogate pairs\n\tr1 = rune(0xD83D)\n\tr2 = rune(0x0000)\n\tr = utf16.DecodeRune(r1, r2)\n\tif r != utf16.ReplacementChar {\n\t\tt.Errorf(\"utf16.DecodeRune() returned incorrect value: %v\", r)\n\t}\n}","98c795bf1798c0c906aef3710ac7839f":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestHasSpecialChars(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"no special chars\",\n\t\t\targs: args{s: \"abc123\"},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"contains backslash\",\n\t\t\targs: args{s: \"abc\\\\123\"},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"contains control char\",\n\t\t\targs: args{s: \"abc\\x01123\"},\n\t\t\twant: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := hasSpecialChars(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"hasSpecialChars() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","9914998199e4809edead0dd3661441c4":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello world\"`,\n\t\t\t},\n\t\t\twant:    \"hello world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello \\\\\"world\\\\\"\"`,\n\t\t\t},\n\t\t\twant:    \"hello \\\"world\\\"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello \\\\\"world\\\\\" \\\\\"again\\\\\"\"`,\n\t\t\t},\n\t\t\twant:    \"hello \\\"world\\\" \\\"again\\\"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped backslash\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello \\\\\\\\world\"`,\n\t\t\t},\n\t\t\twant:    \"hello \\\\world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello world`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: ``,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with no quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `hello world`,\n\t\t\t},\n\t\t\twant:    \"hello world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote at the beginning\",\n\t\t\targs: args{\n\t\t\t\ts: `\\\\\"hello world\"`,\n\t\t\t},\n\t\t\twant:    `\\hello world`,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote at the end\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello world\\\\\"`,\n\t\t\t},\n\t\t\twant:    \"hello world\\\\\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","99f957235d301b83e920e28e6e699f3b":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttype want struct {\n\t\tv   *Value\n\t\ts   string\n\t\terr error\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant want\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{},\n\t\t\t\t},\n\t\t\t\ts: \"\",\n\t\t\t\terr: nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"single element array\",\n\t\t\targs: args{\n\t\t\t\ts:    `[1]`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ts: \"\",\n\t\t\t\terr: nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element array\",\n\t\t\targs: args{\n\t\t\t\ts:    `[1, \"2\", {\"a\": 3}]`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tk: \"a\",\n\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ts: \"\",\n\t\t\t\terr: nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"array with trailing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    `[1, 2,]`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ts:   \",]\",\n\t\t\t\terr: fmt.Errorf(\"missing ',' after array value\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"array with missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:    `[1, 2`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ts:   `1, 2`,\n\t\t\t\terr: fmt.Errorf(\"unexpected end of array\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"array with invalid value\",\n\t\t\targs: args{\n\t\t\t\ts:    `[1, 2, {`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ts:   `{`,\n\t\t\t\terr: fmt.Errorf(\"cannot parse array value: unexpected end of object\"),\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotV, gotS, gotErr := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif gotErr != nil {\n\t\t\t\tif tt.want.err == nil {\n\t\t\t\t\tt.Errorf(\"parseArray() error = %v, want nil\", gotErr)\n\t\t\t\t} else {\n\t\t\t\t\tif gotErr.Error() != tt.want.err.Error() {\n\t\t\t\t\t\tt.Errorf(\"parseArray() error = %v, want %v\", gotErr, tt.want.err)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif tt.want.err != nil {\n\t\t\t\t\tt.Errorf(\"parseArray() error = %v, want %v\", gotErr, tt.want.err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(gotV, tt.want.v) {\n\t\t\t\tt.Errorf(\"parseArray() gotV = %v, want %v\", gotV, tt.want.v)\n\t\t\t}\n\t\t\tif gotS != tt.want.s {\n\t\t\t\tt.Errorf(\"parseArray() gotS = %v, want %v\", gotS, tt.want.s)\n\t\t\t}\n\t\t})\n\t}\n}","9a400049bc667439078b6f295edaa514":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttype want struct {\n\t\tv   *Value\n\t\ts   string\n\t\terr error\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant want\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[]\",\n\t\t\t\tc:   \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{},\n\t\t\t\t},\n\t\t\t\ts: \"\",\n\t\t\t\terr: nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"single element array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"hello\"]`,\n\t\t\t\tc:   \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt:  TypeString,\n\t\t\t\t\t\t\ts: \"hello\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ts: \"\",\n\t\t\t\terr: nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[1, \"hello\", true, {\"a\": 1}]`,\n\t\t\t\tc:   \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt:  TypeString,\n\t\t\t\t\t\t\ts: \"hello\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tk: \"a\",\n\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ts: \"\",\n\t\t\t\terr: nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:   `[1, \"hello\", true`,\n\t\t\t\tc:   \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ts:   `[1, \"hello\", true`,\n\t\t\t\terr: fmt.Errorf(\"missing ']'\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected end of array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[1, \"hello\", true,`,\n\t\t\t\tc:   \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ts:   `[1, \"hello\", true,`,\n\t\t\t\terr: fmt.Errorf(\"unexpected end of array\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"missing comma after array value\",\n\t\t\targs: args{\n\t\t\t\ts:   `[1 \"hello\", true]`,\n\t\t\t\tc:   \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ts:   `[1 \"hello\", true]`,\n\t\t\t\terr: fmt.Errorf(\"missing ',' after array value\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"cannot parse array value\",\n\t\t\targs: args{\n\t\t\t\ts:   `[1, \"hello\", {`,\n\t\t\t\tc:   \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ts:   `[1, \"hello\", {`,\n\t\t\t\terr: fmt.Errorf(\"cannot parse array value: missing '}'\"),\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotV, gotS, gotErr := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (gotErr == nil) != (tt.want.err == nil) {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", gotErr, tt.want.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotErr != nil \u0026\u0026 tt.want.err != nil {\n\t\t\t\tif gotErr.Error() != tt.want.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", gotErr, tt.want.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(gotV, tt.want.v) {\n\t\t\t\tt.Errorf(\"parseArray() gotV = %v, wantV %v\", gotV, tt.want.v)\n\t\t\t}\n\t\t\tif gotS != tt.want.s {\n\t\t\t\tt.Errorf(\"parseArray() gotS = %v, wantS %v\", gotS, tt.want.s)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseArray_JSON(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tinput string\n\t\twant  []interface{}\n\t}{\n\t\t{\n\t\t\tname:  \"empty array\",\n\t\t\tinput: \"[]\",\n\t\t\twant:  []interface{}{},\n\t\t},\n\t\t{\n\t\t\tname:  \"single element array\",\n\t\t\tinput: `[\"hello\"]`,\n\t\t\twant:  []interface{}{\"hello\"},\n\t\t},\n\t\t{\n\t\t\tname:  \"multiple element array\",\n\t\t\tinput: `[1, \"hello\", true, {\"a\": 1}]`,\n\t\t\twant:  []interface{}{1, \"hello\", true, map[string]interface{}{\"a\": 1}},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tvar got []interface{}\n\t\t\tif err := json.Unmarshal([]byte(tt.input), \u0026got); err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","9b380eec8fa2e09aba0eeacd0f8da3ef":"```go\npackage fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape characters\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quote\",\n\t\t\targs: args{s: \"\\\\\\\"\"},\n\t\t\twant: \"\\\"\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslash\",\n\t\t\targs: args{s: \"\\\\\\\\\"},\n\t\t\twant: \"\\\\\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slash\",\n\t\t\targs: args{s: \"\\\\/\"},\n\t\t\twant: \"/\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\b\"},\n\t\t\twant: \"\\b\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\f\"},\n\t\t\twant: \"\\f\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\n\"},\n\t\t\twant: \"\\n\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\r\"},\n\t\t\twant: \"\\r\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\t\"},\n\t\t\twant: \"\\t\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character\",\n\t\t\targs: args{s: \"\\\\u0061\"},\n\t\t\twant: \"a\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"😁\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\u\"},\n\t\t\twant: \"\\\\u\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence 2\",\n\t\t\targs: args{s: \"\\\\u00\"},\n\t\t\twant: \"\\\\u00\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence 3\",\n\t\t\targs: args{s: \"\\\\u000\"},\n\t\t\twant: \"\\\\u000\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence 4\",\n\t\t\targs: args{s: \"\\\\u0000\"},\n\t\t\twant: \"\\\\u0000\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence 5\",\n\t\t\targs: args{s: \"\\\\u00000\"},\n\t\t\twant: \"\\\\u00000\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE00\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE00\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 2\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE02\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE02\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 3\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE03\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE03\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 4\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE04\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE04\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 5\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE05\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE05\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 6\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE06\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE06\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 7\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE07\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE07\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 8\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE08\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE08\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 9\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE09\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE09\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 10\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE0A\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE0A\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 11\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE0B\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE0B\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 12\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE0C\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE0C\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 13\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE0D\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE0D\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 14\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE0E\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE0E\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 15\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE0F\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE0F\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 16\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE10\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE10\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 17\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE11\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE11\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 18\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE12\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE12\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 19\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE13\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE13\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 20\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE14\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE14\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 21\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE15\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE15\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 22\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE16\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE16\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 23\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE17\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE17\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 24\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE18\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE18\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 25\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE19\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE19\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 26\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE1A\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE1A\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 27\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE1B\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE1B\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 28\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE1C\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE1C\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 29\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE1D\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE1D\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 30\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE1E\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE1E\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 31\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE1F\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE1F\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 32\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE20\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE20\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 33\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE21\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE21\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 34\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE22\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE22\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 35\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE23\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE23\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 36\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE24\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE24\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 37\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE25\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE25\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 38\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE26\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE26\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 39\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE27\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE27\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 40\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE28\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE28\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 41\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE29\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE29\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 42\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE2A\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE2A\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 43\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE2B\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE2B\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 44\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE2C\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE2C\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 45\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE2D\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE2D\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 46\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE2E\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE2E\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 47\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE2F\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE2F\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 48\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE30\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE30\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 49\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE31\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE31\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 50\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE32\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE32\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 51\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE33\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE33\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 52\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE34\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE34\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 53\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE35\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE35\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 54\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE36\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE36\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 55\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE37\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE37\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 56\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE38\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE38\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 57\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE39\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE39\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 58\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE3A\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE3A\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 59\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE3B\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE3B\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 60\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE3C\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE3C\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 61\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE3D\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE3D\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 62\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE3E\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE3E\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 63\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE3F\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE3F\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 64\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE40\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE40\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 65\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE41\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE41\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 66\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE42\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE42\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 67\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE43\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE43\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 68\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE44\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE44\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 69\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE45\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE45\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 70\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE46\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE46\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 71\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE47\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE47\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 72\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE48\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE48\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 73\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE49\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE49\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 74\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE4A\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE4A\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 75\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE4B\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE4B\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 76\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE4C\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE4C\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 77\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE4D\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE4D\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 78\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE4E\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE4E\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 79\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE4F\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE4F\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 80\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE50\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE50\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 81\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE51\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE51\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 82\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE52\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE52\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 83\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE53\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE53\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 84\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE54\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE54\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 85\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE55\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE55\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 86\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE56\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE56\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 87\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE57\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE57\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 88\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE58\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE58\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 89\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE59\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE59\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 90\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE5A\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE5A\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 91\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE5B\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE5B\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 92\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE5C\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE5C\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 93\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE5D\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE5D\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 94\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE5E\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE5E\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 95\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE5F\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE5F\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 96\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE60\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE60\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 97\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE61\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE61\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 98\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE62\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE62\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 99\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE63\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE63\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 100\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE64\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE64\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 101\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE65\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE65\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 102\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE66\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE66\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 103\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE67\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE67\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 104\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE68\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE68\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 105\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE69\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE69\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 106\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE6A\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE6A\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 107\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE6B\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE6B\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 108\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE6C\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE6C\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 109\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE6D\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE6D\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 110\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE6E\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE6E\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 111\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE6F\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE6F\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 112\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE70\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE70\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 113\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE71\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE71\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 114\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE72\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE72\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 115\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE73\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE73\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 116\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE74\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE74\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 117\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE75\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE75\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 118\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE76\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE76\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 119\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE77\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE77\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 120\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE78\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE78\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 121\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE79\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE79\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 122\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE7A\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE7A\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 123\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE7B\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE7B\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 124\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE7C\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE7C\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 125\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE7D\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE7D\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 126\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE7E\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE7E\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 127\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE7F\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE7F\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 128\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE80\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE80\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 129\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE81\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE81\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 130\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE82\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE82\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 131\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE83\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE83\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 132\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE84\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE84\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 133\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE85\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE85\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 134\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE86\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE86\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 135\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE87\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE87\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid surrogate 136\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE88\"},\n\t\t\twant: \"\\\\uD83D\\\\uDE88\",\n\t\t},\n\t\t{\n","9c63bb399dab302f6903eab6bf141443":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCacheGetValue(t *testing.T) {\n\tt.Run(\"empty cache\", func(t *testing.T) {\n\t\tc := \u0026cache{}\n\t\tv := c.getValue()\n\t\tif v == nil {\n\t\t\tt.Errorf(\"getValue() returned nil for an empty cache\")\n\t\t}\n\t})\n\n\tt.Run(\"non-empty cache\", func(t *testing.T) {\n\t\tc := \u0026cache{\n\t\t\tvs: []Value{\n\t\t\t\t{t: TypeString, s: \"test\"},\n\t\t\t},\n\t\t}\n\t\tv := c.getValue()\n\t\tif v == nil {\n\t\t\tt.Errorf(\"getValue() returned nil for a non-empty cache\")\n\t\t}\n\t\tif v.t != TypeString {\n\t\t\tt.Errorf(\"getValue() returned incorrect type: got %v, want %v\", v.t, TypeString)\n\t\t}\n\t\tif v.s != \"test\" {\n\t\t\tt.Errorf(\"getValue() returned incorrect value: got %v, want %v\", v.s, \"test\")\n\t\t}\n\t})\n\n\tt.Run(\"capacity greater than length\", func(t *testing.T) {\n\t\tc := \u0026cache{\n\t\t\tvs: make([]Value, 1),\n\t\t}\n\t\tv := c.getValue()\n\t\tif v == nil {\n\t\t\tt.Errorf(\"getValue() returned nil for a cache with capacity greater than length\")\n\t\t}\n\t\tif len(c.vs) != 2 {\n\t\t\tt.Errorf(\"getValue() did not resize the cache: got length %v, want %v\", len(c.vs), 2)\n\t\t}\n\t})\n\n\tt.Run(\"capacity equal to length\", func(t *testing.T) {\n\t\tc := \u0026cache{\n\t\t\tvs: make([]Value, 1),\n\t\t}\n\t\tc.vs = c.vs[:cap(c.vs)]\n\t\tv := c.getValue()\n\t\tif v == nil {\n\t\t\tt.Errorf(\"getValue() returned nil for a cache with capacity equal to length\")\n\t\t}\n\t\tif len(c.vs) != 2 {\n\t\t\tt.Errorf(\"getValue() did not resize the cache: got length %v, want %v\", len(c.vs), 2)\n\t\t}\n\t})\n}","9d1c733b765c6e5bb2e318b7bf7b1f1d":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetFloat64(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.GetFloat64(tt.args.keys...); got != tt.want {\n\t\t\t\tt.Errorf(\"Value.GetFloat64() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","9d722c9775b36fd5ffebc9644db7afd5":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantKey string\n\t\twantTail string\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:    \"simple key\",\n\t\t\targs:    args{s: `\"key\"`},\n\t\t\twantKey: \"key\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:    \"key with space\",\n\t\t\targs:    args{s: `\"key with space\"`},\n\t\t\twantKey: \"key with space\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:    \"key with escape sequences\",\n\t\t\targs:    args{s: `\"key\\\\\"with\\\\\"escape\\\\\"sequences\"`},\n\t\t\twantKey: \"key\\\\\\\"with\\\\\\\"escape\\\\\\\"sequences\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:    \"missing closing quote\",\n\t\t\targs:    args{s: `\"key`},\n\t\t\twantKey: \"\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:    \"empty key\",\n\t\t\targs:    args{s: `\"\"`},\n\t\t\twantKey: \"\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:    \"key with backslash\",\n\t\t\targs:    args{s: `\"key\\\\\"`},\n\t\t\twantKey: \"key\\\\\",\n\t\t\twantTail: \"\",\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotKey, gotTail, err := parseRawKey(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawKey() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotKey != tt.wantKey {\n\t\t\t\tt.Errorf(\"parseRawKey() gotKey = %v, want %v\", gotKey, tt.wantKey)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseRawKey() gotTail = %v, want %v\", gotTail, tt.wantTail)\n\t\t\t}\n\t\t})\n\t}\n}","9ded4cbbfb091b99193517a3125351b6":"```go\npackage fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"abcdefg\"},\n\t\t\twant: \"abcdefg\",\n\t\t},\n\t\t{\n\t\t\tname: \"simple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"\\\\/\\\\b\\\\f\\\\n\\\\r\\\\t\"},\n\t\t\twant: \"\\\"\\\\/\\\\f\\n\\r\\t\",\n\t\t},\n\t\t{\n\t\t\tname: \"unicode escape sequences\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064\"},\n\t\t\twant: \"abcd\",\n\t\t},\n\t\t{\n\t\t\tname: \"surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"😊\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid unicode escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u006d\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u006d\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete unicode escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\\\\u\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslash\",\n\t\t\targs: args{s: \"\\\\\\\\\"},\n\t\t\twant: \"\\\\\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"\\\\/\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\u0062\\\\u0063\\\\u0064\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"\\\"\\\\/\\\\f\\n\\r\\tabcd😊\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_surrogatePair(t *testing.T) {\n\ts := \"\\\\uD83D\\\\uDE01\"\n\twant := \"😊\"\n\tgot := unescapeStringBestEffort(s)\n\tif got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_invalidUnicodeEscapeSequence(t *testing.T) {\n\ts := \"\\\\u0061\\\\u0062\\\\u0063\\\\u006d\"\n\twant := \"\\\\u0061\\\\u0062\\\\u0063\\\\u006d\"\n\tgot := unescapeStringBestEffort(s)\n\tif got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_incompleteUnicodeEscapeSequence(t *testing.T) {\n\ts := \"\\\\u0061\\\\u0062\\\\u0063\\\\u\"\n\twant := \"\\\\u0061\\\\u0062\\\\u0063\\\\u\"\n\tgot := unescapeStringBestEffort(s)\n\tif got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_escapedBackslash(t *testing.T) {\n\ts := \"\\\\\\\\\"\n\twant := \"\\\\\"\n\tgot := unescapeStringBestEffort(s)\n\tif got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_multipleEscapeSequences(t *testing.T) {\n\ts := \"\\\\\\\"\\\\/\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\u0062\\\\u0063\\\\u0064\\\\uD83D\\\\uDE01\"\n\twant := \"\\\"\\\\/\\\\f\\n\\r\\tabcd😊\"\n\tgot := unescapeStringBestEffort(s)\n\tif got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_surrogatePair_incomplete(t *testing.T) {\n\ts := \"\\\\uD83D\\\\u\"\n\twant := \"\\\\uD83D\\\\u\"\n\tgot := unescapeStringBestEffort(s)\n\tif got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_surrogatePair_invalid_second(t *testing.T) {\n\ts := \"\\\\uD83D\\\\uDE0\"\n\twant := \"\\\\uD83D\\\\uDE0\"\n\tgot := unescapeStringBestEffort(s)\n\tif got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_surrogatePair_invalid_second_2(t *testing.T) {\n\ts := \"\\\\uD83D\\\\uDE\"\n\twant := \"\\\\uD83D\\\\uDE\"\n\tgot := unescapeStringBestEffort(s)\n\tif got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_surrogatePair_invalid_second_3(t *testing.T) {\n\ts := \"\\\\uD83D\\\\u\"\n\twant := \"\\\\uD83D\\\\u\"\n\tgot := unescapeStringBestEffort(s)\n\tif got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_surrogatePair_invalid_first(t *testing.T) {\n\ts := \"\\\\uD83\\\\uDE01\"\n\twant := \"\\\\uD83\\\\uDE01\"\n\tgot := unescapeStringBestEffort(s)\n\tif got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_surrogatePair_invalid_first_2(t *testing.T) {\n\ts := \"\\\\uD8\\\\uDE01\"\n\twant := \"\\\\uD8\\\\uDE01\"\n\tgot := unescapeStringBestEffort(s)\n\tif got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_surrogatePair_invalid_first_3(t *testing.T) {\n\ts := \"\\\\u\\\\uDE01\"\n\twant := \"\\\\u\\\\uDE01\"\n\tgot := unescapeStringBestEffort(s)\n\tif got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_surrogatePair_invalid_first_4(t *testing.T) {\n\ts := \"\\\\uD83D\\\\uDE01\\\\u\"\n\twant := \"\\\\uD83D\\\\uDE01\\\\u\"\n\tgot := unescapeStringBestEffort(s)\n\tif got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_surrogatePair_invalid_first_5(t *testing.T) {\n\ts := \"\\\\uD83D\\\\uDE01\\\\uD83D\"\n\twant := \"\\\\uD83D\\\\uDE01\\\\uD83D\"\n\tgot := unescapeStringBestEffort(s)\n\tif got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_surrogatePair_invalid_first_6(t *testing.T) {\n\ts := \"\\\\uD83D\\\\uDE01\\\\uD83\"\n\twant := \"\\\\uD83D\\\\uDE01\\\\uD83\"\n\tgot := unescapeStringBestEffort(s)\n\tif got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_surrogatePair_invalid_first_7(t *testing.T) {\n\ts := \"\\\\uD83D\\\\uDE01\\\\uD\"\n\twant := \"\\\\uD83D\\\\uDE01\\\\uD\"\n\tgot := unescapeStringBestEffort(s)\n\tif got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_surrogatePair_invalid_first_8(t *testing.T) {\n\ts := \"\\\\uD83D\\\\uDE01\\\\uDE01\"\n\twant := \"\\\\uD83D\\\\uDE01\\\\uDE01\"\n\tgot := unescapeStringBestEffort(s)\n\tif got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_surrogatePair_invalid_first_9(t *testing.T) {\n\ts := \"\\\\uD83D\\\\uDE01\\\\uDE\"\n\twant := \"\\\\uD83D\\\\uDE01\\\\uDE\"\n\tgot := unescapeStringBestEffort(s)\n\tif got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_surrogatePair_invalid_first_10(t *testing.T) {\n\ts := \"\\\\uD83D\\\\uDE01\\\\u\"\n\twant := \"\\\\uD83D\\\\uDE01\\\\u\"\n\tgot := unescapeStringBestEffort(s)\n\tif got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_surrogatePair_invalid_first_11(t *testing.T) {\n\ts := \"\\\\uD83D\\\\uDE01\\\\\"\n\twant := \"\\\\uD83D\\\\uDE01\\\\\"\n\tgot := unescapeStringBestEffort(s)\n\tif got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_surrogatePair_invalid_first_12(t *testing.T) {\n\ts := \"\\\\uD83D\\\\uDE01\\\\uDE02\"\n\twant := \"\\\\uD83D\\\\uDE01\\\\uDE02\"\n\tgot := unescapeStringBestEffort(s)\n\tif got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_surrogatePair_invalid_first_13(t *testing.T) {\n\ts := \"\\\\uD83D\\\\uDE01\\\\uDE\"\n\twant := \"\\\\uD83D\\\\uDE01\\\\uDE\"\n\tgot := unescapeStringBestEffort(s)\n\tif got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_surrogatePair_invalid_first_14(t *testing.T) {\n\ts := \"\\\\uD83D\\\\uDE01\\\\u\"\n\twant := \"\\\\uD83D\\\\uDE01\\\\u\"\n\tgot := unescapeStringBestEffort(s)\n\tif got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_surrogatePair_invalid_first_15(t *testing.T) {\n\ts := \"\\\\uD83D\\\\uDE01\\\\\"\n\twant := \"\\\\uD83D\\\\uDE01\\\\\"\n\tgot := unescapeStringBestEffort(s)\n\tif got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_surrogatePair_invalid_first_16(t *testing.T) {\n\ts := \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\"\n\twant := \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\"\n\tgot := unescapeStringBestEffort(s)\n\tif got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_surrogatePair_invalid_first_17(t *testing.T) {\n\ts := \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE\"\n\twant := \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE\"\n\tgot := unescapeStringBestEffort(s)\n\tif got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_surrogatePair_invalid_first_18(t *testing.T) {\n\ts := \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\u\"\n\twant := \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\u\"\n\tgot := unescapeStringBestEffort(s)\n\tif got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_surrogatePair_invalid_first_19(t *testing.T) {\n\ts := \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\\"\n\twant := \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\\"\n\tgot := unescapeStringBestEffort(s)\n\tif got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_surrogatePair_invalid_first_20(t *testing.T) {\n\ts := \"\\\\uD83D\\\\uDE01\\\\uD83\"\n\twant := \"\\\\uD83D\\\\uDE01\\\\uD83\"\n\tgot := unescapeStringBestEffort(s)\n\tif got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_surrogatePair_invalid_first_21(t *testing.T) {\n\ts := \"\\\\uD83D\\\\uDE01\\\\uD\"\n\twant := \"\\\\uD83D\\\\uDE01\\\\uD\"\n\tgot := unescapeStringBestEffort(s)\n\tif got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_surrogatePair_invalid_first_22(t *testing.T) {\n\ts := \"\\\\uD83D\\\\uDE01\\\\u\"\n\twant := \"\\\\uD83D\\\\uDE01\\\\u\"\n\tgot := unescapeStringBestEffort(s)\n\tif got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_surrogatePair_invalid_first_23(t *testing.T) {\n\ts := \"\\\\uD83D\\\\uDE01\\\\\"\n\twant := \"\\\\uD83D\\\\uDE01\\\\\"\n\tgot := unescapeStringBestEffort(s)\n\tif got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_surrogatePair_invalid_first_24(t *testing.T) {\n\ts := \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\"\n\twant := \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\"\n\tgot := unescapeStringBestEffort(s)\n\tif got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_surrogatePair_invalid_first_25(t *testing.T) {\n\ts := \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE\"\n\twant := \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE\"\n\tgot := unescapeStringBestEffort(s)\n\tif got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_surrogatePair_invalid_first_26(t *testing.T) {\n\ts := \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\u\"\n\twant := \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\u\"\n\tgot := unescapeStringBestEffort(s)\n\tif got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_surrogatePair_invalid_first_27(t *testing.T) {\n\ts := \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\\"\n\twant := \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\\"\n\tgot := unescapeStringBestEffort(s)\n\tif got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_surrogatePair_invalid_first_28(t *testing.T) {\n\ts := \"\\\\uD83D\\\\uDE01\\\\uD83\"\n\twant := \"\\\\uD83D\\\\uDE01\\\\uD83\"\n\tgot := unescapeStringBestEffort(s)\n\tif got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_surrogatePair_invalid_first_29(t *testing.T) {\n\ts := \"\\\\uD83D\\\\uDE01\\\\uD\"\n\twant := \"\\\\uD83D\\\\uDE01\\\\uD\"\n\tgot := unescapeStringBestEffort(s)\n\tif got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_surrogatePair_invalid_first_30(t *testing.T) {\n\ts := \"\\\\uD83D\\\\uDE01\\\\u\"\n\twant := \"\\\\uD83D\\\\uDE01\\\\u\"\n\tgot := unescapeStringBestEffort(s)\n\tif got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_surrogatePair_invalid_first_31(t *testing.T) {\n\ts := \"\\\\uD83D\\\\uDE01\\\\\"\n\twant := \"\\\\uD83D\\\\uDE01\\\\\"\n\tgot := unescapeStringBestEffort(s)\n\tif got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_surrogatePair_invalid_first_32(t *testing.T) {\n\ts := \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\"\n\twant := \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\"\n\tgot := unescapeStringBestEffort(s)\n\tif got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_surrogatePair_invalid_first_33(t *testing.T) {\n\ts := \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE\"\n\twant := \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE\"\n\tgot := unescapeStringBestEffort(s)\n\tif got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_surrogatePair_invalid_first_34(t *testing.T) {\n\ts := \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\u\"\n\twant := \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\u\"\n\tgot := unescapeStringBestEffort(s)\n\tif got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_surrogatePair_invalid_first_35(t *testing.T) {\n\ts := \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\\"\n\twant := \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\\"\n\tgot := unescapeStringBestEffort(s)\n\tif got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_surrogatePair_invalid_first_36(t *testing.T) {\n\ts := \"\\\\uD83D\\\\uDE01\\\\uD83\"\n\twant := \"\\\\uD83D\\\\uDE01\\\\uD83\"\n\tgot := unescapeStringBestEffort(s)\n\tif got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_surrogatePair_invalid_first_37(t *testing.T) {\n\ts := \"\\\\uD83D\\\\uDE01\\\\uD\"\n\twant := \"\\\\uD83D\\\\uDE01\\\\uD\"\n\tgot := unescapeStringBestEffort(s)\n\tif got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_surrogatePair_invalid_first_38(t *testing.T) {\n\ts := \"\\\\uD83D\\\\uDE01\\\\u\"\n\twant := \"\\\\uD83D\\\\uDE01\\\\u\"\n\tgot := unescapeStringBestEffort(s)\n\tif got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_surrogatePair_invalid_first_39(t *testing.T) {\n\ts := \"\\\\uD83D\\\\uDE01\\\\\"\n\twant := \"\\\\uD83D\\\\uDE01\\\\\"\n\tgot := unescapeStringBestEffort(s)\n\tif got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_surrogatePair_invalid_first_40(t *testing.T) {\n\ts := \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\"\n\twant := \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\"\n\tgot := unescapeStringBestEffort(s)\n\tif got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_surrogatePair_invalid_first_41(t *testing.T) {\n\ts := \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE\"\n\twant := \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE\"\n\tgot := unescapeStringBestEffort(s)\n\tif got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_surrogatePair_invalid_first_42(t *testing.T) {\n\ts := \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\u\"\n\twant := \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\u\"\n\tgot := unescapeStringBestEffort(s)\n\tif got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_surrogatePair_invalid_first_43(t *testing.T) {\n\ts := \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\\"\n\twant := \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\\"\n\tgot := unescapeStringBestEffort(s)\n\tif got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_surrogatePair_invalid_first_44(t *testing.T) {\n\ts := \"\\\\uD83D\\\\uDE01\\\\uD83\"\n\twant := \"\\\\uD83D\\\\uDE01\\\\uD83\"\n\tgot := unescapeStringBestEffort(s)\n\tif got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_surrogatePair_invalid_first_45(t *testing.T) {\n\ts := \"\\\\uD83D\\\\uDE01\\\\uD\"\n\twant := \"\\\\uD83D\\\\uDE01\\\\uD\"\n\tgot := unescapeStringBestEffort(s)\n\tif got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_surrogatePair_invalid_first_46(t *testing.T) {\n\ts := \"\\\\uD83D\\\\uDE01\\\\u\"\n\twant := \"\\\\uD83D\\\\uDE01\\\\u\"\n\tgot := unescapeStringBestEffort(s)\n\tif got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_surrogatePair_invalid_first_47(t *testing.T) {\n\ts := \"\\\\uD83D\\\\uDE01\\\\\"\n\twant := \"\\\\uD83D\\\\uDE01\\\\\"\n\tgot := unescapeStringBestEffort(s)\n\tif got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_surrogatePair_invalid_first_48(t *testing.T) {\n\ts := \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\"\n\twant := \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\"\n\tgot := unescapeStringBestEffort(s)\n\tif got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_surrogatePair_invalid_first_49(t *testing.T) {\n\ts := \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE\"\n\twant := \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE\"\n\tgot := unescapeStringBestEffort(s)\n\tif got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_surrogatePair_invalid_first_50(t *testing.T) {\n\ts := \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\u\"\n\twant := \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\u\"\n\tgot := unescapeStringBestEffort(s)\n\tif got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_surrogatePair_invalid_first_51(t *testing.T) {\n\ts := \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\\"\n\twant := \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\\"\n\tgot := unescapeStringBestEffort(s)\n\tif got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_surrogatePair_invalid_first_52(t *testing.T) {\n\ts := \"\\\\uD83D\\\\uDE01\\\\uD83\"\n\twant := \"\\\\uD83D\\\\uDE01\\\\uD83\"\n\tgot := unescapeStringBestEffort(s)\n\tif got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_surrogatePair_invalid_first_53(t *testing.T) {\n\ts := \"\\\\uD83D\\\\uDE01\\\\uD\"\n\twant := \"\\\\uD83D\\\\uDE01\\\\uD\"\n\tgot := unescapeStringBestEffort(s)\n\tif got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_surrogatePair_invalid_first_54(t *testing.T) {\n\ts := \"\\\\uD83D\\\\uDE01\\\\u\"\n\twant := \"\\\\uD83D\\\\uDE01\\\\u\"\n\tgot := unescapeStringBestEffort(s)\n\tif got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_surrogatePair_invalid_first_55(t *testing.T) {\n\ts := \"\\\\uD83D\\\\uDE01\\\\\"\n\twant := \"\\\\uD83D\\\\uDE01\\\\\"\n\tgot := unescapeStringBestEffort(s)\n\tif got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_surrogatePair_invalid_first_56(t *testing.T) {\n\ts := \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\"\n\twant := \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\"\n\tgot := unescapeStringBestEffort(s)\n\tif got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_surrogatePair_invalid_first_57(t *testing.T) {\n\ts := \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE\"\n\twant := \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE\"\n\tgot := unescapeStringBestEffort(s)\n\tif got != want {\n\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, want)\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_surrogatePair_invalid_first_58(t *testing.T) {\n\ts := \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\u\"\n\twant :=","9e07e1684a9175571829fc4b6c2848ae":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGet(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant *Value\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.Get(tt.args.keys...); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Get() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","9e0ed56369c9670fc81d5c33642bb3d0":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWS(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no whitespace\",\n\t\t\targs: args{s: \"abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace\",\n\t\t\targs: args{s: \"  abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailing whitespace\",\n\t\t\targs: args{s: \"abc  \"},\n\t\t\twant: \"abc  \",\n\t\t},\n\t\t{\n\t\t\tname: \"leading and trailing whitespace\",\n\t\t\targs: args{s: \"  abc  \"},\n\t\t\twant: \"abc  \",\n\t\t},\n\t\t{\n\t\t\tname: \"internal whitespace\",\n\t\t\targs: args{s: \"a b c\"},\n\t\t\twant: \"a b c\",\n\t\t},\n\t\t{\n\t\t\tname: \"mixed whitespace\",\n\t\t\targs: args{s: \"\\t\\r\\n abc \\t\\r\\n\"},\n\t\t\twant: \"abc \\t\\r\\n\",\n\t\t},\n\t\t{\n\t\t\tname: \"special characters\",\n\t\t\targs: args{s: \"abc\\t\\r\\n!@#$%^\u0026*()_+=-`~[]{};':\\\",./\u003c\u003e?|\"},\n\t\t\twant: \"abc\\t\\r\\n!@#$%^\u0026*()_+=-`~[]{};':\\\",./\u003c\u003e?|\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWS(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWS() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","9e524aa14aefac4ab3ed67beab293c90":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no whitespace\",\n\t\t\targs: args{s: \"hello\"},\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace\",\n\t\t\targs: args{s: \"  hello\"},\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailing whitespace\",\n\t\t\targs: args{s: \"hello  \"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"whitespace in the middle\",\n\t\t\targs: args{s: \"hello  world\"},\n\t\t\twant: \"world\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple whitespace\",\n\t\t\targs: args{s: \"  hello   world   \"},\n\t\t\twant: \"world\",\n\t\t},\n\t\t{\n\t\t\tname: \"mixed whitespace\",\n\t\t\targs: args{s: \" \\t\\n\\rhello \\t\\n\\rworld\\t\\n\\r \"},\n\t\t\twant: \"world\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","9ecd12b15090c9fb41c1b44b254548bd":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\"`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n","9f53176c39cd51e97ea861dcb0f5391f":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantV  *Value\n\t\twantTail string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t\tc: \u0026cache{},\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"too deep\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\": \"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: \u0026Value{t: TypeString, s: \"value\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantTail: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"value1\", \"value2\"]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"value1\"},\n\t\t\t\t\t{t: TypeString, s: \"value2\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantTail: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"value\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"value\",\n\t\t\t},\n\t\t\twantTail: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   \"true\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV:  valueTrue,\n\t\t\twantTail: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   \"false\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV:  valueFalse,\n\t\t\twantTail: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   \"null\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV:  valueNull,\n\t\t\twantTail: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   \"123\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantTail: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"number with decimal\",\n\t\t\targs: args{\n\t\t\t\ts:   \"123.456\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twantTail: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"number with exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   \"1.23e+4\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twantTail: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"number with negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts:   \"1.23e-4\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"1.23e-4\",\n\t\t\t},\n\t\t\twantTail: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   \"NaN\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twantTail: \"\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotV, gotTail, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr \u0026\u0026 !reflect.DeepEqual(gotV, tt.wantV) {\n\t\t\t\tt.Errorf(\"parseValue() gotV = %v, want %v\", gotV, tt.wantV)\n\t\t\t}\n\t\t\tif !tt.wantErr \u0026\u0026 gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseValue() gotTail = %v, want %v\", gotTail, tt.wantTail)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseValue_RawString(t *testing.T) {\n\tc := \u0026cache{}\n\ts := `\"hello, world!\"`\n\tv, tail, err := parseValue(s, c, 0)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif tail != \"\" {\n\t\tt.Errorf(\"Expected empty tail, got %s\", tail)\n\t}\n\tif v.t != typeRawString {\n\t\tt.Errorf(\"Expected typeRawString, got %v\", v.t)\n\t}\n\tif v.s != \"hello, world!\" {\n\t\tt.Errorf(\"Expected 'hello, world!', got %s\", v.s)\n\t}\n}\n\nfunc TestParseValue_Invalid(t *testing.T) {\n\tc := \u0026cache{}\n\ttests := []string{\n\t\t\"{\",\n\t\t\"[\",\n\t\t`\"`,\n\t\t\"t\",\n\t\t\"f\",\n\t\t\"n\",\n\t\t\"1\",\n\t\t\".\",\n\t\t\"e\",\n\t\t\"+\",\n\t\t\"-\",\n\t\t\"1+\",\n\t\t\"1-\",\n\t\t\"1e\",\n\t\t\"1.\",\n\t}\n\tfor _, s := range tests {\n\t\tt.Run(fmt.Sprintf(\"test %s\", s), func(t *testing.T) {\n\t\t\t_, _, err := parseValue(s, c, 0)\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"Expected error for %s\", s)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseValue_JSON(t *testing.T) {\n\tc := \u0026cache{}\n\tjsonStr := `{\n\t\t\"key1\": \"value1\",\n\t\t\"key2\": [1, 2, 3],\n\t\t\"key3\": {\n\t\t\t\"key4\": true,\n\t\t\t\"key5\": null\n\t\t}\n\t}`\n\tvar expected map[string]interface{}\n\tif err := json.Unmarshal([]byte(jsonStr), \u0026expected); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tv, _, err := parseValue(jsonStr, c, 0)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif v.t != TypeObject {\n\t\tt.Errorf(\"Expected object, got %v\", v.t)\n\t}\n\tfor key, value := range expected {\n\t\tif !v.Exists(key) {\n\t\t\tt.Errorf(\"Key %s not found\", key)\n\t\t\tcontinue\n\t\t}\n\t\tswitch value.(type) {\n\t\tcase string:\n\t\t\tif v.GetString(key) != value {\n\t\t\t\tt.Errorf(\"Expected %v for key %s, got %v\", value, key, v.GetString(key))\n\t\t\t}\n\t\tcase []interface{}:\n\t\t\tarr, err := v.GetArray(key)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Error getting array for key %s: %v\", key, err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif len(arr) != len(value.([]interface{})) {\n\t\t\t\tt.Errorf(\"Expected array length %d for key %s, got %d\", len(value.([]interface{})), key, len(arr))\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfor i, val := range value.([]interface{}) {\n\t\t\t\tswitch val.(type) {\n\t\t\t\tcase float64:\n\t\t\t\t\tif arr[i].GetFloat64() != val {\n\t\t\t\t\t\tt.Errorf(\"Expected %v for key %s[%d], got %v\", val, key, i, arr[i].GetFloat64())\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tt.Errorf(\"Unsupported type %T for key %s[%d]\", val, key, i)\n\t\t\t\t}\n\t\t\t}\n\t\tcase map[string]interface{}:\n\t\t\tobj, err := v.GetObject(key)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Error getting object for key %s: %v\", key, err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfor k, val := range value.(map[string]interface{}) {\n\t\t\t\tswitch val.(type) {\n\t\t\t\tcase bool:\n\t\t\t\t\tif obj.GetBool(k) != val {\n\t\t\t\t\t\tt.Errorf(\"Expected %v for key %s[%s], got %v\", val, key, k, obj.GetBool(k))\n\t\t\t\t\t}\n\t\t\t\tcase nil:\n\t\t\t\t\tif !obj.Exists(k) {\n\t\t\t\t\t\tt.Errorf(\"Expected key %s[%s] to exist\", key, k)\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tt.Errorf(\"Unsupported type %T for key %s[%s]\", val, key, k)\n\t\t\t\t}\n\t\t\t}\n\t\tdefault:\n\t\t\tt.Errorf(\"Unsupported type %T for key %s\", value, key)\n\t\t}\n\t}\n}\n","9f91440c10436878372c66e4c407c431":"package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n)\n\nfunc TestEscapeString(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\ts   string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\ts:   \"\",\n\t\t\t},\n\t\t\twant: []byte(`\"\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\ts:   \"hello\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"string with special characters\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\ts:   \"hello world!\",\n\t\t\t},\n\t\t\twant: []byte(`\"hello world!\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped characters\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\ts:   `\\n\\t\\r\\b\\f\"`,\n\t\t\t},\n\t\t\twant: []byte(`\"\\\\n\\\\t\\\\r\\\\b\\\\f\\\\\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"string with unicode characters\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\ts:   \"こんにちは\",\n\t\t\t},\n\t\t\twant: []byte(`\"こんにちは\"`),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := escapeString(tt.args.dst, tt.args.s); !bytesEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"escapeString() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc bytesEqual(a, b []byte) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","9fedd9038220768c2bac39e510f99dc1":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCacheGetValue(t *testing.T) {\n\tc := \u0026cache{}\n\tv := c.getValue()\n\tif v == nil {\n\t\tt.Errorf(\"getValue() returned nil, expected a pointer to Value\")\n\t}\n}","a0373d3677e79e645b6cf3ae1430e524":"```go\npackage fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[]\",\n\t\t\t\tc:   \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"single element array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[1]\",\n\t\t\t\tc:   \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[1,2,3]\",\n\t\t\t\tc:   \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[[1,2],[3,4]]\",\n\t\t\t\tc:   \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"4\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[\\\"hello\\\",\\\"world\\\"]\",\n\t\t\t\tc:   \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"hello\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"world\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with object\",\n\t\t\targs: args{\n\t\t\t\ts:   `[{\"name\":\"John\",\"age\":30},{\"name\":\"Jane\",\"age\":25}]`,\n\t\t\t\tc:   \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tk: \"name\",\n\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\ts: \"John\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tk: \"age\",\n\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\t\ts: \"30\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tk: \"name\",\n\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\tt: TypeString,","a0be294fe6b017709180cd40c5a0fee5":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetFloat64(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.GetFloat64(tt.args.keys...); got != tt.want {\n\t\t\t\tt.Errorf(\"Value.GetFloat64() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","a182a5363911766a168f3e7aaec2dfd7":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\tv   *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.v.MarshalTo(tt.args.dst); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","a1999ce8c66e2667b511eb94b5a41394":"```go\npackage fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"simple number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative number\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"decimal number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.45\",\n\t\t\t},\n\t\t\twantNs:  \"123.45\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponent number\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e+45\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e+45\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inf\",\n\t\t\targs","a1df8c3e567b7b354393345c6fe5b1af":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGet(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant *Value\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.Get(tt.args.keys...); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Get() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","a235cfa8a800f97d978cf0010f204605":"```go\npackage fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"{}\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"parse object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{\\\"key\\\":\\\"value\\\"}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"parse array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[\\\"value1\\\",\\\"value2\\\"]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"parse string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\\\"value\\\"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"value\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"parse true\",\n\t\t\targs: args{\n\t\t\t\ts:   \"true\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueTrue,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"parse false\",\n\t\t\targs: args{\n\t\t\t\ts:   \"false\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueFalse,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"parse null\",\n\t\t\targs: args{\n\t\t\t\ts:   \"null\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueNull,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"parse number\",\n\t\t\targs: args{\n\t\t\t\ts:   \"123\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"parse NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   \"NaN\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseValue() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_parseValue_InvalidValue(t *testing.T) {\n\ttests := []string{\n\t\t\"truee\",\n\t\t\"fals\",\n\t\t\"nul\",\n\t\t\"123e\",\n\t\t\"123+\",\n\t\t\"123-\",\n\t\t\"123.\",\n\t\t\"123.\",\n\t\t\"123..\",\n\t\t\"123.e\",\n\t\t\"123.e+\",\n\t\t\"123.e-\",\n\t\t\"123.e+\",\n\t\t\"123.e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t\"123e-\",\n\t\t\"123e+\",\n\t\t","a25d25f02f8b86580274389aa74aef8f":"```go\npackage fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantV   *Value\n\t\twantTail string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV:   nil,\n\t\t\twantTail: \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twantV:   nil,\n\t\t\twantTail: \"{}\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": 2}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"2\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[1, \"2\", true]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeString, s: \"2\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"hello world\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello world\",\n\t\t\t},\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   \"true\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV:   valueTrue,\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   \"false\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV:   valueFalse,\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   \"null\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV:   valueNull,\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   \"123.456\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\ts:   \"NaN\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected value\",\n\t\t\targs: args{\n\t\t\t\ts:   \"abc\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV:   nil,","a26b80d5cf03fc8984eb5057109c119c":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdep int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantV  *Value\n\t\twantT  Type\n\t\twantS  string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"parse empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdep: 0,\n\t\t\t},\n\t\t\twantV:  nil,\n\t\t\twantT:  TypeNull,\n\t\t\twantS:  \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"parse object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\":\"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdep: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: \u0026Value{t: TypeString, s: \"value\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantT:  TypeObject,\n\t\t\twantS:  \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"parse array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[1,2,3]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdep: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantT:  TypeArray,\n\t\t\twantS:  \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"parse string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"hello\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdep: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twantT:  TypeString,\n\t\t\twantS:  \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"parse true\",\n\t\t\targs: args{\n\t\t\t\ts:   `true`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdep: 0,\n\t\t\t},\n\t\t\twantV:  valueTrue,\n\t\t\twantT:  TypeTrue,\n\t\t\twantS:  \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"parse false\",\n\t\t\targs: args{\n\t\t\t\ts:   `false`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdep: 0,\n\t\t\t},\n\t\t\twantV:  valueFalse,\n\t\t\twantT:  TypeFalse,\n\t\t\twantS:  \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"parse null\",\n\t\t\targs: args{\n\t\t\t\ts:   `null`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdep: 0,\n\t\t\t},\n\t\t\twantV:  valueNull,\n\t\t\twantT:  TypeNull,\n\t\t\twantS:  \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"parse number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdep: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantT:  TypeNumber,\n\t\t\twantS:  \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"parse NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   `NaN`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdep: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twantT:  TypeNumber,\n\t\t\twantS:  \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"parse too deep object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\":\"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdep: MaxDepth,\n\t\t\t},\n\t\t\twantV:  nil,\n\t\t\twantT:  TypeNull,\n\t\t\twantS:  \"\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotV, gotT, err := parseValue(tt.args.s, tt.args.c, tt.args.dep)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotV != nil {\n\t\t\t\tif gotV.t != tt.wantT {\n\t\t\t\t\tt.Errorf(\"parseValue() gotV.t = %v, want %v\", gotV.t, tt.wantT)\n\t\t\t\t}\n\t\t\t\tif gotV.s != tt.wantS {\n\t\t\t\t\tt.Errorf(\"parseValue() gotV.s = %v, want %v\", gotV.s, tt.wantS)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif tt.wantV != nil {\n\t\t\t\t\tt.Errorf(\"parseValue() gotV = %v, want %v\", gotV, tt.wantV)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_parseValue_invalid_value(t *testing.T) {\n\tc := \u0026cache{}\n\t_, _, err := parseValue(\"invalid\", c, 0)\n\tif err == nil {\n\t\tt.Errorf(\"parseValue() expected an error, got nil\")\n\t}\n\t_, _, err = parseValue(\"tr\", c, 0)\n\tif err == nil {\n\t\tt.Errorf(\"parseValue() expected an error, got nil\")\n\t}\n\t_, _, err = parseValue(\"fal\", c, 0)\n\tif err == nil {\n\t\tt.Errorf(\"parseValue() expected an error, got nil\")\n\t}\n\t_, _, err = parseValue(\"nu\", c, 0)\n\tif err == nil {\n\t\tt.Errorf(\"parseValue() expected an error, got nil\")\n\t}\n}\n\nfunc Test_parseValue_string_escape_sequences(t *testing.T) {\n\tc := \u0026cache{}\n\tcases := []string{\n\t\t`\"hello\\\\\"world\"`,\n\t\t`\"hello\\\\/world\"`,\n\t\t`\"hello\\\\bworld\"`,\n\t\t`\"hello\\\\fworld\"`,\n\t\t`\"hello\\\\nworld\"`,\n\t\t`\"hello\\\\rworld\"`,\n\t\t`\"hello\\\\tworld\"`,\n\t\t`\"hello\\\\\\\\world\"`,\n\t}\n\tfor _, s := range cases {\n\t\tv, _, err := parseValue(s, c, 0)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"parseValue() error = %v\", err)\n\t\t\tcontinue\n\t\t}\n\t\tif v.t != TypeString {\n\t\t\tt.Errorf(\"parseValue() gotV.t = %v, want %v\", v.t, TypeString)\n\t\t}\n\t\tif v.s != unescapeStringBestEffort(s[1:len(s)-1]) {\n\t\t\tt.Errorf(\"parseValue() gotV.s = %v, want %v\", v.s, unescapeStringBestEffort(s[1:len(s)-1]))\n\t\t}\n\t}\n}\n\nfunc Test_parseValue_string_unicode_escape_sequences(t *testing.T) {\n\tc := \u0026cache{}\n\tcases := []string{\n\t\t`\"\\u0061\"`,\n\t\t`\"\\u0041\"`,\n\t\t`\"\\u00e1\"`,\n\t\t`\"\\u00E1\"`,\n\t}\n\tfor _, s := range cases {\n\t\tv, _, err := parseValue(s, c, 0)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"parseValue() error = %v\", err)\n\t\t\tcontinue\n\t\t}\n\t\tif v.t != TypeString {\n\t\t\tt.Errorf(\"parseValue() gotV.t = %v, want %v\", v.t, TypeString)\n\t\t}\n\t\texpected, _ := json.Marshal(unescapeStringBestEffort(s[1:len(s)-1]))\n\t\tif v.s != string(expected) {\n\t\t\tt.Errorf(\"parseValue() gotV.s = %v, want %v\", v.s, string(expected))\n\t\t}\n\t}\n}\n\nfunc Benchmark_parseValue(b *testing.B) {\n\tc := \u0026cache{}\n\tfor i := 0; i \u003c b.N; i++ {\n\t\tparseValue(`{\"key\":\"value\"}`, c, 0)\n\t}\n}\n\nfunc Benchmark_parseValue_string(b *testing.B) {\n\tc := \u0026cache{}\n\tfor i := 0; i \u003c b.N; i++ {\n\t\tparseValue(`\"hello world\"`, c, 0)\n\t}\n}\n\nfunc Benchmark_parseValue_number(b *testing.B) {\n\tc := \u0026cache{}\n\tfor i := 0; i \u003c b.N; i++ {\n\t\tparseValue(`1234567890`, c, 0)\n\t}\n}\n\nfunc Benchmark_parseValue_true(b *testing.B) {\n\tc := \u0026cache{}\n\tfor i := 0; i \u003c b.N; i++ {\n\t\tparseValue(`true`, c, 0)\n\t}\n}\n\nfunc Benchmark_parseValue_false(b *testing.B) {\n\tc := \u0026cache{}\n\tfor i := 0; i \u003c b.N; i++ {\n\t\tparseValue(`false`, c, 0)\n\t}\n}\n\nfunc Benchmark_parseValue_null(b *testing.B) {\n\tc := \u0026cache{}\n\tfor i := 0; i \u003c b.N; i++ {\n\t\tparseValue(`null`, c, 0)\n\t}\n}\n\nfunc Benchmark_parseValue_array(b *testing.B) {\n\tc := \u0026cache{}\n\tfor i := 0; i \u003c b.N; i++ {\n\t\tparseValue(`[1,2,3,4,5,6,7,8,9,10]`, c, 0)\n\t}\n}\n\nfunc Benchmark_parseValue_empty_string(b *testing.B) {\n\tc := \u0026cache{}\n\tfor i := 0; i \u003c b.N; i++ {\n\t\tparseValue(``, c, 0)\n\t}\n}\n\nfunc Benchmark_parseValue_empty_array(b *testing.B) {\n\tc := \u0026cache{}\n\tfor i := 0; i \u003c b.N; i++ {\n\t\tparseValue(`[]`, c, 0)\n\t}\n}\n\nfunc Benchmark_parseValue_empty_object(b *testing.B) {\n\tc := \u0026cache{}\n\tfor i := 0; i \u003c b.N; i++ {\n\t\tparseValue(`{}`, c, 0)\n\t}\n}\n","a26ff4e2909ed2e5edc90ee00447e0ab":"package fastjson\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\tv   *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"RawString\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: typeRawString, s: \"hello\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"Object\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"foo\", v: \u0026Value{t: TypeString, s: \"bar\"}}}}},\n\t\t\t},\n\t\t\twant: []byte(\"{\\\"foo\\\":\\\"bar\\\"}\"),\n\t\t},\n\t\t{\n\t\t\tname: \"Array\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeArray, a: []*Value{{t: TypeString, s: \"foo\"}, {t: TypeString, s: \"bar\"}}},\n\t\t\t},\n\t\t\twant: []byte(\"[\\\"foo\\\",\\\"bar\\\"]\"),\n\t\t},\n\t\t{\n\t\t\tname: \"String\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeString, s: \"hello\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"Number\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t},\n\t\t\twant: []byte(\"123\"),\n\t\t},\n\t\t{\n\t\t\tname: \"True\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeTrue},\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"False\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeFalse},\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"Null\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNull},\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.v.MarshalTo(tt.args.dst); !bytes.Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","a2c3d304cfd86c61fd58859dae8a49a4":"```go\npackage fastjson\n\nimport (\n\t\"encoding/json\"\n","a2f4f8f4570d0c7dbc3af7e259d2ec73":"```go\npackage fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"strconv\"\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"abcdefg\"},\n\t\t\twant: \"abcdefg\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: `\\\"abcdefg\\\"\"`},\n\t\t\twant: `\"abcdefg\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: `\\\\abcdefg\\\\`},\n\t\t\twant: `\\abcdefg\\`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: `\\/abcdefg\\/`},\n\t\t\twant: `/abcdefg/`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: `\\babcdefg\\b`},\n\t\t\twant: \"\\babcdefg\\b\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: `\\fabcdefg\\f`},\n\t\t\twant: \"\\fabcdefg\\f\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: `\\nabcdefg\\n`},\n\t\t\twant: \"\\nabcdefg\\n\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: `\\rabcdefg\\r`},\n\t\t\twant: \"\\rabcdefg\\r\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: `\\tabcdefg\\t`},\n\t\t\twant: \"\\tabcdefg\\t\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: `\\u0061\\u0062\\u0063\\u0064\\u0065\\u0066\\u0067`},\n\t\t\twant: \"abcdefg\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode surrogate pair\",\n\t\t\targs: args{s: `\\uD83D\\uDE03`},\n\t\t\twant: \"😊\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode invalid\",\n\t\t\targs: args{s: `\\u0061\\u0062\\u0063\\u0064\\u0065\\u0066\\u0067\\u0068\\u0069\\u006a\\u006b\\u006c\\u006d\\u006e\\u006f\\u0070\\u0071\\u0072\\u0073\\u0074\\u0075\\u0076\\u0077\\u0078\\u0079\\u007a\\u0030\\u0031\\u0032\\u0033\\u0034\\u0035\\u0036\\u0037\\u0038\\u0039\\u0041\\u0042\\u0043\\u0044\\u0045\\u0046\\u0047\\u0048\\u0049\\u004a\\u004b\\u004c\\u004d\\u004e\\u004f\\u0050\\u0051\\u0052\\u0053\\u0054\\u0055\\u0056\\u0057\\u0058\\u0059\\u005a\\u0061\\u0062\\u0063\\u0064\\u0065\\u0066\\u0067\\u0068\\u0069\\u006a\\u006b\\u006c\\u006d\\u006e\\u006f\\u0070\\u0071\\u0072\\u0073\\u0074\\u0075\\u0076\\u0077\\u0078\\u0079\\u007a\\u0030\\u0031\\u0032\\u0033\\u0034\\u0035\\u0036\\u0037\\u0038\\u0039\\u0041\\u0042\\u0043\\u0044\\u0045\\u0046\\u0047\\u0048\\u0049\\u004a\\u004b\\u004c\\u004d\\u004e\\u004f\\u0050\\u0051\\u0052\\u0053\\u0054\\u0055\\u0056\\u0057\\u0058\\u0059\\u005a\\u0061\\u0062\\u0063\\u0064\\u0065\\u0066\\u0067\\u0068\\u0069\\u006a\\u006b\\u006c\\u006d\\u006e\\u006f\\u0070\\u0071\\u0072\\u0073\\u0074\\u0075\\u0076\\u0077\\u0078\\u0079\\u007a\\u0030\\u0031\\u0032\\u0033\\u0034\\u0035\\u0036\\u0037\\u0038\\u0039\\u0041\\u0042\\u0043\\u0044\\u0045\\u0046\\u0047\\u0048\\u0049\\u004a\\u004b\\u004c\\u004d\\u004e\\u004f\\u0050\\u0051\\u0052\\u0053\\u0054\\u0055\\u0056\\u0057\\u0058\\u0059\\u005a\\u0061\\u0062\\u0063\\u0064\\u0065\\u0066\\u0067\\u0068\\u0069\\u006a\\u006b\\u006c\\u006d\\u006e\\u006f\\u0070\\u0071\\u0072\\u0073\\u0074\\u0075\\u0076\\u0077\\u0078\\u0079\\u007a\\u0030\\u0031\\u0032\\u0033\\u0034\\u0035\\u0036\\u0037\\u0038\\u0039\\u0041\\u0042\\u0043\\u0044\\u0045\\u0046\\u0047\\u0048\\u0049\\u004a\\u004b\\u004c\\u004d\\u004e\\u004f\\u0050\\u0051\\u0052\\u0053\\u0054\\u0055\\u0056\\u0057\\u0058\\u0059\\u005a\\u0061\\u0062\\u0063\\u0064\\u0065\\u0066\\u0067\\u0068\\u0069\\u006a\\u006b\\u006c\\u006d\\u006e\\u006f\\u0070\\u0071\\u0072\\u0073\\u0074\\u0075\\u0076\\u0077\\u0078\\u0079\\u007a\\u0030\\u0031\\u0032\\u0033\\u0034\\u0035\\u0036\\u0037\\u0038\\u0039\\u0041\\u0042\\u0043\\u0044\\u0045\\u0046\\u0047\\u0048\\u0049\\u004a\\u004b\\u004c\\u004d\\u004e\\u004f\\u0050\\u0051\\u0052\\u0053\\u0054\\u0055\\u0056\\u0057\\u0058\\u0059\\u005a\\u0061\\u0062\\u0063\\u0064\\u0065\\u0066\\u0067\\u0068\\u0069\\u006a\\u006b\\u006c\\u006d\\u006e\\u006f\\u0070\\u0071\\u0072\\u0073\\u0074\\u0075\\u0076\\u0077\\u0078\\u0079\\u007a\\u0030\\u0031\\u0032\\u0033\\u0034\\u0035\\u0036\\u0037\\u0038\\u0039\\u0041\\u0042\\u0043\\u0044\\u0045\\u0046\\u0047\\u0048\\u0049\\u004a\\u004b\\u004c\\u004d\\u004e\\u004f\\u0050\\u0051\\u0052\\u0053\\u0054\\u0055\\u0056\\u0057\\u0058\\u0059\\u005a\\u0061\\u0062\\u0063\\u0064\\u0065\\u0066\\u0067\\u0068\\u0069\\u006a\\u006b\\u006c\\u006d\\u006e\\u006f\\u0070\\u0071\\u0072\\u0073\\u0074\\u0075\\u0076\\u0077\\u0078\\u0079\\u007a\\u0030\\u0031\\u0032\\u0033\\u0034\\u0035\\u0036\\u0037\\u0038\\u0039\\u0041\\u0042\\u0043\\u0044\\u0045\\u0046\\u0047\\u0048\\u0049\\u004a\\u004b\\u004c\\u004d\\u004e\\u004f\\u0050\\u0051\\u0052\\u0053\\u0054\\u0055\\u0056\\u0057\\u0058\\u0059\\u005a\\u0061\\u0062\\u0063\\u0064\\u0065\\u0066\\u0067\\u0068\\u0069\\u006a\\u006b\\u006c\\u006d\\u006e\\u006f\\u0070\\u0071\\u0072\\u0073\\u0074\\u0075\\u0076\\u0077\\u0078\\u0079\\u007a\\u0030\\u0031\\u0032\\u0033\\u0034\\u0035\\u0036\\u0037\\u0038\\u0039\\u0041\\u0042\\u0043\\u0044\\u0045\\u0046\\u0047\\u0048\\u0049\\u004a\\u004b\\u004c\\u004d\\u004e\\u004f\\u0050\\u0051\\u0052\\u0053\\u0054\\u0055\\u0056\\u0057\\u0058\\u0059\\u005a\\u0061\\u0062\\u0063\\u0064\\u0065\\u0066\\u0067\\u0068\\u0069\\u006a\\u006b\\u006c\\u006d\\u006e\\u006f\\u0070\\u0071\\u0072\\u0073\\u0074\\u0075\\u0076\\u0077\\u0078\\u0079\\u007a\\u0030\\u0031\\u0032\\u0033\\u0034\\u0035\\u0036\\u0037\\u0038\\u0039\\u0041\\u0042\\u0043\\u0044\\u0045\\u0046\\u0047\\u0048\\u0049\\u004a\\u004b\\u004c\\u004d\\u004e\\u004f\\u0050\\u0051\\u0052\\u0053\\u0054\\u0055\\u0056\\u0057\\u0058\\u0059\\u005a\\u0061\\u0062\\u0063\\u0064\\u0065\\u0066\\u0067\\u0068\\u0069\\u006a\\u006b\\u006c\\u006d\\u006e\\u006f\\u0070\\u0071\\u0072\\u0073\\u0074\\u0075\\u0076\\u0077\\u0078\\u0079\\u007a\\u0030\\u0031\\u0032\\u0033\\u0034\\u0035\\u0036\\u0037\\u0038\\u0039\\u0041\\u0042\\u0043\\u0044\\u0045\\u0046\\u0047\\u0048\\u0049\\u004a\\u004b\\u004c\\u004d\\u004e\\u004f\\u0050\\u0051\\u0052\\u0053\\u0054\\u0055\\u0056\\u0057\\u0058\\u0059\\u005a\\u0061\\u0062\\u0063\\u0064\\u0065\\u0066\\u0067\\u0068\\u0069\\u006a\\u006b\\u006c\\u006d\\u006e\\u006f\\u0070\\u0071\\u0072\\u0073\\u0074\\u0075\\u0076\\u0077\\u0078\\u0079\\u007a\\u0030\\u0031\\u0032\\u0033\\u0034\\u0035\\u0036\\u0037\\u0038\\u0039\\u0041\\u0042\\u0043\\u0044\\u0045\\u0046\\u0047\\u0048\\u0049\\u004a\\u004b\\u004c\\u004d\\u004e\\u004f\\u0050\\u0051\\u0052\\u0053\\u0054\\u0055\\u0056\\u0057\\u0058\\u0059\\u005a\\u0061\\u0062\\u0063\\u0064\\u0065\\u0066\\u0067\\u0068\\u0069\\u006a\\u006b\\u006c\\u006d\\u006e\\u006f\\u0070\\u0071\\u0072\\u0073\\u0074\\u0075\\u0076\\u0077\\u0078\\u0079\\u007a\\u0030\\u0031\\u0032\\u0033\\u0034\\u0035\\u0036\\u0037\\u0038\\u0039\\u0041\\u0042\\u0043\\u0044\\u0045\\u0046\\u0047\\u0048\\u0049\\u004a\\u004b\\u004c\\u004d\\u004e\\u004f\\u0050\\u0051\\u0052\\u0053\\u0054\\u0055\\u0056\\u0057\\u0058\\u0059\\u005a\\u0061\\u0062\\u0063\\u0064\\u0065\\u0066\\u0067\\u0068\\u0069\\u006a\\u006b\\u006c\\u006d\\u006e\\u006f\\u0070\\u0071\\u0072\\u0073\\u0074\\u0075\\u0076\\u0077\\u0078\\u0079\\u007a\\u0030\\u0031\\u0032\\u0033\\u0034\\u0035\\u0036\\u0037\\u0038\\u0039\\u0041\\u0042\\u0043\\u0044\\u0045\\u0046\\u0047\\u0048\\u0049\\u004a\\u004b\\u004c\\u004d\\u004e\\u004f\\u0050\\u0051\\u0052\\u0053\\u0054\\u0055\\u0056\\u0057\\u0058\\u0059\\u005a\\u0061\\u0062\\u0063\\u0064\\u0065\\u0066\\u0067\\u0068\\u0069\\u006a\\u006b\\u006c\\u006d\\u006e\\u006f\\u0070\\u0071\\u0072\\u0073\\u0074\\u0075\\u0076\\u0077\\u0078\\u0079\\u007a\\u0030\\u0031\\u0032\\u0033\\u0034\\u0035\\u0036\\u0037\\u0038\\u0039\\u0041\\u0042\\u0043\\u0044\\u0045\\u0046\\u0047\\u0048\\u0049\\u004a\\u004b\\u004c\\u004d\\u004e\\u004f\\u0050\\u0051\\u0052\\u0053\\u0054\\u0055\\u0056\\u0057\\u0058\\u0059\\u005a\\u0061\\u0062\\u0063\\u0064\\u0065\\u0066\\u0067\\u0068\\u0069\\u006a\\u006b\\u006c\\u006d\\u006e\\u006f\\u0070\\u0071\\u0072\\u0073\\u0074\\u0075\\u0076\\u0077\\u0078\\u0079\\u007a\\u0030\\u0031\\u0032\\u0033\\u0034\\u0035\\u0036\\u0037\\u0038\\u0039\\u0041\\u0042\\u0043\\u0044\\u0045\\u0046\\u0047\\u0048\\u0049\\u004a\\u004b\\u004c\\u004d\\u004e\\u004f\\u0050\\u0051\\u0052\\u0053\\u0054\\u0055\\u0056\\u0057\\u0058\\u0059\\u005a\\u0061\\u0062\\u0063\\u0064\\u0065\\u0066\\u0067\\u0068\\u0069\\u006a\\u006b\\u006c\\u006d\\u006e\\u006f\\u0070\\u0071\\u0072\\u0073\\u0074\\u0075\\u0076\\u0077\\u0078\\u0079\\u007a\\u0030\\u0031\\u0032\\u0033\\u0034\\u0035\\u0036\\u0037\\u0038\\u0039\\u0041\\u0042\\u0043\\u0044\\u0045\\u0046\\u0047\\u0048\\u0049\\u004a\\u004b\\u004c\\u004d\\u004e\\u004f\\u0050\\u0051\\u0052\\u0053\\u0054\\u0055\\u0056\\u0057\\u0058\\u0059\\u005a\\u0061\\u0062\\u0063\\u0064\\u0065\\u0066\\u0067\\u0068\\u0069\\u006a\\u006b\\u006c\\u006d\\u006e\\u006f\\u0070\\u0071\\u0072\\u0073\\u0074\\u0075\\u0076\\u0077\\u0078\\u0079\\u007a\\u0030\\u0031\\u0032\\u0033\\u0034\\u0035\\u0036\\u0037\\u0038\\u0039\\u0041\\u0042\\u0043\\u0044\\u0045\\u0046\\u0047\\u0048\\u0049\\u004a\\u004b\\u004c\\u004d\\u004e\\u004f\\u0050\\u0051\\u0052\\u0053\\u0054\\u0055\\u0056\\u0057\\u0058\\u0059\\u005a\\u0061\\u0062\\u0063\\u0064\\u0065\\u0066\\u0067\\u0068\\u0069\\u006a\\u006b\\u006c\\u006d\\u006e\\u006f\\u0070\\u0071\\u0072\\u0073\\u0074\\u0075\\u0076\\u0077\\u0078\\u0079\\u007a\\u0030\\u0031\\u0032\\u0033\\u0034\\u0035\\u0036\\u0037\\u0038\\u0039\\u0041\\u0042\\u0043\\u0044\\u0045\\u0046\\u0047\\u0048\\u0049\\u004a\\u004b\\u004c\\u004d\\u004e\\u004f\\u0050\\u0051\\u0052\\u0053\\u0054\\u0055\\u0056\\u0057\\u0058\\u0059\\u005a\\u0061\\u0062\\u0063\\u0064\\u0065\\u0066\\u0067\\u0068\\u0069\\u006a\\u006b\\u006c\\u006d\\u006e\\u006f\\u0070\\u0071\\u0072\\u0073\\u0074\\u0075\\u0076\\u0077\\u0078\\u0079\\u007a\\u0030\\u0031\\u0032\\u0033\\u0034\\u0035\\u0036\\u0037\\u0038\\u0039\\u0041\\u0042\\u0043\\u0044\\u0045\\u0046\\u0047\\u0048\\u0049\\u004a\\u004b\\u004c\\u004d\\u004e\\u004f\\u0050\\u0051\\u0052\\u0053\\u0054\\u0055\\u0056\\u0057\\u0058\\u0059\\u005a\\u0061\\u0062\\u0063\\u0064\\u0065\\u0066\\u0067\\u0068\\u0069\\u006a\\u006b\\u006c\\u006d\\u006e\\u006f\\u0070\\u0071\\u0072\\u0073\\u0074\\u0075\\u0076\\u0077\\u0078\\u0079\\u007a\\u0030\\u0031\\u0032\\u0033\\u0034\\u0035\\u0036\\u0037\\u0038\\u0039\\u0041\\u0042\\u0043\\u0044\\u0045\\u0046\\u0047\\u0048\\u0049\\u004a\\u004b\\u004c\\u004d\\u004e\\u004f\\u0050\\u0051\\u0052\\u0053\\u0054\\u0055\\u0056\\u0057\\u0058\\u0059\\u005a\\u0061\\u0062\\u0063\\u0064\\u0065\\u0066\\u0067\\u0068\\u0069\\u006a\\u006b\\u006c\\u006d\\u006e\\u006f\\u0070\\u0071\\u0072\\u0073\\u0074\\u0075\\u0076\\u007","a31ab6e2a85edb4433203a49ee3c665e":"package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello world\"},\n\t\t\twant: \"\\\\hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello world\"},\n\t\t\twant: \"/hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello world\"},\n\t\t\twant: \"\\bhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello world\"},\n\t\t\twant: \"\\fhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello world\"},\n\t\t\twant: \"\\nhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello world\"},\n\t\t\twant: \"\\rhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello world\"},\n\t\t\twant: \"\\thello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061hello world\"},\n\t\t\twant: \"ahello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01hello world\"},\n\t\t\twant: \"😁hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\u00hello world\"},\n\t\t\twant: \"\\\\u00hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\uhello world\"},\n\t\t\twant: \"\\\\uhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex\",\n\t\t\targs: args{s: \"\\\\u00zzhello world\"},\n\t\t\twant: \"\\\\u00zzhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDEzzhello world\"},\n\t\t\twant: \"\\\\uD83D\\\\uDEzzhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\n\\\\u0061\\\\u0062\\\\uD83D\\\\uDE01\\\\u0063\"},\n\t\t\twant: \"\\\"hello\\\" \\\\world\\nabc😁c\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","a33528d332979ee2e87754f0c86d20ab":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"single element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,3]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[[1,2],[3,4]]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"4\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1,2\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"array with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1 2]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1 2]\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseArray() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","a3df68aeb767bb59890390b17452dac4":"```go\npackage fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantV  *Value\n\t\twantS  string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           make([]kv, 0),\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantS:  \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"single key-value pair\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\": \"value\"}`,\n\t\t\t\tc:    \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: \u0026","a3e48b7e8794256346743472b05097d3":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello world\"},\n\t\t\twant: \"\\\\hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello world\"},\n\t\t\twant: \"/hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello world\"},\n\t\t\twant: \"\\bhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello world\"},\n\t\t\twant: \"\\fhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello world\"},\n\t\t\twant: \"\\nhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello world\"},\n\t\t\twant: \"\\rhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello world\"},\n\t\t\twant: \"\\thello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061hello world\"},\n\t\t\twant: \"ahello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello world\"},\n\t\t\twant: \"\\\\xhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01hello world\"},\n\t\t\twant: \"\\U0001F601hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\n\\\\t\\\\u0061\\\\b\\\\f\\\\r\\\\/\"},\n\t\t\twant: \"\\\"hello\\\" \\\\world\\n\\ta\\b\\f\\r/\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestUnescapeStringBestEffort_JSON(t *testing.T) {\n\ttype Test struct {\n\t\tInput string\n\t\tWant  string\n\t}\n\ttests := []Test{\n\t\t{\n\t\t\tInput: `{\"key\": \"value\\\\\\\"\\\\t\\\\n\\\\r\\\\f\\\\b\\\\/\\\\u0061\\\\uD83D\\\\uDE01\"}`,\n\t\t\tWant:  `{\"key\": \"value\\\"\\t\\n\\r\\f\\b/\\a\\U0001F601\"}`,\n\t\t},\n\t\t{\n\t\t\tInput: `{\"key\": \"\\\\\\\\\"}`,\n\t\t\tWant:  `{\"key\": \"\\\\\"}`,\n\t\t},\n\t\t{\n\t\t\tInput: `{\"key\": \"\\\\\"}`,\n\t\t\tWant:  `{\"key\": \"\\\\\"}`,\n\t\t},\n\t\t{\n\t\t\tInput: `{\"key\": \"\\\\u0061\\\\\"}`,\n\t\t\tWant:  `{\"key\": \"a\\\\\"}`,\n\t\t},\n\t\t{\n\t\t\tInput: `{\"key\": \"\\\\uD83D\\\\uDE01\\\\\"}`,\n\t\t\tWant:  `{\"key\": \"\\U0001F601\\\\\"}`,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tvar v map[string]interface{}\n\t\t\terr := json.Unmarshal([]byte(tt.Input), \u0026v)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t}\n\t\t\tgot := unescapeStringBestEffort(tt.Input)\n\t\t\tif got != tt.Want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.Want)\n\t\t\t}\n\t\t\tif got != string(json.Marshal(v)) {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, string(json.Marshal(v)))\n\t\t\t}\n\t\t})\n\t}\n}","a4fba82f647f277618decc132ad6bbbd":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"strconv\"\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: `\\\"hello world\\\"`},\n\t\t\twant: `\"hello world\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: `\\\\hello world\\\\`},\n\t\t\twant: `\\hello world\\`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: `\\/hello world\\/`},\n\t\t\twant: `/hello world/`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: `\\bhello world\\b`},\n\t\t\twant: \"\\bhello world\\b\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: `\\fhello world\\f`},\n\t\t\twant: \"\\fhello world\\f\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: `\\nhello world\\n`},\n\t\t\twant: \"\\nhello world\\n\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: `\\rhello world\\r`},\n\t\t\twant: \"\\rhello world\\r\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: `\\thello world\\t`},\n\t\t\twant: \"\\thello world\\t\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: `\\u0061hello world\\u0062`},\n\t\t\twant: \"ahello worldb\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode surrogate\",\n\t\t\targs: args{s: `\\uD83D\\uDE01hello world`},\n\t\t\twant: \"😁hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid sequence\",\n\t\t\targs: args{s: `\\u0061hello world\\u00xx`},\n\t\t\twant: `\\u0061hello world\\u00xx`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with short sequence\",\n\t\t\targs: args{s: `\\u0061hello world\\u00`},\n\t\t\twant: `\\u0061hello world\\u00`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with incomplete surrogate\",\n\t\t\targs: args{s: `\\uD83Dhello world`},\n\t\t\twant: `\\uD83Dhello world`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid surrogate\",\n\t\t\targs: args{s: `\\uD83D\\uDE01hello world\\uD83D\\uDE02`},\n\t\t\twant: `\\uD83D\\uDE01hello world\\uD83D\\uDE02`,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_unescapeStringBestEffort_json(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"escaped quotes in json\",\n\t\t\targs: args{s: `{\"key\": \"\\\"value\\\"\"}`},\n\t\t\twant: `{\"key\": \"value\"}`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes in json\",\n\t\t\targs: args{s: `{\"key\": \"\\\\value\\\\\"}`},\n\t\t\twant: `{\"key\": \"\\\\value\\\\\"}`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes in json\",\n\t\t\targs: args{s: `{\"key\": \"/value/\"}`},\n\t\t\twant: `{\"key\": \"/value/\"}`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace in json\",\n\t\t\targs: args{s: `{\"key\": \"\\bvalue\\b\"}`},\n\t\t\twant: `{\"key\": \"\\bvalue\\b\"}`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed in json\",\n\t\t\targs: args{s: `{\"key\": \"\\fvalue\\f\"}`},\n\t\t\twant: `{\"key\": \"\\fvalue\\f\"}`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline in json\",\n\t\t\targs: args{s: `{\"key\": \"\\nvalue\\n\"}`},\n\t\t\twant: `{\"key\": \"\\nvalue\\n\"}`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return in json\",\n\t\t\targs: args{s: `{\"key\": \"\\rvalue\\r\"}`},\n\t\t\twant: `{\"key\": \"\\rvalue\\r\"}`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab in json\",\n\t\t\targs: args{s: `{\"key\": \"\\tvalue\\t\"}`},\n\t\t\twant: `{\"key\": \"\\tvalue\\t\"}`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode in json\",\n\t\t\targs: args{s: `{\"key\": \"\\u0061value\\u0062\"}`},\n\t\t\twant: `{\"key\": \"avalueb\"}`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode surrogate in json\",\n\t\t\targs: args{s: `{\"key\": \"\\uD83D\\uDE01value\"}`},\n\t\t\twant: `{\"key\": \"😁value\"}`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid sequence in json\",\n\t\t\targs: args{s: `{\"key\": \"\\u0061value\\u00xx\"}`},\n\t\t\twant: `{\"key\": \"\\u0061value\\u00xx\"}`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with short sequence in json\",\n\t\t\targs: args{s: `{\"key\": \"\\u0061value\\u00\"}`},\n\t\t\twant: `{\"key\": \"\\u0061value\\u00\"}`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with incomplete surrogate in json\",\n\t\t\targs: args{s: `{\"key\": \"\\uD83Dvalue\"}`},\n\t\t\twant: `{\"key\": \"\\uD83Dvalue\"}`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid surrogate in json\",\n\t\t\targs: args{s: `{\"key\": \"\\uD83D\\uDE01value\\uD83D\\uDE02\"}`},\n\t\t\twant: `{\"key\": \"\\uD83D\\uDE01value\\uD83D\\uDE02\"}`,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := unescapeStringBestEffort(tt.args.s)\n\n\t\t\t// Check if the unescaped string can be parsed as valid JSON\n\t\t\tvar parsed interface{}\n\t\t\terr := json.Unmarshal([]byte(got), \u0026parsed)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error for %s: %v\", got, err)\n\t\t\t}\n\n\t\t\t// Check if the unescaped string matches the expected string\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","a5b8556bdc21d1ed32652816cb936193":"package fastjson\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\tv   *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNull},\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeTrue},\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeFalse},\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t},\n\t\t\twant: []byte(\"123\"),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeString, s: \"hello\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeArray, a: []*Value{{t: TypeString, s: \"a\"}, {t: TypeNumber, s: \"1\"}}},\n\t\t\t},\n\t\t\twant: []byte(\"[\\\"a\\\",1]\"),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"a\", v: \u0026Value{t: TypeString, s: \"b\"}}, {k: \"c\", v: \u0026Value{t: TypeNumber, s: \"1\"}}}},\n\t\t\t},\n\t\t\twant: []byte(\"{\\\"a\\\":\\\"b\\\",\\\"c\\\":1}\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.v.MarshalTo(tt.args.dst); !bytes.Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","a5e01f7b9aa5ec2f7147d5827f47b853":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestString(t *testing.T) {\n\ttype args struct {\n\t\tt Type\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"TestString_Object\",\n\t\t\targs: args{\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\twant: \"object\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestString_Array\",\n\t\t\targs: args{\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\twant: \"array\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestString_String\",\n\t\t\targs: args{\n\t\t\t\tt: TypeString,\n\t\t\t},\n\t\t\twant: \"string\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestString_Number\",\n\t\t\targs: args{\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\twant: \"number\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestString_True\",\n\t\t\targs: args{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: \"true\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestString_False\",\n\t\t\targs: args{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: \"false\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestString_Null\",\n\t\t\targs: args{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: \"null\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.t.String(); got != tt.want {\n\t\t\t\tt.Errorf(\"String() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","a5e6d71fa8c194773dae5aec918f7650":"```go\npackage fastjson\n\nimport (\n\t\"encoding/json\"\n","a68b8acf83004d4b6f250b3f0d6d4899":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           make([]kv, 0),\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt:  TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt:  TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nested_key1\": \"nested_value1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nested_key1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt:  TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nested_value1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt:  TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\tc:    \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\tc:    \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_JSONMarshal(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    \"{}\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `{\"key1\":\"value1\",\"key2\":\"value2\"}`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nested_key1\": \"nested_value1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `{\"key1\":{\"nested_key1\":\"nested_value1\"},\"key2\":\"value2\"}`,\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgotBytes, err := json.Marshal(got)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"json.Marshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgotStr := string(gotBytes)\n\t\t\tif gotStr != tt.want {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", gotStr, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","a70e42d00ffb9791be3db5ccdfec5efc":"```go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\tv   *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"marshal raw string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: typeRawString,\n\t\t\t\t\ts: \"test string\",\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`\"test string\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal object\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":\"value1\",\"key2\":123}`),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal array\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`[\"value1\",123]`),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeString,\n\t\t\t\t\ts: \"test string\",\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`\"test string\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal number\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"123\",\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`123`),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal true\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeTrue,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`true`),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal false\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeFalse,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`false`),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal null\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeNull,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`null`),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.v.MarshalTo(tt.args.dst); !bytesEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc bytesEqual(a, b []byte","a811fb62916e790dd566077bd6a35109":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestType_String(t *testing.T) {\n\ttype args struct {\n\t\tt Type\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"TypeObject\",\n\t\t\targs: args{\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\twant: \"object\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeArray\",\n\t\t\targs: args{\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\twant: \"array\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeString\",\n\t\t\targs: args{\n\t\t\t\tt: TypeString,\n\t\t\t},\n\t\t\twant: \"string\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeNumber\",\n\t\t\targs: args{\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\twant: \"number\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeTrue\",\n\t\t\targs: args{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: \"true\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeFalse\",\n\t\t\targs: args{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: \"false\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeNull\",\n\t\t\targs: args{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: \"null\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.t.String(); got != tt.want {\n\t\t\t\tt.Errorf(\"Type.String() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","a9e232b93b484e6e3469207334efc237":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCache_GetValue(t *testing.T) {\n\ttype args struct {\n\t\tc *cache\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant *Value\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.c.getValue(); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"cache.getValue() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","aa6b9126a55855fa7d61ff927be5d07b":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_unescapeKeys(t *testing.T) {\n\ttype args struct {\n\t\to *Object\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\ttt.args.o.unescapeKeys()\n\t\t\tif got := tt.args.o.keysUnescaped; got != tt.want {\n\t\t\t\tt.Errorf(\"Object.unescapeKeys() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","aadbb8a32afe4362ea210a5afd1631b3":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueGet(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttype want struct {\n\t\twant *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant want\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.Get(tt.args.keys...); !reflect.DeepEqual(got, tt.want.want) {\n\t\t\t\tt.Errorf(\"Value.Get() = %v, want %v\", got, tt.want.want)\n\t\t\t}\n\t\t})\n\t}\n}","ab7254c63d697a2098f1843de7716d02":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetFloat64(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant float64\n\t}{\n\t\t// TODO: Add test cases.\n\t\t{\n\t\t\tname: \"GetFloat64 from existing key\",\n\t\t\tv:    parseJSON(`{\"key\": 1.234}`, t),\n\t\t\targs: args{keys: []string{\"key\"}},\n\t\t\twant: 1.234,\n\t\t},\n\t\t{\n\t\t\tname: \"GetFloat64 from nested object\",\n\t\t\tv:    parseJSON(`{\"key\": {\"nested_key\": 5.678}}`, t),\n\t\t\targs: args{keys: []string{\"key\", \"nested_key\"}},\n\t\t\twant: 5.678,\n\t\t},\n\t\t{\n\t\t\tname: \"GetFloat64 from array\",\n\t\t\tv:    parseJSON(`{\"key\": [1, 2, 3.456]}`, t),\n\t\t\targs: args{keys: []string{\"key\", \"2\"}},\n\t\t\twant: 3.456,\n\t\t},\n\t\t{\n\t\t\tname: \"GetFloat64 from non-existing key\",\n\t\t\tv:    parseJSON(`{\"key\": 1.234}`, t),\n\t\t\targs: args{keys: []string{\"non_existing_key\"}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"GetFloat64 from invalid value type\",\n\t\t\tv:    parseJSON(`{\"key\": \"string\"}`, t),\n\t\t\targs: args{keys: []string{\"key\"}},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.GetFloat64(tt.args.keys...); got != tt.want {\n\t\t\t\tt.Errorf(\"Value.GetFloat64() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc parseJSON(json string, t *testing.T) *Value {\n\tp := NewParser()\n\tv, err := p.Parse(json)\n\tif err != nil {\n\t\tt.Fatalf(\"Error parsing JSON: %s\", err)\n\t}\n\treturn v\n}","abaa0a9b4a1101f0ffe6fbdd0d47f13e":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no whitespace\",\n\t\t\targs: args{s: \"abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace\",\n\t\t\targs: args{s: \"  abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailing whitespace\",\n\t\t\targs: args{s: \"abc  \"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"whitespace in the middle\",\n\t\t\targs: args{s: \"ab c\"},\n\t\t\twant: \"ab c\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple whitespace\",\n\t\t\targs: args{s: \"  ab  c  \"},\n\t\t\twant: \"ab  c\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading newline\",\n\t\t\targs: args{s: \"\\nabc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailing newline\",\n\t\t\targs: args{s: \"abc\\n\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"newline in the middle\",\n\t\t\targs: args{s: \"ab\\nc\"},\n\t\t\twant: \"c\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading tab\",\n\t\t\targs: args{s: \"\\tabc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailing tab\",\n\t\t\targs: args{s: \"abc\\t\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"tab in the middle\",\n\t\t\targs: args{s: \"ab\\tc\"},\n\t\t\twant: \"c\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading carriage return\",\n\t\t\targs: args{s: \"\\rabc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailing carriage return\",\n\t\t\targs: args{s: \"abc\\r\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"carriage return in the middle\",\n\t\t\targs: args{s: \"ab\\rc\"},\n\t\t\twant: \"c\",\n\t\t},\n\t\t{\n\t\t\tname: \"all whitespace\",\n\t\t\targs: args{s: \" \\t\\n\\r\"},\n\t\t\twant: \"\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","abc7cd4d914a92eeb50b3ac0d0168973":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"empty string\",\n\t\t\targs:    args{s: \"\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"single char\",\n\t\t\targs:    args{s: \"1\"},\n\t\t\twantNs:  \"1\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"multiple char\",\n\t\t\targs:    args{s: \"123\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"decimal number\",\n\t\t\targs:    args{s: \"123.456\"},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"negative number\",\n\t\t\targs:    args{s: \"-123\"},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"exponential number\",\n\t\t\targs:    args{s: \"1.23e+4\"},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"exponential number with minus sign\",\n\t\t\targs:    args{s: \"1.23e-4\"},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"inf\",\n\t\t\targs:    args{s: \"inf\"},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"Inf\",\n\t\t\targs:    args{s: \"Inf\"},\n\t\t\twantNs:  \"Inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"inF\",\n\t\t\targs:    args{s: \"inF\"},\n\t\t\twantNs:  \"inF\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"NaN\",\n\t\t\targs:    args{s: \"NaN\"},\n\t\t\twantNs:  \"NaN\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"nan\",\n\t\t\targs:    args{s: \"nan\"},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"nAn\",\n\t\t\targs:    args{s: \"nAn\"},\n\t\t\twantNs:  \"nAn\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"unexpected char\",\n\t\t\targs:    args{s: \"a123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"a123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"unexpected char at beginning\",\n\t\t\targs:    args{s: \"a123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"a123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"unexpected char at beginning 2\",\n\t\t\targs:    args{s: \"123a\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"unexpected char at beginning 3\",\n\t\t\targs:    args{s: \"123a456\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a456\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"unexpected char at beginning 4\",\n\t\t\targs:    args{s: \"123a456\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a456\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"unexpected char after minus sign\",\n\t\t\targs:    args{s: \"-a123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"-a123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"unexpected char after plus sign\",\n\t\t\targs:    args{s: \"+a123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+a123\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}","abf55f53ceb89bc55eca47b43f24c5c4":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested objects\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"key2\": \"value2\"}, \"key3\": [1, 2, 3]}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{key1: \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{key1: \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_parseObject_EscapedKeys(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"escaped keys\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\", \"key\\\\\"2\\\\\"\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\\\"1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key\\\"2\\\"\", v: \u0026Value{t: TypeString, s: \"value2\"}},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_parseObject_UnescapedKeys(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"unescaped keys\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\"1\": \"value1\", \"key\\\"2\\\"\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\\\"1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key\\\"2\\\"\", v: \u0026Value{t: TypeString, s: \"value2\"}},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: true,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_parseObject_Performance(t *testing.T) {\n\t// Create a large JSON object with 10,000 key-value pairs\n\tdata := make(map[string]interface{}, 10000)\n\tfor i := 0; i \u003c 10000; i++ {\n\t\tdata[fmt.Sprintf(\"key%d\", i)] = fmt.Sprintf(\"value%d\", i)\n\t}\n\tjsonBytes, err := json.Marshal(data)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Benchmark parsing the JSON object\n\tt.Run(\"BenchmarkParseObject\", func(b *testing.B) {\n\t\tc := \u0026cache{}\n\t\tfor i := 0; i \u003c b.N; i++ {\n\t\t\t_, _, err = parseObject(string(jsonBytes), c, 0)\n\t\t\tif err != nil {\n\t\t\t\tb.Fatal(err)\n\t\t\t}\n\t\t}\n\t})\n}","ac3e7c0295a352264e9924a302df5bfd":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantKey string\n\t\twantRem string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"simple key\",\n\t\t\targs:    args{s: `\"key\"`},\n\t\t\twantKey: \"key\",\n\t\t\twantRem: `\"`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"key with escape sequence\",\n\t\t\targs:    args{s: `\"key\\\\\"\"`},\n\t\t\twantKey: \"\",\n\t\t\twantRem: \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"key with spaces\",\n\t\t\targs:    args{s: `\"key with spaces\"`},\n\t\t\twantKey: \"key with spaces\",\n\t\t\twantRem: `\"`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"missing closing quote\",\n\t\t\targs:    args{s: `\"key`},\n\t\t\twantKey: \"\",\n\t\t\twantRem: \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"empty key\",\n\t\t\targs:    args{s: `\"\"`},\n\t\t\twantKey: \"\",\n\t\t\twantRem: `\"\"`,\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotKey, gotRem, err := parseRawKey(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawKey() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotKey != tt.wantKey {\n\t\t\t\tt.Errorf(\"parseRawKey() gotKey = %v, want %v\", gotKey, tt.wantKey)\n\t\t\t}\n\t\t\tif gotRem != tt.wantRem {\n\t\t\t\tt.Errorf(\"parseRawKey() gotRem = %v, want %v\", gotRem, tt.wantRem)\n\t\t\t}\n\t\t})\n\t}\n}","ac7b78a14ebcaa3e2da32258ce951a82":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"single digit\",\n\t\t\targs: args{\n\t\t\t\ts: \"1\",\n\t\t\t},\n\t\t\twantNs:  \"1\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple digits\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative number\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"decimal number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential number\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"123abc\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"abc\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading and trailing characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"abc123def\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"abc123def\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number with spaces\",\n\t\t\targs: args{\n\t\t\t\ts: \"123 456\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \" 456\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with special characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"123!@#$%^\u0026*()_+=-`~\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"!@#$%^\u0026*()_+=-`~\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}","adf277bf36616eaa81aa73858644bb63":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestString(t *testing.T) {\n\ttype args struct {\n\t\tt Type\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"TestObject\",\n\t\t\targs: args{t: TypeObject},\n\t\t\twant: \"object\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestArray\",\n\t\t\targs: args{t: TypeArray},\n\t\t\twant: \"array\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestString\",\n\t\t\targs: args{t: TypeString},\n\t\t\twant: \"string\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestNumber\",\n\t\t\targs: args{t: TypeNumber},\n\t\t\twant: \"number\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestTrue\",\n\t\t\targs: args{t: TypeTrue},\n\t\t\twant: \"true\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestFalse\",\n\t\t\targs: args{t: TypeFalse},\n\t\t\twant: \"false\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestNull\",\n\t\t\targs: args{t: TypeNull},\n\t\t\twant: \"null\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.t.String(); got != tt.want {\n\t\t\t\tt.Errorf(\"String() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","ae0b572cc88c22817952f3cafbbcef57":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttype want struct {\n\t\tv   *Value\n\t\ttail string\n\t\terr  error\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant want\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  fmt.Errorf(\"cannot parse empty string\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth + 1,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"{}\",\n\t\t\t\terr:  fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{ \\\"a\\\": 1 }\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"a\",\n\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[ 1, 2, 3 ]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\\\"hello\\\"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: typeRawString,\n\t\t\t\t\ts: \"hello\",\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   \"true\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueTrue,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   \"false\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueFalse,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   \"null\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueNull,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   \"123\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"123\",\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   \"NaN\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"NaN\",\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected value\",\n\t\t\targs: args{\n\t\t\t\ts:   \"tru\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"tru\",\n\t\t\t\terr:  fmt.Errorf(\"unexpected value found: %q\", \"tru\"),\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotV, gotTail, gotErr := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif gotErr != nil {\n\t\t\t\tif tt.want.err == nil {\n\t\t\t\t\tt.Errorf(\"parseValue() error = %v, want nil\", gotErr)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif gotErr.Error() != tt.want.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue() error = %v, want %v\", gotErr, tt.want.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else if tt.want.err != nil {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, want %v\", gotErr, tt.want.err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !reflect.DeepEqual(gotV, tt.want.v) {\n\t\t\t\tt.Errorf(\"parseValue() gotV = %v, want %v\", gotV, tt.want.v)\n\t\t\t}\n\n\t\t\tif gotTail != tt.want.tail {\n\t\t\t\tt.Errorf(\"parseValue() gotTail = %v, want %v\", gotTail, tt.want.tail)\n\t\t\t}\n\t\t})\n\t}\n}","ae4d8039b488babc11d0ff7d99cdce09":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_getKV(t *testing.T) {\n\ttype args struct {\n\t\to *Object\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant *kv\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.o.getKV(); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Object.getKV() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","ae9123f503428ba5692e3ea27ac17461":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote and other escaped characters\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\t\\\\n\\\\r\\\\b\\\\f\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\t\\n\\r\\b\\f\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: ``,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with no quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `hello`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","ae9693e983789f3217631b97120308a1":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"empty string\",\n\t\t\targs:    args{s: \"\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"single digit\",\n\t\t\targs:    args{s: \"1\"},\n\t\t\twantNs:  \"1\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"multiple digits\",\n\t\t\targs:    args{s: \"123\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"negative number\",\n\t\t\targs:    args{s: \"-123\"},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"positive number\",\n\t\t\targs:    args{s: \"+123\"},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with decimal\",\n\t\t\targs:    args{s: \"123.456\"},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with exponent\",\n\t\t\targs:    args{s: \"123e+456\"},\n\t\t\twantNs:  \"123e+456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with exponent and sign\",\n\t\t\targs:    args{s: \"123e-456\"},\n\t\t\twantNs:  \"123e-456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"inf\",\n\t\t\targs:    args{s: \"inf\"},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"Inf\",\n\t\t\targs:    args{s: \"Inf\"},\n\t\t\twantNs:  \"Inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"inF\",\n\t\t\targs:    args{s: \"inF\"},\n\t\t\twantNs:  \"inF\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"nan\",\n\t\t\targs:    args{s: \"nan\"},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"Nan\",\n\t\t\targs:    args{s: \"Nan\"},\n\t\t\twantNs:  \"Nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"nAn\",\n\t\t\targs:    args{s: \"nAn\"},\n\t\t\twantNs:  \"nAn\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number\",\n\t\t\targs:    args{s: \"123a\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"123a\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading zero\",\n\t\t\targs:    args{s: \"0123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"0123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading plus sign\",\n\t\t\targs:    args{s: \"+123a\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+123a\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}","af10a7f04b7057fbe477a26022125bc6":"```go\npackage fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"he\\\"llo\"`,\n\t\t\t},\n\t\t\twant:    \"he\\\"llo\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},","afef6c05b46268a259be59a5a9fca661":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\tv   *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.v.MarshalTo(tt.args.dst); !bytes.Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","b04b74319d940f0635ec6c3ab0c4f8db":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttype want struct {\n\t\tv   *Value\n\t\ts   string\n\t\terr error\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant want\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{},\n\t\t\t\t},\n\t\t\t\ts:   \"\",\n\t\t\t\terr: nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"single element array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[1]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ts:   \"\",\n\t\t\t\terr: nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[1,2,3]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ts:   \"\",\n\t\t\t\terr: nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"array with nested array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[[1,2],[3,4]]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\ts: \"4\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ts:   \"\",\n\t\t\t\terr: nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"array with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:   `[{\"a\":1},{\"b\":2}]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tk: \"a\",\n\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tk: \"b\",\n\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ts:   \"\",\n\t\t\t\terr: nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"invalid array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[1,2,\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ts:   \"[1,2,\",\n\t\t\t\terr: \u0026ParseError{\n\t\t\t\t\tS: \"[1,2,\",\n\t\t\t\t\tE: \"missing ',' after array value\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[1,2\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ts:   \"[1,2\",\n\t\t\t\terr: \u0026ParseError{\n\t\t\t\t\tS: \"[1,2\",\n\t\t\t\t\tE: \"unexpected end of array\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotV, gotS, gotErr := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif gotErr != nil \u0026\u0026 tt.want.err == nil {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, want nil\", gotErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotErr == nil \u0026\u0026 tt.want.err != nil {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, want %v\", gotErr, tt.want.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotErr != nil \u0026\u0026 tt.want.err != nil {\n\t\t\t\tif gotErr.Error() != tt.want.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseArray() error = %v, want %v\", gotErr, tt.want.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(gotV, tt.want.v) {\n\t\t\t\tt.Errorf(\"parseArray() gotV = %v, want %v\", gotV, tt.want.v)\n\t\t\t}\n\t\t\tif gotS != tt.want.s {\n\t\t\t\tt.Errorf(\"parseArray() gotS = %v, want %v\", gotS, tt.want.s)\n\t\t\t}\n\t\t})\n\t}\n}","b0b5fd686ad16fef8e8d59f74a9f67c4":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueGet(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant *Value\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.Get(tt.args.keys...); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.Get() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","b19489aa7c40cead98db30a214543112":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"empty string\",\n\t\t\targs:    args{s: \"\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"single digit\",\n\t\t\targs:    args{s: \"1\"},\n\t\t\twantNs:  \"1\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"multiple digits\",\n\t\t\targs:    args{s: \"123\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"negative number\",\n\t\t\targs:    args{s: \"-123\"},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"decimal number\",\n\t\t\targs:    args{s: \"123.456\"},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"exponential number\",\n\t\t\targs:    args{s: \"1.23e+4\"},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"exponential number with negative exponent\",\n\t\t\targs:    args{s: \"1.23e-4\"},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"inf\",\n\t\t\targs:    args{s: \"inf\"},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"INF\",\n\t\t\targs:    args{s: \"INF\"},\n\t\t\twantNs:  \"INF\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"nan\",\n\t\t\targs:    args{s: \"nan\"},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"NAN\",\n\t\t\targs:    args{s: \"NAN\"},\n\t\t\twantNs:  \"NAN\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number\",\n\t\t\targs:    args{s: \"123a\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading plus\",\n\t\t\targs:    args{s: \"+123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading minus\",\n\t\t\targs:    args{s: \"-123a\"},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}\n","b23f165790dec92592a71e74e8fd8fd3":"```go\npackage fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,3]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,","b274ce25e34f5619bedd4d1f51c52eb9":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[]\",\n\t\t\t\tc:    \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"single element array\",\n\t\t\targs: args{\n\t\t\t\ts:    `[\"hello\"]`,\n\t\t\t\tc:    \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt:  TypeString,\n\t\t\t\t\t\ts: \"hello\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element array\",\n\t\t\targs: args{\n\t\t\t\ts:    `[\"hello\", \"world\"]`,\n\t\t\t\tc:    \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt:  TypeString,\n\t\t\t\t\t\ts: \"hello\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt:  TypeString,\n\t\t\t\t\t\ts: \"world\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts:    `[[\"hello\", \"world\"], \"!\" ]`,\n\t\t\t\tc:    \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt:  TypeString,\n\t\t\t\t\t\t\t\ts: \"hello\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt:  TypeString,\n\t\t\t\t\t\t\t\ts: \"world\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt:  TypeString,\n\t\t\t\t\t\ts: \"!\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid array\",\n\t\t\targs: args{\n\t\t\t\ts:    `[ \"hello\"`,\n\t\t\t\tc:    \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `[ \"hello\"`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !compareValue(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseArray() = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValue(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !compareValue(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !compareValue(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\tcase TypeString:\n\t\tif v1.s != v2.s {\n\t\t\treturn false\n\t\t}\n\tcase TypeNumber:\n\t\tif v1.s != v2.s {\n\t\t\treturn false\n\t\t}\n\tcase TypeTrue:\n\t\treturn true\n\tcase TypeFalse:\n\t\treturn true\n\tcase TypeNull:\n\t\treturn true\n\tcase typeRawString:\n\t\tif v1.s != v2.s {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","b2c1c16f19f788e01adcb94f55cad0b0":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"Empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": 2}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"key2\": \"value2\"}, \"key3\": [1, 2, 3]}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\"`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\"`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\" \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Invalid key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2: 2}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2: 2}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Invalid value\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": value1}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": value1}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","b2cf84a6aeb0b423ad46a2a92b4babdf":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.MarshalTo(tt.args.dst); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","b450486b468a9852733fdb3976569a3c":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetFloat64(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.GetFloat64(tt.args.keys...); got != tt.want {\n\t\t\t\tt.Errorf(\"Value.GetFloat64() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","b514df76d6af14fc4f444c942cde5ac8":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with whitespace\",\n\t\t\targs: args{s: \"  \\t\\n\\r  \"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with leading whitespace\",\n\t\t\targs: args{s: \"  hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with trailing whitespace\",\n\t\t\targs: args{s: \"hello world  \"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with whitespace in the middle\",\n\t\t\targs: args{s: \"hello  world\"},\n\t\t\twant: \"hello  world\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with no whitespace\",\n\t\t\targs: args{s: \"helloworld\"},\n\t\t\twant: \"helloworld\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with special characters\",\n\t\t\targs: args{s: \"  \\t\\n\\r  hello world!  \\t\\n\\r  \"},\n\t\t\twant: \"hello world!  \\t\\n\\r  \",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","b5ba9e305ed271a13086bb75c92eeb74":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{\\\"a\\\": 1}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"{\\\"a\\\": 1}\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{\\\"a\\\": 1}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"a\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[1, 2]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"hello\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   \"true\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueTrue,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   \"false\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueFalse,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   \"null\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueNull,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   \"123\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   \"NaN\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseValue() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseValue_MarshalJSON(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{\\\"a\\\": 1}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    \"{\\\"a\\\":1}\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[1, 2]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    \"[1,2]\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"hello\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `\"hello\"`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   \"true\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    \"true\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   \"false\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    \"false\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   \"null\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    \"null\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   \"123\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    \"123\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   \"NaN\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    \"NaN\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tb, err := json.Marshal(got)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"json.Marshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif string(b) != tt.want {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", string(b), tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","b649516c92ed84646401f9a0c8be1b42":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGet(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttype want struct {\n\t\twant *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant want\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.Get(tt.args.keys...); !reflect.DeepEqual(got, tt.want.want) {\n\t\t\t\tt.Errorf(\"Get() = %v, want %v\", got, tt.want.want)\n\t\t\t}\n\t\t})\n\t}\n}","b677050dbcec629c8d29f82e2c3f2fd6":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Type(t *testing.T) {\n\ttype args struct {\n\t\tv *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant Type\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.v.Type(); got != tt.want {\n\t\t\t\tt.Errorf(\"Value.Type() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","b702b7f64b16cbf5e64694750a7a6b86":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantKey string\n\t\twantRest string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"empty\",\n\t\t\targs:    args{s: \"\"},\n\t\t\twantKey: \"\",\n\t\t\twantRest: \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"simple\",\n\t\t\targs:    args{s: `\"key\"`},\n\t\t\twantKey: \"key\",\n\t\t\twantRest: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"with_rest\",\n\t\t\targs:    args{s: `\"key\"value`},\n\t\t\twantKey: \"key\",\n\t\t\twantRest: \"value\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"escaped_key\",\n\t\t\targs:    args{s: `\"key\\\\\"\"`},\n\t\t\twantKey: \"key\\\"\",\n\t\t\twantRest: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"missing_closing_quote\",\n\t\t\targs:    args{s: `\"key`},\n\t\t\twantKey: \"\",\n\t\t\twantRest: \"\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotKey, gotRest, err := parseRawKey(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawKey() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotKey != tt.wantKey {\n\t\t\t\tt.Errorf(\"parseRawKey() gotKey = %v, want %v\", gotKey, tt.wantKey)\n\t\t\t}\n\t\t\tif gotRest != tt.wantRest {\n\t\t\t\tt.Errorf(\"parseRawKey() gotRest = %v, want %v\", gotRest, tt.wantRest)\n\t\t\t}\n\t\t})\n\t}\n}","b77435e569aff9b55cf6558a968f476c":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\"world\\\\\\\"\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\\\\\\\"\\\\\\\"\",\n\t\t\twant1:   \"!\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: ``,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with no quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `hello`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","b7a19dad9f8dc44de63625c70135f9cb":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"empty string\",\n\t\t\targs:    args{s: \"\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"single digit\",\n\t\t\targs:    args{s: \"1\"},\n\t\t\twantNs:  \"1\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"multiple digits\",\n\t\t\targs:    args{s: \"123\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"decimal number\",\n\t\t\targs:    args{s: \"123.456\"},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"negative number\",\n\t\t\targs:    args{s: \"-123\"},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"exponential notation\",\n\t\t\targs:    args{s: \"1.23e+4\"},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"exponential notation with minus\",\n\t\t\targs:    args{s: \"1.23e-4\"},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"inf\",\n\t\t\targs:    args{s: \"inf\"},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"INF\",\n\t\t\targs:    args{s: \"INF\"},\n\t\t\twantNs:  \"INF\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"nan\",\n\t\t\targs:    args{s: \"nan\"},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"NAN\",\n\t\t\targs:    args{s: \"NAN\"},\n\t\t\twantNs:  \"NAN\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"leading plus sign\",\n\t\t\targs:    args{s: \"+123\"},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"leading plus sign with space\",\n\t\t\targs:    args{s: \"+ 123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+ 123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"leading plus sign with inf\",\n\t\t\targs:    args{s: \"+inf\"},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"leading plus sign with nan\",\n\t\t\targs:    args{s: \"+nan\"},\n\t\t\twantNs:  \"+nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"leading minus sign with space\",\n\t\t\targs:    args{s: \"- 123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"- 123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid character\",\n\t\t\targs:    args{s: \"123a\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid character at beginning\",\n\t\t\targs:    args{s: \"a123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"a123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid character after decimal\",\n\t\t\targs:    args{s: \"123.456a\"},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid character after e\",\n\t\t\targs:    args{s: \"123e+4a\"},\n\t\t\twantNs:  \"123e+4\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid character after inf\",\n\t\t\targs:    args{s: \"inf123\"},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"123\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid character after nan\",\n\t\t\targs:    args{s: \"nan123\"},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"123\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}","b820683300c14c36357582b48bac4df3":"```go\npackage fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"empty string\",\n\t\t\t","b9027e608afcd64bdeefc42196d68462":"package fastjson\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\tv   *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"String\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeString, s: \"test\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"test\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"Number\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t},\n\t\t\twant: []byte(\"123\"),\n\t\t},\n\t\t{\n\t\t\tname: \"True\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeTrue},\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"False\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeFalse},\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"Null\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNull},\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"RawString\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: typeRawString, s: \"test\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"test\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"Array\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{t: TypeString, s: \"test1\"},\n\t\t\t\t\t\t{t: TypeString, s: \"test2\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"[\\\"test1\\\",\\\"test2\\\"]\"),\n\t\t},\n\t\t{\n\t\t\tname: \"Object\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":\"value1\",\"key2\":\"value2\"}`),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.v.MarshalTo(tt.args.dst); !bytes.Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValueMarshalTo_JSONMarshal(t *testing.T) {\n\ttype args struct {\n\t\tv *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"String\",\n\t\t\targs: args{\n\t\t\t\tv: \u0026Value{t: TypeString, s: \"test\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"test\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"Number\",\n\t\t\targs: args{\n\t\t\t\tv: \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t},\n\t\t\twant: []byte(\"123\"),\n\t\t},\n\t\t{\n\t\t\tname: \"True\",\n\t\t\targs: args{\n\t\t\t\tv: \u0026Value{t: TypeTrue},\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"False\",\n\t\t\targs: args{\n\t\t\t\tv: \u0026Value{t: TypeFalse},\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"Null\",\n\t\t\targs: args{\n\t\t\t\tv: \u0026Value{t: TypeNull},\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"RawString\",\n\t\t\targs: args{\n\t\t\t\tv: \u0026Value{t: typeRawString, s: \"test\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"test\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"Array\",\n\t\t\targs: args{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{t: TypeString, s: \"test1\"},\n\t\t\t\t\t\t{t: TypeString, s: \"test2\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"[\\\"test1\\\",\\\"test2\\\"]\"),\n\t\t},\n\t\t{\n\t\t\tname: \"Object\",\n\t\t\targs: args{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":\"value1\",\"key2\":\"value2\"}`),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tvar buf bytes.Buffer\n\t\t\terr := json.NewEncoder(\u0026buf).Encode(tt.args.v)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"json.Marshal() = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !bytes.Equal(buf.Bytes(), tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", buf.Bytes(), tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","b94c8a675ca01c0e5705f4898a327a1f":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with one element\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,3]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with nested array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[[1,2],[3,4]]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"4\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1,2\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"array with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1 2]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1 2]\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseArray() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","b986d4c589f56a16c52eb378505a2e52":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestType_String(t *testing.T) {\n\ttype args struct {\n\t\tt Type\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"TypeObject\",\n\t\t\targs: args{t: TypeObject},\n\t\t\twant: \"object\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeArray\",\n\t\t\targs: args{t: TypeArray},\n\t\t\twant: \"array\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeString\",\n\t\t\targs: args{t: TypeString},\n\t\t\twant: \"string\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeNumber\",\n\t\t\targs: args{t: TypeNumber},\n\t\t\twant: \"number\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeTrue\",\n\t\t\targs: args{t: TypeTrue},\n\t\t\twant: \"true\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeFalse\",\n\t\t\targs: args{t: TypeFalse},\n\t\t\twant: \"false\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeNull\",\n\t\t\targs: args{t: TypeNull},\n\t\t\twant: \"null\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.t.String(); got != tt.want {\n\t\t\t\tt.Errorf(\"Type.String() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","bae59786f5c861d477ca897b14a101e7":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo_Null(t *testing.T) {\n\tv := \u0026Value{\n\t\tt: TypeNull,\n\t}\n\tdst := []byte{}\n\tresult := v.MarshalTo(dst)\n\texpected := []byte(\"null\")\n\tif !bytesEqual(result, expected) {\n\t\tt.Errorf(\"Expected: %s, Got: %s\", expected, result)\n\t}\n}\n\nfunc TestValueMarshalTo_True(t *testing.T) {\n\tv := \u0026Value{\n\t\tt: TypeTrue,\n\t}\n\tdst := []byte{}\n\tresult := v.MarshalTo(dst)\n\texpected := []byte(\"true\")\n\tif !bytesEqual(result, expected) {\n\t\tt.Errorf(\"Expected: %s, Got: %s\", expected, result)\n\t}\n}\n\nfunc TestValueMarshalTo_False(t *testing.T) {\n\tv := \u0026Value{\n\t\tt: TypeFalse,\n\t}\n\tdst := []byte{}\n\tresult := v.MarshalTo(dst)\n\texpected := []byte(\"false\")\n\tif !bytesEqual(result, expected) {\n\t\tt.Errorf(\"Expected: %s, Got: %s\", expected, result)\n\t}\n}\n\nfunc TestValueMarshalTo_Number(t *testing.T) {\n\tv := \u0026Value{\n\t\tt: TypeNumber,\n\t\ts: \"123\",\n\t}\n\tdst := []byte{}\n\tresult := v.MarshalTo(dst)\n\texpected := []byte(\"123\")\n\tif !bytesEqual(result, expected) {\n\t\tt.Errorf(\"Expected: %s, Got: %s\", expected, result)\n\t}\n}\n\nfunc TestValueMarshalTo_String(t *testing.T) {\n\tv := \u0026Value{\n\t\tt: TypeString,\n\t\ts: \"hello\",\n\t}\n\tdst := []byte{}\n\tresult := v.MarshalTo(dst)\n\texpected := []byte(\"\\\"hello\\\"\")\n\tif !bytesEqual(result, expected) {\n\t\tt.Errorf(\"Expected: %s, Got: %s\", expected, result)\n\t}\n}\n\nfunc TestValueMarshalTo_RawString(t *testing.T) {\n\tv := \u0026Value{\n\t\tt: typeRawString,\n\t\ts: \"hello\",\n\t}\n\tdst := []byte{}\n\tresult := v.MarshalTo(dst)\n\texpected := []byte(\"\\\"hello\\\"\")\n\tif !bytesEqual(result, expected) {\n\t\tt.Errorf(\"Expected: %s, Got: %s\", expected, result)\n\t}\n}\n\nfunc TestValueMarshalTo_Array(t *testing.T) {\n\tv := \u0026Value{\n\t\tt: TypeArray,\n\t\ta: []*Value{\n\t\t\t{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"1\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t},\n\t}\n\tdst := []byte{}\n\tresult := v.MarshalTo(dst)\n\texpected := []byte(\"[1,\\\"hello\\\"]\")\n\tif !bytesEqual(result, expected) {\n\t\tt.Errorf(\"Expected: %s, Got: %s\", expected, result)\n\t}\n}\n\nfunc TestValueMarshalTo_Object(t *testing.T) {\n\to := Object{\n\t\tkvs: []kv{\n\t\t\t{\n\t\t\t\tk: \"key1\",\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"1\",\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tk: \"key2\",\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeString,\n\t\t\t\t\ts: \"hello\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tv := \u0026Value{\n\t\tt: TypeObject,\n\t\to: o,\n\t}\n\tdst := []byte{}\n\tresult := v.MarshalTo(dst)\n\texpected := []byte(\"{\\\"key1\\\":1,\\\"key2\\\":\\\"hello\\\"}\")\n\tif !bytesEqual(result, expected) {\n\t\tt.Errorf(\"Expected: %s, Got: %s\", expected, result)\n\t}\n}\n\nfunc bytesEqual(a, b []byte) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","bae6aaeb6d2dde466a9d225e8b25689e":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\tv   *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.v.MarshalTo(tt.args.dst); !bytes.Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","bba33bd45299023ca8b7a83a78d12329":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"single element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,3]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[[1,2],[3,4]]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"4\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1,2,\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1,2\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseArray() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseArray_JSON(t *testing.T) {\n\ttype testCase struct {\n\t\tjson string\n\t\twant []interface{}\n\t}\n\ttestCases := []testCase{\n\t\t{\n\t\t\tjson: \"[]\",\n\t\t\twant: []interface{}{},\n\t\t},\n\t\t{\n\t\t\tjson: \"[1,2,3]\",\n\t\t\twant: []interface{}{1, 2, 3},\n\t\t},\n\t\t{\n\t\t\tjson: `[\"hello\", \"world\"]`,\n\t\t\twant: []interface{}{\"hello\", \"world\"},\n\t\t},\n\t\t{\n\t\t\tjson: `[{\"key1\": \"value1\"}, {\"key2\": \"value2\"}]`,\n\t\t\twant: []interface{}{\n\t\t\t\tmap[string]interface{}{\"key1\": \"value1\"},\n\t\t\t\tmap[string]interface{}{\"key2\": \"value2\"},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tjson: `[1, [2, 3], 4]`,\n\t\t\twant: []interface{}{1, []interface{}{2, 3}, 4},\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.json, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tv, _, err := parseArray(tc.json, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"parseArray() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tvar got []interface{}\n\t\t\tif err := json.Unmarshal(v.MarshalTo(nil), \u0026got); err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tc.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}","bbd4aacd501b5510c301e28e2c99a7a2":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetStringBytes(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.GetStringBytes(tt.args.keys...); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.GetStringBytes() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","bbe3e673670e6d1a8100b95f3f3b6604":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": 2}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"key2\": \"value2\"}, \"key3\": [1, 2, 3]}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": 2`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": 2`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\" \"value1\", \"key2\": 2}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\", \"key2\": 2}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\" \"key2\": 2}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": 2}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr {\n\t\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t\t}\n\t\t\t\tif got1 != tt.want1 {\n\t\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","bc32bb4bd7cd7c280d27c80f1da62f5b":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"valid integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"valid float\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"valid negative number\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"valid exponential number\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"valid inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"inf\",\n\t\t\t},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"valid nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"nan\",\n\t\t\t},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123a\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and trailing plus sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123+\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"-123+\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and trailing minus sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123-\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and trailing character\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123a\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing plus sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"123+\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with trailing character\",\n\t\t\targs: args{\n\t\t\t\ts: \"123a\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}","bc5d285469a1c0d8fc4ef44b5183d6ea":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[]\",\n\t\t\t\tc:   \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"single element array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"hello\"]`,\n\t\t\t\tc:   \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt:  TypeString,\n\t\t\t\t\t\ts: \"hello\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"hello\", \"world\", 123]`,\n\t\t\t\tc:   \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt:  TypeString,\n\t\t\t\t\t\ts: \"hello\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt:  TypeString,\n\t\t\t\t\t\ts: \"world\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt:  TypeNumber,\n\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[[\"hello\", \"world\"], 123]`,\n\t\t\t\tc:   \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt:  TypeString,\n\t\t\t\t\t\t\t\ts: \"hello\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt:  TypeString,\n\t\t\t\t\t\t\t\ts: \"world\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt:  TypeNumber,\n\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:   `[1, 2, 3`,\n\t\t\t\tc:   \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `[1, 2, 3`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid array value\",\n\t\t\targs: args{\n\t\t\t\ts:   `[1, 2, \"hello\", ]`,\n\t\t\t\tc:   \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `[1, 2, \"hello\", ]`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseArray() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseArray_UnmarshalJSON(t *testing.T) {\n\ttype TestStruct struct {\n\t\tA []interface{}\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tjson string\n\t\twant TestStruct\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\tjson: `{\"A\": []}`,\n\t\t\twant: TestStruct{\n\t\t\t\tA: []interface{}{},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"single element array\",\n\t\t\tjson: `{\"A\": [\"hello\"]}`,\n\t\t\twant: TestStruct{\n\t\t\t\tA: []interface{}{\"hello\"},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element array\",\n\t\t\tjson: `{\"A\": [\"hello\", \"world\", 123]}`,\n\t\t\twant: TestStruct{\n\t\t\t\tA: []interface{}{\"hello\", \"world\", 123},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\tjson: `{\"A\": [[\"hello\", \"world\"], 123]}`,\n\t\t\twant: TestStruct{\n\t\t\t\tA: []interface{}{[]interface{}{\"hello\", \"world\"}, 123},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tvar got TestStruct\n\t\t\terr := json.Unmarshal([]byte(tt.json), \u0026got)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"json.Unmarshal() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","bd08cdc2e23161062627047e003b8850":"```go\npackage fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args","bd43f4fafcaeeba798c3f402040ffc31":"package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello world\",\n\t\t\t},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello world\\\"\",\n\t\t\t},\n\t\t\twant: \"\\\"hello world\\\"\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\hello world\",\n\t\t\t},\n\t\t\twant: \"\\\\hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped slashes\",\n\t\t\targs: args{\n\t\t\t\ts: \"/hello world\",\n\t\t\t},\n\t\t\twant: \"/hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\bhello world\",\n\t\t\t},\n\t\t\twant: \"\\bhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\fhello world\",\n\t\t\t},\n\t\t\twant: \"\\fhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\nhello world\",\n\t\t\t},\n\t\t\twant: \"\\nhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\rhello world\",\n\t\t\t},\n\t\t\twant: \"\\rhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\thello world\",\n\t\t\t},\n\t\t\twant: \"\\thello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\u0020hello world\",\n\t\t\t},\n\t\t\twant: \" hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode surrogate pair\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\uD83D\\\\uDE00hello world\",\n\t\t\t},\n\t\t\twant: \"😁hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\xhello world\",\n\t\t\t},\n\t\t\twant: \"\\\\xhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete unicode escape sequence\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\u002hello world\",\n\t\t\t},\n\t\t\twant: \"\\\\u002hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\\\\"\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0020hello\\\\u0020world\",\n\t\t\t},\n\t\t\twant: \"\\\" \\f\\n\\r\\thello world\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","be3fef38b753fb00b2dd27df1c22fb9f":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestType_String(t *testing.T) {\n\ttype args struct {\n\t\tt Type\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"TypeObject\",\n\t\t\targs: args{\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\twant: \"object\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeArray\",\n\t\t\targs: args{\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\twant: \"array\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeString\",\n\t\t\targs: args{\n\t\t\t\tt: TypeString,\n\t\t\t},\n\t\t\twant: \"string\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeNumber\",\n\t\t\targs: args{\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\twant: \"number\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeTrue\",\n\t\t\targs: args{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: \"true\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeFalse\",\n\t\t\targs: args{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: \"false\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeNull\",\n\t\t\targs: args{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: \"null\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.t.String(); got != tt.want {\n\t\t\t\tt.Errorf(\"Type.String() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","bfd9bf47990529b6e2f1fe69b5593909":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestHasSpecialChars(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with double quote\",\n\t\t\targs: args{s: \"hello\\\"\"},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with backslash\",\n\t\t\targs: args{s: \"hello\\\\\"},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with control character\",\n\t\t\targs: args{s: \"hello\\x00\"},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with normal characters\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := hasSpecialChars(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"hasSpecialChars() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","bfff9a81256b0c60aeeaa312fc7ea322":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseArray() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","c0874c7164c921c92d5c73b5e96f2adc":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"empty string\",\n\t\t\targs:    args{s: \"\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"single digit\",\n\t\t\targs:    args{s: \"1\"},\n\t\t\twantNs:  \"1\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"multiple digits\",\n\t\t\targs:    args{s: \"123\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"negative number\",\n\t\t\targs:    args{s: \"-123\"},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"decimal number\",\n\t\t\targs:    args{s: \"123.456\"},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"exponent\",\n\t\t\targs:    args{s: \"123e+456\"},\n\t\t\twantNs:  \"123e+456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"exponent with negative sign\",\n\t\t\targs:    args{s: \"123e-456\"},\n\t\t\twantNs:  \"123e-456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"exponent with capital E\",\n\t\t\targs:    args{s: \"123E+456\"},\n\t\t\twantNs:  \"123E+456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading zeros\",\n\t\t\targs:    args{s: \"00123\"},\n\t\t\twantNs:  \"00123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with trailing zeros\",\n\t\t\targs:    args{s: \"123.00\"},\n\t\t\twantNs:  \"123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with space\",\n\t\t\targs:    args{s: \"123 456\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \" 456\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with inf\",\n\t\t\targs:    args{s: \"123inf\"},\n\t\t\twantNs:  \"123inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with inf (case-insensitive)\",\n\t\t\targs:    args{s: \"123InF\"},\n\t\t\twantNs:  \"123InF\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with nan\",\n\t\t\targs:    args{s: \"123nan\"},\n\t\t\twantNs:  \"123nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with nan (case-insensitive)\",\n\t\t\targs:    args{s: \"123NaN\"},\n\t\t\twantNs:  \"123NaN\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with invalid character\",\n\t\t\targs:    args{s: \"123a\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with invalid character at the beginning\",\n\t\t\targs:    args{s: \"a123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"a123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with invalid character after minus sign\",\n\t\t\targs:    args{s: \"-a123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"-a123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with invalid character after plus sign\",\n\t\t\targs:    args{s: \"+a123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+a123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with invalid character after exponent\",\n\t\t\targs:    args{s: \"123e+a\"},\n\t\t\twantNs:  \"123e+\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with invalid character after inf\",\n\t\t\targs:    args{s: \"123inf123\"},\n\t\t\twantNs:  \"123inf\",\n\t\t\twantS:   \"123\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with invalid character after nan\",\n\t\t\targs:    args{s: \"123nan123\"},\n\t\t\twantNs:  \"123nan\",\n\t\t\twantS:   \"123\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}","c139b8b840fd95c233cf58a5b0b8e307":"```go\npackage fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello\\\"\",\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello\\\\\\\"world\\\"\",\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n","c2da5751cd2c5398838167b28b6919cf":"package fastjson\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttype args struct {\n\t\tv *Value\n\t\tdst []byte\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"marshal string\",\n\t\t\targs: args{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeString,\n\t\t\t\t\ts: \"hello\",\n\t\t\t\t},\n\t\t\t\tdst: []byte{},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal number\",\n\t\t\targs: args{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"123\",\n\t\t\t\t},\n\t\t\t\tdst: []byte{},\n\t\t\t},\n\t\t\twant: []byte(\"123\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal true\",\n\t\t\targs: args{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeTrue,\n\t\t\t\t},\n\t\t\t\tdst: []byte{},\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal false\",\n\t\t\targs: args{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeFalse,\n\t\t\t\t},\n\t\t\t\tdst: []byte{},\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal null\",\n\t\t\targs: args{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeNull,\n\t\t\t\t},\n\t\t\t\tdst: []byte{},\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal object\",\n\t\t\targs: args{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdst: []byte{},\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":\"value1\",\"key2\":123}`),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal array\",\n\t\t\targs: args{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdst: []byte{},\n\t\t\t},\n\t\t\twant: []byte(`[\"value1\",123]`),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal raw string\",\n\t\t\targs: args{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: typeRawString,\n\t\t\t\t\ts: \"hello\",\n\t\t\t\t},\n\t\t\t\tdst: []byte{},\n\t\t\t},\n\t\t\twant: []byte(`\"hello\"`),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.v.MarshalTo(tt.args.dst); !bytes.Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","c32a429bd8165819c0e2efc39c6b825a":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"basic\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped_quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple_escaped_quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\"world\\\\\\\"\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\\\\\\\"\\\\\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing_closing_quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty_string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\"`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"no_quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `hello`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","c3af1e47e08002ea2a66ba4555dc8b2c":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetStringBytes(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.GetStringBytes(tt.args.keys...); !bytesEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.GetStringBytes() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc bytesEqual(a, b []byte) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","c3ca300ea3ef3c2d58924dcfd3e7b4d8":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello world\",\n\t\t\t},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\\\\"hello\\\\\\\"\",\n\t\t\t},\n\t\t\twant: \"\\\"hello\\\"\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\\\\\hello\\\\\\\\\",\n\t\t\t},\n\t\t\twant: \"\\\\hello\\\\\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\/hello\\\\/\",\n\t\t\t},\n\t\t\twant: \"/hello/\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\bhello\\\\b\",\n\t\t\t},\n\t\t\twant: \"\\bhello\\b\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\fhello\\\\f\",\n\t\t\t},\n\t\t\twant: \"\\fhello\\f\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\nhello\\\\n\",\n\t\t\t},\n\t\t\twant: \"\\nhello\\n\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\rhello\\\\r\",\n\t\t\t},\n\t\t\twant: \"\\rhello\\r\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\thello\\\\t\",\n\t\t\t},\n\t\t\twant: \"\\thello\\t\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\u0061hello\\\\u0062\",\n\t\t\t},\n\t\t\twant: \"ahello b\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\uD83D\\\\uDE01hello\",\n\t\t\t},\n\t\t\twant: \"😀hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\xhello\",\n\t\t\t},\n\t\t\twant: \"\\\\xhello\",\n\t\t},\n\t\t{\n\t\t\tname: \"short unicode escape sequence\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\u006\",\n\t\t\t},\n\t\t\twant: \"\\\\u006\",\n\t\t},\n\t\t{\n\t\t\tname: \"short surrogate pair escape sequence\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\uD83D\\\\uDE\",\n\t\t\t},\n\t\t\twant: \"\\\\uD83D\\\\uDE\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid hex\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\u00zz\",\n\t\t\t},\n\t\t\twant: \"\\\\u00zz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character with invalid hex 2\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\u00z\",\n\t\t\t},\n\t\t\twant: \"\\\\u00z\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\uD83D\\\\uDEzz\",\n\t\t\t},\n\t\t\twant: \"\\\\uD83D\\\\uDEzz\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex 2\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\uD83D\\\\uDEz\",\n\t\t\t},\n\t\t\twant: \"\\\\uD83D\\\\uDEz\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\\\\"hello\\\\\\\" \\\\\\\\ \\\\/ \\\\b \\\\f \\\\n \\\\r \\\\t \\\\u0061 \\\\u0062\",\n\t\t\t},\n\t\t\twant: \"\\\"hello\\\" \\\\ / \\b \\f \\n \\r \\t a b\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","c3d3743fdc801655ec63135d7bb59672":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCacheGetValue(t *testing.T) {\n\tt.Run(\"EmptyCache\", func(t *testing.T) {\n\t\tc := \u0026cache{}\n\t\tv := c.getValue()\n\t\tif v == nil {\n\t\t\tt.Error(\"getValue() returned nil for empty cache\")\n\t\t}\n\t})\n\n\tt.Run(\"NonEmptyCache\", func(t *testing.T) {\n\t\tc := \u0026cache{vs: []Value{{t: TypeString, s: \"test\"}}}\n\t\tv := c.getValue()\n\t\tif v == nil {\n\t\t\tt.Error(\"getValue() returned nil for non-empty cache\")\n\t\t}\n\t\tif v.t != TypeString || v.s != \"test\" {\n\t\t\tt.Error(\"getValue() did not return expected value\")\n\t\t}\n\t})\n}\n","c3f9de78bc4ab5f2c224c68fe6a512d2":"```go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetObject(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttype want struct {\n\t\tobject *Object\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant want\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.GetObject(tt.args.keys...); !reflect.DeepEqual(got, tt.want.object) {\n\t\t\t\tt.Errorf(\"GetObject() = %v, want %v\", got, tt.want.object)\n\t\t\t}\n\t\t})\n\t}\n}\n","c41fada46f28a36a945f14b1dabf43f8":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no whitespace\",\n\t\t\targs: args{s: \"hello\"},\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace\",\n\t\t\targs: args{s: \"  hello\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailing whitespace\",\n\t\t\targs: args{s: \"hello  \"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"whitespace in the middle\",\n\t\t\targs: args{s: \"hello  world\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"mixed whitespace\",\n\t\t\targs: args{s: \"\\t\\n hello\\r world \\t\\n\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"single whitespace\",\n\t\t\targs: args{s: \" \"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"single newline\",\n\t\t\targs: args{s: \"\\n\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"single tab\",\n\t\t\targs: args{s: \"\\t\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"single carriage return\",\n\t\t\targs: args{s: \"\\r\"},\n\t\t\twant: \"\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","c4ca0fa3d11b72162681fabfbab58d61":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCache_getValue(t *testing.T) {\n\ttype args struct {\n\t\tvs []Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant *Value\n\t}{\n\t\t{\n\t\t\tname: \"empty cache\",\n\t\t\targs: args{\n\t\t\t\tvs: []Value{},\n\t\t\t},\n\t\t\twant: \u0026Value{},\n\t\t},\n\t\t{\n\t\t\tname: \"non-empty cache\",\n\t\t\targs: args{\n\t\t\t\tvs: []Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"test\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: \u0026Value{},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{\n\t\t\t\tvs: tt.args.vs,\n\t\t\t}\n\t\t\tif got := c.getValue(); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"cache.getValue() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","c5586c4ceae5d3f167bcc3ee23c33dbe":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"single digit\",\n\t\t\targs: args{\n\t\t\t\ts: \"1\",\n\t\t\t},\n\t\t\twantNs:  \"1\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple digits\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative number\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"decimal number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential number\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential number with negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e-4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"inf\",\n\t\t\t},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"nan\",\n\t\t\t},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123abc\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"abc\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and extra characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123abc\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"abc\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and invalid characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"-abc\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"-abc\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and extra characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123abc\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+123abc\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and invalid characters\",\n\t\t\targs: args{\n\t\t\t\ts: \"+abc\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+abc\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading plus sign and invalid characters 2\",\n\t\t\targs: args{\n\t\t\t\ts: \"+\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading minus sign and invalid characters 2\",\n\t\t\targs: args{\n\t\t\t\ts: \"-\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}","c55ae409893aa760b6837960ae6d3139":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\ world\"},\n\t\t\twant: \"\\\\hello\\\\ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/ world\"},\n\t\t\twant: \"/hello/ world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b world\"},\n\t\t\twant: \"\\bhello\\b world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f world\"},\n\t\t\twant: \"\\fhello\\f world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n world\"},\n\t\t\twant: \"\\nhello\\n world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r world\"},\n\t\t\twant: \"\\rhello\\r world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t world\"},\n\t\t\twant: \"\\thello\\t world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\\\\u0064\"},\n\t\t\twant: \"abcd\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"😀\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello world\"},\n\t\t\twant: \"\\\\xhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete unicode escape sequence\",\n\t\t\targs: args{s: \"\\\\u0061\\\\u0062\\\\u0063\"},\n\t\t\twant: \"\\\\u0061\\\\u0062\\\\u0063\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete surrogate pair escape sequence\",\n\t\t\targs: args{s: \"\\\\uD83D\"},\n\t\t\twant: \"\\\\uD83D\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","c5cb7d728cb8fdc34f85c406b961cc9e":"package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: `\\\"hello world\\\"`},\n\t\t\twant: `\"hello world\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: `\\\\hello world\\\\`},\n\t\t\twant: `\\hello world\\`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped slashes\",\n\t\t\targs: args{s: `\\/hello world\\/`},\n\t\t\twant: `/hello world/`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: `\\bhello world\\b`},\n\t\t\twant: \"\\bhello world\\b\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: `\\fhello world\\f`},\n\t\t\twant: \"\\fhello world\\f\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: `\\nhello world\\n`},\n\t\t\twant: \"\\nhello world\\n\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: `\\rhello world\\r`},\n\t\t\twant: \"\\rhello world\\r\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: `\\thello world\\t`},\n\t\t\twant: \"\\thello world\\t\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: `\\u0061hello world\\u0062`},\n\t\t\twant: \"ahello worldb\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode surrogate pair\",\n\t\t\targs: args{s: `\\uD83D\\uDE01hello world`},\n\t\t\twant: \"😁hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: `\\xhello world`},\n\t\t\twant: `\\xhello world`,\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete unicode escape sequence\",\n\t\t\targs: args{s: `\\u006hello world`},\n\t\t\twant: `\\u006hello world`,\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete surrogate pair\",\n\t\t\targs: args{s: `\\uD83Dhello world`},\n\t\t\twant: `\\uD83Dhello world`,\n\t\t},\n\t\t{\n\t\t\tname: \"mixed escape sequences\",\n\t\t\targs: args{s: `\\\"hello \\bworld\\t\\u0061\\u0062\\n\\r\\\\\\\"`},\n\t\t\twant: `\"hello \\bworld\\ta\\nb\\r\\\\\"`,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","c5cdd5f26f85c8b4f71fd4ad327b5a2e":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_reset(t *testing.T) {\n\ttype args struct {\n\t\to *Object\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant *Object\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.o.reset(); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Object.reset() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","c6faba2bbfc994b9485296bddc91361b":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    \u0026Value{t: TypeObject, o: Object{}},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\":\"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\":{\"key2\":\"value2\"}}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with multiple keys\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\":\"value1\",\"key2\":\"value2\",\"key3\":\"value3\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}},\n\t\t\t\t\t\t{k: \"key3\", v: \u0026Value{t: TypeString, s: \"value3\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped keys\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\\\\\\\"key2\\\":\\\"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\\\"key2\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with invalid key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1: \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1: \"value1\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\" \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\":\"value1\" \"key2\":\"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\":\"value1\" \"key2\":\"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\":\"value1\"`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\":\"value1\"`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_RealWorldExample(t *testing.T) {\n\ttype MyObject struct {\n\t\tName  string `json:\"name\"`\n\t\tAge   int    `json:\"age\"`\n\t\tEmail string `json:\"email\"`\n\t}\n\tjsonString := `{\"name\":\"John Doe\",\"age\":30,\"email\":\"john.doe@example.com\"}`\n\tvar myObject MyObject\n\n\t// Parse the JSON string into a Value object\n\tc := \u0026cache{}\n\tv, _, err := parseObject(jsonString, c, 0)\n\tif err != nil {\n\t\tt.Errorf(\"parseObject() error = %v\", err)\n\t\treturn\n\t}\n\n\t// Convert the Value object to a MyObject struct\n\terr = json.Unmarshal(v.MarshalTo(nil), \u0026myObject)\n\tif err != nil {\n\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\treturn\n\t}\n\n\t// Assert the values are correctly extracted\n\tif myObject.Name != \"John Doe\" {\n\t\tt.Errorf(\"myObject.Name = %v, want %v\", myObject.Name, \"John Doe\")\n\t}\n\tif myObject.Age != 30 {\n\t\tt.Errorf(\"myObject.Age = %v, want %v\", myObject.Age, 30)\n\t}\n\tif myObject.Email != \"john.doe@example.com\" {\n\t\tt.Errorf(\"myObject.Email = %v, want %v\", myObject.Email, \"john.doe@example.com\")\n\t}\n}","c764ce35ca14ae6a72207278122d0d5b":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\tv   *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"TestMarshalString\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeString, s: \"hello\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"TestMarshalNumber\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t},\n\t\t\twant: []byte(\"123\"),\n\t\t},\n\t\t{\n\t\t\tname: \"TestMarshalTrue\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeTrue},\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"TestMarshalFalse\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeFalse},\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"TestMarshalNull\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNull},\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"TestMarshalRawString\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: typeRawString, s: \"hello\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"TestMarshalArray\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{t: TypeString, s: \"hello\"},\n\t\t\t\t\t\t{t: TypeNumber, s: \"123\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"[\\\"hello\\\",123]\"),\n\t\t},\n\t\t{\n\t\t\tname: \"TestMarshalObject\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{k: \"name\", v: \u0026Value{t: TypeString, s: \"john\"}},\n\t\t\t\t\t\t\t{k: \"age\", v: \u0026Value{t: TypeNumber, s: \"30\"}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`{\"name\":\"john\",\"age\":30}`),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.v.MarshalTo(tt.args.dst); !bytesEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc bytesEqual(a, b []byte) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","c7df6ab3486acf816f4a9b764f6a03d8":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello world\"`,\n\t\t\t},\n\t\t\twant:    \"hello world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello \\\\\"world\\\\\"\"`,\n\t\t\t},\n\t\t\twant:    \"hello \\\"world\\\"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello \\\\\"world\\\\\" \\\\\"again\\\\\"\"`,\n\t\t\t},\n\t\t\twant:    \"hello \\\"world\\\" \\\"again\\\"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello world`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\"`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quote at the end\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","c8009aa53c1b79da028713d43677a10e":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[]\",\n\t\t\t\tc:    \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"single element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1]\",\n\t\t\t\tc:    \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,3]\",\n\t\t\t\tc:    \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[[1,2],[3,4]]\",\n\t\t\t\tc:    \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"4\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,\",\n\t\t\t\tc:    \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1,2,\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2\",\n\t\t\t\tc:    \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"[1,2\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseArray() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseArray_Unmarshal(t *testing.T) {\n\ttype testStruct struct {\n\t\tA []int\n\t\tB []string\n\t\tC []map[string]interface{}\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tjson string\n\t\twant testStruct\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\tjson: `{\"A\": [], \"B\": [], \"C\": []}`,\n\t\t\twant: testStruct{\n\t\t\t\tA: []int{},\n\t\t\t\tB: []string{},\n\t\t\t\tC: []map[string]interface{}{},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"single element array\",\n\t\t\tjson: `{\"A\": [1], \"B\": [\"test\"], \"C\": [{\"foo\": \"bar\"}]}`,\n\t\t\twant: testStruct{\n\t\t\t\tA: []int{1},\n\t\t\t\tB: []string{\"test\"},\n\t\t\t\tC: []map[string]interface{}{{\"foo\": \"bar\"}},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element array\",\n\t\t\tjson: `{\"A\": [1, 2, 3], \"B\": [\"test1\", \"test2\", \"test3\"], \"C\": [{\"foo\": \"bar1\"}, {\"foo\": \"bar2\"}, {\"foo\": \"bar3\"}]}`,\n\t\t\twant: testStruct{\n\t\t\t\tA: []int{1, 2, 3},\n\t\t\t\tB: []string{\"test1\", \"test2\", \"test3\"},\n\t\t\t\tC: []map[string]interface{}{{\"foo\": \"bar1\"}, {\"foo\": \"bar2\"}, {\"foo\": \"bar3\"}},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\tjson: `{\"A\": [[1, 2], [3, 4]], \"B\": [[\"test1\", \"test2\"], [\"test3\", \"test4\"]], \"C\": [{\"foo\": [1, 2]}, {\"foo\": [3, 4]}]}`,\n\t\t\twant: testStruct{\n\t\t\t\tA: []int{1, 2, 3, 4},\n\t\t\t\tB: []string{\"test1\", \"test2\", \"test3\", \"test4\"},\n\t\t\t\tC: []map[string]interface{}{{\"foo\": []interface{}{1, 2}}, {\"foo\": []interface{}{3, 4}}},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tvar got testStruct\n\t\t\tc := \u0026cache{vs: make([]Value, 0)}\n\t\t\tv, _, err := Parse(tt.json)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Parse() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\terr = json.Unmarshal(v.MarshalTo(nil), \u0026got)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Parse() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","c80f450b5ed4b0fa2ce024b7f69bb8fc":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested objects\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey1\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue1\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped keys\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", : \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", : \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","c862c57bfd6664eb3772ddfd9cc5ec8c":"package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello world\",\n\t\t\t},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello world\\\"\",\n\t\t\t},\n\t\t\twant: `\"hello world\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\\\\\hello world\",\n\t\t\t},\n\t\t\twant: `\\hello world`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\/hello world\",\n\t\t\t},\n\t\t\twant: `/hello world`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\bhello world\",\n\t\t\t},\n\t\t\twant: \"\\bhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\fhello world\",\n\t\t\t},\n\t\t\twant: \"\\fhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\nhello world\",\n\t\t\t},\n\t\t\twant: \"\\nhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\rhello world\",\n\t\t\t},\n\t\t\twant: \"\\rhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\thello world\",\n\t\t\t},\n\t\t\twant: \"\\thello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\u0061hello world\",\n\t\t\t},\n\t\t\twant: \"ahello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode surrogate pair\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\uD83D\\\\uDE01hello world\",\n\t\t\t},\n\t\t\twant: \"😀hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\xhello world\",\n\t\t\t},\n\t\t\twant: \"\\\\xhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete unicode escape sequence\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\u006hello world\",\n\t\t\t},\n\t\t\twant: \"\\\\u006hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\\\\"\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061hello world\",\n\t\t\t},\n\t\t\twant: \"\\\"\\\\b\\f\\n\\r\\tahello world\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","c89109383f77829fd96d34eb2ecc83ef":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo_Null(t *testing.T) {\n\tv := \u0026Value{t: TypeNull}\n\tdst := []byte{}\n\tdst = v.MarshalTo(dst)\n\tif string(dst) != \"null\" {\n\t\tt.Errorf(\"expected 'null', got %q\", dst)\n\t}\n}\n\nfunc TestValueMarshalTo_True(t *testing.T) {\n\tv := \u0026Value{t: TypeTrue}\n\tdst := []byte{}\n\tdst = v.MarshalTo(dst)\n\tif string(dst) != \"true\" {\n\t\tt.Errorf(\"expected 'true', got %q\", dst)\n\t}\n}\n\nfunc TestValueMarshalTo_False(t *testing.T) {\n\tv := \u0026Value{t: TypeFalse}\n\tdst := []byte{}\n\tdst = v.MarshalTo(dst)\n\tif string(dst) != \"false\" {\n\t\tt.Errorf(\"expected 'false', got %q\", dst)\n\t}\n}\n\nfunc TestValueMarshalTo_Number(t *testing.T) {\n\tv := \u0026Value{t: TypeNumber, s: \"123\"}\n\tdst := []byte{}\n\tdst = v.MarshalTo(dst)\n\tif string(dst) != \"123\" {\n\t\tt.Errorf(\"expected '123', got %q\", dst)\n\t}\n}\n\nfunc TestValueMarshalTo_String(t *testing.T) {\n\tv := \u0026Value{t: TypeString, s: \"hello\"}\n\tdst := []byte{}\n\tdst = v.MarshalTo(dst)\n\tif string(dst) != \"\\\"hello\\\"\" {\n\t\tt.Errorf(\"expected '\\\"hello\\\"', got %q\", dst)\n\t}\n}\n\nfunc TestValueMarshalTo_RawString(t *testing.T) {\n\tv := \u0026Value{t: typeRawString, s: \"hello\"}\n\tdst := []byte{}\n\tdst = v.MarshalTo(dst)\n\tif string(dst) != \"\\\"hello\\\"\" {\n\t\tt.Errorf(\"expected '\\\"hello\\\"', got %q\", dst)\n\t}\n}\n\nfunc TestValueMarshalTo_Array(t *testing.T) {\n\tv := \u0026Value{\n\t\tt: TypeArray,\n\t\ta: []*Value{\n\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t{t: TypeString, s: \"hello\"},\n\t\t},\n\t}\n\tdst := []byte{}\n\tdst = v.MarshalTo(dst)\n\tif string(dst) != \"[1,\\\"hello\\\"]\" {\n\t\tt.Errorf(\"expected '[1,\\\"hello\\\"]', got %q\", dst)\n\t}\n}\n\nfunc TestValueMarshalTo_Object(t *testing.T) {\n\tv := \u0026Value{\n\t\tt: TypeObject,\n\t\to: Object{\n\t\t\tkvs: []kv{\n\t\t\t\t{k: \"a\", v: \u0026Value{t: TypeNumber, s: \"1\"}},\n\t\t\t\t{k: \"b\", v: \u0026Value{t: TypeString, s: \"hello\"}},\n\t\t\t},\n\t\t},\n\t}\n\tdst := []byte{}\n\tdst = v.MarshalTo(dst)\n\tif string(dst) != `{\"a\":1,\"b\":\"hello\"}` {\n\t\tt.Errorf(\"expected `{\\\"a\\\":1,\\\"b\\\":\\\"hello\\\"}`, got %q\", dst)\n\t}\n}\n","c9f4acd3cb04b2ed994e2e7099cc5b41":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestString(t *testing.T) {\n\ttype args struct {\n\t\tt Type\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"TypeObject\",\n\t\t\targs: args{t: TypeObject},\n\t\t\twant: \"object\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeArray\",\n\t\t\targs: args{t: TypeArray},\n\t\t\twant: \"array\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeString\",\n\t\t\targs: args{t: TypeString},\n\t\t\twant: \"string\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeNumber\",\n\t\t\targs: args{t: TypeNumber},\n\t\t\twant: \"number\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeTrue\",\n\t\t\targs: args{t: TypeTrue},\n\t\t\twant: \"true\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeFalse\",\n\t\t\targs: args{t: TypeFalse},\n\t\t\twant: \"false\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeNull\",\n\t\t\targs: args{t: TypeNull},\n\t\t\twant: \"null\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.t.String(); got != tt.want {\n\t\t\t\tt.Errorf(\"String() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","cac4f04680835dd843013cfc1b730880":"package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n)\n\nfunc TestEscapeString(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\ts   string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\ts:   \"\",\n\t\t\t},\n\t\t\twant: []byte(`\"\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"no special chars\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\ts:   \"abc\",\n\t\t\t},\n\t\t\twant: []byte(`\"abc\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"special chars\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\ts:   \"a\\\"b\\\\c\",\n\t\t\t},\n\t\t\twant: []byte(`\"a\\\"b\\\\c\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"unicode chars\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\ts:   \"你好世界\",\n\t\t\t},\n\t\t\twant: []byte(`\"你好世界\"`),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := escapeString(tt.args.dst, tt.args.s); !bytesEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"escapeString() = %v, want %v\", string(got), string(tt.want))\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc bytesEqual(a, b []byte) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","cb85710523cfb04cdcdf04451f7449d2":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped backslashes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\\world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with no closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with invalid escape sequence\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\x\"`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: ``,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with leading whitespace\",\n\t\t\targs: args{\n\t\t\t\ts: ` \"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with trailing whitespace\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\" `,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \" \",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","cb8b337a5da945f53db16b6db1e7cef5":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"simple key\",\n\t\t\targs:    args{s: `\"key\"`},\n\t\t\twant:    \"key\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"key with escape sequences\",\n\t\t\targs:    args{s: `\"key\\\\\"escaped\\\\\"\"`},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"missing closing quote\",\n\t\t\targs:    args{s: `\"key`},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"empty key\",\n\t\t\targs:    args{s: `\"\"`},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"key with special characters\",\n\t\t\targs:    args{s: `\"key:value\"`},\n\t\t\twant:    \"key:value\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawKey(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawKey() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawKey() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawKey() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","cbef8bb22fee92b10afa87f54f0a53b0":"```go\npackage fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t\t{\n\t\t\tname: \"TestParseValue_Null\",\n\t\t\targs: args{\n\t\t\t\ts:    \"null\",\n\t\t\t\tc:    \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueNull,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"TestParseValue_True\",\n\t\t\targs: args{\n\t\t\t\ts:    \"true\",\n\t\t\t\tc:    \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueTrue,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"TestParseValue_False\",\n\t\t\targs: args{\n\t\t\t\ts:    \"false\",\n\t\t\t\tc:    \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueFalse,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"TestParseValue_String\",\n\t\t\targs: args{\n\t\t\t\ts:    `\"hello world\"`,\n\t\t\t\tc:    \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\ts: `\"hello world\"`,\n\t\t\t\tt: typeRawString,\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"TestParseValue_Number\",\n\t\t\targs: args{\n\t\t\t\ts:    \"123\",\n\t\t\t\tc:    \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\ts: \"123\",\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"TestParseValue_Object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": 123}`,\n\t\t\t\tc:    \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\ts: `\"value1\"`,\n\t\t\t\t\t\t\t\tt: typeRawString,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: true,\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"TestParseValue_Array\",\n\t\t\targs: args{\n\t\t\t\ts:    `[1, 2, \"hello\"]`,\n\t\t\t\tc:    \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\ts: `\"hello\"`,\n\t\t\t\t\t\tt: typeRawString,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"TestParseValue_Empty\",\n\t\t\targs: args{\n\t\t\t\ts:    \"\",\n\t\t\t\tc:    \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"TestParseValue_Invalid\",\n\t\t\targs: args{\n\t\t\t\ts:    \"invalid\",\n\t\t\t\tc:    \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"invalid\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"TestParseValue_TooDeep\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"key2\": {\"key3\": \"value\"}}}`,\n\t\t\t\tc:    \u0026cache{vs: make([]Value, 0)},\n\t\t\t\tdepth: MaxDepth - 1,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key2\": {\"key3\": \"value\"}}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 !=","cc2ca3ffb95a189c0927b89f2ea28794":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\"world\\\\\\\"\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quotes and other characters\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\\\"\\\\\"\\\\\\\\\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"\\\\\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: ``,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with no quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `hello`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","cc89c1bed9800d39da5e4dc1a0fd47ba":"```go\npackage fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"single digit\",\n\t\t\targs: args{\n\t\t\t\ts: \"1\",\n\t\t\t},\n\t\t\twantNs:  \"1\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple digits\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative number\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"decimal number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential number\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential number with minus sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e-4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with plus sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zero\",\n\t\t\targs: args{\n\t\t\t\ts: \"0123\",\n\t\t\t},\n\t\t\twantNs:  \"0123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with trailing zero\",\n\t\t\targs: args{\n\t\t\t\ts: \"1230\",\n\t\t\t},\n\t\t\twantNs:  \"1230\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading and trailing zeros\",\n\t\t\targs: args{\n\t\t\t\ts: \"01230\",\n\t\t\t},\n\t\t\twantNs:  \"01230\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading space\",\n\t\t\targs: args{\n\t\t\t\ts: \" 123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" 123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number with trailing space\",\n\t\t\targs: args{\n\t\t\t\ts: \"123 \",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \" \",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading and trailing spaces\",\n\t\t\targs: args{\n\t\t\t\ts: \" 123 \",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS","cd096a26bec96244813fa324ca0118d3":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttype want struct {\n\t\tv   *Value\n\t\ttail string\n\t\terr  error\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant want\n\t}{\n\t\t// TODO: Add test cases.\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  fmt.Errorf(\"cannot parse empty string\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   \"null\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueNull,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   \"true\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueTrue,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   \"false\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueFalse,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   \"123\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"123\",\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"hello world\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: typeRawString,\n\t\t\t\t\ts: \"hello world\",\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[1,2,3]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{t: TypeArray},\n\t\t\t\ttail: \"]\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{t: TypeObject},\n\t\t\t\ttail: \"}\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"nested object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": {\"key2\": \"value2\"}}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{t: TypeObject},\n\t\t\t\ttail: \"}\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": [1,2,3]}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{t: TypeObject},\n\t\t\t\ttail: \"}\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": {\"key2\": {\"key3\": \"value3\"}}}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth - 1,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"}\",\n\t\t\t\terr:  fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotV, gotTail, gotErr := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif gotErr != nil \u0026\u0026 tt.want.err == nil {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, want nil\", gotErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotErr == nil \u0026\u0026 tt.want.err != nil {\n\t\t\t\tt.Errorf(\"parseValue() error = nil, want %v\", tt.want.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotErr != nil \u0026\u0026 tt.want.err != nil {\n\t\t\t\tif gotErr.Error() != tt.want.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue() error = %v, want %v\", gotErr, tt.want.err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(gotV, tt.want.v) {\n\t\t\t\tt.Errorf(\"parseValue() gotV = %v, want %v\", gotV, tt.want.v)\n\t\t\t}\n\t\t\tif gotTail != tt.want.tail {\n\t\t\t\tt.Errorf(\"parseValue() gotTail = %v, want %v\", gotTail, tt.want.tail)\n\t\t\t}\n\t\t})\n\t}\n}","cd09872ff98ed51df9fc60253203ac1c":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"basic case\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\"world\\\\\"and\\\\\"more\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\\\\\\\"and\\\\\\\"more\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"\"`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","cd6cb6e8218d1f8c8539694471a3eebe":"package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: `\\\"hello world\\\"`},\n\t\t\twant: `\"hello world\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: `\\\\hello world\\\\`},\n\t\t\twant: `\\hello world\\`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: `\\/hello world\\/`},\n\t\t\twant: `/hello world/`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: `\\bhello world\\b`},\n\t\t\twant: \"\\bhello world\\b\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: `\\fhello world\\f`},\n\t\t\twant: \"\\fhello world\\f\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: `\\nhello world\\n`},\n\t\t\twant: \"\\nhello world\\n\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: `\\rhello world\\r`},\n\t\t\twant: \"\\rhello world\\r\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: `\\thello world\\t`},\n\t\t\twant: \"\\thello world\\t\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: `\\u0061hello world\\u0062`},\n\t\t\twant: \"ahello worldb\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: `\\uD83D\\uDE01hello world\\uD83D\\uDE02`},\n\t\t\twant: \"😁hello world😂\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: `\\xhello world\\y`},\n\t\t\twant: `\\xhello world\\y`,\n\t\t},\n\t\t{\n\t\t\tname: \"too short escape sequence\",\n\t\t\targs: args{s: `\\uhello world`},\n\t\t\twant: `\\uhello world`,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: `\\u0061\\bhello\\tworld\\r\\n\\f\\\\`},\n\t\t\twant: \"a\\bhello\\tworld\\r\\n\\f\\\\\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes in unicode\",\n\t\t\targs: args{s: `\\u0022hello world\\u0022`},\n\t\t\twant: `\"hello world\"`,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","ce19768ad4ca3977d0976120357c68d6":"package fastjson\n\nimport \"testing\"\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with leading whitespace\",\n\t\t\targs: args{s: \" \\t\\r\\n  hello\"},\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with trailing whitespace\",\n\t\t\targs: args{s: \"hello \\t\\r\\n  \"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with whitespace in the middle\",\n\t\t\targs: args{s: \"hello \\t\\r\\n world\"},\n\t\t\twant: \"world\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with no whitespace\",\n\t\t\targs: args{s: \"hello\"},\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with leading carriage return\",\n\t\t\targs: args{s: \"\\rhello\"},\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with leading carriage return and whitespace\",\n\t\t\targs: args{s: \"\\r \\t\\n  hello\"},\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"string with leading carriage return and no whitespace\",\n\t\t\targs: args{s: \"\\rhello\"},\n\t\t\twant: \"hello\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","ce393aeae9568082d69d7a6c00ded17e":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"too deep\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{ }\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"{ }\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{ }\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[ ]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"hello\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   \"true\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueTrue,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   \"false\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueFalse,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   \"null\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueNull,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   \"123\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   \"NaN\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected value\",\n\t\t\targs: args{\n\t\t\t\ts:   \"tru\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"tru\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseValue() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","cee6ab93546cb62c80fb31265cc0b0c3":"```go\npackage fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"single digit\",\n\t\t\targs: args{\n\t\t\t\ts: \"1\",\n\t\t\t},\n\t\t\twantNs:  \"1\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple digits\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"decimal number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative number\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential number\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential number with negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e-4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zeros\",\n\t\t\targs: args{\n\t\t\t\ts: \"00123\",\n\t\t\t},\n\t\t\twantNs:  \"00123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with trailing zeros\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.00\",\n\t\t\t},\n\t\t\twantNs:  \"123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading plus sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading plus sign and trailing zeros\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123.00\",\n\t\t\t},\n\t\t\twantNs:  \"+123.00\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading plus sign and trailing zeros and exponent\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123.00e+4\",\n\t\t\t},\n\t\t\twantNs:  \"+123.00e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading plus sign and trailing zeros and exponent\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123.00e-4\",\n\t\t\t},\n\t\t\twantNs:  \"+123.00e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading minus sign and trailing zeros and exponent\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123.00e+4\",\n\t\t\t},\n\t\t\twantNs:  \"-123.00e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading minus sign and trailing zeros and exponent\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123.00e-4\",\n\t\t\t},\n\t\t\twantNs:  \"-123.00e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading plus sign and trailing zeros and exponent\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123.00E+4\",\n\t\t\t},\n\t\t\twantNs:  \"+123.00E+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading plus sign and trailing zeros and exponent\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123.00E-4\",\n\t\t\t},\n\t\t\twantNs:  \"+123.00E-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading minus sign and trailing zeros and exponent\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123.00E+4\",\n\t\t\t},\n\t\t\twantNs:  \"-123.00E+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\t","cf569eccca807a583e3e1abb4542ed42":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"no quotes\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello world\",\n\t\t\t},\n\t\t\twant:    \"hello world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"single quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello world\"`,\n\t\t\t},\n\t\t\twant:    \"hello world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello \\\\\"world\\\\\"\"`,\n\t\t\t},\n\t\t\twant:    \"hello \\\\\\\"world\\\\\\\"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello \\\\\"world\\\\\" \\\\\"again\\\\\"\"`,\n\t\t\t},\n\t\t\twant:    \"hello \\\\\\\"world\\\\\\\" \\\\\\\"again\\\\\\\"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quote at the end\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello \\\\\"world\\\\\"`,\n\t\t\t},\n\t\t\twant:    \"hello \\\\\\\"world\\\\\\\"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quote at the beginning\",\n\t\t\targs: args{\n\t\t\t\ts: `\\\\\"hello world\\\\\"`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   `\\\\\"hello world\\\\\"`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quote in the middle\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello \\\\\"world\\\\\" again\"`,\n\t\t\t},\n\t\t\twant:    \"hello \\\\\\\"world\\\\\\\" again\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","cfc916037e0bc9ef8c3ad68cd5ccc315":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueGet(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttype want struct {\n\t\twant *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant want\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.Get(tt.args.keys...); !reflect.DeepEqual(got, tt.want.want) {\n\t\t\t\tt.Errorf(\"Value.Get() = %v, want %v\", got, tt.want.want)\n\t\t\t}\n\t\t})\n\t}\n}","d022cd027712a505cb7c482afa838bb6":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttype want struct {\n\t\tv   *Value\n\t\ttail string\n\t\terr  error\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant want\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  fmt.Errorf(\"cannot parse empty string\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"{}\",\n\t\t\t\terr:  fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\": \"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"value1\", \"value2\"]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"value\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeString,\n\t\t\t\t\ts: \"value\",\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   `true`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueTrue,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   `false`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueFalse,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   `null`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueNull,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"123\",\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\ts:   `NaN`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"NaN\",\n\t\t\t\t},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"invalid value\",\n\t\t\targs: args{\n\t\t\t\ts:   `invalid`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"invalid\",\n\t\t\t\terr:  fmt.Errorf(\"unexpected value found: %q\", \"invalid\"),\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotV, gotTail, gotErr := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (gotErr == nil) != (tt.want.err == nil) {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", gotErr, tt.want.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotErr != nil \u0026\u0026 tt.want.err != nil {\n\t\t\t\tif gotErr.Error() != tt.want.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", gotErr, tt.want.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(gotV, tt.want.v) {\n\t\t\t\tt.Errorf(\"parseValue() gotV = %v, want %v\", gotV, tt.want.v)\n\t\t\t}\n\t\t\tif gotTail != tt.want.tail {\n\t\t\t\tt.Errorf(\"parseValue() gotTail = %v, want %v\", gotTail, tt.want.tail)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_parseValue_roundtrip(t *testing.T) {\n\ttype roundtripTest struct {\n\t\tjsonStr string\n\t\twant    string\n\t}\n\ttests := []roundtripTest{\n\t\t{\"null\", \"null\"},\n\t\t{\"true\", \"true\"},\n\t\t{\"false\", \"false\"},\n\t\t{\"123\", \"123\"},\n\t\t{\"123.456\", \"123.456\"},\n\t\t{\"\\\"string\\\"\", \"\\\"string\\\"\"},\n\t\t{\"[1,2,3]\", \"[1,2,3]\"},\n\t\t{\"{\\\"key1\\\":\\\"value1\\\",\\\"key2\\\":\\\"value2\\\"}\", \"{\\\"key1\\\":\\\"value1\\\",\\\"key2\\\":\\\"value2\\\"}\"},\n\t\t{\"{\\\"key1\\\":[1,2,3],\\\"key2\\\":{\\\"key3\\\":\\\"value3\\\"}}\", \"{\\\"key1\\\":[1,2,3],\\\"key2\\\":{\\\"key3\\\":\\\"value3\\\"}}\"},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.jsonStr, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tv, _, err := parseValue(tt.jsonStr, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"parseValue() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgotJSON, err := json.Marshal(v)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"json.Marshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif string(gotJSON) != tt.want {\n\t\t\t\tt.Errorf(\"parseValue() gotJSON = %s, want %s\", string(gotJSON), tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","d08a0b4bda078a33a560fef033579209":"package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: `\\\"hello world\\\"`},\n\t\t\twant: `\"hello world\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: `\\\\hello world`},\n\t\t\twant: `\\hello world`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: `\\/hello world`},\n\t\t\twant: `/hello world`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: `\\bhello world`},\n\t\t\twant: \"\\bhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: `\\fhello world`},\n\t\t\twant: \"\\fhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: `\\nhello world`},\n\t\t\twant: \"\\nhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: `\\rhello world`},\n\t\t\twant: \"\\rhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: `\\thello world`},\n\t\t\twant: \"\\thello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: `\\u0061hello world`},\n\t\t\twant: \"ahello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: `\\uD83D\\uDE01hello world`},\n\t\t\twant: \"😁hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: `\\xhello world`},\n\t\t\twant: `\\xhello world`,\n\t\t},\n\t\t{\n\t\t\tname: \"short escape sequence\",\n\t\t\targs: args{s: `\\uhello world`},\n\t\t\twant: `\\uhello world`,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: `\\b\\f\\n\\r\\thello world`},\n\t\t\twant: \"\\b\\f\\n\\r\\thello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid hex\",\n\t\t\targs: args{s: `\\u006zhello world`},\n\t\t\twant: `\\u006zhello world`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with invalid hex\",\n\t\t\targs: args{s: `\\uD83D\\uDE0zhello world`},\n\t\t\twant: `\\uD83D\\uDE0zhello world`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair with short sequence\",\n\t\t\targs: args{s: `\\uD83Dhello world`},\n\t\t\twant: `\\uD83Dhello world`,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","d17936696f61395fe3f9b52667ef3ece":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no whitespace\",\n\t\t\targs: args{s: \"hello\"},\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace\",\n\t\t\targs: args{s: \"  hello\"},\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailing whitespace\",\n\t\t\targs: args{s: \"hello  \"},\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading and trailing whitespace\",\n\t\t\targs: args{s: \"  hello  \"},\n\t\t\twant: \"hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"internal whitespace\",\n\t\t\targs: args{s: \"  hello world  \"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"all whitespace\",\n\t\t\targs: args{s: \"  \\t\\n\\r  \"},\n\t\t\twant: \"\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","d19552cb4a85b8bdc7ee59d416f1defb":"package fastjson\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\tv   *Value\n\t}\n\ttype want struct {\n\t\twant []byte\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant want\n\t}{\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNull},\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\twant: []byte(\"null\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeTrue},\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\twant: []byte(\"true\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeFalse},\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\twant: []byte(\"false\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeString, s: \"test\"},\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\twant: []byte(\"\\\"test\\\"\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\twant: []byte(\"123\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{t: TypeNull},\n\t\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t\t\t{t: TypeFalse},\n\t\t\t\t\t\t{t: TypeString, s: \"test\"},\n\t\t\t\t\t\t{t: TypeNumber, s: \"123\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\twant: []byte(\"[null,true,false,\\\"test\\\",123]\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeNull}},\n\t\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeTrue}},\n\t\t\t\t\t\t\t{k: \"key3\", v: \u0026Value{t: TypeFalse}},\n\t\t\t\t\t\t\t{k: \"key4\", v: \u0026Value{t: TypeString, s: \"test\"}},\n\t\t\t\t\t\t\t{k: \"key5\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\twant: []byte(`{\"key1\":null,\"key2\":true,\"key3\":false,\"key4\":\"test\",\"key5\":123}`),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"raw_string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: typeRawString, s: \"test\"},\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\twant: []byte(`test\"`),\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.v.MarshalTo(tt.args.dst); !bytes.Equal(got, tt.want.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", got, tt.want.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestObjectMarshalTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\to   *Object\n\t}\n\ttype want struct {\n\t\twant []byte\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant want\n\t}{\n\t\t{\n\t\t\tname: \"empty\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\to:   \u0026Object{},\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\twant: []byte(\"{}\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"non-empty\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\to: \u0026Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeNull}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeTrue}},\n\t\t\t\t\t\t{k: \"key3\", v: \u0026Value{t: TypeFalse}},\n\t\t\t\t\t\t{k: \"key4\", v: \u0026Value{t: TypeString, s: \"test\"}},\n\t\t\t\t\t\t{k: \"key5\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\twant: []byte(`{\"key1\":null,\"key2\":true,\"key3\":false,\"key4\":\"test\",\"key5\":123}`),\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.o.MarshalTo(tt.args.dst); !bytes.Equal(got, tt.want.want) {\n\t\t\t\tt.Errorf(\"Object.MarshalTo() = %v, want %v\", got, tt.want.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestEscapeString(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\ts   string\n\t}\n\ttype want struct {\n\t\twant []byte\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant want\n\t}{\n\t\t{\n\t\t\tname: \"empty\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\ts:   \"\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\twant: []byte(\"\\\"\\\"\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"simple\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\ts:   \"test\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\twant: []byte(\"\\\"test\\\"\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"escaped\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\ts:   \"test\\t\\r\\n\\\\\\\"\\\\/\\\\b\\\\f\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\twant: []byte(\"\\\"test\\\\t\\\\r\\\\n\\\\\\\\\\\\\\\"\\\\/\\\\b\\\\f\\\"\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"escaped_with_unicode\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\ts:   \"test\\u0000\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\\u0008\\u0009\\u000a\\u000b\\u000c\\u000d\\u000e\\u000f\\u0010\\u0011\\u0012\\u0013\\u0014\\u0015\\u0016\\u0017\\u0018\\u0019\\u001a\\u001b\\u001c\\u001d\\u001e\\u001f\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\twant: []byte(\"\\\"test\\\\u0000\\\\u0001\\\\u0002\\\\u0003\\\\u0004\\\\u0005\\\\u0006\\\\u0007\\\\b\\\\t\\\\n\\\\u000b\\\\f\\\\r\\\\u000e\\\\u000f\\\\u0010\\\\u0011\\\\u0012\\\\u0013\\\\u0014\\\\u0015\\\\u0016\\\\u0017\\\\u0018\\\\u0019\\\\u001a\\\\u001b\\\\u001c\\\\u001d\\\\u001e\\\\u001f\\\"\"),\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := escapeString(tt.args.dst, tt.args.s); !bytes.Equal(got, tt.want.want) {\n\t\t\t\tt.Errorf(\"escapeString() = %v, want %v\", got, tt.want.want)\n\t\t\t}\n\t\t})\n\t}\n}","d1c42aa0ff9a668dfcf23c9f797c946e":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"key2\": \"value2\"}, \"key3\": \"value3\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{\n\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}},\n\t\t\t\t\t\t{k: \"key3\", v: \u0026Value{t: TypeString, s: \"value3\"}},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\" \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t// Add more test cases here\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_JSONMarshal(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tjsonStr string\n\t\twant    string\n\t}{\n\t\t{\n\t\t\tname:    \"empty object\",\n\t\t\tjsonStr: `{}`,\n\t\t\twant:    `{}`,\n\t\t},\n\t\t{\n\t\t\tname:    \"simple object\",\n\t\t\tjsonStr: `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\twant:    `{\"key1\":\"value1\",\"key2\":\"value2\"}`,\n\t\t},\n\t\t{\n\t\t\tname:    \"nested object\",\n\t\t\tjsonStr: `{\"key1\": {\"key2\": \"value2\"}, \"key3\": \"value3\"}`,\n\t\t\twant:    `{\"key1\":{\"key2\":\"value2\"},\"key3\":\"value3\"}`,\n\t\t},\n\t\t{\n\t\t\tname:    \"object with different types\",\n\t\t\tjsonStr: `{\"key1\": 1, \"key2\": \"value2\", \"key3\": true}`,\n\t\t\twant:    `{\"key1\":1,\"key2\":\"value2\",\"key3\":true}`,\n\t\t},\n\t\t{\n\t\t\tname:    \"object with array\",\n\t\t\tjsonStr: `{\"key1\": [1, 2, 3], \"key2\": \"value2\"}`,\n\t\t\twant:    `{\"key1\":[1,2,3],\"key2\":\"value2\"}`,\n\t\t},\n\t\t// Add more test cases here\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tvar v *Value\n\t\t\tvar err error\n\t\t\tif v, err = json.Marshal([]byte(tt.jsonStr)); err != nil {\n\t\t\t\tt.Fatalf(\"json.Marshal failed: %v\", err)\n\t\t\t}\n\t\t\tvar got []byte\n\t\t\tif got = v.MarshalTo(nil); string(got) != tt.want {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", string(got), tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","d2756c18d2278ae148d9b3426eb9553b":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttype want struct {\n\t\tv    *Value\n\t\ts    string\n\t\terr  error\n\t\twant string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant want\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs:           nil,\n\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ts:    \"\",\n\t\t\t\terr:  nil,\n\t\t\t\twant: \"{}\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"object with one key-value pair\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ts:    \"\",\n\t\t\t\terr:  nil,\n\t\t\t\twant: `{\"key1\":\"value1\"}`,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"object with multiple key-value pairs\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\", \"key3\": \"value3\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value3\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ts:    \"\",\n\t\t\t\terr:  nil,\n\t\t\t\twant: `{\"key1\":\"value1\",\"key2\":\"value2\",\"key3\":\"value3\"}`,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested objects\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"nestedKey1\": \"nestedValue1\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tk: \"nestedKey1\",\n\t\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\t\ts: \"nestedValue1\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ts:    \"\",\n\t\t\t\terr:  nil,\n\t\t\t\twant: `{\"key1\":{\"nestedKey1\":\"nestedValue1\"},\"key2\":\"value2\"}`,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped keys\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\", \"key\\\\\\\"2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key\\\"2\",\n\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ts:    \"\",\n\t\t\t\terr:  nil,\n\t\t\t\twant: `{\"key\\\"1\":\"value1\",\"key\\\"2\":\"value2\"}`,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:    nil,\n\t\t\t\ts:    `{\"key1\": \"value1`,\n\t\t\t\terr:  fmt.Errorf(\"missing '}'\"),\n\t\t\t\twant: \"\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing colon after key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\" \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:    nil,\n\t\t\t\ts:    `{\"key1\" \"value1\"}`,\n\t\t\t\terr:  fmt.Errorf(\"missing ':' after object key\"),\n\t\t\t\twant: \"\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing comma after value\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:    nil,\n\t\t\t\ts:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\terr:  fmt.Errorf(\"missing ',' after object value\"),\n\t\t\t\twant: \"\",\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotV, gotS, gotErr := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (gotErr == nil \u0026\u0026 tt.want.err != nil) || (gotErr != nil \u0026\u0026 tt.want.err == nil) || (gotErr != nil \u0026\u0026 tt.want.err != nil \u0026\u0026 gotErr.Error() != tt.want.err.Error()) {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", gotErr, tt.want.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotS != tt.want.s {\n\t\t\t\tt.Errorf(\"parseObject() gotS = %v, want %v\", gotS, tt.want.s)\n\t\t\t}\n\t\t\tif gotV == nil \u0026\u0026 tt.want.v != nil {\n\t\t\t\tt.Errorf(\"parseObject() gotV = %v, want %v\", gotV, tt.want.v)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotV != nil \u0026\u0026 tt.want.v == nil {\n\t\t\t\tt.Errorf(\"parseObject() gotV = %v, want %v\", gotV, tt.want.v)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotV != nil \u0026\u0026 tt.want.v != nil {\n\t\t\t\tif gotV.t != tt.want.v.t {\n\t\t\t\t\tt.Errorf(\"parseObject() gotV.t = %v, want %v\", gotV.t, tt.want.v.t)\n\t\t\t\t}\n\t\t\t\tif len(gotV.o.kvs) != len(tt.want.v.o.kvs) {\n\t\t\t\t\tt.Errorf(\"parseObject() gotV.o.kvs length = %v, want %v\", len(gotV.o.kvs), len(tt.want.v.o.kvs))\n\t\t\t\t}\n\t\t\t\tfor i, kv := range gotV.o.kvs {\n\t\t\t\t\tif kv.k != tt.want.v.o.kvs[i].k {\n\t\t\t\t\t\tt.Errorf(\"parseObject() gotV.o.kvs[%d].k = %v, want %v\", i, kv.k, tt.want.v.o.kvs[i].k)\n\t\t\t\t\t}\n\t\t\t\t\tif kv.v.t != tt.want.v.o.kvs[i].v.t {\n\t\t\t\t\t\tt.Errorf(\"parseObject() gotV.o.kvs[%d].v.t = %v, want %v\", i, kv.v.t, tt.want.v.o.kvs[i].v.t)\n\t\t\t\t\t}\n\t\t\t\t\tif kv.v.s != tt.want.v.o.kvs[i].v.s {\n\t\t\t\t\t\tt.Errorf(\"parseObject() gotV.o.kvs[%d].v.s = %v, want %v\", i, kv.v.s, tt.want.v.o.kvs[i].v.s)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","d37f73f2514549345a227ae9b96d41ee":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantKey string\n\t\twantTail string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"empty string\",\n\t\t\targs:    args{s: \"\"},\n\t\t\twantKey: \"\",\n\t\t\twantTail: \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"no closing quote\",\n\t\t\targs:    args{s: `\"key`},\n\t\t\twantKey: \"\",\n\t\t\twantTail: \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"simple key\",\n\t\t\targs:    args{s: `\"key\"`},\n\t\t\twantKey: \"key\",\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"key with escape sequence\",\n\t\t\targs:    args{s: `\"key\\\\\"\"`},\n\t\t\twantKey: \"key\",\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"key with escape sequence and tail\",\n\t\t\targs:    args{s: `\"key\\\\\"\"test\"`},\n\t\t\twantKey: \"key\",\n\t\t\twantTail: `\"test\"`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"key with escaped quote\",\n\t\t\targs:    args{s: `\"key\\\\\"\"`},\n\t\t\twantKey: \"key\",\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"key with escaped slash\",\n\t\t\targs:    args{s: `\"key\\\\\\\\\"`},\n\t\t\twantKey: \"key\\\\\",\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotKey, gotTail, err := parseRawKey(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawKey() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotKey != tt.wantKey {\n\t\t\t\tt.Errorf(\"parseRawKey() gotKey = %v, want %v\", gotKey, tt.wantKey)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseRawKey() gotTail = %v, want %v\", gotTail, tt.wantTail)\n\t\t\t}\n\t\t})\n\t}\n}","d384e78a0455b8094e0cc981c2bfffd0":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_unescapeKeys(t *testing.T) {\n\ttype args struct {\n\t\to *Object\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant *Object\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\ttt.args.o.unescapeKeys()\n\t\t\tif !reflect.DeepEqual(tt.args.o, tt.want) {\n\t\t\t\tt.Errorf(\"Object.unescapeKeys() = %v, want %v\", tt.args.o, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","d4399876666ac672c67f3ad25ddf2cf4":"","d4b604f7b013fd7cbb085e5d0f4c170d":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"single digit\",\n\t\t\targs: args{\n\t\t\t\ts: \"1\",\n\t\t\t},\n\t\t\twantNs:  \"1\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple digits\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative number\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"positive number\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with decimal\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with exponent\",\n\t\t\targs: args{\n\t\t\t\ts: \"123e456\",\n\t\t\t},\n\t\t\twantNs:  \"123e456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with exponent and sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"123e+456\",\n\t\t\t},\n\t\t\twantNs:  \"123e+456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"inf\",\n\t\t\t},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inf with sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"+inf\",\n\t\t\t},\n\t\t\twantNs:  \"+inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"nan\",\n\t\t\t},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nan with sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"-nan\",\n\t\t\t},\n\t\t\twantNs:  \"-nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123abc\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"123abc\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}","d5afcbd21334131754f319a21296c8e1":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantV   *Value\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\twantS: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"single element array\",\n\t\t\targs: args{\n\t\t\t\ts:    `[ \"hello\" ]`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt:  TypeString,\n\t\t\t\t\t\ts: \"hello\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantS: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element array\",\n\t\t\targs: args{\n\t\t\t\ts:    `[ \"hello\", 123, true, { \"key\": \"value\" } ]`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt:  TypeString,\n\t\t\t\t\t\ts: \"hello\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\tt:  TypeString,\n\t\t\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantS: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with nested arrays\",\n\t\t\targs: args{\n\t\t\t\ts:    `[ [ \"hello\", 123 ], [ true, { \"key\": \"value\" } ] ]`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt:  TypeString,\n\t\t\t\t\t\t\t\ts: \"hello\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeTrue,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt:  TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantS: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:    `[ \"hello\", 123, true, { \"key\": \"value\" }`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV:   nil,\n\t\t\twantS:   `[ \"hello\", 123, true, { \"key\": \"value\" }`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing comma after array value\",\n\t\t\targs: args{\n\t\t\t\ts:    `[ \"hello\", 123 true, { \"key\": \"value\" } ]`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV:   nil,\n\t\t\twantS:   `[ \"hello\", 123 true, { \"key\": \"value\" } ]`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected end of array\",\n\t\t\targs: args{\n\t\t\t\ts:    `[ \"hello\", 123, true, { \"key\": \"value\" } `,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV:   nil,\n\t\t\twantS:   `[ \"hello\", 123, true, { \"key\": \"value\" } `,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotV, gotS, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(gotV, tt.wantV) {\n\t\t\t\tt.Errorf(\"parseArray() gotV = %v, wantV %v\", gotV, tt.wantV)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseArray() gotS = %v, wantS %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}","d6b58a3300f6f0aa3be4fdc50d3224d9":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_StringBytes(t *testing.T) {\n\ttype args struct {\n\t\tv *Value\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    []byte\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := tt.args.v.StringBytes()\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Value.StringBytes() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr \u0026\u0026 !bytes.Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.StringBytes() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","d82823f69afa030b585520cf90bdf567":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestType_String(t *testing.T) {\n\ttype args struct {\n\t\tt Type\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"TestType_String_Object\",\n\t\t\targs: args{t: TypeObject},\n\t\t\twant: \"object\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_Array\",\n\t\t\targs: args{t: TypeArray},\n\t\t\twant: \"array\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_String\",\n\t\t\targs: args{t: TypeString},\n\t\t\twant: \"string\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_Number\",\n\t\t\targs: args{t: TypeNumber},\n\t\t\twant: \"number\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_True\",\n\t\t\targs: args{t: TypeTrue},\n\t\t\twant: \"true\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_False\",\n\t\t\targs: args{t: TypeFalse},\n\t\t\twant: \"false\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestType_String_Null\",\n\t\t\targs: args{t: TypeNull},\n\t\t\twant: \"null\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.t.String(); got != tt.want {\n\t\t\t\tt.Errorf(\"Type.String() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","db61f8c8bafafa3f785b8278370ea805":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\"world\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\\\\\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote and other characters\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"123\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\\\\\\\"123\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote and other characters\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"123\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\\\\\\\"123\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote and other characters\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\\\\\"123\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\\\\\\\"123\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with multiple escaped quotes and other characters\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\"world\\\\\"123\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\\\\\\\"123\\\\\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with multiple closing quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","dc8534c514a95ac790249388b3fb0c86":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"empty string\",\n\t\t\targs:    args{s: \"\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"single digit\",\n\t\t\targs:    args{s: \"1\"},\n\t\t\twantNs:  \"1\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"multiple digits\",\n\t\t\targs:    args{s: \"123\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"negative number\",\n\t\t\targs:    args{s: \"-123\"},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"decimal number\",\n\t\t\targs:    args{s: \"123.456\"},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"exponential number\",\n\t\t\targs:    args{s: \"1.23e+4\"},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"exponential number with negative exponent\",\n\t\t\targs:    args{s: \"1.23e-4\"},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"inf\",\n\t\t\targs:    args{s: \"inf\"},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"Inf\",\n\t\t\targs:    args{s: \"Inf\"},\n\t\t\twantNs:  \"Inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"inF\",\n\t\t\targs:    args{s: \"inF\"},\n\t\t\twantNs:  \"inF\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"NaN\",\n\t\t\targs:    args{s: \"NaN\"},\n\t\t\twantNs:  \"NaN\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"nan\",\n\t\t\targs:    args{s: \"nan\"},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"nAn\",\n\t\t\targs:    args{s: \"nAn\"},\n\t\t\twantNs:  \"nAn\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with trailing whitespace\",\n\t\t\targs:    args{s: \"123 \"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \" \",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading whitespace\",\n\t\t\targs:    args{s: \" 123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" 123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with invalid character\",\n\t\t\targs:    args{s: \"123a\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with invalid character at start\",\n\t\t\targs:    args{s: \"a123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"a123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with invalid character at start 2\",\n\t\t\targs:    args{s: \"+123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with invalid character at start 3\",\n\t\t\targs:    args{s: \"-123\"},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with invalid character at start 4\",\n\t\t\targs:    args{s: \"-+123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"-+123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with invalid character at start 5\",\n\t\t\targs:    args{s: \"++123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"++123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with invalid character at start 6\",\n\t\t\targs:    args{s: \"--123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"--123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with invalid character at start 7\",\n\t\t\targs:    args{s: \"+123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with invalid character at start 8\",\n\t\t\targs:    args{s: \"-+123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"-+123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with invalid character at start 9\",\n\t\t\targs:    args{s: \"++123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"++123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with invalid character at start 10\",\n\t\t\targs:    args{s: \"--123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"--123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with invalid character at start 11\",\n\t\t\targs:    args{s: \"123-\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"-\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with invalid character at start 12\",\n\t\t\targs:    args{s: \"123+\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"+\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}","dc8ba8ea3d6e15a7873c4367652b2c60":"package fastjson\n\nimport \"testing\"\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no whitespace\",\n\t\t\targs: args{s: \"abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace\",\n\t\t\targs: args{s: \"  abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailing whitespace\",\n\t\t\targs: args{s: \"abc  \"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"whitespace in the middle\",\n\t\t\targs: args{s: \"a bc\"},\n\t\t\twant: \"bc\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple whitespace\",\n\t\t\targs: args{s: \"  a  bc  \"},\n\t\t\twant: \"bc\",\n\t\t},\n\t\t{\n\t\t\tname: \"all whitespace\",\n\t\t\targs: args{s: \"  \\t\\r\\n  \"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading and trailing whitespace\",\n\t\t\targs: args{s: \"  \\t\\r\\n  abc  \\t\\r\\n  \"},\n\t\t\twant: \"abc\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","dca2d006634fa60407c962b9f0af8fda":"```go\npackage fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    \u0026Value{t: TypeObject, o: Object{kvs: nil, keysUnescaped: false}},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": 2}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}}, {k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"2\"}}}, keysUnescaped: false}},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": {\"key2\": \"value2\"}, \"key3\": [1, 2, 3]}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key1\", v: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}}}, keysUnescaped: false}}}, {k: \"key3\", v: \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber","dd219a2aa44bcb66c6744f5b2ba36ce9":"package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\"\",\n\t\t\twant: \"\\\"hello\\\"\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello\\\\\\\\\"},\n\t\t\twant: \"\\\\hello\\\\\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped slashes\",\n\t\t\targs: args{s: \"\\\\/hello\\\\/\"},\n\t\t\twant: \"/hello/\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello\\\\b\"},\n\t\t\twant: \"\\bhello\\b\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello\\\\f\"},\n\t\t\twant: \"\\fhello\\f\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello\\\\n\"},\n\t\t\twant: \"\\nhello\\n\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello\\\\r\"},\n\t\t\twant: \"\\rhello\\r\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello\\\\t\"},\n\t\t\twant: \"\\thello\\t\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode character\",\n\t\t\targs: args{s: \"\\\\u0061hello\\\\u0062\"},\n\t\t\twant: \"ahello b\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01hello\\\\uD83D\\\\uDE02\"},\n\t\t\twant: \"😁hello😂\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello\\\\x\"},\n\t\t\twant: \"\\\\xhello\\\\x\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{s: \"\\\\u006\"},\n\t\t\twant: \"\\\\u006\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\\\\\ \\\\/test\\\\/ \\\\b\\\\f\\\\n\\\\r\\\\t \\\\u0061\\\\u0062\"},\n\t\t\twant: \"\\\"hello\\\" \\\\world\\\\ /test/ \\b\\f\\n\\r\\t ab\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","dde25cf643e56e97e53ca4ead8c2e7f0":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative integer\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple float\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.45\",\n\t\t\t},\n\t\t\twantNs:  \"123.45\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"float with exponent\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"float with exponent and sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e-4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"inf\",\n\t\t\t},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"INF\",\n\t\t\targs: args{\n\t\t\t\ts: \"INF\",\n\t\t\t},\n\t\t\twantNs:  \"INF\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"nan\",\n\t\t\t},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NAN\",\n\t\t\targs: args{\n\t\t\t\ts: \"NAN\",\n\t\t\t},\n\t\t\twantNs:  \"NAN\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"leading plus\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char\",\n\t\t\targs: args{\n\t\t\t\ts: \"123a\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char at beginning\",\n\t\t\targs: args{\n\t\t\t\ts: \"a123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"a123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char after sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"-a123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"-a123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected char after sign 2\",\n\t\t\targs: args{\n\t\t\t\ts: \"+a123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+a123\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}","de1d09d9d4effb17d78a1263560aee71":"```go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no whitespace\",\n\t\t\targs: args{s: \"abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace\",\n\t\t\targs: args{s: \"   abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailing whitespace\",\n\t\t\targs: args{s: \"abc   \"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading and trailing whitespace\",\n\t\t\targs: args{s: \"   abc   \"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"whitespace in the middle\",\n\t\t\targs: args{s: \"a bc\"},\n\t\t\twant: \"bc\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple whitespace\",\n\t\t\targs: args{s: \"  a  b  c  \"},\n\t\t\twant: \"a  b  c\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace with newline\",\n\t\t\targs: args{s: \"\\n  abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace with tab\",\n\t\t\targs: args{s: \"\\t  abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace with carriage return\",\n\t\t\targs: args{s: \"\\r  abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace with all types\",\n\t\t\targs: args{s: \" \\n\\t\\r abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace with all types and trailing whitespace\",\n\t\t\targs: args{s: \" \\n\\t\\r abc  \"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"all whitespace\",\n","df4c44fc41f3659b59dbb32405ad0613":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetBool(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant bool\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.GetBool(tt.args.keys...); got != tt.want {\n\t\t\t\tt.Errorf(\"Value.GetBool() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","e08540605cae6ed9a666d3cee7b412f7":"package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello world\",\n\t\t\t},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\\\\"hello\\\\\\\"\",\n\t\t\t},\n\t\t\twant: \"\\\"hello\\\"\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\\\\\hello\\\\\\\\\",\n\t\t\t},\n\t\t\twant: \"\\\\hello\\\\\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped slashes\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\/hello\\\\/\",\n\t\t\t},\n\t\t\twant: \"/hello/\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped b\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\bhello\\\\b\",\n\t\t\t},\n\t\t\twant: \"\\bhello\\b\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped f\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\fhello\\\\f\",\n\t\t\t},\n\t\t\twant: \"\\fhello\\f\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped n\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\nhello\\\\n\",\n\t\t\t},\n\t\t\twant: \"\\nhello\\n\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped r\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\rhello\\\\r\",\n\t\t\t},\n\t\t\twant: \"\\rhello\\r\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped t\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\thello\\\\t\",\n\t\t\t},\n\t\t\twant: \"\\thello\\t\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped u\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\u0061hello\\\\u0062\",\n\t\t\t},\n\t\t\twant: \"ahello b\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\uD83D\\\\uDE01hello\\\\uD83D\\\\uDE02\",\n\t\t\t},\n\t\t\twant: \"😀hello😂\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\xhello\\\\x\",\n\t\t\t},\n\t\t\twant: \"\\\\xhello\\\\x\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete escape sequence\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\u0061hello\",\n\t\t\t},\n\t\t\twant: \"\\\\u0061hello\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete surrogate pair\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\uD83Dhello\",\n\t\t\t},\n\t\t\twant: \"\\\\uD83Dhello\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\\\\"hello\\\\\\\"\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\u0062\",\n\t\t\t},\n\t\t\twant: \"\\\"hello\\\"\\b\\f\\n\\r\\ta b\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","e0c44423b42e12e4986c689637048fc2":"package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello world\",\n\t\t\t},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quote\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello world\\\"\",\n\t\t\t},\n\t\t\twant: \"\\\"hello world\\\"\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslash\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\hello world\",\n\t\t\t},\n\t\t\twant: \"\\\\hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slash\",\n\t\t\targs: args{\n\t\t\t\ts: \"/hello world\",\n\t\t\t},\n\t\t\twant: \"/hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\bhello world\",\n\t\t\t},\n\t\t\twant: \"\\bhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\fhello world\",\n\t\t\t},\n\t\t\twant: \"\\fhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\nhello world\",\n\t\t\t},\n\t\t\twant: \"\\nhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\rhello world\",\n\t\t\t},\n\t\t\twant: \"\\rhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\thello world\",\n\t\t\t},\n\t\t\twant: \"\\thello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\u0061hello world\",\n\t\t\t},\n\t\t\twant: \"ahello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode surrogate pair\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\uD83D\\\\uDE01hello world\",\n\t\t\t},\n\t\t\twant: \"😁hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\xhello world\",\n\t\t\t},\n\t\t\twant: \"\\\\xhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\\\\"\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\uD83D\\\\uDE01hello world\",\n\t\t\t},\n\t\t\twant: \"\\\"\\\\b\\f\\n\\r\\ta😁hello world\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","e21671345d404e178d58a9be757c585b":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantV  *Value\n\t\twantS  string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{},\n\t\t\t},\n\t\t\twantS:  \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with one element\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantS:  \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,3]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantS:  \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with nested array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[[1,2],[3,4]]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"4\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantS:  \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with invalid element\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV:  nil,\n\t\t\twantS:  \",]\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"array with missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV:  nil,\n\t\t\twantS:  \"\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotV, gotS, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(gotV, tt.wantV) {\n\t\t\t\tt.Errorf(\"parseArray() gotV = %v, wantV %v\", gotV, tt.wantV)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseArray() gotS = %v, wantS %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}","e23f2363915a7f8671a8500fbf19be5d":"package fastjson\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttype args struct {\n\t\tv   *Value\n\t\tdst []byte\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\tv:   \u0026Value{t: TypeString, s: \"test\"},\n\t\t\t\tdst: []byte{},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"test\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t\tdst: []byte{},\n\t\t\t},\n\t\t\twant: []byte(\"123\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\tv:   \u0026Value{t: TypeTrue},\n\t\t\t\tdst: []byte{},\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\tv:   \u0026Value{t: TypeFalse},\n\t\t\t\tdst: []byte{},\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\tv:   \u0026Value{t: TypeNull},\n\t\t\t\tdst: []byte{},\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdst: []byte{},\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":\"value1\",\"key2\":123}`),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{t: TypeString, s: \"value1\"},\n\t\t\t\t\t\t{t: TypeNumber, s: \"123\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdst: []byte{},\n\t\t\t},\n\t\t\twant: []byte(`[\"value1\",123]`),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.v.MarshalTo(tt.args.dst); !bytes.Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValueMarshalTo_escapedString(t *testing.T) {\n\ttype args struct {\n\t\tv   *Value\n\t\tdst []byte\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"escaped string\",\n\t\t\targs: args{\n\t\t\t\tv:   \u0026Value{t: TypeString, s: `\"\\t\\r\\n\\\\\"`},\n\t\t\t\tdst: []byte{},\n\t\t\t},\n\t\t\twant: []byte(`\"\\\\\\\"\\\\t\\\\r\\\\n\\\\\\\\\"`),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.v.MarshalTo(tt.args.dst); !bytes.Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValueMarshalTo_compareWithJSONMarshal(t *testing.T) {\n\ttype args struct {\n\t\tv   *Value\n\t\tdst []byte\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t}{\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\tv:   \u0026Value{t: TypeString, s: \"test\"},\n\t\t\t\tdst: []byte{},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t\tdst: []byte{},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\tv:   \u0026Value{t: TypeTrue},\n\t\t\t\tdst: []byte{},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\tv:   \u0026Value{t: TypeFalse},\n\t\t\t\tdst: []byte{},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\tv:   \u0026Value{t: TypeNull},\n\t\t\t\tdst: []byte{},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdst: []byte{},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{t: TypeString, s: \"value1\"},\n\t\t\t\t\t\t{t: TypeNumber, s: \"123\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdst: []byte{},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"escaped string\",\n\t\t\targs: args{\n\t\t\t\tv:   \u0026Value{t: TypeString, s: `\"\\t\\r\\n\\\\\"`},\n\t\t\t\tdst: []byte{},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst1 := tt.args.v.MarshalTo(tt.args.dst)\n\t\t\tdst2 := make([]byte, 0)\n\t\t\tjson.Marshal(tt.args.v, \u0026dst2)\n\t\t\tif !bytes.Equal(dst1, dst2) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %s, want %s\", string(dst1), string(dst2))\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValueMarshalTo_panic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Value.MarshalTo() should panic\")\n\t\t}\n\t}()\n\tv := \u0026Value{t: 8}\n\tv.MarshalTo([]byte{})\n}","e29ea33cab5b9f9fb4523fdea62a7bfd":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"empty string\",\n\t\t\targs:    args{s: \"\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"simple integer\",\n\t\t\targs:    args{s: \"123\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"negative integer\",\n\t\t\targs:    args{s: \"-123\"},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"floating point number\",\n\t\t\targs:    args{s: \"123.456\"},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"exponential notation\",\n\t\t\targs:    args{s: \"1.23e+4\"},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"exponential notation with negative exponent\",\n\t\t\targs:    args{s: \"1.23e-4\"},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with leading whitespace\",\n\t\t\targs:    args{s: \" 123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" 123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with trailing whitespace\",\n\t\t\targs:    args{s: \"123 \"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \" \",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid number with invalid character\",\n\t\t\targs:    args{s: \"123a\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"inf\",\n\t\t\targs:    args{s: \"inf\"},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"INF\",\n\t\t\targs:    args{s: \"INF\"},\n\t\t\twantNs:  \"INF\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"InF\",\n\t\t\targs:    args{s: \"InF\"},\n\t\t\twantNs:  \"InF\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"nan\",\n\t\t\targs:    args{s: \"nan\"},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"NAN\",\n\t\t\targs:    args{s: \"NAN\"},\n\t\t\twantNs:  \"NAN\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"NaN\",\n\t\t\targs:    args{s: \"NaN\"},\n\t\t\twantNs:  \"NaN\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid inf\",\n\t\t\targs:    args{s: \"in\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"in\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid nan\",\n\t\t\targs:    args{s: \"na\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"na\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}","e2f1c5765c1a8aba24c0ebf5d434d945":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"key2\": \"value2\"}, \"key3\": \"value3\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped keys\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing colon after key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing opening double quote for key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{key1: \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{key1: \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"unexpected end of object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\",`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": \"value2\",`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr {\n\t\t\t\tif !compareValue(got, tt.want) {\n\t\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t\t}\n\t\t\t\tif got1 != tt.want1 {\n\t\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValue(got, want *Value) bool {\n\tif got == nil \u0026\u0026 want == nil {\n\t\treturn true\n\t}\n\tif got == nil || want == nil {\n\t\treturn false\n\t}\n\tif got.t != want.t {\n\t\treturn false\n\t}\n\tswitch got.t {\n\tcase TypeObject:\n\t\tif len(got.o.kvs) != len(want.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range got.o.kvs {\n\t\t\tif got.o.kvs[i].k != want.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !compareValue(got.o.kvs[i].v, want.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\tcase TypeArray:\n\t\tif len(got.a) != len(want.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range got.a {\n\t\t\tif !compareValue(got.a[i], want.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\tcase TypeString:\n\t\tif got.s != want.s {\n\t\t\treturn false\n\t\t}\n\tcase TypeNumber:\n\t\t// TODO: compare numbers\n\tcase TypeTrue, TypeFalse:\n\t\t// TODO: compare bool\n\tcase TypeNull:\n\t\t// TODO: compare null\n\t}\n\treturn true\n}","e310404b1d11354d4286fbf82a7a9788":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"single key-value pair\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\": \"value\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple key-value pairs\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"key2\": \"value2\"}, \"key3\": \"value3\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\": \"value\"`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key\": \"value\"`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"value\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"value\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\" \"value\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key\" \"value\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","e32f3799b5fb1bcda0719fd195661530":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"strconv\"\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\"hello world\\\"\"},\n\t\t\twant: \"\\\"hello world\\\"\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello world\"},\n\t\t\twant: \"\\\\hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello world\"},\n\t\t\twant: \"/hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello world\"},\n\t\t\twant: \"\\bhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello world\"},\n\t\t\twant: \"\\fhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello world\"},\n\t\t\twant: \"\\nhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello world\"},\n\t\t\twant: \"\\rhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello world\"},\n\t\t\twant: \"\\thello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061hello world\"},\n\t\t\twant: \"ahello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01hello world\"},\n\t\t\twant: \"😀hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello world\"},\n\t\t\twant: \"\\\\xhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"short escape sequence\",\n\t\t\targs: args{s: \"\\\\u00hello world\"},\n\t\t\twant: \"\\\\u00hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0061\\\\u0042hello world\"},\n\t\t\twant: \"\\\"\\\\b\\f\\n\\r\\taBhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped with other characters\",\n\t\t\targs: args{s: \"hello\\\\\\\"world\\\\b\"},\n\t\t\twant: \"hello\\\"world\\b\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestUnescapeStringBestEffort_JSON(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{s: `\"hello world\"`},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: `\"hello \\\"world\\\"\"`},\n\t\t\twant: `hello \"world\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: `\"hello \\\\world\"`},\n\t\t\twant: `hello \\world`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: `\"hello /world\"`},\n\t\t\twant: `hello /world`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: `\"hello \\bworld\"`},\n\t\t\twant: `hello \\bworld`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: `\"hello \\fworld\"`},\n\t\t\twant: `hello \\fworld`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: `\"hello \\nworld\"`},\n\t\t\twant: `hello \\nworld`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: `\"hello \\rworld\"`},\n\t\t\twant: `hello \\rworld`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: `\"hello \\tworld\"`},\n\t\t\twant: `hello \\tworld`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: `\"hello \\u0061world\"`},\n\t\t\twant: `hello aworld`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: `\"hello \\uD83D\\uDE01world\"`},\n\t\t\twant: `hello 😀world`,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: `\"hello \\xworld\"`},\n\t\t\twant: `hello \\xworld`,\n\t\t},\n\t\t{\n\t\t\tname: \"short escape sequence\",\n\t\t\targs: args{s: `\"hello \\u00world\"`},\n\t\t\twant: `hello \\u00world`,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: `\"hello \\\\\"\\b\\f\\n\\r\\t\\u0061\\u0042world\"`},\n\t\t\twant: `hello \"\\b\\f\\n\\r\\taBworld`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped with other characters\",\n\t\t\targs: args{s: `\"hello\\\\\\\"world\\\\b\"`},\n\t\t\twant: `hello\\\"world\\b`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped with other characters\",\n\t\t\targs: args{s: `\"hello\\\\\\\"world\\\\b\"`},\n\t\t\twant: `hello\\\"world\\b`,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := unescapeStringBestEffort(tt.args.s)\n\t\t\tif !tt.wantErr {\n\t\t\t\tif got != tt.want {\n\t\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif got == tt.want {\n\t\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want error\", got)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestUnescapeStringBestEffort_JSON_Compare(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{s: `\"hello world\"`},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: `\"hello \\\"world\\\"\"`},\n\t\t\twant: `hello \"world\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: `\"hello \\\\world\"`},\n\t\t\twant: `hello \\world`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: `\"hello /world\"`},\n\t\t\twant: `hello /world`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: `\"hello \\bworld\"`},\n\t\t\twant: `hello \\bworld`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: `\"hello \\fworld\"`},\n\t\t\twant: `hello \\fworld`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: `\"hello \\nworld\"`},\n\t\t\twant: `hello \\nworld`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: `\"hello \\rworld\"`},\n\t\t\twant: `hello \\rworld`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: `\"hello \\tworld\"`},\n\t\t\twant: `hello \\tworld`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: `\"hello \\u0061world\"`},\n\t\t\twant: `hello aworld`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: `\"hello \\uD83D\\uDE01world\"`},\n\t\t\twant: `hello 😀world`,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: `\"hello \\xworld\"`},\n\t\t\twant: `hello \\xworld`,\n\t\t},\n\t\t{\n\t\t\tname: \"short escape sequence\",\n\t\t\targs: args{s: `\"hello \\u00world\"`},\n\t\t\twant: `hello \\u00world`,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: `\"hello \\\\\"\\b\\f\\n\\r\\t\\u0061\\u0042world\"`},\n\t\t\twant: `hello \"\\b\\f\\n\\r\\taBworld`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped with other characters\",\n\t\t\targs: args{s: `\"hello\\\\\\\"world\\\\b\"`},\n\t\t\twant: `hello\\\"world\\b`,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := unescapeStringBestEffort(tt.args.s)\n\t\t\tif !tt.wantErr {\n\t\t\t\tif got != tt.want {\n\t\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t\t}\n\t\t\t\tvar jsonGot interface{}\n\t\t\t\tif err := json.Unmarshal([]byte(got), \u0026jsonGot); err != nil {\n\t\t\t\t\tt.Errorf(\"json.Unmarshal(%v) error = %v\", got, err)\n\t\t\t\t}\n\t\t\t\tvar jsonWant interface{}\n\t\t\t\tif err := json.Unmarshal([]byte(tt.want), \u0026jsonWant); err != nil {\n\t\t\t\t\tt.Errorf(\"json.Unmarshal(%v) error = %v\", tt.want, err)\n\t\t\t\t}\n\t\t\t\tif !reflect.DeepEqual(jsonGot, jsonWant) {\n\t\t\t\t\tt.Errorf(\"json.Unmarshal(%v) = %v, want %v\", tt.args.s, jsonGot, jsonWant)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif got == tt.want {\n\t\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want error\", got)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc BenchmarkUnescapeStringBestEffort(b *testing.B) {\n\ts := `\"hello \\u0061world\"`\n\tfor i := 0; i \u003c b.N; i++ {\n\t\tunescapeStringBestEffort(s)\n\t}\n}","e367c07855bfa56e25589782286ec8b7":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"no escape\",\n\t\t\targs: args{s: `\"hello\"`},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quote\",\n\t\t\targs: args{s: `\"hello\\\\\"\"`},\n\t\t\twant:    \"hello\\\"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quote in the middle\",\n\t\t\targs: args{s: `\"hel\\\\\"lo\"`},\n\t\t\twant:    \"hel\\\"lo\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escaped quotes\",\n\t\t\targs: args{s: `\"hel\\\\\"lo\\\\\"\"`},\n\t\t\twant:    \"hel\\\"lo\\\"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quote with other escape sequences\",\n\t\t\targs: args{s: `\"hel\\\\\"lo\\\\t\\\\n\\\\r\\\\b\\\\f\\\\/\\\\\"\\\\\\\\\"`},\n\t\t\twant:    \"hel\\\"lo\\t\\n\\r\\b\\f/\\\"\\\"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{s: `\"hello`},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: `\"\"`},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"no quotes\",\n\t\t\targs: args{s: `hello`},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","e3b625c10b9083a177ee75bf2554ab5a":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"Empty array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    \u0026Value{t: TypeArray, a: []*Value{}},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Simple array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[1,2,3]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Array with nested objects\",\n\t\t\targs: args{\n\t\t\t\ts:   `[{\"a\": 1}, {\"b\": 2}]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t{k: \"a\", v: \u0026Value{t: TypeNumber, s: \"1\"}},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t{k: \"b\", v: \u0026Value{t: TypeNumber, s: \"2\"}},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Array with invalid value\",\n\t\t\targs: args{\n\t\t\t\ts:   `[1,2,a]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"a]\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Array with missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:   `[1,2,3`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseArray() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","e3eb0620aefa4f7a91429e17a5df1d87":"package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"abcdefg\"},\n\t\t\twant: \"abcdefg\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: `\\\"`},\n\t\t\twant: `\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: `\\\\`},\n\t\t\twant: `\\`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: `\\/`},\n\t\t\twant: `/`,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: `\\b`},\n\t\t\twant: \"\\b\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: `\\f`},\n\t\t\twant: \"\\f\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: `\\n`},\n\t\t\twant: \"\\n\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: `\\r`},\n\t\t\twant: \"\\r\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: `\\t`},\n\t\t\twant: \"\\t\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: `\\u0061`},\n\t\t\twant: \"a\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: `\\uD83D\\uDE01`},\n\t\t\twant: \"😁\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: `\\z`},\n\t\t\twant: `\\z`,\n\t\t},\n\t\t{\n\t\t\tname: \"short unicode escape sequence\",\n\t\t\targs: args{s: `\\u006`},\n\t\t\twant: `\\u006`,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: `\\\"\\\\\\/\\b\\f\\n\\r\\t\\u0061\\uD83D\\uDE01\\z`},\n\t\t\twant: `\"\\/\\b\\f\\n\\r\\ta😁\\z`,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","e3f590dbf2ba58be97e9c05ed05fbb1a":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestString(t *testing.T) {\n\ttype args struct {\n\t\tt Type\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"TypeObject\",\n\t\t\targs: args{\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\twant: \"object\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeArray\",\n\t\t\targs: args{\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\twant: \"array\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeString\",\n\t\t\targs: args{\n\t\t\t\tt: TypeString,\n\t\t\t},\n\t\t\twant: \"string\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeNumber\",\n\t\t\targs: args{\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\twant: \"number\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeTrue\",\n\t\t\targs: args{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: \"true\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeFalse\",\n\t\t\targs: args{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: \"false\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeNull\",\n\t\t\targs: args{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: \"null\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.t.String(); got != tt.want {\n\t\t\t\tt.Errorf(\"String() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","e51e94608dd11bf35b4e80233aad4416":"package fastjson\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\tv   *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"RawString\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: typeRawString, s: \"hello world\"},\n\t\t\t},\n\t\t\twant: []byte(`\"hello world\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"Object\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}}, {k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}}}},\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":\"value1\",\"key2\":123}`),\n\t\t},\n\t\t{\n\t\t\tname: \"Array\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeArray, a: []*Value{{t: TypeString, s: \"value1\"}, {t: TypeNumber, s: \"123\"}}},\n\t\t\t},\n\t\t\twant: []byte(`[\"value1\",123]`),\n\t\t},\n\t\t{\n\t\t\tname: \"String\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeString, s: \"hello world\"},\n\t\t\t},\n\t\t\twant: []byte(`\"hello world\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"Number\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t},\n\t\t\twant: []byte(`123`),\n\t\t},\n\t\t{\n\t\t\tname: \"True\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeTrue},\n\t\t\t},\n\t\t\twant: []byte(`true`),\n\t\t},\n\t\t{\n\t\t\tname: \"False\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeFalse},\n\t\t\t},\n\t\t\twant: []byte(`false`),\n\t\t},\n\t\t{\n\t\t\tname: \"Null\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNull},\n\t\t\t},\n\t\t\twant: []byte(`null`),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.v.MarshalTo(tt.args.dst); !bytes.Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","e5485be886fbf998b404fd9392355eb6":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetFloat64(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.GetFloat64(tt.args.keys...); got != tt.want {\n\t\t\t\tt.Errorf(\"Value.GetFloat64() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","e5859f88ecff2e15e312b6c54fde32c3":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\tv   *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: typeRawString, s: \"test\"},\n\t\t\t},\n\t\t\twant: []byte(`\"test\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{t: TypeString, s: \"value\"}}}}},\n\t\t\t},\n\t\t\twant: []byte(`{\"key\":\"value\"}`),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeArray, a: []*Value{{t: TypeString, s: \"value1\"}, {t: TypeString, s: \"value2\"}}},\n\t\t\t},\n\t\t\twant: []byte(`[\"value1\",\"value2\"]`),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeString, s: \"test\"},\n\t\t\t},\n\t\t\twant: []byte(`\"test\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t},\n\t\t\twant: []byte(`123`),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeTrue},\n\t\t\t},\n\t\t\twant: []byte(`true`),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeFalse},\n\t\t\t},\n\t\t\twant: []byte(`false`),\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNull},\n\t\t\t},\n\t\t\twant: []byte(`null`),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.v.MarshalTo(tt.args.dst); !bytesEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", string(got), string(tt.want))\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc bytesEqual(a, b []byte) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","e59539ec2cf73eea40662f8b045e72c5":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObjectVisit(t *testing.T) {\n\ttype args struct {\n\t\tf func(key []byte, v *Value)\n\t}\n\ttests := []struct {\n\t\tname string\n\t\to    *Object\n\t\targs args\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\ttt.o.Visit(tt.args.f)\n\t\t})\n\t}\n}","e68dfded8d2b26a44da71ff5e78c83dd":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"simple number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative number\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with decimal\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with exponent\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with exponent and sign\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e-4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zeros\",\n\t\t\targs: args{\n\t\t\t\ts: \"00123\",\n\t\t\t},\n\t\t\twantNs:  \"00123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with trailing zeros\",\n\t\t\targs: args{\n\t\t\t\ts: \"12300\",\n\t\t\t},\n\t\t\twantNs:  \"12300\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading and trailing zeros\",\n\t\t\targs: args{\n\t\t\t\ts: \"0012300\",\n\t\t\t},\n\t\t\twantNs:  \"0012300\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zero and decimal\",\n\t\t\targs: args{\n\t\t\t\ts: \"0.123\",\n\t\t\t},\n\t\t\twantNs:  \"0.123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading zero and exponent\",\n\t\t\targs: args{\n\t\t\t\ts: \"0e+10\",\n\t\t\t},\n\t\t\twantNs:  \"0e+10\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading minus and plus\",\n\t\t\targs: args{\n\t\t\t\ts: \"-+123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"-+123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number with leading plus and minus\",\n\t\t\targs: args{\n\t\t\t\ts: \"+-123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+-123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number with inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"inf\",\n\t\t\t},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with INF\",\n\t\t\targs: args{\n\t\t\t\ts: \"INF\",\n\t\t\t},\n\t\t\twantNs:  \"INF\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with InF\",\n\t\t\targs: args{\n\t\t\t\ts: \"InF\",\n\t\t\t},\n\t\t\twantNs:  \"InF\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"nan\",\n\t\t\t},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with NAN\",\n\t\t\targs: args{\n\t\t\t\ts: \"NAN\",\n\t\t\t},\n\t\t\twantNs:  \"NAN\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with NaN\",\n\t\t\targs: args{\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twantNs:  \"NaN\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with inf and trailing chars\",\n\t\t\targs: args{\n\t\t\t\ts: \"infabc\",\n\t\t\t},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"abc\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with nan and trailing chars\",\n\t\t\targs: args{\n\t\t\t\ts: \"nanabc\",\n\t\t\t},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"abc\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid char\",\n\t\t\targs: args{\n\t\t\t\ts: \"123a\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid char at beginning\",\n\t\t\targs: args{\n\t\t\t\ts: \"a123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"a123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"number with invalid char at beginning 2\",\n\t\t\targs: args{\n\t\t\t\ts: \"1a23\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"1a23\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}","e6b2976f720156be6211fd77b2f75c07":"```go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\tv   *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"MarshalTo_RawString\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: typeRawString,\n\t\t\t\t\ts: \"test\",\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`\"test\"`),\n\t\t},\n\t\t{\n","e6cb490bb2c0d83ed347c3d9f08ba14a":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWS(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no whitespace\",\n\t\t\targs: args{s: \"abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace\",\n\t\t\targs: args{s: \"  abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailing whitespace\",\n\t\t\targs: args{s: \"abc  \"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading and trailing whitespace\",\n\t\t\targs: args{s: \"  abc  \"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"whitespace in the middle\",\n\t\t\targs: args{s: \"a bc\"},\n\t\t\twant: \"a bc\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple whitespace\",\n\t\t\targs: args{s: \"  a   b  c  \"},\n\t\t\twant: \"a   b  c\",\n\t\t},\n\t\t{\n\t\t\tname: \"special characters\",\n\t\t\targs: args{s: \"  a\\t\\nb\\r\\nc  \"},\n\t\t\twant: \"a\\t\\nb\\r\\nc\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWS(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWS() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","e7400b10fb6d7115b93dba7c2dfd9129":"```go\npackage fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape\",\n\t\t\targs: args{s: \"abcdefg\"},\n\t\t\twant: \"abcdefg\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quote\",\n\t\t\targs: args{s: \"\\\\\\\"\"},\n\t\t\twant: \"\\\"\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslash\",\n\t\t\targs: args{s: \"\\\\\\\\\"},\n\t\t\twant: \"\\\\\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped slash\",\n\t\t\targs: args{s: \"\\\\/\"},\n\t\t\twant: \"/\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped b\",\n\t\t\targs: args{s: \"\\\\b\"},\n\t\t\twant: \"\\b\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped f\",\n\t\t\targs: args{s: \"\\\\f\"},\n\t\t\twant: \"\\f\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped n\",\n\t\t\targs: args{s: \"\\\\n\"},\n\t\t\twant: \"\\n\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped r\",\n\t\t\targs: args{s: \"\\\\r\"},\n\t\t\twant: \"\\r\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped t\",\n\t\t\targs: args{s: \"\\\\t\"},\n\t\t\twant: \"\\t\",","e74702fd6fc7d1ac731ed0c5591cd278":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"Empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    \u0026Value{t: TypeObject, o: Object{}},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\": \"value\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{t: TypeObject, o: Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"key\", v: \u0026Value{t: TypeString, s: \"value\"}},\n\t\t\t\t},\n\t\t\t}},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"key2\": \"value\"}}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{t: TypeObject, o: Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{\n\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\tv: \u0026Value{t: TypeObject, o: Object{\n\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value\"}},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Object with multiple keys\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": \"value2\", \"key3\": \"value3\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{t: TypeObject, o: Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}},\n\t\t\t\t\t{k: \"key3\", v: \u0026Value{t: TypeString, s: \"value3\"}},\n\t\t\t\t},\n\t\t\t}},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Object with escaped keys\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\\\\\\\"1\": \"value1\", \"key2\\\\\\\"\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{t: TypeObject, o: Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: `key\"1`, v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t{k: `key2\"`, v: \u0026Value{t: TypeString, s: \"value2\"}},\n\t\t\t\t},\n\t\t\t}},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Invalid object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\": \"value`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key\": \"value`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\": \"value\"`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key\": \"value\"`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key\" \"value\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key\" \"value\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_Unmarshal(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tjson    string\n\t\twant    map[string]interface{}\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"Empty object\",\n\t\t\tjson:    `{}`,\n\t\t\twant:    map[string]interface{}{},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"Simple object\",\n\t\t\tjson:    `{\"key\": \"value\"}`,\n\t\t\twant:    map[string]interface{}{\"key\": \"value\"},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"Nested object\",\n\t\t\tjson:    `{\"key1\": {\"key2\": \"value\"}}`,\n\t\t\twant:    map[string]interface{}{\"key1\": map[string]interface{}{\"key2\": \"value\"}},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"Object with multiple keys\",\n\t\t\tjson:    `{\"key1\": \"value1\", \"key2\": \"value2\", \"key3\": \"value3\"}`,\n\t\t\twant:    map[string]interface{}{\"key1\": \"value1\", \"key2\": \"value2\", \"key3\": \"value3\"},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"Object with escaped keys\",\n\t\t\tjson:    `{\"key\\\\\\\"1\": \"value1\", \"key2\\\\\\\"\": \"value2\"}`,\n\t\t\twant:    map[string]interface{}{`key\"1`: \"value1\", `key2\"`: \"value2\"},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"Invalid object\",\n\t\t\tjson:    `{\"key\": \"value`,\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"Missing closing brace\",\n\t\t\tjson:    `{\"key\": \"value\"`,\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"Missing colon\",\n\t\t\tjson:    `{\"key\" \"value\"}`,\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"Missing comma\",\n\t\t\tjson:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv, _, err := parseObject(tt.json, \u0026cache{}, 0)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif tt.wantErr {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgot := make(map[string]interface{})\n\t\t\tfor _, kv := range v.o.kvs {\n\t\t\t\tswitch kv.v.t {\n\t\t\t\tcase TypeString:\n\t\t\t\t\tgot[kv.k] = kv.v.s\n\t\t\t\tcase TypeNumber:\n\t\t\t\t\tvar num float64\n\t\t\t\t\tjson.Unmarshal([]byte(kv.v.s), \u0026num)\n\t\t\t\t\tgot[kv.k] = num\n\t\t\t\tcase TypeBool:\n\t\t\t\t\tvar b bool\n\t\t\t\t\tjson.Unmarshal([]byte(kv.v.s), \u0026b)\n\t\t\t\t\tgot[kv.k] = b\n\t\t\t\tcase TypeArray:\n\t\t\t\t\tgot[kv.k] = kv.v.a\n\t\t\t\tcase TypeObject:\n\t\t\t\t\tgot[kv.k] = kv.v.o\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","e7490200a8c15ff50bab2c7d5fde9cac":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"empty string\",\n\t\t\targs:    args{s: \"\"},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"no closing quote\",\n\t\t\targs:    args{s: `\"hello`},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"simple string\",\n\t\t\targs:    args{s: `\"hello\"`},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"escaped quote\",\n\t\t\targs:    args{s: `\"hello\\\\\"`},\n\t\t\twant:    \"hello\\\"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"multiple escaped quotes\",\n\t\t\targs:    args{s: `\"hello\\\\\\\"world\\\\\"`},\n\t\t\twant:    \"hello\\\"world\\\"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"escaped quote with other characters\",\n\t\t\targs:    args{s: `\"hello\\\\\"world\\\\\"!\"`},\n\t\t\twant:    \"hello\\\"world\\\"\",\n\t\t\twant1:   \"!\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"escaped quote with newline\",\n\t\t\targs:    args{s: `\"hello\\\\\"world\\\\\\n\"`},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\\n\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"escaped quote with tab\",\n\t\t\targs:    args{s: `\"hello\\\\\"world\\\\\\t\"`},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\\t\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"escaped quote with backspace\",\n\t\t\targs:    args{s: `\"hello\\\\\"world\\\\\\b\"`},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\\b\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"escaped quote with carriage return\",\n\t\t\targs:    args{s: `\"hello\\\\\"world\\\\\\r\"`},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\\r\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"escaped quote with form feed\",\n\t\t\targs:    args{s: `\"hello\\\\\"world\\\\\\f\"`},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\\f\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"escaped quote with escape character\",\n\t\t\targs:    args{s: `\"hello\\\\\"world\\\\\\\\\"`},\n\t\t\twant:    \"hello\\\"world\\\\\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","e783a3e5d0076d408007be0cbdc07566":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObjectReset(t *testing.T) {\n\tt.Run(\"EmptyObject\", func(t *testing.T) {\n\t\to := Object{}\n\t\to.reset()\n\t\tif len(o.kvs) != 0 {\n\t\t\tt.Errorf(\"Expected empty kvs slice, got %v\", o.kvs)\n\t\t}\n\t\tif o.keysUnescaped {\n\t\t\tt.Errorf(\"Expected keysUnescaped to be false, got %v\", o.keysUnescaped)\n\t\t}\n\t})\n\n\tt.Run(\"NonEmptyObject\", func(t *testing.T) {\n\t\to := Object{\n\t\t\tkvs: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t},\n\t\t\tkeysUnescaped: true,\n\t\t}\n\t\to.reset()\n\t\tif len(o.kvs) != 0 {\n\t\t\tt.Errorf(\"Expected empty kvs slice, got %v\", o.kvs)\n\t\t}\n\t\tif o.keysUnescaped {\n\t\t\tt.Errorf(\"Expected keysUnescaped to be false, got %v\", o.keysUnescaped)\n\t\t}\n\t})\n}","e7853b1995be2a7e0f2c932045cca477":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"{}\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\": \"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"value1\", \"value2\"]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"value\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"value\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   `true`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueTrue,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   `false`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueFalse,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   `null`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueNull,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative number\",\n\t\t\targs: args{\n\t\t\t\ts:   `-123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"decimal number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123.456`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential number\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e+4`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   `NaN`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseValue() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseValue_JSONMarshal(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\": \"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `{\"key\":\"value\"}`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[\"value1\", \"value2\"]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `[\"value1\",\"value2\"]`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"value\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `\"value\"`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   `true`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `true`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   `false`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `false`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   `null`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `null`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `123`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative number\",\n\t\t\targs: args{\n\t\t\t\ts:   `-123`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `-123`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"decimal number\",\n\t\t\targs: args{\n\t\t\t\ts:   `123.456`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `123.456`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential number\",\n\t\t\targs: args{\n\t\t\t\ts:   `1.23e+4`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `1.23e+4`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   `NaN`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `NaN`,\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err == nil {\n\t\t\t\tb, err := json.Marshal(got)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"json.Marshal() error = %v\", err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif string(b) != tt.want {\n\t\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", string(b), tt.want)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","e83bb0b3a53e8c49660f6e11d35138f1":"","e897c35ec322a812216cfd3f5ff03ffd":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueGetInt(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttype want struct {\n\t\twant int\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant want\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.GetInt(tt.args.keys...); got != tt.want.want {\n\t\t\t\tt.Errorf(\"Value.GetInt() = %v, want %v\", got, tt.want.want)\n\t\t\t}\n\t\t})\n\t}\n}","ea1af124e3f14fce95ff74dac77cb87e":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_getKV(t *testing.T) {\n\ttype args struct {\n\t\to *Object\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant *kv\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.o.getKV(); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Object.getKV() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","eb071f816583aa7cfc1e96a4582d81f2":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"single digit\",\n\t\t\targs: args{\n\t\t\t\ts: \"1\",\n\t\t\t},\n\t\t\twantNs:  \"1\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple digits\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative number\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"decimal number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential number\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"inf\",\n\t\t\t},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"nan\",\n\t\t\t},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123a\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace\",\n\t\t\targs: args{\n\t\t\t\ts: \" 123\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \" 123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"trailing whitespace\",\n\t\t\targs: args{\n\t\t\t\ts: \"123 \",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \" \",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}","eb0bed6b248796ac2aa5e59b1e4f4066":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestString(t *testing.T) {\n\ttype args struct {\n\t\tt Type\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"TestObject\",\n\t\t\targs: args{t: TypeObject},\n\t\t\twant: \"object\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestArray\",\n\t\t\targs: args{t: TypeArray},\n\t\t\twant: \"array\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestString\",\n\t\t\targs: args{t: TypeString},\n\t\t\twant: \"string\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestNumber\",\n\t\t\targs: args{t: TypeNumber},\n\t\t\twant: \"number\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestTrue\",\n\t\t\targs: args{t: TypeTrue},\n\t\t\twant: \"true\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestFalse\",\n\t\t\targs: args{t: TypeFalse},\n\t\t\twant: \"false\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestNull\",\n\t\t\targs: args{t: TypeNull},\n\t\t\twant: \"null\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.t.String(); got != tt.want {\n\t\t\t\tt.Errorf(\"String() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","eb2f7a09786ed520e3c0026730fb8e56":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\tv   *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.v.MarshalTo(tt.args.dst); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","eb885289b7d2fd99a584dd8528e7a597":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped string with multiple escapes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\"\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"\\\\\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: ``,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","ebf2cbcce69e6375a3f5bae521ef8b70":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"empty string\",\n\t\t\targs:    args{s: \"\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"single digit\",\n\t\t\targs:    args{s: \"1\"},\n\t\t\twantNs:  \"1\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"multiple digits\",\n\t\t\targs:    args{s: \"12345\"},\n\t\t\twantNs:  \"12345\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"negative number\",\n\t\t\targs:    args{s: \"-123\"},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"decimal number\",\n\t\t\targs:    args{s: \"123.456\"},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"exponential number\",\n\t\t\targs:    args{s: \"1.23e4\"},\n\t\t\twantNs:  \"1.23e4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"exponential number with plus sign\",\n\t\t\targs:    args{s: \"1.23E+4\"},\n\t\t\twantNs:  \"1.23E+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading zeros\",\n\t\t\targs:    args{s: \"00123\"},\n\t\t\twantNs:  \"00123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with trailing zeros\",\n\t\t\targs:    args{s: \"12300\"},\n\t\t\twantNs:  \"12300\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading plus sign\",\n\t\t\targs:    args{s: \"+123\"},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading minus sign\",\n\t\t\targs:    args{s: \"-123\"},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading and trailing spaces\",\n\t\t\targs:    args{s: \" 123 \"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \" \",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with leading spaces\",\n\t\t\targs:    args{s: \" 123\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with trailing spaces\",\n\t\t\targs:    args{s: \"123 \"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \" \",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"number with special characters\",\n\t\t\targs:    args{s: \"123abc\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"abc\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"inf\",\n\t\t\targs:    args{s: \"inf\"},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"Inf\",\n\t\t\targs:    args{s: \"Inf\"},\n\t\t\twantNs:  \"Inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"inF\",\n\t\t\targs:    args{s: \"inF\"},\n\t\t\twantNs:  \"inF\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"NaN\",\n\t\t\targs:    args{s: \"NaN\"},\n\t\t\twantNs:  \"NaN\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"nan\",\n\t\t\targs:    args{s: \"nan\"},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"nAn\",\n\t\t\targs:    args{s: \"nAn\"},\n\t\t\twantNs:  \"nAn\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"unexpected char\",\n\t\t\targs:    args{s: \"123a\"},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"unexpected char at beginning\",\n\t\t\targs:    args{s: \"a123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"a123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"unexpected char after minus sign\",\n\t\t\targs:    args{s: \"-a123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"-a123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"unexpected char after plus sign\",\n\t\t\targs:    args{s: \"+a123\"},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+a123\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"unexpected char after inf\",\n\t\t\targs:    args{s: \"inf123\"},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"123\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"unexpected char after NaN\",\n\t\t\targs:    args{s: \"NaN123\"},\n\t\t\twantNs:  \"NaN\",\n\t\t\twantS:   \"123\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}","ebf877e63e90ebbf0504c5ddb8afea58":"","ec026c231b0d836d21a262081a7a59a0":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetObject(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant *Object\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.GetObject(tt.args.keys...); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.GetObject() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","ecb9681ec50f26f5fdb26414aabd3121":"```go\npackage fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello world\",\n\t\t\t},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quote\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\\\\"\",\n\t\t\t},\n\t\t\twant: \"\\\"\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslash\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\\\\\\",\n\t\t\t},\n\t\t\twant: \"\\\\\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slash\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\/\",\n\t\t\t},\n\t\t\twant: \"/\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\b\",\n\t\t\t},\n\t\t\twant: \"\\b\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\f\",\n\t\t\t},\n\t\t\twant: \"\\f\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\n\",\n\t\t\t},\n\t\t\twant: \"\\n\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\r\",\n\t\t\t},\n\t\t\twant: \"\\r\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\t\",\n\t\t\t},\n\t\t\twant: \"\\t\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\u0061\",\n\t\t\t},\n\t\t\twant: \"a\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\uD83D\\\\uDE01\",\n\t\t\t},\n\t\t\twant: \"😊\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\u00\",\n\t\t\t},\n\t\t\twant: \"\\\\u00\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\\\\"\\\\b\\\\t\\\\u0061\\\\uD83D\\\\uDE01\",\n\t\t\t},\n\t\t\twant: \"\\\"\ta😊\",\n\t\t},\n\t\t{\n\t\t\tname: \"escape sequence in the middle of the string\",\n\t\t\targs: args{\n\t\t\t\ts: \"hello\\\\nworld\",\n\t\t\t},\n\t\t\twant: \"hello\\nworld\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(","ed2bbe5d8b0addacee0007eb6c33fdd0":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestString(t *testing.T) {\n\ttype args struct {\n\t\tt Type\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"TestString_Object\",\n\t\t\targs: args{t: TypeObject},\n\t\t\twant: \"object\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestString_Array\",\n\t\t\targs: args{t: TypeArray},\n\t\t\twant: \"array\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestString_String\",\n\t\t\targs: args{t: TypeString},\n\t\t\twant: \"string\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestString_Number\",\n\t\t\targs: args{t: TypeNumber},\n\t\t\twant: \"number\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestString_True\",\n\t\t\targs: args{t: TypeTrue},\n\t\t\twant: \"true\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestString_False\",\n\t\t\targs: args{t: TypeFalse},\n\t\t\twant: \"false\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestString_Null\",\n\t\t\targs: args{t: TypeNull},\n\t\t\twant: \"null\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.t.String(); got != tt.want {\n\t\t\t\tt.Errorf(\"String() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","ed60335579948b7d973b557c9487f30f":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUint64(t *testing.T) {\n\ttype args struct {\n\t\tv *Value\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    uint64\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := tt.args.v.Uint64()\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Uint64() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Uint64() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","ed7f1f9db9ebf8c730e6dec6ab9e2901":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"parse null\",\n\t\t\targs: args{\n\t\t\t\ts: \"null\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"parse true\",\n\t\t\targs: args{\n\t\t\t\ts: \"true\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"parse false\",\n\t\t\targs: args{\n\t\t\t\ts: \"false\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"parse empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"\\\"\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"parse string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello world\\\"\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello world\",\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"parse number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"parse object\",\n\t\t\targs: args{\n\t\t\t\ts: `{\"key1\": \"value1\", \"key2\": 123}`,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"123\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"parse array\",\n\t\t\targs: args{\n\t\t\t\ts: `[1, 2, \"hello\"]`,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\ts: \"hello\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"parse invalid json\",\n\t\t\targs: args{\n\t\t\t\ts: `{`,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tp := \u0026Parser{}\n\t\t\tgot, err := p.Parse(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Parse() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif tt.wantErr {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Parse() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParse_with_json_library(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"parse null\",\n\t\t\targs: args{\n\t\t\t\ts: \"null\",\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"parse true\",\n\t\t\targs: args{\n\t\t\t\ts: \"true\",\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"parse false\",\n\t\t\targs: args{\n\t\t\t\ts: \"false\",\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"parse empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"\\\"\",\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"parse string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello world\\\"\",\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"parse number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"parse object\",\n\t\t\targs: args{\n\t\t\t\ts: `{\"key1\": \"value1\", \"key2\": 123}`,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"parse array\",\n\t\t\targs: args{\n\t\t\t\ts: `[1, 2, \"hello\"]`,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"parse invalid json\",\n\t\t\targs: args{\n\t\t\t\ts: `{`,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tvar v interface{}\n\t\t\terr := json.Unmarshal([]byte(tt.args.s), \u0026v)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Parse() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t})\n\t}\n}","edc73e729f5fb16c77ddb02f2d62c7f4":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\tv   *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"MarshalTo_RawString\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: typeRawString, s: \"test\"},\n\t\t\t},\n\t\t\twant: []byte(`\"test\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"MarshalTo_Object\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}}, {k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}}}},\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":\"value1\",\"key2\":123}`),\n\t\t},\n\t\t{\n\t\t\tname: \"MarshalTo_Array\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeArray, a: []*Value{{t: TypeString, s: \"value1\"}, {t: TypeNumber, s: \"2\"}}},\n\t\t\t},\n\t\t\twant: []byte(`[\"value1\",2]`),\n\t\t},\n\t\t{\n\t\t\tname: \"MarshalTo_String\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeString, s: \"test\"},\n\t\t\t},\n\t\t\twant: []byte(`\"test\"`),\n\t\t},\n\t\t{\n\t\t\tname: \"MarshalTo_Number\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t},\n\t\t\twant: []byte(`123`),\n\t\t},\n\t\t{\n\t\t\tname: \"MarshalTo_True\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeTrue},\n\t\t\t},\n\t\t\twant: []byte(`true`),\n\t\t},\n\t\t{\n\t\t\tname: \"MarshalTo_False\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeFalse},\n\t\t\t},\n\t\t\twant: []byte(`false`),\n\t\t},\n\t\t{\n\t\t\tname: \"MarshalTo_Null\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNull},\n\t\t\t},\n\t\t\twant: []byte(`null`),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.v.MarshalTo(tt.args.dst); !bytesEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc bytesEqual(a, b []byte) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","ee281fd673e0e5921d985e16d66274ec":"```go\npackage fastjson\n\nimport (\n\t\"testing\"\n\t\"unicode/utf16\"\n\t\"strconv\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},","efa4903c7248777618b60131d2acc577":"package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello world\"},\n\t\t\twant: \"\\\\hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello world\"},\n\t\t\twant: \"/hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello world\"},\n\t\t\twant: \"\\bhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello world\"},\n\t\t\twant: \"\\fhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello world\"},\n\t\t\twant: \"\\nhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello world\"},\n\t\t\twant: \"\\rhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello world\"},\n\t\t\twant: \"\\thello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061hello world\"},\n\t\t\twant: \"ahello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01hello world\"},\n\t\t\twant: \"😀hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid unicode escape\",\n\t\t\targs: args{s: \"\\\\u000hello world\"},\n\t\t\twant: \"\\\\u000hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete unicode escape\",\n\t\t\targs: args{s: \"\\\\u006hello world\"},\n\t\t\twant: \"\\\\u006hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid unicode surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\u0001hello world\"},\n\t\t\twant: \"\\\\uD83D\\\\u0001hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete unicode surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83Dhello world\"},\n\t\t\twant: \"\\\\uD83Dhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\n\\\\t\\\\u0061\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"\\\"hello\\\" \\\\world\\n\\ta😀\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","f05845715af1ed66ea29327c8a4a23ec":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCacheGetValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\t// Test case 1: Empty cache\n\tv1 := c.getValue()\n\tif len(c.vs) != 1 {\n\t\tt.Errorf(\"Expected cache to have 1 value, got %d\", len(c.vs))\n\t}\n\tif v1 != \u0026c.vs[0] {\n\t\tt.Errorf(\"Expected getValue to return a pointer to the first value in the cache, got %p\", v1)\n\t}\n\n\t// Test case 2: Non-empty cache\n\tc.vs = append(c.vs, Value{})\n\tv2 := c.getValue()\n\tif len(c.vs) != 2 {\n\t\tt.Errorf(\"Expected cache to have 2 values, got %d\", len(c.vs))\n\t}\n\tif v2 != \u0026c.vs[1] {\n\t\tt.Errorf(\"Expected getValue to return a pointer to the second value in the cache, got %p\", v2)\n\t}\n}\n","f0667afc84cf5da4eedaac8df46a195b":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": 2}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt:  TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": {\"key2\": \"value2\"}, \"key3\": [1, 2, 3]}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt:  TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\"`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\" \"value1\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid key\",\n\t\t\targs: args{\n\t\t\t\ts:   `{key1: \"value1\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{key1: \"value1\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid value\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": value1}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": value1}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_WithEscapeCharacters(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt:  TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped value\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value\\\\\\\"2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt:  TypeString,\n\t\t\t\t\t\t\t\ts: \"value\\\"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped key and value\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\\\\\\\"1\": \"value\\\\\\\"2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt:  TypeString,\n\t\t\t\t\t\t\t\ts: \"value\\\"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_WithControlCharacters(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"control character in key\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\\u0001\": \"value1\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key\\u0001\": \"value1\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"control character in value\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value\\u0002\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value\\u0002\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_WithInvalidJSON(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"invalid json\",\n\t\t\targs: args{\n\t\t\t\ts:   `{key1: \"value1\", \"key2\": 2`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{key1: \"value1\", \"key2\": 2`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid json 2\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": 2,`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": 2,`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid json 3\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": 2 \"key3\": \"value3\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": 2 \"key3\": \"value3\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_CompareWithStdlib(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": 2}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": {\"key2\": \"value2\"}, \"key3\": [1, 2, 3]}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\\\\\\\"1\": \"value\\\\\\\"2\", \"key3\": [1, 2, 3]}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tvar stdlibResult map[string]interface{}\n\t\t\terr := json.Unmarshal([]byte(tt.args.s), \u0026stdlibResult)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tgot, _, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !compareValues(got, stdlibResult) {\n\t\t\t\tt.Errorf(\"parseObject() result doesn't match stdlib result\")\n\t\t\t\treturn\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v *Value, stdlibValue interface{}) bool {\n\tswitch stdlibValue.(type) {\n\tcase map[string]interface{}:\n\t\to, _ := v.Object()\n\t\tfor i := 0; i \u003c o.Len(); i++ {\n\t\t\tkv := o.kvs[i]\n\t\t\tif !compareValues(kv.v, stdlibValue.(map[string]interface{})[kv.k]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase []interface{}:\n\t\ta, _ := v.Array()\n\t\tif len(a) != len(stdlibValue.([]interface{})) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := 0; i \u003c len(a); i++ {\n\t\t\tif !compareValues(a[i], stdlibValue.([]interface{})[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase string:\n\t\treturn v.String() == stdlibValue.(string)\n\tcase float64:\n\t\treturn v.Float64() == stdlibValue.(float64)\n\tcase bool:\n\t\treturn v.Bool() == stdlibValue.(bool)\n\tcase nil:\n\t\treturn v.Type() == TypeNull\n\tdefault:\n\t\treturn false\n\t}\n}","f090bde8d09c3c16eb0203495d317a50":"```go\npackage fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"single key-value pair\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\": \"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple key-value pairs\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": \"value2\", \"key3\": \"value3\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": {\"key2\": \"value2\"}, \"key3\": \"value3\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\": \"value\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key\": \"value\"`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\" \"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key\" \"value\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid key\",\n\t\t\targs: args{\n\t\t\t\ts:   `{key: \"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{key: \"value\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid value\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\": value}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key\": value}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr {\n\t\t\t\tif !compareValues(got, tt.want) {\n\t\t\t\t\tt.Errorf(\"parseObject() = %v, want %v\", got, tt.want)\n\t\t\t\t}\n\t\t\t\tif got1 != tt.want1 {\n\t\t\t\t\tt.Errorf(\"parseObject() = %v, want %v\", got1, tt.want1)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeObject:\n\t\treturn compareObjects(v1.o, v2.o)\n\tcase TypeArray:\n\t\treturn compareArrays(v1.a, v2.a)\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeTrue:\n\t\treturn true\n\tcase TypeFalse:\n\t\treturn true\n\tcase TypeNull:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc compareObjects(o1, o2 Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv1 := range o1.kvs {\n\t\tkv2 := o2.kvs[i]\n\t\tif kv1.k != kv2.k {\n\t\t\treturn false\n\t\t}\n\t\tif !compareValues(kv1.v, kv2.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc compareArrays(a1, a2 []*Value) bool {\n\tif len(a1) != len(a2) {\n\t\treturn false\n\t}\n\tfor i, v1 := range a1 {\n\t\tv2 := a2[i]\n\t\tif !compareValues(v1, v2) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc TestParseObject_NestedObjects(t *testing.T) {\n\tjsonStr := `{\n\t\t\"name\": \"John Doe\",\n\t\t\"age\": 30,\n\t\t\"address\": {\n\t\t\t\"street\": \"123 Main St\",\n\t\t\t\"city\": \"Anytown\",\n\t\t\t\"zip\": \"12345\"\n\t\t},\n\t\t\"hobbies\": [\"reading\", \"hiking\", \"coding\"]\n\t}`\n\tc := \u0026cache{}\n\tv, _, err := parseObject(jsonStr, c, 0)\n\tif err != nil {\n","f131920ae34d0848f01ae4cda57a1695":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_getKV(t *testing.T) {\n\ttype args struct {\n\t\to *Object\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant *kv\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.o.getKV(); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Object.getKV() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","f1d4a580fbdf8c143281df8713dc7b06":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{\\\"a\\\": 1}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"{\\\"a\\\": 1}\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{\\\"a\\\": 1}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"a\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[1, 2, 3]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"hello\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   \"true\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueTrue,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   \"false\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueFalse,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   \"null\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueNull,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   \"123\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   \"NaN\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseValue() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_parseValue_JSON(t *testing.T) {\n\ttype testCase struct {\n\t\tinput  string\n\t\texpect string\n\t}\n\tcases := []testCase{\n\t\t{\n\t\t\tinput:  `{\"a\": 1}`,\n\t\t\texpect: `{\"a\":1}`,\n\t\t},\n\t\t{\n\t\t\tinput:  `[1, 2, 3]`,\n\t\t\texpect: `[1,2,3]`,\n\t\t},\n\t\t{\n\t\t\tinput:  `\"hello\"`,\n\t\t\texpect: `\"hello\"`,\n\t\t},\n\t\t{\n\t\t\tinput:  `true`,\n\t\t\texpect: `true`,\n\t\t},\n\t\t{\n\t\t\tinput:  `false`,\n\t\t\texpect: `false`,\n\t\t},\n\t\t{\n\t\t\tinput:  `null`,\n\t\t\texpect: `null`,\n\t\t},\n\t\t{\n\t\t\tinput:  `123`,\n\t\t\texpect: `123`,\n\t\t},\n\t\t{\n\t\t\tinput:  `NaN`,\n\t\t\texpect: `\"NaN\"`,\n\t\t},\n\t}\n\tfor _, c := range cases {\n\t\tt.Run(c.input, func(t *testing.T) {\n\t\t\tv, _, err := parseValue(c.input, \u0026cache{}, 0)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"parseValue() error: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Marshal the parsed value and compare it to the expected JSON\n\t\t\tmarshaled, err := json.Marshal(v)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"json.Marshal() error: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif string(marshaled) != c.expect {\n\t\t\t\tt.Errorf(\"ParseValue() got: %s, want: %s\", string(marshaled), c.expect)\n\t\t\t}\n\t\t})\n\t}\n}","f1fe434c7c5c4eee4f1b5f499d63ef52":"```go\npackage fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttype want struct {\n\t\tv   *Value\n\t\ttail string\n\t\terr  error\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant want\n\t}{\n\t\t{\n\t\t\tname: \"Empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  fmt.Errorf(\"cannot parse empty string\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"Too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{\\\"a\\\": 1}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ttail: \"{\\n\\\"a\\\": 1}\",\n\t\t\t\terr:  fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"Object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{\\\"a\\\": 1}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"a\", v: \u0026Value{t: TypeNumber, s: \"1\"}}}}},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"Array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[1, 2, 3]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"String\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\\\"hello\\\"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   \u0026Value{t: typeRawString, s: \"hello\"},\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"True\",\n\t\t\targs: args{\n\t\t\t\ts:   \"true\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueTrue,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"False\",\n\t\t\targs: args{\n\t\t\t\ts:   \"false\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   valueFalse,\n\t\t\t\ttail: \"\",\n\t\t\t\terr:  nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"Null\",","f23543cc8a2f20450756636e16c7ac84":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_getKV(t *testing.T) {\n\ttype args struct {\n\t\to *Object\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant *kv\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.o.getKV(); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Object.getKV() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","f42b808694ac056f3434ca48d3a97f42":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttype want struct {\n\t\tv   *Value\n\t\ts   string\n\t\terr error\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant want\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs:           nil,\n\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ts:   \"\",\n\t\t\t\terr: nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ts:   \"\",\n\t\t\t\terr: nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"nested object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": {\"key2\": \"value2\"}, \"key3\": \"value3\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value3\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ts:   \"\",\n\t\t\t\terr: nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ts:   \"\",\n\t\t\t\terr: nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ts:   `{\"key1\": \"value1`,\n\t\t\t\terr: fmt.Errorf(\"missing '}'\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\" \"value1\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ts:   `{\"key1\" \"value1\"}`,\n\t\t\t\terr: fmt.Errorf(\"missing ':' after object key\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"object with invalid key\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2: \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2: \"value2\"}`,\n\t\t\t\terr: fmt.Errorf(`cannot find opening '\"\" for object key`),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"object with invalid value\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": value2}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": value2}`,\n\t\t\t\terr: fmt.Errorf(\"cannot parse object value: cannot find opening quote for string\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"object with missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv:   nil,\n\t\t\t\ts:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\terr: fmt.Errorf(\"missing ',' after object value\"),\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotV, gotS, gotErr := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (gotErr == nil) != (tt.want.err == nil) {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", gotErr, tt.want.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotErr != nil \u0026\u0026 tt.want.err != nil {\n\t\t\t\tif gotErr.Error() != tt.want.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", gotErr, tt.want.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(gotV, tt.want.v) {\n\t\t\t\tt.Errorf(\"parseObject() gotV = %v, want %v\", gotV, tt.want.v)\n\t\t\t}\n\t\t\tif gotS != tt.want.s {\n\t\t\t\tt.Errorf(\"parseObject() gotS = %v, want %v\", gotS, tt.want.s)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_WithCache(t *testing.T) {\n\tc := \u0026cache{}\n\ts := `{\"key1\": \"value1\", \"key2\": \"value2\"}`\n\tv, _, err := parseObject(s, c, 0)\n\tif err != nil {\n\t\tt.Errorf(\"parseObject() error = %v\", err)\n\t}\n\n\t// Check if the cache is used correctly\n\tif len(c.vs) != 3 {\n\t\tt.Errorf(\"parseObject() cache length = %v, want %v\", len(c.vs), 3)\n\t}\n\n\t// Check if the returned value is using the cached Value\n\tif v == c.vs[0] {\n\t\tt.Errorf(\"parseObject() returned value is not using the cached Value\")\n\t}\n\tif v.o.kvs[0].v == c.vs[1] {\n\t\tt.Errorf(\"parseObject() returned value is not using the cached Value\")\n\t}\n\tif v.o.kvs[1].v == c.vs[2] {\n\t\tt.Errorf(\"parseObject() returned value is not using the cached Value\")\n\t}\n}\n\nfunc TestParseObject_WithEscapedKeys(t *testing.T) {\n\tc := \u0026cache{}\n\ts := `{\"key\\\\\\\"1\": \"value1\", \"key\\\\\"2\": \"value2\"}`\n\tv, _, err := parseObject(s, c, 0)\n\tif err != nil {\n\t\tt.Errorf(\"parseObject() error = %v\", err)\n\t}\n\n\tif v.o.keysUnescaped {\n\t\tt.Errorf(\"parseObject() keysUnescaped = %v, want %v\", v.o.keysUnescaped, false)\n\t}\n\n\tif v.o.kvs[0].k != \"key\\\"1\" {\n\t\tt.Errorf(\"parseObject() key1 = %v, want %v\", v.o.kvs[0].k, \"key\\\"1\")\n\t}\n\n\tif v.o.kvs[1].k != \"key\\\"2\" {\n\t\tt.Errorf(\"parseObject() key2 = %v, want %v\", v.o.kvs[1].k, \"key\\\"2\")\n\t}\n}\n\nfunc TestParseObject_WithDepth(t *testing.T) {\n\ttype args struct {\n\t\ts      string\n\t\tc      *cache\n\t\tdepth  int\n\t\texpect string\n\t}\n\ttype want struct {\n\t\tv   *Value\n\t\ts   string\n\t\terr error\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant want\n\t}{\n\t\t{\n\t\t\tname: \"depth 0\",\n\t\t\targs: args{\n\t\t\t\ts:      `{\"key1\": {\"key2\": \"value2\"}, \"key3\": \"value3\"}`,\n\t\t\t\tc:      \u0026cache{},\n\t\t\t\tdepth:  0,\n\t\t\t\texpect: `{\"key1\": {\"key2\": \"value2\"}, \"key3\": \"value3\"}`,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value3\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ts:   \"\",\n\t\t\t\terr: nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"depth 1\",\n\t\t\targs: args{\n\t\t\t\ts:      `{\"key1\": {\"key2\": \"value2\"}, \"key3\": \"value3\"}`,\n\t\t\t\tc:      \u0026cache{},\n\t\t\t\tdepth:  1,\n\t\t\t\texpect: `{\"key1\": {\"key2\": \"value2\"}, \"key3\": \"value3\"}`,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value3\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ts:   \"\",\n\t\t\t\terr: nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"depth 2\",\n\t\t\targs: args{\n\t\t\t\ts:      `{\"key1\": {\"key2\": \"value2\"}, \"key3\": \"value3\"}`,\n\t\t\t\tc:      \u0026cache{},\n\t\t\t\tdepth:  2,\n\t\t\t\texpect: `{\"key1\": {\"key2\": \"value2\"}, \"key3\": \"value3\"}`,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value3\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ts:   \"\",\n\t\t\t\terr: nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"depth -1\",\n\t\t\targs: args{\n\t\t\t\ts:      `{\"key1\": {\"key2\": \"value2\"}, \"key3\": \"value3\"}`,\n\t\t\t\tc:      \u0026cache{},\n\t\t\t\tdepth:  -1,\n\t\t\t\texpect: `{\"key1\": {\"key2\": \"value2\"}, \"key3\": \"value3\"}`,\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\ts: \"value3\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\ts:   \"\",\n\t\t\t\terr: nil,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotV, gotS, gotErr := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (gotErr == nil) != (tt.want.err == nil) {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", gotErr, tt.want.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotErr != nil \u0026\u0026 tt.want.err != nil {\n\t\t\t\tif gotErr.Error() != tt.want.err.Error() {\n\t\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", gotErr, tt.want.err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(gotV, tt.want.v) {\n\t\t\t\tt.Errorf(\"parseObject() gotV = %v, want %v\", gotV, tt.want.v)\n\t\t\t}\n\t\t\tif gotS != tt.want.s {\n\t\t\t\tt.Errorf(\"parseObject() gotS = %v, want %v\", gotS, tt.want.s)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_WithInvalidDepth(t *testing.T) {\n\tc := \u0026cache{}\n\ts := `{\"key1\": {\"key2\": \"value2\"}, \"key3\": \"value3\"}`\n\t_, _, err := parseObject(s, c, -2)\n\tif err == nil {\n\t\tt.Errorf(\"parseObject() expected error, but got nil\")\n\t}\n}\n\nfunc TestParseObject_WithJsonMarshal(t *testing.T) {\n\tc := \u0026cache{}\n\ts := `{\"key1\": \"value1\", \"key2\": \"value2\"}`\n\tv, _, err := parseObject(s, c, 0)\n\tif err != nil {\n\t\tt.Errorf(\"parseObject() error = %v\", err)\n\t}\n\n\t// Marshal the parsed object back to JSON\n\tb, err := json.Marshal(v)\n\tif err != nil {\n\t\tt.Errorf(\"json.Marshal() error = %v\", err)\n\t}\n\n\t// Compare the marshaled JSON with the original string\n\tif string(b) != s {\n\t\tt.Errorf(\"json.Marshal() got = %v, want %v\", string(b), s)\n\t}\n}","f43be1abf4b1b32657a9009cca3aa5f7":"```go\npackage fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escape sequence\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with multiple escape sequences\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\"world\\\\\"again\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\\\\\\\"again\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped double quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: ``,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with double quote at the beginning\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with double quote at the end\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with double quote in the middle\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"world\"`,\n\t\t\t},\n\t\t\twant:    ","f4bcb92947eb553e92ce8b89aba331e3":"package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequence\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quote\",\n\t\t\targs: args{s: \"\\\\\\\"\"},\n\t\t\twant: \"\\\"\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslash\",\n\t\t\targs: args{s: \"\\\\\\\\\"},\n\t\t\twant: \"\\\\\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped slash\",\n\t\t\targs: args{s: \"\\\\/\"},\n\t\t\twant: \"/\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\b\"},\n\t\t\twant: \"\\b\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\f\"},\n\t\t\twant: \"\\f\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\n\"},\n\t\t\twant: \"\\n\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\r\"},\n\t\t\twant: \"\\r\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\t\"},\n\t\t\twant: \"\\t\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0020\"},\n\t\t\twant: \" \",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"😁\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\u\"},\n\t\t\twant: \"\\\\u\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence 2\",\n\t\t\targs: args{s: \"\\\\u00\"},\n\t\t\twant: \"\\\\u00\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence 3\",\n\t\t\targs: args{s: \"\\\\u002\"},\n\t\t\twant: \"\\\\u002\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence 4\",\n\t\t\targs: args{s: \"\\\\ux000\"},\n\t\t\twant: \"\\\\ux000\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence 5\",\n\t\t\targs: args{s: \"\\\\u000x\"},\n\t\t\twant: \"\\\\u000x\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence 6\",\n\t\t\targs: args{s: \"\\\\u000X\"},\n\t\t\twant: \"\\\\u000X\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence 7\",\n\t\t\targs: args{s: \"\\\\u000 \"},\n\t\t\twant: \"\\\\u000 \",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence 8\",\n\t\t\targs: args{s: \"\\\\u000\\n\"},\n\t\t\twant: \"\\\\u000\\n\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence 9\",\n\t\t\targs: args{s: \"\\\\u000\\\\\"},\n\t\t\twant: \"\\\\u000\\\\\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u0020\\\\uD83D\\\\uDE01\\\\u0020\\\\\"},\n\t\t\twant: \"\\\"\\\\b\\\\f\\\\n\\\\r\\\\t 😁 \\\\\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\u0001\"},\n\t\t\twant: \"\\\\uD83D\\\\u0001\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid surrogate pair 2\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\u\"},\n\t\t\twant: \"\\\\uD83D\\\\u\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid surrogate pair 3\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\\"},\n\t\t\twant: \"\\\\uD83D\\\\\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid surrogate pair 4\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\u0001\"},\n\t\t\twant: \"😁\\\\u0001\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid surrogate pair 5\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\"},\n\t\t\twant: \"😁\\\\uD83D\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode with invalid surrogate pair 6\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01\\\\uD83D\\\\u0001\"},\n\t\t\twant: \"😁\\\\uD83D\\\\u0001\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","f4ec22d1a5a18bc89b39a41074f20a98":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"single digit\",\n\t\t\targs: args{\n\t\t\t\ts: \"1\",\n\t\t\t},\n\t\t\twantNs:  \"1\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple digits\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"decimal number\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23\",\n\t\t\t},\n\t\t\twantNs:  \"1.23\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative number\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123\",\n\t\t\t},\n\t\t\twantNs:  \"-123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"positive number\",\n\t\t\targs: args{\n\t\t\t\ts: \"+123\",\n\t\t\t},\n\t\t\twantNs:  \"+123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential notation\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponential notation with negative exponent\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e-4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"inf\",\n\t\t\t},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"nan\",\n\t\t\t},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number\",\n\t\t\targs: args{\n\t\t\t\ts: \"1a\",\n\t\t\t},\n\t\t\twantNs:  \"1\",\n\t\t\twantS:   \"a\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with special chars\",\n\t\t\targs: args{\n\t\t\t\ts: \"1a+\",\n\t\t\t},\n\t\t\twantNs:  \"1\",\n\t\t\twantS:   \"a+\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading special chars\",\n\t\t\targs: args{\n\t\t\t\ts: \"+1a\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"+1a\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading special chars 2\",\n\t\t\targs: args{\n\t\t\t\ts: \"-1a\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"-1a\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number with leading special chars 3\",\n\t\t\targs: args{\n\t\t\t\ts: \"a1\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"a1\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}","f507afd9a2e710907103163f30938768":"```go\npackage fastjson\n\nimport (\n\t\"testing\"\n\t\"strconv\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape sequences\",\n\t\t\targs: args{\n\t\t\t\ts: \"abcdefg\",\n\t\t\t},\n\t\t\twant: \"abcdefg\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\\\\"\\\\\\\"\",\n\t\t\t},\n\t\t\twant: \"\\\"\\\"\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\\\\\\\\\\",\n\t\t\t},\n\t\t\twant: \"\\\\\\\\\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\/\",\n\t\t\t},\n\t\t\twant: \"/\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\b\",\n\t\t\t},\n\t\t\twant: \"\\b\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\f\",\n\t\t\t},\n\t\t\twant: \"\\f\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\n\",\n\t\t\t},\n\t\t\twant: \"\\n\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\r\",\n\t\t\t},\n\t\t\twant: \"\\r\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\t\",\n\t\t\t},\n\t\t\twant: \"\\t\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\\u0061\",\n\t\t\t},\n\t\t\twant: \"a\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{\n","f52a9ba437685c8435afc8b5272bb656":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueGetInt(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\tv:    \u0026Value{t: TypeObject, o: Object{}},\n\t\t\targs: args{keys: []string{\"a\"}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\tv:    \u0026Value{t: TypeArray, a: []*Value{}},\n\t\t\targs: args{keys: []string{\"0\"}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"non-existing key\",\n\t\t\tv:    \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"a\", v: \u0026Value{t: TypeNumber, s: \"1\"}}}}},\n\t\t\targs: args{keys: []string{\"b\"}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid type\",\n\t\t\tv:    \u0026Value{t: TypeString, s: \"1\"},\n\t\t\targs: args{keys: []string{}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"valid int\",\n\t\t\tv:    \u0026Value{t: TypeNumber, s: \"1\"},\n\t\t\targs: args{keys: []string{}},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"valid int with negative\",\n\t\t\tv:    \u0026Value{t: TypeNumber, s: \"-1\"},\n\t\t\targs: args{keys: []string{}},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"valid int with leading zero\",\n\t\t\tv:    \u0026Value{t: TypeNumber, s: \"01\"},\n\t\t\targs: args{keys: []string{}},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"valid int with decimal\",\n\t\t\tv:    \u0026Value{t: TypeNumber, s: \"1.0\"},\n\t\t\targs: args{keys: []string{}},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"valid int with overflow\",\n\t\t\tv:    \u0026Value{t: TypeNumber, s: \"9223372036854775808\"},\n\t\t\targs: args{keys: []string{}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"valid int with underflow\",\n\t\t\tv:    \u0026Value{t: TypeNumber, s: \"-9223372036854775809\"},\n\t\t\targs: args{keys: []string{}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"valid int with keys path\",\n\t\t\tv:    \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"a\", v: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"b\", v: \u0026Value{t: TypeNumber, s: \"1\"}}}}}}}},\n\t\t\targs: args{keys: []string{\"a\", \"b\"}},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"valid int with array index\",\n\t\t\tv:    \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}}},\n\t\t\targs: args{keys: []string{\"0\"}},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"valid int with array index as decimal\",\n\t\t\tv:    \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}}},\n\t\t\targs: args{keys: []string{\"0.0\"}},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.GetInt(tt.args.keys...); got != tt.want {\n\t\t\t\tt.Errorf(\"Value.GetInt() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","f583068e21b7ee06f424a489cd2eb93d":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:    \"\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{\\\"a\\\":1}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"{\\\"a\\\":1}\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{\\\"a\\\":1}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"a\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[1,2,3]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:    \"\\\"hello\\\"\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:    \"true\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueTrue,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:    \"false\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueFalse,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:    \"null\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueNull,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:    \"123\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:    \"NaN\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseValue() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseValue_InvalidInput(t *testing.T) {\n\ttests := []string{\n\t\t\"tru\",\n\t\t\"fals\",\n\t\t\"nul\",\n\t\t\"{\",\n\t\t\"[\",\n\t\t\"123,\",\n\t\t\"\\\"hello\",\n\t\t\"true,\",\n\t\t\"false,\",\n\t\t\"null,\",\n\t\t\"NaN,\",\n\t}\n\n\tfor _, s := range tests {\n\t\tt.Run(s, func(t *testing.T) {\n\t\t\t_, _, err := parseValue(s, \u0026cache{}, 0)\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) should have returned an error\", s)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseValue_CompareWithJSON(t *testing.T) {\n\ttype test struct {\n\t\tinput string\n\t\twant  interface{}\n\t}\n\ttests := []test{\n\t\t{\n\t\t\tinput: \"null\",\n\t\t\twant:  nil,\n\t\t},\n\t\t{\n\t\t\tinput: \"true\",\n\t\t\twant:  true,\n\t\t},\n\t\t{\n\t\t\tinput: \"false\",\n\t\t\twant:  false,\n\t\t},\n\t\t{\n\t\t\tinput: \"123\",\n\t\t\twant:  123,\n\t\t},\n\t\t{\n\t\t\tinput: \"123.456\",\n\t\t\twant:  123.456,\n\t\t},\n\t\t{\n\t\t\tinput: \"\\\"hello\\\"\",\n\t\t\twant:  \"hello\",\n\t\t},\n\t\t{\n\t\t\tinput: \"[]\",\n\t\t\twant:  []interface{}{},\n\t\t},\n\t\t{\n\t\t\tinput: \"[1,2,3]\",\n\t\t\twant:  []interface{}{1, 2, 3},\n\t\t},\n\t\t{\n\t\t\tinput: \"{}\",\n\t\t\twant:  map[string]interface{}{},\n\t\t},\n\t\t{\n\t\t\tinput: \"{\\\"a\\\":1,\\\"b\\\":\\\"hello\\\"}\",\n\t\t\twant:  map[string]interface{}{\"a\": 1, \"b\": \"hello\"},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, _, err := parseValue(tt.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = %v\", tt.input, err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tgotJSON, err := json.Marshal(got)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"json.Marshal(got) error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\twantJSON, err := json.Marshal(tt.want)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"json.Marshal(tt.want) error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !bytes.Equal(gotJSON, wantJSON) {\n\t\t\t\tt.Errorf(\"parseValue(%q) got = %s, want %s\", tt.input, string(gotJSON), string(wantJSON))\n\t\t\t}\n\t\t})\n\t}\n}\n","f59ee05c8531a20d9be7e8f6127935d7":"package fastjson\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode/utf16\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no escape characters\",\n\t\t\targs: args{s: \"hello world\"},\n\t\t\twant: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped quotes\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" world\"},\n\t\t\twant: \"\\\"hello\\\" world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backslashes\",\n\t\t\targs: args{s: \"\\\\\\\\hello world\"},\n\t\t\twant: \"\\\\hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped forward slashes\",\n\t\t\targs: args{s: \"\\\\/hello world\"},\n\t\t\twant: \"/hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped backspace\",\n\t\t\targs: args{s: \"\\\\bhello world\"},\n\t\t\twant: \"\\bhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped form feed\",\n\t\t\targs: args{s: \"\\\\fhello world\"},\n\t\t\twant: \"\\fhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped newline\",\n\t\t\targs: args{s: \"\\\\nhello world\"},\n\t\t\twant: \"\\nhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped carriage return\",\n\t\t\targs: args{s: \"\\\\rhello world\"},\n\t\t\twant: \"\\rhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped tab\",\n\t\t\targs: args{s: \"\\\\thello world\"},\n\t\t\twant: \"\\thello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped unicode\",\n\t\t\targs: args{s: \"\\\\u0061hello world\"},\n\t\t\twant: \"ahello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"escaped surrogate pair\",\n\t\t\targs: args{s: \"\\\\uD83D\\\\uDE01hello world\"},\n\t\t\twant: \"😁hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid escape sequence\",\n\t\t\targs: args{s: \"\\\\xhello world\"},\n\t\t\twant: \"\\\\xhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete unicode escape sequence\",\n\t\t\targs: args{s: \"\\\\u006hello world\"},\n\t\t\twant: \"\\\\u006hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete surrogate pair escape sequence\",\n\t\t\targs: args{s: \"\\\\uD83Dhello world\"},\n\t\t\twant: \"\\\\uD83Dhello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple escape sequences\",\n\t\t\targs: args{s: \"\\\\\\\"hello\\\\\\\" \\\\\\\\world\\\\n\\\\u0061\\\\uD83D\\\\uDE01\"},\n\t\t\twant: \"\\\"hello\\\" \\\\world\\na😁\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := unescapeStringBestEffort(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","f5e0639406a7ac149ef59ce46b9fd877":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_getKV(t *testing.T) {\n\ttype args struct {\n\t\to *Object\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant *kv\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.o.getKV(); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Object.getKV() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","f61bfa80baef78dd9ee3035bba841ed5":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no whitespace\",\n\t\t\targs: args{s: \"abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace\",\n\t\t\targs: args{s: \"  abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailing whitespace\",\n\t\t\targs: args{s: \"abc  \"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading and trailing whitespace\",\n\t\t\targs: args{s: \"  abc  \"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"whitespace in the middle\",\n\t\t\targs: args{s: \"abc  def\"},\n\t\t\twant: \"def\",\n\t\t},\n\t\t{\n\t\t\tname: \"multiple whitespace\",\n\t\t\targs: args{s: \"  abc  def  \"},\n\t\t\twant: \"def\",\n\t\t},\n\t\t{\n\t\t\tname: \"whitespace with newline\",\n\t\t\targs: args{s: \"  abc\\n def  \"},\n\t\t\twant: \"def\",\n\t\t},\n\t\t{\n\t\t\tname: \"whitespace with tab\",\n\t\t\targs: args{s: \"  abc\\tdef  \"},\n\t\t\twant: \"def\",\n\t\t},\n\t\t{\n\t\t\tname: \"whitespace with carriage return\",\n\t\t\targs: args{s: \"  abc\\rdef  \"},\n\t\t\twant: \"def\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","f625b903fe1f87df3db897c6edb4f6ae":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo_RawString(t *testing.T) {\n\tv := \u0026Value{\n\t\tt: typeRawString,\n\t\ts: \"hello\",\n\t}\n\tdst := []byte{}\n\tdst = v.MarshalTo(dst)\n\tif string(dst) != `\"hello\"` {\n\t\tt.Errorf(\"expected `\\\"hello\\\"`, got %s\", string(dst))\n\t}\n}\n\nfunc TestValueMarshalTo_Object(t *testing.T) {\n\to := Object{\n\t\tkvs: []kv{\n\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t},\n\t}\n\tv := \u0026Value{\n\t\tt: TypeObject,\n\t\to: o,\n\t}\n\tdst := []byte{}\n\tdst = v.MarshalTo(dst)\n\tif string(dst) != `{\"key1\":\"value1\",\"key2\":123}` {\n\t\tt.Errorf(\"expected `{\\\"key1\\\":\\\"value1\\\",\\\"key2\\\":123}`, got %s\", string(dst))\n\t}\n}\n\nfunc TestValueMarshalTo_Array(t *testing.T) {\n\tv := \u0026Value{\n\t\tt: TypeArray,\n\t\ta: []*Value{\n\t\t\t{t: TypeString, s: \"value1\"},\n\t\t\t{t: TypeNumber, s: \"123\"},\n\t\t},\n\t}\n\tdst := []byte{}\n\tdst = v.MarshalTo(dst)\n\tif string(dst) != `[\"value1\",123]` {\n\t\tt.Errorf(\"expected `[\\\"value1\\\",123]`, got %s\", string(dst))\n\t}\n}\n\nfunc TestValueMarshalTo_String(t *testing.T) {\n\tv := \u0026Value{\n\t\tt: TypeString,\n\t\ts: \"hello world\",\n\t}\n\tdst := []byte{}\n\tdst = v.MarshalTo(dst)\n\tif string(dst) != `\"hello world\"` {\n\t\tt.Errorf(\"expected `\\\"hello world\\\"`, got %s\", string(dst))\n\t}\n}\n\nfunc TestValueMarshalTo_Number(t *testing.T) {\n\tv := \u0026Value{\n\t\tt: TypeNumber,\n\t\ts: \"123\",\n\t}\n\tdst := []byte{}\n\tdst = v.MarshalTo(dst)\n\tif string(dst) != \"123\" {\n\t\tt.Errorf(\"expected `123`, got %s\", string(dst))\n\t}\n}\n\nfunc TestValueMarshalTo_True(t *testing.T) {\n\tv := \u0026Value{\n\t\tt: TypeTrue,\n\t}\n\tdst := []byte{}\n\tdst = v.MarshalTo(dst)\n\tif string(dst) != \"true\" {\n\t\tt.Errorf(\"expected `true`, got %s\", string(dst))\n\t}\n}\n\nfunc TestValueMarshalTo_False(t *testing.T) {\n\tv := \u0026Value{\n\t\tt: TypeFalse,\n\t}\n\tdst := []byte{}\n\tdst = v.MarshalTo(dst)\n\tif string(dst) != \"false\" {\n\t\tt.Errorf(\"expected `false`, got %s\", string(dst))\n\t}\n}\n\nfunc TestValueMarshalTo_Null(t *testing.T) {\n\tv := \u0026Value{\n\t\tt: TypeNull,\n\t}\n\tdst := []byte{}\n\tdst = v.MarshalTo(dst)\n\tif string(dst) != \"null\" {\n\t\tt.Errorf(\"expected `null`, got %s\", string(dst))\n\t}\n}","f6f799d652f95548df1454b0da524481":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"simple string\",\n\t\t\targs:    args{s: \"\\\"hello\\\"\"},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"escaped string\",\n\t\t\targs:    args{s: \"\\\"hello\\\\\\\"world\\\"\"},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"multiple escaped string\",\n\t\t\targs:    args{s: \"\\\"hello\\\\\\\"world\\\\\\\"\\\\\\\"\"},\n\t\t\twant:    \"hello\\\"world\\\"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"missing closing quote\",\n\t\t\targs:    args{s: \"\\\"hello\"},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"empty string\",\n\t\t\targs:    args{s: \"\\\"\\\"\"},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"string with whitespace\",\n\t\t\targs:    args{s: \"\\\" hello \\\"\"},\n\t\t\twant:    \" hello \",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","f7174365718278f6c246af3c02df800c":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts: \"null\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts: \"true\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts: \"false\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello\\\"\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts: \"[1,2,3]\",\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts: `{\"key1\":\"value1\",\"key2\":2}`,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested object\",\n\t\t\targs: args{\n\t\t\t\ts: `{\"key1\":{\"key2\":\"value2\"}}`,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts: `{\"key1\":[1,2,3]}`,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tp := \u0026Parser{}\n\t\t\tgot, err := p.Parse(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Parse() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr \u0026\u0026 !compareValue(got, tt.want) {\n\t\t\t\tt.Errorf(\"Parse() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValue(v1, v2 *Value) bool {\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeNull:\n\t\treturn true\n\tcase TypeTrue:\n\t\treturn true\n\tcase TypeFalse:\n\t\treturn true\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeArray:\n\t\tif len(v1.a) != len(v2.a) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.a {\n\t\t\tif !compareValue(v1.a[i], v2.a[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeObject:\n\t\tif len(v1.o.kvs) != len(v2.o.kvs) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range v1.o.kvs {\n\t\t\tif v1.o.kvs[i].k != v2.o.kvs[i].k {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !compareValue(v1.o.kvs[i].v, v2.o.kvs[i].v) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}","f7c57cc5d4987c63433126e4c45ef159":"package fastjson\n\nimport \"testing\"\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{s: \"\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"no whitespace\",\n\t\t\targs: args{s: \"abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"leading whitespace\",\n\t\t\targs: args{s: \" \\t\\r\\n abc\"},\n\t\t\twant: \"abc\",\n\t\t},\n\t\t{\n\t\t\tname: \"trailing whitespace\",\n\t\t\targs: args{s: \"abc \\t\\r\\n\"},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"whitespace in the middle\",\n\t\t\targs: args{s: \"abc \\t\\r\\n def\"},\n\t\t\twant: \"def\",\n\t\t},\n\t\t{\n\t\t\tname: \"only whitespace\",\n\t\t\targs: args{s: \" \\t\\r\\n\"},\n\t\t\twant: \"\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := skipWSSlow(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"skipWSSlow() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","f8928951972e02af89edabbec7377750":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestInt(t *testing.T) {\n\ttype args struct {\n\t\tv *Value\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"ValidInt\",\n\t\t\targs: args{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"123\",\n\t\t\t\t},\n\t\t\t},\n\t\t\twant:    123,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"InvalidInt\",\n\t\t\targs: args{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeString,\n\t\t\t\t\ts: \"abc\",\n\t\t\t\t},\n\t\t\t},\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"IntOutOfRange\",\n\t\t\targs: args{\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\ts: \"9223372036854775808\",\n\t\t\t\t},\n\t\t\t},\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := tt.args.v.Int()\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Int() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Int() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestInt_JSON(t *testing.T) {\n\ttype args struct {\n\t\tjsonStr string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"ValidInt\",\n\t\t\targs: args{\n\t\t\t\tjsonStr: \"123\",\n\t\t\t},\n\t\t\twant:    123,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"InvalidInt\",\n\t\t\targs: args{\n\t\t\t\tjsonStr: `\"abc\"`,\n\t\t\t},\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"IntOutOfRange\",\n\t\t\targs: args{\n\t\t\t\tjsonStr: \"9223372036854775808\",\n\t\t\t},\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tvar v Value\n\t\t\tif err := json.Unmarshal([]byte(tt.args.jsonStr), \u0026v); err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgot, err := v.Int()\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Int() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Int() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","f8da9bdf20008c2b106a9e69d349e4ba":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello\\\"\",\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"escaped string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello\\\\\\\"world\\\"\",\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello\",\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped backslash\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello\\\\\\\\world\\\"\",\n\t\t\t},\n\t\t\twant:    \"hello\\\\world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello\\\\\\\"world\\\\\\\"\\\\\\\"\\\"\",\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"\\\"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote at the end\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"hello\\\\\\\"\",\n\t\t\t},\n\t\t\twant:    \"hello\\\"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote at the beginning\",\n\t\t\targs: args{\n\t\t\t\ts: \"\\\"\\\\\\\"hello\\\"\",\n\t\t\t},\n\t\t\twant:    \"\\\"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","f95819b73bedc0740878a7252e4ef62b":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestType_String(t *testing.T) {\n\ttype args struct {\n\t\tt Type\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"TypeObject\",\n\t\t\targs: args{\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\twant: \"object\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeArray\",\n\t\t\targs: args{\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\twant: \"array\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeString\",\n\t\t\targs: args{\n\t\t\t\tt: TypeString,\n\t\t\t},\n\t\t\twant: \"string\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeNumber\",\n\t\t\targs: args{\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\twant: \"number\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeTrue\",\n\t\t\targs: args{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\twant: \"true\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeFalse\",\n\t\t\targs: args{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\twant: \"false\",\n\t\t},\n\t\t{\n\t\t\tname: \"TypeNull\",\n\t\t\targs: args{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\twant: \"null\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.t.String(); got != tt.want {\n\t\t\t\tt.Errorf(\"Type.String() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","f9747230c68e23c0a3a3fc2165b2b8a6":"package fastjson\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\tv   *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNull},\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeTrue},\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeFalse},\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeString, s: \"test\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"test\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t},\n\t\t\twant: []byte(\"123\"),\n\t\t},\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: typeRawString, s: \"test\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"test\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{t: TypeString, s: \"test1\"},\n\t\t\t\t\t\t{t: TypeString, s: \"test2\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"[\\\"test1\\\",\\\"test2\\\"]\"),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"{\\\"key1\\\":\\\"value1\\\",\\\"key2\\\":\\\"value2\\\"}\"),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.v.MarshalTo(tt.args.dst); !bytes.Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","f981bfe9171513de09c0681357443d27":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"simple\",\n\t\t\targs:    args{s: \"\\\"hello\\\"\"},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"escaped\",\n\t\t\targs:    args{s: \"\\\"hello\\\\\\\"world\\\"\"},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"escaped_multiple\",\n\t\t\targs:    args{s: \"\\\"hello\\\\\\\\\\\\\\\"world\\\"\"},\n\t\t\twant:    \"hello\\\\\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"missing_closing_quote\",\n\t\t\targs:    args{s: \"\\\"hello\"},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"empty_string\",\n\t\t\targs:    args{s: \"\\\"\\\"\"},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"no_quotes\",\n\t\t\targs:    args{s: \"hello\"},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"quotes_in_middle\",\n\t\t\targs:    args{s: \"hello\\\"world\"},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"world\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parseRawString() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseRawString() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","fa1f625cfa6f647e389ef8b2e4a2b0f7":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{}\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    \u0026Value{t: TypeObject, o: Object{kvs: nil}},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\", \"key2\": 2}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}}, {k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"2\"}}}}},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested object\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": {\"key2\": \"value2\"}, \"key3\": [1, 2, 3]}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key1\", v: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key2\", v: \u0026Value{t: TypeString, s: \"value2\"}}}}}}, {k: \"key3\", v: \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}}}}}},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\" \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid key\",\n\t\t\targs: args{\n\t\t\t\ts:    `{1: \"value1\"}`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{1: \"value1\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","fa43a2f1438e1f409b9dcf9d2fc25dc6":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"simple object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with nested object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": {\"nested_key\": \"nested_value\"}, \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"nested_key\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"nested_value\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"object with escaped key\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\\\\\\\"1\": \"value1\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\\\"1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\" \"value1\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_WithCache(t *testing.T) {\n\tc := \u0026cache{\n\t\tvs: make([]Value, 10),\n\t}\n\ts := `{\"key1\": \"value1\", \"key2\": \"value2\", \"key3\": \"value3\"}`\n\tv, _, err := parseObject(s, c, 0)\n\tif err != nil {\n\t\tt.Errorf(\"parseObject() error = %v\", err)\n\t}\n\tif len(c.vs) != 11 {\n\t\tt.Errorf(\"parseObject() expected 11 values in cache, got %d\", len(c.vs))\n\t}\n\tif v.t != TypeObject {\n\t\tt.Errorf(\"parseObject() expected TypeObject, got %v\", v.t)\n\t}\n\tif len(v.o.kvs) != 3 {\n\t\tt.Errorf(\"parseObject() expected 3 key-value pairs, got %d\", len(v.o.kvs))\n\t}\n}\n\nfunc TestParseObject_WithNestedObjects(t *testing.T) {\n\ts := `{\"key1\": {\"nested_key1\": \"value1\", \"nested_key2\": \"value2\"}, \"key2\": \"value3\"}`\n\tv, _, err := parseObject(s, \u0026cache{}, 0)\n\tif err != nil {\n\t\tt.Errorf(\"parseObject() error = %v\", err)\n\t}\n\tif v.t != TypeObject {\n\t\tt.Errorf(\"parseObject() expected TypeObject, got %v\", v.t)\n\t}\n\tif len(v.o.kvs) != 2 {\n\t\tt.Errorf(\"parseObject() expected 2 key-value pairs, got %d\", len(v.o.kvs))\n\t}\n\tnestedObject := v.o.kvs[0].v\n\tif nestedObject.t != TypeObject {\n\t\tt.Errorf(\"parseObject() expected TypeObject for nested object, got %v\", nestedObject.t)\n\t}\n\tif len(nestedObject.o.kvs) != 2 {\n\t\tt.Errorf(\"parseObject() expected 2 key-value pairs in nested object, got %d\", len(nestedObject.o.kvs))\n\t}\n}\n\nfunc TestParseObject_WithArrays(t *testing.T) {\n\ts := `{\"key1\": [\"value1\", \"value2\"], \"key2\": \"value3\"}`\n\tv, _, err := parseObject(s, \u0026cache{}, 0)\n\tif err != nil {\n\t\tt.Errorf(\"parseObject() error = %v\", err)\n\t}\n\tif v.t != TypeObject {\n\t\tt.Errorf(\"parseObject() expected TypeObject, got %v\", v.t)\n\t}\n\tif len(v.o.kvs) != 2 {\n\t\tt.Errorf(\"parseObject() expected 2 key-value pairs, got %d\", len(v.o.kvs))\n\t}\n\tarrayValue := v.o.kvs[0].v\n\tif arrayValue.t != TypeArray {\n\t\tt.Errorf(\"parseObject() expected TypeArray for array value, got %v\", arrayValue.t)\n\t}\n\tif len(arrayValue.a) != 2 {\n\t\tt.Errorf(\"parseObject() expected 2 elements in array, got %d\", len(arrayValue.a))\n\t}\n}\n\nfunc TestParseObject_WithEscapedCharacters(t *testing.T) {\n\ts := `{\"key1\": \"value1\\\\\\\"value2\", \"key2\": \"value3\"}`\n\tv, _, err := parseObject(s, \u0026cache{}, 0)\n\tif err != nil {\n\t\tt.Errorf(\"parseObject() error = %v\", err)\n\t}\n\tif v.t != TypeObject {\n\t\tt.Errorf(\"parseObject() expected TypeObject, got %v\", v.t)\n\t}\n\tif len(v.o.kvs) != 2 {\n\t\tt.Errorf(\"parseObject() expected 2 key-value pairs, got %d\", len(v.o.kvs))\n\t}\n\tif v.o.kvs[0].v.s != \"value1\\\"value2\" {\n\t\tt.Errorf(\"parseObject() expected escaped string value, got %v\", v.o.kvs[0].v.s)\n\t}\n}\n\nfunc TestParseObject_WithInvalidJSON(t *testing.T) {\n\ttests := []string{\n\t\t\"{\",\n\t\t\"}\",\n\t\t\"{\",\n\t\t`{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t`{\"key1\": \"value1\", \"key2\": \"value2}}`,\n\t\t`{\"key1\": \"value1\", \"key2\": \"value2\",`,\n\t}\n\tfor _, s := range tests {\n\t\t_, _, err := parseObject(s, \u0026cache{}, 0)\n\t\tif err == nil {\n\t\t\tt.Errorf(\"parseObject() expected error for invalid JSON, got nil\")\n\t\t}\n\t}\n}\n\nfunc TestParseObject_CompareWithStdlib(t *testing.T) {\n\ttests := []string{\n\t\t`{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t`{\"key1\": {\"nested_key1\": \"value1\", \"nested_key2\": \"value2\"}, \"key2\": \"value3\"}`,\n\t\t`{\"key1\": [\"value1\", \"value2\"], \"key2\": \"value3\"}`,\n\t\t`{\"key1\": \"value1\\\\\\\"value2\", \"key2\": \"value3\"}`,\n\t}\n\tfor _, s := range tests {\n\t\tt.Run(s, func(t *testing.T) {\n\t\t\t// Parse with fastjson\n\t\t\tv, _, err := parseObject(s, \u0026cache{}, 0)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"parseObject() error = %v\", err)\n\t\t\t}\n\n\t\t\t// Parse with standard library\n\t\t\tvar stdlibValue map[string]interface{}\n\t\t\tif err := json.Unmarshal([]byte(s), \u0026stdlibValue); err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t}\n\n\t\t\t// Compare the results\n\t\t\tif !compareValues(v, stdlibValue) {\n\t\t\t\tt.Errorf(\"parseObject() results don't match standard library\")\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(fastjsonValue *Value, stdlibValue interface{}) bool {\n\tswitch fastjsonValue.t {\n\tcase TypeObject:\n\t\tstdlibObject, ok := stdlibValue.(map[string]interface{})\n\t\tif !ok {\n\t\t\treturn false\n\t\t}\n\t\tif len(fastjsonValue.o.kvs) != len(stdlibObject) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, kv := range fastjsonValue.o.kvs {\n\t\t\tstdlibKey := kv.k\n\t\t\tstdlibValue := stdlibObject[stdlibKey]\n\t\t\tif !compareValues(kv.v, stdlibValue) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeArray:\n\t\tstdlibArray, ok := stdlibValue.([]interface{})\n\t\tif !ok {\n\t\t\treturn false\n\t\t}\n\t\tif len(fastjsonValue.a) != len(stdlibArray) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, v := range fastjsonValue.a {\n\t\t\tif !compareValues(v, stdlibArray[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase TypeString:\n\t\tstdlibString, ok := stdlibValue.(string)\n\t\tif !ok {\n\t\t\treturn false\n\t\t}\n\t\treturn fastjsonValue.s == stdlibString\n\tcase TypeNumber:\n\t\tstdlibNumber, ok := stdlibValue.(float64)\n\t\tif !ok {\n\t\t\treturn false\n\t\t}\n\t\treturn fastjsonValue.s == fmt.Sprintf(\"%f\", stdlibNumber)\n\tcase TypeTrue:\n\t\tstdlibBool, ok := stdlibValue.(bool)\n\t\tif !ok {\n\t\t\treturn false\n\t\t}\n\t\treturn stdlibBool == true\n\tcase TypeFalse:\n\t\tstdlibBool, ok := stdlibValue.(bool)\n\t\tif !ok {\n\t\t\treturn false\n\t\t}\n\t\treturn stdlibBool == false\n\tcase TypeNull:\n\t\treturn stdlibValue == nil\n\tdefault:\n\t\treturn false\n\t}\n}","fad2cd55a1437b3ce0da7feb21a2c28c":"package fastjson\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []byte\n\t\tv   *Value\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"marshal string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeString, s: \"hello world\"},\n\t\t\t},\n\t\t\twant: []byte(\"\\\"hello world\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal number\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t},\n\t\t\twant: []byte(\"123\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal true\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeTrue},\n\t\t\t},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal false\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeFalse},\n\t\t\t},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal null\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: TypeNull},\n\t\t\t},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal object\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeObject,\n\t\t\t\t\to: Object{\n\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\t\tv: \u0026Value{t: TypeString, s: \"value1\"},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\tv: \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`{\"key1\":\"value1\",\"key2\":123}`),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal array\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv: \u0026Value{\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t{t: TypeString, s: \"value1\"},\n\t\t\t\t\t\t{t: TypeNumber, s: \"123\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(`[\"value1\",123]`),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal raw string\",\n\t\t\targs: args{\n\t\t\t\tdst: []byte{},\n\t\t\t\tv:   \u0026Value{t: typeRawString, s: \"hello world\"},\n\t\t\t},\n\t\t\twant: []byte(`\"hello world\"`),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.v.MarshalTo(tt.args.dst); !bytes.Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Value.MarshalTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","fafe949e40ef0e679a1dce9f0ab14244":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs:           nil,\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"single key-value pair\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\": \"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple key-value pairs\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested objects\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": {\"key2\": \"value2\"}, \"key3\": \"value3\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key1\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tk: \"key2\",\n\t\t\t\t\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\ts: \"value2\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tk: \"key3\",\n\t\t\t\t\t\t\tv: \u0026Value{\n\t\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\t\ts: \"value3\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tkeysUnescaped: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing brace\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\", \"key2\": \"value2`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing key\",\n\t\t\targs: args{\n\t\t\t\ts:   `{:\"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{:\"value1\", \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing colon\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\" \"value1\", \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing comma\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr {\n\t\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got, tt.want)\n\t\t\t\t}\n\t\t\t\tif got1 != tt.want1 {\n\t\t\t\t\tt.Errorf(\"parseObject() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_RealWorld(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"real world example\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key1\": \"value1\", \"key2\": 123, \"key3\": true, \"key4\": [1, 2, 3], \"key5\": {\"key6\": \"value6\"}}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    `{\"key1\":\"value1\",\"key2\":123,\"key3\":true,\"key4\":[1,2,3],\"key5\":{\"key6\":\"value6\"}}`,\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseObject(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr {\n\t\t\t\tif got.String() != tt.want {\n\t\t\t\t\tt.Errorf(\"parseObject() got = %v, want %v\", got.String(), tt.want)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseObject_Benchmark(t *testing.T) {\n\ts := `{\"key1\": \"value1\", \"key2\": 123, \"key3\": true, \"key4\": [1, 2, 3], \"key5\": {\"key6\": \"value6\"}}`\n\tc := \u0026cache{}\n\n\tt.Run(\"parseObject\", func(t *testing.T) {\n\t\tfor i := 0; i \u003c 1000; i++ {\n\t\t\t_, _, err := parseObject(s, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"parseObject() error = %v\", err)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"json.Unmarshal\", func(t *testing.T) {\n\t\tvar v map[string]interface{}\n\t\tfor i := 0; i \u003c 1000; i++ {\n\t\t\terr := json.Unmarshal([]byte(s), \u0026v)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t}\n\t\t}\n\t})\n}","fb729c9e664590824f43d00dd4575e18":"```go\npackage fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    string\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"simple string\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\"`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with multiple escaped quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\"world\\\\\\\"\\\\\"!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world\\\"!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped backslash\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\\world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped backslash and quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\\\\\\\\\"world\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\\\\\"world\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing closing quote\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello`,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: ``,\n\t\t\t},\n\t\t\twant:    \"\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"no quotes\",\n\t\t\targs: args{\n\t\t\t\ts: `hello`,\n\t\t\t},\n\t\t\twant:    \"hello\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"single quote\",\n\t\t\targs: args{\n\t\t\t\ts: `'hello'`,\n\t\t\t},\n\t\t\twant:    `'hello'`,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string with escaped quote and other characters\",\n\t\t\targs: args{\n\t\t\t\ts: `\"hello\\\\\"world, this is a test!\"`,\n\t\t\t},\n\t\t\twant:    \"hello\\\"world, this is a test!\",\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseRawString(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawString() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"parse","fb7e9ab90d925bed85b64d15b8032d26":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    \u0026Value{t: TypeArray, a: []*Value{}},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"single element array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[1]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}}},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[1,2,3]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[[1,2],[3,4]]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    \u0026Value{t: TypeArray, a: []*Value{{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}}}, {t: TypeArray, a: []*Value{{t: TypeNumber, s: \"3\"}, {t: TypeNumber, s: \"4\"}}}},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with spaces\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[ 1 , 2 , 3 ]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with invalid element\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[1,2,]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \",]\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"array with missing closing bracket\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[1,2\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseArray() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseArray_JSON(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    \u0026Value{t: TypeArray, a: []*Value{}},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"single element array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[1]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}}},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[1,2,3]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[[1,2],[3,4]]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    \u0026Value{t: TypeArray, a: []*Value{{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}}}, {t: TypeArray, a: []*Value{{t: TypeNumber, s: \"3\"}, {t: TypeNumber, s: \"4\"}}}},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with strings\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[\\\"hello\\\",\\\"world\\\"]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    \u0026Value{t: TypeArray, a: []*Value{{t: TypeString, s: \"hello\"}, {t: TypeString, s: \"world\"}}},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with booleans\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[true,false]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    \u0026Value{t: TypeArray, a: []*Value{{t: TypeTrue}, {t: TypeFalse}}},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseArray_JSONUnmarshal(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    interface{}\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    []interface{}{},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"single element array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[1]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    []interface{}{1},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[1,2,3]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    []interface{}{1, 2, 3},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nested array\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[[1,2],[3,4]]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    [][]interface{}{{1, 2}, {3, 4}},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with strings\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[\\\"hello\\\",\\\"world\\\"]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    []interface{}{\"hello\", \"world\"},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array with booleans\",\n\t\t\targs: args{\n\t\t\t\ts:   \"[true,false]\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    []interface{}{true, false},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, _, err := parseArray(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tvar result interface{}\n\t\t\tif err := json.Unmarshal([]byte(tt.args.s), \u0026result); err != nil {\n\t\t\t\tt.Errorf(\"json.Unmarshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(result, tt.want) {\n\t\t\t\tt.Errorf(\"json.Unmarshal() got = %v, want %v\", result, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc BenchmarkParseArray(b *testing.B) {\n\ts := `[1,2,3,4,5,6,7,8,9,10]`\n\tc := \u0026cache{}\n\tfor i := 0; i \u003c b.N; i++ {\n\t\t_, _, _ = parseArray(s, c, 0)\n\t}\n}\n\nfunc BenchmarkParseArray_JSONUnmarshal(b *testing.B) {\n\ts := `[1,2,3,4,5,6,7,8,9,10]`\n\tfor i := 0; i \u003c b.N; i++ {\n\t\tvar result interface{}\n\t\t_ = json.Unmarshal([]byte(s), \u0026result)\n\t}\n}\n","fce70cc9e40ba2c400ed89f3e0ba423b":"```go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetInt(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args","feacaa5e88202caacf33cb33a02608a6":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts   string\n\t\tc   *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *Value\n\t\twant1   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:   \"\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:   \"{}\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twant1:   \"{}\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:   `{\"key\": \"value\"}`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: \u0026Value{\n\t\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t\t\ts: \"value\",\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:   `[1, 2, 3]`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:   `\"string\"`,\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"string\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:   \"true\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueTrue,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:   \"false\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueFalse,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:   \"null\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant:    valueNull,\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:   \"123\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:   \"NaN\",\n\t\t\t\tc:   \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twant: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"NaN\",\n\t\t\t},\n\t\t\twant1:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, got1, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif got1 != tt.want1 {\n\t\t\t\tt.Errorf(\"parseValue() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","ff29818ed9c5eb2e04b751c3ad5a474c":"package fastjson\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttype args struct {\n\t\ts    string\n\t\tc    *cache\n\t\tdepth int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantV   *Value\n\t\twantTail string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts:    \"\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV:   nil,\n\t\t\twantTail: \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"too big depth\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{ }\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: MaxDepth,\n\t\t\t},\n\t\t\twantV:   nil,\n\t\t\twantTail: \"{ }\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\targs: args{\n\t\t\t\ts:    \"{ }\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV:   \u0026Value{t: TypeObject},\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\targs: args{\n\t\t\t\ts:    \"[]\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV:   \u0026Value{t: TypeArray},\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\ts:    `\"hello\"`,\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV:   \u0026Value{t: typeRawString, s: \"hello\"},\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"true\",\n\t\t\targs: args{\n\t\t\t\ts:    \"true\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV:   valueTrue,\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"false\",\n\t\t\targs: args{\n\t\t\t\ts:    \"false\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV:   valueFalse,\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"null\",\n\t\t\targs: args{\n\t\t\t\ts:    \"null\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV:   valueNull,\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\targs: args{\n\t\t\t\ts:    \"123\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV:   \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts:    \"NaN\",\n\t\t\t\tc:    \u0026cache{},\n\t\t\t\tdepth: 0,\n\t\t\t},\n\t\t\twantV:   \u0026Value{t: TypeNumber, s: \"NaN\"},\n\t\t\twantTail: \"\",\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotV, gotTail, err := parseValue(tt.args.s, tt.args.c, tt.args.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(gotV, tt.wantV) {\n\t\t\t\tt.Errorf(\"parseValue() gotV = %v, want %v\", gotV, tt.wantV)\n\t\t\t}\n\t\t\tif gotTail != tt.wantTail {\n\t\t\t\tt.Errorf(\"parseValue() gotTail = %v, want %v\", gotTail, tt.wantTail)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_parseValue_invalid_true(t *testing.T) {\n\ts := \"tru\"\n\tc := \u0026cache{}\n\tdepth := 0\n\t_, _, err := parseValue(s, c, depth)\n\tif err == nil {\n\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, true)\n\t}\n}\n\nfunc Test_parseValue_invalid_false(t *testing.T) {\n\ts := \"fals\"\n\tc := \u0026cache{}\n\tdepth := 0\n\t_, _, err := parseValue(s, c, depth)\n\tif err == nil {\n\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, true)\n\t}\n}\n\nfunc Test_parseValue_invalid_null(t *testing.T) {\n\ts := \"nul\"\n\tc := \u0026cache{}\n\tdepth := 0\n\t_, _, err := parseValue(s, c, depth)\n\tif err == nil {\n\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, true)\n\t}\n}\n\nfunc Test_parseValue_invalid_number(t *testing.T) {\n\ts := \"123a\"\n\tc := \u0026cache{}\n\tdepth := 0\n\t_, _, err := parseValue(s, c, depth)\n\tif err == nil {\n\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, true)\n\t}\n}\n\nfunc Test_parseValue_invalid_string(t *testing.T) {\n\ts := `\"hello\"`\n\tc := \u0026cache{}\n\tdepth := 0\n\t_, _, err := parseValue(s, c, depth)\n\tif err == nil {\n\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, true)\n\t}\n}\n\nfunc TestParseValue_JSONMarshal(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tinput string\n\t\twant  string\n\t}{\n\t\t{\n\t\t\tname:  \"null\",\n\t\t\tinput: \"null\",\n\t\t\twant:  \"null\",\n\t\t},\n\t\t{\n\t\t\tname:  \"true\",\n\t\t\tinput: \"true\",\n\t\t\twant:  \"true\",\n\t\t},\n\t\t{\n\t\t\tname:  \"false\",\n\t\t\tinput: \"false\",\n\t\t\twant:  \"false\",\n\t\t},\n\t\t{\n\t\t\tname:  \"number\",\n\t\t\tinput: \"123\",\n\t\t\twant:  \"123\",\n\t\t},\n\t\t{\n\t\t\tname:  \"string\",\n\t\t\tinput: `\"hello\"`,\n\t\t\twant:  `\"hello\"`,\n\t\t},\n\t\t{\n\t\t\tname:  \"object\",\n\t\t\tinput: `{}`,\n\t\t\twant:  `{}`,\n\t\t},\n\t\t{\n\t\t\tname:  \"array\",\n\t\t\tinput: `[]`,\n\t\t\twant:  `[]`,\n\t\t},\n\t\t{\n\t\t\tname:  \"nested object\",\n\t\t\tinput: `{\"a\": {\"b\": 1}}`,\n\t\t\twant:  `{\"a\":{\"b\":1}}`,\n\t\t},\n\t\t{\n\t\t\tname:  \"nested array\",\n\t\t\tinput: `[1, [2, 3]]`,\n\t\t\twant:  `[1,[2,3]]`,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tv, _, err := parseValue(tt.input, c, 0)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"parseValue() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tb, err := json.Marshal(v)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"json.Marshal() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif string(b) != tt.want {\n\t\t\t\tt.Errorf(\"json.Marshal() = %v, want %v\", string(b), tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","ff2e64941735c4b5b5fb0f73d2564232":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetUint(t *testing.T) {\n\ttype args struct {\n\t\tkeys []string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\targs args\n\t\twant uint\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.v.GetUint(tt.args.keys...); got != tt.want {\n\t\t\t\tt.Errorf(\"Value.GetUint() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","ff75975ea5cedab01a573834e62bf964":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantNs  string\n\t\twantS   string\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\targs: args{\n\t\t\t\ts: \"\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"single digit\",\n\t\t\targs: args{\n\t\t\t\ts: \"1\",\n\t\t\t},\n\t\t\twantNs:  \"1\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple digits\",\n\t\t\targs: args{\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\twantNs:  \"123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"decimal number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\twantNs:  \"123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"negative number\",\n\t\t\targs: args{\n\t\t\t\ts: \"-123.456\",\n\t\t\t},\n\t\t\twantNs:  \"-123.456\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponent\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23e+4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23e+4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"exponent with capital E\",\n\t\t\targs: args{\n\t\t\t\ts: \"1.23E-4\",\n\t\t\t},\n\t\t\twantNs:  \"1.23E-4\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"leading zeros\",\n\t\t\targs: args{\n\t\t\t\ts: \"000123\",\n\t\t\t},\n\t\t\twantNs:  \"000123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"trailing zeros\",\n\t\t\targs: args{\n\t\t\t\ts: \"123.000\",\n\t\t\t},\n\t\t\twantNs:  \"123.000\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"leading zero with decimal\",\n\t\t\targs: args{\n\t\t\t\ts: \"0.123\",\n\t\t\t},\n\t\t\twantNs:  \"0.123\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"inf\",\n\t\t\t},\n\t\t\twantNs:  \"inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\ts: \"Inf\",\n\t\t\t},\n\t\t\twantNs:  \"Inf\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"inF\",\n\t\t\targs: args{\n\t\t\t\ts: \"inF\",\n\t\t\t},\n\t\t\twantNs:  \"inF\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"nan\",\n\t\t\t},\n\t\t\twantNs:  \"nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Nan\",\n\t\t\targs: args{\n\t\t\t\ts: \"Nan\",\n\t\t\t},\n\t\t\twantNs:  \"Nan\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nAn\",\n\t\t\targs: args{\n\t\t\t\ts: \"nAn\",\n\t\t\t},\n\t\t\twantNs:  \"nAn\",\n\t\t\twantS:   \"\",\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number\",\n\t\t\targs: args{\n\t\t\t\ts: \"123a\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"123a\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number 2\",\n\t\t\targs: args{\n\t\t\t\ts: \"123-\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"123-\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number 3\",\n\t\t\targs: args{\n\t\t\t\ts: \"123+\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"123+\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number 4\",\n\t\t\targs: args{\n\t\t\t\ts: \"123e\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"123e\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid number 5\",\n\t\t\targs: args{\n\t\t\t\ts: \"123E\",\n\t\t\t},\n\t\t\twantNs:  \"\",\n\t\t\twantS:   \"123E\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotNs, gotS, err := parseRawNumber(tt.args.s)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gotNs != tt.wantNs {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotNs = %v, want %v\", gotNs, tt.wantNs)\n\t\t\t}\n\t\t\tif gotS != tt.wantS {\n\t\t\t\tt.Errorf(\"parseRawNumber() gotS = %v, want %v\", gotS, tt.wantS)\n\t\t\t}\n\t\t})\n\t}\n}"}